import { Component, Input, NgModule, Injectable, NgZone, RendererFactory2, Directive, ElementRef, EventEmitter, Output, ChangeDetectionStrategy, ContentChild, TemplateRef, HostBinding, ViewChild, forwardRef, QueryList, ContentChildren, Optional, Renderer2, ViewEncapsulation, Pipe, Host, ChangeDetectorRef, ViewContainerRef, HostListener, Attribute, ViewChildren, SkipSelf, Inject, ComponentFactoryResolver, Injector } from '@angular/core';
import { CommonModule, DOCUMENT as DOCUMENT$1 } from '@angular/common';
import { RouterModule, ActivatedRoute, NavigationEnd, Router } from '@angular/router';
import { BehaviorSubject } from 'rxjs/BehaviorSubject';
import { fromEvent } from 'rxjs/observable/fromEvent';
import { Subscription } from 'rxjs/Subscription';
import { debounceTime, filter, map, distinctUntilChanged, takeUntil, delay, first, switchMap, auditTime, combineLatest as combineLatest$1 } from 'rxjs/operators';
import { __read, __extends, __spread, __assign, __values } from 'tslib';
import { NG_VALUE_ACCESSOR, FormsModule, NG_VALIDATORS, NgModel } from '@angular/forms';
import { Subject } from 'rxjs/Subject';
import { combineLatest } from 'rxjs/observable/combineLatest';
import { Observable } from 'rxjs/Observable';
import { from } from 'rxjs/observable/from';
import { of } from 'rxjs/observable/of';
import { Overlay, ScrollDispatcher, OverlayModule } from '@angular/cdk/overlay';
import { ComponentPortal } from '@angular/cdk/portal';
import { ObserversModule } from '@angular/cdk/observers';
import * as dragulaNamespace from 'dragula';
import dragulaNamespace__default, {  } from 'dragula';
import { TypeaheadModule } from 'ngx-bootstrap/typeahead';
import { BsDropdownDirective, BsDropdownModule } from 'ngx-bootstrap/dropdown';
import { animate, query, stagger, style, transition, trigger, state } from '@angular/animations';
import { TooltipDirective } from 'ngx-bootstrap/tooltip';
import { ESCAPE } from '@angular/cdk/keycodes';
import { Http, ResponseContentType, HttpModule } from '@angular/http';
import { concat } from 'rxjs/observable/concat';
import { timer } from 'rxjs/observable/timer';
import { map as map$1 } from 'rxjs/operators/map';
import { DOCUMENT } from '@angular/platform-browser';
import { delay as delay$1 } from 'rxjs/operators/delay';
import { Subject as Subject$1 } from 'rxjs';
import { UpgradeComponent } from '@angular/upgrade/static';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var BreadcrumbsComponent = (function () {
    function BreadcrumbsComponent() {
    }
    /**
     * @param {?} event
     * @param {?} crumb
     * @return {?}
     */
    BreadcrumbsComponent.prototype.clickCrumb = /**
     * @param {?} event
     * @param {?} crumb
     * @return {?}
     */
    function (event, crumb) {
        if (crumb.onClick) {
            crumb.onClick.call(null, event);
        }
    };
    BreadcrumbsComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-breadcrumbs',
                    template: "<nav aria-label=\"Breadcrumb\">\n    <ol class=\"breadcrumb\">\n        <li *ngFor=\"let crumb of crumbs\">\n\n            <!-- If there is a router link then use a tag -->\n            <a *ngIf=\"crumb.routerLink || crumb.onClick\"\n                tabindex=\"0\"\n                [routerLink]=\"crumb.routerLink\"\n                [fragment]=\"crumb.fragment\"\n                [queryParams]=\"crumb.queryParams\"\n                (click)=\"clickCrumb($event, crumb)\">\n                {{ crumb.title }}\n            </a>\n\n            <!-- If there is not router link then display text in a span -->\n            <span *ngIf=\"!crumb.routerLink && !crumb.onClick\">{{ crumb.title }}</span>\n        </li>\n    </ol>\n</nav>"
                },] },
    ];
    /** @nocollapse */
    BreadcrumbsComponent.ctorParameters = function () { return []; };
    BreadcrumbsComponent.propDecorators = {
        "crumbs": [{ type: Input },],
    };
    return BreadcrumbsComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var BreadcrumbsModule = (function () {
    function BreadcrumbsModule() {
    }
    BreadcrumbsModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        RouterModule
                    ],
                    exports: [BreadcrumbsComponent],
                    declarations: [BreadcrumbsComponent]
                },] },
    ];
    /** @nocollapse */
    BreadcrumbsModule.ctorParameters = function () { return []; };
    return BreadcrumbsModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ResizeService = (function () {
    function ResizeService(rendererFactory, _ngZone) {
        this._ngZone = _ngZone;
        this._subscription = new Subscription();
        this._renderer = rendererFactory.createRenderer(null, null);
    }
    /**
     * @return {?}
     */
    ResizeService.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._subscription.unsubscribe();
    };
    /**
     * @param {?} nativeElement
     * @return {?}
     */
    ResizeService.prototype.addResizeListener = /**
     * @param {?} nativeElement
     * @return {?}
     */
    function (nativeElement) {
        var _this = this;
        // create a behavior subject subject
        var /** @type {?} */ subject = new BehaviorSubject({ width: nativeElement.offsetWidth, height: nativeElement.offsetHeight });
        // determine the style of the element
        var /** @type {?} */ displayMode = window.getComputedStyle(nativeElement).getPropertyValue('display');
        // create the iframe element
        var /** @type {?} */ iframe = this._renderer.createElement('iframe');
        // style the iframe to be invisible but fill containing element
        this._renderer.setStyle(iframe, 'position', 'absolute');
        this._renderer.setStyle(iframe, 'width', '100%');
        this._renderer.setStyle(iframe, 'height', '100%');
        this._renderer.setStyle(iframe, 'top', '0');
        this._renderer.setStyle(iframe, 'right', '0');
        this._renderer.setStyle(iframe, 'bottom', '0');
        this._renderer.setStyle(iframe, 'left', '0');
        this._renderer.setStyle(iframe, 'z-index', '-1');
        this._renderer.setStyle(iframe, 'opacity', '0');
        this._renderer.setStyle(iframe, 'border', 'none');
        this._renderer.setStyle(iframe, 'margin', '0');
        this._renderer.setStyle(iframe, 'pointer-events', 'none');
        this._renderer.setStyle(iframe, 'overflow', 'hidden');
        // ensure the iframe ignores any tabbing
        this._renderer.setAttribute(iframe, 'tabindex', '-1');
        this._renderer.setAttribute(iframe, 'aria-hidden', 'true');
        // statically positioned elements need changed to relative for this method to work
        if (displayMode !== 'relative' && displayMode !== 'absolute' && displayMode !== 'fixed') {
            this._renderer.setStyle(nativeElement, 'position', 'relative');
        }
        // add the iframe to the container element
        this._renderer.appendChild(nativeElement, iframe);
        this.waitUntilReady(iframe, function () {
            var /** @type {?} */ iframeDoc = iframe.contentDocument || /** @type {?} */ (iframe.contentWindow.document);
            var /** @type {?} */ attachListener = function () {
                // watch for any future resizes - run inside ngzone as an iframe event listener is not patched
                // watch for any future resizes - run inside ngzone as an iframe event listener is not patched
                _this._subscription.add(fromEvent(iframe.contentWindow, 'resize').subscribe(function (event) {
                    return _this._ngZone.run(function () { return subject.next({ width: nativeElement.offsetWidth, height: nativeElement.offsetHeight }); });
                }));
            };
            if (iframeDoc.readyState === 'complete') {
                attachListener();
            }
            else {
                // wait for iframe to load
                iframe.addEventListener('load', function () { return attachListener(); });
            }
        });
        return subject;
    };
    /**
     * @param {?} iframe
     * @param {?} callback
     * @return {?}
     */
    ResizeService.prototype.waitUntilReady = /**
     * @param {?} iframe
     * @param {?} callback
     * @return {?}
     */
    function (iframe, callback) {
        var _this = this;
        if (iframe.contentDocument || iframe.contentWindow) {
            callback.call(this);
        }
        else {
            setTimeout(function () { return _this.waitUntilReady(iframe, callback); });
        }
    };
    ResizeService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    ResizeService.ctorParameters = function () { return [
        { type: RendererFactory2, },
        { type: NgZone, },
    ]; };
    return ResizeService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ResizeDirective = (function () {
    function ResizeDirective(_elementRef, _resizeService, _ngZone) {
        this._elementRef = _elementRef;
        this._resizeService = _resizeService;
        this._ngZone = _ngZone;
        this.throttle = 0;
        this.uxResize = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ResizeDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this._subscription = this._resizeService.addResizeListener(this._elementRef.nativeElement)
            .pipe(debounceTime(this.throttle))
            .subscribe(function (event) { return _this._ngZone.run(function () { return _this.uxResize.emit(event); }); });
    };
    /**
     * @return {?}
     */
    ResizeDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._subscription.unsubscribe();
    };
    ResizeDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[uxResize]',
                    providers: [ResizeService]
                },] },
    ];
    /** @nocollapse */
    ResizeDirective.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: ResizeService, },
        { type: NgZone, },
    ]; };
    ResizeDirective.propDecorators = {
        "throttle": [{ type: Input },],
        "uxResize": [{ type: Output },],
    };
    return ResizeDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ResizeModule = (function () {
    function ResizeModule() {
    }
    ResizeModule.decorators = [
        { type: NgModule, args: [{
                    exports: [ResizeDirective],
                    declarations: [ResizeDirective],
                    providers: [ResizeService]
                },] },
    ];
    /** @nocollapse */
    ResizeModule.ctorParameters = function () { return []; };
    return ResizeModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var CardTabContentDirective = (function () {
    function CardTabContentDirective() {
    }
    CardTabContentDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[uxCardTabContent]'
                },] },
    ];
    /** @nocollapse */
    CardTabContentDirective.ctorParameters = function () { return []; };
    return CardTabContentDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var CardTabsService = (function () {
    function CardTabsService() {
        var _this = this;
        this.tab$ = new BehaviorSubject(null);
        this.tabs$ = new BehaviorSubject([]);
        this.position$ = new BehaviorSubject('top');
        // when a tab is added or removed ensure we always select one if any are available
        this._subscription = this.tabs$.pipe(filter(function (tabs) { return !_this.tab$.value || !tabs.find(function (tab) { return tab === _this.tab$.value; }); })).subscribe(function (tabs) { return _this.tab$.next(tabs.length > 0 ? tabs[0] : null); });
    }
    /**
     * @return {?}
     */
    CardTabsService.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._subscription.unsubscribe();
    };
    /**
     * Add a tab to the list of tabs
     */
    /**
     * Add a tab to the list of tabs
     * @param {?} tab
     * @return {?}
     */
    CardTabsService.prototype.addTab = /**
     * Add a tab to the list of tabs
     * @param {?} tab
     * @return {?}
     */
    function (tab) {
        this.tabs$.next(__spread(this.tabs$.value, [tab]));
    };
    /**
     * Remove a tab from the list
     */
    /**
     * Remove a tab from the list
     * @param {?} tab
     * @return {?}
     */
    CardTabsService.prototype.removeTab = /**
     * Remove a tab from the list
     * @param {?} tab
     * @return {?}
     */
    function (tab) {
        this.tabs$.next(this.tabs$.value.filter(function (_tab) { return _tab !== tab; }));
    };
    /**
     * Select the tab
     */
    /**
     * Select the tab
     * @param {?} tab
     * @return {?}
     */
    CardTabsService.prototype.select = /**
     * Select the tab
     * @param {?} tab
     * @return {?}
     */
    function (tab) {
        this.tab$.next(tab);
    };
    /**
     * Set the position of the tab content
     */
    /**
     * Set the position of the tab content
     * @param {?} position
     * @return {?}
     */
    CardTabsService.prototype.setPosition = /**
     * Set the position of the tab content
     * @param {?} position
     * @return {?}
     */
    function (position) {
        this.position$.next(position);
    };
    CardTabsService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    CardTabsService.ctorParameters = function () { return []; };
    return CardTabsService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var CardTabComponent = (function () {
    function CardTabComponent(_tabService) {
        var _this = this;
        this._tabService = _tabService;
        this.active$ = this._tabService.tab$.pipe(map(function (tab) { return tab === _this; }));
        this._tabService.addTab(this);
    }
    /**
     * @return {?}
     */
    CardTabComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._tabService.removeTab(this);
    };
    CardTabComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-card-tab',
                    template: "<ng-content *ngIf=\"active$ | async\"></ng-content>",
                    changeDetection: ChangeDetectionStrategy.OnPush
                },] },
    ];
    /** @nocollapse */
    CardTabComponent.ctorParameters = function () { return [
        { type: CardTabsService, },
    ]; };
    CardTabComponent.propDecorators = {
        "content": [{ type: ContentChild, args: [CardTabContentDirective, { read: TemplateRef },] },],
    };
    return CardTabComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var CardTabsetComponent = (function () {
    function CardTabsetComponent(tabService) {
        this.tabService = tabService;
        this.offset = 0;
        this.bounds = { lower: 0, upper: 0 };
    }
    Object.defineProperty(CardTabsetComponent.prototype, "position", {
        get: /**
         * @return {?}
         */
        function () {
            return this.tabService.position$.getValue();
        },
        set: /**
         * @param {?} direction
         * @return {?}
         */
        function (direction) {
            this.tabService.setPosition(direction);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} tab
     * @param {?} element
     * @return {?}
     */
    CardTabsetComponent.prototype.select = /**
     * @param {?} tab
     * @param {?} element
     * @return {?}
     */
    function (tab, element) {
        // select the tab
        this.tabService.select(tab);
        // ensure the tab is moved into view if required
        this.moveIntoView(element);
    };
    /**
     * @param {?} dimensions
     * @return {?}
     */
    CardTabsetComponent.prototype.resize = /**
     * @param {?} dimensions
     * @return {?}
     */
    function (dimensions) {
        this._width = dimensions.width;
        this._innerWidth = this.tablist.nativeElement.scrollWidth;
        this.bounds.lower = 0;
        this.bounds.upper = -(this._innerWidth - this._width);
    };
    /**
     * @return {?}
     */
    CardTabsetComponent.prototype.previous = /**
     * @return {?}
     */
    function () {
        this.offset += this._width;
        // ensure it remains within the allowed bounds
        this.offset = Math.min(this.offset, this.bounds.lower);
    };
    /**
     * @return {?}
     */
    CardTabsetComponent.prototype.next = /**
     * @return {?}
     */
    function () {
        this.offset -= this._width;
        // ensure it remains within the allowed bounds
        this.offset = Math.max(this.offset, this.bounds.upper);
    };
    /**
     * @param {?} element
     * @return {?}
     */
    CardTabsetComponent.prototype.moveIntoView = /**
     * @param {?} element
     * @return {?}
     */
    function (element) {
        // if we dont have the dimensions we cant check
        if (!this._width || !this._innerWidth) {
            return;
        }
        // get the current element bounds
        var offsetLeft = element.offsetLeft, offsetWidth = element.offsetWidth;
        var _a = getComputedStyle(element), marginLeft = _a.marginLeft, marginRight = _a.marginRight;
        // calculate the visible area
        var /** @type {?} */ viewportStart = Math.abs(this.offset);
        var /** @type {?} */ viewportEnd = viewportStart + this._width;
        var /** @type {?} */ cardWidth = parseFloat(marginLeft) + offsetWidth + parseFloat(marginRight);
        // if we need to move to the left - figure out how much
        if (offsetLeft < viewportStart) {
            this.offset -= (offsetLeft - parseFloat(marginLeft)) - viewportStart;
        }
        // if we need to move to the right - figure out how much
        if ((offsetLeft + cardWidth) > viewportEnd) {
            this.offset -= (offsetLeft + cardWidth) - viewportEnd;
        }
    };
    CardTabsetComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-card-tabset',
                    template: "<div class=\"card-tab-content\" role=\"tabpanel\" *ngIf=\"(tabService.tab$ | async)\">\n    <ng-content></ng-content>\n</div>\n\n<div class=\"card-tabs\" #tabs>\n\n    <button class=\"card-tabs-paging-btn card-tabs-paging-btn-previous\" aria-label=\"Previous Tabs\" (click)=\"previous()\" *ngIf=\"offset < bounds.lower\">\n        <i class=\"hpe-icon hpe-previous\"></i>\n    </button>\n\n    <div class=\"card-tabs-list\" role=\"tablist\" #tablist (uxResize)=\"resize($event)\" [style.transform]=\"'translateX(' + offset + 'px)'\">\n\n        <div class=\"card-tab\"\n            role=\"tab\"\n            tabindex=\"0\" #card\n            *ngFor=\"let tab of tabService.tabs$ | async\"\n            [ngClass]=\"tabService.position$ | async\"\n            [class.active]=\"tab.active$ | async\"\n            [attr.aria-selected]=\"tab.active$ | async\"\n            (click)=\"select(tab, card)\"\n            (focus)=\"tabs.scrollLeft = 0\"\n            (keydown.enter)=\"select(tab, card)\">\n\n            <ng-container [ngTemplateOutlet]=\"tab.content\"></ng-container>\n        </div>\n\n    </div>\n\n    <button class=\"card-tabs-paging-btn card-tabs-paging-btn-next\" aria-label=\"Next Tabs\" (click)=\"next()\" *ngIf=\"offset > bounds.upper\">\n        <i class=\"hpe-icon hpe-next\"></i>\n    </button>\n</div>",
                    providers: [CardTabsService]
                },] },
    ];
    /** @nocollapse */
    CardTabsetComponent.ctorParameters = function () { return [
        { type: CardTabsService, },
    ]; };
    CardTabsetComponent.propDecorators = {
        "position": [{ type: HostBinding, args: ['class',] }, { type: Input },],
        "tablist": [{ type: ViewChild, args: ['tablist',] },],
    };
    return CardTabsetComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var CardTabsModule = (function () {
    function CardTabsModule() {
    }
    CardTabsModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        ResizeModule
                    ],
                    declarations: [CardTabsetComponent, CardTabComponent, CardTabContentDirective],
                    exports: [CardTabsetComponent, CardTabComponent, CardTabContentDirective]
                },] },
    ];
    /** @nocollapse */
    CardTabsModule.ctorParameters = function () { return []; };
    return CardTabsModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var /** @type {?} */ CHECKBOX_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(function () { return CheckboxComponent; }),
    multi: true
};
var /** @type {?} */ uniqueCheckboxId = 0;
var CheckboxComponent = (function () {
    function CheckboxComponent() {
        this._checkboxId = "ux-checkbox-" + ++uniqueCheckboxId;
        this.id = this._checkboxId;
        this.tabindex = 0;
        this.clickable = true;
        this.simplified = false;
        this.indeterminateValue = -1;
        this.disabled = false;
        this.ariaLabel = '';
        this.ariaLabelledby = null;
        this.valueChange = new EventEmitter();
        this._value = false;
        this.indeterminate = false;
        this.focused = false;
        this.onTouchedCallback = function () { };
        this.onChangeCallback = function () { };
    }
    Object.defineProperty(CheckboxComponent.prototype, "value", {
        get: /**
         * @return {?}
         */
        function () {
            return this._value;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._value = value;
            // determine if it is in the indeterminate state
            this.indeterminate = this._value === this.indeterminateValue;
            // determine the checked state
            this.ariaChecked = this.indeterminate ? 'mixed' : this._value;
            // invoke change event
            this.valueChange.emit(this._value);
            // call callback
            this.onChangeCallback(this._value);
            this.onTouchedCallback();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CheckboxComponent.prototype, "inputId", {
        get: /**
         * @return {?}
         */
        function () {
            return (this.id || this._checkboxId) + "-input";
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    CheckboxComponent.prototype.toggle = /**
     * @return {?}
     */
    function () {
        if (this.disabled || !this.clickable) {
            return;
        }
        if (this.value === this.indeterminateValue) {
            this.value = true;
            return;
        }
        // toggle the checked state
        this.value = !this.value;
    };
    // Functions required to update ngModel
    /**
     * @param {?} value
     * @return {?}
     */
    CheckboxComponent.prototype.writeValue = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (value !== this._value) {
            this._value = value;
        }
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    CheckboxComponent.prototype.registerOnChange = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onChangeCallback = fn;
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    CheckboxComponent.prototype.registerOnTouched = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onTouchedCallback = fn;
    };
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    CheckboxComponent.prototype.setDisabledState = /**
     * @param {?} isDisabled
     * @return {?}
     */
    function (isDisabled) {
        this.disabled = isDisabled;
    };
    CheckboxComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-checkbox',
                    template: "<label [attr.for]=\"inputId\"\n       class=\"ux-checkbox\"\n       [class.ux-checkbox-checked]=\"value === true\"\n       [class.ux-checkbox-indeterminate]=\"indeterminate\"\n       [class.ux-checkbox-simplified]=\"simplified\"\n       [class.ux-checkbox-disabled]=\"disabled\"\n       [class.ux-checkbox-focused]=\"focused\">\n\n    <div class=\"ux-checkbox-container\">\n        <input type=\"checkbox\"\n               class=\"ux-checkbox-input\"\n               [id]=\"inputId\"\n               [required]=\"required\"\n               [checked]=\"value\"\n               [attr.value]=\"value\"\n               [disabled]=\"disabled\"\n               [attr.name]=\"name\"\n               [tabindex]=\"tabindex\"\n               [indeterminate]=\"indeterminate\"\n               [attr.aria-label]=\"ariaLabel\"\n               [attr.aria-labelledby]=\"ariaLabelledby\"\n               [attr.aria-checked]=\"ariaChecked\"\n               (focus)=\"focused = true\"\n               (blur)=\"focused = false\"\n               (change)=\"$event.stopPropagation()\"\n               (click)=\"toggle()\">\n    </div>\n\n    <span class=\"ux-checkbox-label\">\n        <ng-content></ng-content>\n    </span>\n</label>\n",
                    providers: [CHECKBOX_VALUE_ACCESSOR]
                },] },
    ];
    /** @nocollapse */
    CheckboxComponent.ctorParameters = function () { return []; };
    CheckboxComponent.propDecorators = {
        "id": [{ type: Input },],
        "name": [{ type: Input },],
        "required": [{ type: Input },],
        "tabindex": [{ type: Input },],
        "clickable": [{ type: Input },],
        "simplified": [{ type: Input },],
        "indeterminateValue": [{ type: Input },],
        "disabled": [{ type: Input },],
        "ariaLabel": [{ type: Input, args: ['aria-label',] },],
        "ariaLabelledby": [{ type: Input, args: ['aria-labelledby',] },],
        "valueChange": [{ type: Output },],
        "value": [{ type: Input },],
    };
    return CheckboxComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var CheckboxModule = (function () {
    function CheckboxModule() {
    }
    CheckboxModule.decorators = [
        { type: NgModule, args: [{
                    imports: [FormsModule],
                    exports: [CheckboxComponent],
                    declarations: [CheckboxComponent]
                },] },
    ];
    /** @nocollapse */
    CheckboxModule.ctorParameters = function () { return []; };
    return CheckboxModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ColumnSortingComponent = (function () {
    function ColumnSortingComponent() {
        this.stateChange = new EventEmitter();
        this.columnSortingState = ColumnSortingState;
    }
    /**
     * @param {?} parent
     * @return {?}
     */
    ColumnSortingComponent.prototype.initParent = /**
     * @param {?} parent
     * @return {?}
     */
    function (parent) {
        var _this = this;
        this._parent = parent;
        // watch for any events
        this._parent.events.subscribe(function (event) {
            var /** @type {?} */ idx = event.findIndex(function (column) { return column.key === _this.key; });
            if (idx == -1) {
                _this.state = ColumnSortingState.NoSort;
            }
            // only store the number if we have 2 or more columns being sorted
            if (event.length > 1) {
                _this.orderNumber = idx === -1 ? null : idx + 1;
            }
            else {
                _this.orderNumber = null;
            }
            _this.stateChange.emit(_this.state);
        });
    };
    /**
     * @return {?}
     */
    ColumnSortingComponent.prototype.changeState = /**
     * @return {?}
     */
    function () {
        if (this.state === ColumnSortingState.Ascending) {
            this.state = ColumnSortingState.Descending;
        }
        else if (this.state === ColumnSortingState.Descending) {
            this.state = ColumnSortingState.NoSort;
        }
        else {
            this.state = ColumnSortingState.Ascending;
        }
        // inform parent
        return this._parent.toggleColumn(this.key, this.state);
    };
    ColumnSortingComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-column-sorting',
                    template: "<div class=\"ux-column-sorting\">\n    <i class=\"ux-column-sorting-icon hpe-icon\" \n        [class.hpe-ascend]=\"state === columnSortingState.Ascending\" \n        [class.hpe-descend]=\"state === columnSortingState.Descending\" \n        [class.column-sorting-icon-hidden]=\"state === columnSortingState.NoSort\"></i>\n    <p class=\"ux-column-sorting-number\">{{ orderNumber }}</p>\n</div>",
                    exportAs: 'ux-column-sorting'
                },] },
    ];
    /** @nocollapse */
    ColumnSortingComponent.ctorParameters = function () { return []; };
    ColumnSortingComponent.propDecorators = {
        "state": [{ type: Input },],
        "key": [{ type: Input },],
        "orderNumber": [{ type: Input },],
        "stateChange": [{ type: Output },],
    };
    return ColumnSortingComponent;
}());
/** @enum {number} */
var ColumnSortingState = {
    Ascending: 0,
    Descending: 1,
    NoSort: 2,
};
ColumnSortingState[ColumnSortingState.Ascending] = "Ascending";
ColumnSortingState[ColumnSortingState.Descending] = "Descending";
ColumnSortingState[ColumnSortingState.NoSort] = "NoSort";

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ColumnSortingDirective = (function () {
    function ColumnSortingDirective() {
        this.events = new Subject();
        this.order = [];
    }
    /**
     * @return {?}
     */
    ColumnSortingDirective.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.components.forEach(function (component) { return component.initParent(_this); });
    };
    /**
     * @param {?} key
     * @param {?} state
     * @return {?}
     */
    ColumnSortingDirective.prototype.toggleColumn = /**
     * @param {?} key
     * @param {?} state
     * @return {?}
     */
    function (key, state$$1) {
        if (this.singleSort) {
            if (state$$1 === ColumnSortingState.NoSort) {
                this.order = [];
            }
            else {
                this.order = [{ key: key, state: state$$1 }];
            }
        }
        else {
            // reorder columns here
            var /** @type {?} */ idx = this.order.findIndex(function (column) { return column.key === key; });
            // if wasnt previously selected add to list
            if (idx === -1) {
                this.order.push({ key: key, state: state$$1 });
            }
            else if (state$$1 === ColumnSortingState.Ascending || state$$1 === ColumnSortingState.Descending) {
                this.order.splice(idx, 1);
                this.order.push({ key: key, state: state$$1 });
            }
            else {
                this.order.splice(idx, 1);
            }
        }
        this.events.next(this.order);
        // return the order
        return this.order;
    };
    ColumnSortingDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[uxColumnSorting]'
                },] },
    ];
    /** @nocollapse */
    ColumnSortingDirective.ctorParameters = function () { return []; };
    ColumnSortingDirective.propDecorators = {
        "singleSort": [{ type: Input },],
        "components": [{ type: ContentChildren, args: [ColumnSortingComponent,] },],
    };
    return ColumnSortingDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ColumnSortingModule = (function () {
    function ColumnSortingModule() {
    }
    ColumnSortingModule.decorators = [
        { type: NgModule, args: [{
                    exports: [ColumnSortingComponent, ColumnSortingDirective],
                    declarations: [ColumnSortingComponent, ColumnSortingDirective]
                },] },
    ];
    /** @nocollapse */
    ColumnSortingModule.ctorParameters = function () { return []; };
    return ColumnSortingModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ConduitSubject = (function () {
    function ConduitSubject(conduit, _zone, zoneId) {
        this.conduit = conduit;
        this._zone = _zone;
        this.zoneId = zoneId;
        this._onDestroy = new Subject();
        // store the target subject object
        this._subject = conduit.subject;
        // check if there are any conduits that have supplied an initial value
        this.getInitialValue();
        // subscribe to changes to the source subject
        this._subject.pipe(distinctUntilChanged(conduit.changeDetection), takeUntil(this._onDestroy))
            .subscribe(this.onOutput.bind(this));
        // subscribe to the zone events and root zone events
        _zone.getEvents().pipe(filter(function (event) { return event.conduit.id === conduit.id; }), takeUntil(this._onDestroy)).subscribe(this.onInput.bind(this));
    }
    /** Check all allow inputs to see if there is a value we should initially set the conduit to */
    /**
     * Check all allow inputs to see if there is a value we should initially set the conduit to
     * @return {?}
     */
    ConduitSubject.prototype.getInitialValue = /**
     * Check all allow inputs to see if there is a value we should initially set the conduit to
     * @return {?}
     */
    function () {
        var _this = this;
        // if we do not accept inputs then do nothing
        if (this.conduit.acceptsInput === false) {
            return;
        }
        // return all subjects that are 1) Not itself 2) In a zone that is listed in acceptsInput 3) Have a currentValue set
        var /** @type {?} */ subjects = this._zone.getSubjects().filter(function (subject) {
            // If this is itself or if it has not value to give us then do nothing
            if (subject === _this || subject.conduit.id !== _this.conduit.id || !subject.conduit.hasOwnProperty('currentValue')) {
                return false;
            }
            // if acceptsInput is true then we return every time
            if (_this.conduit.acceptsInput === true) {
                return true;
            }
            if (Array.isArray(_this.conduit.acceptsInput)) {
                return _this.conduit.acceptsInput.indexOf(subject.zoneId) !== -1;
            }
        });
        // if there are no matches then do nothing
        if (subjects.length === 0) {
            return;
        }
        // otherwise sort by the last modified field
        subjects.sort(function (subjectOne, subjectTwo) { return subjectOne.conduit.lastModified.getTime() < subjectTwo.conduit.lastModified.getTime() ? 1 : -1; });
        // get the most recent value
        this._subject.next(subjects[0].conduit.currentValue);
    };
    /** This will be triggered when a conduits value has changed */
    /**
     * This will be triggered when a conduits value has changed
     * @param {?} event
     * @return {?}
     */
    ConduitSubject.prototype.onInput = /**
     * This will be triggered when a conduits value has changed
     * @param {?} event
     * @return {?}
     */
    function (event) {
        // if we dont accept input or we emitted this value then do nothing
        if (this.conduit.acceptsInput === false || event.conduit === this.conduit) {
            return;
        }
        // check if the conduit produces output - if not we only do something if we are in the same zone
        if (event.conduit.producesOutput === false && event.zoneId !== this.zoneId) {
            return;
        }
        // check if we only accept inputs from specific zones
        if (Array.isArray(this.conduit.acceptsInput)) {
            // check if the event came from an acceptable zone
            if (!this.conduit.acceptsInput.find(function (zone) { return zone === event.zoneId; })) {
                return;
            }
        }
        // if required transform the value
        var /** @type {?} */ outputValue = this.conduit.map ? this.conduit.map(event.value) : event.value;
        // update the subject
        this._subject.next(outputValue);
    };
    /** This will be fired when this conduit emits a new value */
    /**
     * This will be fired when this conduit emits a new value
     * @param {?} value
     * @return {?}
     */
    ConduitSubject.prototype.onOutput = /**
     * This will be fired when this conduit emits a new value
     * @param {?} value
     * @return {?}
     */
    function (value) {
        // store the most recent value and when it was modified - can be used for any new conduits to lookup a value
        this.conduit.currentValue = value;
        this.conduit.lastModified = new Date();
        // check if this should produce output
        if (this.conduit.producesOutput) {
            this._zone.emit({ conduit: this.conduit, zoneId: this.zoneId, value: value });
        }
    };
    /** Unsubscribe once this subject is destroyed */
    /**
     * Unsubscribe once this subject is destroyed
     * @return {?}
     */
    ConduitSubject.prototype.destroy = /**
     * Unsubscribe once this subject is destroyed
     * @return {?}
     */
    function () {
        this._onDestroy.next();
        this._onDestroy.complete();
    };
    return ConduitSubject;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * This utility is to ensure a all functions with the specified name are called in all super classes
 * @param {?} target
 * @param {?} functionName
 * @return {?}
 */
function invokeSuperFunction(target, functionName) {
    // get all instances of the function
    var /** @type {?} */ functionList = [];
    // store the current prototype we are checking
    var /** @type {?} */ prototype = target;
    // look through every base class and check it
    do {
        if (prototype.hasOwnProperty(functionName)) {
            functionList.push(prototype[functionName]);
        }
        prototype = prototype.__proto__;
    } while (prototype.__proto__);
    // augment the top level function to call all the functions
    target[functionName] = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        functionList.forEach(function (func) { return func.call.apply(func, __spread([target], args)); });
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ConduitZone = (function () {
    function ConduitZone() {
    }
    /**
     * @return {?}
     */
    ConduitZone.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // find all conduit subjects that are part of this zone
        ConduitZone.subjects.filter(function (_subject) { return _subject.zoneId === _this._zoneId; })
            .forEach(function (_subject) { return _this.unregisterConduit(_subject.conduit); });
    };
    /** Store reference to the repository and begin watching for and emitting changes */
    /**
     * Store reference to the repository and begin watching for and emitting changes
     * @param {?} conduit
     * @return {?}
     */
    ConduitZone.prototype.registerConduit = /**
     * Store reference to the repository and begin watching for and emitting changes
     * @param {?} conduit
     * @return {?}
     */
    function (conduit) {
        ConduitZone.subjects.push(new ConduitSubject(conduit, this, this._zoneId));
    };
    /** Destroy a conduit */
    /**
     * Destroy a conduit
     * @param {?} conduit
     * @return {?}
     */
    ConduitZone.prototype.unregisterConduit = /**
     * Destroy a conduit
     * @param {?} conduit
     * @return {?}
     */
    function (conduit) {
        var /** @type {?} */ subject = this.getConduitSubject(conduit.subject);
        if (subject) {
            // remove the subject from the internal list of conduit subjects
            ConduitZone.subjects = ConduitZone.subjects.filter(function (_subject) { return _subject !== subject; });
            // perform all unsubscriptions
            subject.destroy();
        }
    };
    /** Provide the zone with an ID */
    /**
     * Provide the zone with an ID
     * @param {?} zoneId
     * @return {?}
     */
    ConduitZone.prototype.setZoneId = /**
     * Provide the zone with an ID
     * @param {?} zoneId
     * @return {?}
     */
    function (zoneId) {
        this._zoneId = zoneId;
    };
    /** Emit a value to all zones for checking */
    /**
     * Emit a value to all zones for checking
     * @param {?} event
     * @return {?}
     */
    ConduitZone.prototype.emit = /**
     * Emit a value to all zones for checking
     * @param {?} event
     * @return {?}
     */
    function (event) {
        ConduitZone.events.next(event);
    };
    /** Retrieve a conduit subsject object from the rxjs subject */
    /**
     * Retrieve a conduit subsject object from the rxjs subject
     * @param {?} subject
     * @return {?}
     */
    ConduitZone.prototype.getConduitSubject = /**
     * Retrieve a conduit subsject object from the rxjs subject
     * @param {?} subject
     * @return {?}
     */
    function (subject) {
        return ConduitZone.subjects.find(function (_subject) { return _subject.conduit.subject === subject; });
    };
    /** Get all subjects from all zones */
    /**
     * Get all subjects from all zones
     * @return {?}
     */
    ConduitZone.prototype.getSubjects = /**
     * Get all subjects from all zones
     * @return {?}
     */
    function () {
        return ConduitZone.subjects;
    };
    /** Alter the properties of a conduit dynamically */
    /**
     * Alter the properties of a conduit dynamically
     * @param {?} subject
     * @param {?} properties
     * @return {?}
     */
    ConduitZone.prototype.setConduitProperties = /**
     * Alter the properties of a conduit dynamically
     * @param {?} subject
     * @param {?} properties
     * @return {?}
     */
    function (subject, properties) {
        // find the conduit with the matching subject
        var /** @type {?} */ conduitSubject = this.getSubjects().find(function (_conduit) { return _conduit.conduit.subject === subject; });
        // if a match was found update the properties
        if (conduitSubject) {
            // update each specified property
            for (var /** @type {?} */ prop in properties) {
                conduitSubject.conduit[prop] = properties[prop];
            }
        }
    };
    /** Programmatically create a conduit at runtime */
    /**
     * Programmatically create a conduit at runtime
     * @param {?} subject
     * @param {?} properties
     * @return {?}
     */
    ConduitZone.prototype.createConduit = /**
     * Programmatically create a conduit at runtime
     * @param {?} subject
     * @param {?} properties
     * @return {?}
     */
    function (subject, properties) {
        // register the conduit with the zone
        this.registerConduit(__assign({}, properties, { subject: subject }));
    };
    /** Register all conduits in a component */
    /**
     * Register all conduits in a component
     * @param {?} component
     * @return {?}
     */
    ConduitZone.prototype.registerConduits = /**
     * Register all conduits in a component
     * @param {?} component
     * @return {?}
     */
    function (component) {
        var _this = this;
        if (Array.isArray(component._conduits)) {
            component._conduits.forEach(function (conduit) { return _this.registerConduit(__assign({}, conduit, { subject: component[conduit.propertyKey] })); });
        }
    };
    /** Register all conduits in a component */
    /**
     * Register all conduits in a component
     * @param {?} component
     * @return {?}
     */
    ConduitZone.prototype.unregisterConduits = /**
     * Register all conduits in a component
     * @param {?} component
     * @return {?}
     */
    function (component) {
        var _this = this;
        if (Array.isArray(component._conduits)) {
            component._conduits.forEach(function (conduit) { return _this.unregisterConduit(conduit); });
        }
    };
    /** Return the global event stream */
    /**
     * Return the global event stream
     * @return {?}
     */
    ConduitZone.prototype.getEvents = /**
     * Return the global event stream
     * @return {?}
     */
    function () {
        return ConduitZone.events;
    };
    /**
     * Create a global subject store
     */
    ConduitZone.subjects = [];
    /**
     * Expose an event stream of new values
     */
    ConduitZone.events = new Subject();
    ConduitZone.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    ConduitZone.ctorParameters = function () { return []; };
    return ConduitZone;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ConduitComponent = (function () {
    function ConduitComponent(_zone) {
        this._zone = _zone;
        // we want to ensure these functions get called even if a class overrides them
        invokeSuperFunction(this, 'ngOnInit');
        invokeSuperFunction(this, 'ngOnDestroy');
    }
    /** We need to register the conduits with the zone when the component is initialised */
    /**
     * We need to register the conduits with the zone when the component is initialised
     * @return {?}
     */
    ConduitComponent.prototype.ngOnInit = /**
     * We need to register the conduits with the zone when the component is initialised
     * @return {?}
     */
    function () {
        // register the conduit in the zone and ensure it gets the correct instance of the target
        this._zone.registerConduits(this);
    };
    /** We need to unregister the conduits when the component is destroyed */
    /**
     * We need to unregister the conduits when the component is destroyed
     * @return {?}
     */
    ConduitComponent.prototype.ngOnDestroy = /**
     * We need to unregister the conduits when the component is destroyed
     * @return {?}
     */
    function () {
        this._zone.unregisterConduits(this);
    };
    /** Alter the properties of a conduit dynamically */
    /**
     * Alter the properties of a conduit dynamically
     * @param {?} subject
     * @param {?} properties
     * @return {?}
     */
    ConduitComponent.prototype.setConduitProperties = /**
     * Alter the properties of a conduit dynamically
     * @param {?} subject
     * @param {?} properties
     * @return {?}
     */
    function (subject, properties) {
        this._zone.setConduitProperties(subject, properties);
    };
    /** Programmatically create a conduit at runtime */
    /**
     * Programmatically create a conduit at runtime
     * @param {?} subject
     * @param {?} properties
     * @return {?}
     */
    ConduitComponent.prototype.createConduit = /**
     * Programmatically create a conduit at runtime
     * @param {?} subject
     * @param {?} properties
     * @return {?}
     */
    function (subject, properties) {
        this._zone.createConduit(subject, properties);
    };
    /** @nocollapse */
    ConduitComponent.ctorParameters = function () { return [
        { type: ConduitZone, decorators: [{ type: Optional },] },
    ]; };
    return ConduitComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @abstract
 */
var  /**
 * @abstract
 */
ConduitZoneComponent = (function (_super) {
    __extends(ConduitZoneComponent, _super);
    function ConduitZoneComponent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @return {?}
     */
    ConduitZoneComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this._zone.setZoneId(this.zoneId);
    };
    return ConduitZoneComponent;
}(ConduitComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var /** @type {?} */ defaultConduitProps = {
    acceptsInput: true,
    producesOutput: true,
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Expose the property that conduits will be stored in
 */
var /** @type {?} */ CONDUITS = '_conduits';
/**
 * Create the conduit property decorator
 * @param {?} properties
 * @return {?}
 */
function Conduit(properties) {
    return function (target, propertyKey) {
        if (typeof properties === 'function') {
            properties = properties.call(null);
        }
        // if the target does not already have a conduit list then create one
        if (!target.hasOwnProperty(CONDUITS)) {
            Object.defineProperty(target, CONDUITS, { value: [] });
        }
        // add the conduit to the list ensuring all required properties are provided
        target[CONDUITS].push(/** @type {?} */ (__assign({}, defaultConduitProps, properties, { target: target, propertyKey: propertyKey })));
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var DashboardService = (function () {
    function DashboardService() {
        var _this = this;
        this._rowHeight = 0;
        this.widgets$ = new BehaviorSubject([]);
        this.options$ = new BehaviorSubject(defaultOptions);
        this.dimensions$ = new BehaviorSubject({});
        this.height$ = this.dimensions$.pipe(delay(0), map(function (dimensions) { return dimensions.height; }), distinctUntilChanged());
        this.placeholder$ = new BehaviorSubject({ visible: false, x: 0, y: 0, width: 0, height: 0 });
        this.layout$ = new Subject();
        this.stacked$ = new BehaviorSubject(false);
        this.layout$.subscribe(this.setLayoutData.bind(this));
        this.stacked$.pipe(filter(function (stacked) { return stacked === true; })).subscribe(this.updateWhenStacked.bind(this));
        this.widgets$.pipe(delay(0)).subscribe(function () { return _this.renderDashboard(); });
        this.dimensions$.pipe(delay(0)).subscribe(function () { return _this.renderDashboard(); });
    }
    Object.defineProperty(DashboardService.prototype, "options", {
        get: /**
         * @return {?}
         */
        function () {
            return this.options$.getValue();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DashboardService.prototype, "widgets", {
        get: /**
         * @return {?}
         */
        function () {
            return this.widgets$.getValue();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DashboardService.prototype, "stacked", {
        get: /**
         * @return {?}
         */
        function () {
            return this.stacked$.getValue();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DashboardService.prototype, "dimensions", {
        get: /**
         * @return {?}
         */
        function () {
            return this.dimensions$.getValue();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DashboardService.prototype, "columnWidth", {
        get: /**
         * @return {?}
         */
        function () {
            return this.dimensions.width / this.options.columns;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Add a widget to the dashboard
     * @param widget The widget component to add to the dashboard
     */
    /**
     * Add a widget to the dashboard
     * @param {?} widget The widget component to add to the dashboard
     * @return {?}
     */
    DashboardService.prototype.addWidget = /**
     * Add a widget to the dashboard
     * @param {?} widget The widget component to add to the dashboard
     * @return {?}
     */
    function (widget) {
        this.widgets$.next(__spread(this.widgets$.getValue(), [widget]));
    };
    /**
     * Remove a widget from the dashboard
     * @param widget The widget to remove
     */
    /**
     * Remove a widget from the dashboard
     * @param {?} widget The widget to remove
     * @return {?}
     */
    DashboardService.prototype.removeWidget = /**
     * Remove a widget from the dashboard
     * @param {?} widget The widget to remove
     * @return {?}
     */
    function (widget) {
        this.widgets$.next(this.widgets$.getValue().filter(function (_widget) { return _widget !== widget; }));
    };
    /**
     * Indicate that the dashboard element has been resized
     * @param width The width of the dashboard element in px
     * @param height The height of the dashboard element in px
     */
    /**
     * Indicate that the dashboard element has been resized
     * @param {?=} width The width of the dashboard element in px
     * @param {?=} height The height of the dashboard element in px
     * @return {?}
     */
    DashboardService.prototype.setDimensions = /**
     * Indicate that the dashboard element has been resized
     * @param {?=} width The width of the dashboard element in px
     * @param {?=} height The height of the dashboard element in px
     * @return {?}
     */
    function (width, height) {
        if (width === void 0) { width = this.dimensions.width; }
        if (height === void 0) { height = this.dimensions.height; }
        if (this.dimensions.width !== width || this.dimensions.height !== height) {
            this.dimensions$.next({ width: width, height: height });
        }
    };
    /**
     * Produce an object containing all the required layout data.
     * This can be useful for exporting/saving a layout
     */
    /**
     * Produce an object containing all the required layout data.
     * This can be useful for exporting/saving a layout
     * @return {?}
     */
    DashboardService.prototype.getLayoutData = /**
     * Produce an object containing all the required layout data.
     * This can be useful for exporting/saving a layout
     * @return {?}
     */
    function () {
        return this.widgets.map(function (widget) {
            return { id: widget.id, col: widget.getColumn(), row: widget.getRow(), colSpan: widget.getColumnSpan(), rowSpan: widget.getRowSpan() };
        });
    };
    /**
     * Position widgets programatically
     */
    /**
     * Position widgets programatically
     * @param {?} widgets
     * @return {?}
     */
    DashboardService.prototype.setLayoutData = /**
     * Position widgets programatically
     * @param {?} widgets
     * @return {?}
     */
    function (widgets) {
        var _this = this;
        // iterate through each widget data and find a match
        widgets.forEach(function (widget) {
            // find the matching widget
            var /** @type {?} */ target = _this.widgets.find(function (_widget) { return _widget.id === widget.id; });
            if (target) {
                target.setColumn(widget.col);
                target.setRow(widget.row);
                target.setColumnSpan(widget.colSpan);
                target.setRowSpan(widget.rowSpan);
            }
        });
    };
    /**
     * Update the positions and sizes of the widgets
     */
    /**
     * Update the positions and sizes of the widgets
     * @return {?}
     */
    DashboardService.prototype.renderDashboard = /**
     * Update the positions and sizes of the widgets
     * @return {?}
     */
    function () {
        var _this = this;
        // get the dimensions of the dashboard
        this._rowHeight = this.options.rowHeight || this.columnWidth;
        // ensure the column width is not below the min widths
        this.stacked$.next(this.columnWidth < this.options.minWidth);
        // ensure the row height is not below the min widths
        if (this._rowHeight < this.options.minWidth) {
            this._rowHeight = this.options.minWidth;
        }
        this.setDashboardLayout();
        // iterate through each widget and set the size - except the one being resized
        this.widgets.filter(function (widget) { return !_this._actionWidget || widget !== _this._actionWidget.widget; })
            .forEach(function (widget) { return widget.render(); });
    };
    /**
     * Determine where widgets should be positioned based on their positions, width and the size of the container
     */
    /**
     * Determine where widgets should be positioned based on their positions, width and the size of the container
     * @return {?}
     */
    DashboardService.prototype.setDashboardLayout = /**
     * Determine where widgets should be positioned based on their positions, width and the size of the container
     * @return {?}
     */
    function () {
        var _this = this;
        // find any widgets that do not currently have a position set
        this.widgets.filter(function (widget) { return widget.getColumn() === undefined || widget.getRow() === undefined; })
            .forEach(function (widget) { return _this.setWidgetPosition(widget); });
        this.setDashboardHeight();
    };
    /**
     * @return {?}
     */
    DashboardService.prototype.updateWhenStacked = /**
     * @return {?}
     */
    function () {
        // iterate through each widget set it's stacked state and
        this.getWidgetsByOrder().forEach(function (widget, idx) {
            widget.setColumn(0);
            widget.setRow(idx);
        });
    };
    /**
     * @return {?}
     */
    DashboardService.prototype.getWidgetsByOrder = /**
     * @return {?}
     */
    function () {
        return this.widgets.sort(function (w1, w2) {
            var /** @type {?} */ w1Position = w1.getColumn() * w1.getRow();
            var /** @type {?} */ w2Position = w2.getColumn() * w2.getRow();
            if (w1Position < w2Position) {
                return -1;
            }
            if (w1Position > w2Position) {
                return 1;
            }
            return 0;
        });
    };
    /**
     * Find a position that a widget can fit in the dashboard
     * @param widget The widget to try and position
     */
    /**
     * Find a position that a widget can fit in the dashboard
     * @param {?} widget The widget to try and position
     * @return {?}
     */
    DashboardService.prototype.setWidgetPosition = /**
     * Find a position that a widget can fit in the dashboard
     * @param {?} widget The widget to try and position
     * @return {?}
     */
    function (widget) {
        // find a position for the widget
        var /** @type {?} */ position = 0;
        var /** @type {?} */ success = false;
        // repeat until a space is found
        while (!success) {
            // get a position to try
            var /** @type {?} */ column = position % this.options.columns;
            var /** @type {?} */ row = Math.floor(position / this.options.columns);
            // check the current position
            if (this.getPositionAvailable(column, row, widget.getColumnSpan(), widget.getRowSpan())) {
                success = true;
                widget.setColumn(column);
                widget.setRow(row);
                return;
            }
            if (column === 0 && widget.colSpan > this.options.columns) {
                throw new Error('Dashboard widgets have a colSpan greater than the max number of dashboard columns!');
            }
            position++;
        }
    };
    /**
     * Check if a position in the dashboard is vacant or not
     */
    /**
     * Check if a position in the dashboard is vacant or not
     * @param {?} column
     * @param {?} row
     * @param {?} columnSpan
     * @param {?} rowSpan
     * @param {?=} ignoreWidget
     * @return {?}
     */
    DashboardService.prototype.getPositionAvailable = /**
     * Check if a position in the dashboard is vacant or not
     * @param {?} column
     * @param {?} row
     * @param {?} columnSpan
     * @param {?} rowSpan
     * @param {?=} ignoreWidget
     * @return {?}
     */
    function (column, row, columnSpan, rowSpan, ignoreWidget) {
        // get a list of grid spaces that are populated
        var /** @type {?} */ spaces = this.getOccupiedSpaces();
        // check if the block would still be in bounds
        if (column + columnSpan > this.options.columns) {
            return false;
        }
        var _loop_1 = function (x) {
            var _loop_2 = function (y) {
                if (spaces.find(function (block) { return block.column === x && block.row === y && block.widget !== ignoreWidget; })) {
                    return { value: false };
                }
            };
            for (var /** @type {?} */ y = row; y < row + rowSpan; y++) {
                var state_1 = _loop_2(y);
                if (typeof state_1 === "object")
                    return state_1;
            }
        };
        // check each required position
        for (var /** @type {?} */ x = column; x < column + columnSpan; x++) {
            var state_2 = _loop_1(x);
            if (typeof state_2 === "object")
                return state_2.value;
        }
        return true;
    };
    /**
     * @return {?}
     */
    DashboardService.prototype.getOccupiedSpaces = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // find all spaces that are currently occupied
        return this.widgets.filter(function (widget) { return widget.getColumn() !== undefined && widget.getRow() !== undefined; })
            .reduce(function (value, widget) {
            _this.forEachBlock(widget, function (column, row) { return value.push({ widget: widget, column: column, row: row }); });
            return value;
        }, []);
    };
    /**
     * Begin resizing a widget
     * @param action The the widget to resize
     */
    /**
     * Begin resizing a widget
     * @param {?} action The the widget to resize
     * @return {?}
     */
    DashboardService.prototype.onResizeStart = /**
     * Begin resizing a widget
     * @param {?} action The the widget to resize
     * @return {?}
     */
    function (action) {
        // store the mouse event
        this._mouseEvent = action.event;
        this._actionWidget = action;
        // bring the widget to the font
        this.bringToFront(action.widget);
    };
    /**
     * @param {?} action
     * @return {?}
     */
    DashboardService.prototype.onResizeDrag = /**
     * @param {?} action
     * @return {?}
     */
    function (action) {
        var /** @type {?} */ mousePosX = this._mouseEvent.pageX - pageXOffset;
        var /** @type {?} */ mousePosY = this._mouseEvent.pageY - pageYOffset;
        // if there was no movement then do nothing
        if (action.event.x === mousePosX && action.event.y === mousePosY) {
            return;
        }
        // update the stored mouse event
        this._mouseEvent = action.event;
        // get handle for direction
        var handle = action.handle;
        // get the bounds of the handle
        var /** @type {?} */ bounds = handle.getBoundingClientRect();
        // get the center of the handle
        var /** @type {?} */ centerX = bounds.left + (bounds.width / 2);
        var /** @type {?} */ centerY = bounds.top + (bounds.height / 2);
        // get the current mouse position
        var /** @type {?} */ mouseX = mousePosX - centerX;
        var /** @type {?} */ mouseY = mousePosY - centerY;
        // store the new proposed dimensions for the widget
        var /** @type {?} */ dimensions = {
            x: action.widget.x,
            y: action.widget.y,
            width: action.widget.width,
            height: action.widget.height
        };
        // update widget based on the handle being dragged
        switch (action.direction) {
            case ActionDirection.Right:
                dimensions.width += mouseX;
                break;
            case ActionDirection.Left:
                dimensions.x += mouseX;
                dimensions.width -= mouseX;
                if (dimensions.width < this.options.minWidth) {
                    var /** @type {?} */ difference = this.options.minWidth - dimensions.width;
                    dimensions.x -= difference;
                    dimensions.width += difference;
                }
                break;
            case ActionDirection.Bottom:
                dimensions.height += mouseY;
                break;
            case ActionDirection.Top:
                dimensions.y += mouseY;
                dimensions.height -= mouseY;
                if (dimensions.height < this.options.minHeight) {
                    var /** @type {?} */ difference = this.options.minHeight - dimensions.height;
                    dimensions.y -= difference;
                    dimensions.height += difference;
                }
                break;
            // Support resizing on multiple axis simultaneously
            case ActionDirection.TopLeft:
                dimensions.x += mouseX;
                dimensions.width -= mouseX;
                if (dimensions.width < this.options.minWidth) {
                    var /** @type {?} */ difference = this.options.minWidth - dimensions.width;
                    dimensions.x -= difference;
                    dimensions.width += difference;
                }
                dimensions.y += mouseY;
                dimensions.height -= mouseY;
                if (dimensions.height < this.options.minHeight) {
                    var /** @type {?} */ difference = this.options.minHeight - dimensions.height;
                    dimensions.y -= difference;
                    dimensions.height += difference;
                }
                break;
            case ActionDirection.TopRight:
                dimensions.width += mouseX;
                dimensions.y += mouseY;
                dimensions.height -= mouseY;
                if (dimensions.height < this.options.minHeight) {
                    var /** @type {?} */ difference = this.options.minHeight - dimensions.height;
                    dimensions.y -= difference;
                    dimensions.height += difference;
                }
                break;
            case ActionDirection.BottomLeft:
                dimensions.height += mouseY;
                dimensions.x += mouseX;
                dimensions.width -= mouseX;
                if (dimensions.width < this.options.minWidth) {
                    var /** @type {?} */ difference = this.options.minWidth - dimensions.width;
                    dimensions.x -= difference;
                    dimensions.width += difference;
                }
                break;
            case ActionDirection.BottomRight:
                dimensions.height += mouseY;
                dimensions.width += mouseX;
                break;
        }
        var /** @type {?} */ currentWidth = action.widget.x + action.widget.width;
        var /** @type {?} */ currentHeight = action.widget.y + action.widget.height;
        // ensure values are within the dashboard bounds
        if (dimensions.x < 0) {
            dimensions.x = 0;
            dimensions.width = currentWidth;
        }
        if (dimensions.y < 0) {
            dimensions.y = 0;
            dimensions.height = currentHeight;
        }
        if ((dimensions.x + dimensions.width) > this.dimensions.width) {
            dimensions.width = this.dimensions.width - dimensions.x;
        }
        // if the proposed width is smaller than allowed then reset width to minimum and ignore x changes
        if (dimensions.width < this.options.minWidth) {
            dimensions.x = action.widget.x;
            dimensions.width = this.options.minWidth;
        }
        // if the proposed height is smaller than allowed then reset height to minimum and ignore y changes
        if (dimensions.height < this.options.minHeight) {
            dimensions.y = action.widget.y;
            dimensions.height = this.options.minHeight;
        }
        // update the widget actual values
        action.widget.setBounds(dimensions.x, dimensions.y, dimensions.width, dimensions.height);
        // update placeholder position and value
        this.setPlaceholderBounds(true, dimensions.x, dimensions.y, dimensions.width, dimensions.height);
        // show the widget positions if the current positions and sizes were to persist
        this.updateWidgetPositions(action.widget);
    };
    /**
     * @return {?}
     */
    DashboardService.prototype.onResizeEnd = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ placeholder = this.placeholder$.getValue();
        // commit resize changes
        this.commitWidgetChanges();
        // hide placeholder
        placeholder.visible = false;
        // update the placeholder
        this.placeholder$.next(placeholder);
        this._actionWidget = null;
        this._mouseEvent = null;
        // ensure any vacant upper spaces are filled where required
        this.shiftWidgetsUp();
        // update dashboard height
        this.setDashboardHeight();
        // emit information about the layout
        this.layout$.next(this.getLayoutData());
    };
    /**
     * @param {?} action
     * @return {?}
     */
    DashboardService.prototype.onDragStart = /**
     * @param {?} action
     * @return {?}
     */
    function (action) {
        this.onResizeStart(action);
        // store the starting placeholder position
        this.setWidgetOrigin();
        this.cacheWidgets();
    };
    /**
     * @return {?}
     */
    DashboardService.prototype.onDragEnd = /**
     * @return {?}
     */
    function () {
        this.onResizeEnd();
        this._widgetOrigin = {};
    };
    /**
     * @param {?} action
     * @return {?}
     */
    DashboardService.prototype.onDrag = /**
     * @param {?} action
     * @return {?}
     */
    function (action) {
        // if there was no movement then do nothing
        if (action.event.pageX === this._mouseEvent.pageX && action.event.pageY === this._mouseEvent.pageY) {
            return;
        }
        // get the current mouse position
        var /** @type {?} */ mouseX = action.event.pageX - this._mouseEvent.pageX;
        var /** @type {?} */ mouseY = action.event.pageY - this._mouseEvent.pageY;
        // store the latest event
        this._mouseEvent = action.event;
        var /** @type {?} */ dimensions = {
            x: action.widget.x + mouseX,
            y: action.widget.y + mouseY,
            width: action.widget.width,
            height: action.widget.height
        };
        this.restoreWidgets(true);
        // update widget position
        action.widget.setBounds(dimensions.x, dimensions.y, dimensions.width, dimensions.height);
        // update placeholder position and value
        this.setPlaceholderBounds(true, dimensions.x, dimensions.y, dimensions.width, dimensions.height);
        // show the widget positions if the current positions and sizes were to persist
        this.shiftWidgets();
        this.setDashboardHeight();
    };
    /**
     * @return {?}
     */
    DashboardService.prototype.getRowHeight = /**
     * @return {?}
     */
    function () {
        return this._rowHeight;
    };
    /**
     * @return {?}
     */
    DashboardService.prototype.cacheWidgets = /**
     * @return {?}
     */
    function () {
        this._cache = this.widgets.map(function (widget) { return ({ id: widget.id, column: widget.getColumn(), row: widget.getRow() }); });
    };
    /**
     * @param {?=} ignoreActionWidget
     * @return {?}
     */
    DashboardService.prototype.restoreWidgets = /**
     * @param {?=} ignoreActionWidget
     * @return {?}
     */
    function (ignoreActionWidget) {
        var _this = this;
        if (ignoreActionWidget === void 0) { ignoreActionWidget = false; }
        this._cache.filter(function (widget) { return !ignoreActionWidget || widget.id !== _this._actionWidget.widget.id; }).forEach(function (widget) {
            var /** @type {?} */ match = _this.widgets.find(function (wgt) { return wgt.id === widget.id; });
            if (match) {
                match.setColumn(widget.column);
                match.setRow(widget.row);
            }
        });
    };
    /**
     * When dragging any widgets that need to be moved should be moved to an appropriate position
     */
    /**
     * When dragging any widgets that need to be moved should be moved to an appropriate position
     * @return {?}
     */
    DashboardService.prototype.shiftWidgets = /**
     * When dragging any widgets that need to be moved should be moved to an appropriate position
     * @return {?}
     */
    function () {
        var _this = this;
        var /** @type {?} */ widgetsToMove = [];
        var /** @type {?} */ placeholder = this.placeholder$.getValue();
        var _loop_3 = function (row) {
            var _loop_4 = function (column) {
                // store reference to any widgets that need moved
                this_1.getOccupiedSpaces()
                    .filter(function (space) { return space.column === column && space.row === row && space.widget !== _this._actionWidget.widget; })
                    .forEach(function (space) { return widgetsToMove.push(space.widget); });
            };
            for (var /** @type {?} */ column = placeholder.column; column < placeholder.column + placeholder.columnSpan; column++) {
                _loop_4(column);
            }
        };
        var this_1 = this;
        // check if there are any widgets under the placeholder
        for (var /** @type {?} */ row = placeholder.row; row < placeholder.row + placeholder.rowSpan; row++) {
            _loop_3(row);
        }
        // remove any duplicates
        widgetsToMove = widgetsToMove.filter(function (widget, idx, array) { return array.indexOf(widget) === idx; });
        // if no widgets need moved then we can stop here
        if (widgetsToMove.length === 0) {
            return;
        }
        // create a duplicate we can use to keep track of which have been moved
        var /** @type {?} */ unmovedWidgets = widgetsToMove.slice();
        // attempt to move any widgets to the previous widget position
        widgetsToMove.forEach(function (widget) {
            // get a grid off all occupied spaces - taking into account the placeholder and ignoring widgets that need moved
            var /** @type {?} */ grid = _this.getOccupiedSpaces().filter(function (space) { return !unmovedWidgets.find(function (wgt) { return wgt === space.widget; }); });
            // iterate each free block
            for (var /** @type {?} */ row = _this._widgetOrigin.row; row < _this._widgetOrigin.row + _this._widgetOrigin.rowSpan; row++) {
                for (var /** @type {?} */ column = _this._widgetOrigin.column; column < _this._widgetOrigin.column + _this._widgetOrigin.columnSpan; column++) {
                    // determine if the block can fit in this space
                    var /** @type {?} */ requiredSpaces = _this.getRequiredSpacesFromPoint(widget, column, row);
                    // check if widget would fit in space
                    var /** @type {?} */ available = requiredSpaces.every(function (space) {
                        return !grid.find(function (gridSpace) { return gridSpace.column === space.column && gridSpace.row === space.row; }) && space.column < _this.getColumnCount();
                    });
                    if (available) {
                        widget.setColumn(column);
                        widget.setRow(row);
                        unmovedWidgets.splice(unmovedWidgets.findIndex(function (wgt) { return wgt === widget; }), 1);
                        return;
                    }
                }
            }
            // if we get to here then we can't simply swap the positions - next try moving right
            if (_this.canWidgetMoveRight(widget, true)) {
                // after the shift check if placeholder position is still valid
                // after the shift check if placeholder position is still valid
                _this.validatePlaceholderPosition(ActionDirection.Right);
                return;
            }
            // next try moving left
            if (_this.canWidgetMoveLeft(widget, true)) {
                // after the shift check if placeholder position is still valid
                // after the shift check if placeholder position is still valid
                _this.validatePlaceholderPosition(ActionDirection.Left);
                return;
            }
            // determine the distance that the widget needs to be moved down
            var /** @type {?} */ distance = (_this._actionWidget.widget.getRow() - widget.getRow()) + _this._actionWidget.widget.getRowSpan();
            // as a last resort move the widget downwards
            // as a last resort move the widget downwards
            _this.moveWidgetDown(widget, distance);
        });
    };
    /**
     * After shifts have taken place we should verify the place holder position is still valid
     * @param shiftDirection - the position widgets were shifted
     */
    /**
     * After shifts have taken place we should verify the place holder position is still valid
     * @param {?} shiftDirection - the position widgets were shifted
     * @return {?}
     */
    DashboardService.prototype.validatePlaceholderPosition = /**
     * After shifts have taken place we should verify the place holder position is still valid
     * @param {?} shiftDirection - the position widgets were shifted
     * @return {?}
     */
    function (shiftDirection) {
        var /** @type {?} */ placeholder = this.placeholder$.getValue();
        // check if the placeholder is over a widget
        if (this.getWidgetsAtPosition(placeholder.column, placeholder.row, true).length > 0) {
            // move the placeholder the opposite direction
            switch (shiftDirection) {
                case ActionDirection.Left:
                    this.setPlaceholderBounds(placeholder.visible, placeholder.x + this.getColumnWidth(), placeholder.y, placeholder.width, placeholder.height);
                    break;
                case ActionDirection.Right:
                    this.setPlaceholderBounds(placeholder.visible, placeholder.x - this.getColumnWidth(), placeholder.y, placeholder.width, placeholder.height);
                    break;
            }
            // validate this new position again
            this.validatePlaceholderPosition(shiftDirection);
        }
    };
    /**
     * Determine if a widget can be moved left - or if it can move the widgets to the right to make space for the widget
     */
    /**
     * Determine if a widget can be moved left - or if it can move the widgets to the right to make space for the widget
     * @param {?} widget
     * @param {?=} performMove
     * @return {?}
     */
    DashboardService.prototype.canWidgetMoveLeft = /**
     * Determine if a widget can be moved left - or if it can move the widgets to the right to make space for the widget
     * @param {?} widget
     * @param {?=} performMove
     * @return {?}
     */
    function (widget, performMove) {
        var _this = this;
        if (performMove === void 0) { performMove = false; }
        // check if the widget is the action widget or occupies the first column
        if (widget === this._actionWidget.widget || widget.getColumn() === 0) {
            return false;
        }
        // find the positions required
        var /** @type {?} */ targetSpaces = this.getOccupiedSpaces().filter(function (space) { return space.widget === widget; }).map(function (space) {
            return { column: space.column - widget.getColumnSpan(), row: space.row, widget: space.widget };
        });
        // check if there are widget in the required positions and if so, can they move right?
        var /** @type {?} */ moveable = targetSpaces.every(function (space) { return _this.getWidgetsAtPosition(space.column, space.row).filter(function (wgt) { return wgt !== space.widget; }).every(function (wgt) { return _this.canWidgetMoveLeft(wgt); }); });
        if (performMove && moveable) {
            // move all widgets to the right
            targetSpaces.forEach(function (space) { return _this.getWidgetsAtPosition(space.column, space.row).filter(function (wgt) { return wgt !== space.widget; }).forEach(function (wgt) { return _this.canWidgetMoveLeft(wgt, true); }); });
            // move current widget to the right
            widget.setColumn(widget.getColumn() - 1);
        }
        return moveable;
    };
    /**
     * Determine if a widget can be moved right - or if it can move the widgets to the right to make space for the widget
     */
    /**
     * Determine if a widget can be moved right - or if it can move the widgets to the right to make space for the widget
     * @param {?} widget
     * @param {?=} performMove
     * @return {?}
     */
    DashboardService.prototype.canWidgetMoveRight = /**
     * Determine if a widget can be moved right - or if it can move the widgets to the right to make space for the widget
     * @param {?} widget
     * @param {?=} performMove
     * @return {?}
     */
    function (widget, performMove) {
        var _this = this;
        if (performMove === void 0) { performMove = false; }
        // check if the widget is the dragging widget or the widget occupies the final column
        if (widget === this._actionWidget.widget || widget.getColumn() + widget.getColumnSpan() === this.options.columns) {
            return false;
        }
        // find the positions required
        var /** @type {?} */ targetSpaces = this.getOccupiedSpaces().filter(function (space) { return space.widget === widget; }).map(function (space) {
            return { column: space.column + widget.getColumnSpan(), row: space.row, widget: space.widget };
        });
        // check if there are widget in the required positions and if so, can they move right?
        var /** @type {?} */ moveable = targetSpaces.every(function (space) { return _this.getWidgetsAtPosition(space.column, space.row).filter(function (wgt) { return wgt !== space.widget; }).every(function (wgt) { return _this.canWidgetMoveRight(wgt); }); });
        if (performMove && moveable) {
            // move all widgets to the right
            targetSpaces.forEach(function (space) { return _this.getWidgetsAtPosition(space.column, space.row).filter(function (wgt) { return wgt !== space.widget; }).forEach(function (wgt) { return _this.canWidgetMoveRight(wgt, true); }); });
            // move current widget to the right
            widget.setColumn(widget.getColumn() + 1);
        }
        return moveable;
    };
    /**
     * Store the initial position of the widget being dragged
     */
    /**
     * Store the initial position of the widget being dragged
     * @return {?}
     */
    DashboardService.prototype.setWidgetOrigin = /**
     * Store the initial position of the widget being dragged
     * @return {?}
     */
    function () {
        this._widgetOrigin = {
            column: this._actionWidget.widget.getColumn(),
            row: this._actionWidget.widget.getRow(),
            columnSpan: this._actionWidget.widget.getColumnSpan(),
            rowSpan: this._actionWidget.widget.getRowSpan()
        };
    };
    /**
     * Calculate all the required positions is a widget was to be positioned at a particular point
     */
    /**
     * Calculate all the required positions is a widget was to be positioned at a particular point
     * @param {?} widget
     * @param {?} column
     * @param {?} row
     * @return {?}
     */
    DashboardService.prototype.getRequiredSpacesFromPoint = /**
     * Calculate all the required positions is a widget was to be positioned at a particular point
     * @param {?} widget
     * @param {?} column
     * @param {?} row
     * @return {?}
     */
    function (widget, column, row) {
        var /** @type {?} */ spaces = [];
        for (var /** @type {?} */ y = row; y < row + widget.getRowSpan(); y++) {
            for (var /** @type {?} */ x = column; x < column + widget.getColumnSpan(); x++) {
                spaces.push({ column: x, row: y, widget: widget });
            }
        }
        return spaces;
    };
    /**
     * Position widgets based on the position of the placeholder - this is temporary until confirmed
     */
    /**
     * Position widgets based on the position of the placeholder - this is temporary until confirmed
     * @param {?} widget
     * @return {?}
     */
    DashboardService.prototype.updateWidgetPositions = /**
     * Position widgets based on the position of the placeholder - this is temporary until confirmed
     * @param {?} widget
     * @return {?}
     */
    function (widget) {
        var _this = this;
        var /** @type {?} */ placeholder = this.placeholder$.getValue();
        // check all spaces the placeholder will occupy and move any widget currently in them down
        for (var /** @type {?} */ column = placeholder.column; column < placeholder.column + placeholder.columnSpan; column++) {
            for (var /** @type {?} */ row = placeholder.row; row < placeholder.row + placeholder.rowSpan; row++) {
                this.getWidgetsAtPosition(column, row, true)
                    .filter(function (wgt) { return wgt !== widget; })
                    .forEach(function (wgt) { return _this.moveWidgetDown(wgt); });
            }
        }
        // update the height of the dashboard
        this.setDashboardHeight();
        // if we arent dragging the top handle then fill spaces
        if (this._actionWidget.direction !== ActionDirection.Top &&
            this._actionWidget.direction !== ActionDirection.TopLeft &&
            this._actionWidget.direction !== ActionDirection.TopRight) {
            this.shiftWidgetsUp();
        }
    };
    /**
     * Determine if a widget is occupying a specific row and column
     * @param column The columns to check if occupied
     * @param row The row to check if occupied
     * @param ignoreResizing Whether or not to ignore the widget currently being resized
     */
    /**
     * Determine if a widget is occupying a specific row and column
     * @param {?} column The columns to check if occupied
     * @param {?} row The row to check if occupied
     * @param {?=} ignoreResizing Whether or not to ignore the widget currently being resized
     * @return {?}
     */
    DashboardService.prototype.getWidgetsAtPosition = /**
     * Determine if a widget is occupying a specific row and column
     * @param {?} column The columns to check if occupied
     * @param {?} row The row to check if occupied
     * @param {?=} ignoreResizing Whether or not to ignore the widget currently being resized
     * @return {?}
     */
    function (column, row, ignoreResizing) {
        var _this = this;
        if (ignoreResizing === void 0) { ignoreResizing = false; }
        return this.getOccupiedSpaces()
            .filter(function (space) { return space.column === column && space.row === row; })
            .filter(function (space) { return space.widget !== _this._actionWidget.widget || !ignoreResizing; })
            .map(function (space) { return space.widget; });
    };
    /**
     * Update the placeholder visibility, position and size
     */
    /**
     * Update the placeholder visibility, position and size
     * @param {?} visible
     * @param {?} x
     * @param {?} y
     * @param {?} width
     * @param {?} height
     * @return {?}
     */
    DashboardService.prototype.setPlaceholderBounds = /**
     * Update the placeholder visibility, position and size
     * @param {?} visible
     * @param {?} x
     * @param {?} y
     * @param {?} width
     * @param {?} height
     * @return {?}
     */
    function (visible, x, y, width, height) {
        var _this = this;
        var /** @type {?} */ placeholder = this.placeholder$.getValue();
        var /** @type {?} */ rounding = this._actionWidget.direction === ActionDirection.Left ||
            this._actionWidget.direction === ActionDirection.Top ? Rounding.RoundDownBelowHalf : Rounding.RoundUpOverHalf;
        placeholder.visible = visible;
        placeholder.column = this.getPlaceholderColumn(x, width);
        placeholder.row = this.getPlaceholderRow(y, height);
        placeholder.columnSpan = this.getPlaceholderColumnSpan(width);
        placeholder.rowSpan = this.getPlaceholderRowSpan(height);
        // calculate the maximum number of rows
        var /** @type {?} */ rowCount = this.widgets.filter(function (widget) { return widget !== _this._actionWidget.widget; })
            .reduce(function (previous, widget) { return Math.max(widget.getRow() + widget.getRowSpan(), previous); }, 0);
        // constrain maximum placeholder row
        placeholder.row = Math.min(placeholder.row, rowCount);
        placeholder.x = (placeholder.column * this.getColumnWidth()) + this.options.padding;
        placeholder.y = (placeholder.row * this._rowHeight) + this.options.padding;
        placeholder.width = (placeholder.columnSpan * this.getColumnWidth()) - (this.options.padding * 2);
        placeholder.height = (placeholder.rowSpan * this._rowHeight) - (this.options.padding * 2);
        // set the values of the widget to match the values of the placeholder - however do not render the changes
        this._actionWidget.widget.setColumn(placeholder.column, false);
        this._actionWidget.widget.setRow(placeholder.row, false);
        this._actionWidget.widget.setColumnSpan(placeholder.columnSpan, false);
        this._actionWidget.widget.setRowSpan(placeholder.rowSpan, false);
        // update the placeholder
        this.placeholder$.next(placeholder);
    };
    /**
     * Get the placeholder column position
     */
    /**
     * Get the placeholder column position
     * @param {?} x
     * @param {?} width
     * @return {?}
     */
    DashboardService.prototype.getPlaceholderColumn = /**
     * Get the placeholder column position
     * @param {?} x
     * @param {?} width
     * @return {?}
     */
    function (x, width) {
        var /** @type {?} */ column = this.getColumnFromPx(x, this._actionWidget.direction === ActionDirection.Move ? Rounding.RoundUpOverHalf : Rounding.RoundDown);
        var /** @type {?} */ columnSpan = Math.floor(width / this.getColumnWidth());
        var /** @type {?} */ upperLimit = this.getColumnCount() - columnSpan;
        // if we arent dragging left then just return the column
        if (this._actionWidget.direction !== ActionDirection.Left &&
            this._actionWidget.direction !== ActionDirection.TopLeft &&
            this._actionWidget.direction !== ActionDirection.BottomLeft) {
            return Math.max(Math.min(column, upperLimit), 0);
        }
        // get any overflow
        var /** @type {?} */ overflow = width % this.getColumnWidth();
        return (x <= 0 || overflow === 0 || columnSpan === 0 || overflow > (this.getColumnWidth() / 2)) ?
            Math.max(Math.min(column, upperLimit), 0) :
            Math.max(Math.min(column + 1, upperLimit), 0);
    };
    /**
     * Get the column span of the placeholder
     */
    /**
     * Get the column span of the placeholder
     * @param {?} width
     * @return {?}
     */
    DashboardService.prototype.getPlaceholderColumnSpan = /**
     * Get the column span of the placeholder
     * @param {?} width
     * @return {?}
     */
    function (width) {
        var /** @type {?} */ columnSpan = this.getColumnFromPx(width);
        // if we arent dragging right or left then just return the column span
        if (this._actionWidget.direction !== ActionDirection.Right &&
            this._actionWidget.direction !== ActionDirection.TopRight &&
            this._actionWidget.direction !== ActionDirection.BottomRight &&
            this._actionWidget.direction !== ActionDirection.Left &&
            this._actionWidget.direction !== ActionDirection.TopLeft &&
            this._actionWidget.direction !== ActionDirection.BottomLeft) {
            return Math.max(columnSpan, 1);
        }
        // get the current column span and any overflow
        var /** @type {?} */ overflow = width % this.getColumnWidth();
        return (columnSpan > 0 && overflow > (this.getColumnWidth() / 2)) ? Math.max(columnSpan + 1, 1) : Math.max(columnSpan, 1);
    };
    /**
     * Get the row position of the placeholder
     */
    /**
     * Get the row position of the placeholder
     * @param {?} y
     * @param {?} height
     * @return {?}
     */
    DashboardService.prototype.getPlaceholderRow = /**
     * Get the row position of the placeholder
     * @param {?} y
     * @param {?} height
     * @return {?}
     */
    function (y, height) {
        var /** @type {?} */ row = this.getRowFromPx(y, this._actionWidget.direction === ActionDirection.Move ? Rounding.RoundUpOverHalf : Rounding.RoundDown);
        var /** @type {?} */ rowSpan = Math.ceil(height / this._rowHeight);
        // if we arent dragging up then just return the row
        if (this._actionWidget.direction !== ActionDirection.Top &&
            this._actionWidget.direction !== ActionDirection.TopLeft &&
            this._actionWidget.direction !== ActionDirection.TopRight) {
            return Math.max(row, 0);
        }
        // get any overflow
        var /** @type {?} */ overflow = height < this._rowHeight ? 0 : height % this._rowHeight;
        return (y <= 0 || rowSpan === 0 || overflow === 0 || overflow > (this._rowHeight / 2)) ? Math.max(row, 0) : Math.max(row + 1, 0);
    };
    /**
     * Get the row span of the placeholder
     */
    /**
     * Get the row span of the placeholder
     * @param {?} height
     * @return {?}
     */
    DashboardService.prototype.getPlaceholderRowSpan = /**
     * Get the row span of the placeholder
     * @param {?} height
     * @return {?}
     */
    function (height) {
        var /** @type {?} */ rowSpan = this.getRowFromPx(height);
        // if we arent dragging up or down then just return the column span
        if (this._actionWidget.direction !== ActionDirection.Top &&
            this._actionWidget.direction !== ActionDirection.TopLeft &&
            this._actionWidget.direction !== ActionDirection.TopRight &&
            this._actionWidget.direction !== ActionDirection.Bottom &&
            this._actionWidget.direction !== ActionDirection.BottomLeft &&
            this._actionWidget.direction !== ActionDirection.BottomRight) {
            return Math.max(rowSpan, 1);
        }
        // get the current column span and any overflow
        var /** @type {?} */ overflow = height % this._rowHeight;
        return (overflow > (this._rowHeight / 2)) ? Math.max(rowSpan + 1, 1) : Math.max(rowSpan, 1);
    };
    /**
     * @param {?} x
     * @param {?=} rounding
     * @return {?}
     */
    DashboardService.prototype.getColumnFromPx = /**
     * @param {?} x
     * @param {?=} rounding
     * @return {?}
     */
    function (x, rounding) {
        if (rounding === void 0) { rounding = Rounding.RoundDown; }
        var /** @type {?} */ column = Math.floor(x / Math.floor(this.getColumnWidth()));
        var /** @type {?} */ overflow = (x % Math.floor(this.getColumnWidth()));
        var /** @type {?} */ half = this.getColumnWidth() / 2;
        switch (rounding) {
            case Rounding.RoundDown:
                return column;
            case Rounding.RoundDownBelowHalf:
                return overflow < half ? column : column + 1;
            case Rounding.RoundUpOverHalf:
                return overflow > half ? column + 1 : column;
            case Rounding.RoundUp:
                return overflow > 0 ? column + 1 : column;
        }
    };
    /**
     * @param {?} y
     * @param {?=} rounding
     * @return {?}
     */
    DashboardService.prototype.getRowFromPx = /**
     * @param {?} y
     * @param {?=} rounding
     * @return {?}
     */
    function (y, rounding) {
        if (rounding === void 0) { rounding = Rounding.RoundDown; }
        var /** @type {?} */ row = Math.floor(y / Math.floor(this._rowHeight));
        var /** @type {?} */ overflow = (y % Math.floor(this._rowHeight));
        var /** @type {?} */ half = this._rowHeight / 2;
        switch (rounding) {
            case Rounding.RoundDown:
                return row;
            case Rounding.RoundDownBelowHalf:
                return overflow < half ? row : row + 1;
            case Rounding.RoundUpOverHalf:
                return overflow > half ? row + 1 : row;
            case Rounding.RoundUp:
                return overflow > 0 ? row + 1 : row;
        }
    };
    /**
     * @return {?}
     */
    DashboardService.prototype.commitWidgetChanges = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ placeholder = this.placeholder$.getValue();
        // check that we have all the values we need
        if (placeholder.column === undefined || placeholder.row === undefined ||
            placeholder.columnSpan === undefined || placeholder.rowSpan === undefined) {
            return;
        }
        if (this._actionWidget) {
            this._actionWidget.widget.setColumn(placeholder.column);
            this._actionWidget.widget.setRow(placeholder.row);
            this._actionWidget.widget.setColumnSpan(placeholder.columnSpan);
            this._actionWidget.widget.setRowSpan(placeholder.rowSpan);
        }
        // reset all placeholder values
        placeholder.column = undefined;
        placeholder.row = undefined;
        placeholder.columnSpan = undefined;
        placeholder.rowSpan = undefined;
        // emit the new placeholder values
        this.placeholder$.next(placeholder);
    };
    /**
     * Get the current column width
     */
    /**
     * Get the current column width
     * @return {?}
     */
    DashboardService.prototype.getColumnWidth = /**
     * Get the current column width
     * @return {?}
     */
    function () {
        return Math.floor(this.columnWidth);
    };
    /**
     * Calculate the number of rows populated with widgets
     */
    /**
     * Calculate the number of rows populated with widgets
     * @return {?}
     */
    DashboardService.prototype.getRowCount = /**
     * Calculate the number of rows populated with widgets
     * @return {?}
     */
    function () {
        return this.widgets.reduce(function (previous, widget) { return Math.max(widget.getRow() + widget.getRowSpan(), previous); }, 0);
    };
    /**
     * Set the height of the dashboard container element
     */
    /**
     * Set the height of the dashboard container element
     * @return {?}
     */
    DashboardService.prototype.setDashboardHeight = /**
     * Set the height of the dashboard container element
     * @return {?}
     */
    function () {
        // size the dashboard container to ensure all rows fit
        var /** @type {?} */ rowCount = this.getRowCount();
        // if we should show an empty row increment the row count by 1
        if (this.options.emptyRow) {
            rowCount++;
        }
        this.setDimensions(undefined, rowCount * this._rowHeight);
    };
    /**
     * Orders the z-index of all widgets to move the active one to the front
     * @param widget The widget that should be brought to the front
     */
    /**
     * Orders the z-index of all widgets to move the active one to the front
     * @param {?} widget The widget that should be brought to the front
     * @return {?}
     */
    DashboardService.prototype.bringToFront = /**
     * Orders the z-index of all widgets to move the active one to the front
     * @param {?} widget The widget that should be brought to the front
     * @return {?}
     */
    function (widget) {
        this.widgets.forEach(function (_widget) { return _widget === widget ? _widget.bringToFront() : _widget.sendToBack(); });
    };
    /**
     * Move a widget down - if widgets are in the position below, then move them down further
     * @param widget The widget to move downwards
     */
    /**
     * Move a widget down - if widgets are in the position below, then move them down further
     * @param {?} widget The widget to move downwards
     * @param {?=} distance
     * @return {?}
     */
    DashboardService.prototype.moveWidgetDown = /**
     * Move a widget down - if widgets are in the position below, then move them down further
     * @param {?} widget The widget to move downwards
     * @param {?=} distance
     * @return {?}
     */
    function (widget, distance) {
        var _this = this;
        if (distance === void 0) { distance = 1; }
        // move the widget down one position
        widget.setRow(widget.getRow() + distance);
        // check every space the widget occupies for collisions
        this.forEachBlock(widget, function (column, row) {
            return _this.getWidgetsAtPosition(column, row, true)
                .filter(function (wgt) { return wgt !== widget; })
                .forEach(function (wgt) { return _this.moveWidgetDown(wgt, distance); });
        });
    };
    /**
     * Widgets should not be allowed to have a vacant space above them - if there is one they should move upwards to fill it
     */
    /**
     * Widgets should not be allowed to have a vacant space above them - if there is one they should move upwards to fill it
     * @return {?}
     */
    DashboardService.prototype.shiftWidgetsUp = /**
     * Widgets should not be allowed to have a vacant space above them - if there is one they should move upwards to fill it
     * @return {?}
     */
    function () {
        var _this = this;
        // check whether or not changes have been made - if so we need to repeat until stable
        var /** @type {?} */ stable = true;
        // iterate each widget and
        this.widgets.forEach(function (widget) {
            // if widget is already on the top row then do nothing
            if (widget.getRow() === 0) {
                return;
            }
            // if we are currently dragging and this is the dragging widget then skip
            if (_this._actionWidget && _this._actionWidget.widget === widget) {
                return;
            }
            if (_this.getPositionAvailable(widget.getColumn(), widget.getRow() - 1, widget.getColumnSpan(), 1)) {
                widget.setRow(widget.getRow() - 1);
                stable = false;
            }
        });
        // if changes occurred then we should repeat the process
        if (!stable) {
            this.shiftWidgetsUp();
        }
    };
    /**
     * Iterate over each space a widget occupied
     * @param widget The widget to determine spaces
     * @param callback The function to be called for each space, should expect a column and row argument witht he context being the widget
     */
    /**
     * Iterate over each space a widget occupied
     * @param {?} widget The widget to determine spaces
     * @param {?} callback The function to be called for each space, should expect a column and row argument witht he context being the widget
     * @return {?}
     */
    DashboardService.prototype.forEachBlock = /**
     * Iterate over each space a widget occupied
     * @param {?} widget The widget to determine spaces
     * @param {?} callback The function to be called for each space, should expect a column and row argument witht he context being the widget
     * @return {?}
     */
    function (widget, callback) {
        for (var /** @type {?} */ row = widget.getRow(); row < widget.getRow() + widget.getRowSpan(); row++) {
            for (var /** @type {?} */ column = widget.getColumn(); column < widget.getColumn() + widget.getColumnSpan(); column++) {
                callback.call(widget, column, row);
            }
        }
    };
    /**
     * Returns the number of columns available
     */
    /**
     * Returns the number of columns available
     * @return {?}
     */
    DashboardService.prototype.getColumnCount = /**
     * Returns the number of columns available
     * @return {?}
     */
    function () {
        return this.stacked ? 1 : this.options.columns;
    };
    DashboardService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    DashboardService.ctorParameters = function () { return []; };
    return DashboardService;
}());
var /** @type {?} */ defaultOptions = { columns: 5, padding: 5, minWidth: 100, minHeight: 100, emptyRow: true };
/** @enum {number} */
var ActionDirection = {
    Top: 0,
    TopRight: 1,
    Right: 2,
    BottomRight: 3,
    Bottom: 4,
    BottomLeft: 5,
    Left: 6,
    TopLeft: 7,
    Move: 8,
};
ActionDirection[ActionDirection.Top] = "Top";
ActionDirection[ActionDirection.TopRight] = "TopRight";
ActionDirection[ActionDirection.Right] = "Right";
ActionDirection[ActionDirection.BottomRight] = "BottomRight";
ActionDirection[ActionDirection.Bottom] = "Bottom";
ActionDirection[ActionDirection.BottomLeft] = "BottomLeft";
ActionDirection[ActionDirection.Left] = "Left";
ActionDirection[ActionDirection.TopLeft] = "TopLeft";
ActionDirection[ActionDirection.Move] = "Move";
/** @enum {number} */
var Rounding = {
    RoundDown: 0,
    RoundDownBelowHalf: 1,
    RoundUp: 2,
    RoundUpOverHalf: 3,
};
Rounding[Rounding.RoundDown] = "RoundDown";
Rounding[Rounding.RoundDownBelowHalf] = "RoundDownBelowHalf";
Rounding[Rounding.RoundUp] = "RoundUp";
Rounding[Rounding.RoundUpOverHalf] = "RoundUpOverHalf";

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var DashboardComponent = (function () {
    function DashboardComponent(dashboardService) {
        var _this = this;
        this.dashboardService = dashboardService;
        this.layoutChange = new EventEmitter();
        dashboardService.layout$.subscribe(function (layout) { return _this.layoutChange.emit(layout); });
    }
    Object.defineProperty(DashboardComponent.prototype, "layout", {
        set: /**
         * @param {?} layout
         * @return {?}
         */
        function (layout) {
            if (layout) {
                this.dashboardService.layout$.next(layout);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DashboardComponent.prototype, "options", {
        set: /**
         * @param {?} options
         * @return {?}
         */
        function (options) {
            this.dashboardService.options$.next(__assign({}, defaultOptions, options));
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Set the initial dimensions
     */
    /**
     * Set the initial dimensions
     * @return {?}
     */
    DashboardComponent.prototype.ngAfterViewInit = /**
     * Set the initial dimensions
     * @return {?}
     */
    function () {
        this.dashboardService.setDimensions(this.dashboardElement.nativeElement.offsetWidth, this.dashboardElement.nativeElement.offsetHeight);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    DashboardComponent.prototype.onResize = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.dashboardService.setDimensions(event.width, event.height);
    };
    DashboardComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-dashboard',
                    template: "<div #dashboard class=\"dashboard-container\" [style.height.px]=\"dashboardService.height$ | async\">\n    <div (uxResize)=\"onResize($event)\" [throttle]=\"16\" class=\"dashboard\">\n        <ng-content></ng-content>\n    </div>\n    \n    <div class=\"position-indicator\" *ngIf=\"(dashboardService.placeholder$ | async).visible\" \n        [style.left.px]=\"(dashboardService.placeholder$ | async).x\" \n        [style.top.px]=\"(dashboardService.placeholder$ | async).y\" \n        [style.width.px]=\"(dashboardService.placeholder$ | async).width\"\n        [style.height.px]=\"(dashboardService.placeholder$ | async).height\"></div>\n</div>",
                    providers: [DashboardService],
                    changeDetection: ChangeDetectionStrategy.OnPush
                },] },
    ];
    /** @nocollapse */
    DashboardComponent.ctorParameters = function () { return [
        { type: DashboardService, },
    ]; };
    DashboardComponent.propDecorators = {
        "layout": [{ type: Input },],
        "options": [{ type: Input },],
        "layoutChange": [{ type: Output },],
        "dashboardElement": [{ type: ViewChild, args: ['dashboard',] },],
    };
    return DashboardComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var DashboardWidgetComponent = (function () {
    function DashboardWidgetComponent(dashboardService) {
        var _this = this;
        this.dashboardService = dashboardService;
        this.colSpan = 1;
        this.rowSpan = 1;
        this.resizable = false;
        this.x = 0;
        this.y = 0;
        this.width = 100;
        this.height = 100;
        this.padding = 0;
        this.zIndex = 0;
        this._column = { regular: undefined, stacked: undefined };
        this._row = { regular: undefined, stacked: undefined };
        this._columnSpan = { regular: 1, stacked: 1 };
        this._rowSpan = { regular: 1, stacked: 1 };
        this._subscription = dashboardService.options$.subscribe(function () { return _this.update(); });
    }
    /**
     * @return {?}
     */
    DashboardWidgetComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this._columnSpan.regular = this.colSpan;
        this._rowSpan.regular = this.rowSpan;
        if (!this.id) {
            console.warn('Dashboard Widget is missing an ID.');
            // set random id - keeps things working but prevents exporting of positions
            this.id = Math.floor(Math.random() * 100000).toString();
        }
    };
    /**
     * @return {?}
     */
    DashboardWidgetComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        // add the widget to the dashboard
        this.dashboardService.addWidget(this);
        // apply the current options
        this.update();
    };
    /**
     * If component is removed, then unregister it from the service
     */
    /**
     * If component is removed, then unregister it from the service
     * @return {?}
     */
    DashboardWidgetComponent.prototype.ngOnDestroy = /**
     * If component is removed, then unregister it from the service
     * @return {?}
     */
    function () {
        this._subscription.unsubscribe();
        this.dashboardService.removeWidget(this);
    };
    /**
     * Apply the current dashboard options
     */
    /**
     * Apply the current dashboard options
     * @return {?}
     */
    DashboardWidgetComponent.prototype.update = /**
     * Apply the current dashboard options
     * @return {?}
     */
    function () {
        // get the current options at the time
        var _a = this.dashboardService.options, padding = _a.padding, columns = _a.columns;
        this.padding = padding;
        this._columnSpan.stacked = columns;
    };
    /**
     * Set the actual position and size values
     */
    /**
     * Set the actual position and size values
     * @return {?}
     */
    DashboardWidgetComponent.prototype.render = /**
     * Set the actual position and size values
     * @return {?}
     */
    function () {
        this.x = this.getColumn() * this.dashboardService.getColumnWidth();
        this.y = this.getRow() * this.dashboardService.getRowHeight();
        this.width = this.getColumnSpan() * this.dashboardService.getColumnWidth();
        this.height = this.getRowSpan() * this.dashboardService.getRowHeight();
    };
    /**
     * @return {?}
     */
    DashboardWidgetComponent.prototype.getColumn = /**
     * @return {?}
     */
    function () {
        return this.getStackableValue(this._column);
    };
    /**
     * @return {?}
     */
    DashboardWidgetComponent.prototype.getRow = /**
     * @return {?}
     */
    function () {
        return this.getStackableValue(this._row);
    };
    /**
     * @param {?} column
     * @param {?=} render
     * @return {?}
     */
    DashboardWidgetComponent.prototype.setColumn = /**
     * @param {?} column
     * @param {?=} render
     * @return {?}
     */
    function (column, render) {
        if (render === void 0) { render = true; }
        this.setStackableValue(this._column, column);
        if (render) {
            this.render();
        }
    };
    /**
     * @param {?} row
     * @param {?=} render
     * @return {?}
     */
    DashboardWidgetComponent.prototype.setRow = /**
     * @param {?} row
     * @param {?=} render
     * @return {?}
     */
    function (row, render) {
        if (render === void 0) { render = true; }
        this.setStackableValue(this._row, row);
        if (render) {
            this.render();
        }
    };
    /**
     * @return {?}
     */
    DashboardWidgetComponent.prototype.getColumnSpan = /**
     * @return {?}
     */
    function () {
        return this.getStackableValue(this._columnSpan);
    };
    /**
     * @return {?}
     */
    DashboardWidgetComponent.prototype.getRowSpan = /**
     * @return {?}
     */
    function () {
        return this.getStackableValue(this._rowSpan);
    };
    /**
     * @param {?} columnSpan
     * @param {?=} render
     * @return {?}
     */
    DashboardWidgetComponent.prototype.setColumnSpan = /**
     * @param {?} columnSpan
     * @param {?=} render
     * @return {?}
     */
    function (columnSpan, render) {
        if (render === void 0) { render = true; }
        this.setStackableValue(this._columnSpan, columnSpan);
        if (render) {
            this.render();
        }
    };
    /**
     * @param {?} rowSpan
     * @param {?=} render
     * @return {?}
     */
    DashboardWidgetComponent.prototype.setRowSpan = /**
     * @param {?} rowSpan
     * @param {?=} render
     * @return {?}
     */
    function (rowSpan, render) {
        if (render === void 0) { render = true; }
        this.setStackableValue(this._rowSpan, rowSpan);
        if (render) {
            this.render();
        }
    };
    /**
     * @return {?}
     */
    DashboardWidgetComponent.prototype.bringToFront = /**
     * @return {?}
     */
    function () {
        this.zIndex = 1;
    };
    /**
     * @return {?}
     */
    DashboardWidgetComponent.prototype.sendToBack = /**
     * @return {?}
     */
    function () {
        this.zIndex = 0;
    };
    /**
     * @param {?} x
     * @param {?} y
     * @param {?} width
     * @param {?} height
     * @return {?}
     */
    DashboardWidgetComponent.prototype.setBounds = /**
     * @param {?} x
     * @param {?} y
     * @param {?} width
     * @param {?} height
     * @return {?}
     */
    function (x, y, width, height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    };
    /**
     * @param {?} handle
     * @param {?} event
     * @param {?} direction
     * @return {?}
     */
    DashboardWidgetComponent.prototype.dragstart = /**
     * @param {?} handle
     * @param {?} event
     * @param {?} direction
     * @return {?}
     */
    function (handle, event, direction) {
        this.dashboardService.onResizeStart({ widget: this, direction: direction, event: event, handle: handle });
    };
    /**
     * @param {?} handle
     * @param {?} event
     * @param {?} direction
     * @return {?}
     */
    DashboardWidgetComponent.prototype.drag = /**
     * @param {?} handle
     * @param {?} event
     * @param {?} direction
     * @return {?}
     */
    function (handle, event, direction) {
        this.dashboardService.onResizeDrag({ widget: this, direction: direction, event: event, handle: handle });
    };
    /**
     * @return {?}
     */
    DashboardWidgetComponent.prototype.dragend = /**
     * @return {?}
     */
    function () {
        this.dashboardService.onResizeEnd();
    };
    /**
     * Allows automatic setting of stackable value
     * @param {?} property The current StackableValue object
     * @param {?} value The value to set in the appropriate field
     * @return {?}
     */
    DashboardWidgetComponent.prototype.setStackableValue = /**
     * Allows automatic setting of stackable value
     * @param {?} property The current StackableValue object
     * @param {?} value The value to set in the appropriate field
     * @return {?}
     */
    function (property, value) {
        if (this.dashboardService.stacked) {
            property.stacked = value;
        }
        else {
            property.regular = value;
        }
    };
    /**
     * Return the appropriate value from a stackable value
     * @param {?} property The Stackable value object
     * @return {?}
     */
    DashboardWidgetComponent.prototype.getStackableValue = /**
     * Return the appropriate value from a stackable value
     * @param {?} property The Stackable value object
     * @return {?}
     */
    function (property) {
        return this.dashboardService.stacked ? property.stacked : property.regular;
    };
    DashboardWidgetComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-dashboard-widget',
                    template: "<div class=\"widget-content widget-col-span-{{ getColumnSpan() }} widget-row-span-{{ getRowSpan() }}\">\n    <ng-content></ng-content>\n</div>\n\n<div uxDrag #handleTop class=\"resizer-handle handle-top\" \n    (dragstart)=\"dragstart(handleTop, $event, 0)\"\n    (drag)=\"drag(handleTop, $event, 0)\"\n    (dragend)=\"dragend()\"\n    [style.top.px]=\"padding\" \n    [hidden]=\"!resizable\">\n</div>\n\n<div uxDrag #handleTopRight class=\"resizer-handle handle-top-right\" \n    (dragstart)=\"dragstart(handleTopRight, $event, 1)\"\n    (drag)=\"drag(handleTopRight, $event, 1)\"\n    (dragend)=\"dragend()\"\n    [style.top.px]=\"padding\" \n    [style.right.px]=\"padding\" \n    [hidden]=\"!resizable && !(dashboardService.stacked$ | async)\">\n</div>\n\n<div uxDrag #handleRight class=\"resizer-handle handle-right\" \n    (dragstart)=\"dragstart(handleRight, $event, 2)\"\n    (drag)=\"drag(handleRight, $event, 2)\"\n    (dragend)=\"dragend()\"\n    [style.right.px]=\"padding\" \n    [hidden]=\"!resizable || (dashboardService.stacked$ | async)\">\n</div>\n\n<div uxDrag #handleBottomRight class=\"resizer-handle handle-bottom-right\" \n    (dragstart)=\"dragstart(handleBottomRight, $event, 3)\"\n    (drag)=\"drag(handleBottomRight, $event, 3)\"\n    (dragend)=\"dragend()\"\n    [style.bottom.px]=\"padding\" \n    [style.right.px]=\"padding\" \n    [hidden]=\"!resizable && !(dashboardService.stacked$ | async)\">\n</div>\n\n<div uxDrag #handleBottom class=\"resizer-handle handle-bottom\" \n    (dragstart)=\"dragstart(handleBottom, $event, 4)\"\n    (drag)=\"drag(handleBottom, $event, 4)\"\n    (dragend)=\"dragend()\"\n    [style.bottom.px]=\"padding\" \n    [hidden]=\"!resizable\">\n</div>\n\n<div uxDrag #handleBottomLeft class=\"resizer-handle handle-bottom-left\" \n    (dragstart)=\"dragstart(handleBottomLeft, $event, 5)\"\n    (drag)=\"drag(handleBottomLeft, $event, 5)\"\n    (dragend)=\"dragend()\"\n    [style.bottom.px]=\"padding\" \n    [style.left.px]=\"padding\" \n    [hidden]=\"!resizable && !(dashboardService.stacked$ | async)\">\n</div>\n\n<div uxDrag #handleLeft class=\"resizer-handle handle-left\" \n    (dragstart)=\"dragstart(handleLeft, $event, 6)\"\n    (drag)=\"drag(handleLeft, $event, 6)\"\n    (dragend)=\"dragend()\"\n    [style.left.px]=\"padding\" \n    [hidden]=\"!resizable || (dashboardService.stacked$ | async)\">\n</div>\n\n<div uxDrag #handleTopLeft class=\"resizer-handle handle-top-left\" \n    (dragstart)=\"dragstart(handleTopLeft, $event, 7)\"\n    (drag)=\"drag(handleTopLeft, $event, 7)\"\n    (dragend)=\"dragend()\"\n    [style.top.px]=\"padding\" \n    [style.left.px]=\"padding\" \n    [hidden]=\"!resizable && !(dashboardService.stacked$ | async)\">\n</div>"
                },] },
    ];
    /** @nocollapse */
    DashboardWidgetComponent.ctorParameters = function () { return [
        { type: DashboardService, },
    ]; };
    DashboardWidgetComponent.propDecorators = {
        "id": [{ type: Input },],
        "col": [{ type: Input },],
        "row": [{ type: Input },],
        "colSpan": [{ type: Input },],
        "rowSpan": [{ type: Input },],
        "resizable": [{ type: Input },],
        "x": [{ type: HostBinding, args: ['style.left.px',] },],
        "y": [{ type: HostBinding, args: ['style.top.px',] },],
        "width": [{ type: HostBinding, args: ['style.width.px',] },],
        "height": [{ type: HostBinding, args: ['style.height.px',] },],
        "padding": [{ type: HostBinding, args: ['style.padding.px',] },],
        "zIndex": [{ type: HostBinding, args: ['style.z-index',] },],
    };
    return DashboardWidgetComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var DragDirective = (function () {
    function DragDirective(_elementRef, _ngZone, _renderer) {
        this._elementRef = _elementRef;
        this._ngZone = _ngZone;
        this._renderer = _renderer;
        /**
         * Detemine if we should show a clone when dragging
         */
        this.clone = false;
        /**
         * Emit an event when dragging starts
         */
        this.dragstart = new EventEmitter();
        /**
         * Emit an event when the mouse moves while dragging
         */
        this.drag = new EventEmitter();
        /**
         * Emit an event when the dragging finishes
         */
        this.dragend = new EventEmitter();
        /**
         * Create an observable from the mouse down event
         */
        this._mousedown$ = fromEvent(this._elementRef.nativeElement, 'mousedown');
        /**
         * Create an observable from the mouse move event
         */
        this._mousemove$ = fromEvent(document, 'mousemove');
        /**
         * Create an observable from the mouse up event
         */
        this._mouseup$ = fromEvent(document, 'mouseup');
        /**
         * Use an observable to unsubscribe from all subscriptions
         */
        this._onDestroy = new Subject();
        this._mousedown$.pipe(takeUntil(this._onDestroy)).subscribe(this.dragStart.bind(this));
    }
    /** Emit events and create clone when drag starts */
    /**
     * Emit events and create clone when drag starts
     * @param {?} event
     * @return {?}
     */
    DragDirective.prototype.dragStart = /**
     * Emit events and create clone when drag starts
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        event.preventDefault();
        if (this.clone) {
            // clone the node
            this.cloneNode(event);
        }
        // apply a class to the element being dragged
        this._renderer.addClass(this._elementRef.nativeElement, 'ux-drag-dragging');
        // emit the drag start event
        this._ngZone.run(function () { return _this.dragstart.emit(event); });
        this._mousemove$.pipe(takeUntil(this._mouseup$), takeUntil(this._onDestroy))
            .subscribe(this.dragMove.bind(this), null, this.dragEnd.bind(this));
    };
    /** Emit event and update clone position when dragging moves */
    /**
     * Emit event and update clone position when dragging moves
     * @param {?} event
     * @return {?}
     */
    DragDirective.prototype.dragMove = /**
     * Emit event and update clone position when dragging moves
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        event.preventDefault();
        if (this._clone) {
            this.updateNodePosition(event);
        }
        // emit the drag start event
        this._ngZone.run(function () { return _this.drag.emit(event); });
    };
    /** Emit event and destroy clone when dragging ends */
    /**
     * Emit event and destroy clone when dragging ends
     * @return {?}
     */
    DragDirective.prototype.dragEnd = /**
     * Emit event and destroy clone when dragging ends
     * @return {?}
     */
    function () {
        var _this = this;
        // if there was a clone, remove it
        if (this._clone) {
            this._renderer.removeChild(document.body, this._clone);
            this._clone = null;
        }
        // remove the dragging class
        this._renderer.removeClass(this._elementRef.nativeElement, 'ux-drag-dragging');
        this._ngZone.run(function () { return _this.dragend.emit(); });
    };
    /** Create an exact clone of an element */
    /**
     * Create an exact clone of an element
     * @param {?} event
     * @return {?}
     */
    DragDirective.prototype.cloneNode = /**
     * Create an exact clone of an element
     * @param {?} event
     * @return {?}
     */
    function (event) {
        // duplicate the node
        this._clone = this._elementRef.nativeElement.cloneNode(true);
        // store the position within the draggable element
        var _a = this._elementRef.nativeElement.getBoundingClientRect(), top = _a.top, left = _a.left;
        this._offset = { x: event.clientX - left, y: event.clientY - top };
        // inline all styles so it looks identical regardless of its position in the DOM
        this.inlineStyles(this._elementRef.nativeElement, this._clone);
        // ensure we can easily position the node an it is above all other elements
        this._renderer.setAttribute(this._clone, 'aria-hidden', 'true');
        this._renderer.setStyle(this._clone, 'position', 'absolute');
        this._renderer.setStyle(this._clone, 'z-index', '99999');
        // apply a class to allow custom styling
        this._renderer.addClass(this._clone, 'ux-drag-dragging-clone');
        // insert the cloned element
        this._renderer.appendChild(document.body, this._clone);
        // set the cloned element initial position
        this.updateNodePosition(event);
    };
    /** Position the clone relative to the mouse */
    /**
     * Position the clone relative to the mouse
     * @param {?} event
     * @return {?}
     */
    DragDirective.prototype.updateNodePosition = /**
     * Position the clone relative to the mouse
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this._renderer.setStyle(this._clone, 'left', (event.pageX - this._offset.x) + 'px');
        this._renderer.setStyle(this._clone, 'top', (event.pageY - this._offset.y) + 'px');
    };
    /** Inline all styles to ensure styling is consistent regardless of its position in the dom */
    /**
     * Inline all styles to ensure styling is consistent regardless of its position in the dom
     * @param {?} source
     * @param {?} target
     * @return {?}
     */
    DragDirective.prototype.inlineStyles = /**
     * Inline all styles to ensure styling is consistent regardless of its position in the dom
     * @param {?} source
     * @param {?} target
     * @return {?}
     */
    function (source, target) {
        // get all the computed styles from the source element
        var /** @type {?} */ styles = getComputedStyle(source);
        // inline every specified style
        for (var /** @type {?} */ idx = 0; idx < styles.length; idx++) {
            var /** @type {?} */ style$$1 = styles.item(idx);
            if (style$$1 !== undefined) {
                this._renderer.setStyle(target, styles[idx], styles[style$$1]);
            }
        }
        // ensure we dont capture any move events
        this._renderer.setStyle(target, 'pointer-events', 'none');
        // do the same for all the child elements
        for (var /** @type {?} */ idx = 0; idx < source.children.length; idx++) {
            this.inlineStyles(source.children[idx], target.children[idx]);
        }
    };
    /** Unsubscribe from all subscriptions */
    /**
     * Unsubscribe from all subscriptions
     * @return {?}
     */
    DragDirective.prototype.ngOnDestroy = /**
     * Unsubscribe from all subscriptions
     * @return {?}
     */
    function () {
        this._onDestroy.next();
        this._onDestroy.complete();
    };
    DragDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[uxDrag]'
                },] },
    ];
    /** @nocollapse */
    DragDirective.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgZone, },
        { type: Renderer2, },
    ]; };
    DragDirective.propDecorators = {
        "clone": [{ type: Input },],
        "dragstart": [{ type: Output },],
        "drag": [{ type: Output },],
        "dragend": [{ type: Output },],
    };
    return DragDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var DashboardDragHandleDirective = (function (_super) {
    __extends(DashboardDragHandleDirective, _super);
    function DashboardDragHandleDirective(widget, dashboardService, elementRef, ngZone, renderer) {
        var _this = _super.call(this, elementRef, ngZone, renderer) || this;
        _this.dragstart.pipe(takeUntil(_this._onDestroy))
            .subscribe(function (event) { return dashboardService.onDragStart({ widget: widget, direction: ActionDirection.Move, event: event }); });
        _this.drag.pipe(takeUntil(_this._onDestroy))
            .subscribe(function (event) { return dashboardService.onDrag({ widget: widget, direction: ActionDirection.Move, event: event }); });
        _this.dragend.pipe(takeUntil(_this._onDestroy))
            .subscribe(function () { return dashboardService.onDragEnd(); });
        return _this;
    }
    DashboardDragHandleDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[uxDashboardWidgetDragHandle], [ux-dashboard-widget-drag-handle]'
                },] },
    ];
    /** @nocollapse */
    DashboardDragHandleDirective.ctorParameters = function () { return [
        { type: DashboardWidgetComponent, },
        { type: DashboardService, },
        { type: ElementRef, },
        { type: NgZone, },
        { type: Renderer2, },
    ]; };
    return DashboardDragHandleDirective;
}(DragDirective));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var DragModule = (function () {
    function DragModule() {
    }
    DragModule.decorators = [
        { type: NgModule, args: [{
                    exports: [DragDirective],
                    declarations: [DragDirective]
                },] },
    ];
    /** @nocollapse */
    DragModule.ctorParameters = function () { return []; };
    return DragModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var /** @type {?} */ DECLARATIONS = [
    DashboardComponent,
    DashboardWidgetComponent,
    DashboardDragHandleDirective
];
var DashboardModule = (function () {
    function DashboardModule() {
    }
    DashboardModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        ResizeModule,
                        DragModule
                    ],
                    exports: DECLARATIONS,
                    declarations: DECLARATIONS,
                    providers: [DashboardService],
                },] },
    ];
    /** @nocollapse */
    DashboardModule.ctorParameters = function () { return []; };
    return DashboardModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var /** @type {?} */ SPIN_BUTTON_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(function () { return SpinButtonComponent; }),
    multi: true
};
var SpinButtonComponent = (function () {
    function SpinButtonComponent() {
        this.type = 'text';
        this.placeholder = '';
        this.disabled = false;
        this.spinners = true;
        this.readOnly = true;
        this.scrolling = true;
        this.arrowkeys = true;
        this.valueChange = new EventEmitter();
        this.increment = new EventEmitter();
        this.decrement = new EventEmitter();
        this.onTouchedCallback = function () { };
        this.onChangeCallback = function () { };
    }
    Object.defineProperty(SpinButtonComponent.prototype, "value", {
        get: /**
         * @return {?}
         */
        function () {
            return this._value;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._value = value;
            this.onChangeCallback(value);
            this.onTouchedCallback();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} event
     * @return {?}
     */
    SpinButtonComponent.prototype.scroll = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (!this.scrolling) {
            return;
        }
        if (event.deltaY > 0) {
            this.triggerDecrement();
        }
        else {
            this.triggerIncrement();
        }
        event.preventDefault();
    };
    /**
     * @return {?}
     */
    SpinButtonComponent.prototype.triggerIncrement = /**
     * @return {?}
     */
    function () {
        if (!this.disabled) {
            this.increment.emit();
        }
    };
    /**
     * @return {?}
     */
    SpinButtonComponent.prototype.triggerDecrement = /**
     * @return {?}
     */
    function () {
        if (!this.disabled) {
            this.decrement.emit();
        }
    };
    /**
     * @param {?} value
     * @return {?}
     */
    SpinButtonComponent.prototype.writeValue = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this.value = value;
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    SpinButtonComponent.prototype.registerOnChange = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onChangeCallback = fn;
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    SpinButtonComponent.prototype.registerOnTouched = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onTouchedCallback = fn;
    };
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    SpinButtonComponent.prototype.setDisabledState = /**
     * @param {?} isDisabled
     * @return {?}
     */
    function (isDisabled) {
        this.disabled = isDisabled;
    };
    SpinButtonComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-spin-button',
                    template: "<button class=\"spin-button\"\n        *ngIf=\"spinners\"\n        tabindex=\"-1\"\n        [disabled]=\"disabled\"\n        [attr.aria-label]=\"incrementAriaLabel\"\n        [attr.aria-disabled]=\"disabled\"\n        (click)=\"triggerIncrement()\">\n\n  <span class=\"hpe-icon hpe-up\"></span>\n</button>\n\n<input [type]=\"type\"\n       role=\"spinbutton\"\n       [min]=\"min\"\n       [max]=\"max\"\n       [tabindex]=\"0\"\n       class=\"form-control\"\n       [placeholder]=\"placeholder\"\n       [readOnly]=\"readOnly\"\n       [disabled]=\"disabled\"\n       [attr.aria-label]=\"inputAriaLabel\"\n       [attr.aria-disabled]=\"disabled\"\n       [attr.aria-valuemin]=\"min\"\n       [attr.aria-valuenow]=\"value\"\n       [attr.aria-valuemax]=\"max\"\n       [attr.aria-readonly]=\"readOnly\"\n       [ngModel]=\"value\"\n       (ngModelChange)=\"valueChange.emit($event)\"\n       (wheel)=\"scroll($event)\"\n       (keydown.arrowup)=\"arrowkeys ? triggerIncrement() : null; $event.preventDefault()\"\n       (keydown.arrowdown)=\"arrowkeys ? triggerDecrement() : null; $event.preventDefault()\">\n\n<button class=\"spin-button\"\n        *ngIf=\"spinners\"\n        tabindex=\"-1\"\n        [disabled]=\"disabled\"\n        [attr.aria-label]=\"decrementAriaLabel\"\n        [attr.aria-disabled]=\"disabled\"\n        (click)=\"triggerDecrement()\">\n\n  <span class=\"hpe-icon hpe-down\"></span>\n</button>",
                    encapsulation: ViewEncapsulation.None,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [SPIN_BUTTON_VALUE_ACCESSOR]
                },] },
    ];
    /** @nocollapse */
    SpinButtonComponent.ctorParameters = function () { return []; };
    SpinButtonComponent.propDecorators = {
        "value": [{ type: Input },],
        "type": [{ type: Input },],
        "min": [{ type: Input },],
        "max": [{ type: Input },],
        "placeholder": [{ type: Input },],
        "disabled": [{ type: Input },],
        "spinners": [{ type: Input },],
        "readOnly": [{ type: Input },],
        "scrolling": [{ type: Input },],
        "arrowkeys": [{ type: Input },],
        "incrementAriaLabel": [{ type: Input },],
        "inputAriaLabel": [{ type: Input },],
        "decrementAriaLabel": [{ type: Input },],
        "valueChange": [{ type: Output },],
        "increment": [{ type: Output },],
        "decrement": [{ type: Output },],
    };
    return SpinButtonComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var SpinButtonModule = (function () {
    function SpinButtonModule() {
    }
    SpinButtonModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        FormsModule
                    ],
                    exports: [SpinButtonComponent],
                    declarations: [SpinButtonComponent]
                },] },
    ];
    /** @nocollapse */
    SpinButtonModule.ctorParameters = function () { return []; };
    return SpinButtonModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var TimeFormatPipe = (function () {
    function TimeFormatPipe() {
    }
    /**
     * @param {?} value
     * @return {?}
     */
    TimeFormatPipe.prototype.transform = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        return value < 10 ? '0' + value : value;
    };
    TimeFormatPipe.decorators = [
        { type: Pipe, args: [{
                    name: 'timeFormat'
                },] },
    ];
    /** @nocollapse */
    TimeFormatPipe.ctorParameters = function () { return []; };
    return TimeFormatPipe;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var /** @type {?} */ TIME_PICKER_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(function () { return TimePickerComponent; }),
    multi: true
};
var TimePickerComponent = (function () {
    function TimePickerComponent() {
        var _this = this;
        this.arrowkeys = true;
        this.mousewheel = true;
        this.disabled = false;
        this.readOnly = false;
        this.showMeridian = false;
        this.showHours = true;
        this.showMinutes = true;
        this.showSeconds = false;
        this.showSpinners = true;
        this.hourStep = 1;
        this.minuteStep = 1;
        this.secondStep = 1;
        this.meridians = ['AM', 'PM'];
        this.valueChange = new EventEmitter();
        this.isValid = new EventEmitter();
        this.onTouchedCallback = function () { };
        this.onChangeCallback = function () { };
        this.value$ = new BehaviorSubject(new Date());
        // create observables that are derived from the latest value
        this.hour$ = this.value$.pipe(map(function (date) { return date.getHours(); }), map(function (hour) { return _this.showMeridian ? _this.getMeridianTime(hour) : hour; }));
        this.minute$ = this.value$.pipe(map(function (date) { return date.getMinutes(); }));
        this.second$ = this.value$.pipe(map(function (date) { return date.getSeconds(); }));
        this.meridian$ = this.value$.pipe(map(function (date) { return date.getHours() < 12 ? _this.meridians[0] : _this.meridians[1]; }));
        this.valid$ = this.value$.pipe(map(function (date) { return _this.checkValidity(date); }));
        this._meridian = this.meridians[0];
        this._subscription = this.valid$.pipe(distinctUntilChanged()).subscribe(function (valid) { return _this.isValid.emit(valid); });
    }
    Object.defineProperty(TimePickerComponent.prototype, "value", {
        get: /**
         * @return {?}
         */
        function () {
            return new Date(this.value$.value);
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.value$.next(new Date(value));
            this.valueChange.emit(this.value$.value);
            this.onChangeCallback(this.value$.value);
            this.onTouchedCallback();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    TimePickerComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._subscription.unsubscribe();
    };
    /**
     * @param {?} value
     * @return {?}
     */
    TimePickerComponent.prototype.writeValue = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this.value = value;
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    TimePickerComponent.prototype.registerOnChange = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onChangeCallback = fn;
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    TimePickerComponent.prototype.registerOnTouched = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onTouchedCallback = fn;
    };
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    TimePickerComponent.prototype.setDisabledState = /**
     * @param {?} isDisabled
     * @return {?}
     */
    function (isDisabled) {
        this.disabled = isDisabled;
    };
    /**
     * @param {?} hour
     * @return {?}
     */
    TimePickerComponent.prototype.getMeridianTime = /**
     * @param {?} hour
     * @return {?}
     */
    function (hour) {
        return hour > 12 ? hour - 12 : hour;
    };
    /**
     * @param {?} hour
     * @return {?}
     */
    TimePickerComponent.prototype.setHour = /**
     * @param {?} hour
     * @return {?}
     */
    function (hour) {
        var /** @type {?} */ date = this.value;
        date.setHours(hour ? hour : 0);
        this.value = date;
    };
    /**
     * @param {?} minute
     * @return {?}
     */
    TimePickerComponent.prototype.setMinute = /**
     * @param {?} minute
     * @return {?}
     */
    function (minute) {
        var /** @type {?} */ date = this.value;
        date.setMinutes(minute ? minute : 0);
        this.value = date;
    };
    /**
     * @param {?} seconds
     * @return {?}
     */
    TimePickerComponent.prototype.setSeconds = /**
     * @param {?} seconds
     * @return {?}
     */
    function (seconds) {
        var /** @type {?} */ date = this.value;
        date.setSeconds(seconds ? seconds : 0);
        this.value = date;
    };
    /**
     * @param {?=} arrowkey
     * @return {?}
     */
    TimePickerComponent.prototype.incrementHour = /**
     * @param {?=} arrowkey
     * @return {?}
     */
    function (arrowkey) {
        if (arrowkey === void 0) { arrowkey = false; }
        if (this.disabled || arrowkey && !this.arrowkeys) {
            return;
        }
        this.setHour(this.value.getHours() + this.hourStep);
    };
    /**
     * @param {?=} arrowkey
     * @return {?}
     */
    TimePickerComponent.prototype.decrementHour = /**
     * @param {?=} arrowkey
     * @return {?}
     */
    function (arrowkey) {
        if (arrowkey === void 0) { arrowkey = false; }
        if (this.disabled || arrowkey && !this.arrowkeys) {
            return;
        }
        this.setHour(this.value.getHours() - this.hourStep);
    };
    /**
     * @param {?=} arrowkey
     * @return {?}
     */
    TimePickerComponent.prototype.incrementMinute = /**
     * @param {?=} arrowkey
     * @return {?}
     */
    function (arrowkey) {
        if (arrowkey === void 0) { arrowkey = false; }
        if (this.disabled || arrowkey && !this.arrowkeys) {
            return;
        }
        this.setMinute(this.value.getMinutes() + this.minuteStep);
    };
    /**
     * @param {?=} arrowkey
     * @return {?}
     */
    TimePickerComponent.prototype.decrementMinute = /**
     * @param {?=} arrowkey
     * @return {?}
     */
    function (arrowkey) {
        if (arrowkey === void 0) { arrowkey = false; }
        if (this.disabled || arrowkey && !this.arrowkeys) {
            return;
        }
        this.setMinute(this.value.getMinutes() - this.minuteStep);
    };
    /**
     * @param {?=} arrowkey
     * @return {?}
     */
    TimePickerComponent.prototype.incrementSecond = /**
     * @param {?=} arrowkey
     * @return {?}
     */
    function (arrowkey) {
        if (arrowkey === void 0) { arrowkey = false; }
        if (this.disabled || arrowkey && !this.arrowkeys) {
            return;
        }
        this.setSeconds(this.value.getSeconds() + this.secondStep);
    };
    /**
     * @param {?=} arrowkey
     * @return {?}
     */
    TimePickerComponent.prototype.decrementSecond = /**
     * @param {?=} arrowkey
     * @return {?}
     */
    function (arrowkey) {
        if (arrowkey === void 0) { arrowkey = false; }
        if (this.disabled || arrowkey && !this.arrowkeys) {
            return;
        }
        this.setSeconds(this.value.getSeconds() - this.secondStep);
    };
    /**
     * @param {?} meridian
     * @return {?}
     */
    TimePickerComponent.prototype.selectMeridian = /**
     * @param {?} meridian
     * @return {?}
     */
    function (meridian) {
        this._meridian = meridian;
        // get the current time
        var /** @type {?} */ hour = this.value.getHours();
        // if we have selected AM
        if (meridian === this.meridians[0]) {
            if (hour >= 12) {
                this.setHour(hour - 12);
            }
        }
        // if we have selected PM
        if (meridian === this.meridians[1]) {
            if (hour < 12) {
                this.setHour(hour + 12);
            }
        }
    };
    /**
     * @param {?} date
     * @return {?}
     */
    TimePickerComponent.prototype.checkValidity = /**
     * @param {?} date
     * @return {?}
     */
    function (date) {
        var /** @type {?} */ valid = true;
        if (this.min && date.getTime() <= this.min.getTime()) {
            valid = false;
        }
        if (this.max && date.getTime() >= this.max.getTime()) {
            valid = false;
        }
        return valid;
    };
    /**
     * @param {?} value
     * @return {?}
     */
    TimePickerComponent.prototype.hourChange = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        // convert the string to a number
        var /** @type {?} */ hour = parseInt(value);
        var /** @type {?} */ currentHour = this.value.getHours();
        // if the value hasn't changed, do nothing
        if (hour === currentHour) {
            return;
        }
        // ensure the hours is valid
        if (!isNaN(hour)) {
            if (hour < 0) {
                hour = 0;
            }
            if (hour > (this.showMeridian ? 12 : 23)) {
                hour = this.showMeridian ? 12 : 23;
            }
        }
        hour = isNaN(hour) ? currentHour : hour;
        // if the number is invalid then restore it to the previous value
        if (this._meridian === this.meridians[0]) {
            if (hour >= 12) {
                hour -= 12;
            }
        }
        // if we have selected PM
        if (this._meridian === this.meridians[1]) {
            if (hour < 12) {
                hour += 12;
            }
        }
        this.setHour(hour);
    };
    /**
     * @param {?} value
     * @return {?}
     */
    TimePickerComponent.prototype.minuteChange = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        // convert the string to a number
        var /** @type {?} */ minute = parseInt(value);
        var /** @type {?} */ currentMinute = this.value.getMinutes();
        // if the value hasn't changed, do nothing
        if (minute === currentMinute) {
            return;
        }
        // ensure the hours is valid
        if (!isNaN(minute)) {
            if (minute < 0) {
                minute = 59;
            }
            if (minute > 59) {
                minute = 0;
            }
        }
        // if the number is invalid then restore it to the previous value
        this.setMinute(isNaN(minute) ? currentMinute : minute);
    };
    /**
     * @param {?} value
     * @return {?}
     */
    TimePickerComponent.prototype.secondChange = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        // convert the string to a number
        var /** @type {?} */ second = parseInt(value);
        var /** @type {?} */ currentSecond = this.value.getSeconds();
        // if the value hasn't changed, do nothing
        if (second === currentSecond) {
            return;
        }
        // ensure the hours is valid
        if (!isNaN(second)) {
            if (second < 0) {
                second = 0;
            }
            if (second > 59) {
                second = 59;
            }
        }
        // if the number is invalid then restore it to the previous value
        this.setSeconds(isNaN(second) ? currentSecond : second);
    };
    TimePickerComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-time-picker',
                    template: "<div class=\"time-picker\" aria-label=\"Time picker\">\n\n    <div class=\"time-picker-column\" [class.has-error]=\"!(valid$ | async)\" *ngIf=\"showHours\">\n\n        <ux-spin-button\n            type=\"number\"\n            class=\"time-spinner\"\n            placeholder=\"HH\"\n            [min]=\"0\"\n            [max]=\"showMeridian ? 12 : 23\"\n            [value]=\"hour$ | async | timeFormat\"\n            (valueChange)=\"hourChange($event)\"\n            [spinners]=\"showSpinners\"\n            [disabled]=\"disabled\"\n            [readOnly]=\"readOnly\"\n            inputAriaLabel=\"hour\"\n            incrementAriaLabel=\"Increment the hour\"\n            decrementAriaLabel=\"Decrement the hour\"\n            (increment)=\"incrementHour()\"\n            (decrement)=\"decrementHour()\">\n        </ux-spin-button>\n\n    </div>\n\n    <div class=\"time-picker-separator\" *ngIf=\"showMinutes\">:</div>\n\n    <div class=\"time-picker-column\" [class.has-error]=\"!(valid$ | async)\" *ngIf=\"showMinutes\">\n\n        <ux-spin-button\n            type=\"number\"\n            class=\"time-spinner\"\n            placeholder=\"MM\"\n            [min]=\"0\"\n            [max]=\"59\"\n            [value]=\"minute$ | async | timeFormat\"\n            (valueChange)=\"minuteChange($event)\"\n            [spinners]=\"showSpinners\"\n            [disabled]=\"disabled\"\n            [readOnly]=\"readOnly\"\n            inputAriaLabel=\"minute\"\n            incrementAriaLabel=\"Increment the minute\"\n            decrementAriaLabel=\"Decrement the minute\"\n            (increment)=\"incrementMinute()\"\n            (decrement)=\"decrementMinute()\">\n        </ux-spin-button>\n\n    </div>\n\n    <div class=\"time-picker-separator\" *ngIf=\"showSeconds\">:</div>\n\n    <div class=\"time-picker-column\" [class.has-error]=\"!(valid$ | async)\" *ngIf=\"showSeconds\">\n\n        <ux-spin-button\n            type=\"number\"\n            class=\"time-spinner\"\n            type=\"number\"\n            placeholder=\"SS\"\n            [min]=\"0\"\n            [max]=\"59\"\n            [value]=\"second$ | async | timeFormat\"\n            (valueChange)=\"secondChange($event)\"\n            [spinners]=\"showSpinners\"\n            [disabled]=\"disabled\"\n            [readOnly]=\"readOnly\"\n            inputAriaLabel=\"seconds\"\n            incrementAriaLabel=\"Increment the second\"\n            decrementAriaLabel=\"Decrement the second\"\n            (increment)=\"incrementSecond()\"\n            (decrement)=\"decrementSecond()\">\n        </ux-spin-button>\n\n    </div>\n</div>\n\n<div class=\"time-picker-meridian\" *ngIf=\"showMeridian\">\n\n    <div class=\"btn-group\" role=\"radiogroup\">\n\n        <button class=\"btn button-toggle-accent\"\n                *ngFor=\"let meridian of meridians\"\n                role=\"radio\"\n                tabindex=\"0\"\n                [disabled]=\"disabled\"\n                (click)=\"selectMeridian(meridian)\"\n                [class.active]=\"meridian === (meridian$ | async)\"\n                [attr.aria-label]=\"meridian\"\n                [attr.aria-checked]=\"meridian === (meridian$ | async)\"\n                [attr.aria-disabled]=\"disabled\">\n                {{ meridian }}\n        </button>\n\n    </div>\n</div>",
                    encapsulation: ViewEncapsulation.None,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [TIME_PICKER_VALUE_ACCESSOR],
                    host: {
                        'aria-label': 'Time Picker'
                    }
                },] },
    ];
    /** @nocollapse */
    TimePickerComponent.ctorParameters = function () { return []; };
    TimePickerComponent.propDecorators = {
        "arrowkeys": [{ type: Input },],
        "mousewheel": [{ type: Input },],
        "disabled": [{ type: Input },],
        "readOnly": [{ type: Input },],
        "showMeridian": [{ type: Input },],
        "showHours": [{ type: Input },],
        "showMinutes": [{ type: Input },],
        "showSeconds": [{ type: Input },],
        "showSpinners": [{ type: Input },],
        "hourStep": [{ type: Input },],
        "minuteStep": [{ type: Input },],
        "secondStep": [{ type: Input },],
        "min": [{ type: Input },],
        "max": [{ type: Input },],
        "meridians": [{ type: Input },],
        "value": [{ type: Input },],
        "valueChange": [{ type: Output },],
        "isValid": [{ type: Output },],
    };
    return TimePickerComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var TimePickerModule = (function () {
    function TimePickerModule() {
    }
    TimePickerModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        FormsModule,
                        SpinButtonModule
                    ],
                    exports: [TimePickerComponent],
                    declarations: [TimePickerComponent, TimeFormatPipe],
                },] },
    ];
    /** @nocollapse */
    TimePickerModule.ctorParameters = function () { return []; };
    return TimePickerModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Convert a single dimension array to a double dimension array
 * @template T
 * @param {?} items the single dimension array to convert
 * @param {?} columns the number of items each array should have
 * @return {?}
 */
function gridify(items, columns) {
    // create a copy of array so not to effect the original
    items = items.slice(0);
    var /** @type {?} */ grid = [];
    while (items.length) {
        grid.push(items.splice(0, columns));
    }
    return grid;
}
/**
 * Create an array of numbers between two limits
 * @param {?} start the lower limit
 * @param {?} end the upper limit
 * @return {?}
 */
function range(start, end) {
    var /** @type {?} */ list = [];
    for (var /** @type {?} */ idx = start; idx <= end; idx++) {
        list.push(idx);
    }
    return list;
}
/**
 * Create an array of dates between two points
 * @param {?} start the date to start the array
 * @param {?} end the date to end the array
 * @return {?}
 */
function dateRange(start, end) {
    var /** @type {?} */ dates = [];
    // loop through all the days between the date range
    while (start <= end) {
        // add the date to the array
        dates.push(new Date(start));
        // move to the next day
        start.setDate(start.getDate() + 1);
    }
    return dates;
}
/**
 * Compare two dates to see if they are on the same day
 * @param {?} day1 the first date to compare
 * @param {?} day2 the second date to compare
 * @return {?}
 */
function compareDays(day1, day2) {
    return day1.getDate() === day2.getDate() &&
        day1.getMonth() === day2.getMonth() &&
        day1.getFullYear() === day2.getFullYear();
}
/**
 * Date comparison for use primarily with distinctUntilChanged
 * @param {?} dateOne
 * @param {?} dateTwo
 * @return {?}
 */
function dateComparator(dateOne, dateTwo) {
    return dateOne.getTime() === dateTwo.getTime();
}
/**
 * Timezone comparison for use primarily with distinctUntilChanged
 * @param {?} zoneOne
 * @param {?} zoneTwo
 * @return {?}
 */
function timezoneComparator(zoneOne, zoneTwo) {
    return zoneOne.name === zoneTwo.name && zoneOne.offset === zoneTwo.offset;
}
/**
 * Export an array of all the available months
 */
var /** @type {?} */ months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
var /** @type {?} */ monthsShort = months.map(function (month) { return month.substring(0, 3); });
/**
 * Export an array of all the available days of the week
 */
var /** @type {?} */ weekdays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
var /** @type {?} */ weekdaysShort = weekdays.map(function (weekday) { return weekday.substring(0, 3); });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var DateTimePickerConfig = (function () {
    function DateTimePickerConfig() {
        this.showDate = true;
        this.showTime = true;
        this.showTimezone = true;
        this.showSeconds = false;
        this.showMeridian = true;
        this.showSpinners = true;
        this.weekdays = weekdaysShort;
        this.nowBtnText = 'Today';
        this.timezones = [
            { name: 'GMT-11', offset: 660 },
            { name: 'GMT-10', offset: 600 },
            { name: 'GMT-9', offset: 540 },
            { name: 'GMT-8', offset: 480 },
            { name: 'GMT-7', offset: 420 },
            { name: 'GMT-6', offset: 360 },
            { name: 'GMT-5', offset: 300 },
            { name: 'GMT-4', offset: 240 },
            { name: 'GMT-3', offset: 180 },
            { name: 'GMT-2', offset: 120 },
            { name: 'GMT-1', offset: 60 },
            { name: 'GMT', offset: 0 },
            { name: 'GMT+1', offset: -60 },
            { name: 'GMT+2', offset: -120 },
            { name: 'GMT+3', offset: -180 },
            { name: 'GMT+4', offset: -240 },
            { name: 'GMT+5', offset: -300 },
            { name: 'GMT+6', offset: -360 },
            { name: 'GMT+7', offset: -420 },
            { name: 'GMT+8', offset: -480 },
            { name: 'GMT+9', offset: -540 },
            { name: 'GMT+10', offset: -600 },
            { name: 'GMT+11', offset: -660 },
            { name: 'GMT+12', offset: -720 }
        ];
    }
    DateTimePickerConfig.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    DateTimePickerConfig.ctorParameters = function () { return []; };
    return DateTimePickerConfig;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var DateTimePickerService = (function () {
    function DateTimePickerService(_config) {
        var _this = this;
        this._config = _config;
        this.mode$ = new BehaviorSubject(DatePickerMode.Day);
        this.date$ = new BehaviorSubject(new Date());
        this.timezone$ = new BehaviorSubject(this.getCurrentTimezone());
        this.selected$ = new BehaviorSubject(new Date());
        // the month and year to display in the viewport
        this.month$ = new BehaviorSubject(new Date().getMonth());
        this.year$ = new BehaviorSubject(new Date().getFullYear());
        this.showDate$ = new BehaviorSubject(this._config.showDate);
        this.showTime$ = new BehaviorSubject(this._config.showTime);
        this.showTimezone$ = new BehaviorSubject(this._config.showTimezone);
        this.showSeconds$ = new BehaviorSubject(this._config.showSeconds);
        this.showMeridian$ = new BehaviorSubject(this._config.showMeridian);
        this.showSpinners$ = new BehaviorSubject(this._config.showSpinners);
        this.weekdays$ = new BehaviorSubject(this._config.weekdays);
        this.nowBtnText$ = new BehaviorSubject(this._config.nowBtnText);
        this.timezones$ = new BehaviorSubject(this._config.timezones);
        this.header$ = new BehaviorSubject(null);
        this.headerEvent$ = new Subject();
        this.modeDirection = ModeDirection.None;
        // when the active date changes set the currently selected date
        this._subscription = this.selected$.pipe(distinctUntilChanged(dateComparator)).subscribe(function (date) {
            // the month and year displayed in the viewport should reflect the newly selected items
            // the month and year displayed in the viewport should reflect the newly selected items
            _this.setViewportMonth(date.getMonth());
            _this.setViewportYear(date.getFullYear());
            // emit the new date to the component host
            // emit the new date to the component host
            _this.date$.next(date);
        });
    }
    /**
     * @return {?}
     */
    DateTimePickerService.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._subscription.unsubscribe();
    };
    /**
     * @param {?} month
     * @return {?}
     */
    DateTimePickerService.prototype.setViewportMonth = /**
     * @param {?} month
     * @return {?}
     */
    function (month) {
        if (month < 0) {
            this.month$.next(11);
            this.year$.next(this.year$.value - 1);
        }
        else if (month > 11) {
            this.month$.next(0);
            this.year$.next(this.year$.value + 1);
        }
        else {
            this.month$.next(month);
        }
    };
    /**
     * @param {?} year
     * @return {?}
     */
    DateTimePickerService.prototype.setViewportYear = /**
     * @param {?} year
     * @return {?}
     */
    function (year) {
        this.year$.next(year);
    };
    /**
     * @param {?} day
     * @param {?} month
     * @param {?} year
     * @return {?}
     */
    DateTimePickerService.prototype.setDate = /**
     * @param {?} day
     * @param {?} month
     * @param {?} year
     * @return {?}
     */
    function (day, month, year) {
        var /** @type {?} */ date = new Date(this.selected$.value);
        date.setDate(day);
        date.setMonth(month);
        date.setFullYear(year);
        this.selected$.next(date);
    };
    /**
     * @return {?}
     */
    DateTimePickerService.prototype.setDateToNow = /**
     * @return {?}
     */
    function () {
        this.selected$.next(new Date());
    };
    /**
     * @param {?} mode
     * @return {?}
     */
    DateTimePickerService.prototype.setViewportMode = /**
     * @param {?} mode
     * @return {?}
     */
    function (mode) {
        this.mode$.next(mode);
    };
    /**
     * @return {?}
     */
    DateTimePickerService.prototype.goToChildMode = /**
     * @return {?}
     */
    function () {
        this.modeDirection = ModeDirection.Descend;
        switch (this.mode$.value) {
            case DatePickerMode.Year:
                return this.setViewportMode(DatePickerMode.Month);
            case DatePickerMode.Month:
                return this.setViewportMode(DatePickerMode.Day);
        }
    };
    /**
     * @return {?}
     */
    DateTimePickerService.prototype.goToParentMode = /**
     * @return {?}
     */
    function () {
        this.modeDirection = ModeDirection.Ascend;
        switch (this.mode$.value) {
            case DatePickerMode.Day:
                return this.setViewportMode(DatePickerMode.Month);
            case DatePickerMode.Month:
                return this.setViewportMode(DatePickerMode.Year);
        }
    };
    /**
     * @return {?}
     */
    DateTimePickerService.prototype.goToNext = /**
     * @return {?}
     */
    function () {
        this.headerEvent$.next(DatePickerHeaderEvent.Next);
    };
    /**
     * @return {?}
     */
    DateTimePickerService.prototype.goToPrevious = /**
     * @return {?}
     */
    function () {
        this.headerEvent$.next(DatePickerHeaderEvent.Previous);
    };
    /**
     * @param {?} header
     * @return {?}
     */
    DateTimePickerService.prototype.setHeader = /**
     * @param {?} header
     * @return {?}
     */
    function (header) {
        this.header$.next(header);
    };
    /**
     * @return {?}
     */
    DateTimePickerService.prototype.getCurrentTimezone = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ offset = new Date().getTimezoneOffset();
        return this._config.timezones.find(function (timezone) { return timezone.offset === offset; });
    };
    /**
     * @param {?} timezone
     * @return {?}
     */
    DateTimePickerService.prototype.setTimezone = /**
     * @param {?} timezone
     * @return {?}
     */
    function (timezone) {
        this.timezone$.next(timezone);
    };
    DateTimePickerService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    DateTimePickerService.ctorParameters = function () { return [
        { type: DateTimePickerConfig, },
    ]; };
    return DateTimePickerService;
}());
/** @enum {number} */
var DatePickerMode = {
    Day: 0,
    Month: 1,
    Year: 2,
};
DatePickerMode[DatePickerMode.Day] = "Day";
DatePickerMode[DatePickerMode.Month] = "Month";
DatePickerMode[DatePickerMode.Year] = "Year";
/** @enum {number} */
var ModeDirection = {
    None: 0,
    Ascend: 1,
    Descend: 2,
};
ModeDirection[ModeDirection.None] = "None";
ModeDirection[ModeDirection.Ascend] = "Ascend";
ModeDirection[ModeDirection.Descend] = "Descend";
/** @enum {number} */
var DatePickerHeaderEvent = {
    Previous: 0,
    Next: 1,
};
DatePickerHeaderEvent[DatePickerHeaderEvent.Previous] = "Previous";
DatePickerHeaderEvent[DatePickerHeaderEvent.Next] = "Next";

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var DateTimePickerComponent = (function () {
    function DateTimePickerComponent(datepicker) {
        var _this = this;
        this.datepicker = datepicker;
        this.dateChange = new EventEmitter();
        this.timezoneChange = new EventEmitter();
        // expose enum to view
        this.DatePickerMode = DatePickerMode;
        this._subscription = new Subscription();
        var /** @type {?} */ valueChange = datepicker.selected$.pipe(distinctUntilChanged(dateComparator))
            .subscribe(function (date) { return _this.dateChange.emit(date); });
        var /** @type {?} */ timezoneChange = datepicker.timezone$.pipe(distinctUntilChanged(timezoneComparator))
            .subscribe(function (timezone) { return _this.timezoneChange.emit(timezone); });
    }
    Object.defineProperty(DateTimePickerComponent.prototype, "showDate", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.datepicker.showDate$.next(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateTimePickerComponent.prototype, "showTime", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.datepicker.showTime$.next(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateTimePickerComponent.prototype, "showTimezone", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.datepicker.showTimezone$.next(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateTimePickerComponent.prototype, "showSeconds", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.datepicker.showSeconds$.next(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateTimePickerComponent.prototype, "showMeridian", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.datepicker.showMeridian$.next(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateTimePickerComponent.prototype, "showSpinners", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.datepicker.showSpinners$.next(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateTimePickerComponent.prototype, "weekdays", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.datepicker.weekdays$.next(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateTimePickerComponent.prototype, "nowBtnText", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.datepicker.nowBtnText$.next(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateTimePickerComponent.prototype, "timezones", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.datepicker.timezones$.next(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateTimePickerComponent.prototype, "date", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (!dateComparator(value, this.datepicker.selected$.value)) {
                this.datepicker.selected$.next(new Date(value));
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DateTimePickerComponent.prototype, "timezone", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.datepicker.timezone$.next(value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    DateTimePickerComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._subscription.unsubscribe();
    };
    /**
     * Change the date to the current date and time
     */
    /**
     * Change the date to the current date and time
     * @return {?}
     */
    DateTimePickerComponent.prototype.setToNow = /**
     * Change the date to the current date and time
     * @return {?}
     */
    function () {
        // set the date to the current moment
        this.datepicker.setDateToNow();
    };
    DateTimePickerComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-date-time-picker',
                    template: "<div class=\"calendar-container\">\n\n  <ux-date-time-picker-header></ux-date-time-picker-header>\n\n  <ng-container *ngIf=\"datepicker.showDate$ | async\" [ngSwitch]=\"datepicker.mode$ | async\">\n\n      <!-- Display days in the current month -->\n      <ux-date-time-picker-day-view *ngSwitchCase=\"DatePickerMode.Day\"></ux-date-time-picker-day-view>\n\n      <!-- Display the months in the current year -->\n      <ux-date-time-picker-month-view *ngSwitchCase=\"DatePickerMode.Month\"></ux-date-time-picker-month-view>\n\n      <!-- Display a decade -->\n      <ux-date-time-picker-year-view *ngSwitchCase=\"DatePickerMode.Year\"></ux-date-time-picker-year-view>\n\n  </ng-container>\n\n  <!-- Display a Time Picker -->\n  <ux-date-time-picker-time-view *ngIf=\"datepicker.showTime$ | async\"></ux-date-time-picker-time-view>\n\n</div>\n\n<button class=\"now-button\" aria-label=\"Set date to now\" (click)=\"setToNow()\">{{ datepicker.nowBtnText$ | async }}</button>",
                    providers: [DateTimePickerService],
                    changeDetection: ChangeDetectionStrategy.OnPush
                },] },
    ];
    /** @nocollapse */
    DateTimePickerComponent.ctorParameters = function () { return [
        { type: DateTimePickerService, },
    ]; };
    DateTimePickerComponent.propDecorators = {
        "showDate": [{ type: Input },],
        "showTime": [{ type: Input },],
        "showTimezone": [{ type: Input },],
        "showSeconds": [{ type: Input },],
        "showMeridian": [{ type: Input },],
        "showSpinners": [{ type: Input },],
        "weekdays": [{ type: Input },],
        "nowBtnText": [{ type: Input },],
        "timezones": [{ type: Input },],
        "dateChange": [{ type: Output },],
        "timezoneChange": [{ type: Output },],
        "date": [{ type: Input },],
        "timezone": [{ type: Input },],
    };
    return DateTimePickerComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var DayViewService = (function () {
    function DayViewService(_datepicker) {
        var _this = this;
        this._datepicker = _datepicker;
        this.grid$ = new BehaviorSubject([[]]);
        this.focused$ = new BehaviorSubject(null);
        this._subscription = combineLatest(_datepicker.month$, _datepicker.year$)
            .subscribe(function (_a) {
            var _b = __read(_a, 2), month = _b[0], year = _b[1];
            return _this.createDayGrid(month, year);
        });
    }
    /**
     * @return {?}
     */
    DayViewService.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._subscription.unsubscribe();
    };
    /**
     * @param {?} day
     * @param {?} month
     * @param {?} year
     * @return {?}
     */
    DayViewService.prototype.setFocus = /**
     * @param {?} day
     * @param {?} month
     * @param {?} year
     * @return {?}
     */
    function (day, month, year) {
        this.focused$.next({ day: day, month: month, year: year });
        // update the date picker to show the required month and year
        this._datepicker.setViewportMonth(month);
        this._datepicker.setViewportYear(year);
    };
    /**
     * @param {?} month
     * @param {?} year
     * @return {?}
     */
    DayViewService.prototype.createDayGrid = /**
     * @param {?} month
     * @param {?} year
     * @return {?}
     */
    function (month, year) {
        var _this = this;
        // update the header
        this._datepicker.setHeader(months[month] + ' ' + year);
        // find the lower and upper boundaries
        var /** @type {?} */ start = new Date(year, month, 1);
        var /** @type {?} */ end = new Date(year, month + 1, 0);
        // we always want to show from the sunday - this may include showing some dates from the previous month
        start.setDate(start.getDate() - start.getDay());
        // we also want to make sure that the range ends on a saturday
        end.setDate(end.getDate() + (6 - end.getDay()));
        // create an array of all the days to display
        var /** @type {?} */ dates = dateRange(start, end).map(function (date) {
            return ({
                day: date.getDate(),
                month: date.getMonth(),
                year: date.getFullYear(),
                date: date,
                isToday: _this.isToday(date),
                isActive: _this.isActive(date),
                isCurrentMonth: date.getMonth() === month
            });
        });
        // turn the dates into a grid
        var /** @type {?} */ items = gridify(dates, 7);
        this.grid$.next(items);
        // if no item has yet been focused then focus the first day of the month
        if ((this._datepicker.modeDirection === ModeDirection.None || this._datepicker.modeDirection === ModeDirection.Descend) && this.focused$.value === null) {
            // check if the selected item is visible
            var /** @type {?} */ selectedDay = dates.find(function (day) { return day.isCurrentMonth && day.isActive; });
            if (selectedDay) {
                this.setFocus(selectedDay.day, selectedDay.month, selectedDay.year);
            }
            else {
                // find the first day of the month
                var /** @type {?} */ first$$1 = dates.find(function (date) { return date.day === 1; });
                // focus the date
                this.setFocus(first$$1.day, first$$1.month, first$$1.year);
            }
        }
    };
    /**
     * Determine whether or not a specific date is today
     * @param {?} date The date to check
     * @return {?}
     */
    DayViewService.prototype.isToday = /**
     * Determine whether or not a specific date is today
     * @param {?} date The date to check
     * @return {?}
     */
    function (date) {
        return compareDays(new Date(), date);
    };
    /**
     * Determines whether or not a specific date is the selected one
     * @param {?} date the date to check
     * @return {?}
     */
    DayViewService.prototype.isActive = /**
     * Determines whether or not a specific date is the selected one
     * @param {?} date the date to check
     * @return {?}
     */
    function (date) {
        return compareDays(this._datepicker.selected$.value, date);
    };
    DayViewService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    DayViewService.ctorParameters = function () { return [
        { type: DateTimePickerService, },
    ]; };
    return DayViewService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var DayViewComponent = (function () {
    function DayViewComponent(datePicker, dayService) {
        var _this = this;
        this.datePicker = datePicker;
        this.dayService = dayService;
        this._subscription = datePicker.headerEvent$
            .subscribe(function (event) { return event === DatePickerHeaderEvent.Next ? _this.next() : _this.previous(); });
    }
    /**
     * @return {?}
     */
    DayViewComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._subscription.unsubscribe();
    };
    /**
     * Navigate to the previous page of dates
     */
    /**
     * Navigate to the previous page of dates
     * @return {?}
     */
    DayViewComponent.prototype.previous = /**
     * Navigate to the previous page of dates
     * @return {?}
     */
    function () {
        this.datePicker.setViewportMonth(this.datePicker.month$.value - 1);
    };
    /**
     * Navigate to the next page of dates
     */
    /**
     * Navigate to the next page of dates
     * @return {?}
     */
    DayViewComponent.prototype.next = /**
     * Navigate to the next page of dates
     * @return {?}
     */
    function () {
        this.datePicker.setViewportMonth(this.datePicker.month$.value + 1);
    };
    /**
     * Select a particular date
     * @param date the date to select
     */
    /**
     * Select a particular date
     * @param {?} date the date to select
     * @return {?}
     */
    DayViewComponent.prototype.select = /**
     * Select a particular date
     * @param {?} date the date to select
     * @return {?}
     */
    function (date) {
        // update the current date object
        this.datePicker.setDate(date.getDate(), date.getMonth(), date.getFullYear());
        // focus the newly selected date
        this.dayService.setFocus(date.getDate(), date.getMonth(), date.getFullYear());
    };
    /**
     * @param {?} index
     * @return {?}
     */
    DayViewComponent.prototype.trackWeekByFn = /**
     * @param {?} index
     * @return {?}
     */
    function (index) {
        return index;
    };
    /**
     * @param {?} index
     * @param {?} item
     * @return {?}
     */
    DayViewComponent.prototype.trackDayByFn = /**
     * @param {?} index
     * @param {?} item
     * @return {?}
     */
    function (index, item) {
        return item.day + " " + item.month + " " + item.year;
    };
    /**
     * @param {?} item
     * @param {?} dayOffset
     * @return {?}
     */
    DayViewComponent.prototype.focusDate = /**
     * @param {?} item
     * @param {?} dayOffset
     * @return {?}
     */
    function (item, dayOffset) {
        // determine the date of the day
        var /** @type {?} */ target = new Date(item.date.setDate(item.date.getDate() + dayOffset));
        // identify which date should be focused
        this.dayService.setFocus(target.getDate(), target.getMonth(), target.getFullYear());
    };
    /**
     * @param {?} item
     * @return {?}
     */
    DayViewComponent.prototype.getTabbable = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        var /** @type {?} */ focused = this.dayService.focused$.value;
        var /** @type {?} */ grid = this.dayService.grid$.value;
        // if there is a focused month check if this is it
        if (focused) {
            // check if the focused day is visible
            var /** @type {?} */ isFocusedDayVisible = !!grid.find(function (row) { return !!row.find(function (_item) { return _item.day === focused.day && _item.month === focused.month && _item.year === focused.year; }); });
            if (isFocusedDayVisible) {
                return focused.day === item.day && focused.month === item.month && focused.year === item.year;
            }
        }
        // if there is no focusable day then check if there is a selected day
        var /** @type {?} */ isSelectedDayVisible = !!grid.find(function (row) { return !!row.find(function (day) { return day.isActive; }); });
        if (isSelectedDayVisible) {
            return item.isActive;
        }
        // otherwise make the first day tabbable
        return item.day === 1;
    };
    DayViewComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-date-time-picker-day-view',
                    template: "<table class=\"calendar\">\n    <thead>\n        <tr>\n            <th *ngFor=\"let day of datePicker.weekdays$ | async\" class=\"weekday\" [attr.aria-label]=\"day\">{{ day }}</th>\n        </tr>\n    </thead>\n\n    <tbody role=\"grid\">\n        <tr role=\"row\" *ngFor=\"let row of dayService.grid$ | async; trackBy: trackWeekByFn\">\n\n            <td *ngFor=\"let item of row; trackBy: trackDayByFn\" class=\"date-cell\" role=\"gridcell\">\n\n                <button class=\"date-button\"\n                        [focusIf]=\"(dayService.focused$ | async)?.day === item.day && (dayService.focused$ | async)?.month === item.month && (dayService.focused$ | async)?.year === item.year\"\n                        [attr.aria-label]=\"item.date | date\"\n                        [attr.aria-selected]=\"item.isActive\"\n                        [attr.aria-hidden]=\"!item.isCurrentMonth\"\n                        [class.current]=\"item.isToday\"\n                        [class.active]=\"item.isActive\"\n                        [class.preview]=\"!item.isCurrentMonth\"\n                        [tabindex]=\"getTabbable(item) ? 0 : -1\"\n                        (click)=\"select(item.date); $event.stopPropagation()\"\n                        (keydown.ArrowLeft)=\"focusDate(item, -1); $event.preventDefault()\"\n                        (keydown.ArrowRight)=\"focusDate(item, 1); $event.preventDefault()\"\n                        (keydown.ArrowUp)=\"focusDate(item, -7); $event.preventDefault()\"\n                        (keydown.ArrowDown)=\"focusDate(item, 7); $event.preventDefault()\">\n\n                    {{ item.date.getDate() }}\n                </button>\n\n            </td>\n        </tr>\n    </tbody>\n</table>",
                    providers: [DayViewService],
                    changeDetection: ChangeDetectionStrategy.OnPush
                },] },
    ];
    /** @nocollapse */
    DayViewComponent.ctorParameters = function () { return [
        { type: DateTimePickerService, },
        { type: DayViewService, },
    ]; };
    return DayViewComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var HeaderComponent = (function () {
    function HeaderComponent(datepicker) {
        this.datepicker = datepicker;
        this.canAscend$ = this.datepicker.mode$.pipe(map(function (mode) { return mode !== DatePickerMode.Year; }));
        this.mode$ = this.datepicker.mode$.pipe(map(function (mode) {
            switch (mode) {
                case DatePickerMode.Day:
                    return 'Day';
                case DatePickerMode.Month:
                    return 'Month';
                case DatePickerMode.Year:
                    return 'Year';
            }
        }));
        this.headerAria$ = this.datepicker.mode$.pipe(map(function (mode) {
            switch (mode) {
                case DatePickerMode.Day:
                    return 'Switch to show months in the year';
                case DatePickerMode.Month:
                    return 'Switch to show years in the decade';
                case DatePickerMode.Year:
                    return '';
            }
        }));
        this.previousAria$ = this.datepicker.mode$.pipe(map(function (mode) {
            switch (mode) {
                case DatePickerMode.Day:
                    return 'Previous month';
                case DatePickerMode.Month:
                    return 'Previous year';
                case DatePickerMode.Year:
                    return 'Previous decade';
            }
        }));
        this.nextAria$ = this.datepicker.mode$.pipe(map(function (mode) {
            switch (mode) {
                case DatePickerMode.Day:
                    return 'Next month';
                case DatePickerMode.Month:
                    return 'Next year';
                case DatePickerMode.Year:
                    return 'Next decade';
            }
        }));
    }
    /**
     * @return {?}
     */
    HeaderComponent.prototype.previous = /**
     * @return {?}
     */
    function () {
        this.datepicker.goToPrevious();
    };
    /**
     * @return {?}
     */
    HeaderComponent.prototype.ascend = /**
     * @return {?}
     */
    function () {
        this.datepicker.goToParentMode();
    };
    /**
     * @return {?}
     */
    HeaderComponent.prototype.next = /**
     * @return {?}
     */
    function () {
        this.datepicker.goToNext();
    };
    HeaderComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-date-time-picker-header',
                    template: "<header class=\"header\">\n\n  <button class=\"header-navigation\"\n          (click)=\"previous(); $event.stopPropagation()\"\n          [attr.aria-label]=\"previousAria$ | async\"\n          tabindex=\"0\">\n\n    <i class=\"hpe-icon hpe-previous\"></i>\n  </button>\n\n  <button class=\"header-title\"\n          [attr.aria-label]=\"headerAria$ | async\"\n          [class.active]=\"canAscend$ | async\"\n          (click)=\"ascend(); $event.stopPropagation()\"\n          [tabindex]=\"(canAscend$ | async) ? 0 : -1\">\n       {{ datepicker.header$ | async }}\n  </button>\n\n  <button class=\"header-navigation\"\n          (click)=\"next(); $event.stopPropagation()\"\n          [attr.aria-label]=\"nextAria$ | async\"\n          tabindex=\"0\">\n\n    <i class=\"hpe-icon hpe-next\"></i>\n  </button>\n</header>",
                    changeDetection: ChangeDetectionStrategy.OnPush
                },] },
    ];
    /** @nocollapse */
    HeaderComponent.ctorParameters = function () { return [
        { type: DateTimePickerService, },
    ]; };
    return HeaderComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var MonthViewService = (function () {
    function MonthViewService(_datepicker) {
        var _this = this;
        this._datepicker = _datepicker;
        this.grid$ = new BehaviorSubject([[]]);
        this.focused$ = new BehaviorSubject(null);
        this._subscription = _datepicker.year$.subscribe(function (year) { return _this.createMonthGrid(year); });
    }
    /**
     * @return {?}
     */
    MonthViewService.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._subscription.unsubscribe();
    };
    /**
     * @param {?} month
     * @param {?} year
     * @return {?}
     */
    MonthViewService.prototype.setFocus = /**
     * @param {?} month
     * @param {?} year
     * @return {?}
     */
    function (month, year) {
        this.focused$.next({ month: month, year: year });
        // update the viewport to ensure focused month is visible
        this._datepicker.setViewportYear(year);
    };
    /**
     * @param {?} year
     * @return {?}
     */
    MonthViewService.prototype.createMonthGrid = /**
     * @param {?} year
     * @return {?}
     */
    function (year) {
        // update the header
        this._datepicker.setHeader(year.toString());
        // get the current year and month
        var /** @type {?} */ currentMonth = new Date().getMonth();
        var /** @type {?} */ currentYear = new Date().getFullYear();
        // get the currently selected month
        var /** @type {?} */ activeMonth = this._datepicker.selected$.value.getMonth();
        var /** @type {?} */ activeYear = this._datepicker.selected$.value.getFullYear();
        // create a 4x3 grid of month numbers
        var /** @type {?} */ months$$1 = range(0, 11).map(function (month) {
            return {
                name: monthsShort[month],
                month: month,
                year: year,
                isCurrentMonth: year === currentYear && month === currentMonth,
                isActiveMonth: year === activeYear && month === activeMonth
            };
        });
        // map these to the appropriate format
        var /** @type {?} */ items = gridify(months$$1, 4);
        // update the grid
        this.grid$.next(items);
        // if there is no focused month select the first one
        if (this._datepicker.modeDirection === ModeDirection.Descend && this.focused$.value === null) {
            // check if the selected month is in view
            var /** @type {?} */ selectedMonth = months$$1.find(function (month) { return month.isActiveMonth; });
            this.setFocus(selectedMonth ? selectedMonth.month : 0, year);
        }
    };
    MonthViewService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    MonthViewService.ctorParameters = function () { return [
        { type: DateTimePickerService, },
    ]; };
    return MonthViewService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var MonthViewComponent = (function () {
    function MonthViewComponent(_datePicker, monthService) {
        var _this = this;
        this._datePicker = _datePicker;
        this.monthService = monthService;
        this._subscription = _datePicker.headerEvent$
            .subscribe(function (event) { return event === DatePickerHeaderEvent.Next ? _this.next() : _this.previous(); });
    }
    /**
     * @return {?}
     */
    MonthViewComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._subscription.unsubscribe();
    };
    /**
     * Go to the previous year
     */
    /**
     * Go to the previous year
     * @return {?}
     */
    MonthViewComponent.prototype.previous = /**
     * Go to the previous year
     * @return {?}
     */
    function () {
        this._datePicker.setViewportYear(this._datePicker.year$.value - 1);
    };
    /**
     * Go to the next year
     */
    /**
     * Go to the next year
     * @return {?}
     */
    MonthViewComponent.prototype.next = /**
     * Go to the next year
     * @return {?}
     */
    function () {
        this._datePicker.setViewportYear(this._datePicker.year$.value + 1);
    };
    /**
     * Select a month in the calendar
     * @param month the index of the month to select
     */
    /**
     * Select a month in the calendar
     * @param {?} month the index of the month to select
     * @return {?}
     */
    MonthViewComponent.prototype.select = /**
     * Select a month in the calendar
     * @param {?} month the index of the month to select
     * @return {?}
     */
    function (month) {
        this._datePicker.setViewportMonth(month);
        // show the day picker
        this._datePicker.goToChildMode();
    };
    /**
     * @param {?} item
     * @param {?} monthOffset
     * @return {?}
     */
    MonthViewComponent.prototype.focusMonth = /**
     * @param {?} item
     * @param {?} monthOffset
     * @return {?}
     */
    function (item, monthOffset) {
        var /** @type {?} */ targetMonth = item.month + monthOffset;
        var /** @type {?} */ targetYear = item.year;
        if (targetMonth < 0) {
            targetMonth += 12;
            targetYear -= 1;
        }
        if (targetMonth >= 12) {
            targetMonth -= 12;
            targetYear += 1;
        }
        this.monthService.setFocus(targetMonth, targetYear);
    };
    /**
     * @param {?} index
     * @return {?}
     */
    MonthViewComponent.prototype.trackRowByFn = /**
     * @param {?} index
     * @return {?}
     */
    function (index) {
        return index;
    };
    /**
     * @param {?} index
     * @param {?} item
     * @return {?}
     */
    MonthViewComponent.prototype.trackMonthByFn = /**
     * @param {?} index
     * @param {?} item
     * @return {?}
     */
    function (index, item) {
        return item.month + " " + item.year;
    };
    /**
     * @param {?} item
     * @return {?}
     */
    MonthViewComponent.prototype.getTabbable = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        var /** @type {?} */ focused = this.monthService.focused$.value;
        var /** @type {?} */ grid = this.monthService.grid$.value;
        // if there is a focused month check if this is it
        if (focused) {
            // check if the focused month is visible
            var /** @type {?} */ isFocusedMonthVisible = !!grid.find(function (row) { return !!row.find(function (_item) { return _item.month === focused.month && _item.year === focused.year; }); });
            if (isFocusedMonthVisible) {
                return focused.month === item.month && focused.year === item.year;
            }
        }
        // if there is no focusable month then check if there is a selected month
        var /** @type {?} */ isSelectedMonthVisible = !!grid.find(function (row) { return !!row.find(function (month) { return month.isActiveMonth; }); });
        if (isSelectedMonthVisible) {
            return item.isActiveMonth;
        }
        // otherwise make the first month tabbable
        return item.month === 0;
    };
    MonthViewComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-date-time-picker-month-view',
                    template: "<div class=\"calendar\" role=\"grid\">\n  <div class=\"calendar-row\" *ngFor=\"let row of monthService.grid$ | async; trackBy: trackRowByFn\" role=\"row\">\n\n    <button role=\"gridcell\"\n         class=\"calendar-item\"\n         *ngFor=\"let item of row; trackBy: trackMonthByFn\"\n         [focusIf]=\"(monthService.focused$ | async)?.month === item.month && (monthService.focused$ | async)?.year === item.year\"\n         [tabindex]=\"getTabbable(item) ? 0 : -1\"\n         [attr.aria-label]=\"item.name + ' ' + item.year\"\n         [attr.aria-selected]=\"item.isActiveMonth\"\n         [class.active]=\"item.isActiveMonth\"\n         [class.current]=\"item.isCurrentMonth\"\n         (click)=\"select(item.month); $event.stopPropagation()\"\n         (keydown.ArrowLeft)=\"focusMonth(item, -1); $event.preventDefault()\"\n         (keydown.ArrowRight)=\"focusMonth(item, 1); $event.preventDefault()\"\n         (keydown.ArrowUp)=\"focusMonth(item, -4); $event.preventDefault()\"\n         (keydown.ArrowDown)=\"focusMonth(item, 4); $event.preventDefault()\">\n         {{ item.name }}\n    </button>\n  </div>\n</div>\n",
                    providers: [MonthViewService],
                    changeDetection: ChangeDetectionStrategy.OnPush
                },] },
    ];
    /** @nocollapse */
    MonthViewComponent.ctorParameters = function () { return [
        { type: DateTimePickerService, },
        { type: MonthViewService, },
    ]; };
    return MonthViewComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var TimeViewComponent = (function () {
    function TimeViewComponent(datepicker) {
        this.datepicker = datepicker;
    }
    /**
     * @param {?} name
     * @return {?}
     */
    TimeViewComponent.prototype.selectTimezone = /**
     * @param {?} name
     * @return {?}
     */
    function (name) {
        var /** @type {?} */ timezones = this.datepicker.timezones$.value;
        // find matching timezone
        var /** @type {?} */ timezone = timezones.find(function (_timezone) { return _timezone.name === name; });
        if (timezone) {
            this.datepicker.setTimezone(timezone);
        }
    };
    /**
     * @return {?}
     */
    TimeViewComponent.prototype.incrementTimezone = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ timezone = this.datepicker.timezone$.value;
        var /** @type {?} */ timezones = this.datepicker.timezones$.value;
        var /** @type {?} */ currentZone = timezones.findIndex(function (zone) { return zone.name === timezone.name && zone.offset === timezone.offset; });
        // try to get the previous zone
        this.datepicker.setTimezone(timezones[currentZone + 1] ? timezones[currentZone + 1] : timezones[currentZone]);
    };
    /**
     * @return {?}
     */
    TimeViewComponent.prototype.decrementTimezone = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ timezone = this.datepicker.timezone$.value;
        var /** @type {?} */ timezones = this.datepicker.timezones$.value;
        var /** @type {?} */ currentZone = timezones.findIndex(function (zone) { return zone.name === timezone.name && zone.offset === timezone.offset; });
        // try to get the previous zone
        this.datepicker.setTimezone(timezones[currentZone - 1] ? timezones[currentZone - 1] : timezones[currentZone]);
    };
    TimeViewComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-date-time-picker-time-view',
                    template: "<ux-time-picker *ngIf=\"datepicker.showTime$ | async\"\n    [value]=\"datepicker.selected$ | async\"\n    (valueChange)=\"datepicker.selected$.next($event)\"\n    [showSeconds]=\"datepicker.showSeconds$ | async\"\n    [showMeridian]=\"datepicker.showMeridian$ | async\"\n    [showSpinners]=\"datepicker.showSpinners$ | async\">\n</ux-time-picker>\n\n<ng-container *ngIf=\"datepicker.showTimezone$ | async\">\n\n    <div class=\"time-zone-picker\" *ngIf=\"datepicker.showSpinners$ | async\">\n\n        <ux-spin-button\n            class=\"time-zone-spinner\"\n            [value]=\"(datepicker.timezone$ | async).name\"\n            [readOnly]=\"true\"\n            (increment)=\"incrementTimezone()\"\n            (decrement)=\"decrementTimezone()\"\n            inputAriaLabel=\"Time Zone\"\n            incrementAriaLabel=\"Switch to the next time zone\"\n            decrementAriaLabel=\"Switch to the previous time zone\">\n        </ux-spin-button>\n    </div>\n\n    <div class=\"time-zone-picker\" *ngIf=\"!(datepicker.showSpinners$ | async)\">\n\n        <select class=\"form-control time-zone-select\"\n                tabindex=\"0\"\n                [ngModel]=\"(datepicker.timezone$ | async).name\"\n                (ngModelChange)=\"selectTimezone($event)\"\n                aria-label=\"Timezone\"\n                [attr.aria-valuenow]=\"(datepicker.timezone$ | async).name\">\n\n            <option *ngFor=\"let zone of datepicker.timezones$ | async\"\n                    [selected]=\"zone.name === (datepicker.timezone$ | async).name\"\n                    [value]=\"zone.name\">\n                {{ zone?.name }}\n            </option>\n\n        </select>\n    </div>\n\n</ng-container>\n",
                    changeDetection: ChangeDetectionStrategy.OnPush
                },] },
    ];
    /** @nocollapse */
    TimeViewComponent.ctorParameters = function () { return [
        { type: DateTimePickerService, },
    ]; };
    return TimeViewComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var YearViewService = (function () {
    function YearViewService(_datepicker) {
        var _this = this;
        this._datepicker = _datepicker;
        this.grid$ = new BehaviorSubject([[]]);
        this.focused$ = new BehaviorSubject(null);
        this._year = new Date().getFullYear();
        this._subscription = new Subscription();
        var /** @type {?} */ year = _datepicker.year$.subscribe(function (_year) { return _this.createYearGrid(_year); });
        var /** @type {?} */ event = _datepicker.headerEvent$
            .subscribe(function (_event) { return _event === DatePickerHeaderEvent.Next ? _this.goToNextDecade() : _this.goToPreviousDecade(); });
        this._subscription.add(year);
        this._subscription.add(event);
    }
    /**
     * @return {?}
     */
    YearViewService.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._subscription.unsubscribe();
    };
    /**
     * @param {?} year
     * @return {?}
     */
    YearViewService.prototype.setFocus = /**
     * @param {?} year
     * @return {?}
     */
    function (year) {
        this.focused$.next(year);
        this.createYearGrid(year);
    };
    /**
     * @return {?}
     */
    YearViewService.prototype.goToPreviousDecade = /**
     * @return {?}
     */
    function () {
        this.createYearGrid(this._year - 10);
    };
    /**
     * @return {?}
     */
    YearViewService.prototype.goToNextDecade = /**
     * @return {?}
     */
    function () {
        this.createYearGrid(this._year + 10);
    };
    /**
     * @param {?=} year
     * @return {?}
     */
    YearViewService.prototype.createYearGrid = /**
     * @param {?=} year
     * @return {?}
     */
    function (year) {
        var _this = this;
        if (year === void 0) { year = this._year; }
        this._year = year;
        // get the years to display
        var /** @type {?} */ decade = this.getDecade(year);
        var /** @type {?} */ currentYear = new Date().getFullYear();
        // produce items in the correct format
        var /** @type {?} */ items = decade.range.map(function (_year) {
            return {
                year: _year,
                isCurrentYear: _year === currentYear,
                isActiveYear: _year === _this._datepicker.year$.value
            };
        });
        // update the header text
        this._datepicker.setHeader(decade.start + ' - ' + decade.end);
        // create the grid
        this.grid$.next(gridify(items, 4));
    };
    /**
     * Get the years in the current decade to display
     * @param {?} year
     * @return {?}
     */
    YearViewService.prototype.getDecade = /**
     * Get the years in the current decade to display
     * @param {?} year
     * @return {?}
     */
    function (year) {
        // figure the start and end points
        var /** @type {?} */ start = (year - (year % 10));
        var /** @type {?} */ end = start + 9;
        // create an array containing all the numbers between the start and end points
        return { start: start, end: end, range: range(start, end) };
    };
    YearViewService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    YearViewService.ctorParameters = function () { return [
        { type: DateTimePickerService, },
    ]; };
    return YearViewService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var YearViewComponent = (function () {
    function YearViewComponent(_datePicker, yearService) {
        this._datePicker = _datePicker;
        this.yearService = yearService;
    }
    /**
     * @param {?} year
     * @return {?}
     */
    YearViewComponent.prototype.select = /**
     * @param {?} year
     * @return {?}
     */
    function (year) {
        this._datePicker.setViewportYear(year);
        // show the month picker
        this._datePicker.goToChildMode();
    };
    /**
     * @param {?} item
     * @param {?} yearOffset
     * @return {?}
     */
    YearViewComponent.prototype.focusYear = /**
     * @param {?} item
     * @param {?} yearOffset
     * @return {?}
     */
    function (item, yearOffset) {
        this.yearService.setFocus(item.year + yearOffset);
    };
    /**
     * @param {?} index
     * @return {?}
     */
    YearViewComponent.prototype.trackRowByFn = /**
     * @param {?} index
     * @return {?}
     */
    function (index) {
        return index;
    };
    /**
     * @param {?} index
     * @param {?} item
     * @return {?}
     */
    YearViewComponent.prototype.trackYearByFn = /**
     * @param {?} index
     * @param {?} item
     * @return {?}
     */
    function (index, item) {
        return item.year;
    };
    /**
     * @param {?} item
     * @return {?}
     */
    YearViewComponent.prototype.getTabbable = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        var /** @type {?} */ focused = this.yearService.focused$.value;
        var /** @type {?} */ grid = this.yearService.grid$.value;
        // if there is a focused year check if this is it
        if (focused) {
            // check if the focused year is visible
            var /** @type {?} */ isFocusedYearVisible = !!grid.find(function (row) { return !!row.find(function (_item) { return _item.year === focused; }); });
            if (isFocusedYearVisible) {
                return focused === item.year;
            }
        }
        // if there is no focusable year then check if there is a selected year
        var /** @type {?} */ isSelectedYearVisible = !!grid.find(function (row) { return !!row.find(function (year) { return year.isActiveYear; }); });
        if (isSelectedYearVisible) {
            return item.isActiveYear;
        }
        // otherwise make the first month tabbable
        return grid[0][0].year === item.year;
    };
    YearViewComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-date-time-picker-year-view',
                    template: "<div class=\"calendar\" role=\"grid\">\n  <div class=\"calendar-row\" role=\"row\" *ngFor=\"let row of yearService.grid$ | async; trackBy: trackRowByFn\">\n\n    <button *ngFor=\"let item of row; trackBy: trackYearByFn\"\n         role=\"gridcell\"\n         class=\"calendar-item\"\n         [focusIf]=\"(yearService.focused$ | async) === item.year\"\n         [attr.aria-label]=\"item.year\"\n         [attr.aria-selected]=\"item.isActiveYear\"\n         [class.current]=\"item.isCurrentYear\"\n         [class.active]=\"item.isActiveYear\"\n         (click)=\"select(item.year); $event.stopPropagation()\"\n         (keydown.ArrowLeft)=\"focusYear(item, -1); $event.preventDefault()\"\n         (keydown.ArrowRight)=\"focusYear(item, 1); $event.preventDefault()\"\n         (keydown.ArrowUp)=\"focusYear(item, -4); $event.preventDefault()\"\n         (keydown.ArrowDown)=\"focusYear(item, 4); $event.preventDefault()\"\n         [tabindex]=\"getTabbable(item) ? 0 : -1\">\n         {{ item.year }}\n    </button>\n  </div>\n</div>\n",
                    providers: [YearViewService],
                    changeDetection: ChangeDetectionStrategy.OnPush
                },] },
    ];
    /** @nocollapse */
    YearViewComponent.ctorParameters = function () { return [
        { type: DateTimePickerService, },
        { type: YearViewService, },
    ]; };
    return YearViewComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var FocusIfDirective = (function () {
    function FocusIfDirective(_elementRef) {
        this._elementRef = _elementRef;
        this.focusIfDelay = 0;
        this._timeout = null;
    }
    Object.defineProperty(FocusIfDirective.prototype, "focusIf", {
        set: /**
         * @param {?} focus
         * @return {?}
         */
        function (focus) {
            var _this = this;
            // if a timeout is pending then cancel it
            if (!focus && this._timeout !== null) {
                clearTimeout(this._timeout);
                this._timeout = null;
            }
            if (focus && this._timeout === null) {
                this._timeout = window.setTimeout(function () {
                    _this._elementRef.nativeElement.focus();
                    _this._timeout = null;
                }, this.focusIfDelay);
            }
        },
        enumerable: true,
        configurable: true
    });
    FocusIfDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[focusIf]'
                },] },
    ];
    /** @nocollapse */
    FocusIfDirective.ctorParameters = function () { return [
        { type: ElementRef, },
    ]; };
    FocusIfDirective.propDecorators = {
        "focusIfDelay": [{ type: Input },],
        "focusIf": [{ type: Input },],
    };
    return FocusIfDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var FocusIfModule = (function () {
    function FocusIfModule() {
    }
    FocusIfModule.decorators = [
        { type: NgModule, args: [{
                    exports: [FocusIfDirective],
                    declarations: [FocusIfDirective]
                },] },
    ];
    /** @nocollapse */
    FocusIfModule.ctorParameters = function () { return []; };
    return FocusIfModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var DateTimePickerModule = (function () {
    function DateTimePickerModule() {
    }
    DateTimePickerModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        FormsModule,
                        TimePickerModule,
                        SpinButtonModule,
                        FocusIfModule
                    ],
                    exports: [DateTimePickerComponent],
                    declarations: [DateTimePickerComponent, HeaderComponent, DayViewComponent, MonthViewComponent, YearViewComponent, TimeViewComponent],
                    providers: [
                        DateTimePickerConfig
                    ]
                },] },
    ];
    /** @nocollapse */
    DateTimePickerModule.ctorParameters = function () { return []; };
    return DateTimePickerModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var EboxComponent = (function () {
    function EboxComponent() {
    }
    EboxComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-ebox',
                    template: "<div class=\"ux-ebox-header\">\n    <ng-content select=\"ux-ebox-header\"></ng-content>\n</div>\n\n<div class=\"ux-ebox-content\">\n    <ng-content select=\"ux-ebox-content\"></ng-content>\n</div>",
                    changeDetection: ChangeDetectionStrategy.OnPush
                },] },
    ];
    /** @nocollapse */
    EboxComponent.ctorParameters = function () { return []; };
    return EboxComponent;
}());
var EboxHeaderDirective = (function () {
    function EboxHeaderDirective() {
    }
    EboxHeaderDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'ux-ebox-header'
                },] },
    ];
    /** @nocollapse */
    EboxHeaderDirective.ctorParameters = function () { return []; };
    return EboxHeaderDirective;
}());
var EboxContentDirective = (function () {
    function EboxContentDirective() {
    }
    EboxContentDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'ux-ebox-content'
                },] },
    ];
    /** @nocollapse */
    EboxContentDirective.ctorParameters = function () { return []; };
    return EboxContentDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var EboxModule = (function () {
    function EboxModule() {
    }
    EboxModule.decorators = [
        { type: NgModule, args: [{
                    exports: [EboxComponent, EboxContentDirective, EboxHeaderDirective],
                    declarations: [EboxComponent, EboxContentDirective, EboxHeaderDirective]
                },] },
    ];
    /** @nocollapse */
    EboxModule.ctorParameters = function () { return []; };
    return EboxModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var FacetSelect = (function () {
    function FacetSelect(facet) {
        this.facet = facet;
    }
    return FacetSelect;
}());
var FacetDeselect = (function () {
    function FacetDeselect(facet) {
        this.facet = facet;
    }
    return FacetDeselect;
}());
var FacetDeselectAll = (function () {
    function FacetDeselectAll() {
    }
    return FacetDeselectAll;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var FacetContainerComponent = (function () {
    function FacetContainerComponent() {
        this.header = 'Selected:';
        this.clearTooltip = 'Clear All';
        this.emptyText = 'No Items';
        this.facets = [];
        this.facetsReorderable = false;
        this.facetsChange = new EventEmitter();
        this.events = new EventEmitter();
    }
    /**
     * @param {?} facet
     * @return {?}
     */
    FacetContainerComponent.prototype.selectFacet = /**
     * @param {?} facet
     * @return {?}
     */
    function (facet) {
        // push the facet on to the list
        this.facets.push(facet);
        // update the two way binding
        this.facetsChange.emit(this.facets);
        // trigger event
        this.triggerEvent(new FacetSelect(facet));
    };
    /**
     * @param {?} facet
     * @return {?}
     */
    FacetContainerComponent.prototype.deselectFacet = /**
     * @param {?} facet
     * @return {?}
     */
    function (facet) {
        // find the index of the item in the selected array
        var /** @type {?} */ idx = this.facets.findIndex(function (selectedFacet) { return facet === selectedFacet; });
        // if match there was no match then finish
        if (idx === -1) {
            return;
        }
        // remove the last item
        this.facets.splice(idx, 1);
        // update the two way binding
        this.facetsChange.emit(this.facets);
        // trigger event
        this.triggerEvent(new FacetDeselect(facet));
    };
    /**
     * @return {?}
     */
    FacetContainerComponent.prototype.deselectAllFacets = /**
     * @return {?}
     */
    function () {
        // empty the selected array
        this.facets = [];
        // update the two way binding
        this.facetsChange.emit(this.facets);
        // trigger event
        this.triggerEvent(new FacetDeselectAll());
    };
    /**
     * @param {?} event
     * @return {?}
     */
    FacetContainerComponent.prototype.triggerEvent = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.events.next(event);
    };
    FacetContainerComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-facet-container',
                    template: "<!-- Display Any Selected Facets -->\n<div class=\"facets-selected-container\">\n\n    <!-- Display Title an Clear Button -->\n    <div class=\"facets-selected-header-container\">\n\n        <!-- Show The Selected Text -->\n        <span class=\"facets-selected-header-label\">{{ header }}</span>\n\n        <!-- Add a Clear Button -->\n        <div class=\"facets-selected-clear-button\" tabindex=\"0\" [uxTooltip]=\"clearTooltip\" placement=\"left\" (click)=\"deselectAllFacets()\"\n            (keyup.enter)=\"deselectAllFacets()\" *ngIf=\"facets.length > 0\">\n\n            <svg class=\"facets-selected-clear-graphic\" viewBox=\"0 0 19 12\" shape-rendering=\"geometricPrecision\">\n                <rect class=\"light-grey\" x=\"0\" y=\"2\" width=\"7\" height=\"2\"></rect>\n                <rect class=\"dark-grey\" x=\"0\" y=\"5\" width=\"9\" height=\"2\"></rect>\n                <rect class=\"light-grey\" x=\"0\" y=\"8\" width=\"7\" height=\"2\"></rect>\n                <path class=\"dark-grey\" d=\"M9,1 h1 l9,9 v1 h-1 l-9,-9 v-1 Z\"></path>\n                <path class=\"dark-grey\" d=\"M9,11 v-1 l9,-9 h1 v1 l-9,9 h-1 Z\"></path>\n            </svg>\n        </div>\n\n    </div>\n\n    <!-- Display Tags For Selected Items -->\n    <div class=\"facets-selected-list\" uxReorderable [reorderingDisabled]=\"!facetsReorderable\" [(reorderableModel)]=\"facets\" (reorderableModelChange)=\"facetsChange.emit(facets)\">\n\n        <!-- Show Selected Tags -->\n        <div class=\"facet-selected-tag\" tabindex=\"0\" *ngFor=\"let facet of facets\" (mousedown)=\"$event.preventDefault()\" (click)=\"deselectFacet(facet)\" (keyup.enter)=\"deselectFacet(facet)\"\n             [uxReorderableModel]=\"facet\">\n\n            <!-- Display Label -->\n            <span class=\"facet-selected-tag-label\" uxReorderableHandle>{{ facet.title }}</span>\n\n            <!-- Display Remove Icon -->\n            <span class=\"hpe-icon hpe-close\"></span>\n        </div>\n\n    </div>\n\n    <!-- Show Message Here if No Facets Selected -->\n    <p class=\"facets-selected-none-label\" *ngIf=\"emptyText && facets.length === 0\">{{ emptyText }}</p>\n\n</div>\n\n<!-- Any Facet Elements Should be Added Here By User -->\n<div class=\"facets-region\">\n    <ng-content></ng-content>\n</div>"
                },] },
    ];
    /** @nocollapse */
    FacetContainerComponent.ctorParameters = function () { return []; };
    FacetContainerComponent.propDecorators = {
        "header": [{ type: Input },],
        "clearTooltip": [{ type: Input },],
        "emptyText": [{ type: Input },],
        "facets": [{ type: Input },],
        "facetsReorderable": [{ type: Input },],
        "facetsChange": [{ type: Output },],
        "events": [{ type: Output },],
    };
    return FacetContainerComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var FacetBaseComponent = (function () {
    function FacetBaseComponent(facetContainer, _elementRef) {
        var _this = this;
        this.facetContainer = facetContainer;
        this._elementRef = _elementRef;
        this.selected = [];
        this.selectedChange = new EventEmitter();
        this.events = new Subject();
        this._onDestroy = new Subject();
        if (facetContainer) {
            // subscribe to any deselect events from the facet container
            facetContainer.events.pipe(filter(function (event) { return event instanceof FacetDeselect; }), filter(function (event) { return !!_this.selected.find(function (facet) { return facet === event.facet; }); }), takeUntil(this._onDestroy)).subscribe(function (event) { return _this.deselectFacet(event.facet); });
            // subscribe to any deselect all events from facet container
            facetContainer.events.pipe(filter(function (event) { return event instanceof FacetDeselectAll; }), takeUntil(this._onDestroy)).subscribe(function (_) { return _this.deselectAll(); });
        }
    }
    /**
     * @return {?}
     */
    FacetBaseComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // check if there should be any facets initially selected
        if (this.facetContainer) {
            this.selected.forEach(function (facet) { return _this.facetContainer.selectFacet(facet); });
        }
    };
    /**
     * @return {?}
     */
    FacetBaseComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._onDestroy.next();
        this._onDestroy.complete();
    };
    /**
     * @param {?} facet
     * @return {?}
     */
    FacetBaseComponent.prototype.selectFacet = /**
     * @param {?} facet
     * @return {?}
     */
    function (facet) {
        // if the facet is disabled it should not be selected
        if (facet.disabled) {
            return;
        }
        // add the facet to the list of selected facets
        this.selected.push(facet);
        // send the new value to the event emitter
        this.selectedChange.emit(this.selected);
        // fire the event to the observable
        this.triggerEvent(new FacetSelect(facet));
        // tell the facet container about the selected facet
        if (this.facetContainer) {
            this.facetContainer.selectFacet(facet);
        }
    };
    /**
     * @param {?} facet
     * @return {?}
     */
    FacetBaseComponent.prototype.deselectFacet = /**
     * @param {?} facet
     * @return {?}
     */
    function (facet) {
        // find facet to remove
        var /** @type {?} */ index = this.selected.findIndex(function (selectedFacet) { return selectedFacet === facet; });
        // only continue if facet is found
        if (index !== -1) {
            // remove the facet from the selected list
            this.selected.splice(index, 1);
            // emit the changes to selected event emitter
            this.selectedChange.emit(this.selected);
            // fire the event to the observable
            this.triggerEvent(new FacetDeselect(facet));
            // deselect the facet in the facet container
            if (this.facetContainer) {
                this.facetContainer.deselectFacet(facet);
            }
        }
    };
    /**
     * @return {?}
     */
    FacetBaseComponent.prototype.deselectAll = /**
     * @return {?}
     */
    function () {
        // remove all selected facets
        this.selected = [];
        // fire the event to the observable
        this.triggerEvent(new FacetDeselectAll());
        // emit the changes to the selected event emitter
        this.selectedChange.emit(this.selected);
    };
    /**
     * @param {?} facet
     * @return {?}
     */
    FacetBaseComponent.prototype.toggleFacetSelection = /**
     * @param {?} facet
     * @return {?}
     */
    function (facet) {
        // if the facet is selected then deselect - otherwise select it
        if (this.isFacetSelected(facet)) {
            this.deselectFacet(facet);
        }
        else {
            this.selectFacet(facet);
        }
    };
    /**
     * @param {?} facet
     * @return {?}
     */
    FacetBaseComponent.prototype.isFacetSelected = /**
     * @param {?} facet
     * @return {?}
     */
    function (facet) {
        // determine if a facet is currently selected
        return !!this.selected.find(function (selectedFacet) { return selectedFacet === facet; });
    };
    /**
     * @param {?} event
     * @return {?}
     */
    FacetBaseComponent.prototype.triggerEvent = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.events.next(event);
    };
    FacetBaseComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-facet-base',
                    template: '',
                },] },
    ];
    /** @nocollapse */
    FacetBaseComponent.ctorParameters = function () { return [
        { type: FacetContainerComponent, decorators: [{ type: Host },] },
        { type: ElementRef, },
    ]; };
    FacetBaseComponent.propDecorators = {
        "selected": [{ type: Input },],
        "selectedChange": [{ type: Output },],
        "events": [{ type: Output },],
    };
    return FacetBaseComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var FacetHeaderComponent = (function () {
    function FacetHeaderComponent() {
        this.canExpand = true;
        this.expanded = true;
        this.expandedChange = new EventEmitter();
    }
    /**
     * @return {?}
     */
    FacetHeaderComponent.prototype.toggleExpand = /**
     * @return {?}
     */
    function () {
        // if not expandable then do nothing
        if (this.canExpand) {
            this.expanded = !this.expanded;
            this.expandedChange.emit(this.expanded);
        }
    };
    FacetHeaderComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-facet-header',
                    template: "<span class=\"facet-header-title\">{{ header }}</span>\n<span class=\"hpe-icon\" [class.hpe-down]=\"expanded\" [class.hpe-previous]=\"!expanded\" *ngIf=\"canExpand\"></span>",
                    host: {
                        'tabindex': '0',
                        '(click)': 'toggleExpand()',
                        '(keyup.enter)': 'toggleExpand()'
                    }
                },] },
    ];
    /** @nocollapse */
    FacetHeaderComponent.ctorParameters = function () { return []; };
    FacetHeaderComponent.propDecorators = {
        "header": [{ type: Input },],
        "canExpand": [{ type: Input },],
        "expanded": [{ type: Input },],
        "expandedChange": [{ type: Output },],
    };
    return FacetHeaderComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var FacetCheckListComponent = (function (_super) {
    __extends(FacetCheckListComponent, _super);
    function FacetCheckListComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.facets = [];
        _this.scrollbar = true;
        _this.expanded = true;
        return _this;
    }
    FacetCheckListComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-facet-check-list',
                    template: "<ux-facet-header [header]=\"header\" [(expanded)]=\"expanded\"></ux-facet-header>\n\n<!-- Create a container which will show when section is expanded -->\n<div class=\"facet-check-list-container\" [class.facet-check-list-scrollbar]=\"scrollbar\" *ngIf=\"expanded\">\n\n    <!-- Iterate through each possible facet -->\n    <div class=\"facet-check-list-item\" *ngFor=\"let facet of facets\" [class.facet-active]=\"isFacetSelected(facet)\" tabindex=\"0\"\n        (click)=\"toggleFacetSelection(facet)\" (keyup.enter)=\"toggleFacetSelection(facet)\" [class.disabled]=\"facet.disabled\">\n\n        <!-- Show check icon to indicate the state -->\n        <span class=\"facet-check-list-item-check\">\n            <span class=\"hpe-icon hpe-active\"></span>\n        </span>\n\n        <!-- Display the title -->\n        <span class=\"facet-check-list-item-title\">{{ facet.title }}</span>\n\n        <!-- Display the count if specified -->\n        <span class=\"facet-check-list-item-count\" *ngIf=\"facet.count !== undefined\">({{ facet.count }})</span>\n    </div>\n</div>"
                },] },
    ];
    /** @nocollapse */
    FacetCheckListComponent.ctorParameters = function () { return []; };
    FacetCheckListComponent.propDecorators = {
        "facets": [{ type: Input },],
        "header": [{ type: Input },],
        "scrollbar": [{ type: Input },],
        "expanded": [{ type: Input },],
    };
    return FacetCheckListComponent;
}(FacetBaseComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var FacetTypeaheadListComponent = (function (_super) {
    __extends(FacetTypeaheadListComponent, _super);
    function FacetTypeaheadListComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.expanded = true;
        _this.typeaheadConfig = {};
        _this.suggestions = [];
        _this.simplified = true;
        _this._nativeElement = /** @type {?} */ (_this._elementRef.nativeElement);
        _this._defaultTypeaheadConfig = {
            placeholder: '',
            maxResults: 50,
            minCharacters: 1
        };
        return _this;
    }
    /**
     * @return {?}
     */
    FacetTypeaheadListComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // wrap the observable and filter out any already selected items or any disabled items
        if (this.facets instanceof Observable) {
            // handle an observable of data
            this.typeaheadOptions = from(this.facets).pipe(map(function (facets) {
                // remove disabled facets, selected facets and facets that dont match search term
                return facets.filter(function (facet) { return !facet.disabled; })
                    .filter(function (facet) { return !_this.selected.find(function (selectedFacet) { return selectedFacet === facet; }); })
                    .filter(function (facet) { return facet.title.toUpperCase().includes(_this.searchQuery.toUpperCase()); });
            }));
        }
        else {
            // handle an array of data
            this.typeaheadOptions = of(this.facets).pipe(map(function (facets) {
                // remove disabled facets, selected facets and facets that dont match search term
                return facets.filter(function (facet) { return !facet.disabled; })
                    .filter(function (facet) { return !_this.selected.find(function (selectedFacet) { return selectedFacet === facet; }); })
                    .filter(function (facet) { return facet.title.toUpperCase().includes(_this.searchQuery.toUpperCase()); });
            }));
        }
        // provide default values for typeahead config
        for (var /** @type {?} */ prop in this._defaultTypeaheadConfig) {
            // check if prop has been defined in the users typeahead config - if not set default value
            if (this.typeaheadConfig.hasOwnProperty(prop) === false) {
                this.typeaheadConfig[prop] = this._defaultTypeaheadConfig[prop];
            }
        }
    };
    /**
     * @param {?} typeaheadOption
     * @return {?}
     */
    FacetTypeaheadListComponent.prototype.selectOption = /**
     * @param {?} typeaheadOption
     * @return {?}
     */
    function (typeaheadOption) {
        // check to make sure that the item is not currently selected
        if (this.selected.find(function (facet) { return facet === typeaheadOption.item; })) {
            return;
        }
        // select the facet
        this.selectFacet(typeaheadOption.item);
        // clear the typeahead
        this.searchQuery = '';
    };
    /**
     * @return {?}
     */
    FacetTypeaheadListComponent.prototype.scrollToFocused = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ dropdown = this._nativeElement.querySelector('.dropdown-menu');
        // delay to allow the typeahead ui to update
        setTimeout(function () {
            // find the currently active element if there is one
            var /** @type {?} */ activeElement = dropdown.querySelector('.dropdown-menu > li.active');
            if (activeElement) {
                // check if element is not in view
                var /** @type {?} */ elementBounds = activeElement.getBoundingClientRect();
                var /** @type {?} */ dropdownBounds = dropdown.getBoundingClientRect();
                if (elementBounds.top < dropdownBounds.top) {
                    dropdown.scrollTop += elementBounds.top - dropdownBounds.top;
                }
                if (elementBounds.bottom > dropdownBounds.bottom) {
                    dropdown.scrollTop += elementBounds.bottom - dropdownBounds.bottom;
                }
            }
        });
    };
    FacetTypeaheadListComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-facet-typeahead-list',
                    template: "<ux-facet-header [header]=\"header\" [(expanded)]=\"expanded\"></ux-facet-header>\n\n<div class=\"facet-typeahead-list-container\" *ngIf=\"expanded\">\n\n    <div class=\"facet-typeahead-list-selected-container\" *ngIf=\"suggestions?.length > 0\">\n\n        <div class=\"facet-typeahead-list-selected-option\" tabindex=\"0\" *ngFor=\"let facet of suggestions\" (click)=\"toggleFacetSelection(facet)\"\n            (keyup.enter)=\"toggleFacetSelection(facet)\">\n\n            <ux-checkbox [clickable]=\"false\" [value]=\"isFacetSelected(facet)\" [simplified]=\"simplified\">\n                <span class=\"facet-typeahead-list-selected-option-title\">{{ facet.title }}</span>\n                <span class=\"facet-typeahead-list-selected-option-count\">({{ facet.count }})</span>\n            </ux-checkbox>\n\n        </div>\n\n    </div>\n\n    <div class=\"facet-typeahead-list-control\">\n\n        <!-- Create Typeahead Control -->\n        <input type=\"text\" class=\"form-control\" [placeholder]=\"typeaheadConfig?.placeholder\" [typeahead]=\"typeaheadOptions\" [(ngModel)]=\"searchQuery\"\n            [typeaheadMinLength]=\"typeaheadConfig?.minCharacters\" [typeaheadOptionsLimit]=\"typeaheadConfig?.maxResults\" [typeaheadWaitMs]=\"typeaheadConfig?.delay\"\n            (typeaheadOnSelect)=\"selectOption($event)\" [typeaheadItemTemplate]=\"facetOptionTemplate\" (keyup.ArrowUp)=\"scrollToFocused()\" (keyup.ArrowDown)=\"scrollToFocused()\">\n\n    </div>\n\n</div>\n\n<ng-template #facetOptionTemplate let-model=\"item\" let-index=\"index\">\n    <p class=\"facet-typeahead-list-option\"><span [innerHTML]=\"model.title | facetTypeaheadHighlight: searchQuery\"></span> <span class=\"facet-typeahead-list-option-count\"\n            *ngIf=\"model.count\">({{ model.count }})</span></p>\n</ng-template>"
                },] },
    ];
    /** @nocollapse */
    FacetTypeaheadListComponent.ctorParameters = function () { return []; };
    FacetTypeaheadListComponent.propDecorators = {
        "facets": [{ type: Input },],
        "header": [{ type: Input },],
        "expanded": [{ type: Input },],
        "typeaheadConfig": [{ type: Input },],
        "suggestions": [{ type: Input },],
        "simplified": [{ type: Input },],
    };
    return FacetTypeaheadListComponent;
}(FacetBaseComponent));
var FacetTypeaheadHighlight = (function () {
    function FacetTypeaheadHighlight() {
    }
    /**
     * @param {?} value
     * @param {?} searchQuery
     * @return {?}
     */
    FacetTypeaheadHighlight.prototype.transform = /**
     * @param {?} value
     * @param {?} searchQuery
     * @return {?}
     */
    function (value, searchQuery) {
        var /** @type {?} */ regex = new RegExp(searchQuery, 'i');
        return value.replace(regex, "<b class=\"facet-typeahead-highlighted\">" + value.match(regex) + "</b>");
    };
    FacetTypeaheadHighlight.decorators = [
        { type: Pipe, args: [{
                    name: 'facetTypeaheadHighlight'
                },] },
    ];
    /** @nocollapse */
    FacetTypeaheadHighlight.ctorParameters = function () { return []; };
    return FacetTypeaheadHighlight;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var /** @type {?} */ uniqueTooltipId = 0;
var TooltipComponent = (function () {
    function TooltipComponent(_changeDetectorRef) {
        this._changeDetectorRef = _changeDetectorRef;
        /**
         * Define a unique id for each tooltip
         */
        this.id = "ux-tooltip-" + ++uniqueTooltipId;
        /**
         * Define the tooltip role
         */
        this.role = 'tooltip';
        /**
         * Allow a custom class to be added to the tooltip to allow custom styling
         */
        this.customClass = '';
        /**
         * Indicates whether or not the content is a string or a TemplateRef
         */
        this.isTemplateRef = false;
        /**
         * Emit when the tooltip need to update it's position
         */
        this.reposition$ = new Subject();
    }
    /** Cleanup after the component is destroyed */
    /**
     * Cleanup after the component is destroyed
     * @return {?}
     */
    TooltipComponent.prototype.ngOnDestroy = /**
     * Cleanup after the component is destroyed
     * @return {?}
     */
    function () {
        this.reposition$.complete();
    };
    /** Inform the parent directive that it needs to recalulate the position */
    /**
     * Inform the parent directive that it needs to recalulate the position
     * @return {?}
     */
    TooltipComponent.prototype.reposition = /**
     * Inform the parent directive that it needs to recalulate the position
     * @return {?}
     */
    function () {
        this.reposition$.next();
    };
    /** This will update the content of the tooltip and trigger change detection */
    /**
     * This will update the content of the tooltip and trigger change detection
     * @param {?} content
     * @return {?}
     */
    TooltipComponent.prototype.setContent = /**
     * This will update the content of the tooltip and trigger change detection
     * @param {?} content
     * @return {?}
     */
    function (content) {
        this.content = content;
        this.isTemplateRef = content instanceof TemplateRef;
        this._changeDetectorRef.markForCheck();
    };
    /** This will update the tooltip placement and trigger change detection */
    /**
     * This will update the tooltip placement and trigger change detection
     * @param {?} placement
     * @return {?}
     */
    TooltipComponent.prototype.setPlacement = /**
     * This will update the tooltip placement and trigger change detection
     * @param {?} placement
     * @return {?}
     */
    function (placement) {
        if (!placement) {
            return;
        }
        this.placement = placement;
        this._changeDetectorRef.markForCheck();
    };
    /** This will set a custom class on the tooltip and trigger change detection */
    /**
     * This will set a custom class on the tooltip and trigger change detection
     * @param {?} customClass
     * @return {?}
     */
    TooltipComponent.prototype.setClass = /**
     * This will set a custom class on the tooltip and trigger change detection
     * @param {?} customClass
     * @return {?}
     */
    function (customClass) {
        if (!customClass) {
            return;
        }
        this.customClass = customClass;
        this._changeDetectorRef.markForCheck();
    };
    /** Updates the context used by the TemplateRef */
    /**
     * Updates the context used by the TemplateRef
     * @param {?} context
     * @return {?}
     */
    TooltipComponent.prototype.setContext = /**
     * Updates the context used by the TemplateRef
     * @param {?} context
     * @return {?}
     */
    function (context) {
        if (!context) {
            return;
        }
        this.context = context;
        this._changeDetectorRef.markForCheck();
    };
    /** Specify the tooltip role attribute */
    /**
     * Specify the tooltip role attribute
     * @param {?} role
     * @return {?}
     */
    TooltipComponent.prototype.setRole = /**
     * Specify the tooltip role attribute
     * @param {?} role
     * @return {?}
     */
    function (role) {
        if (!role) {
            return;
        }
        this.role = role;
        this._changeDetectorRef.markForCheck();
    };
    TooltipComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-tooltip',
                    template: "<div class=\"tooltip in\" [id]=\"id\" [attr.role]=\"role\" [ngClass]=\"[placement, customClass]\">\n    <div class=\"tooltip-arrow\"></div>\n    <div class=\"tooltip-inner\" (cdkObserveContent)=\"reposition()\">\n        <ng-container *ngIf=\"!isTemplateRef\">{{ content }}</ng-container>\n        <ng-container *ngIf=\"isTemplateRef\" [ngTemplateOutlet]=\"content\" [ngTemplateOutletContext]=\"context\"></ng-container>\n    </div>\n</div>",
                    changeDetection: ChangeDetectionStrategy.OnPush
                },] },
    ];
    /** @nocollapse */
    TooltipComponent.ctorParameters = function () { return [
        { type: ChangeDetectorRef, },
    ]; };
    return TooltipComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var TooltipService = (function () {
    function TooltipService() {
        this.shown$ = new Subject();
    }
    TooltipService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    TooltipService.ctorParameters = function () { return []; };
    return TooltipService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var TooltipDirective$1 = (function () {
    function TooltipDirective$$1(_elementRef, _viewContainerRef, _overlay, _scrollDispatcher, _changeDetectorRef, _renderer, _tooltipService) {
        this._elementRef = _elementRef;
        this._viewContainerRef = _viewContainerRef;
        this._overlay = _overlay;
        this._scrollDispatcher = _scrollDispatcher;
        this._changeDetectorRef = _changeDetectorRef;
        this._renderer = _renderer;
        this._tooltipService = _tooltipService;
        /**
         * All the user to add a custom class to the tooltip
         */
        this.customClass = '';
        /**
         * All the user to add a role to the tooltip - default is tooltip
         */
        this.role = 'tooltip';
        /**
         * Provide the TemplateRef a context object
         */
        this.context = {};
        /**
         * Delay the showing of the tooltip by a number of miliseconds
         */
        this.delay = 0;
        /**
         * Programmatically show and hide the tooltip
         */
        this.isOpen = false;
        /**
         * Customize how the tooltip should be positioned relative to the element
         */
        this.placement = 'top';
        /**
         * Specify which events should show the tooltip
         */
        this.showTriggers = ['mouseenter', 'focus'];
        /**
         * Specify which events should hide the tooltip
         */
        this.hideTriggers = ['mouseleave', 'blur'];
        /**
         * Emits an event when the tooltip is shown
         */
        this.shown = new EventEmitter();
        /**
         * Emits a event when the tooltip is hidden
         */
        this.hidden = new EventEmitter();
        /**
         * Allow two way binding to track the visibility of the tooltip
         */
        this.isOpenChange = new EventEmitter();
        /**
         * Keep track of the tooltip visibility
         */
        this.isVisible = false;
        /**
         * This will emit when the directive is destroyed allowing us to unsubscribe all subscriptions automatically
         */
        this._onDestroy = new Subject();
        /**
         * Internally store the type of this component - usual for distinctions when extending this class
         */
        this._type = 'tooltip';
    }
    /** Set up the triggers and bind to the show/hide events to keep visibility in sync */
    /**
     * Set up the triggers and bind to the show/hide events to keep visibility in sync
     * @return {?}
     */
    TooltipDirective$$1.prototype.ngOnInit = /**
     * Set up the triggers and bind to the show/hide events to keep visibility in sync
     * @return {?}
     */
    function () {
        var _this = this;
        // set up show and hide event triggers
        fromEvent(this._elementRef.nativeElement, 'click').pipe(takeUntil(this._onDestroy)).subscribe(this.onClick.bind(this));
        fromEvent(this._elementRef.nativeElement, 'mouseenter').pipe(takeUntil(this._onDestroy)).subscribe(this.onMouseEnter.bind(this));
        fromEvent(this._elementRef.nativeElement, 'mouseleave').pipe(takeUntil(this._onDestroy)).subscribe(this.onMouseLeave.bind(this));
        fromEvent(this._elementRef.nativeElement, 'focus').pipe(takeUntil(this._onDestroy)).subscribe(this.onFocus.bind(this));
        fromEvent(this._elementRef.nativeElement, 'blur').pipe(takeUntil(this._onDestroy)).subscribe(this.onBlur.bind(this));
        // when any other tooltips open hide this one
        this._tooltipService.shown$.pipe(filter(function () { return _this._type === 'tooltip'; }), filter(function (tooltip) { return tooltip !== _this._instance; }), takeUntil(this._onDestroy)).subscribe(this.hide.bind(this));
        // if the tooltip should be initially visible then open it
        if (this.isOpen) {
            this.show();
        }
    };
    /**
     * We need to send input changes to the tooltip component
     * We can't use setters as they may trigger before tooltip initialised and can't resend once initialised
     **/
    /**
     * We need to send input changes to the tooltip component
     * We can't use setters as they may trigger before tooltip initialised and can't resend once initialised
     *
     * @param {?} changes
     * @return {?}
     */
    TooltipDirective$$1.prototype.ngOnChanges = /**
     * We need to send input changes to the tooltip component
     * We can't use setters as they may trigger before tooltip initialised and can't resend once initialised
     *
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        // we can ignore the first change as it's handled in ngOnInit
        if (changes["isOpen"] && !changes["isOpen"].firstChange && changes["isOpen"].currentValue !== this.isVisible) {
            changes["isOpen"].currentValue ? this.show() : this.hide();
        }
        // destroy the overlay ref so a new correctly positioned instance will be created next time
        if (changes["placement"]) {
            this.destroyOverlay();
        }
        if (this._instance && changes["placement"]) {
            this._instance.setPlacement(changes["placement"].currentValue);
        }
        if (this._instance && changes["content"]) {
            this._instance.setContent(changes["content"].currentValue);
        }
        if (this._instance && changes["customClass"]) {
            this._instance.setClass(changes["customClass"].currentValue);
        }
        if (this._instance && changes["context"]) {
            this._instance.setContext(changes["context"].currentValue);
        }
        if (this._instance && changes["role"]) {
            this._instance.setContext(changes["role"].currentValue);
        }
    };
    /** Ensure we clean up after ourselves */
    /**
     * Ensure we clean up after ourselves
     * @return {?}
     */
    TooltipDirective$$1.prototype.ngOnDestroy = /**
     * Ensure we clean up after ourselves
     * @return {?}
     */
    function () {
        // ensure we close the tooltip when the host is destroyed
        if (this._overlayRef) {
            this._overlayRef.dispose();
            this._instance = null;
        }
        // emit this event to automatically unsubscribe from all subscriptions
        this._onDestroy.next();
        this._onDestroy.complete();
    };
    /** Make the tooltip open */
    /**
     * Make the tooltip open
     * @return {?}
     */
    TooltipDirective$$1.prototype.show = /**
     * Make the tooltip open
     * @return {?}
     */
    function () {
        var _this = this;
        // if the tooltip is disabled then do nothing
        if (this.disabled || this.isVisible || this._showTimeoutId || !this.content) {
            return;
        }
        // delay the show by the delay amount
        this._showTimeoutId = window.setTimeout(function () {
            // create the tooltip and get the overlay ref
            var /** @type {?} */ overlayRef = _this.createOverlay();
            // create the portal to create the tooltip component
            // create the portal to create the tooltip component
            _this._portal = _this.createPortal();
            _this._instance = _this.createInstance(overlayRef);
            // watch for any changes to the content
            // watch for any changes to the content
            _this._instance.reposition$.pipe(takeUntil(_this._onDestroy)).subscribe(_this.reposition.bind(_this));
            // store the visible state
            // store the visible state
            _this.isVisible = true;
            // ensure the overlay has the correct initial position
            // ensure the overlay has the correct initial position
            _this.reposition();
            // emit the show events
            // emit the show events
            _this.shown.emit();
            _this.isOpenChange.next(true);
            // clear the interval id
            // clear the interval id
            _this._showTimeoutId = null;
            // emit the show event to close any other tooltips
            // emit the show event to close any other tooltips
            _this._tooltipService.shown$.next(_this._instance);
            // ensure change detection is run
            // ensure change detection is run
            _this._changeDetectorRef.detectChanges();
        }, this.delay);
    };
    /** If a tooltip exists and is visible, hide it */
    /**
     * If a tooltip exists and is visible, hide it
     * @return {?}
     */
    TooltipDirective$$1.prototype.hide = /**
     * If a tooltip exists and is visible, hide it
     * @return {?}
     */
    function () {
        // if we are waiting to show a tooltip then cancel the pending timeout
        if (this._showTimeoutId) {
            clearTimeout(this._showTimeoutId);
            this._showTimeoutId = null;
            return;
        }
        if (this._overlayRef && this._overlayRef.hasAttached()) {
            this._overlayRef.detach();
        }
        this.setAriaDescribedBy(null);
        this._instance = null;
        // store the visible state
        this.isVisible = false;
        // emit the hide events
        this.hidden.emit();
        this.isOpenChange.next(false);
        // ensure change detection is run
        this._changeDetectorRef.detectChanges();
    };
    /** Toggle the visibility of the tooltip */
    /**
     * Toggle the visibility of the tooltip
     * @return {?}
     */
    TooltipDirective$$1.prototype.toggle = /**
     * Toggle the visibility of the tooltip
     * @return {?}
     */
    function () {
        this.isVisible ? this.hide() : this.show();
    };
    /** Recalculate the position of the popover */
    /**
     * Recalculate the position of the popover
     * @return {?}
     */
    TooltipDirective$$1.prototype.reposition = /**
     * Recalculate the position of the popover
     * @return {?}
     */
    function () {
        if (this.isVisible && this._overlayRef) {
            this._overlayRef.updatePosition();
        }
    };
    /** Create an instance from the overlay ref - allows overriding and additional logic here */
    /**
     * Create an instance from the overlay ref - allows overriding and additional logic here
     * @param {?} overlayRef
     * @return {?}
     */
    TooltipDirective$$1.prototype.createInstance = /**
     * Create an instance from the overlay ref - allows overriding and additional logic here
     * @param {?} overlayRef
     * @return {?}
     */
    function (overlayRef) {
        var /** @type {?} */ instance = /** @type {?} */ (overlayRef.attach(this._portal).instance);
        // supply the tooltip with the correct properties
        instance.setContent(this.content);
        instance.setPlacement(this.placement);
        instance.setClass(this.customClass);
        instance.setContext(this.context);
        instance.setRole(this.role);
        // Update the aria-describedby attribute
        this.setAriaDescribedBy(instance.id);
        return instance;
    };
    /** Create the component portal - allows overriding to allow other portals eg. popovers */
    /**
     * Create the component portal - allows overriding to allow other portals eg. popovers
     * @return {?}
     */
    TooltipDirective$$1.prototype.createPortal = /**
     * Create the component portal - allows overriding to allow other portals eg. popovers
     * @return {?}
     */
    function () {
        return this._portal || new ComponentPortal(TooltipComponent, this._viewContainerRef);
    };
    /**
     * Create the overlay and set up the scroll handling behavior
     * @return {?}
     */
    TooltipDirective$$1.prototype.createOverlay = /**
     * Create the overlay and set up the scroll handling behavior
     * @return {?}
     */
    function () {
        // if the tooltip has already been created then just return the existing instance
        if (this._overlayRef) {
            return this._overlayRef;
        }
        // configure the tooltip
        var /** @type {?} */ strategy = this._overlay.position()
            .connectedTo(this._elementRef, this.getOrigin(), this.getOverlayPosition());
        // correctly handle scrolling
        var /** @type {?} */ scrollableAncestors = this._scrollDispatcher
            .getAncestorScrollContainers(this._elementRef);
        strategy.withScrollableContainers(scrollableAncestors);
        this._overlayRef = this._overlay.create({
            positionStrategy: strategy,
            panelClass: 'ux-overlay-pane',
            scrollStrategy: this._overlay.scrollStrategies.reposition({ scrollThrottle: 0 }),
            hasBackdrop: false
        });
        return this._overlayRef;
    };
    /**
     * Recreate the overlay ref using the updated origin and overlay positions
     * @return {?}
     */
    TooltipDirective$$1.prototype.destroyOverlay = /**
     * Recreate the overlay ref using the updated origin and overlay positions
     * @return {?}
     */
    function () {
        // destroy the existing overlay
        if (this._overlayRef && this._overlayRef.hasAttached()) {
            this._overlayRef.detach();
        }
        if (this._overlayRef) {
            this._overlayRef.dispose();
            this._overlayRef = null;
        }
        this.isVisible = false;
    };
    /**
     * Get the origin position based on the specified tooltip placement
     * @return {?}
     */
    TooltipDirective$$1.prototype.getOrigin = /**
     * Get the origin position based on the specified tooltip placement
     * @return {?}
     */
    function () {
        // ensure placement is defined
        this.placement = this.placement || 'top';
        if (this.placement == 'top' || this.placement == 'bottom') {
            return { originX: 'center', originY: this.placement };
        }
        else if (this.placement == 'left') {
            return { originX: 'start', originY: 'center' };
        }
        else if (this.placement == 'right') {
            return { originX: 'end', originY: 'center' };
        }
    };
    /**
     * Calculate the overlay position based on the specified tooltip placement
     * @return {?}
     */
    TooltipDirective$$1.prototype.getOverlayPosition = /**
     * Calculate the overlay position based on the specified tooltip placement
     * @return {?}
     */
    function () {
        // ensure placement is defined
        this.placement = this.placement || 'top';
        if (this.placement == 'top') {
            return { overlayX: 'center', overlayY: 'bottom' };
        }
        else if (this.placement == 'bottom') {
            return { overlayX: 'center', overlayY: 'top' };
        }
        else if (this.placement == 'left') {
            return { overlayX: 'end', overlayY: 'center' };
        }
        else if (this.placement == 'right') {
            return { overlayX: 'start', overlayY: 'center' };
        }
    };
    /**
     * Simple utility method - because IE doesn't support array.includes
     * And it isn't included in the core-js/es6 polyfills which are the
     * only ones required by Angular and guaranteed to be there
     **/
    /**
     * Simple utility method - because IE doesn't support array.includes
     * And it isn't included in the core-js/es6 polyfills which are the
     * only ones required by Angular and guaranteed to be there
     *
     * @template T
     * @param {?} array
     * @param {?} value
     * @return {?}
     */
    TooltipDirective$$1.prototype.includes = /**
     * Simple utility method - because IE doesn't support array.includes
     * And it isn't included in the core-js/es6 polyfills which are the
     * only ones required by Angular and guaranteed to be there
     *
     * @template T
     * @param {?} array
     * @param {?} value
     * @return {?}
     */
    function (array, value) {
        return Array.isArray(array) && !!array.find(function (item) { return item === value; });
    };
    /** Handle the click event - show or hide accordingly */
    /**
     * Handle the click event - show or hide accordingly
     * @param {?} event
     * @return {?}
     */
    TooltipDirective$$1.prototype.onClick = /**
     * Handle the click event - show or hide accordingly
     * @param {?} event
     * @return {?}
     */
    function (event) {
        // if its not visible and click is a show trigger open it
        if (!this.isVisible && this.includes(this.showTriggers, 'click')) {
            return this.show();
        }
        // if its visible and click is a hide trigger close it
        if (this.isVisible && this.includes(this.hideTriggers, 'click')) {
            return this.hide();
        }
    };
    /** Handle the mouse enter event - show or hide accordingly */
    /**
     * Handle the mouse enter event - show or hide accordingly
     * @param {?} event
     * @return {?}
     */
    TooltipDirective$$1.prototype.onMouseEnter = /**
     * Handle the mouse enter event - show or hide accordingly
     * @param {?} event
     * @return {?}
     */
    function (event) {
        // this is an show only trigger - if already open or it isn't a trigger do nothing
        if (this.isVisible || !this.includes(this.showTriggers, 'mouseenter')) {
            return;
        }
        // otherwise open the tooltip
        this.show();
    };
    /** Handle the mouse leave event - show or hide accordingly */
    /**
     * Handle the mouse leave event - show or hide accordingly
     * @param {?} event
     * @return {?}
     */
    TooltipDirective$$1.prototype.onMouseLeave = /**
     * Handle the mouse leave event - show or hide accordingly
     * @param {?} event
     * @return {?}
     */
    function (event) {
        // this is an hide only trigger - if not open or it isn't a trigger do nothing
        if (!this.isVisible || !this.includes(this.hideTriggers, 'mouseleave')) {
            return;
        }
        // otherwise close the tooltip
        this.hide();
    };
    /** Handle the focus event - show or hide accordingly */
    /**
     * Handle the focus event - show or hide accordingly
     * @param {?} event
     * @return {?}
     */
    TooltipDirective$$1.prototype.onFocus = /**
     * Handle the focus event - show or hide accordingly
     * @param {?} event
     * @return {?}
     */
    function (event) {
        // this is an show only trigger - if already open or it isn't a trigger do nothing
        if (this.isVisible || !this.includes(this.showTriggers, 'focus')) {
            return;
        }
        // otherwise open the tooltip
        this.show();
    };
    /** Handle the blur event - show or hide accordingly */
    /**
     * Handle the blur event - show or hide accordingly
     * @param {?} event
     * @return {?}
     */
    TooltipDirective$$1.prototype.onBlur = /**
     * Handle the blur event - show or hide accordingly
     * @param {?} event
     * @return {?}
     */
    function (event) {
        // this is an hide only trigger - if not open or it isn't a trigger do nothing
        if (!this.isVisible || !this.includes(this.hideTriggers, 'blur')) {
            return;
        }
        // otherwise close the tooltip
        this.hide();
    };
    /**
     * Determine if the trigger element is focused
     * @return {?}
     */
    TooltipDirective$$1.prototype.isFocused = /**
     * Determine if the trigger element is focused
     * @return {?}
     */
    function () {
        return document.activeElement === this._elementRef.nativeElement;
    };
    /** Programmatically update the aria-describedby property */
    /**
     * Programmatically update the aria-describedby property
     * @param {?} id
     * @return {?}
     */
    TooltipDirective$$1.prototype.setAriaDescribedBy = /**
     * Programmatically update the aria-describedby property
     * @param {?} id
     * @return {?}
     */
    function (id) {
        if (id === null) {
            this._renderer.removeAttribute(this._elementRef.nativeElement, 'aria-describedby');
        }
        else {
            this._renderer.setAttribute(this._elementRef.nativeElement, 'aria-describedby', id);
        }
    };
    TooltipDirective$$1.decorators = [
        { type: Directive, args: [{
                    selector: '[uxTooltip]',
                    exportAs: 'ux-tooltip'
                },] },
    ];
    /** @nocollapse */
    TooltipDirective$$1.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: ViewContainerRef, },
        { type: Overlay, },
        { type: ScrollDispatcher, },
        { type: ChangeDetectorRef, },
        { type: Renderer2, },
        { type: TooltipService, },
    ]; };
    TooltipDirective$$1.propDecorators = {
        "content": [{ type: Input, args: ['uxTooltip',] },],
        "disabled": [{ type: Input, args: ['tooltipDisabled',] },],
        "customClass": [{ type: Input, args: ['tooltipClass',] },],
        "role": [{ type: Input, args: ['tooltipRole',] },],
        "context": [{ type: Input, args: ['tooltipContext',] },],
        "delay": [{ type: Input, args: ['tooltipDelay',] },],
        "isOpen": [{ type: Input },],
        "placement": [{ type: Input },],
        "showTriggers": [{ type: Input },],
        "hideTriggers": [{ type: Input },],
        "shown": [{ type: Output },],
        "hidden": [{ type: Output },],
        "isOpenChange": [{ type: Output },],
    };
    return TooltipDirective$$1;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var TooltipModule = (function () {
    function TooltipModule() {
    }
    TooltipModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        OverlayModule,
                        ObserversModule
                    ],
                    exports: [TooltipDirective$1],
                    declarations: [TooltipComponent, TooltipDirective$1],
                    providers: [TooltipService],
                    entryComponents: [TooltipComponent]
                },] },
    ];
    /** @nocollapse */
    TooltipModule.ctorParameters = function () { return []; };
    return TooltipModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ReorderableHandleDirective = (function () {
    function ReorderableHandleDirective() {
    }
    ReorderableHandleDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[uxReorderableHandle]'
                },] },
    ];
    /** @nocollapse */
    ReorderableHandleDirective.ctorParameters = function () { return []; };
    return ReorderableHandleDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ReorderableModelDirective = (function () {
    // this can be used to identify which instance of the directive relates to which element
    function ReorderableModelDirective(elementRef) {
        this.elementRef = elementRef;
    }
    ReorderableModelDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[uxReorderableModel]'
                },] },
    ];
    /** @nocollapse */
    ReorderableModelDirective.ctorParameters = function () { return [
        { type: ElementRef, },
    ]; };
    ReorderableModelDirective.propDecorators = {
        "uxReorderableModel": [{ type: Input },],
    };
    return ReorderableModelDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
// WORKAROUND: Angular Cli 6 has removed the globals patch, dragular requires this to we can patch it here
(/** @type {?} */ (window)).global = (/** @type {?} */ (window)).global || {};
var /** @type {?} */ dragula = dragulaNamespace__default || dragulaNamespace;

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ReorderableService = (function () {
    function ReorderableService() {
        this._groups = {};
        this._uniqueGroupId = 0;
    }
    /**
     * Returns a unique string which can be used as a group name if one was not configured.
     */
    /**
     * Returns a unique string which can be used as a group name if one was not configured.
     * @return {?}
     */
    ReorderableService.prototype.getUniqueGroupName = /**
     * Returns a unique string which can be used as a group name if one was not configured.
     * @return {?}
     */
    function () {
        return '_uxReorderable_' + this._uniqueGroupId++;
    };
    /**
     * Adds the container to the named group.
     */
    /**
     * Adds the container to the named group.
     * @param {?} groupName
     * @param {?} container
     * @return {?}
     */
    ReorderableService.prototype.register = /**
     * Adds the container to the named group.
     * @param {?} groupName
     * @param {?} container
     * @return {?}
     */
    function (groupName, container) {
        if (!this._groups[groupName]) {
            this._groups[groupName] = new ReorderableGroup();
        }
        this._groups[groupName].register(container);
        return this._groups[groupName];
    };
    /**
     * Removes the container from the named group. If it was the last container in the group, destroys the group.
     */
    /**
     * Removes the container from the named group. If it was the last container in the group, destroys the group.
     * @param {?} groupName
     * @param {?} container
     * @return {?}
     */
    ReorderableService.prototype.unregister = /**
     * Removes the container from the named group. If it was the last container in the group, destroys the group.
     * @param {?} groupName
     * @param {?} container
     * @return {?}
     */
    function (groupName, container) {
        var /** @type {?} */ group = this._groups[groupName];
        if (group) {
            group.unregister(container);
            if (group.isEmpty()) {
                group.destroy();
                delete this._groups[groupName];
            }
        }
    };
    /**
     * Creates the dragula instance with the current config and attaches the events, if not already created.
     */
    /**
     * Creates the dragula instance with the current config and attaches the events, if not already created.
     * @param {?} groupName
     * @return {?}
     */
    ReorderableService.prototype.initialize = /**
     * Creates the dragula instance with the current config and attaches the events, if not already created.
     * @param {?} groupName
     * @return {?}
     */
    function (groupName) {
        var /** @type {?} */ group = this._groups[groupName];
        if (group) {
            group.initialize();
        }
        return group;
    };
    /**
     * Returns the group object for the given name.
     */
    /**
     * Returns the group object for the given name.
     * @param {?} group
     * @return {?}
     */
    ReorderableService.prototype.getGroup = /**
     * Returns the group object for the given name.
     * @param {?} group
     * @return {?}
     */
    function (group) {
        return this._groups[group];
    };
    ReorderableService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    ReorderableService.ctorParameters = function () { return []; };
    return ReorderableService;
}());
/**
 * Represents a collection of drag-and-drop containers (uxReorderable) that items can be dragged between.
 */
var  /**
 * Represents a collection of drag-and-drop containers (uxReorderable) that items can be dragged between.
 */
ReorderableGroup = (function () {
    function ReorderableGroup() {
        this.drag = new EventEmitter();
        this.dragEnd = new EventEmitter();
        this.drop = new EventEmitter();
        this.cancel = new EventEmitter();
        this.cloned = new EventEmitter();
        this._containers = [];
        this._config = {
            moves: this.canMove.bind(this)
        };
    }
    /**
     * Returns true if there are no containers registered with the group.
     */
    /**
     * Returns true if there are no containers registered with the group.
     * @return {?}
     */
    ReorderableGroup.prototype.isEmpty = /**
     * Returns true if there are no containers registered with the group.
     * @return {?}
     */
    function () {
        return this._containers.length === 0;
    };
    /**
     * Returns the model object (uxReorderableModel) for an elements in one of the containers in the group.
     */
    /**
     * Returns the model object (uxReorderableModel) for an elements in one of the containers in the group.
     * @param {?} element
     * @return {?}
     */
    ReorderableGroup.prototype.getModelForElement = /**
     * Returns the model object (uxReorderableModel) for an elements in one of the containers in the group.
     * @param {?} element
     * @return {?}
     */
    function (element) {
        try {
            for (var _a = __values(this._containers), _b = _a.next(); !_b.done; _b = _a.next()) {
                var container = _b.value;
                var /** @type {?} */ model = container.getModelFromElement(element);
                if (model) {
                    return model;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return null;
        var e_1, _c;
    };
    /**
     * Adds the container to the group.
     */
    /**
     * Adds the container to the group.
     * @param {?} container
     * @return {?}
     */
    ReorderableGroup.prototype.register = /**
     * Adds the container to the group.
     * @param {?} container
     * @return {?}
     */
    function (container) {
        this._containers.push(container);
        if (this._instance) {
            this._instance.containers = this._containers.map(function (c) { return c.element; });
        }
        if (!this._config.mirrorContainer) {
            this._config.mirrorContainer = container.element;
        }
    };
    /**
     * Removes the container from the group.
     */
    /**
     * Removes the container from the group.
     * @param {?} container
     * @return {?}
     */
    ReorderableGroup.prototype.unregister = /**
     * Removes the container from the group.
     * @param {?} container
     * @return {?}
     */
    function (container) {
        var /** @type {?} */ index = this._containers.indexOf(container);
        if (index >= 0) {
            this._containers.splice(index, 1);
            if (this._instance) {
                this._instance.containers = this._containers.map(function (c) { return c.element; });
            }
        }
    };
    /**
     * Creates the dragula instance with the current config and attaches the events, if not already created.
     */
    /**
     * Creates the dragula instance with the current config and attaches the events, if not already created.
     * @return {?}
     */
    ReorderableGroup.prototype.initialize = /**
     * Creates the dragula instance with the current config and attaches the events, if not already created.
     * @return {?}
     */
    function () {
        var _this = this;
        if (this._instance) {
            return;
        }
        this._instance = dragula(this._containers.map(function (c) { return c.element; }), this._config);
        this._instance.on('drag', function (element, source) {
            _this.drag.emit({
                model: _this.getModelForElement(element),
                element: element,
                source: source
            });
        });
        this._instance.on('dragend', function (element) {
            _this.dragEnd.emit({
                model: _this.getModelForElement(element),
                element: element
            });
        });
        this._instance.on('drop', function (element, target, source, sibling) {
            _this.drop.emit({
                model: _this.getModelForElement(element),
                element: element,
                target: target,
                source: source,
                sibling: sibling
            });
        });
        this._instance.on('cancel', function (element) {
            _this.cancel.emit({
                model: _this.getModelForElement(element),
                element: element
            });
        });
        this._instance.on('cloned', function (clone, element, type) {
            _this.cloned.emit({
                clone: clone,
                element: element,
                type: type
            });
        });
    };
    /**
     * Destroys the dragula instance.
     */
    /**
     * Destroys the dragula instance.
     * @return {?}
     */
    ReorderableGroup.prototype.destroy = /**
     * Destroys the dragula instance.
     * @return {?}
     */
    function () {
        if (this._instance) {
            this._instance.destroy();
            this._instance = null;
        }
    };
    /**
     * Finds the container for the containerElement and returns the results of canMove.
     * @param {?} element
     * @param {?} containerElement
     * @param {?} handle
     * @return {?}
     */
    ReorderableGroup.prototype.canMove = /**
     * Finds the container for the containerElement and returns the results of canMove.
     * @param {?} element
     * @param {?} containerElement
     * @param {?} handle
     * @return {?}
     */
    function (element, containerElement, handle) {
        try {
            for (var _a = __values(this._containers), _b = _a.next(); !_b.done; _b = _a.next()) {
                var container = _b.value;
                if (container.element.isSameNode(containerElement)) {
                    return container.canMove(element, containerElement, handle);
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_2) throw e_2.error; }
        }
        var e_2, _c;
    };
    return ReorderableGroup;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ReorderableDirective = (function () {
    function ReorderableDirective(_elementRef, _renderer, _service) {
        this._elementRef = _elementRef;
        this._renderer = _renderer;
        this._service = _service;
        this.reorderingDisabled = false;
        this.reorderableModelChange = new EventEmitter();
        this.reorderStart = new EventEmitter();
        this.reorderCancel = new EventEmitter();
        this.reorderEnd = new EventEmitter();
        this.dragging = false;
        this._subscriptions = new Subscription();
    }
    /**
     * Initialise dragula and bind to all the required events
     */
    /**
     * Initialise dragula and bind to all the required events
     * @return {?}
     */
    ReorderableDirective.prototype.ngOnInit = /**
     * Initialise dragula and bind to all the required events
     * @return {?}
     */
    function () {
        var _this = this;
        // If no group name then generate a unique one for this instance only
        if (!this.reorderableGroup) {
            this.reorderableGroup = this._service.getUniqueGroupName();
        }
        this._container = {
            element: this._elementRef.nativeElement,
            getModelFromElement: this.getModelFromElement.bind(this),
            canMove: this.canMove.bind(this)
        };
        // Register for drag events on this element
        var /** @type {?} */ group = this._service.register(this.reorderableGroup, this._container);
        this._subscriptions.add(group.drag.subscribe(this.onDrag.bind(this)));
        this._subscriptions.add(group.dragEnd.subscribe(this.onDragEnd.bind(this)));
        this._subscriptions.add(group.drop.subscribe(this.onDrop.bind(this)));
        this._subscriptions.add(group.cancel.subscribe(function (event) { return _this.reorderCancel.emit({ element: event.element, model: event.model }); }));
        this._subscriptions.add(group.cloned.subscribe(this.onClone.bind(this)));
    };
    /**
     * @return {?}
     */
    ReorderableDirective.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        this._service.initialize(this.reorderableGroup);
    };
    /**
     * We need to destroy the dragula instance on component destroy
     */
    /**
     * We need to destroy the dragula instance on component destroy
     * @return {?}
     */
    ReorderableDirective.prototype.ngOnDestroy = /**
     * We need to destroy the dragula instance on component destroy
     * @return {?}
     */
    function () {
        this._service.unregister(this.reorderableGroup, this._container);
        this._subscriptions.unsubscribe();
    };
    /**
     * @param {?} event
     * @return {?}
     */
    ReorderableDirective.prototype.onDrag = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.dragging = true;
        this.reorderStart.emit({ element: event.element, model: event.model });
    };
    /**
     * This is fired when items get reordered - we need to emit the new order of the models
     */
    /**
     * This is fired when items get reordered - we need to emit the new order of the models
     * @param {?} event
     * @return {?}
     */
    ReorderableDirective.prototype.onDrop = /**
     * This is fired when items get reordered - we need to emit the new order of the models
     * @param {?} event
     * @return {?}
     */
    function (event) {
        // if there is no provided module we can skip this
        if (!this.reorderableModel) {
            return;
        }
        var /** @type {?} */ changed = false;
        if (event.source.isSameNode(this._elementRef.nativeElement)) {
            // remove this model from the list of models
            var /** @type {?} */ index = this.reorderableModel.indexOf(event.model);
            if (index >= 0) {
                this.reorderableModel.splice(index, 1);
                changed = true;
            }
        }
        if (event.target.isSameNode(this._elementRef.nativeElement)) {
            // get the position of sibling element
            var /** @type {?} */ index = event.sibling && !event.sibling.classList.contains('gu-mirror') ?
                this.reorderableModel.indexOf(this.getModelFromElement(event.sibling)) :
                this.reorderableModel.length;
            // insert the model at its new location
            this.reorderableModel.splice(index, 0, event.model);
            changed = true;
        }
        // Emit event if any changes were made
        if (changed) {
            this.reorderableModelChange.emit(this.reorderableModel);
        }
    };
    /**
     * Return the model assciated with a particular element in the list.
     * This should ensure that the items have the draggable model directive applied
     */
    /**
     * Return the model assciated with a particular element in the list.
     * This should ensure that the items have the draggable model directive applied
     * @param {?} element
     * @return {?}
     */
    ReorderableDirective.prototype.getModelFromElement = /**
     * Return the model assciated with a particular element in the list.
     * This should ensure that the items have the draggable model directive applied
     * @param {?} element
     * @return {?}
     */
    function (element) {
        var /** @type {?} */ model = this.models.find(function (_model) { return _model.elementRef.nativeElement === element; });
        if (!model) {
            return null;
        }
        return model.uxReorderableModel;
    };
    /**
     * When we finish dragging remove the utillity class from the element being moved
     */
    /**
     * When we finish dragging remove the utillity class from the element being moved
     * @param {?} event
     * @return {?}
     */
    ReorderableDirective.prototype.onDragEnd = /**
     * When we finish dragging remove the utillity class from the element being moved
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.dragging = false;
        if (this._elementRef.nativeElement.contains(event.element)) {
            this._renderer.removeClass(event.element, 'ux-reorderable-moving');
            this.reorderEnd.emit({
                element: event.element,
                model: event.model
            });
        }
    };
    /**
     * We want to ensure that the cloned element is identical
     * to the original, regardless of it's location in the DOM tree
     */
    /**
     * We want to ensure that the cloned element is identical
     * to the original, regardless of it's location in the DOM tree
     * @param {?} event
     * @return {?}
     */
    ReorderableDirective.prototype.onClone = /**
     * We want to ensure that the cloned element is identical
     * to the original, regardless of it's location in the DOM tree
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this._elementRef.nativeElement.contains(event.element)) {
            this.setTableCellWidths(event.element, event.clone);
            this.captureCanvases(event.element, event.clone);
            this._renderer.addClass(event.element, 'ux-reorderable-moving');
        }
    };
    /**
     * If elements contain handles then only drag when the handle is dragged
     * otherwise drag whenever an immediate child is specified
     */
    /**
     * If elements contain handles then only drag when the handle is dragged
     * otherwise drag whenever an immediate child is specified
     * @param {?} element
     * @param {?} container
     * @param {?} handle
     * @return {?}
     */
    ReorderableDirective.prototype.canMove = /**
     * If elements contain handles then only drag when the handle is dragged
     * otherwise drag whenever an immediate child is specified
     * @param {?} element
     * @param {?} container
     * @param {?} handle
     * @return {?}
     */
    function (element, container, handle) {
        if (this.reorderingDisabled) {
            return false;
        }
        return this.handles.length === 0 ? true : !!this.handles.find(function (_handle) { return _handle.nativeElement === handle; });
    };
    /**
     * @param {?} source
     * @param {?} target
     * @return {?}
     */
    ReorderableDirective.prototype.setTableCellWidths = /**
     * @param {?} source
     * @param {?} target
     * @return {?}
     */
    function (source, target) {
        // if it is not a table row then skip this
        if (source.tagName !== 'TR') {
            return;
        }
        // find any immediate td children and fix their width
        var /** @type {?} */ sourceCells = /** @type {?} */ (Array.from(source.children));
        var /** @type {?} */ targetCells = /** @type {?} */ (Array.from(target.children));
        // fix the width of these cells
        sourceCells.forEach(function (cell, idx) { return targetCells[idx].style.minWidth = getComputedStyle(cell).getPropertyValue('width'); });
    };
    /**
     * @param {?} source
     * @param {?} target
     * @return {?}
     */
    ReorderableDirective.prototype.captureCanvases = /**
     * @param {?} source
     * @param {?} target
     * @return {?}
     */
    function (source, target) {
        // find all child canvas elements
        var /** @type {?} */ sourceCanvases = Array.from(source.querySelectorAll('canvas'));
        var /** @type {?} */ targetCanvases = Array.from(target.querySelectorAll('canvas'));
        // replicate the canvas content
        targetCanvases.map(function (canvas) { return canvas.getContext('2d'); })
            .forEach(function (context, idx) { return context.drawImage(sourceCanvases[idx], 0, 0); });
    };
    ReorderableDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[uxReorderable]'
                },] },
    ];
    /** @nocollapse */
    ReorderableDirective.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: Renderer2, },
        { type: ReorderableService, },
    ]; };
    ReorderableDirective.propDecorators = {
        "reorderableModel": [{ type: Input },],
        "reorderableGroup": [{ type: Input },],
        "reorderingDisabled": [{ type: Input },],
        "reorderableModelChange": [{ type: Output },],
        "reorderStart": [{ type: Output },],
        "reorderCancel": [{ type: Output },],
        "reorderEnd": [{ type: Output },],
        "handles": [{ type: ContentChildren, args: [ReorderableHandleDirective, { read: ElementRef, descendants: true },] },],
        "models": [{ type: ContentChildren, args: [ReorderableModelDirective,] },],
        "dragging": [{ type: HostBinding, args: ['class.ux-reorderable-container-moving',] },],
    };
    return ReorderableDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ReorderableModule = (function () {
    function ReorderableModule() {
    }
    ReorderableModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule
                    ],
                    declarations: [
                        ReorderableDirective,
                        ReorderableHandleDirective,
                        ReorderableModelDirective
                    ],
                    exports: [
                        ReorderableDirective,
                        ReorderableHandleDirective,
                        ReorderableModelDirective
                    ],
                    providers: [
                        ReorderableService
                    ]
                },] },
    ];
    /** @nocollapse */
    ReorderableModule.ctorParameters = function () { return []; };
    return ReorderableModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var /** @type {?} */ DECLARATIONS$1 = [
    FacetContainerComponent,
    FacetHeaderComponent,
    FacetBaseComponent,
    FacetCheckListComponent,
    FacetTypeaheadListComponent,
    FacetTypeaheadHighlight
];
var FacetsModule = (function () {
    function FacetsModule() {
    }
    FacetsModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        FormsModule,
                        CheckboxModule,
                        TooltipModule,
                        ReorderableModule,
                        TypeaheadModule.forRoot()
                    ],
                    exports: DECLARATIONS$1,
                    declarations: DECLARATIONS$1
                },] },
    ];
    /** @nocollapse */
    FacetsModule.ctorParameters = function () { return []; };
    return FacetsModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var Facet = (function () {
    function Facet(title, data, count, disabled, id) {
        if (data === void 0) { data = {}; }
        if (disabled === void 0) { disabled = false; }
        this.title = title;
        this.data = data;
        this.count = count;
        this.disabled = disabled;
        this.id = id;
    }
    return Facet;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var FilterContainerComponent = (function () {
    function FilterContainerComponent() {
        this.filters = [];
        this.filtersChange = new EventEmitter();
        this.events = new EventEmitter();
    }
    /**
     * @param {?} filter
     * @return {?}
     */
    FilterContainerComponent.prototype.addFilter = /**
     * @param {?} filter
     * @return {?}
     */
    function (filter$$1) {
        this.filters.push(filter$$1);
        this.events.next(new FilterAddEvent(filter$$1));
        this.filtersChange.emit(this.filters);
    };
    /**
     * @param {?} filter
     * @return {?}
     */
    FilterContainerComponent.prototype.removeFilter = /**
     * @param {?} filter
     * @return {?}
     */
    function (filter$$1) {
        var /** @type {?} */ idx = this.filters.findIndex(function (filters) { return filters === filter$$1; });
        if (idx !== -1) {
            this.filters.splice(idx, 1);
            this.events.next(new FilterRemoveEvent(filter$$1));
            this.filtersChange.emit(this.filters);
        }
    };
    /**
     * @return {?}
     */
    FilterContainerComponent.prototype.removeAll = /**
     * @return {?}
     */
    function () {
        this.events.next(new FilterRemoveAllEvent());
    };
    FilterContainerComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-filter-container',
                    template: "<ng-content></ng-content>\n\n<!-- Add a Clear Button -->\n<div class=\"filter-selected-clear-button\" *ngIf=\"filters.length > 0\" [uxTooltip]=\"clearTooltip || 'Clear All'\" (click)=\"removeAll()\">\n\n    <svg class=\"filter-selected-clear-graphic\" width=\"19\" height=\"12\" viewBox=\"0 0 19 12\" shape-rendering=\"geometricPrecision\">\n        <rect class=\"light-grey\" x=\"0\" y=\"2\" width=\"7\" height=\"2\"></rect>\n        <rect class=\"dark-grey\" x=\"0\" y=\"5\" width=\"9\" height=\"2\"></rect>\n        <rect class=\"light-grey\" x=\"0\" y=\"8\" width=\"7\" height=\"2\"></rect>\n        <path class=\"dark-grey\" d=\"M9,1 h1 l9,9 v1 h-1 l-9,-9 v-1 Z\"></path>\n        <path class=\"dark-grey\" d=\"M9,11 v-1 l9,-9 h1 v1 l-9,9 h-1 Z\"></path>\n    </svg>\n\n</div>"
                },] },
    ];
    /** @nocollapse */
    FilterContainerComponent.ctorParameters = function () { return []; };
    FilterContainerComponent.propDecorators = {
        "filters": [{ type: Input },],
        "clearTooltip": [{ type: Input },],
        "filtersChange": [{ type: Output },],
        "events": [{ type: Output },],
    };
    return FilterContainerComponent;
}());
var FilterAddEvent = (function () {
    function FilterAddEvent(filter$$1) {
        this.filter = filter$$1;
    }
    return FilterAddEvent;
}());
var FilterRemoveEvent = (function () {
    function FilterRemoveEvent(filter$$1) {
        this.filter = filter$$1;
    }
    return FilterRemoveEvent;
}());
var FilterRemoveAllEvent = (function () {
    function FilterRemoveAllEvent() {
    }
    return FilterRemoveAllEvent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var FilterBaseComponent = (function () {
    function FilterBaseComponent(filtersContainer) {
        this.filtersContainer = filtersContainer;
        this._subscription = filtersContainer.events.pipe(filter(function (event) { return event instanceof FilterRemoveAllEvent; })).subscribe(this.removeFilter.bind(this));
    }
    /**
     * @return {?}
     */
    FilterBaseComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._subscription.unsubscribe();
    };
    /**
     * @param {?} _filter
     * @return {?}
     */
    FilterBaseComponent.prototype.addFilter = /**
     * @param {?} _filter
     * @return {?}
     */
    function (_filter) {
        if (!_filter.initial) {
            this.filtersContainer.addFilter(_filter);
        }
    };
    /**
     * @param {?} _filter
     * @return {?}
     */
    FilterBaseComponent.prototype.removeFilter = /**
     * @param {?} _filter
     * @return {?}
     */
    function (_filter) {
        if (!_filter) {
            return;
        }
        this.filtersContainer.removeFilter(_filter);
    };
    FilterBaseComponent.decorators = [
        { type: Directive, args: [{
                    selector: 'ux-filter-base'
                },] },
    ];
    /** @nocollapse */
    FilterBaseComponent.ctorParameters = function () { return [
        { type: FilterContainerComponent, decorators: [{ type: Host },] },
    ]; };
    FilterBaseComponent.propDecorators = {
        "filters": [{ type: Input },],
    };
    return FilterBaseComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var FilterDropdownComponent = (function (_super) {
    __extends(FilterDropdownComponent, _super);
    function FilterDropdownComponent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @return {?}
     */
    FilterDropdownComponent.prototype.removeFilter = /**
     * @return {?}
     */
    function () {
        _super.prototype.removeFilter.call(this, this.selected);
        this.selected = this.initial;
    };
    /**
     * @return {?}
     */
    FilterDropdownComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.selected = this.initial;
    };
    /**
     * @param {?} filter
     * @return {?}
     */
    FilterDropdownComponent.prototype.selectFilter = /**
     * @param {?} filter
     * @return {?}
     */
    function (filter$$1) {
        this.removeFilter();
        this.selected = filter$$1;
        this.addFilter(this.selected);
    };
    FilterDropdownComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-filter-dropdown',
                    template: "<div class=\"btn-group\" dropdown>\n    <button dropdownToggle type=\"button\" class=\"filter-dropdown btn dropdown-toggle\" [class.active]=\"selected !== initial\">{{ selected?.title }} \n        <span class=\"hpe-icon hpe-down\"></span>\n    </button>\n    <ul *dropdownMenu class=\"dropdown-menu\" role=\"menu\">\n        <li class=\"dropdown-list-item\" *ngFor=\"let filter of filters\" role=\"menuitem\">\n            <a class=\"dropdown-item\" (click)=\"selectFilter(filter)\">\n                <i class=\"hpe-icon\" [class.hpe-checkmark]=\"filter === selected\"></i>\n                <span class=\"filter-dropdown-title\">{{ filter.name }}</span>\n            </a>\n        </li>\n    </ul>\n</div>",
                },] },
    ];
    /** @nocollapse */
    FilterDropdownComponent.ctorParameters = function () { return []; };
    FilterDropdownComponent.propDecorators = {
        "initial": [{ type: Input },],
    };
    return FilterDropdownComponent;
}(FilterBaseComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var FilterDynamicComponent = (function (_super) {
    __extends(FilterDynamicComponent, _super);
    function FilterDynamicComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.defaultOptions = {
            placeholder: '',
            minCharacters: 3
        };
        _this.showTypeahead = true;
        _this.typeaheadItems = [];
        return _this;
    }
    /**
     * @return {?}
     */
    FilterDynamicComponent.prototype.getItems = /**
     * @return {?}
     */
    function () {
        var _this = this;
        return this.filters.filter(function (item) { return item !== _this.initial; }).map(function (item) { return item.name; });
    };
    /**
     * @return {?}
     */
    FilterDynamicComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.selected = this.initial;
        this.typeaheadItems = this.getItems();
        if (this.options && this.options.maxIndividualItems && this.options.maxIndividualItems + 1 >= this.filters.length) {
            this.showTypeahead = false;
        }
    };
    /**
     * @param {?} typeaheadOption
     * @return {?}
     */
    FilterDynamicComponent.prototype.selectOption = /**
     * @param {?} typeaheadOption
     * @return {?}
     */
    function (typeaheadOption) {
        this.removeFilter();
        var /** @type {?} */ idx = this.filters.findIndex(function (filter$$1) { return filter$$1.name === typeaheadOption.value; });
        this.selected = this.filters[idx];
        this.addFilter(this.selected);
        this.searchQuery = '';
        this.dropdown.hide();
    };
    /**
     * @param {?} event
     * @return {?}
     */
    FilterDynamicComponent.prototype.clickOff = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var /** @type {?} */ target = /** @type {?} */ (event.target);
        var /** @type {?} */ hideDropdown = true;
        while (target && target.nodeName !== 'BODY') {
            if (target.classList.contains('ux-dynamic-filter')) {
                hideDropdown = false;
                break;
            }
            else {
                target = target.parentElement;
            }
        }
        if (hideDropdown) {
            this.searchQuery = '';
            this.dropdown.hide();
        }
    };
    /**
     * @return {?}
     */
    FilterDynamicComponent.prototype.removeFilter = /**
     * @return {?}
     */
    function () {
        if (this.selected !== this.initial) {
            _super.prototype.removeFilter.call(this, this.selected);
            this.selected = this.initial;
        }
        this.searchQuery = '';
    };
    /**
     * @param {?} filter
     * @return {?}
     */
    FilterDynamicComponent.prototype.selectFilter = /**
     * @param {?} filter
     * @return {?}
     */
    function (filter$$1) {
        this.removeFilter();
        this.selected = filter$$1;
        this.addFilter(this.selected);
    };
    FilterDynamicComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-filter-dynamic',
                    template: "<div class=\"btn-group ux-dynamic-filter\" dropdown #dynamicDropdown=\"bs-dropdown\">\n    <button (click)=\"dynamicDropdown.show()\" type=\"button\" [class.active]=\"selected !== initial\" class=\"filter-dropdown btn dropdown-toggle\">{{ selected?.title }} \n        <span class=\"hpe-icon hpe-down\"></span>\n    </button>\n    <ul *dropdownMenu class=\"dropdown-menu\" role=\"menu\">\n\n        <li class=\"dropdown-list-item\" *ngIf=\"showTypeahead\" role=\"menuitem\">\n            <a class=\"dropdown-item\" (click)=\"removeFilter(); dynamicDropdown.hide();\">\n                <i class=\"hpe-icon\" [class.hpe-checkmark]=\"initial === selected\"></i>\n                <span class=\"filter-dropdown-title\">{{ initial.name }}</span>\n            </a>\n        </li>\n\n        <li class=\"dropdown-list-item\" *ngIf=\"selected !== initial && showTypeahead\" role=\"menuitem\">\n            <a class=\"dropdown-item\">\n                <i class=\"hpe-icon hpe-checkmark\"></i>\n                <span class=\"filter-dropdown-title\">{{ selected.name }}</span>\n            </a>\n        </li>\n\n        <hr>\n\n        <li *ngIf=\"showTypeahead\" class=\"typeahead-box\">\n            <input [(ngModel)]=\"searchQuery\" [typeahead]=\"typeaheadItems\" class=\"form-control\" \n            (typeaheadOnSelect)=\"selectOption($event)\" \n            [placeholder]=\"options?.placeholder || defaultOptions.placeholder\"\n            [typeaheadMinLength]=\"options?.minCharacters || defaultOptions.minCharacters\"\n            [typeaheadOptionsLimit]=\"options?.maxResults\">\n        </li>\n\n        <span *ngIf=\"!showTypeahead\">\n            <li class=\"dropdown-list-item\" *ngFor=\"let filter of filters\" role=\"menuitem\">\n                <a class=\"dropdown-item\" (click)=\"selectFilter(filter)\">\n                    <i class=\"hpe-icon\" [class.hpe-checkmark]=\"filter === selected\"></i>\n                    <span class=\"filter-dropdown-title\">{{ filter.name }}</span>\n                </a>\n            </li>\n        </span>\n\n    </ul>\n</div>",
                    host: {
                        '(document:click)': 'clickOff($event)',
                    }
                },] },
    ];
    /** @nocollapse */
    FilterDynamicComponent.ctorParameters = function () { return []; };
    FilterDynamicComponent.propDecorators = {
        "filters": [{ type: Input },],
        "initial": [{ type: Input },],
        "options": [{ type: Input },],
        "dropdown": [{ type: ViewChild, args: [BsDropdownDirective,] },],
    };
    return FilterDynamicComponent;
}(FilterBaseComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var /** @type {?} */ DECLARATIONS$2 = [
    FilterBaseComponent,
    FilterContainerComponent,
    FilterDropdownComponent,
    FilterDynamicComponent
];
var FilterModule = (function () {
    function FilterModule() {
    }
    FilterModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        BsDropdownModule.forRoot(),
                        TypeaheadModule.forRoot(),
                        TooltipModule,
                        FormsModule,
                        CommonModule
                    ],
                    exports: DECLARATIONS$2,
                    declarations: DECLARATIONS$2
                },] },
    ];
    /** @nocollapse */
    FilterModule.ctorParameters = function () { return []; };
    return FilterModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var FlippableCardComponent = (function () {
    function FlippableCardComponent() {
        this.direction = 'horizontal';
        this.trigger = 'hover';
        this.width = 280;
        this.height = 200;
        this.flipped = false;
        this.flippedChange = new EventEmitter();
    }
    /**
     * @param {?} state
     * @return {?}
     */
    FlippableCardComponent.prototype.setFlipped = /**
     * @param {?} state
     * @return {?}
     */
    function (state$$1) {
        this.flipped = state$$1;
        this.flippedChange.emit(this.flipped);
    };
    /**
     * @return {?}
     */
    FlippableCardComponent.prototype.toggleFlipped = /**
     * @return {?}
     */
    function () {
        this.setFlipped(!this.flipped);
    };
    /**
     * @return {?}
     */
    FlippableCardComponent.prototype.clickTrigger = /**
     * @return {?}
     */
    function () {
        // add or remove the class depending on whether or not the card has been flipped
        if (this.trigger === 'click') {
            this.toggleFlipped();
        }
    };
    /**
     * @return {?}
     */
    FlippableCardComponent.prototype.hoverEnter = /**
     * @return {?}
     */
    function () {
        // if the trigger is hover then begin to flip
        if (this.trigger === 'hover') {
            this.setFlipped(true);
        }
    };
    /**
     * @return {?}
     */
    FlippableCardComponent.prototype.hoverExit = /**
     * @return {?}
     */
    function () {
        if (this.trigger === 'hover') {
            this.setFlipped(false);
        }
    };
    FlippableCardComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-flippable-card',
                    template: "<div class=\"ux-flipper\" [class.ux-flip-card]=\"flipped\" [style.width.px]=\"width\" [style.height.px]=\"height\">\n\n    <div class=\"ux-flippable-card-front\" [style.width.px]=\"width\" [style.height.px]=\"height\">\n        <ng-content select=\"ux-flippable-card-front\"></ng-content>\n    </div>\n\n    <div class=\"ux-flippable-card-back\" [style.width.px]=\"width\" [style.height.px]=\"height\">\n        <ng-content select=\"ux-flippable-card-back\"></ng-content>\n    </div>\n</div>",
                    host: {
                        '[class.horizontal]': 'direction === "horizontal"',
                        '[class.vertical]': 'direction === "vertical"'
                    },
                    exportAs: 'ux-flippable-card'
                },] },
    ];
    /** @nocollapse */
    FlippableCardComponent.ctorParameters = function () { return []; };
    FlippableCardComponent.propDecorators = {
        "direction": [{ type: Input },],
        "trigger": [{ type: Input },],
        "width": [{ type: Input },],
        "height": [{ type: Input },],
        "flipped": [{ type: Input },],
        "flippedChange": [{ type: Output },],
        "clickTrigger": [{ type: HostListener, args: ['click',] },],
        "hoverEnter": [{ type: HostListener, args: ['mouseenter',] },],
        "hoverExit": [{ type: HostListener, args: ['mouseleave',] },],
    };
    return FlippableCardComponent;
}());
var FlippableCardFrontDirective = (function () {
    function FlippableCardFrontDirective() {
    }
    FlippableCardFrontDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'ux-flippable-card-front'
                },] },
    ];
    /** @nocollapse */
    FlippableCardFrontDirective.ctorParameters = function () { return []; };
    return FlippableCardFrontDirective;
}());
var FlippableCardBackDirective = (function () {
    function FlippableCardBackDirective() {
    }
    FlippableCardBackDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'ux-flippable-card-back'
                },] },
    ];
    /** @nocollapse */
    FlippableCardBackDirective.ctorParameters = function () { return []; };
    return FlippableCardBackDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var FlippableCardModule = (function () {
    function FlippableCardModule() {
    }
    FlippableCardModule.decorators = [
        { type: NgModule, args: [{
                    exports: [FlippableCardComponent, FlippableCardBackDirective, FlippableCardFrontDirective],
                    declarations: [FlippableCardComponent, FlippableCardBackDirective, FlippableCardFrontDirective]
                },] },
    ];
    /** @nocollapse */
    FlippableCardModule.ctorParameters = function () { return []; };
    return FlippableCardModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var FloatingActionButtonsService = (function () {
    function FloatingActionButtonsService() {
        this.open$ = new BehaviorSubject(false);
    }
    /**
     * @return {?}
     */
    FloatingActionButtonsService.prototype.open = /**
     * @return {?}
     */
    function () {
        this.open$.next(true);
    };
    /**
     * @return {?}
     */
    FloatingActionButtonsService.prototype.toggle = /**
     * @return {?}
     */
    function () {
        this.open$.next(!this.open$.getValue());
    };
    /**
     * @return {?}
     */
    FloatingActionButtonsService.prototype.close = /**
     * @return {?}
     */
    function () {
        this.open$.next(false);
    };
    FloatingActionButtonsService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    FloatingActionButtonsService.ctorParameters = function () { return []; };
    return FloatingActionButtonsService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var FloatingActionButtonsComponent = (function () {
    function FloatingActionButtonsComponent(fab, _elementRef) {
        this.fab = fab;
        this._elementRef = _elementRef;
        this.direction = 'top';
    }
    /**
     * @return {?}
     */
    FloatingActionButtonsComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this._subscription = this.fab.open$.pipe(filter(function (open) { return open === false; }))
            .subscribe(function () { return _this.tooltips.forEach(function (tooltip) { return tooltip.hide(); }); });
    };
    /**
     * @return {?}
     */
    FloatingActionButtonsComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._subscription.unsubscribe();
    };
    /**
     * @param {?} target
     * @return {?}
     */
    FloatingActionButtonsComponent.prototype.close = /**
     * @param {?} target
     * @return {?}
     */
    function (target) {
        if (!this._elementRef.nativeElement.contains(target)) {
            this.fab.close();
        }
    };
    FloatingActionButtonsComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-floating-action-buttons',
                    template: "<ng-content select=\"[fab-primary]\"></ng-content>\n\n<div class=\"floating-action-button-list\" [@fabAnimation]=\"fab.open$ | async\" [ngClass]=\"direction\" *ngIf=\"fab.open$ | async\">\n    <ng-content></ng-content>\n</div>",
                    providers: [FloatingActionButtonsService],
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    preserveWhitespaces: false,
                    animations: [
                        trigger('fabAnimation', [
                            transition('void => true', [
                                query('ux-floating-action-button', style({ opacity: 0 })),
                                query('ux-floating-action-button', stagger(50, animate(250, style({ opacity: 1 }))))
                            ]),
                            transition('true => void', [
                                query('ux-floating-action-button', stagger(-50, animate(250, style({ opacity: 0 }))))
                            ])
                        ])
                    ]
                },] },
    ];
    /** @nocollapse */
    FloatingActionButtonsComponent.ctorParameters = function () { return [
        { type: FloatingActionButtonsService, },
        { type: ElementRef, },
    ]; };
    FloatingActionButtonsComponent.propDecorators = {
        "direction": [{ type: Input },],
        "tooltips": [{ type: ContentChildren, args: [TooltipDirective,] },],
        "close": [{ type: HostListener, args: ['document:click', ['$event.target'],] },],
    };
    return FloatingActionButtonsComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var FloatingActionButtonComponent = (function () {
    function FloatingActionButtonComponent(primary, fab) {
        this.fab = fab;
        this.tabindex = 1;
        this.primary = false;
        this.primary = primary !== null;
    }
    FloatingActionButtonComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-floating-action-button',
                    template: "<button class=\"btn floating-action-button\" \n        [class.button-primary]=\"primary\" \n        [class.button-secondary]=\"!primary\" \n        (click)=\"primary ? fab.toggle() : fab.close()\">\n\n    <span class=\"hpe-icon floating-action-button-icon\" *ngIf=\"icon\" [ngClass]=\"icon\"></span>\n    <ng-content *ngIf=\"!icon\"></ng-content>\n\n</button>",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    preserveWhitespaces: false
                },] },
    ];
    /** @nocollapse */
    FloatingActionButtonComponent.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Attribute, args: ['fab-primary',] },] },
        { type: FloatingActionButtonsService, },
    ]; };
    FloatingActionButtonComponent.propDecorators = {
        "icon": [{ type: Input },],
        "tabindex": [{ type: HostBinding },],
    };
    return FloatingActionButtonComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var FloatingActionButtonsModule = (function () {
    function FloatingActionButtonsModule() {
    }
    FloatingActionButtonsModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule
                    ],
                    exports: [
                        FloatingActionButtonsComponent,
                        FloatingActionButtonComponent
                    ],
                    declarations: [
                        FloatingActionButtonsComponent,
                        FloatingActionButtonComponent
                    ]
                },] },
    ];
    /** @nocollapse */
    FloatingActionButtonsModule.ctorParameters = function () { return []; };
    return FloatingActionButtonsModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var HierarchyBarService = (function () {
    function HierarchyBarService() {
        this.nodes$ = new BehaviorSubject([]);
        this._nodes = [];
    }
    /**
     * Store the root node of the hierarchy tree
     */
    /**
     * Store the root node of the hierarchy tree
     * @param {?} root
     * @return {?}
     */
    HierarchyBarService.prototype.setRootNode = /**
     * Store the root node of the hierarchy tree
     * @param {?} root
     * @return {?}
     */
    function (root) {
        // store the root node
        this._root = root;
        // create a flat structure of nodes
        this._nodes = this.getNodeList(root);
        // flatten the array - based on the selected node
        this.nodes$.next(this.getSelectedChildren(root));
    };
    /**
     * Select a node. This causes all nodes to be
     * deselected and the path to the selected node
     * to be selected
     */
    /**
     * Select a node. This causes all nodes to be
     * deselected and the path to the selected node
     * to be selected
     * @param {?} node
     * @return {?}
     */
    HierarchyBarService.prototype.selectNode = /**
     * Select a node. This causes all nodes to be
     * deselected and the path to the selected node
     * to be selected
     * @param {?} node
     * @return {?}
     */
    function (node) {
        // deselect all nodes
        this.deselectAll();
        // ensure the current node is selected and its parents
        this.select(node);
        // emit a new node list to trigger change detection
        this.nodes$.next(this.getSelectedChildren(this._root));
    };
    /**
     * Handles getting children with support for both arrays and observables
     */
    /**
     * Handles getting children with support for both arrays and observables
     * @param {?} node
     * @return {?}
     */
    HierarchyBarService.prototype.getChildren = /**
     * Handles getting children with support for both arrays and observables
     * @param {?} node
     * @return {?}
     */
    function (node) {
        var _this = this;
        if (Array.isArray(node.children)) {
            return of({ loading: false, children: node.children });
        }
        var /** @type {?} */ children$ = node.children;
        // if it is an observable then handle loading
        return Observable.create(function (observer) {
            // emit initial value
            observer.next({ loading: true, children: [] });
            // now wait until the children observable completes
            children$.pipe(first()).subscribe(function (children) {
                // replace the observable with an array for future loading
                node.children = children;
                // rebuild the node tree
                // rebuild the node tree
                _this.setRootNode(_this._root);
                // emit the latest value
                observer.next({ loading: false, children: children });
                // close the observable stream
                observer.complete();
            });
        });
    };
    /**
     * Traverses all the parents to ensure they are selected
     * @param {?} node
     * @return {?}
     */
    HierarchyBarService.prototype.select = /**
     * Traverses all the parents to ensure they are selected
     * @param {?} node
     * @return {?}
     */
    function (node) {
        node.selected = true;
        if (node.parent) {
            this.select(node.parent);
        }
    };
    /**
     * Deselects all nodes
     * @return {?}
     */
    HierarchyBarService.prototype.deselectAll = /**
     * Deselects all nodes
     * @return {?}
     */
    function () {
        this._nodes.forEach(function (node) { return node.selected = false; });
    };
    /**
     * Gets all the nodes in the tree as a flat array.
     * It also stores the parent node in a parent property
     * on the node for easy traversal in both directions
     * @param {?} node
     * @return {?}
     */
    HierarchyBarService.prototype.getNodeList = /**
     * Gets all the nodes in the tree as a flat array.
     * It also stores the parent node in a parent property
     * on the node for easy traversal in both directions
     * @param {?} node
     * @return {?}
     */
    function (node) {
        var _this = this;
        // if there are no children then return only itself
        if (!node.children || node.children instanceof Observable || node.children.length === 0) {
            return [node];
        }
        // store the parent property
        node.children.forEach(function (child) { return child.parent = node; });
        // get all descendants of this node
        var /** @type {?} */ descendants = node.children.reduce(function (nodes, current) { return __spread(nodes, _this.getNodeList(current)); }, []);
        return __spread([node], descendants);
    };
    /**
     * Gets all selected nodes from the parent node.
     * @param {?} node
     * @return {?}
     */
    HierarchyBarService.prototype.getSelectedChildren = /**
     * Gets all selected nodes from the parent node.
     * @param {?} node
     * @return {?}
     */
    function (node) {
        if (node.children instanceof Observable) {
            return [node];
        }
        // get the children - and account for when there is none
        var /** @type {?} */ children = node.children || [];
        // check if any child is selected
        var /** @type {?} */ child = children.find(function (_child) { return _child.selected; });
        // return the remaining chain of selected items
        return child ? __spread([node], this.getSelectedChildren(child)) : [node];
    };
    HierarchyBarService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    HierarchyBarService.ctorParameters = function () { return []; };
    return HierarchyBarService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var HierarchyBarComponent = (function () {
    function HierarchyBarComponent(hierarchyBar) {
        var _this = this;
        this.hierarchyBar = hierarchyBar;
        this.selectedChange = new EventEmitter();
        this.overflow$ = new BehaviorSubject(false);
        this.overflowNodes$ = new BehaviorSubject([]);
        this._subscription = new Subscription();
        // subscribe to changes in the selected node
        var /** @type {?} */ selected = hierarchyBar.nodes$.subscribe(function (nodes) { return _this.selectedChange.emit(nodes.length === 0 ? null : nodes[nodes.length - 1]); });
        var /** @type {?} */ changed = hierarchyBar.nodes$.pipe(debounceTime(0)).subscribe(function () { return _this.scrollIntoView(); });
        // store subscriptions
        this._subscription.add(selected);
        this._subscription.add(changed);
    }
    Object.defineProperty(HierarchyBarComponent.prototype, "root", {
        set: /**
         * @param {?} node
         * @return {?}
         */
        function (node) {
            this.hierarchyBar.setRootNode(node);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HierarchyBarComponent.prototype, "selected", {
        set: /**
         * @param {?} node
         * @return {?}
         */
        function (node) {
            this.hierarchyBar.selectNode(node);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    HierarchyBarComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._subscription.unsubscribe();
    };
    /**
     * When there is overflow ensure that the rightmost
     * node remains in view at all times. The nodes no longer
     * visible be be displayed in a popover available on the
     * overflow indicator
     */
    /**
     * When there is overflow ensure that the rightmost
     * node remains in view at all times. The nodes no longer
     * visible be be displayed in a popover available on the
     * overflow indicator
     * @return {?}
     */
    HierarchyBarComponent.prototype.scrollIntoView = /**
     * When there is overflow ensure that the rightmost
     * node remains in view at all times. The nodes no longer
     * visible be be displayed in a popover available on the
     * overflow indicator
     * @return {?}
     */
    function () {
        var _this = this;
        if (!this.nodelist) {
            return;
        }
        // get the native element
        var nativeElement = this.nodelist.nativeElement;
        // emit whether or not there is overflow
        this.overflow$.next(nativeElement.scrollWidth > nativeElement.offsetWidth);
        // if the hierarchy bar contents do not overflow then do nothing
        if (nativeElement.scrollWidth > nativeElement.offsetWidth) {
            // determine the amount of overflow
            var /** @type {?} */ overflowAmount_1 = nativeElement.scrollWidth - nativeElement.offsetWidth;
            // determine which nodes are not fully visible
            this.overflowNodes$.next(this.nodes.filter(function (node) { return node.nativeElement.offsetLeft < overflowAmount_1; })
                .map(function (node, index) { return _this.hierarchyBar.nodes$.value[index]; }));
            // move the scroll position to always show the last itme
            this.nodelist.nativeElement.scrollLeft = overflowAmount_1;
        }
    };
    HierarchyBarComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-hierarchy-bar',
                    template: "<!-- Allow content to be placed on the left of the items -->\n<aside class=\"hierarchy-bar-addons\">\n    <ng-content select=\"[uxHierarchyBarLeftAddon]\"></ng-content>\n</aside>\n\n<main #nodelist class=\"hierarchy-bar-nodes\" (uxResize)=\"scrollIntoView()\">\n\n    <div *ngIf=\"overflow$ | async\"\n         #popover=\"ux-popover\"\n         class=\"hierarchy-bar-overflow-indicator\"\n         [style.left.px]=\"nodelist.scrollLeft\"\n         [uxPopover]=\"overflow\"\n         [popoverContext]=\"{ popover: popover }\"\n         placement=\"bottom\"\n         popoverClass=\"hierarchy-bar-popover\">\n        . . .\n    </div>\n\n    <div #nodeElement class=\"hierarchy-bar-node\"\n         *ngFor=\"let node of hierarchyBar.nodes$ | async\">\n\n        <button class=\"hierarchy-bar-node-content\"\n                [attr.aria-label]=\"node.title\"\n                (click)=\"hierarchyBar.selectNode(node)\">\n\n            <!-- Show an icon if specifed -->\n            <img class=\"hierarchy-bar-node-icon\" *ngIf=\"node.icon\" [src]=\"node.icon\" alt=\"Hierarchy Bar Icon\">\n\n            <!-- Show the name of the current node -->\n            <span class=\"hierarchy-bar-node-title\">{{ node.title }}</span>\n\n        </button>\n\n        <!-- Show a dropdown arrow if there are children -->\n        <button *ngIf=\"node.children\"\n              #popover=\"ux-popover\"\n              aria-label=\"Show children\"\n              role=\"button\"\n              class=\"hierarchy-bar-node-arrow hpe-icon hpe-next\"\n              [uxPopover]=\"content\"\n              [popoverContext]=\"{ node: node, popover: popover }\"\n              placement=\"bottom\"\n              popoverClass=\"hierarchy-bar-popover\"\n              tabindex=\"0\">\n        </button>\n\n    </div>\n\n</main>\n\n<!-- Allow content to be placed on the right of the items -->\n<aside class=\"hierarchy-bar-addons\">\n    <ng-content select=\"[uxHierarchyBarRightAddon]\"></ng-content>\n</aside>\n\n<!-- Template for the popover list -->\n<ng-template #content let-node=\"node\" let-popover=\"popover\">\n\n    <!-- Loading Indicator -->\n    <ul class=\"hierarchy-bar-node-list\" *ngIf=\"(hierarchyBar.getChildren(node) | async).loading\">\n\n        <li class=\"hierarchy-bar-node-list-item\">\n            <ng-container [ngTemplateOutlet]=\"loadingIndicator || defaultLoadingIndicator\"></ng-container>\n        </li>\n    </ul>\n\n    <!-- List of children -->\n    <ul class=\"hierarchy-bar-node-list\" *ngIf=\"!(hierarchyBar.getChildren(node) | async).loading\">\n\n        <li *ngFor=\"let child of (hierarchyBar.getChildren(node) | async).children; let first = first\"\n            class=\"hierarchy-bar-node-list-item\"\n            [focusIf]=\"first\"\n            tabindex=\"0\"\n            (keydown.enter)=\"hierarchyBar.selectNode(child); popover.hide()\"\n            (click)=\"hierarchyBar.selectNode(child); popover.hide()\">\n\n            <!-- Show an icon if specifed -->\n            <img class=\"hierarchy-bar-node-icon\" *ngIf=\"child.icon\" [src]=\"child.icon\" alt=\"Hierarchy Bar Icon\">\n\n            <!-- Show the name of the current node -->\n            <span class=\"hierarchy-bar-node-title\">{{ child.title }}</span>\n\n        </li>\n\n    </ul>\n</ng-template>\n\n<!-- Template for the overflow popover list -->\n<ng-template #overflow let-popover=\"popover\">\n\n    <ul class=\"hierarchy-bar-node-list\">\n\n        <li *ngFor=\"let child of overflowNodes$ | async; let first = first\"\n            class=\"hierarchy-bar-node-list-item\"\n            tabindex=\"0\"\n            [focusIf]=\"first\"\n            (click)=\"hierarchyBar.selectNode(child); popover.hide()\"\n            (keydown.enter)=\"hierarchyBar.selectNode(child); popover.hide()\">\n\n            <!-- Show an icon if specifed -->\n            <img class=\"hierarchy-bar-node-icon\" *ngIf=\"child.icon\" [src]=\"child.icon\" alt=\"Hierarchy Bar Icon\">\n\n            <!-- Show the name of the current node -->\n            <span class=\"hierarchy-bar-node-title\">{{ child.title }}</span>\n\n        </li>\n\n    </ul>\n</ng-template>\n\n<!-- Loading Indicator Template -->\n<ng-template #defaultLoadingIndicator>\n    <div class=\"hierarchy-bar-node-icon\" alt=\"Hierarchy Bar Loading Indicator\">\n        <div class=\"spinner spinner-accent spinner-bounce-middle\"></div>\n    </div>\n\n    <!-- Show the name of the current node -->\n    <span class=\"hierarchy-bar-node-title\">Loading...</span>\n</ng-template>",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    viewProviders: [HierarchyBarService]
                },] },
    ];
    /** @nocollapse */
    HierarchyBarComponent.ctorParameters = function () { return [
        { type: HierarchyBarService, },
    ]; };
    HierarchyBarComponent.propDecorators = {
        "root": [{ type: Input },],
        "selected": [{ type: Input },],
        "loadingIndicator": [{ type: Input },],
        "selectedChange": [{ type: Output },],
        "nodelist": [{ type: ViewChild, args: ['nodelist',] },],
        "nodes": [{ type: ViewChildren, args: ['nodeElement',] },],
    };
    return HierarchyBarComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ClickOutsideDirective = (function () {
    function ClickOutsideDirective(_elementRef) {
        this._elementRef = _elementRef;
        this.uxClickOutside = new EventEmitter();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    ClickOutsideDirective.prototype.click = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this._elementRef.nativeElement !== event.target && !this._elementRef.nativeElement.contains(event.target)) {
            this.uxClickOutside.emit(event);
        }
    };
    ClickOutsideDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[uxClickOutside]'
                },] },
    ];
    /** @nocollapse */
    ClickOutsideDirective.ctorParameters = function () { return [
        { type: ElementRef, },
    ]; };
    ClickOutsideDirective.propDecorators = {
        "uxClickOutside": [{ type: Output },],
        "click": [{ type: HostListener, args: ['document:click', ['$event'],] },],
    };
    return ClickOutsideDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ClickOutsideModule = (function () {
    function ClickOutsideModule() {
    }
    ClickOutsideModule.decorators = [
        { type: NgModule, args: [{
                    exports: [ClickOutsideDirective],
                    declarations: [ClickOutsideDirective]
                },] },
    ];
    /** @nocollapse */
    ClickOutsideModule.ctorParameters = function () { return []; };
    return ClickOutsideModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var /** @type {?} */ uniquePopoverId = 0;
var PopoverComponent = (function (_super) {
    __extends(PopoverComponent, _super);
    function PopoverComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * Define a unique id for each popover
         */
        _this.id = "ux-popover-" + ++uniquePopoverId;
        /**
         * This will emit an event any time the user clicks outside the popover
         */
        _this.clickOutside$ = new Subject();
        return _this;
    }
    /** This will update the title of the popover and trigger change detection */
    /**
     * This will update the title of the popover and trigger change detection
     * @param {?} title
     * @return {?}
     */
    PopoverComponent.prototype.setTitle = /**
     * This will update the title of the popover and trigger change detection
     * @param {?} title
     * @return {?}
     */
    function (title) {
        this.title = title;
        this._changeDetectorRef.markForCheck();
    };
    PopoverComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-popover',
                    template: "<div class=\"popover show\" [ngClass]=\"[placement, customClass]\" [id]=\"id\" [attr.role]=\"role\" (uxClickOutside)=\"clickOutside$.next($event)\">\n    <div class=\"arrow\"></div>\n    <h3 class=\"popover-title\" *ngIf=\"title\">{{ title }}</h3>\n    <div class=\"popover-content\" (cdkObserveContent)=\"reposition()\">\n        <ng-container *ngIf=\"!isTemplateRef\">{{ content }}</ng-container>\n        <ng-container *ngIf=\"isTemplateRef\" [ngTemplateOutlet]=\"content\" [ngTemplateOutletContext]=\"context\"></ng-container>\n    </div>\n</div>",
                    changeDetection: ChangeDetectionStrategy.OnPush
                },] },
    ];
    /** @nocollapse */
    PopoverComponent.ctorParameters = function () { return []; };
    return PopoverComponent;
}(TooltipComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var PopoverDirective = (function (_super) {
    __extends(PopoverDirective, _super);
    function PopoverDirective() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * All the user to add a custom class to the popover
         */
        _this.customClass = '';
        /**
         * All the user to add a role to the popover - default is tooltip
         */
        _this.role = 'tooltip';
        /**
         * Provide the TemplateRef a context object
         */
        _this.context = {};
        /**
         * Delay the showing of the popover by a number of miliseconds
         */
        _this.delay = 0;
        /**
         * Specify which events should show the popover
         */
        _this.showTriggers = ['click'];
        /**
         * Specify which events should hide the popover
         */
        _this.hideTriggers = ['click', 'clickoutside', 'escape'];
        /**
         * Keep track of the tooltip visibility and update aria-expanded attribute
         */
        _this.isVisible = false;
        /**
         * Internally store the type of this component - usual for distinctions when extending the tooltip class
         */
        _this._type = 'popover';
        return _this;
    }
    /** Set up the triggers and bind to the show/hide events to keep visibility in sync */
    /**
     * Set up the triggers and bind to the show/hide events to keep visibility in sync
     * @return {?}
     */
    PopoverDirective.prototype.ngOnInit = /**
     * Set up the triggers and bind to the show/hide events to keep visibility in sync
     * @return {?}
     */
    function () {
        // set up the event triggers
        fromEvent(document, 'keydown').pipe(takeUntil(this._onDestroy)).subscribe(this.onKeyDown.bind(this));
        // check if there is an aria-described by attribute
        this._ariaDescribedBy = this._elementRef.nativeElement.hasAttribute('aria-describedby');
        // set up the default event triggers
        _super.prototype.ngOnInit.call(this);
    };
    /**
     * We need to send input changes to the popover component
     * We can't use setters as they may trigger before popover initialised and can't resend once initialised
     **/
    /**
     * We need to send input changes to the popover component
     * We can't use setters as they may trigger before popover initialised and can't resend once initialised
     *
     * @param {?} changes
     * @return {?}
     */
    PopoverDirective.prototype.ngOnChanges = /**
     * We need to send input changes to the popover component
     * We can't use setters as they may trigger before popover initialised and can't resend once initialised
     *
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        _super.prototype.ngOnChanges.call(this, changes);
        if (this._instance && changes["title"]) {
            this._instance.setTitle(changes["title"].currentValue);
        }
    };
    /**
     * @param {?} overlayRef
     * @return {?}
     */
    PopoverDirective.prototype.createInstance = /**
     * @param {?} overlayRef
     * @return {?}
     */
    function (overlayRef) {
        var /** @type {?} */ instance = /** @type {?} */ (overlayRef.attach(this._portal).instance);
        // supply the tooltip with the correct properties
        instance.setTitle(this.title);
        instance.setContent(this.content);
        instance.setPlacement(this.placement);
        instance.setClass(this.customClass);
        instance.setContext(this.context);
        instance.setRole(this.role);
        // Update the aria-describedby attribute
        this.setAriaDescribedBy(instance.id);
        // subscribe to the outside click event
        instance.clickOutside$.pipe(takeUntil(this._onDestroy)).subscribe(this.onClickOutside.bind(this));
        return instance;
    };
    /**
     * @return {?}
     */
    PopoverDirective.prototype.createPortal = /**
     * @return {?}
     */
    function () {
        return this._portal || new ComponentPortal(PopoverComponent, this._viewContainerRef);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    PopoverDirective.prototype.onKeyDown = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        // if visible and the escape key is pressed and it is one of the hide triggers
        if (this.isVisible && event.keyCode === ESCAPE && this.includes(this.hideTriggers, 'escape')) {
            this.hide();
        }
    };
    /**
     * @return {?}
     */
    PopoverDirective.prototype.onClickOutside = /**
     * @return {?}
     */
    function () {
        // if visible and it is one of the hide triggers
        if (this.isVisible && this.includes(this.hideTriggers, 'clickoutside')) {
            this.hide();
        }
    };
    /** Programmatically update the aria-describedby property */
    /**
     * Programmatically update the aria-describedby property
     * @param {?} id
     * @return {?}
     */
    PopoverDirective.prototype.setAriaDescribedBy = /**
     * Programmatically update the aria-describedby property
     * @param {?} id
     * @return {?}
     */
    function (id) {
        // we only want to set the aria-describedby attr when the content is a string and there was no user defined attribute already
        if (this._ariaDescribedBy === false && typeof this.content === 'string') {
            _super.prototype.setAriaDescribedBy.call(this, id);
        }
    };
    PopoverDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[uxPopover]',
                    exportAs: 'ux-popover'
                },] },
    ];
    /** @nocollapse */
    PopoverDirective.ctorParameters = function () { return []; };
    PopoverDirective.propDecorators = {
        "content": [{ type: Input, args: ['uxPopover',] },],
        "title": [{ type: Input, args: ['popoverTitle',] },],
        "disabled": [{ type: Input, args: ['popoverDisabled',] },],
        "customClass": [{ type: Input, args: ['popoverClass',] },],
        "role": [{ type: Input, args: ['popoverRole',] },],
        "context": [{ type: Input, args: ['popoverContext',] },],
        "delay": [{ type: Input, args: ['popoverDelay',] },],
        "showTriggers": [{ type: Input },],
        "hideTriggers": [{ type: Input },],
        "isVisible": [{ type: HostBinding, args: ['attr.aria-expanded',] },],
    };
    return PopoverDirective;
}(TooltipDirective$1));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var PopoverModule = (function () {
    function PopoverModule() {
    }
    PopoverModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        OverlayModule,
                        ObserversModule,
                        ClickOutsideModule,
                        TooltipModule
                    ],
                    exports: [PopoverDirective],
                    declarations: [PopoverComponent, PopoverDirective],
                    entryComponents: [PopoverComponent]
                },] },
    ];
    /** @nocollapse */
    PopoverModule.ctorParameters = function () { return []; };
    return PopoverModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var HierarchyBarModule = (function () {
    function HierarchyBarModule() {
    }
    HierarchyBarModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        ResizeModule,
                        FocusIfModule,
                        PopoverModule
                    ],
                    exports: [HierarchyBarComponent],
                    declarations: [HierarchyBarComponent],
                },] },
    ];
    /** @nocollapse */
    HierarchyBarModule.ctorParameters = function () { return []; };
    return HierarchyBarModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var SidePanelService = (function () {
    function SidePanelService() {
        this.open$ = new BehaviorSubject(false);
    }
    /**
     * @return {?}
     */
    SidePanelService.prototype.open = /**
     * @return {?}
     */
    function () {
        this.open$.next(true);
    };
    /**
     * @return {?}
     */
    SidePanelService.prototype.close = /**
     * @return {?}
     */
    function () {
        this.open$.next(false);
    };
    SidePanelService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    SidePanelService.ctorParameters = function () { return []; };
    return SidePanelService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var SidePanelComponent = (function () {
    function SidePanelComponent(service, _elementRef) {
        this.service = service;
        this._elementRef = _elementRef;
        this.inline = false;
        this.attachTo = 'window';
        this.width = '50%';
        this.top = '0';
        this.modal = false;
        this.animate = false;
        this.closeOnExternalClick = false;
        this.openChange = new EventEmitter();
    }
    Object.defineProperty(SidePanelComponent.prototype, "open", {
        get: /**
         * @return {?}
         */
        function () {
            return this.service.open$.value;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.service.open$.next(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SidePanelComponent.prototype, "position", {
        get: /**
         * @return {?}
         */
        function () {
            if (this.inline) {
                return 'static';
            }
            if (this.attachTo === 'container') {
                return 'absolute';
            }
            return 'fixed';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SidePanelComponent.prototype, "cssWidth", {
        get: /**
         * @return {?}
         */
        function () {
            if (typeof this.width === 'number') {
                return this.width === 0 ? '0' : this.width + 'px';
            }
            return this.width;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SidePanelComponent.prototype, "cssTop", {
        get: /**
         * @return {?}
         */
        function () {
            if (typeof this.top === 'number') {
                return this.top === 0 ? '0' : this.top + 'px';
            }
            return this.top;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SidePanelComponent.prototype, "componentWidth", {
        get: /**
         * @return {?}
         */
        function () {
            if (this.inline) {
                return this.open ? this.cssWidth : '0';
            }
            return null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SidePanelComponent.prototype, "hostWidth", {
        get: /**
         * @return {?}
         */
        function () {
            return this.inline ? '100%' : this.cssWidth;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    SidePanelComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this._subscription = this.service.open$.subscribe(function (next) {
            _this.openChange.emit(next);
        });
    };
    /**
     * @return {?}
     */
    SidePanelComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._subscription.unsubscribe();
    };
    /**
     * @return {?}
     */
    SidePanelComponent.prototype.openPanel = /**
     * @return {?}
     */
    function () {
        this.service.open();
    };
    /**
     * @return {?}
     */
    SidePanelComponent.prototype.closePanel = /**
     * @return {?}
     */
    function () {
        this.service.close();
    };
    /**
     * @param {?} event
     * @return {?}
     */
    SidePanelComponent.prototype.clickHandler = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (!this.open || !this.closeOnExternalClick) {
            return;
        }
        var /** @type {?} */ target = /** @type {?} */ (event.target);
        if (!this._elementRef.nativeElement.contains(target) ||
            (target && target.classList.contains('modal-backdrop'))) {
            this.closePanel();
        }
    };
    SidePanelComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-side-panel',
                    exportAs: 'ux-side-panel',
                    template: "<div *ngIf=\"modal && open\" class=\"modal-backdrop\"\n    [style.position]=\"position\"\n    [style.top]=\"cssTop\"></div>\n\n<div class=\"ux-side-panel-host\"\n    [class.modal-panel]=\"modal\"\n    [style.position]=\"position\"\n    [style.width]=\"hostWidth\"\n    [style.top]=\"cssTop\">\n    <ng-content></ng-content>\n</div>\n",
                    providers: [SidePanelService],
                    host: {
                        'class': 'ux-side-panel'
                    }
                },] },
    ];
    /** @nocollapse */
    SidePanelComponent.ctorParameters = function () { return [
        { type: SidePanelService, },
        { type: ElementRef, },
    ]; };
    SidePanelComponent.propDecorators = {
        "open": [{ type: Input }, { type: HostBinding, args: ['class.open',] },],
        "inline": [{ type: Input }, { type: HostBinding, args: ['class.inline',] },],
        "attachTo": [{ type: Input },],
        "width": [{ type: Input },],
        "top": [{ type: Input },],
        "modal": [{ type: Input }, { type: HostBinding, args: ['attr.aria-modal',] },],
        "animate": [{ type: Input }, { type: HostBinding, args: ['class.animate',] },],
        "closeOnExternalClick": [{ type: Input },],
        "openChange": [{ type: Output },],
        "componentWidth": [{ type: HostBinding, args: ['style.width',] },],
        "closePanel": [{ type: HostListener, args: ['document:keyup.escape',] },],
        "clickHandler": [{ type: HostListener, args: ['document:click', ['$event'],] },],
    };
    return SidePanelComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ItemDisplayPanelContentDirective = (function () {
    function ItemDisplayPanelContentDirective() {
    }
    ItemDisplayPanelContentDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[uxItemDisplayPanelContent]'
                },] },
    ];
    /** @nocollapse */
    ItemDisplayPanelContentDirective.ctorParameters = function () { return []; };
    return ItemDisplayPanelContentDirective;
}());
var ItemDisplayPanelFooterDirective = (function () {
    function ItemDisplayPanelFooterDirective() {
    }
    ItemDisplayPanelFooterDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[uxItemDisplayPanelFooter]'
                },] },
    ];
    /** @nocollapse */
    ItemDisplayPanelFooterDirective.ctorParameters = function () { return []; };
    return ItemDisplayPanelFooterDirective;
}());
var ItemDisplayPanelComponent = (function (_super) {
    __extends(ItemDisplayPanelComponent, _super);
    function ItemDisplayPanelComponent(service, elementRef) {
        var _this = _super.call(this, service, elementRef) || this;
        _this.boxShadow = true;
        _this.closeVisible = true;
        _this.shadow = false;
        _this.visibleChange = new EventEmitter();
        _this.animate = false;
        _this.closeOnExternalClick = true;
        return _this;
    }
    Object.defineProperty(ItemDisplayPanelComponent.prototype, "preventClose", {
        get: /**
         * @return {?}
         */
        function () {
            return !this.closeOnExternalClick;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.closeOnExternalClick = !value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ItemDisplayPanelComponent.prototype, "title", {
        get: /**
         * @return {?}
         */
        function () {
            return this.header;
        },
        set: /**
         * @deprecated
         * Title used for adding tooltips and shouldn't be used as an input
         * instead header will be used. This is here to support backward compatibility only
         * this property should not be used.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.header = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ItemDisplayPanelComponent.prototype, "visible", {
        get: /**
         * @return {?}
         */
        function () {
            return this.open;
        },
        set: /**
         * @param {?} visible
         * @return {?}
         */
        function (visible) {
            this.open = visible;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ItemDisplayPanelComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this._itemDisplayPanelSubscription = this.service.open$.subscribe(function (next) {
            _this.visibleChange.emit(next);
        });
    };
    /**
     * @return {?}
     */
    ItemDisplayPanelComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._itemDisplayPanelSubscription.unsubscribe();
    };
    ItemDisplayPanelComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-item-display-panel',
                    template: "<div class=\"ux-side-panel-host ux-item-display-panel\"\n    [class.box-shadow]=\"boxShadow\"\n    [style.position]=\"position\"\n    [style.width]=\"hostWidth\"\n    [style.top]=\"cssTop\">\n\n    <div class=\"ux-side-panel-header\" [class.item-display-panel-shadow]=\"shadow\">\n        <h3>{{ header }}</h3>\n        <button *ngIf=\"closeVisible\" type=\"button\" class=\"btn btn-lg btn-link btn-icon button-secondary\" (click)=\"visible = false\">\n            <i class=\"hpe-icon hpe-close\"></i>\n        </button>\n    </div>\n\n    <div class=\"ux-side-panel-content\">\n        <ng-content select=\"[uxItemDisplayPanelContent]\"></ng-content>\n    </div>\n\n    <div class=\"ux-side-panel-footer\" *ngIf=\"footer\">\n        <ng-content select=\"[uxItemDisplayPanelFooter]\"></ng-content>\n    </div>\n\n</div>\n",
                    providers: [SidePanelService],
                    host: {
                        'class': 'ux-side-panel ux-item-display-panel'
                    }
                },] },
    ];
    /** @nocollapse */
    ItemDisplayPanelComponent.ctorParameters = function () { return [
        { type: SidePanelService, },
        { type: ElementRef, },
    ]; };
    ItemDisplayPanelComponent.propDecorators = {
        "header": [{ type: Input },],
        "boxShadow": [{ type: Input },],
        "closeVisible": [{ type: Input },],
        "preventClose": [{ type: Input },],
        "shadow": [{ type: Input },],
        "footer": [{ type: ContentChild, args: [ItemDisplayPanelFooterDirective,] },],
        "visibleChange": [{ type: Output },],
        "title": [{ type: Input },],
        "visible": [{ type: Input },],
    };
    return ItemDisplayPanelComponent;
}(SidePanelComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var /** @type {?} */ DECLARATIONS$3 = [
    ItemDisplayPanelComponent,
    ItemDisplayPanelContentDirective,
    ItemDisplayPanelFooterDirective
];
var ItemDisplayPanelModule = (function () {
    function ItemDisplayPanelModule() {
    }
    ItemDisplayPanelModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule
                    ],
                    exports: DECLARATIONS$3,
                    declarations: DECLARATIONS$3
                },] },
    ];
    /** @nocollapse */
    ItemDisplayPanelModule.ctorParameters = function () { return []; };
    return ItemDisplayPanelModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var WizardStepComponent = (function () {
    function WizardStepComponent() {
        this.valid = true;
        this.visitedChange = new EventEmitter();
        this._active = false;
        this._visited = false;
    }
    Object.defineProperty(WizardStepComponent.prototype, "visited", {
        get: /**
         * @return {?}
         */
        function () {
            return this._visited;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._visited = value;
            this.visitedChange.next(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WizardStepComponent.prototype, "active", {
        get: /**
         * @return {?}
         */
        function () {
            return this._active;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            // store the active state of the step
            this._active = value;
            // if the value is true then the step should also be marked as visited
            if (value === true) {
                this.visited = true;
            }
        },
        enumerable: true,
        configurable: true
    });
    WizardStepComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-wizard-step',
                    template: "<ng-container *ngIf=\"active\">\n    <ng-content></ng-content>\n</ng-container>"
                },] },
    ];
    /** @nocollapse */
    WizardStepComponent.ctorParameters = function () { return []; };
    WizardStepComponent.propDecorators = {
        "header": [{ type: Input },],
        "valid": [{ type: Input },],
        "visitedChange": [{ type: Input },],
        "visited": [{ type: Input },],
    };
    return WizardStepComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var WizardComponent = (function () {
    function WizardComponent() {
        this._step = 0;
        this.steps = new QueryList();
        this.orientation = 'horizontal';
        this.nextText = 'Next';
        this.previousText = 'Previous';
        this.cancelText = 'Cancel';
        this.finishText = 'Finish';
        this.nextTooltip = 'Go to the next step';
        this.previousTooltip = 'Go to the previous step';
        this.cancelTooltip = 'Cancel the wizard';
        this.finishTooltip = 'Finish the wizard';
        this.nextDisabled = false;
        this.previousDisabled = false;
        this.cancelDisabled = false;
        this.finishDisabled = false;
        this.nextVisible = true;
        this.previousVisible = true;
        this.cancelVisible = true;
        this.finishVisible = true;
        this.cancelAlwaysVisible = false;
        this.finishAlwaysVisible = false;
        this.onNext = new EventEmitter();
        this.onPrevious = new EventEmitter();
        this.onCancel = new EventEmitter();
        this.onFinishing = new EventEmitter();
        this.onFinish = new EventEmitter();
        this.stepChanging = new EventEmitter();
        this.stepChange = new EventEmitter();
        this.invalidIndicator = false;
    }
    Object.defineProperty(WizardComponent.prototype, "step", {
        get: /**
         * @return {?}
         */
        function () {
            return this._step;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            // only accept numbers as valid options
            if (typeof value === 'number') {
                // store the active step
                this._step = value;
                // update which steps should be active
                this.update();
                // emit the change event
                this.stepChange.next(this.step);
                // reset the invalid state
                this.invalidIndicator = false;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    WizardComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        // initially set the correct visibility of the steps
        setTimeout(this.update.bind(this));
    };
    /**
     * Navigate to the next step
     */
    /**
     * Navigate to the next step
     * @return {?}
     */
    WizardComponent.prototype.next = /**
     * Navigate to the next step
     * @return {?}
     */
    function () {
        this.stepChanging.next(new StepChangingEvent(this.step, this.step + 1));
        // check if current step is invalid
        if (!this.getCurrentStep().valid) {
            this.invalidIndicator = true;
            return;
        }
        // check if we are currently on the last step
        if ((this.step + 1) < this.steps.length) {
            this.step++;
            // emit the current step
            this.onNext.next(this.step);
        }
    };
    /**
     * Navigate to the previous step
     */
    /**
     * Navigate to the previous step
     * @return {?}
     */
    WizardComponent.prototype.previous = /**
     * Navigate to the previous step
     * @return {?}
     */
    function () {
        this.stepChanging.next(new StepChangingEvent(this.step, this.step - 1));
        // check if we are currently on the last step
        if (this.step > 0) {
            this.step--;
            // emit the current step
            this.onPrevious.next(this.step);
        }
    };
    /**
     * Perform actions when the finish button is clicked
     */
    /**
     * Perform actions when the finish button is clicked
     * @return {?}
     */
    WizardComponent.prototype.finish = /**
     * Perform actions when the finish button is clicked
     * @return {?}
     */
    function () {
        var _this = this;
        // fires when the finish button is clicked always
        this.onFinishing.next();
        /**
                 * This is required because we need to ensure change detection has run
                 * to determine whether or not we have the latest value for the 'valid' input
                 * on the current step. Unfortunately we can't use ChangeDetectorRef as we are looking to run
                 * on content children, and we cant use ApplicationRef.tick() as this does not work in a hybrid app, eg. our docs
                 */
        return new Promise(function (resolve) {
            setTimeout(function () {
                // only fires when the finish button is clicked and the step is valid
                if (_this.getCurrentStep().valid) {
                    _this.onFinish.next();
                }
                resolve();
            });
        });
    };
    /**
     * Perform actions when the cancel button is clicked
     */
    /**
     * Perform actions when the cancel button is clicked
     * @return {?}
     */
    WizardComponent.prototype.cancel = /**
     * Perform actions when the cancel button is clicked
     * @return {?}
     */
    function () {
        this.onCancel.next();
    };
    /**
     * Update the active state of each step
     */
    /**
     * Update the active state of each step
     * @return {?}
     */
    WizardComponent.prototype.update = /**
     * Update the active state of each step
     * @return {?}
     */
    function () {
        var _this = this;
        // update which steps should be active
        this.steps.forEach(function (step, idx) { return step.active = idx === _this.step; });
    };
    /**
     * Jump to a specific step only if the step has previously been visited
     */
    /**
     * Jump to a specific step only if the step has previously been visited
     * @param {?} step
     * @return {?}
     */
    WizardComponent.prototype.gotoStep = /**
     * Jump to a specific step only if the step has previously been visited
     * @param {?} step
     * @return {?}
     */
    function (step) {
        if (step.visited) {
            var /** @type {?} */ stepIndex = this.steps.toArray().findIndex(function (stp) { return stp === step; });
            this.stepChanging.next(new StepChangingEvent(this.step, stepIndex));
            this.step = stepIndex;
        }
    };
    /**
     * Determine if the current step is the last step
     */
    /**
     * Determine if the current step is the last step
     * @return {?}
     */
    WizardComponent.prototype.isLastStep = /**
     * Determine if the current step is the last step
     * @return {?}
     */
    function () {
        return this.step === (this.steps.length - 1);
    };
    /**
     * Reset the wizard - goes to first step and resets visited state
     */
    /**
     * Reset the wizard - goes to first step and resets visited state
     * @return {?}
     */
    WizardComponent.prototype.reset = /**
     * Reset the wizard - goes to first step and resets visited state
     * @return {?}
     */
    function () {
        // mark all steps as not visited
        this.steps.forEach(function (step) { return step.visited = false; });
        // go to the first step
        this.step = 0;
    };
    /**
     * Get the step at the current index
     */
    /**
     * Get the step at the current index
     * @return {?}
     */
    WizardComponent.prototype.getCurrentStep = /**
     * Get the step at the current index
     * @return {?}
     */
    function () {
        return this.getStepAtIndex(this.step);
    };
    /**
     * Return a step at a specific index
     */
    /**
     * Return a step at a specific index
     * @param {?} index
     * @return {?}
     */
    WizardComponent.prototype.getStepAtIndex = /**
     * Return a step at a specific index
     * @param {?} index
     * @return {?}
     */
    function (index) {
        return this.steps.toArray()[index];
    };
    WizardComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-wizard',
                    template: "<div class=\"wizard-body\">\n\n    <div class=\"wizard-steps\">\n\n        <div class=\"wizard-step\" [class.active]=\"stp.active\" [class.visited]=\"stp.visited\" [class.invalid]=\"stp.active && !stp.valid && invalidIndicator\" (click)=\"gotoStep(stp)\" *ngFor=\"let stp of steps\">\n            {{ stp.header }}\n        </div>\n\n    </div>\n\n    <div class=\"wizard-content\">\n        <ng-content></ng-content>\n    </div>\n\n</div>\n\n<div class=\"wizard-footer\">\n    <button #tip=\"ux-tooltip\" class=\"btn button-secondary\" *ngIf=\"previousVisible\" [uxTooltip]=\"previousTooltip\" [disabled]=\"previousDisabled || step === 0\"\n        (click)=\"previous(); tip.hide()\">{{ previousText }}</button>\n\n    <button #tip=\"ux-tooltip\" class=\"btn button-primary\" *ngIf=\"nextVisible && !isLastStep()\" [uxTooltip]=\"nextTooltip\" [disabled]=\"nextDisabled\"\n        (click)=\"next(); tip.hide()\">{{ nextText }}</button>\n\n    <button #tip=\"ux-tooltip\" class=\"btn button-primary\" *ngIf=\"finishVisible && isLastStep() || finishAlwaysVisible\" [uxTooltip]=\"finishTooltip\"\n        [disabled]=\"finishDisabled\" (click)=\"finish(); tip.hide()\">{{ finishText }}</button>\n\n    <button #tip=\"ux-tooltip\" class=\"btn button-secondary\" *ngIf=\"cancelVisible && !isLastStep() || cancelAlwaysVisible\" [uxTooltip]=\"cancelTooltip\"\n        [disabled]=\"cancelDisabled\" (click)=\"cancel(); tip.hide()\">{{ cancelText }}</button>\n</div>",
                    host: {
                        '[class]': 'orientation'
                    }
                },] },
    ];
    /** @nocollapse */
    WizardComponent.ctorParameters = function () { return []; };
    WizardComponent.propDecorators = {
        "steps": [{ type: ContentChildren, args: [WizardStepComponent,] },],
        "orientation": [{ type: Input },],
        "nextText": [{ type: Input },],
        "previousText": [{ type: Input },],
        "cancelText": [{ type: Input },],
        "finishText": [{ type: Input },],
        "nextTooltip": [{ type: Input },],
        "previousTooltip": [{ type: Input },],
        "cancelTooltip": [{ type: Input },],
        "finishTooltip": [{ type: Input },],
        "nextDisabled": [{ type: Input },],
        "previousDisabled": [{ type: Input },],
        "cancelDisabled": [{ type: Input },],
        "finishDisabled": [{ type: Input },],
        "nextVisible": [{ type: Input },],
        "previousVisible": [{ type: Input },],
        "cancelVisible": [{ type: Input },],
        "finishVisible": [{ type: Input },],
        "cancelAlwaysVisible": [{ type: Input },],
        "finishAlwaysVisible": [{ type: Input },],
        "onNext": [{ type: Output },],
        "onPrevious": [{ type: Output },],
        "onCancel": [{ type: Output },],
        "onFinishing": [{ type: Output },],
        "onFinish": [{ type: Output },],
        "stepChanging": [{ type: Output },],
        "stepChange": [{ type: Output },],
        "step": [{ type: Input },],
    };
    return WizardComponent;
}());
var StepChangingEvent = (function () {
    function StepChangingEvent(from$$1, to) {
        this.from = from$$1;
        this.to = to;
    }
    return StepChangingEvent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var /** @type {?} */ DECLARATIONS$4 = [
    WizardComponent,
    WizardStepComponent
];
var WizardModule = (function () {
    function WizardModule() {
    }
    WizardModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        TooltipModule
                    ],
                    exports: DECLARATIONS$4,
                    declarations: DECLARATIONS$4
                },] },
    ];
    /** @nocollapse */
    WizardModule.ctorParameters = function () { return []; };
    return WizardModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * This service is required to provide a form of communication
 * between the marquee wizard steps and the containing marquee wizard.
 * We cannot inject the Host due to the steps being content children
 * rather than view children.
 */
var MarqueeWizardService = (function () {
    function MarqueeWizardService() {
        this.valid$ = new Subject();
    }
    MarqueeWizardService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    MarqueeWizardService.ctorParameters = function () { return []; };
    return MarqueeWizardService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var MarqueeWizardStepComponent = (function (_super) {
    __extends(MarqueeWizardStepComponent, _super);
    function MarqueeWizardStepComponent(_marqueeWizardService) {
        var _this = _super.call(this) || this;
        _this._marqueeWizardService = _marqueeWizardService;
        _this.completed = false;
        _this.completedChange = new EventEmitter();
        _this._valid = true;
        return _this;
    }
    Object.defineProperty(MarqueeWizardStepComponent.prototype, "valid", {
        get: /**
         * @return {?}
         */
        function () {
            return this._valid;
        },
        set: /**
         * @param {?} valid
         * @return {?}
         */
        function (valid) {
            this._valid = valid;
            if (this._marqueeWizardService) {
                this._marqueeWizardService.valid$.next({ step: this, valid: valid });
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Update the completed state and emit the latest value
     * @param completed whether or not the step is completed
     */
    /**
     * Update the completed state and emit the latest value
     * @param {?} completed whether or not the step is completed
     * @return {?}
     */
    MarqueeWizardStepComponent.prototype.setCompleted = /**
     * Update the completed state and emit the latest value
     * @param {?} completed whether or not the step is completed
     * @return {?}
     */
    function (completed) {
        this.completed = completed;
        this.completedChange.emit(completed);
    };
    MarqueeWizardStepComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-marquee-wizard-step',
                    template: "<ng-container *ngIf=\"active\">\n    <ng-content></ng-content>\n</ng-container>"
                },] },
    ];
    /** @nocollapse */
    MarqueeWizardStepComponent.ctorParameters = function () { return [
        { type: MarqueeWizardService, },
    ]; };
    MarqueeWizardStepComponent.propDecorators = {
        "icon": [{ type: Input },],
        "completed": [{ type: Input },],
        "completedChange": [{ type: Output },],
    };
    return MarqueeWizardStepComponent;
}(WizardStepComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var MarqueeWizardComponent = (function (_super) {
    __extends(MarqueeWizardComponent, _super);
    function MarqueeWizardComponent(marqueeWizardService) {
        var _this = _super.call(this) || this;
        _this.steps = new QueryList();
        marqueeWizardService.valid$.pipe(filter(function (event) { return !event.valid; })).subscribe(_this.validChange.bind(_this));
        return _this;
    }
    Object.defineProperty(MarqueeWizardComponent.prototype, "isTemplate", {
        get: /**
         * @return {?}
         */
        function () {
            return this.description && this.description instanceof TemplateRef;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * If the current step is valid, mark it as
     * complete and go to the next step
     */
    /**
     * If the current step is valid, mark it as
     * complete and go to the next step
     * @return {?}
     */
    MarqueeWizardComponent.prototype.next = /**
     * If the current step is valid, mark it as
     * complete and go to the next step
     * @return {?}
     */
    function () {
        // get the current step
        var /** @type {?} */ step = /** @type {?} */ (this.getCurrentStep());
        if (step.valid) {
            _super.prototype.next.call(this);
            // mark this step as completed
            step.setCompleted(true);
        }
    };
    /**
     * Emit the onFinishing event and if valid the onFinish event.
     * Also mark the final step as completed if it is valid
     */
    /**
     * Emit the onFinishing event and if valid the onFinish event.
     * Also mark the final step as completed if it is valid
     * @return {?}
     */
    MarqueeWizardComponent.prototype.finish = /**
     * Emit the onFinishing event and if valid the onFinish event.
     * Also mark the final step as completed if it is valid
     * @return {?}
     */
    function () {
        // get the current step
        var /** @type {?} */ step = /** @type {?} */ (this.getCurrentStep());
        // call the original finish function
        return _super.prototype.finish.call(this).then(function () {
            // if the step is valid indicate that it is now complete
            if (step.valid) {
                step.setCompleted(true);
            }
        });
    };
    /**
     * If a step in the wizard becomes invalid, all steps sequentially after
     * it, should become unvisited and incomplete
     */
    /**
     * If a step in the wizard becomes invalid, all steps sequentially after
     * it, should become unvisited and incomplete
     * @param {?} state
     * @return {?}
     */
    MarqueeWizardComponent.prototype.validChange = /**
     * If a step in the wizard becomes invalid, all steps sequentially after
     * it, should become unvisited and incomplete
     * @param {?} state
     * @return {?}
     */
    function (state$$1) {
        var /** @type {?} */ steps = this.steps.toArray();
        var /** @type {?} */ current = steps.findIndex(function (step) { return step === state$$1.step; });
        var /** @type {?} */ affected = steps.slice(current);
        affected.forEach(function (step) {
            // the step should no longer be completed
            step.completed = false;
            // if the step is not the current step then also mark it as unvisited
            if (step !== state$$1.step) {
                step.visited = false;
            }
        });
    };
    MarqueeWizardComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-marquee-wizard',
                    template: "<div class=\"marquee-wizard-side-panel\">\n\n    <div class=\"marquee-wizard-description-container\" *ngIf=\"description\">\n        <!-- If a template was provided display it -->\n        <ng-container *ngIf=\"isTemplate\" [ngTemplateOutlet]=\"description\"></ng-container>\n\n        <!-- Otherwise wimply display the string -->\n        <ng-container *ngIf=\"!isTemplate\">\n            <p>{{ description }}</p>\n        </ng-container>\n    </div>\n\n    <ul class=\"marquee-wizard-steps\">\n\n        <li class=\"marquee-wizard-step\" *ngFor=\"let step of steps\" (click)=\"gotoStep(step)\" [class.active]=\"step.active\" [class.visited]=\"step.visited\" [class.invalid]=\"!step.valid\">\n            <i class=\"marquee-wizard-step-icon\" [ngClass]=\"step.icon\"></i>\n            <span class=\"marquee-wizard-step-title\">{{ step.header }}</span>\n            <span class=\"marquee-wizard-step-status hpe-icon hpe-checkmark\" *ngIf=\"step.completed\"></span>\n        </li>\n\n    </ul>\n</div>\n\n<div class=\"marquee-wizard-content-panel\">\n    <div class=\"marquee-wizard-content\">\n        <ng-content></ng-content>\n    </div>\n\n    <div class=\"modal-footer\">\n\n        <button #tip=\"ux-tooltip\" class=\"btn button-secondary\" *ngIf=\"previousVisible\" [uxTooltip]=\"previousTooltip\" container=\"body\"\n            [disabled]=\"previousDisabled || step === 0\" (click)=\"previous(); tip.hide()\">{{ previousText }}</button>\n\n        <button #tip=\"ux-tooltip\" class=\"btn button-primary\" *ngIf=\"nextVisible && !isLastStep()\" [uxTooltip]=\"nextTooltip\" container=\"body\"\n            [disabled]=\"nextDisabled\" (click)=\"next(); tip.hide()\">{{ nextText }}</button>\n\n        <button #tip=\"ux-tooltip\" class=\"btn button-primary\" *ngIf=\"finishVisible && isLastStep() || finishAlwaysVisible\" [uxTooltip]=\"finishTooltip\"\n            container=\"body\" [disabled]=\"finishDisabled\" (click)=\"finish(); tip.hide()\">{{ finishText }}</button>\n\n        <button #tip=\"ux-tooltip\" class=\"btn button-secondary\" *ngIf=\"cancelVisible && !isLastStep() || cancelAlwaysVisible\" [uxTooltip]=\"cancelTooltip\"\n            container=\"body\" [disabled]=\"cancelDisabled\" (click)=\"cancel(); tip.hide()\">{{ cancelText }}</button>\n    </div>\n</div>",
                    providers: [MarqueeWizardService]
                },] },
    ];
    /** @nocollapse */
    MarqueeWizardComponent.ctorParameters = function () { return [
        { type: MarqueeWizardService, },
    ]; };
    MarqueeWizardComponent.propDecorators = {
        "description": [{ type: Input },],
        "steps": [{ type: ContentChildren, args: [MarqueeWizardStepComponent,] },],
    };
    return MarqueeWizardComponent;
}(WizardComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var MarqueeWizardModule = (function () {
    function MarqueeWizardModule() {
    }
    MarqueeWizardModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        WizardModule,
                        TooltipModule
                    ],
                    exports: [
                        MarqueeWizardComponent,
                        MarqueeWizardStepComponent
                    ],
                    declarations: [
                        MarqueeWizardComponent,
                        MarqueeWizardStepComponent
                    ]
                },] },
    ];
    /** @nocollapse */
    MarqueeWizardModule.ctorParameters = function () { return []; };
    return MarqueeWizardModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AudioService = (function () {
    function AudioService(_http) {
        this._http = _http;
    }
    /**
     * @param {?} mediaElement
     * @return {?}
     */
    AudioService.prototype.getAudioFileMetadata = /**
     * @param {?} mediaElement
     * @return {?}
     */
    function (mediaElement) {
        var _this = this;
        return Observable.create(function (observer) {
            _this._http.request(mediaElement.src, { responseType: ResponseContentType.Blob }).subscribe(function (response) {
                var /** @type {?} */ filename = mediaElement.src.substring(mediaElement.src.lastIndexOf('/') + 1);
                var /** @type {?} */ extension = mediaElement.src.substring(mediaElement.src.lastIndexOf('.') + 1).toLowerCase();
                var /** @type {?} */ blob = response.blob();
                var /** @type {?} */ description;
                switch (extension) {
                    case 'mp3':
                        description = 'MPEG audio layer 3 file';
                        break;
                    case 'wma':
                        description = 'Windows media audio file';
                        break;
                    case 'wav':
                        description = 'WAVE audio file';
                        break;
                    case 'ogg':
                        description = 'Ogg Vorbis file';
                        break;
                    case 'aac':
                        description = 'Advanced audio coding file';
                        break;
                    case 'midi':
                        description = 'Musical instrument digital interface file';
                        break;
                    default:
                        description = 'Audio file';
                        break;
                }
                observer.next({
                    filename: filename,
                    extension: extension,
                    description: description,
                    size: blob.size
                });
            });
        });
    };
    /**
     * @param {?} url
     * @return {?}
     */
    AudioService.prototype.getWaveformFromUrl = /**
     * @param {?} url
     * @return {?}
     */
    function (url) {
        var _this = this;
        // if audio context is not support return a stream of empty data
        if (!(/** @type {?} */ (window)).AudioContext) {
            return of([new Float32Array(0)]);
        }
        this._audioContext = new AudioContext();
        this.createVolumeNode();
        this.createAnalyserNode();
        return Observable.create(function (observer) {
            // load the media from the URL provided
            // load the media from the URL provided
            _this._http.request(url, { responseType: ResponseContentType.ArrayBuffer }).subscribe(function (response) {
                _this.getAudioBuffer(response.arrayBuffer()).subscribe(function (audioBuffer) {
                    // create the buffer source
                    // create the buffer source
                    _this.createBufferSource(audioBuffer);
                    var /** @type {?} */ dataPoints = [];
                    var /** @type {?} */ channels = _this._audioBuffer.numberOfChannels;
                    // extract the data from each channel
                    for (var /** @type {?} */ channelIdx = 0; channelIdx < channels; channelIdx++) {
                        dataPoints[channelIdx] = _this._audioBuffer.getChannelData(channelIdx);
                    }
                    observer.next(dataPoints);
                    observer.complete();
                    // cleanup after ourselves
                    dataPoints = null;
                }, function (error) { return observer.error(error); });
            }, function (error) { return observer.error(error); });
        });
    };
    /**
     * @param {?=} channels
     * @param {?=} skip
     * @return {?}
     */
    AudioService.prototype.getWaveformPoints = /**
     * @param {?=} channels
     * @param {?=} skip
     * @return {?}
     */
    function (channels, skip) {
        if (channels === void 0) { channels = []; }
        if (skip === void 0) { skip = 1000; }
        var /** @type {?} */ waveform = [];
        var /** @type {?} */ duration = channels.length > 0 ? channels[0].length : 0;
        var _loop_1 = function (idx) {
            // get all the channel data for a specific point
            var /** @type {?} */ points = channels.map(function (channel) { return channel[idx]; });
            // find the minimum point and maximum points at each position across all channels
            waveform.push({
                min: points.reduce(function (previous, current) { return current < previous ? current : previous; }),
                max: points.reduce(function (previous, current) { return current > previous ? current : previous; })
            });
        };
        // convert each channel data to a series of waveform points
        for (var /** @type {?} */ idx = 0; idx < duration; idx += skip) {
            _loop_1(idx);
        }
        return waveform;
    };
    /**
     * @param {?} arrayBuffer
     * @return {?}
     */
    AudioService.prototype.getAudioBuffer = /**
     * @param {?} arrayBuffer
     * @return {?}
     */
    function (arrayBuffer) {
        var _this = this;
        return Observable.create(function (observer) {
            _this.getOfflineAudioContext().decodeAudioData(arrayBuffer, function (audioBuffer) {
                observer.next(audioBuffer);
                observer.complete();
            }, function (error) { return observer.error(error); });
        });
    };
    /**
     * @return {?}
     */
    AudioService.prototype.getOfflineAudioContext = /**
     * @return {?}
     */
    function () {
        return new OfflineAudioContext(1, 2, this._audioContext.sampleRate || 44100);
    };
    /**
     * @param {?} audioBuffer
     * @return {?}
     */
    AudioService.prototype.createBufferSource = /**
     * @param {?} audioBuffer
     * @return {?}
     */
    function (audioBuffer) {
        this.disconnectSource();
        this._audioBuffer = audioBuffer;
        this._audioBufferSource = this._audioContext.createBufferSource();
        this._audioBufferSource.buffer = this._audioBuffer;
        this._audioBufferSource.connect(this._analyserNode);
    };
    /**
     * @return {?}
     */
    AudioService.prototype.createVolumeNode = /**
     * @return {?}
     */
    function () {
        this._gainNode = this._audioContext.createGain();
        this._gainNode.connect(this._audioContext.destination);
    };
    /**
     * @return {?}
     */
    AudioService.prototype.createAnalyserNode = /**
     * @return {?}
     */
    function () {
        this._analyserNode = this._audioContext.createAnalyser();
        this._analyserNode.connect(this._gainNode);
    };
    /**
     * @return {?}
     */
    AudioService.prototype.disconnectSource = /**
     * @return {?}
     */
    function () {
        if (this._audioBufferSource) {
            this._audioBufferSource.disconnect();
        }
    };
    AudioService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    AudioService.ctorParameters = function () { return [
        { type: Http, },
    ]; };
    return AudioService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AudioServiceModule = (function () {
    function AudioServiceModule() {
    }
    AudioServiceModule.decorators = [
        { type: NgModule, args: [{
                    imports: [HttpModule],
                    providers: [AudioService]
                },] },
    ];
    /** @nocollapse */
    AudioServiceModule.ctorParameters = function () { return []; };
    return AudioServiceModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var FrameExtractionService = (function () {
    function FrameExtractionService() {
    }
    /**
     * @param {?} source
     * @return {?}
     */
    FrameExtractionService.prototype.createVideoPlayer = /**
     * @param {?} source
     * @return {?}
     */
    function (source) {
        var /** @type {?} */ videoPlayer = document.createElement('video');
        videoPlayer.preload = 'auto';
        videoPlayer.src = source;
        return videoPlayer;
    };
    /**
     * @param {?} width
     * @param {?} height
     * @return {?}
     */
    FrameExtractionService.prototype.createCanvas = /**
     * @param {?} width
     * @param {?} height
     * @return {?}
     */
    function (width, height) {
        var /** @type {?} */ canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        return canvas;
    };
    /**
     * @param {?} videoPlayer
     * @param {?} time
     * @return {?}
     */
    FrameExtractionService.prototype.goToFrame = /**
     * @param {?} videoPlayer
     * @param {?} time
     * @return {?}
     */
    function (videoPlayer, time) {
        videoPlayer.currentTime = time;
        return fromEvent(videoPlayer, time === 0 ? 'loadeddata' : 'seeked');
    };
    /**
     * @param {?} videoPlayer
     * @param {?} canvas
     * @param {?} time
     * @param {?=} width
     * @param {?=} height
     * @return {?}
     */
    FrameExtractionService.prototype.getThumbnail = /**
     * @param {?} videoPlayer
     * @param {?} canvas
     * @param {?} time
     * @param {?=} width
     * @param {?=} height
     * @return {?}
     */
    function (videoPlayer, canvas, time, width, height) {
        var _this = this;
        if (width === void 0) { width = 160; }
        if (height === void 0) { height = 90; }
        return Observable.create(function (observer) {
            // go to specified frame
            var /** @type {?} */ subscription = _this.goToFrame(videoPlayer, time).subscribe(function (event) {
                // create image from current frame
                canvas.getContext('2d').drawImage(videoPlayer, 0, 0, width, height);
                observer.next({ image: canvas.toDataURL(), width: width, height: height, time: time });
                observer.complete();
                subscription.unsubscribe();
            });
        });
    };
    /**
     * @param {?} source
     * @param {?} width
     * @param {?} height
     * @param {?} time
     * @return {?}
     */
    FrameExtractionService.prototype.getFrameThumbnail = /**
     * @param {?} source
     * @param {?} width
     * @param {?} height
     * @param {?} time
     * @return {?}
     */
    function (source, width, height, time) {
        // create required elements
        var /** @type {?} */ videoPlayer = this.createVideoPlayer(source);
        var /** @type {?} */ canvas = this.createCanvas(width, height);
        var /** @type {?} */ frameSubscription = this.getThumbnail(videoPlayer, canvas, time, width, height);
        // ensure we release memory after we are finished
        frameSubscription.subscribe(null, null, function () {
            videoPlayer = null;
            canvas = null;
        });
        return frameSubscription;
    };
    /**
     * @param {?} source
     * @param {?} width
     * @param {?} height
     * @param {?} start
     * @param {?} end
     * @param {?=} skip
     * @return {?}
     */
    FrameExtractionService.prototype.getFrameThumbnails = /**
     * @param {?} source
     * @param {?} width
     * @param {?} height
     * @param {?} start
     * @param {?} end
     * @param {?=} skip
     * @return {?}
     */
    function (source, width, height, start, end, skip) {
        var _this = this;
        if (skip === void 0) { skip = 5; }
        // create required elements
        var /** @type {?} */ videoPlayer = this.createVideoPlayer(source);
        var /** @type {?} */ canvas = this.createCanvas(width, height);
        return Observable.create(function (observer) {
            fromEvent(videoPlayer, 'loadedmetadata').subscribe(function () {
                // calculate the frames required
                var /** @type {?} */ frames = [];
                for (var /** @type {?} */ idx = start; idx < end; idx += skip) {
                    frames.push(_this.getThumbnail(videoPlayer, canvas, idx, width, height));
                }
                concat.apply(void 0, __spread(frames)).subscribe(function (frame) { return observer.next(frame); }, null, function () {
                    videoPlayer = null;
                    canvas = null;
                    observer.complete();
                });
            });
        });
    };
    FrameExtractionService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    FrameExtractionService.ctorParameters = function () { return []; };
    return FrameExtractionService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var FrameExtractionModule = (function () {
    function FrameExtractionModule() {
    }
    FrameExtractionModule.decorators = [
        { type: NgModule, args: [{
                    providers: [FrameExtractionService],
                },] },
    ];
    /** @nocollapse */
    FrameExtractionModule.ctorParameters = function () { return []; };
    return FrameExtractionModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var MediaPlayerService = (function () {
    function MediaPlayerService(_frameExtractionService) {
        var _this = this;
        this._frameExtractionService = _frameExtractionService;
        this.type = 'video';
        this.loaded = false;
        /*
                Create observables for media player events
            */
        this.playing = new BehaviorSubject(false);
        this.initEvent = new BehaviorSubject(false);
        this.abortEvent = new Subject();
        this.canPlayEvent = new BehaviorSubject(false);
        this.canPlayThroughEvent = new BehaviorSubject(false);
        this.durationChangeEvent = new Subject();
        this.endedEvent = new Subject();
        this.errorEvent = new Subject();
        this.loadedDataEvent = new Subject();
        this.loadedMetadataEvent = new Subject();
        this.loadStartEvent = new Subject();
        this.pauseEvent = new Subject();
        this.playEvent = new Subject();
        this.playingEvent = new Subject();
        this.rateChangeEvent = new Subject();
        this.seekedEvent = new Subject();
        this.seekingEvent = new Subject();
        this.stalledEvent = new Subject();
        this.suspendEvent = new Subject();
        this.timeUpdateEvent = new Subject();
        this.volumeChangeEvent = new Subject();
        this.waitingEvent = new Subject();
        this.mediaClickEvent = new Subject();
        this.fullscreenEvent = new BehaviorSubject(false);
        this.quietModeEvent = new BehaviorSubject(false);
        this.progressEvent = Observable.create(function (observer) {
            // repeat until the whole video has fully loaded
            var /** @type {?} */ interval = setInterval(function () {
                var /** @type {?} */ buffered = /** @type {?} */ (_this._mediaPlayer.buffered);
                observer.next(buffered);
                if (buffered.length === 1 && buffered.start(0) === 0 && buffered.end(0) === _this.duration) {
                    observer.complete();
                    clearInterval(interval);
                }
            }, 1000);
        });
        this._fullscreen = false;
    }
    Object.defineProperty(MediaPlayerService.prototype, "mediaPlayer", {
        /*
            Create all the getters and setters the can be used by media player extensions
        */
        get: /**
         * @return {?}
         */
        function () {
            return this._mediaPlayer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MediaPlayerService.prototype, "quietMode", {
        get: /**
         * @return {?}
         */
        function () {
            return this._quietMode;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            // quiet mode cannot be enabled on audio player
            if (this.type === 'audio') {
                value = false;
            }
            this._quietMode = value;
            this.quietModeEvent.next(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MediaPlayerService.prototype, "mediaPlayerWidth", {
        get: /**
         * @return {?}
         */
        function () {
            return this._mediaPlayer ? this._mediaPlayer.offsetWidth : 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MediaPlayerService.prototype, "mediaPlayerHeight", {
        get: /**
         * @return {?}
         */
        function () {
            return this._mediaPlayer ? this._mediaPlayer.offsetHeight : 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MediaPlayerService.prototype, "audioTracks", {
        get: /**
         * @return {?}
         */
        function () {
            return this._mediaPlayer ? this._mediaPlayer.audioTracks : null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MediaPlayerService.prototype, "autoplay", {
        get: /**
         * @return {?}
         */
        function () {
            return this._mediaPlayer ? this._mediaPlayer.autoplay : false;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._mediaPlayer.autoplay = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MediaPlayerService.prototype, "buffered", {
        get: /**
         * @return {?}
         */
        function () {
            return this._mediaPlayer ? this._mediaPlayer.buffered : new TimeRanges();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MediaPlayerService.prototype, "crossOrigin", {
        get: /**
         * @return {?}
         */
        function () {
            return this._mediaPlayer ? this._mediaPlayer.crossOrigin : null;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._mediaPlayer.crossOrigin = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MediaPlayerService.prototype, "currentSrc", {
        get: /**
         * @return {?}
         */
        function () {
            return this._mediaPlayer ? this._mediaPlayer.currentSrc : null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MediaPlayerService.prototype, "currentTime", {
        get: /**
         * @return {?}
         */
        function () {
            return this._mediaPlayer ? this._mediaPlayer.currentTime : 0;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._mediaPlayer.currentTime = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MediaPlayerService.prototype, "defaultMuted", {
        get: /**
         * @return {?}
         */
        function () {
            return this._mediaPlayer ? this._mediaPlayer.defaultMuted : false;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._mediaPlayer.defaultMuted = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MediaPlayerService.prototype, "defaultPlaybackRate", {
        get: /**
         * @return {?}
         */
        function () {
            return this._mediaPlayer ? this._mediaPlayer.defaultPlaybackRate : 1;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._mediaPlayer.defaultPlaybackRate = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MediaPlayerService.prototype, "duration", {
        get: /**
         * @return {?}
         */
        function () {
            return this._mediaPlayer ? this._mediaPlayer.duration : 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MediaPlayerService.prototype, "ended", {
        get: /**
         * @return {?}
         */
        function () {
            return this._mediaPlayer ? this._mediaPlayer.ended : false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MediaPlayerService.prototype, "loop", {
        get: /**
         * @return {?}
         */
        function () {
            return this._mediaPlayer ? this._mediaPlayer.loop : false;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._mediaPlayer.loop = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MediaPlayerService.prototype, "muted", {
        get: /**
         * @return {?}
         */
        function () {
            return this._mediaPlayer ? this._mediaPlayer.muted : false;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._mediaPlayer.muted = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MediaPlayerService.prototype, "networkState", {
        get: /**
         * @return {?}
         */
        function () {
            return this._mediaPlayer.networkState;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MediaPlayerService.prototype, "paused", {
        get: /**
         * @return {?}
         */
        function () {
            return this._mediaPlayer ? this._mediaPlayer.paused : true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MediaPlayerService.prototype, "playbackRate", {
        get: /**
         * @return {?}
         */
        function () {
            return this._mediaPlayer ? this._mediaPlayer.playbackRate : 1;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._mediaPlayer.playbackRate = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MediaPlayerService.prototype, "played", {
        get: /**
         * @return {?}
         */
        function () {
            return this._mediaPlayer ? this._mediaPlayer.played : new TimeRanges();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MediaPlayerService.prototype, "preload", {
        get: /**
         * @return {?}
         */
        function () {
            return this._mediaPlayer ? this._mediaPlayer.preload : 'auto';
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._mediaPlayer.preload = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MediaPlayerService.prototype, "readyState", {
        get: /**
         * @return {?}
         */
        function () {
            return this._mediaPlayer ? this._mediaPlayer.readyState : 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MediaPlayerService.prototype, "seekable", {
        get: /**
         * @return {?}
         */
        function () {
            return this._mediaPlayer ? this._mediaPlayer.seekable : new TimeRanges();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MediaPlayerService.prototype, "seeking", {
        get: /**
         * @return {?}
         */
        function () {
            return this._mediaPlayer ? this._mediaPlayer.seeking : false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MediaPlayerService.prototype, "src", {
        get: /**
         * @return {?}
         */
        function () {
            return this._mediaPlayer ? this._mediaPlayer.src : '';
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._mediaPlayer.src = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MediaPlayerService.prototype, "textTracks", {
        get: /**
         * @return {?}
         */
        function () {
            return this._mediaPlayer ? this._mediaPlayer.textTracks : new TextTrackList();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MediaPlayerService.prototype, "videoTracks", {
        get: /**
         * @return {?}
         */
        function () {
            return this._mediaPlayer ? this._mediaPlayer.videoTracks : new VideoTrackList();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MediaPlayerService.prototype, "volume", {
        get: /**
         * @return {?}
         */
        function () {
            return this._mediaPlayer ? this._mediaPlayer.volume : 1;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._mediaPlayer.volume = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MediaPlayerService.prototype, "fullscreen", {
        get: /**
         * @return {?}
         */
        function () {
            return this._mediaPlayer ? this._fullscreen : false;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._fullscreen = value;
            this.fullscreenEvent.next(value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} hostElement
     * @param {?} mediaPlayer
     * @return {?}
     */
    MediaPlayerService.prototype.setMediaPlayer = /**
     * @param {?} hostElement
     * @param {?} mediaPlayer
     * @return {?}
     */
    function (hostElement, mediaPlayer) {
        this._hostElement = hostElement;
        this._mediaPlayer = mediaPlayer;
        this.initEvent.next(true);
    };
    /**
     * Toggle playing state
     */
    /**
     * Toggle playing state
     * @return {?}
     */
    MediaPlayerService.prototype.togglePlay = /**
     * Toggle playing state
     * @return {?}
     */
    function () {
        // prevent any action is not loaded
        if (this.loaded === false) {
            return;
        }
        if (this.paused) {
            this.play();
        }
        else {
            this.pause();
        }
    };
    /**
     * Starts playing the audio/video
     */
    /**
     * Starts playing the audio/video
     * @return {?}
     */
    MediaPlayerService.prototype.play = /**
     * Starts playing the audio/video
     * @return {?}
     */
    function () {
        this._mediaPlayer.play();
    };
    /**
     * Pauses the currently playing audio/video
     */
    /**
     * Pauses the currently playing audio/video
     * @return {?}
     */
    MediaPlayerService.prototype.pause = /**
     * Pauses the currently playing audio/video
     * @return {?}
     */
    function () {
        this._mediaPlayer.pause();
    };
    /**
     * Re-loads the audio/video element
     */
    /**
     * Re-loads the audio/video element
     * @return {?}
     */
    MediaPlayerService.prototype.load = /**
     * Re-loads the audio/video element
     * @return {?}
     */
    function () {
        this._mediaPlayer.load();
    };
    /**
     * Checks if the browser can play the specified audio/video type
     */
    /**
     * Checks if the browser can play the specified audio/video type
     * @param {?} type
     * @return {?}
     */
    MediaPlayerService.prototype.canPlayType = /**
     * Checks if the browser can play the specified audio/video type
     * @param {?} type
     * @return {?}
     */
    function (type) {
        return this._mediaPlayer.canPlayType(type);
    };
    /**
     * Adds a new text track to the audio/video
     */
    /**
     * Adds a new text track to the audio/video
     * @param {?} kind
     * @param {?} label
     * @param {?} language
     * @return {?}
     */
    MediaPlayerService.prototype.addTextTrack = /**
     * Adds a new text track to the audio/video
     * @param {?} kind
     * @param {?} label
     * @param {?} language
     * @return {?}
     */
    function (kind, label, language) {
        return this._mediaPlayer.addTextTrack(kind, label, language);
    };
    /**
     * Attempt to display media in fullscreen mode
     */
    /**
     * Attempt to display media in fullscreen mode
     * @return {?}
     */
    MediaPlayerService.prototype.requestFullscreen = /**
     * Attempt to display media in fullscreen mode
     * @return {?}
     */
    function () {
        if (this._hostElement.requestFullscreen) {
            this._hostElement.requestFullscreen();
        }
        else if (this._hostElement.webkitRequestFullscreen) {
            this._hostElement.webkitRequestFullscreen();
        }
        else if ((/** @type {?} */ (this._hostElement)).msRequestFullscreen) {
            (/** @type {?} */ (this._hostElement)).msRequestFullscreen();
        }
        else if ((/** @type {?} */ (this._hostElement)).mozRequestFullScreen) {
            (/** @type {?} */ (this._hostElement)).mozRequestFullScreen();
        }
    };
    /**
     * Exit full screen mode
     */
    /**
     * Exit full screen mode
     * @return {?}
     */
    MediaPlayerService.prototype.exitFullscreen = /**
     * Exit full screen mode
     * @return {?}
     */
    function () {
        if ((/** @type {?} */ (this._hostElement)).exitFullscreen) {
            document.exitFullscreen();
        }
        else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        }
        else if ((/** @type {?} */ (document)).msExitFullscreen) {
            (/** @type {?} */ (document)).msExitFullscreen();
        }
        else if ((/** @type {?} */ (document)).mozCancelFullScreen) {
            (/** @type {?} */ (document)).mozCancelFullScreen();
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    MediaPlayerService.prototype.fullscreenChange = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.fullscreen = (/** @type {?} */ (document)).fullscreen || document.webkitIsFullScreen || (/** @type {?} */ (document)).mozFullScreen || (/** @type {?} */ (document)).msFullscreenElement !== null && (/** @type {?} */ (document)).msFullscreenElement !== undefined;
        this.fullscreenEvent.next(this.fullscreen);
    };
    /**
     * Toggle Fullscreen State
     */
    /**
     * Toggle Fullscreen State
     * @return {?}
     */
    MediaPlayerService.prototype.toggleFullscreen = /**
     * Toggle Fullscreen State
     * @return {?}
     */
    function () {
        if (this.fullscreen) {
            this.exitFullscreen();
        }
        else {
            this.requestFullscreen();
        }
    };
    /**
     * Extract the frames from the video
     */
    /**
     * Extract the frames from the video
     * @param {?} width
     * @param {?} height
     * @param {?} skip
     * @return {?}
     */
    MediaPlayerService.prototype.getFrames = /**
     * Extract the frames from the video
     * @param {?} width
     * @param {?} height
     * @param {?} skip
     * @return {?}
     */
    function (width, height, skip) {
        if (this.type === 'video') {
            return this._frameExtractionService.getFrameThumbnails(this.source, width, height, 0, this.duration, 10);
        }
        return from([]);
    };
    MediaPlayerService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    MediaPlayerService.ctorParameters = function () { return [
        { type: FrameExtractionService, },
    ]; };
    return MediaPlayerService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var MediaPlayerComponent = (function () {
    function MediaPlayerComponent(mediaPlayerService, _audioService, _elementRef) {
        var _this = this;
        this.mediaPlayerService = mediaPlayerService;
        this._audioService = _audioService;
        this._elementRef = _elementRef;
        this.hovering = false;
        this._onDestroy = new Subject();
        // show controls when hovering and in quiet mode
        fromEvent(this._elementRef.nativeElement, 'mousemove').pipe(switchMap(function (event) {
            _this.hovering = true;
            return of(event);
        }), debounceTime(2000), takeUntil(this._onDestroy)).subscribe(function () { return _this.hovering = false; });
    }
    Object.defineProperty(MediaPlayerComponent.prototype, "source", {
        get: /**
         * @return {?}
         */
        function () {
            return this.mediaPlayerService.source;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.mediaPlayerService.source = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MediaPlayerComponent.prototype, "type", {
        get: /**
         * @return {?}
         */
        function () {
            return this.mediaPlayerService.type;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.mediaPlayerService.type = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MediaPlayerComponent.prototype, "quietMode", {
        get: /**
         * @return {?}
         */
        function () {
            return this.mediaPlayerService.quietMode;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.mediaPlayerService.quietMode = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    MediaPlayerComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.mediaPlayerService.setMediaPlayer(this._elementRef.nativeElement, this._playerRef.nativeElement);
        this.audioMetadata = this._audioService.getAudioFileMetadata(this._playerRef.nativeElement);
        this.mediaPlayerService.playingEvent.pipe(takeUntil(this._onDestroy)).subscribe(function () { return _this.mediaPlayerService.playing.next(true); });
        this.mediaPlayerService.pauseEvent.pipe(takeUntil(this._onDestroy)).subscribe(function () { return _this.mediaPlayerService.playing.next(false); });
        this.mediaPlayerService.mediaClickEvent.pipe(takeUntil(this._onDestroy)).subscribe(function () { return _this.mediaPlayerService.togglePlay(); });
        this.mediaPlayerService.loadedMetadataEvent.pipe(takeUntil(this._onDestroy)).subscribe(function () { return _this.mediaPlayerService.loaded = true; });
    };
    /**
     * @return {?}
     */
    MediaPlayerComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._onDestroy.next();
        this._onDestroy.complete();
    };
    MediaPlayerComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-media-player',
                    template: "<div class=\"video-player-container\" *ngIf=\"type === 'video'\">\n\n    <video class=\"video-player\"\n        #player\n        [src]=\"source\"\n        (abort)=\"mediaPlayerService.abortEvent.next()\"\n        (canplay)=\"mediaPlayerService.canPlayEvent.next(true)\"\n        (canplaythrough)=\"mediaPlayerService.canPlayThroughEvent.next(true)\"\n        (durationchange)=\"mediaPlayerService.durationChangeEvent.next(player.duration)\"\n        (ended)=\"mediaPlayerService.endedEvent.next()\"\n        (error)=\"mediaPlayerService.errorEvent.next($event)\"\n        (loadeddata)=\"mediaPlayerService.loadedDataEvent.next($event)\"\n        (loadedmetadata)=\"mediaPlayerService.loadedMetadataEvent.next($event)\"\n        (loadstart)=\"mediaPlayerService.loadStartEvent.next()\"\n        (pause)=\"mediaPlayerService.pauseEvent.next()\"\n        (play)=\"mediaPlayerService.playEvent.next()\"\n        (playing)=\"mediaPlayerService.playingEvent.next(!player.paused)\"\n        (ratechange)=\"mediaPlayerService.rateChangeEvent.next(player.playbackRate)\"\n        (seeked)=\"mediaPlayerService.seekedEvent.next(player.currentTime)\"\n        (seeking)=\"mediaPlayerService.seekingEvent.next(player.currentTime)\"\n        (stalled)=\"mediaPlayerService.stalledEvent.next()\"\n        (suspend)=\"mediaPlayerService.suspendEvent.next()\"\n        (timeupdate)=\"mediaPlayerService.timeUpdateEvent.next(player.currentTime)\"\n        (volumechange)=\"mediaPlayerService.volumeChangeEvent.next(player.volume)\"\n        (waiting)=\"mediaPlayerService.waitingEvent.next()\"\n        (click)=\"mediaPlayerService.mediaClickEvent.next($event)\">\n    </video>\n\n    <div class=\"video-overlay\" [class.playing]=\"mediaPlayerService.playing | async\">\n        <svg class=\"play-graphic\" x=\"0px\" y=\"0px\" viewBox=\"0 0 64 64\">\n            <circle class=\"play-circle\" cx=\"32.2\" cy=\"31.8\" r=\"31.8\" />\n            <polygon class=\"play-triangle\" points=\"23,14.1 23,50.8 48.3,32.5\" />\n        </svg>\n    </div>\n\n</div>\n\n\n<div class=\"audio-player\" *ngIf=\"type === 'audio'\">\n\n    <svg width=\"24px\" height=\"24px\" viewBox=\"0 0 24 24\">\n        <g stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\">\n            <g transform=\"translate(-98.000000, -458.000000)\">\n                <g transform=\"translate(98.000000, 458.000000)\">\n                    <path d=\"M4.5,0.5 L18.0435308,0.5 L23.5,6.22251502 L23.5,23.5 L4.5,23.5 L4.5,0.5 Z\" fill=\"#CCEAE2\"></path>\n                    <path d=\"M4.5,8 L4.5,0.5 L18,0.5 L23.5,6 L23.5,23.5 L18,23.5\" stroke=\"#60798D\" fill=\"#CCEAE2\"></path>\n                    <path d=\"M4,13.5 L0.5,13.5 L0.5,18.5 L4,18.5 L9.5,22.5 L9.5,9.5 L4,13.5 Z\" stroke=\"#60798D\" fill=\"#85D2BE\"></path>\n                    <path d=\"M11.5,12.5137939 C13.7576225,12.5137939 14.5,14.3709236 14.5,16 C14.5,17.6849236 13.7089152,19.5420532 11.5,19.5420532\"\n                        stroke=\"#60798D\"></path>\n                    <path d=\"M11.5,9 C15.8037643,9.04168701 18.5,11.6604805 18.5,16 C18.5,20.3395195 15.8804302,23.0079956 11.5,23\" stroke=\"#60798D\"></path>\n                    <path d=\"M17.5219116,0.761413574 L17.5219116,6 L23,6\" stroke=\"#60798D\" fill=\"#85D2BE\"></path>\n                </g>\n            </g>\n        </g>\n    </svg>\n\n    <p class=\"audio-file-name\">{{ (audioMetadata | async)?.filename }}</p>\n    <p class=\"audio-file-format\">{{ (audioMetadata | async)?.description }}</p>\n    <p class=\"audio-file-size\">{{ (audioMetadata | async)?.size | fileSize }}</p>\n\n    <audio #player\n        [src]=\"source\"\n        (abort)=\"mediaPlayerService.abortEvent.next()\"\n        (canplay)=\"mediaPlayerService.canPlayEvent.next(true)\"\n        (canplaythrough)=\"mediaPlayerService.canPlayThroughEvent.next(true)\"\n        (durationchange)=\"mediaPlayerService.durationChangeEvent.next(player.duration)\"\n        (ended)=\"mediaPlayerService.endedEvent.next()\"\n        (error)=\"mediaPlayerService.errorEvent.next($event)\"\n        (loadeddata)=\"mediaPlayerService.loadedDataEvent.next($event)\"\n        (loadedmetadata)=\"mediaPlayerService.loadedMetadataEvent.next($event)\"\n        (loadstart)=\"mediaPlayerService.loadStartEvent.next()\"\n        (pause)=\"mediaPlayerService.pauseEvent.next()\"\n        (play)=\"mediaPlayerService.playEvent.next()\"\n        (playing)=\"mediaPlayerService.playingEvent.next(!player.paused)\"\n        (ratechange)=\"mediaPlayerService.rateChangeEvent.next(player.playbackRate)\"\n        (seeked)=\"mediaPlayerService.seekedEvent.next(player.currentTime)\"\n        (seeking)=\"mediaPlayerService.seekingEvent.next(player.currentTime)\"\n        (stalled)=\"mediaPlayerService.stalledEvent.next()\"\n        (suspend)=\"mediaPlayerService.suspendEvent.next()\"\n        (timeupdate)=\"mediaPlayerService.timeUpdateEvent.next(player.currentTime)\"\n        (volumechange)=\"mediaPlayerService.volumeChangeEvent.next(player.volume)\"\n        (waiting)=\"mediaPlayerService.waitingEvent.next()\"\n        (click)=\"mediaPlayerService.mediaClickEvent.next($event)\">\n    </audio>\n</div>\n\n<div class=\"control-bar\">\n    <ux-media-player-timeline></ux-media-player-timeline>\n    <ux-media-player-controls></ux-media-player-controls>\n</div>",
                    providers: [MediaPlayerService],
                    host: {
                        'tabindex': '0',
                        '(keydown.Space)': 'mediaPlayerService.togglePlay()',
                        '[class.standard]': '!mediaPlayerService.fullscreen',
                        '[class.fullscreen]': 'mediaPlayerService.fullscreen',
                        '[class.quiet]': 'quietMode && type === "video" || mediaPlayerService.fullscreen',
                        '[class.hover]': 'hovering',
                        '[class.video]': 'type === "video"',
                        '[class.audio]': 'type === "audio"',
                        '(mouseenter)': 'hovering = true',
                        '(mouseleave)': 'hovering = false',
                        '(document:webkitfullscreenchange)': 'mediaPlayerService.fullscreenChange($event)',
                        '(document:mozfullscreenchange)': 'mediaPlayerService.fullscreenChange($event)',
                        '(document:MSFullscreenChange)': 'mediaPlayerService.fullscreenChange($event)'
                    }
                },] },
    ];
    /** @nocollapse */
    MediaPlayerComponent.ctorParameters = function () { return [
        { type: MediaPlayerService, },
        { type: AudioService, },
        { type: ElementRef, },
    ]; };
    MediaPlayerComponent.propDecorators = {
        "_playerRef": [{ type: ViewChild, args: ['player',] },],
        "source": [{ type: Input },],
        "type": [{ type: Input },],
        "quietMode": [{ type: Input },],
    };
    return MediaPlayerComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var MediaPlayerBaseExtensionDirective = (function () {
    function MediaPlayerBaseExtensionDirective(mediaPlayerService) {
        this.mediaPlayerService = mediaPlayerService;
    }
    MediaPlayerBaseExtensionDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[mediaPlayerBaseExtension]'
                },] },
    ];
    /** @nocollapse */
    MediaPlayerBaseExtensionDirective.ctorParameters = function () { return [
        { type: MediaPlayerService, },
    ]; };
    return MediaPlayerBaseExtensionDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var MediaPlayerTimelineExtensionComponent = (function (_super) {
    __extends(MediaPlayerTimelineExtensionComponent, _super);
    function MediaPlayerTimelineExtensionComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.current = 0;
        _this.position = 0;
        _this.duration = 0;
        _this.buffered = [];
        _this.mouseDown = false;
        _this.quietMode = false;
        _this.fullscreen = false;
        _this.scrub = { visible: false, position: 0, time: 0 };
        _this._onDestroy = new Subject();
        return _this;
    }
    /**
     * @return {?}
     */
    MediaPlayerTimelineExtensionComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // watch for changes to the current time
        this.mediaPlayerService.durationChangeEvent.pipe(takeUntil(this._onDestroy)).subscribe(function (duration) { return _this.duration = duration; });
        this.mediaPlayerService.quietModeEvent.pipe(takeUntil(this._onDestroy)).subscribe(function (quietMode) { return _this.quietMode = quietMode; });
        this.mediaPlayerService.fullscreenEvent.pipe(takeUntil(this._onDestroy)).subscribe(function (fullscreen) {
            _this.fullscreen = fullscreen;
            _this.scrub.position = 0;
        });
        this.mediaPlayerService.timeUpdateEvent.pipe(takeUntil(this._onDestroy)).subscribe(function (current) {
            _this.current = current;
            _this.position = (_this.current / _this.duration) * 100;
        });
        this.mediaPlayerService.progressEvent.pipe(takeUntil(this._onDestroy)).subscribe(function (buffered) {
            _this.buffered = [];
            for (var /** @type {?} */ idx = 0; idx < buffered.length; idx++) {
                _this.buffered.push({ start: (buffered.start(idx) / _this.duration) * 100, end: (buffered.end(idx) / _this.duration) * 100 });
            }
        });
    };
    /**
     * @return {?}
     */
    MediaPlayerTimelineExtensionComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        var /** @type {?} */ mousedown$ = fromEvent(this.thumb.nativeElement, 'mousedown');
        var /** @type {?} */ mousemove$ = fromEvent(document, 'mousemove');
        var /** @type {?} */ mouseup$ = fromEvent(document, 'mouseup');
        mousedown$.pipe(switchMap(function () { return mousemove$.pipe(takeUntil(mouseup$)); }), takeUntil(this._onDestroy)).subscribe(function () { return _this.scrub.visible = false; });
    };
    /**
     * @return {?}
     */
    MediaPlayerTimelineExtensionComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._onDestroy.next();
        this._onDestroy.complete();
    };
    /**
     * @param {?=} event
     * @return {?}
     */
    MediaPlayerTimelineExtensionComponent.prototype.updateScrub = /**
     * @param {?=} event
     * @return {?}
     */
    function (event) {
        var /** @type {?} */ target = /** @type {?} */ (event.target);
        if (target.classList.contains('media-progress-bar-thumb')) {
            return;
        }
        var /** @type {?} */ timeline = /** @type {?} */ (this.timelineRef.nativeElement);
        var /** @type {?} */ bounds = timeline.getBoundingClientRect();
        this.scrub.position = event.offsetX;
        this.scrub.time = (event.offsetX / bounds.width) * this.mediaPlayerService.duration;
        if (this.mouseDown) {
            this.mediaPlayerService.pause();
            this.mediaPlayerService.currentTime = this.scrub.time;
        }
    };
    MediaPlayerTimelineExtensionComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-media-player-timeline',
                    template: "<p class=\"current-time\">{{ current | duration }}</p>\n\n<div #timeline class=\"timeline-bar\" (mouseenter)=\"scrub.visible = true; pop.show()\" (mouseleave)=\"scrub.visible = false; pop.hide()\"\n    (mousemove)=\"updateScrub($event)\" (mouseup)=\"updateScrub($event)\" (mousedown)=\"mouseDown = true; $event.preventDefault()\">\n\n    <div class=\"buffered-bar\" *ngFor=\"let buffer of buffered\" [style.left.%]=\"buffer.start\" [style.width.%]=\"buffer.end - buffer.start\"></div>\n\n    <div class=\"media-progress-bar\" [style.width.%]=\"position\">\n        <div #progressThumb class=\"media-progress-bar-thumb\" (mouseenter)=\"scrub.visible = false; pop.hide(); $event.stopPropagation()\"\n            (mouseleave)=\"scrub.visible = true; pop.show(); $event.stopPropagation()\"></div>\n    </div>\n\n    <div class=\"scrub-handle\"\n         [class.scrub-handle-hidden]=\"!scrub.visible\"\n         [style.left.px]=\"scrub.position\"\n         [uxTooltip]=\"popTemplate\"\n         placement=\"top\"\n         [showTriggers]=\"[]\"\n         [hideTriggers]=\"[]\"\n         #pop=\"ux-tooltip\"\n         [tooltipDelay]=\"100\"\n         [tooltipDisabled]=\"duration === 0\"></div>\n</div>\n\n<p class=\"duration-time\">{{ duration | duration }}</p>\n\n<ng-template #popTemplate>\n    <span>{{ scrub.time | duration }}</span>\n</ng-template>",
                    host: {
                        '(document:mouseup)': 'mouseDown = false',
                        '[class.quiet]': 'quietMode || fullscreen'
                    }
                },] },
    ];
    /** @nocollapse */
    MediaPlayerTimelineExtensionComponent.ctorParameters = function () { return []; };
    MediaPlayerTimelineExtensionComponent.propDecorators = {
        "thumb": [{ type: ViewChild, args: ['progressThumb',] },],
        "timelineRef": [{ type: ViewChild, args: ['timeline',] },],
    };
    return MediaPlayerTimelineExtensionComponent;
}(MediaPlayerBaseExtensionDirective));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var MediaPlayerControlsExtensionComponent = (function (_super) {
    __extends(MediaPlayerControlsExtensionComponent, _super);
    function MediaPlayerControlsExtensionComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.fullscreen = false;
        _this.volumeActive = false;
        _this.volumeDragging = false;
        _this._volume = 50;
        _this._previousVolume = 50;
        _this._onDestroy = new Subject();
        return _this;
    }
    Object.defineProperty(MediaPlayerControlsExtensionComponent.prototype, "volume", {
        get: /**
         * @return {?}
         */
        function () {
            return this._volume;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value === 0 && this._volume !== 0) {
                this._previousVolume = this._volume;
            }
            this._volume = Math.min(Math.max(value, 0), 100);
            this.mediaPlayerService.volume = this._volume / 100;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    MediaPlayerControlsExtensionComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.mediaPlayerService.playEvent.pipe(takeUntil(this._onDestroy)).subscribe(function (_) { return _this.playing = true; });
        this.mediaPlayerService.pauseEvent.pipe(takeUntil(this._onDestroy)).subscribe(function (_) { return _this.playing = false; });
        this.mediaPlayerService.quietModeEvent.pipe(takeUntil(this._onDestroy)).subscribe(function (quietMode) { return _this.quietMode = quietMode; });
        this.mediaPlayerService.volumeChangeEvent.pipe(takeUntil(this._onDestroy)).subscribe(function (volume) { return _this.volume = volume * 100; });
        this.mediaPlayerService.initEvent.pipe(debounceTime(1), filter(function (init) { return init === true; }), takeUntil(this._onDestroy)).subscribe(function () { return _this.volume = _this.mediaPlayerService.volume * 100; });
        this.mediaPlayerService.fullscreenEvent.pipe(takeUntil(this._onDestroy)).subscribe(function (fullscreen) { return _this.fullscreen = fullscreen; });
        var /** @type {?} */ mouseenter$ = fromEvent(this.volumeIcon.nativeElement, 'mouseenter');
        var /** @type {?} */ mouseenterContainer$ = fromEvent(this.volumeContainer.nativeElement, 'mouseenter');
        var /** @type {?} */ mouseleaveContainer$ = fromEvent(this.volumeContainer.nativeElement, 'mouseleave');
        mouseenter$.pipe(takeUntil(this._onDestroy)).subscribe(function () { return _this.volumeActive = true; });
        mouseleaveContainer$.pipe(switchMap(function () { return timer(1500).pipe(takeUntil(mouseenterContainer$)); }), takeUntil(this._onDestroy)).subscribe(function () { return _this.volumeActive = false; });
    };
    /**
     * @return {?}
     */
    MediaPlayerControlsExtensionComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._onDestroy.next();
        this._onDestroy.complete();
    };
    /**
     * @return {?}
     */
    MediaPlayerControlsExtensionComponent.prototype.toggleMute = /**
     * @return {?}
     */
    function () {
        if (this.volume === 0) {
            this.volume = this._previousVolume;
        }
        else {
            this.volume = 0;
        }
    };
    /**
     * @return {?}
     */
    MediaPlayerControlsExtensionComponent.prototype.togglePlay = /**
     * @return {?}
     */
    function () {
        if (this.playing) {
            this.mediaPlayerService.pause();
        }
        else {
            this.mediaPlayerService.play();
        }
    };
    /**
     * @return {?}
     */
    MediaPlayerControlsExtensionComponent.prototype.setFullscreen = /**
     * @return {?}
     */
    function () {
        this.mediaPlayerService.toggleFullscreen();
    };
    /**
     * @return {?}
     */
    MediaPlayerControlsExtensionComponent.prototype.goToStart = /**
     * @return {?}
     */
    function () {
        this.mediaPlayerService.currentTime = 0;
    };
    /**
     * @return {?}
     */
    MediaPlayerControlsExtensionComponent.prototype.goToEnd = /**
     * @return {?}
     */
    function () {
        this.mediaPlayerService.currentTime = this.mediaPlayerService.duration;
    };
    /**
     * @param {?} event
     * @return {?}
     */
    MediaPlayerControlsExtensionComponent.prototype.dragStart = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.preventDefault();
        this.volumeDragging = true;
        var /** @type {?} */ thumb = /** @type {?} */ (event.target);
        thumb.focus();
    };
    /**
     * @param {?} event
     * @return {?}
     */
    MediaPlayerControlsExtensionComponent.prototype.dragMove = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (!this.volumeDragging) {
            return;
        }
        event.preventDefault();
        var /** @type {?} */ slider = /** @type {?} */ (this.volumeSlider.nativeElement);
        var /** @type {?} */ bounds = slider.getBoundingClientRect();
        var /** @type {?} */ x = Math.min(bounds.width, Math.max(0, event.pageX - bounds.left));
        // convert to a percentage
        this.volume = (x / bounds.width) * 100;
    };
    /**
     * @return {?}
     */
    MediaPlayerControlsExtensionComponent.prototype.dragEnd = /**
     * @return {?}
     */
    function () {
        this.volumeDragging = false;
    };
    MediaPlayerControlsExtensionComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-media-player-controls',
                    template: "<div class=\"volume-container\">\n\n    <div class=\"volume-slider-container\" #volumeContainer [class.active]=\"volumeActive\">\n        <div class=\"volume-slider-icon\" #volumeIcon>\n            <span class=\"hpe-icon\" [class.hpe-volume-mute]=\"volume === 0\" [class.hpe-volume-low]=\"volume > 0 && volume <= 70\" [class.hpe-volume]=\"volume > 70\" [uxTooltip]=\"muteTooltip\" (click)=\"toggleMute()\"></span>\n        </div>\n        \n        <div class=\"volume-slider-node\">\n            <div class=\"volume-slider\" #volumeSlider>\n                <div class=\"volume-track-lower\" [style.width.%]=\"volume\"></div>\n                <div class=\"volume-slider-thumb\" (mousedown)=\"dragStart($event)\" [style.left.%]=\"volume\" tabindex=\"0\" (keydown.ArrowRight)=\"volume = volume + 10\" (keydown.ArrowLeft)=\"volume = volume - 10\"></div>\n            </div>\n        </div>\n    </div>\n</div>\n\n<div class=\"spacer\"></div>\n\n<svg viewBox=\"0 0 51.5 64\" width=\"14\" height=\"17\" class=\"control-button\" (click)=\"goToStart()\">\n    <rect x=\"0\" y=\"0\" width=\"7.5\" height=\"64\" />\n    <polygon points=\"51.5,64 51.5,0 7.4,32 \" />\n</svg>\n\n<svg viewBox=\"0 0 45 64\" width=\"20\" height=\"29\" class=\"control-button\" *ngIf=\"!playing\" (click)=\"togglePlay()\">\n    <polygon points=\"0.4,0 0.4,64 44.6,32\" />\n</svg>\n\n<svg viewBox=\"0 0 43 56.9\" class=\"control-button\" width=\"20\" height=\"29\" *ngIf=\"playing\" (click)=\"togglePlay()\">\n    <rect y=\"0.1\" width=\"15.7\" height=\"56.9\" />\n    <rect x=\"27.3\" y=\"0.1\" width=\"15.7\" height=\"56.9\" />\n</svg>\n\n<svg viewBox=\"0 0 51.5 64\" width=\"14\" height=\"17\" class=\"control-button\" (click)=\"goToEnd()\">\n    <rect x=\"44.1\" y=\"0\" width=\"7.5\" height=\"64\" />\n    <polygon points=\"0,64 0,0 44.1,32 \" />\n</svg>\n\n<div class=\"spacer\"></div>\n\n<span class=\"hpe-icon\" *ngIf=\"mediaPlayerService.type !== 'audio'\" [class.hpe-expand]=\"!mediaPlayerService.fullscreen\" [class.hpe-contract]=\"mediaPlayerService.fullscreen\"\n    (click)=\"setFullscreen()\"></span>\n\n<ng-template #muteTooltip>{{ volume === 0 ? 'Unmute' : 'Mute' }}</ng-template>",
                    host: {
                        '[class.quiet]': 'quietMode || fullscreen'
                    }
                },] },
    ];
    /** @nocollapse */
    MediaPlayerControlsExtensionComponent.ctorParameters = function () { return []; };
    MediaPlayerControlsExtensionComponent.propDecorators = {
        "volumeIcon": [{ type: ViewChild, args: ['volumeIcon',] },],
        "volumeSlider": [{ type: ViewChild, args: ['volumeSlider',] },],
        "volumeContainer": [{ type: ViewChild, args: ['volumeContainer',] },],
        "dragMove": [{ type: HostListener, args: ['document:mousemove', ['$event'],] },],
        "dragEnd": [{ type: HostListener, args: ['document:mouseup',] },],
    };
    return MediaPlayerControlsExtensionComponent;
}(MediaPlayerBaseExtensionDirective));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var DurationPipe = (function () {
    function DurationPipe() {
    }
    /**
     * @param {?} seconds
     * @return {?}
     */
    DurationPipe.prototype.transform = /**
     * @param {?} seconds
     * @return {?}
     */
    function (seconds) {
        var /** @type {?} */ minutes = Math.floor(seconds / 60);
        var /** @type {?} */ hours = Math.floor(minutes / 60);
        var /** @type {?} */ days = Math.floor(hours / 24);
        hours = hours - (days * 24);
        minutes = minutes - (days * 24 * 60) - (hours * 60);
        seconds = Math.floor(seconds - (days * 24 * 60 * 60) - (hours * 60 * 60) - (minutes * 60));
        if (hours > 0) {
            return this.pad(hours) + ":" + this.pad(minutes) + ":" + this.pad(seconds);
        }
        else {
            return this.pad(minutes) + ":" + this.pad(seconds);
        }
    };
    /**
     * @param {?} value
     * @return {?}
     */
    DurationPipe.prototype.pad = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (value < 10) {
            return "0" + value;
        }
        return value.toString();
    };
    DurationPipe.decorators = [
        { type: Pipe, args: [{
                    name: 'duration'
                },] },
    ];
    /** @nocollapse */
    DurationPipe.ctorParameters = function () { return []; };
    return DurationPipe;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var DurationPipeModule = (function () {
    function DurationPipeModule() {
    }
    DurationPipeModule.decorators = [
        { type: NgModule, args: [{
                    exports: [DurationPipe],
                    declarations: [DurationPipe]
                },] },
    ];
    /** @nocollapse */
    DurationPipeModule.ctorParameters = function () { return []; };
    return DurationPipeModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var FileSizePipe = (function () {
    function FileSizePipe() {
    }
    /**
     * @param {?} value
     * @return {?}
     */
    FileSizePipe.prototype.transform = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        // allow for async values
        if (!value) {
            return value;
        }
        var /** @type {?} */ units = ['B', 'KB', 'MB', 'GB', 'TB'];
        // calculate the which unit bracket the values should be a part of
        var /** @type {?} */ idx = Math.floor(Math.log(value) / Math.log(1024));
        var /** @type {?} */ formattedValue = value / Math.pow(1024, idx);
        return formattedValue.toFixed(2) + " " + units[idx];
    };
    FileSizePipe.decorators = [
        { type: Pipe, args: [{
                    name: 'fileSize'
                },] },
    ];
    /** @nocollapse */
    FileSizePipe.ctorParameters = function () { return []; };
    return FileSizePipe;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var FileSizePipeModule = (function () {
    function FileSizePipeModule() {
    }
    FileSizePipeModule.decorators = [
        { type: NgModule, args: [{
                    exports: [FileSizePipe],
                    declarations: [FileSizePipe]
                },] },
    ];
    /** @nocollapse */
    FileSizePipeModule.ctorParameters = function () { return []; };
    return FileSizePipeModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var /** @type {?} */ DECLARATIONS$5 = [
    MediaPlayerComponent,
    MediaPlayerTimelineExtensionComponent,
    MediaPlayerBaseExtensionDirective,
    MediaPlayerControlsExtensionComponent
];
var MediaPlayerModule = (function () {
    function MediaPlayerModule() {
    }
    MediaPlayerModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        FrameExtractionModule,
                        TooltipModule,
                        AudioServiceModule,
                        DurationPipeModule,
                        FileSizePipeModule
                    ],
                    exports: DECLARATIONS$5,
                    declarations: DECLARATIONS$5,
                    providers: [MediaPlayerService]
                },] },
    ];
    /** @nocollapse */
    MediaPlayerModule.ctorParameters = function () { return []; };
    return MediaPlayerModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var NavigationComponent = (function () {
    function NavigationComponent() {
    }
    NavigationComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-navigation',
                    template: "<nav class=\"tree\" role=\"navigation\">\n    <ol class=\"nav\">\n        <ng-content></ng-content>\n    </ol>\n</nav>\n"
                },] },
    ];
    /** @nocollapse */
    NavigationComponent.ctorParameters = function () { return []; };
    return NavigationComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var NavigationItemComponent = (function () {
    function NavigationItemComponent(_elementRef, _renderer, _parent, _router, _activatedRoute) {
        var _this = this;
        this._elementRef = _elementRef;
        this._renderer = _renderer;
        this._parent = _parent;
        this._router = _router;
        this._activatedRoute = _activatedRoute;
        this.expanded = false;
        this.level = 1;
        this.indentWithoutArrow = true;
        this.level = _parent ? _parent.level + 1 : 1;
        this._navigationEnd = _router.events.pipe(filter(function (event) { return event instanceof NavigationEnd; }))
            .subscribe(function () { return _this.expanded = _this.hasActiveLink(_this.link); });
    }
    Object.defineProperty(NavigationItemComponent.prototype, "active", {
        get: /**
         * @return {?}
         */
        function () {
            if (this.link) {
                return this._router.isActive(this.link, true);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NavigationItemComponent.prototype, "children", {
        get: /**
         * @return {?}
         */
        function () {
            var _this = this;
            return this._children.filter(function (item) { return item !== _this; });
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    NavigationItemComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        // Add classes to parent for styling
        var /** @type {?} */ parentListElement = this._elementRef.nativeElement.parentElement;
        if (parentListElement) {
            var /** @type {?} */ levelClass = this.getLevelClass();
            if (levelClass.length > 0) {
                this._renderer.addClass(parentListElement, 'nav');
                this._renderer.addClass(parentListElement, levelClass);
            }
        }
    };
    /**
     * @return {?}
     */
    NavigationItemComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // Set 'indentWithoutArrow'
        this.setIndentWithoutArrow();
        // Update 'indentWithoutArrow' in response to changes to children
        this._childrenChanges = this._children.changes.subscribe(function () { return _this.setIndentWithoutArrow(); });
    };
    /**
     * @return {?}
     */
    NavigationItemComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._navigationEnd.unsubscribe();
        this._childrenChanges.unsubscribe();
    };
    /**
     * @param {?} link
     * @return {?}
     */
    NavigationItemComponent.prototype.hasActiveLink = /**
     * @param {?} link
     * @return {?}
     */
    function (link) {
        var /** @type {?} */ tree = this._router.createUrlTree([link], {
            relativeTo: this._activatedRoute,
            queryParams: this._activatedRoute.snapshot.queryParams,
            fragment: this._activatedRoute.snapshot.fragment
        });
        if (link && this._router.isActive(tree, true)) {
            return true;
        }
        // If this component has children, check if any of them, or their descendants, are active.
        return this.children.some(function (item) { return item.hasActiveLink(item.link); });
    };
    /**
     * @return {?}
     */
    NavigationItemComponent.prototype.getLevelClass = /**
     * @return {?}
     */
    function () {
        switch (this.level) {
            case 2:
                return 'nav-second-level';
            case 3:
                return 'nav-third-level';
            case 4:
                return 'nav-fourth-level';
            case 5:
                return 'nav-fifth-level';
        }
        return '';
    };
    /**
     * @return {?}
     */
    NavigationItemComponent.prototype.setIndentWithoutArrow = /**
     * @return {?}
     */
    function () {
        if (this.children.length > 0) {
            // If this element has children it will be indented and will have an arrow
            this.indentWithoutArrow = false;
        }
        else if (this._parent) {
            // If this element has a parent, indent it if any of its siblings have children
            this.indentWithoutArrow = !this._parent.children.every(function (item) { return item.children.length === 0; });
        }
        else {
            // Top-level elements should be indented
            this.indentWithoutArrow = true;
        }
    };
    NavigationItemComponent.decorators = [
        { type: Component, args: [{
                    selector: '[ux-navigation-item]',
                    template: "<a *ngIf=\"link\" [class.has-arrow]=\"children.length > 0\" [class.no-arrow]=\"indentWithoutArrow\" [routerLink]=\"link\">\n    <span>{{header}}</span>\n</a>\n<a *ngIf=\"!link\" (click)=\"expanded = !expanded\" [class.has-arrow]=\"children.length > 0\" [class.no-arrow]=\"indentWithoutArrow\">\n    <span>{{header}}</span>\n</a>\n<ng-content></ng-content>\n",
                },] },
    ];
    /** @nocollapse */
    NavigationItemComponent.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: Renderer2, },
        { type: NavigationItemComponent, decorators: [{ type: Optional }, { type: SkipSelf },] },
        { type: Router, },
        { type: ActivatedRoute, },
    ]; };
    NavigationItemComponent.propDecorators = {
        "header": [{ type: Input },],
        "icon": [{ type: Input },],
        "link": [{ type: Input },],
        "expanded": [{ type: Input }, { type: HostBinding, args: ['class.selected',] },],
        "active": [{ type: HostBinding, args: ['class.active',] },],
        "_children": [{ type: ContentChildren, args: [NavigationItemComponent, { descendants: true },] },],
    };
    return NavigationItemComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var NavigationModule = (function () {
    function NavigationModule() {
    }
    NavigationModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        RouterModule
                    ],
                    exports: [
                        NavigationComponent,
                        NavigationItemComponent
                    ],
                    declarations: [
                        NavigationComponent,
                        NavigationItemComponent
                    ]
                },] },
    ];
    /** @nocollapse */
    NavigationModule.ctorParameters = function () { return []; };
    return NavigationModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ColorService = (function () {
    function ColorService() {
        this._colorSet = colorSets.keppel;
        if (this._colorSet.colorClassSet) {
            this.setColors();
        }
        else {
            for (var /** @type {?} */ key in this._colorSet.colorValueSet) {
                this._colors[key] = this.getColorValueByHex(this._colorSet.colorValueSet[key]);
            }
        }
    }
    /**
     * @return {?}
     */
    ColorService.prototype.setColors = /**
     * @return {?}
     */
    function () {
        this._html = '';
        for (var /** @type {?} */ key in this._colorSet.colorClassSet) {
            this._html += '<div class="' + this._colorSet.colorClassSet[key] + '-color"></div>';
        }
        this._element = document.createElement('div');
        this._element.className = 'color-chart';
        this._element.innerHTML = this._html;
        document.body.appendChild(this._element);
        this._colors = {};
        for (var /** @type {?} */ key in this._colorSet.colorClassSet) {
            this._colors[key] = this.getColorValue(this._colorSet.colorClassSet[key]);
        }
        this._element.parentNode.removeChild(this._element);
    };
    /**
     * @param {?} color
     * @return {?}
     */
    ColorService.prototype.getColorValueByHex = /**
     * @param {?} color
     * @return {?}
     */
    function (color) {
        var /** @type {?} */ hex = color.replace('#', '');
        var /** @type {?} */ r = parseInt(hex.substring(0, 2), 16).toString();
        var /** @type {?} */ g = parseInt(hex.substring(2, 4), 16).toString();
        var /** @type {?} */ b = parseInt(hex.substring(4, 6), 16).toString();
        return new ThemeColor(r, g, b, '1');
    };
    /**
     * @param {?} color
     * @return {?}
     */
    ColorService.prototype.getColorValue = /**
     * @param {?} color
     * @return {?}
     */
    function (color) {
        var /** @type {?} */ target = this._element.querySelector('.' + this._colorSet.colorClassSet[color] + '-color');
        if (!target) {
            throw new Error('Invalid color');
        }
        var /** @type {?} */ colorValue = window.getComputedStyle(target).backgroundColor;
        var /** @type {?} */ rgba = colorValue.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+(?:\.\d+)?))?\)$/);
        return new ThemeColor(rgba[1], rgba[2], rgba[3], rgba[4]);
    };
    /**
     * @param {?} color
     * @return {?}
     */
    ColorService.prototype.getColor = /**
     * @param {?} color
     * @return {?}
     */
    function (color) {
        var /** @type {?} */ themeColor = this._colors[this.resolveColorName(color)];
        if (!themeColor) {
            throw new Error('Color not found: ' + color);
        }
        return new ThemeColor(themeColor.getRed(), themeColor.getGreen(), themeColor.getBlue(), themeColor.getAlpha());
    };
    /**
     * @return {?}
     */
    ColorService.prototype.getColorSet = /**
     * @return {?}
     */
    function () {
        return this._colorSet;
    };
    /**
     * @param {?} colorSet
     * @return {?}
     */
    ColorService.prototype.setColorSet = /**
     * @param {?} colorSet
     * @return {?}
     */
    function (colorSet) {
        this._colorSet = colorSet;
        this._colors = {};
        if (this._colorSet.colorClassSet) {
            this.setColors();
        }
        else {
            for (var /** @type {?} */ key in this._colorSet.colorValueSet) {
                this._colors[key] = this.getColorValueByHex(this._colorSet.colorValueSet[key]);
            }
        }
    };
    /**
     * @param {?} value
     * @return {?}
     */
    ColorService.prototype.resolve = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (!value) {
            return;
        }
        var /** @type {?} */ colorName = this.resolveColorName(value);
        for (var /** @type {?} */ color in this._colors) {
            if (colorName === color.toLowerCase()) {
                return this.getColor(colorName).toRgba();
            }
        }
        return value;
    };
    /**
     * @param {?=} value
     * @return {?}
     */
    ColorService.prototype.resolveColorName = /**
     * @param {?=} value
     * @return {?}
     */
    function (value) {
        if (value === void 0) { value = ''; }
        return value.replace(/\s+/g, '-').toLowerCase();
    };
    ColorService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    ColorService.ctorParameters = function () { return []; };
    return ColorService;
}());
var ThemeColor = (function () {
    function ThemeColor(r, g, b, a) {
        this._r = r;
        this._g = g;
        this._b = b;
        this._a = a === undefined ? '1' : a;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    ThemeColor.parse = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        var /** @type {?} */ r, /** @type {?} */ g, /** @type {?} */ b, /** @type {?} */ a = '1';
        var /** @type {?} */ rgbaPattern = /^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+(?:\.\d+)?))?\)$/;
        var /** @type {?} */ shortHexPattern = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
        var /** @type {?} */ longHexPattern = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/;
        var /** @type {?} */ rgbaMatch = value.match(rgbaPattern);
        var /** @type {?} */ shortHexMatch = value.match(shortHexPattern);
        var /** @type {?} */ longHexMatch = value.match(longHexPattern);
        if (rgbaMatch) {
            r = rgbaMatch[1];
            g = rgbaMatch[2];
            b = rgbaMatch[3];
            a = rgbaMatch[4] ? rgbaMatch[4] : '1';
        }
        else if (longHexMatch) {
            r = parseInt(longHexMatch[1], 16).toString();
            g = parseInt(longHexMatch[2], 16).toString();
            b = parseInt(longHexMatch[3], 16).toString();
        }
        else if (shortHexMatch) {
            r = parseInt(shortHexMatch[1] + shortHexMatch[1], 16).toString();
            g = parseInt(shortHexMatch[2] + shortHexMatch[2], 16).toString();
            b = parseInt(shortHexMatch[3] + shortHexMatch[3], 16).toString();
        }
        else {
            throw new Error("Cannot parse color - " + value + " is not a valid color.");
        }
        return new ThemeColor(r, g, b, a);
    };
    /**
     * @return {?}
     */
    ThemeColor.prototype.toHex = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ red = parseInt(this._r).toString(16);
        var /** @type {?} */ green = parseInt(this._g).toString(16);
        var /** @type {?} */ blue = parseInt(this._b).toString(16);
        if (red.length < 2) {
            red = '0' + red;
        }
        if (green.length < 2) {
            green = '0' + green;
        }
        if (blue.length < 2) {
            blue = '0' + blue;
        }
        return '#' + red + green + blue;
    };
    /**
     * @return {?}
     */
    ThemeColor.prototype.toRgb = /**
     * @return {?}
     */
    function () {
        return 'rgb(' + this._r + ', ' + this._g + ', ' + this._b + ')';
    };
    /**
     * @return {?}
     */
    ThemeColor.prototype.toRgba = /**
     * @return {?}
     */
    function () {
        return 'rgba(' + this._r + ', ' + this._g + ', ' + this._b + ', ' + this._a + ')';
    };
    /**
     * @return {?}
     */
    ThemeColor.prototype.getRed = /**
     * @return {?}
     */
    function () {
        return this._r;
    };
    /**
     * @return {?}
     */
    ThemeColor.prototype.getGreen = /**
     * @return {?}
     */
    function () {
        return this._g;
    };
    /**
     * @return {?}
     */
    ThemeColor.prototype.getBlue = /**
     * @return {?}
     */
    function () {
        return this._b;
    };
    /**
     * @return {?}
     */
    ThemeColor.prototype.getAlpha = /**
     * @return {?}
     */
    function () {
        return this._a;
    };
    /**
     * @param {?} red
     * @return {?}
     */
    ThemeColor.prototype.setRed = /**
     * @param {?} red
     * @return {?}
     */
    function (red) {
        this._r = red;
        return this;
    };
    /**
     * @param {?} green
     * @return {?}
     */
    ThemeColor.prototype.setGreen = /**
     * @param {?} green
     * @return {?}
     */
    function (green) {
        this._g = green;
        return this;
    };
    /**
     * @param {?} blue
     * @return {?}
     */
    ThemeColor.prototype.setBlue = /**
     * @param {?} blue
     * @return {?}
     */
    function (blue) {
        this._b = blue;
        return this;
    };
    /**
     * @param {?} alpha
     * @return {?}
     */
    ThemeColor.prototype.setAlpha = /**
     * @param {?} alpha
     * @return {?}
     */
    function (alpha) {
        this._a = alpha.toString();
        return this;
    };
    return ThemeColor;
}());
var /** @type {?} */ colorSets = {
    keppel: {
        colorClassSet: {
            'primary': 'primary',
            'accent': 'accent',
            'secondary': 'secondary',
            'alternate1': 'alternate1',
            'alternate2': 'alternate2',
            'alternate3': 'alternate3',
            'vibrant1': 'vibrant1',
            'vibrant2': 'vibrant2',
            'grey1': 'grey1',
            'grey2': 'grey2',
            'grey3': 'grey3',
            'grey4': 'grey4',
            'grey5': 'grey5',
            'grey6': 'grey6',
            'grey7': 'grey7',
            'grey8': 'grey8',
            'chart1': 'chart1',
            'chart2': 'chart2',
            'chart3': 'chart3',
            'chart4': 'chart4',
            'chart5': 'chart5',
            'chart6': 'chart6',
            'ok': 'ok',
            'warning': 'warning',
            'critical': 'critical',
            'partition1': 'partition1',
            'partition9': 'partition9',
            'partition10': 'partition10',
            'partition11': 'partition11',
            'partition12': 'partition12',
            'partition13': 'partition13',
            'partition14': 'partition14',
            'social-chart-node': 'social-chart-node',
            'social-chart-edge': 'social-chart-edge'
        }
    },
    microFocus: {
        'colorValueSet': {
            'cerulean': '#1668c1',
            'aqua': '#29ceff',
            'aquamarine': '#2fd6c3',
            'fuchsia': '#c6179d',
            'indigo': '#7425ad',
            'dark-blue': '#231ca5',
            'white': '#ffffff',
            'slightly-gray': '#f5f7f8',
            'bright-gray': '#f1f2f3',
            'gray': '#dcdedf',
            'silver': '#bdbec0',
            'dim-gray': '#656668',
            'dark-gray': '#323435',
            'black': '#000000',
            'crimson-negative': '#e5004c',
            'apricot': '#f48b34',
            'yellow': '#fcdb1f',
            'green-positive': '#1aac60',
            'ultramarine': '#3939c6',
            'skyblue': '#00abf3',
            'pale-aqua': '#43e4ff',
            'pale-green': '#1ffbba',
            'lime': '#75da4d',
            'orange': '#ffce00',
            'magenta': '#eb23c2',
            'pale-purple': '#ba47e2',
            'dark-ultramarine': '#271782',
            'steelblue': '#014272',
            'arctic-blue': '#0b8eac',
            'emerald': '#00a989',
            'olive': '#5bba36',
            'goldenrod': '#ffb000',
            'purple': '#9b1e83',
            'pale-eggplant': '#5216ac',
            'red': '#ff454f',
            'pale-amber': '#ffb24d',
            'pale-lemon': '#fde159',
            'pale-emerald': '#33c180',
            'plum': '#b21646',
            'copper': '#e57828',
            'amber': '#ffc002',
            'leaf-green': '#118c4f',
            'forest-green': '#00645a',
            'primary': '#0073e7',
            'accent': '#7425ad',
            'secondary': '#ffffff',
            'alternate1': '#29ceff',
            'alternate2': '#2fd6c3',
            'alternate3': '#c6179d',
            'vibrant1': '#43e4ff',
            'vibrant2': '#ffce00',
            'grey1': '#000000',
            'grey2': '#323435',
            'grey3': '#656668',
            'grey4': '#bdbec0',
            'grey5': '#dcdedf',
            'grey6': '#f1f2f3',
            'grey7': '#f5f7f8',
            'grey8': '#ffffff',
            'chart1': '#3939c6',
            'chart2': '#00abf3',
            'chart3': '#75da4d',
            'chart4': '#ffce00',
            'chart5': '#eb23c2',
            'chart6': '#ba47e2',
            'ok': '#1aac60',
            'warning': '#f48b34',
            'critical': 'e5004c',
            'partition1': '#7425ad',
            'partition9': '#5216ac',
            'partition10': '#5bba36',
            'partition11': '#014272',
            'partition12': '#ffb000',
            'partition13': '#bdbec0',
            'partition14': '#271782',
            'social-chart-node': '#ff00ff',
            'social-chart-edge': '#ff00ff'
        }
    }
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ColorServiceModule = (function () {
    function ColorServiceModule() {
    }
    ColorServiceModule.decorators = [
        { type: NgModule, args: [{
                    providers: [ColorService],
                },] },
    ];
    /** @nocollapse */
    ColorServiceModule.ctorParameters = function () { return []; };
    return ColorServiceModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var NotificationService = (function () {
    function NotificationService(_colorService) {
        this._colorService = _colorService;
        // provide default options
        this.options = {
            duration: 4,
            height: 100,
            spacing: 10,
            backgroundColor: this._colorService.getColor('accent').toHex(),
            iconColor: this._colorService.getColor('accent').toHex()
        };
        this.direction = 'above';
        this.notifications$ = new BehaviorSubject([]);
    }
    /**
     * @param {?} templateRef
     * @param {?=} options
     * @param {?=} data
     * @return {?}
     */
    NotificationService.prototype.show = /**
     * @param {?} templateRef
     * @param {?=} options
     * @param {?=} data
     * @return {?}
     */
    function (templateRef, options, data) {
        var _this = this;
        if (options === void 0) { options = this.options; }
        if (data === void 0) { data = {}; }
        options = __assign({}, this.options, options);
        var /** @type {?} */ notificationRef = {
            templateRef: templateRef,
            duration: options.duration,
            date: new Date(),
            visible: true,
            height: options.height,
            spacing: options.spacing,
            backgroundColor: options.backgroundColor,
            iconColor: options.iconColor,
            data: data
        };
        var /** @type {?} */ notifications = this.notifications$.getValue();
        if (this.direction === 'above') {
            notifications.unshift(notificationRef);
        }
        else {
            notifications.push(notificationRef);
        }
        this.notifications$.next(notifications);
        // remove notification after delay
        if (options.duration !== 0) {
            setTimeout(function () { return _this.dismiss(notificationRef); }, options.duration * 1000);
        }
        return notificationRef;
    };
    /**
     * @return {?}
     */
    NotificationService.prototype.getHistory = /**
     * @return {?}
     */
    function () {
        return this.notifications$.getValue();
    };
    /**
     * @param {?} notificationRef
     * @return {?}
     */
    NotificationService.prototype.dismiss = /**
     * @param {?} notificationRef
     * @return {?}
     */
    function (notificationRef) {
        notificationRef.visible = false;
        this.notifications$.next(this.notifications$.getValue());
    };
    /**
     * @return {?}
     */
    NotificationService.prototype.dismissAll = /**
     * @return {?}
     */
    function () {
        this.notifications$.getValue().forEach(function (notificationRef) { return notificationRef.visible = false; });
        this.notifications$.next(this.notifications$.getValue());
    };
    NotificationService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    NotificationService.ctorParameters = function () { return [
        { type: ColorService, },
    ]; };
    return NotificationService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var NotificationListComponent = (function () {
    function NotificationListComponent(_notificationService) {
        this._notificationService = _notificationService;
        this.position = 'top-right';
        this.notifications$ = this._notificationService.notifications$.pipe(map$1(function (notificationRefs) { return notificationRefs.filter(function (notificationRef) { return notificationRef.visible; }); }));
    }
    Object.defineProperty(NotificationListComponent.prototype, "direction", {
        set: /**
         * @param {?} direction
         * @return {?}
         */
        function (direction) {
            this._notificationService.direction = direction;
        },
        enumerable: true,
        configurable: true
    });
    NotificationListComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-notification-list',
                    template: "<div class=\"notification\" *ngFor=\"let notificationRef of notifications$ | async; let idx = index\"\n    [style.top.px]=\"(notificationRef.height + notificationRef.spacing) * idx\"\n    [style.height.px]=\"notificationRef.height\"\n    [style.background-color]=\"notificationRef.backgroundColor\"\n    [@notificationState]>\n    <ng-container *ngTemplateOutlet=\"notificationRef.templateRef; context: { $implicit: notificationRef, data: notificationRef.data }\"></ng-container>\n</div>\n",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    animations: [
                        trigger('notificationState', [
                            state('in', style({ transform: 'translateY(0)', opacity: 0.9 })),
                            transition(':enter', [
                                style({ transform: 'translateY(-50px)', opacity: 0 }),
                                animate(500)
                            ]),
                            transition(':leave', [
                                animate(500, style({ transform: 'translateY(50px)', opacity: 0 }))
                            ])
                        ])
                    ]
                },] },
    ];
    /** @nocollapse */
    NotificationListComponent.ctorParameters = function () { return [
        { type: NotificationService, },
    ]; };
    NotificationListComponent.propDecorators = {
        "direction": [{ type: Input },],
        "position": [{ type: Input }, { type: HostBinding, args: ['class',] },],
    };
    return NotificationListComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var NotificationModule = (function () {
    function NotificationModule() {
    }
    NotificationModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        ColorServiceModule
                    ],
                    exports: [
                        NotificationListComponent
                    ],
                    declarations: [
                        NotificationListComponent
                    ],
                    providers: [
                        NotificationService
                    ]
                },] },
    ];
    /** @nocollapse */
    NotificationModule.ctorParameters = function () { return []; };
    return NotificationModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var /** @type {?} */ NUMBER_PICKER_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(function () { return NumberPickerComponent; }),
    multi: true
};
var NumberPickerComponent = (function () {
    function NumberPickerComponent() {
        this._min = -Infinity;
        this._max = Infinity;
        this._step = 1;
        this._disabled = false;
        this._value = 0;
        this._propagateChange = function (_) { };
        this.valid = true;
        this.valueChange = new EventEmitter();
    }
    Object.defineProperty(NumberPickerComponent.prototype, "value", {
        get: /**
         * @return {?}
         */
        function () {
            return this._value;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._value = value;
            this.valueChange.emit(value);
            this._propagateChange(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NumberPickerComponent.prototype, "min", {
        get: /**
         * @return {?}
         */
        function () {
            return this._min;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._min = typeof value === 'string' ? parseFloat(value) : value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NumberPickerComponent.prototype, "max", {
        get: /**
         * @return {?}
         */
        function () {
            return this._max;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._max = typeof value === 'string' ? parseFloat(value) : value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NumberPickerComponent.prototype, "step", {
        get: /**
         * @return {?}
         */
        function () {
            return this._step;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._step = typeof value === 'string' ? parseFloat(value) : value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NumberPickerComponent.prototype, "disabled", {
        get: /**
         * @return {?}
         */
        function () {
            return this._disabled;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._disabled = typeof value === 'string' && (value === '' || value === 'true' || value === 'disabled') || value === true;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} event
     * @return {?}
     */
    NumberPickerComponent.prototype.increment = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.preventDefault();
        if (!this.disabled) {
            this.value = Math.max(Math.min(this.value + this.step, this.max), this.min);
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    NumberPickerComponent.prototype.decrement = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.preventDefault();
        if (!this.disabled) {
            this.value = Math.min(Math.max(this.value - this.step, this.min), this.max);
        }
    };
    /**
     * @return {?}
     */
    NumberPickerComponent.prototype.isValid = /**
     * @return {?}
     */
    function () {
        if (this.value < this.min || this.value > this.max) {
            return false;
        }
        return this.valid;
    };
    /**
     * @param {?} event
     * @return {?}
     */
    NumberPickerComponent.prototype.onScroll = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var /** @type {?} */ scrollValue = event.deltaY || event.wheelDelta;
        if (scrollValue < 0) {
            this.increment(event);
        }
        else {
            this.decrement(event);
        }
    };
    /**
     * @param {?} value
     * @return {?}
     */
    NumberPickerComponent.prototype.writeValue = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (value !== undefined) {
            this._value = value;
        }
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    NumberPickerComponent.prototype.registerOnChange = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this._propagateChange = fn;
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    NumberPickerComponent.prototype.registerOnTouched = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) { };
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    NumberPickerComponent.prototype.setDisabledState = /**
     * @param {?} isDisabled
     * @return {?}
     */
    function (isDisabled) {
        this.disabled = isDisabled;
    };
    NumberPickerComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-number-picker',
                    template: "<input type=\"number\"\n       role=\"spinbutton\"\n       class=\"form-control number-picker-input\"\n       [(ngModel)]=\"value\"\n       [min]=\"min\"\n       [max]=\"max\"\n       (keydown.ArrowDown)=\"decrement($event)\"\n       (keydown.ArrowUp)=\"increment($event)\"\n       (wheel)=\"onScroll($event)\"\n       step=\"any\"\n       [disabled]=\"disabled\"\n       [attr.aria-valuemin]=\"min\"\n       [attr.aria-valuenow]=\"value\"\n       [attr.aria-valuemax]=\"max\">\n\n<div class=\"number-picker-controls\">\n\n    <div class=\"number-picker-control-up\"\n         (click)=\"increment($event)\"\n         [class.disabled]=\"disabled || value >= max\">\n\n        <span class=\"hpe-icon hpe-up\"></span>\n    </div>\n\n    <div class=\"number-picker-control-down\"\n         (click)=\"decrement($event)\"\n         [class.disabled]=\"disabled || value <= min\">\n\n        <span class=\"hpe-icon hpe-down\"></span>\n    </div>\n\n</div>",
                    providers: [NUMBER_PICKER_VALUE_ACCESSOR],
                    host: {
                        '[class.has-error]': '!isValid()'
                    }
                },] },
    ];
    /** @nocollapse */
    NumberPickerComponent.ctorParameters = function () { return []; };
    NumberPickerComponent.propDecorators = {
        "valid": [{ type: Input },],
        "valueChange": [{ type: Output },],
        "value": [{ type: Input, args: ['value',] },],
        "min": [{ type: Input },],
        "max": [{ type: Input },],
        "step": [{ type: Input },],
        "disabled": [{ type: Input },],
    };
    return NumberPickerComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var NumberPickerModule = (function () {
    function NumberPickerModule() {
    }
    NumberPickerModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        FormsModule
                    ],
                    exports: [NumberPickerComponent],
                    declarations: [NumberPickerComponent]
                },] },
    ];
    /** @nocollapse */
    NumberPickerModule.ctorParameters = function () { return []; };
    return NumberPickerModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var MenuNavigationService = (function () {
    function MenuNavigationService() {
        this.active$ = new BehaviorSubject(null);
    }
    MenuNavigationService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    MenuNavigationService.ctorParameters = function () { return []; };
    return MenuNavigationService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var MenuNavigationItemDirective = (function () {
    function MenuNavigationItemDirective(service, _elementRef) {
        var _this = this;
        this._elementRef = _elementRef;
        this.activated = new EventEmitter();
        this._subscription = service.active$.subscribe(function (next) {
            if (next === _this) {
                _this.setActive();
            }
        });
    }
    /**
     * @return {?}
     */
    MenuNavigationItemDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._subscription.unsubscribe();
    };
    /**
     * @return {?}
     */
    MenuNavigationItemDirective.prototype.setActive = /**
     * @return {?}
     */
    function () {
        this._elementRef.nativeElement.focus();
        this.activated.emit();
    };
    MenuNavigationItemDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[uxMenuNavigationItem]'
                },] },
    ];
    /** @nocollapse */
    MenuNavigationItemDirective.ctorParameters = function () { return [
        { type: MenuNavigationService, },
        { type: ElementRef, },
    ]; };
    MenuNavigationItemDirective.propDecorators = {
        "activated": [{ type: Output },],
    };
    return MenuNavigationItemDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var MenuNavigationToggleDirective = (function () {
    function MenuNavigationToggleDirective(_elementRef) {
        this._elementRef = _elementRef;
        this.menuPosition = 'bottom';
        this.menuOpenChange = new EventEmitter();
        this.keyEnter = new EventEmitter();
    }
    Object.defineProperty(MenuNavigationToggleDirective.prototype, "menuOpen", {
        get: /**
         * @return {?}
         */
        function () {
            return this._menuOpen;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._menuOpen = value;
            this.menuOpenChange.emit(value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    MenuNavigationToggleDirective.prototype.focus = /**
     * @return {?}
     */
    function () {
        this._elementRef.nativeElement.focus();
    };
    /**
     * @param {?} event
     * @return {?}
     */
    MenuNavigationToggleDirective.prototype.keydownHandler = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        if (this.isKeyMatch(event.key)) {
            // Open the menu
            this.menuOpen = true;
            // Allow the menu to init, then send the event to give it focus
            setTimeout(function () {
                _this.keyEnter.emit();
            });
            event.preventDefault();
            event.stopPropagation();
        }
    };
    /**
     * @param {?} key
     * @return {?}
     */
    MenuNavigationToggleDirective.prototype.isKeyMatch = /**
     * @param {?} key
     * @return {?}
     */
    function (key) {
        switch (key) {
            case 'Enter':
            case ' ':
                return true;
            case 'ArrowUp':
            case 'Up':
                return this.menuPosition === 'top';
            case 'ArrowDown':
            case 'Down':
                return this.menuPosition === 'bottom';
            case 'ArrowLeft':
            case 'Left':
                return this.menuPosition === 'left';
            case 'ArrowRight':
            case 'Right':
                return this.menuPosition === 'right';
        }
        return false;
    };
    MenuNavigationToggleDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[uxMenuNavigationToggle]',
                    exportAs: 'uxMenuNavigationToggle'
                },] },
    ];
    /** @nocollapse */
    MenuNavigationToggleDirective.ctorParameters = function () { return [
        { type: ElementRef, },
    ]; };
    MenuNavigationToggleDirective.propDecorators = {
        "menuOpen": [{ type: Input },],
        "menuPosition": [{ type: Input },],
        "menuOpenChange": [{ type: Output },],
        "keydownHandler": [{ type: HostListener, args: ['keydown', ['$event'],] },],
    };
    return MenuNavigationToggleDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var MenuNavigationDirective = (function () {
    function MenuNavigationDirective(_service, _elementRef, document) {
        this._service = _service;
        this._elementRef = _elementRef;
        this.toggleButtonPosition = 'top';
        this.navigatedOut = new EventEmitter();
        this._subscription = new Subscription();
        this._document = document;
    }
    Object.defineProperty(MenuNavigationDirective.prototype, "activeIndex", {
        get: /**
         * @return {?}
         */
        function () {
            return this._itemsOrdered.indexOf(this._service.active$.value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    MenuNavigationDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (this.toggleButton) {
            this._subscription.add(this.toggleButton.keyEnter.subscribe(this.focusFirst.bind(this)));
        }
    };
    /**
     * @return {?}
     */
    MenuNavigationDirective.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this._subscription.add(this.items.changes.subscribe(function () {
            _this._itemsOrdered = _this.items.toArray();
        }));
        this._itemsOrdered = this.items.toArray();
    };
    /**
     * @return {?}
     */
    MenuNavigationDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._subscription.unsubscribe();
    };
    /**
     * @return {?}
     */
    MenuNavigationDirective.prototype.focusFirst = /**
     * @return {?}
     */
    function () {
        this.moveFirst();
    };
    /**
     * @param {?} event
     * @return {?}
     */
    MenuNavigationDirective.prototype.keydownHandler = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        // Only handle events when focus in within the list of menu items
        if (!this._elementRef.nativeElement.contains(this._document.activeElement)) {
            return;
        }
        var /** @type {?} */ handled = false;
        switch (event.key) {
            case 'ArrowUp':
            case 'Up':
                this.movePrevious(event);
                handled = true;
                break;
            case 'ArrowDown':
            case 'Down':
                this.moveNext(event);
                handled = true;
                break;
            case 'ArrowLeft':
            case 'Left':
                if (this.toggleButtonPosition === 'left') {
                    this.moveToToggleButton(event);
                    handled = true;
                }
                break;
            case 'ArrowRight':
            case 'Right':
                if (this.toggleButtonPosition === 'right') {
                    this.moveToToggleButton(event);
                    handled = true;
                }
                break;
            case 'Home':
                this.moveFirst();
                handled = true;
                break;
            case 'End':
                this.moveLast();
                handled = true;
                break;
            case 'Escape':
                this.navigatedOut.emit(event);
                handled = true;
                break;
        }
        if (handled) {
            event.preventDefault();
            event.stopPropagation();
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    MenuNavigationDirective.prototype.moveNext = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        // Do nothing if there's no active menu item registered
        if (this.activeIndex < 0) {
            return;
        }
        var /** @type {?} */ nextIndex = this.activeIndex + 1;
        if (nextIndex < this._itemsOrdered.length) {
            // Activate the next menu item
            // (uxMenuNavigationItem subscribes to this and applies focus if it matches)
            this._service.active$.next(this._itemsOrdered[nextIndex]);
        }
        else {
            // Check if focus went out of bounds in the direction of the origin toggle button
            if (this.toggleButtonPosition === 'bottom') {
                this.moveToToggleButton(event);
            }
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    MenuNavigationDirective.prototype.movePrevious = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        // Do nothing if there's no active menu item registered
        if (this.activeIndex < 0) {
            return;
        }
        var /** @type {?} */ nextIndex = this.activeIndex - 1;
        if (nextIndex >= 0) {
            // Activate the previous menu item
            // (uxMenuNavigationItem subscribes to this and applies focus if it matches)
            this._service.active$.next(this._itemsOrdered[nextIndex]);
        }
        else {
            // Check if focus went out of bounds in the direction of the origin toggle button
            if (this.toggleButtonPosition === 'top') {
                this.moveToToggleButton(event);
            }
        }
    };
    /**
     * @return {?}
     */
    MenuNavigationDirective.prototype.moveFirst = /**
     * @return {?}
     */
    function () {
        if (this._itemsOrdered.length > 0) {
            this._service.active$.next(this._itemsOrdered[0]);
        }
    };
    /**
     * @return {?}
     */
    MenuNavigationDirective.prototype.moveLast = /**
     * @return {?}
     */
    function () {
        if (this._itemsOrdered.length > 0) {
            this._service.active$.next(this._itemsOrdered[this._itemsOrdered.length - 1]);
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    MenuNavigationDirective.prototype.moveToToggleButton = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.toggleButton) {
            this.toggleButton.focus();
            this.toggleButton.menuOpen = false;
        }
        this.navigatedOut.emit(event);
    };
    MenuNavigationDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[uxMenuNavigation]',
                    exportAs: 'uxMenuNavigation',
                    providers: [MenuNavigationService]
                },] },
    ];
    /** @nocollapse */
    MenuNavigationDirective.ctorParameters = function () { return [
        { type: MenuNavigationService, },
        { type: ElementRef, },
        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },
    ]; };
    MenuNavigationDirective.propDecorators = {
        "toggleButton": [{ type: Input },],
        "toggleButtonPosition": [{ type: Input },],
        "navigatedOut": [{ type: Output },],
        "items": [{ type: ContentChildren, args: [MenuNavigationItemDirective, { descendants: true },] },],
        "keydownHandler": [{ type: HostListener, args: ['document:keydown', ['$event'],] },],
    };
    return MenuNavigationDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var /** @type {?} */ EXPORTS = [
    MenuNavigationDirective,
    MenuNavigationItemDirective,
    MenuNavigationToggleDirective
];
var MenuNavigationModule = (function () {
    function MenuNavigationModule() {
    }
    MenuNavigationModule.decorators = [
        { type: NgModule, args: [{
                    imports: [],
                    exports: EXPORTS,
                    declarations: EXPORTS,
                },] },
    ];
    /** @nocollapse */
    MenuNavigationModule.ctorParameters = function () { return []; };
    return MenuNavigationModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var PageHeaderCustomMenuDirective = (function () {
    function PageHeaderCustomMenuDirective() {
    }
    PageHeaderCustomMenuDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[uxPageHeaderCustomMenu]'
                },] },
    ];
    /** @nocollapse */
    PageHeaderCustomMenuDirective.ctorParameters = function () { return []; };
    return PageHeaderCustomMenuDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var PageHeaderService = (function () {
    function PageHeaderService() {
        var _this = this;
        this.items$ = new BehaviorSubject([]);
        this.selected$ = new BehaviorSubject(null);
        this.selectedRoot$ = new BehaviorSubject(null);
        this.secondary$ = new BehaviorSubject(false);
        this.activeIconMenu$ = new BehaviorSubject(null);
        this.secondaryNavigationAutoselect = false;
        this._subscription = this.selected$.pipe(map(function (selected) { return _this.getRoot(selected); })).subscribe(function (root) { return _this.selectedRoot$.next(root); });
    }
    /**
     * @return {?}
     */
    PageHeaderService.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._subscription.unsubscribe();
    };
    /**
     * @param {?} item
     * @return {?}
     */
    PageHeaderService.prototype.select = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        if (this.secondaryNavigationAutoselect && item && item.children && item.children.length > 0) {
            // Select the first child in secondaryNavigationAutoselect mode
            this.selected$.next(item.children[0]);
        }
        else {
            // if we are in secondary navigation mode and we click a parent - dont deselect the child
            if (this.secondary$.getValue() === true && this.isParentOf(this.selected$.getValue(), item)) {
                return;
            }
            // Otherwise select the given item
            this.selected$.next(item);
        }
    };
    /**
     * @param {?} item
     * @return {?}
     */
    PageHeaderService.prototype.deselect = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        var _this = this;
        // deselect the current item
        item.selected = false;
        // iterate any children and deselect them
        if (item.children) {
            item.children.forEach(function (_item) { return _this.deselect(_item); });
        }
    };
    /**
     * @return {?}
     */
    PageHeaderService.prototype.deselectAll = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.items$.getValue().forEach(function (item) { return _this.deselect(item); });
    };
    /**
     * @param {?} item
     * @param {?} selected
     * @return {?}
     */
    PageHeaderService.prototype.updateItem = /**
     * @param {?} item
     * @param {?} selected
     * @return {?}
     */
    function (item, selected) {
        // Item is selected if it is the selected item, or one of the selected item's ancestors.
        item.selected = (item === selected) || this.isParentOf(selected, item);
        if (item === selected) {
            // call the select function if present
            if (item.select) {
                item.select.call(item, item);
            }
        }
    };
    /**
     * @param {?=} items
     * @return {?}
     */
    PageHeaderService.prototype.setItems = /**
     * @param {?=} items
     * @return {?}
     */
    function (items) {
        var _this = this;
        if (items === void 0) { items = []; }
        // identify all parent elements
        items.forEach(function (item) { return _this.setParent(item); });
        this.items$.next(items);
        // Set up the initally selected item
        var /** @type {?} */ initialSelectedItem = items.find(function (item) { return item.selected === true; });
        this.select(initialSelectedItem);
    };
    /**
     * @param {?} enabled
     * @return {?}
     */
    PageHeaderService.prototype.setSecondaryNavigation = /**
     * @param {?} enabled
     * @return {?}
     */
    function (enabled) {
        this.secondary$.next(enabled);
    };
    /**
     * @param {?} item
     * @return {?}
     */
    PageHeaderService.prototype.getRoot = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        return item && item.parent ? this.getRoot(item.parent) : item;
    };
    /**
     * @param {?} item
     * @param {?=} parent
     * @return {?}
     */
    PageHeaderService.prototype.setParent = /**
     * @param {?} item
     * @param {?=} parent
     * @return {?}
     */
    function (item, parent) {
        var _this = this;
        // set the parent field
        item.parent = parent;
        // call this function recursively on all children
        if (item.children) {
            item.children.forEach(function (child) { return _this.setParent(child, item); });
        }
    };
    /**
     * @param {?} node
     * @param {?} parent
     * @return {?}
     */
    PageHeaderService.prototype.isParentOf = /**
     * @param {?} node
     * @param {?} parent
     * @return {?}
     */
    function (node, parent) {
        // if there are no parents return false
        if (!node || !node.parent) {
            return false;
        }
        // if the parent is the match we are looking for return true
        if (node.parent === parent) {
            return true;
        }
        // if there are potentially grandparents then check them too
        return this.isParentOf(node.parent, parent);
    };
    PageHeaderService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    PageHeaderService.ctorParameters = function () { return []; };
    return PageHeaderService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var PageHeaderIconMenuComponent = (function () {
    function PageHeaderIconMenuComponent(_service) {
        var _this = this;
        this._service = _service;
        this._subscription = _service.activeIconMenu$.subscribe(function (next) {
            // Close all but the most recently opened menu
            if (next !== _this.menu) {
                _this._isOpen = false;
            }
        });
    }
    Object.defineProperty(PageHeaderIconMenuComponent.prototype, "isOpen", {
        get: /**
         * @return {?}
         */
        function () {
            return this._isOpen;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._isOpen = value;
            if (value) {
                this._service.activeIconMenu$.next(this.menu);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    PageHeaderIconMenuComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._subscription.unsubscribe();
    };
    /**
     * @param {?} item
     * @return {?}
     */
    PageHeaderIconMenuComponent.prototype.select = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        if (item.select) {
            item.select.call(item, item);
        }
    };
    /**
     * @param {?} item
     * @param {?} event
     * @return {?}
     */
    PageHeaderIconMenuComponent.prototype.keydownHandler = /**
     * @param {?} item
     * @param {?} event
     * @return {?}
     */
    function (item, event) {
        switch (event.key) {
            case 'Enter':
            case ' ':
                this.select(item);
                this.isOpen = false;
                this.menuNavigationToggle.focus();
                event.preventDefault();
                event.stopPropagation();
                break;
        }
    };
    PageHeaderIconMenuComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-page-header-icon-menu',
                    template: "<div class=\"page-header-icon-menu\"\n    dropdown\n    placement=\"bottom right\"\n    [(isOpen)]=\"isOpen\">\n\n    <a role=\"button\"\n        class=\"page-header-icon-menu-button\"\n        [attr.aria-label]=\"menu.label\"\n        aria-haspopup=\"true\"\n        tabindex=\"0\"\n        (click)=\"select(menu)\"\n        dropdownToggle\n        uxMenuNavigationToggle\n        #menuNavigationToggle=\"uxMenuNavigationToggle\"\n        [(menuOpen)]=\"isOpen\">\n\n        <i class=\"hpe-icon\" [ngClass]=\"menu.icon\"></i>\n        <span class=\"label label-primary\" *ngIf=\"menu?.badge\" aria-hidden=\"true\">{{ menu.badge }}</span>\n\n    </a>\n\n    <ul *dropdownMenu\n        class=\"dropdown-menu\"\n        role=\"menu\"\n        uxMenuNavigation\n        [toggleButton]=\"menuNavigationToggle\">\n\n        <li *ngFor=\"let dropdown of menu?.dropdown\"\n            role=\"none\"\n            [class.dropdown-header]=\"dropdown.header\"\n            [class.dropdown-divider]=\"dropdown.divider\">\n\n            <span class=\"font-bold\" *ngIf=\"dropdown.header\">{{ dropdown.title }}</span>\n\n            <a *ngIf=\"!dropdown.header\"\n                role=\"menuitem\"\n                class=\"dropdown-item\"\n                tabindex=\"-1\"\n                (click)=\"select(dropdown)\"\n                (keydown)=\"keydownHandler(dropdown, $event)\"\n                uxMenuNavigationItem>\n\n\n                <span class=\"dropdown-item-title\">\n                    <i class=\"hpe-icon hpe-fw\" [ngClass]=\"dropdown.icon\"></i>\n                    {{ dropdown.title }}\n                </span>\n                <span *ngIf=\"dropdown.subtitle\" class=\"dropdown-item-subtitle\">{{ dropdown.subtitle }}</span>\n\n            </a>\n        </li>\n\n    </ul>\n</div>"
                },] },
    ];
    /** @nocollapse */
    PageHeaderIconMenuComponent.ctorParameters = function () { return [
        { type: PageHeaderService, },
    ]; };
    PageHeaderIconMenuComponent.propDecorators = {
        "menu": [{ type: Input },],
        "menuNavigationToggle": [{ type: ViewChild, args: ['menuNavigationToggle',] },],
    };
    return PageHeaderIconMenuComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var PageHeaderNavigationDropdownItemComponent = (function () {
    function PageHeaderNavigationDropdownItemComponent(_pageHeaderService) {
        var _this = this;
        this._pageHeaderService = _pageHeaderService;
        this.dropdownOpen = false;
        this._hover$ = new Subject();
        // subscribe to stream with a debounce (a small debounce is all that is required)
        this._subscription = this._hover$.pipe(debounceTime(1)).subscribe(function (visible) { return _this.dropdownOpen = visible; });
        // Close submenus when selected item changes
        this._subscription.add(_pageHeaderService.selected$.subscribe(function () {
            _this.dropdownOpen = false;
        }));
    }
    /**
     * @return {?}
     */
    PageHeaderNavigationDropdownItemComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._subscription.unsubscribe();
    };
    /**
     * @param {?} item
     * @return {?}
     */
    PageHeaderNavigationDropdownItemComponent.prototype.select = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        // clicking on an item with children then return
        if (item.children) {
            return;
        }
        // emit the selected item in an event
        this._pageHeaderService.select(item);
    };
    /**
     * @return {?}
     */
    PageHeaderNavigationDropdownItemComponent.prototype.focus = /**
     * @return {?}
     */
    function () {
        this.button.nativeElement.focus();
    };
    /**
     * @return {?}
     */
    PageHeaderNavigationDropdownItemComponent.prototype.hoverStart = /**
     * @return {?}
     */
    function () {
        this._hover$.next(true);
    };
    /**
     * @return {?}
     */
    PageHeaderNavigationDropdownItemComponent.prototype.hoverLeave = /**
     * @return {?}
     */
    function () {
        this._hover$.next(false);
    };
    /**
     * @return {?}
     */
    PageHeaderNavigationDropdownItemComponent.prototype.close = /**
     * @return {?}
     */
    function () {
        this.dropdownOpen = false;
    };
    /**
     * @param {?} event
     * @param {?} item
     * @return {?}
     */
    PageHeaderNavigationDropdownItemComponent.prototype.keydownHandler = /**
     * @param {?} event
     * @param {?} item
     * @return {?}
     */
    function (event, item) {
        switch (event.key) {
            case 'Enter':
            case ' ':
                this.select(item);
                event.preventDefault();
                event.stopPropagation();
                break;
        }
    };
    PageHeaderNavigationDropdownItemComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-page-header-horizontal-navigation-dropdown-item',
                    exportAs: 'ux-page-header-horizontal-navigation-dropdown-item',
                    template: "<div *ngIf=\"item.children && item.children.length > 0\"\n    dropdown\n    #subMenu=\"bs-dropdown\"\n    [isOpen]=\"dropdownOpen\"\n    container=\"body\"\n    placement=\"right\"\n    (mouseenter)=\"hoverStart()\"\n    (mouseleave)=\"hoverLeave()\">\n\n    <a role=\"menuitem\"\n        class=\"dropdown-item\"\n        [class.selected]=\"item.selected\"\n        aria-haspopup=\"true\"\n        [attr.aria-expanded]=\"dropdownOpen\"\n        [attr.aria-selected]=\"item.selected\"\n        tabindex=\"-1\"\n        #button\n        dropdownToggle\n        uxMenuNavigationToggle\n        #menuNavigationToggle=\"uxMenuNavigationToggle\"\n        [(menuOpen)]=\"dropdownOpen\"\n        menuPosition=\"right\">\n\n        <span class=\"dropdown-item-title\">{{ item.title }}</span>\n        <span class=\"dropdown-item-icon hpe-icon hpe-next\"></span>\n\n    </a>\n\n    <ul *dropdownMenu\n        role=\"menu\"\n        class=\"dropdown-menu horizontal-navigation-dropdown-submenu\"\n        (mouseenter)=\"hoverStart()\"\n        (mouseleave)=\"hoverLeave()\"\n        uxMenuNavigation\n        #menuNavigation=\"uxMenuNavigation\"\n        [toggleButton]=\"menuNavigationToggle\"\n        toggleButtonPosition=\"left\">\n\n        <li *ngFor=\"let subItem of item.children\" role=\"none\">\n\n            <a role=\"menuitem\"\n                class=\"dropdown-item\"\n                [class.selected]=\"subItem.selected\"\n                [attr.aria-selected]=\"subItem.selected\"\n                tabindex=\"-1\"\n                (click)=\"select(subItem)\"\n                (keydown)=\"keydownHandler($event, subItem)\"\n                uxMenuNavigationItem>\n\n                <span class=\"dropdown-item-title\">{{ subItem.title }}</span>\n\n            </a>\n\n        </li>\n    </ul>\n\n</div>\n\n<div *ngIf=\"!item.children || item.children.length === 0\"\n    (mouseenter)=\"hoverStart()\"\n    (mouseleave)=\"hoverLeave()\">\n\n    <a role=\"menuitem\"\n        #button\n        class=\"dropdown-item\"\n        [class.selected]=\"item.selected\"\n        [attr.aria-selected]=\"item.selected\"\n        tabindex=\"-1\"\n        (click)=\"select(item)\"\n        (keydown)=\"keydownHandler($event, item)\">\n\n        <span class=\"dropdown-item-title\">{{ item.title }}</span>\n\n    </a>\n\n</div>"
                },] },
    ];
    /** @nocollapse */
    PageHeaderNavigationDropdownItemComponent.ctorParameters = function () { return [
        { type: PageHeaderService, },
    ]; };
    PageHeaderNavigationDropdownItemComponent.propDecorators = {
        "item": [{ type: Input },],
        "button": [{ type: ViewChild, args: ['button',] },],
    };
    return PageHeaderNavigationDropdownItemComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var PageHeaderNavigationItemComponent = (function () {
    function PageHeaderNavigationItemComponent(elementRef, _pageHeaderService) {
        this.elementRef = elementRef;
        this._pageHeaderService = _pageHeaderService;
        this.secondary$ = this._pageHeaderService.secondary$;
    }
    /**
     * @return {?}
     */
    PageHeaderNavigationItemComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this._subscription = this._pageHeaderService.selected$.subscribe(function (next) {
            // Update selected state for this item
            // Update selected state for this item
            _this._pageHeaderService.updateItem(_this.item, next);
            if (next && _this.isOpen) {
                _this.isOpen = false;
                // If menu was closed, keep focus on the toggle button
                // If menu was closed, keep focus on the toggle button
                _this.button.focus();
            }
        });
        if (this.menu) {
            this._subscription.add(this.menu.onHidden.subscribe(function () { return _this.dropdowns.forEach(function (dropdown) { return dropdown.close(); }); }));
        }
    };
    /**
     * @return {?}
     */
    PageHeaderNavigationItemComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._subscription.unsubscribe();
    };
    /**
     * @return {?}
     */
    PageHeaderNavigationItemComponent.prototype.select = /**
     * @return {?}
     */
    function () {
        // if the item has children then do nothing at this stage
        if (this.item.children && this._pageHeaderService.secondary$.getValue() === false) {
            return;
        }
        // otherwise select the current item
        this._pageHeaderService.select(this.item);
    };
    PageHeaderNavigationItemComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-page-header-horizontal-navigation-item',
                    template: "<div *ngIf=\"item.children && item.children.length > 0 && !(secondary$ | async)\"\n    dropdown\n    #menu=\"bs-dropdown\"\n    [(isOpen)]=\"isOpen\"\n    container=\"body\"\n    placement=\"bottom left\">\n\n    <button role=\"menuitem\"\n        class=\"horizontal-navigation-button\"\n        [class.selected]=\"item.selected\"\n        [class.open]=\"isOpen\"\n        aria-haspopup=\"true\"\n        [attr.aria-expanded]=\"isOpen\"\n        [attr.aria-selected]=\"item.selected\"\n        dropdownToggle\n        uxMenuNavigationToggle\n        #button=\"uxMenuNavigationToggle\"\n        [(menuOpen)]=\"isOpen\">\n\n        <span class=\"hpe-icon navigation-item-icon\" *ngIf=\"item.icon\" [ngClass]=\"item?.icon\"></span>\n        <span class=\"navigation-item-label\">{{ item?.title }}</span>\n        <span class=\"hpe-icon hpe-down\"></span>\n\n    </button>\n\n    <div *dropdownMenu\n        role=\"menu\"\n        class=\"dropdown-menu horizontal-navigation-dropdown-menu\"\n        uxMenuNavigation\n        [toggleButton]=\"button\"\n        toggleButtonPosition=\"top\">\n\n        <div *ngFor=\"let item of item?.children\" uxMenuNavigationItem (activated)=\"dropdownItem.focus()\">\n            <ux-page-header-horizontal-navigation-dropdown-item\n                #dropdownItem=\"ux-page-header-horizontal-navigation-dropdown-item\"\n                [item]=\"item\">\n            </ux-page-header-horizontal-navigation-dropdown-item>\n        </div>\n\n    </div>\n\n</div>\n\n<button *ngIf=\"!item.children || item.children.length === 0 || (secondary$ | async)\"\n    role=\"menuitem\"\n    class=\"horizontal-navigation-button\"\n    [class.selected]=\"item.selected\"\n    [attr.aria-selected]=\"item.selected\"\n    (click)=\"select()\">\n\n    <span class=\"hpe-icon navigation-item-icon\" *ngIf=\"item.icon\" [ngClass]=\"item?.icon\"></span>\n    <span class=\"navigation-item-label\">{{ item?.title }}</span>\n\n</button>"
                },] },
    ];
    /** @nocollapse */
    PageHeaderNavigationItemComponent.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: PageHeaderService, },
    ]; };
    PageHeaderNavigationItemComponent.propDecorators = {
        "button": [{ type: ViewChild, args: ['button',] },],
        "menu": [{ type: ViewChild, args: ['menu',] },],
        "dropdowns": [{ type: ViewChildren, args: [PageHeaderNavigationDropdownItemComponent,] },],
        "item": [{ type: Input },],
    };
    return PageHeaderNavigationItemComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var PageHeaderNavigationSecondaryItemDirective = (function () {
    function PageHeaderNavigationSecondaryItemDirective(_pageHeaderService) {
        this._pageHeaderService = _pageHeaderService;
        this._onDestroy = new Subject();
    }
    /**
     * @return {?}
     */
    PageHeaderNavigationSecondaryItemDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this._pageHeaderService.selected$.pipe(delay(0), takeUntil(this._onDestroy)).subscribe(function (next) {
            // Update selected state for this item
            // Update selected state for this item
            _this._pageHeaderService.updateItem(_this.item, next);
        });
    };
    /**
     * @return {?}
     */
    PageHeaderNavigationSecondaryItemDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._onDestroy.next();
        this._onDestroy.complete();
    };
    PageHeaderNavigationSecondaryItemDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[uxPageHeaderNavigationSecondaryItem]'
                },] },
    ];
    /** @nocollapse */
    PageHeaderNavigationSecondaryItemDirective.ctorParameters = function () { return [
        { type: PageHeaderService, },
    ]; };
    PageHeaderNavigationSecondaryItemDirective.propDecorators = {
        "item": [{ type: Input, args: ['uxPageHeaderNavigationSecondaryItem',] },],
    };
    return PageHeaderNavigationSecondaryItemDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var PageHeaderNavigationComponent = (function () {
    function PageHeaderNavigationComponent(elementRef, resizeService, _pageHeaderService) {
        this._pageHeaderService = _pageHeaderService;
        this.items$ = this._pageHeaderService.items$;
        this.indicatorVisible = false;
        this.indicatorX = 0;
        this.indicatorWidth = 0;
        this._subscription = new Subscription();
        this._subscription.add(resizeService.addResizeListener(elementRef.nativeElement).subscribe(this.updateSelectedIndicator.bind(this)));
        this._subscription.add(_pageHeaderService.selected$.pipe(distinctUntilChanged()).subscribe(this.updateSelectedIndicator.bind(this)));
        this._subscription.add(_pageHeaderService.secondary$.pipe(distinctUntilChanged()).subscribe(this.updateSelectedIndicator.bind(this)));
    }
    /**
     * @return {?}
     */
    PageHeaderNavigationComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        this.updateSelectedIndicator();
    };
    /**
     * @return {?}
     */
    PageHeaderNavigationComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._subscription.unsubscribe();
    };
    /**
     * @return {?}
     */
    PageHeaderNavigationComponent.prototype.updateSelectedIndicator = /**
     * @return {?}
     */
    function () {
        var _this = this;
        setTimeout(function () {
            // find the selected item
            var /** @type {?} */ selected = _this.menuItems.find(function (item) { return item.item.selected; });
            // determine whether or not to show the indicator
            // determine whether or not to show the indicator
            _this.indicatorVisible = !!selected;
            // set the width of the indicator to match the width of the navigation item
            if (selected) {
                var /** @type {?} */ styles = getComputedStyle(selected.elementRef.nativeElement);
                _this.indicatorX = selected.elementRef.nativeElement.offsetLeft;
                _this.indicatorWidth = parseInt(styles.getPropertyValue('width'));
            }
        });
    };
    PageHeaderNavigationComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-page-header-horizontal-navigation',
                    template: "<ux-page-header-horizontal-navigation-item\n    *ngFor=\"let item of items$ | async\"\n    [item]=\"item\">\n</ux-page-header-horizontal-navigation-item>\n\n<div class=\"selected-indicator\"\n    [style.opacity]=\"indicatorVisible ? 1 : 0\"\n    [style.margin-left.px]=\"indicatorX\"\n    [style.width.px]=\"indicatorWidth\">\n</div>",
                    host: {
                        'role': 'menubar'
                    }
                },] },
    ];
    /** @nocollapse */
    PageHeaderNavigationComponent.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: ResizeService, },
        { type: PageHeaderService, },
    ]; };
    PageHeaderNavigationComponent.propDecorators = {
        "menuItems": [{ type: ViewChildren, args: [PageHeaderNavigationItemComponent,] },],
    };
    return PageHeaderNavigationComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var PageHeaderComponent = (function () {
    function PageHeaderComponent(_colorService, _pageHeaderService) {
        this._colorService = _colorService;
        this._pageHeaderService = _pageHeaderService;
        this.alignment = 'center';
        this.condensed = false;
        this.backVisible = true;
        this.secondaryNavigationAlignment = 'center';
        this.backClick = new EventEmitter();
        this.selected$ = this._pageHeaderService.selected$;
        this.selectedRoot$ = this._pageHeaderService.selectedRoot$;
        this._crumbs = [];
    }
    Object.defineProperty(PageHeaderComponent.prototype, "secondaryNavigationAutoselect", {
        get: /**
         * @return {?}
         */
        function () {
            return this._pageHeaderService.secondaryNavigationAutoselect;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._pageHeaderService.secondaryNavigationAutoselect = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PageHeaderComponent.prototype, "items", {
        set: /**
         * @param {?} items
         * @return {?}
         */
        function (items) {
            this._pageHeaderService.setItems(items);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PageHeaderComponent.prototype, "secondaryNavigation", {
        get: /**
         * @return {?}
         */
        function () {
            return this._pageHeaderService.secondary$.getValue();
        },
        set: /**
         * @param {?} enabled
         * @return {?}
         */
        function (enabled) {
            this._pageHeaderService.setSecondaryNavigation(enabled);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PageHeaderComponent.prototype, "crumbs", {
        get: /**
         * @return {?}
         */
        function () {
            return this.condensed ? __spread(this._crumbs, [{ title: this.header }]) : this._crumbs;
        },
        set: /**
         * @param {?} crumbs
         * @return {?}
         */
        function (crumbs) {
            this._crumbs = crumbs;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PageHeaderComponent.prototype, "familyBackground", {
        get: /**
         * @return {?}
         */
        function () {
            return this._familyBackground;
        },
        set: /**
         * @param {?} color
         * @return {?}
         */
        function (color) {
            this._familyBackground = this._colorService.resolve(color);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PageHeaderComponent.prototype, "familyForeground", {
        get: /**
         * @return {?}
         */
        function () {
            return this._familyForeground;
        },
        set: /**
         * @param {?} color
         * @return {?}
         */
        function (color) {
            this._familyForeground = this._colorService.resolve(color);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    PageHeaderComponent.prototype.goBack = /**
     * @return {?}
     */
    function () {
        this.backClick.emit();
    };
    /**
     * @param {?} item
     * @return {?}
     */
    PageHeaderComponent.prototype.select = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        this._pageHeaderService.select(item);
    };
    PageHeaderComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-page-header',
                    exportAs: 'ux-page-header',
                    template: "<div class=\"ux-page-header\" [class.page-header-condensed]=\"condensed\" role=\"banner\">\n\n    <!-- Display Upper Section when not condensed -->\n    <div class=\"page-header-actions\" *ngIf=\"!condensed\">\n\n        <div class=\"page-header-logo-container\" role=\"presentation\" [hidden]=\"!logo\">\n            <img [attr.src]=\"logo\" class=\"page-header-logo\">\n        </div>\n\n        <div class=\"page-header-navigation\" [ngClass]=\"alignment\" role=\"navigation\" aria-label=\"Primary Navigation\">\n\n            <!-- The Top Navigation Options -->\n            <ux-page-header-horizontal-navigation></ux-page-header-horizontal-navigation>\n        </div>\n\n        <div class=\"page-header-icon-menus\" role=\"toolbar\">\n            <ng-container *ngFor=\"let menu of customMenus\" [ngTemplateOutlet]=\"menu\"></ng-container>\n\n            <ux-page-header-icon-menu *ngFor=\"let menu of iconMenus\" [menu]=\"menu\"></ux-page-header-icon-menu>\n        </div>\n    </div>\n\n    <!-- Display Lower Section When Not Condensed -->\n    <div class=\"page-header-details\" *ngIf=\"!condensed\">\n\n        <div class=\"page-header-state-container\" role=\"navigation\">\n\n            <button *ngIf=\"backVisible === true\" class=\"page-header-back-button\" (click)=\"goBack()\" aria-label=\"Go Back\">\n                <span class=\"hpe-icon hpe-previous text-primary\"></span>\n            </button>\n\n            <div class=\"page-header-title-container\">\n\n                <ux-breadcrumbs [crumbs]=\"crumbs\"></ux-breadcrumbs>\n\n                <h1 class=\"page-header-title\" [style.backgroundColor]=\"familyBackground\" [style.color]=\"familyForeground\">{{ header }}</h1>\n            </div>\n\n        </div>\n\n    </div>\n\n    <!-- Display This Section Optimized for Condensed Mode -->\n    <div class=\"page-header-condensed-content\" *ngIf=\"condensed\">\n\n        <div class=\"page-header-breadcrumbs\" role=\"navigation\">\n            <ux-breadcrumbs [crumbs]=\"crumbs\"></ux-breadcrumbs>\n        </div>\n\n        <div class=\"page-header-navigation\" [ngClass]=\"alignment\" role=\"navigation\" aria-label=\"Primary Navigation\">\n\n            <!-- The Top Navigation Options -->\n            <ux-page-header-horizontal-navigation></ux-page-header-horizontal-navigation>\n        </div>\n\n        <div class=\"page-header-icon-menus\" role=\"toolbar\">\n            <ng-container *ngFor=\"let menu of customMenus\" [ngTemplateOutlet]=\"menu\"></ng-container>\n            <ux-page-header-icon-menu *ngFor=\"let menu of iconMenus\" [menu]=\"menu\"></ux-page-header-icon-menu>\n        </div>\n\n    </div>\n\n</div>\n\n<div class=\"page-header-secondary\" [ngClass]=\"secondaryNavigationAlignment\" role=\"navigation\" *ngIf=\"secondaryNavigation && (selectedRoot$ | async)\">\n    <ul class=\"nav nav-tabs\" role=\"tablist\" aria-label=\"Secondary Navigation\" *ngIf=\"(selectedRoot$ | async)?.children; let children\">\n        <li *ngFor=\"let child of children\"\n            [class.active]=\"child.selected\"\n            role=\"none\"\n            [uxPageHeaderNavigationSecondaryItem]=\"child\">\n\n            <a role=\"tab\"\n                [attr.aria-selected]=\"child.selected\"\n                tabindex=\"0\"\n                (click)=\"select(child)\"\n                (keydown.enter)=\"select(child)\">{{ child.title }}</a>\n\n        </li>\n    </ul>\n</div>",
                    providers: [PageHeaderService]
                },] },
    ];
    /** @nocollapse */
    PageHeaderComponent.ctorParameters = function () { return [
        { type: ColorService, },
        { type: PageHeaderService, },
    ]; };
    PageHeaderComponent.propDecorators = {
        "logo": [{ type: Input },],
        "header": [{ type: Input },],
        "alignment": [{ type: Input },],
        "condensed": [{ type: Input },],
        "iconMenus": [{ type: Input },],
        "backVisible": [{ type: Input },],
        "secondaryNavigationAlignment": [{ type: Input },],
        "secondaryNavigationAutoselect": [{ type: Input },],
        "items": [{ type: Input },],
        "secondaryNavigation": [{ type: Input },],
        "crumbs": [{ type: Input },],
        "familyBackground": [{ type: Input },],
        "familyForeground": [{ type: Input },],
        "backClick": [{ type: Output },],
        "customMenus": [{ type: ContentChildren, args: [PageHeaderCustomMenuDirective, { read: TemplateRef },] },],
    };
    return PageHeaderComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var PageHeaderModule = (function () {
    function PageHeaderModule() {
    }
    PageHeaderModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        BreadcrumbsModule,
                        ColorServiceModule,
                        ResizeModule,
                        MenuNavigationModule,
                        BsDropdownModule.forRoot()
                    ],
                    exports: [
                        PageHeaderComponent,
                        PageHeaderCustomMenuDirective
                    ],
                    declarations: [
                        PageHeaderComponent,
                        PageHeaderIconMenuComponent,
                        PageHeaderCustomMenuDirective,
                        PageHeaderNavigationComponent,
                        PageHeaderNavigationItemComponent,
                        PageHeaderNavigationDropdownItemComponent,
                        PageHeaderNavigationSecondaryItemDirective
                    ]
                },] },
    ];
    /** @nocollapse */
    PageHeaderModule.ctorParameters = function () { return []; };
    return PageHeaderModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ProgressBarComponent = (function () {
    function ProgressBarComponent() {
        this.value = 0;
        this.max = 100;
        this.indeterminate = false;
    }
    ProgressBarComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-progress-bar',
                    template: "<div *ngIf=\"!indeterminate\" class=\"progressbar-track\" [style.width.%]=\"(value / max) * 100\" [style.backgroundColor]=\"barColor\">\n    <ng-content></ng-content>\n</div>\n<div *ngIf=\"indeterminate\" class=\"progressbar-track indeterminate\" [style.backgroundColor]=\"barColor\">\n    <ng-content></ng-content>\n</div>",
                    changeDetection: ChangeDetectionStrategy.OnPush
                },] },
    ];
    /** @nocollapse */
    ProgressBarComponent.ctorParameters = function () { return []; };
    ProgressBarComponent.propDecorators = {
        "value": [{ type: Input },],
        "max": [{ type: Input },],
        "indeterminate": [{ type: Input },],
        "trackColor": [{ type: Input },],
        "barColor": [{ type: Input },],
    };
    return ProgressBarComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ProgressBarModule = (function () {
    function ProgressBarModule() {
    }
    ProgressBarModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule
                    ],
                    exports: [ProgressBarComponent],
                    declarations: [ProgressBarComponent]
                },] },
    ];
    /** @nocollapse */
    ProgressBarModule.ctorParameters = function () { return []; };
    return ProgressBarModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var /** @type {?} */ RADIOBUTTON_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(function () { return RadioButtonComponent; }),
    multi: true
};
var /** @type {?} */ uniqueRadioId = 0;
var RadioButtonComponent = (function () {
    function RadioButtonComponent() {
        this._radioButtonId = "ux-radio-button-" + ++uniqueRadioId;
        this.id = this._radioButtonId;
        this.tabindex = 0;
        this.clickable = true;
        this.disabled = false;
        this.simplified = false;
        this.ariaLabel = '';
        this.ariaLabelledby = null;
        this.ariaDescribedby = null;
        this.valueChange = new EventEmitter();
        this._value = false;
        this.focused = false;
        this.onTouchedCallback = function () { };
        this.onChangeCallback = function () { };
    }
    Object.defineProperty(RadioButtonComponent.prototype, "value", {
        get: /**
         * @return {?}
         */
        function () {
            return this._value;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._value = value;
            // invoke change event
            this.valueChange.emit(this._value);
            // call callback
            this.onChangeCallback(this._value);
            this.onTouchedCallback();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RadioButtonComponent.prototype, "inputId", {
        get: /**
         * @return {?}
         */
        function () {
            return (this.id || this._radioButtonId) + "-input";
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    RadioButtonComponent.prototype.toggle = /**
     * @return {?}
     */
    function () {
        if (this.disabled || !this.clickable) {
            return;
        }
        // toggle the checked state
        this.value = this.option;
        // call callback
        this.onChangeCallback(this.value);
    };
    // Functions required to update ng-model
    /**
     * @param {?} value
     * @return {?}
     */
    RadioButtonComponent.prototype.writeValue = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (value !== this._value) {
            this._value = value;
        }
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    RadioButtonComponent.prototype.registerOnChange = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onChangeCallback = fn;
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    RadioButtonComponent.prototype.registerOnTouched = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onTouchedCallback = fn;
    };
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    RadioButtonComponent.prototype.setDisabledState = /**
     * @param {?} isDisabled
     * @return {?}
     */
    function (isDisabled) {
        this.disabled = isDisabled;
    };
    RadioButtonComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-radio-button',
                    template: "<label [attr.for]=\"inputId\" class=\"ux-radio-button\"\n       [class.ux-radio-button-checked]=\"value === option\"\n       [class.ux-radio-button-simplified]=\"simplified\"\n       [class.ux-radio-button-disabled]=\"disabled\"\n       [class.ux-radio-button-focused]=\"focused\">\n\n    <div class=\"ux-radio-button-container\">\n        <input class=\"ux-radio-button-input\"\n            type=\"radio\"\n            [id]=\"inputId\"\n            [checked]=\"value === option\"\n            [disabled]=\"disabled\"\n            [tabindex]=\"tabindex || value === option ? 0 : -1\"\n            [attr.name]=\"name\"\n            [required]=\"required\"\n            [attr.aria-label]=\"ariaLabel\"\n            [attr.aria-labelledby]=\"ariaLabelledby\"\n            [attr.aria-describedby]=\"ariaDescribedby\"\n            [attr.aria-checked]=\"value === option\"\n            (focus)=\"focused = true\"\n            (blur)=\"focused = false\"\n            (change)=\"toggle()\"\n            (click)=\"$event.stopPropagation()\">\n    </div>\n\n    <span class=\"ux-radio-button-label\">\n        <ng-content></ng-content>\n    </span>\n\n</label>",
                    providers: [RADIOBUTTON_VALUE_ACCESSOR]
                },] },
    ];
    /** @nocollapse */
    RadioButtonComponent.ctorParameters = function () { return []; };
    RadioButtonComponent.propDecorators = {
        "id": [{ type: Input },],
        "name": [{ type: Input },],
        "required": [{ type: Input },],
        "tabindex": [{ type: Input },],
        "clickable": [{ type: Input },],
        "disabled": [{ type: Input },],
        "simplified": [{ type: Input },],
        "option": [{ type: Input },],
        "ariaLabel": [{ type: Input, args: ['aria-label',] },],
        "ariaLabelledby": [{ type: Input, args: ['aria-labelledby',] },],
        "ariaDescribedby": [{ type: Input, args: ['aria-describedby',] },],
        "valueChange": [{ type: Output },],
        "value": [{ type: Input },],
    };
    return RadioButtonComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var RadioButtonModule = (function () {
    function RadioButtonModule() {
    }
    RadioButtonModule.decorators = [
        { type: NgModule, args: [{
                    imports: [FormsModule],
                    exports: [RadioButtonComponent],
                    declarations: [RadioButtonComponent]
                },] },
    ];
    /** @nocollapse */
    RadioButtonModule.ctorParameters = function () { return []; };
    return RadioButtonModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var SearchBuilderService = (function () {
    function SearchBuilderService() {
        this.query = {};
        this.queryChange = new Subject();
        this.validationChange = new BehaviorSubject(true);
        this._componentId = 0;
        this._components = [];
        this._validation = {};
    }
    /**
     * Add a component to the internal list of components
     */
    /**
     * Add a component to the internal list of components
     * @param {?} component
     * @return {?}
     */
    SearchBuilderService.prototype.registerComponent = /**
     * Add a component to the internal list of components
     * @param {?} component
     * @return {?}
     */
    function (component) {
        // ensure there are no components with a matching name
        if (this._components.find(function (cmp) { return cmp.name === component.name; })) {
            throw new Error("Search builder components must have a unique name. The name " + component.name + " has already been used.");
        }
        // if unique then add the component to the list
        this._components.push(component);
    };
    /**
     * Bulk registration of components
     * (Just a helper method)
     */
    /**
     * Bulk registration of components
     * (Just a helper method)
     * @param {?} components
     * @return {?}
     */
    SearchBuilderService.prototype.registerComponents = /**
     * Bulk registration of components
     * (Just a helper method)
     * @param {?} components
     * @return {?}
     */
    function (components) {
        var _this = this;
        components.forEach(function (component) { return _this.registerComponent(component); });
    };
    /**
     * Get a registered component class
     */
    /**
     * Get a registered component class
     * @param {?} name
     * @return {?}
     */
    SearchBuilderService.prototype.getComponent = /**
     * Get a registered component class
     * @param {?} name
     * @return {?}
     */
    function (name) {
        // find the component
        var /** @type {?} */ component = this._components.find(function (cmp) { return cmp.name === name; });
        // if there is no match throw an exception
        if (!component) {
            throw new Error("No search build component with the name " + name + " exists");
        }
        // ensure config is defined - at least to an empty object
        component.config = component.config || {};
        return component;
    };
    /**
     * Update the internal search query state
     * note that the query will be immutable
     */
    /**
     * Update the internal search query state
     * note that the query will be immutable
     * @param {?} query
     * @return {?}
     */
    SearchBuilderService.prototype.setQuery = /**
     * Update the internal search query state
     * note that the query will be immutable
     * @param {?} query
     * @return {?}
     */
    function (query$$1) {
        this.query = Object.assign({}, query$$1);
    };
    /**
     * Return the current query state
     */
    /**
     * Return the current query state
     * @return {?}
     */
    SearchBuilderService.prototype.getQuery = /**
     * Return the current query state
     * @return {?}
     */
    function () {
        return this.query;
    };
    /**
     * Trigger the observable to indicate the query has been updated
     */
    /**
     * Trigger the observable to indicate the query has been updated
     * @return {?}
     */
    SearchBuilderService.prototype.queryHasChanged = /**
     * Trigger the observable to indicate the query has been updated
     * @return {?}
     */
    function () {
        this.queryChange.next(this.query);
    };
    /**
     * Store the validation state of the query
     */
    /**
     * Store the validation state of the query
     * @param {?} id
     * @param {?} valid
     * @return {?}
     */
    SearchBuilderService.prototype.setValid = /**
     * Store the validation state of the query
     * @param {?} id
     * @param {?} valid
     * @return {?}
     */
    function (id, valid) {
        var _this = this;
        // store the state for this specific component
        this._validation[id] = valid;
        // evaluate the entire validation state
        this.validationChange.next(!Object.keys(this._validation).some(function (key) { return !_this._validation[key]; }));
    };
    /**
     * Generate a unique id for each component
     */
    /**
     * Generate a unique id for each component
     * @return {?}
     */
    SearchBuilderService.prototype.generateComponentId = /**
     * Generate a unique id for each component
     * @return {?}
     */
    function () {
        return this._componentId++;
    };
    SearchBuilderService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    SearchBuilderService.ctorParameters = function () { return []; };
    return SearchBuilderService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var SearchBuilderGroupService = (function () {
    function SearchBuilderGroupService(_searchBuilderService) {
        this._searchBuilderService = _searchBuilderService;
    }
    /**
     * Initialise the group by defining an id
     */
    /**
     * Initialise the group by defining an id
     * @param {?} id
     * @return {?}
     */
    SearchBuilderGroupService.prototype.init = /**
     * Initialise the group by defining an id
     * @param {?} id
     * @return {?}
     */
    function (id) {
        var _this = this;
        // store the name of the group
        this._id = id;
        // create the entry in the query object if it doesn't exist
        if (!this._searchBuilderService.query[this._id]) {
            // create the section
            this._searchBuilderService.query[this._id] = [];
            // emit the changes after the initial setup
            setTimeout(function () { return _this._searchBuilderService.queryHasChanged(); });
        }
    };
    /**
     * Remove a field from the search builder query
     */
    /**
     * Remove a field from the search builder query
     * @param {?} field
     * @return {?}
     */
    SearchBuilderGroupService.prototype.remove = /**
     * Remove a field from the search builder query
     * @param {?} field
     * @return {?}
     */
    function (field) {
        // get the query for this group
        var /** @type {?} */ query$$1 = this.getQuery();
        // remove the field from the array
        query$$1.splice(query$$1.indexOf(field), 1);
    };
    /**
     * Get the query for this specific search group
     */
    /**
     * Get the query for this specific search group
     * @return {?}
     */
    SearchBuilderGroupService.prototype.getQuery = /**
     * Get the query for this specific search group
     * @return {?}
     */
    function () {
        return this._searchBuilderService.query[this._id] ? this._searchBuilderService.query[this._id] : [];
    };
    SearchBuilderGroupService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    SearchBuilderGroupService.ctorParameters = function () { return [
        { type: SearchBuilderService, },
    ]; };
    return SearchBuilderGroupService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var SearchBuilderGroupComponent = (function () {
    function SearchBuilderGroupComponent(searchBuilderGroupService, _searchBuilderService) {
        this.searchBuilderGroupService = searchBuilderGroupService;
        this._searchBuilderService = _searchBuilderService;
        this.operator = 'and';
        this.addText = 'Add a field';
        this.showPlaceholder = false;
        this.add = new EventEmitter();
        this.remove = new EventEmitter();
    }
    /**
     * @return {?}
     */
    SearchBuilderGroupComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        // ensure we have a name otherwise throw an error
        if (!this.id) {
            throw new Error('Search builder group must have a name attribute.');
        }
        // otherwise register the group
        this.searchBuilderGroupService.init(this.id);
    };
    /**
     * @param {?} field
     * @return {?}
     */
    SearchBuilderGroupComponent.prototype.removeField = /**
     * @param {?} field
     * @return {?}
     */
    function (field) {
        this.searchBuilderGroupService.remove(field);
        this.remove.emit(field);
    };
    SearchBuilderGroupComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-search-builder-group',
                    template: "<h4 class=\"search-group-title\">{{ header }}</h4>\n\n<main class=\"search-group-content\">\n\n  <section class=\"search-group-operator search-group-operator-{{ operator }}\" [class.hidden-operator]=\"searchBuilderGroupService.getQuery().length < 2\">{{ operator }}</section>\n\n  <section class=\"search-group-items\">\n\n    <div class=\"search-group-item-container\" *ngFor=\"let field of searchBuilderGroupService.getQuery()\">\n\n      <div class=\"search-group-item\">\n        <ng-container *uxSearchBuilderOutlet=\"field.type; context: field\"></ng-container>\n      </div>\n\n      <div class=\"search-group-item-remove\" (click)=\"removeField(field)\">\n        <span class=\"hpe-icon hpe-close\"></span>\n      </div>\n    </div>\n\n    <!-- Placeholder Item -->\n    <ng-container *ngIf=\"showPlaceholder\">\n\n      <!-- The Default Placeholder -->\n      <div class=\"search-group-item-container placeholder-item\" *ngIf=\"!placeholder\">\n        \n        <div class=\"search-group-item\">\n          <label class=\"form-label\">New field</label>\n          <div class=\"form-control\"></div>\n        </div>\n  \n      </div>\n\n      <!-- Allow a custom placeholder -->\n    <ng-container *ngTemplateOutlet=\"placeholder\"></ng-container>\n\n    </ng-container>\n\n  </section>\n\n  <section class=\"search-builder-group-add-field\" (click)=\"add.emit($event)\">\n\n    <button type=\"button\" class=\"btn btn-icon btn-circular button-accent\" aria-label=\"Add Field\">\n      <span class=\"hpe-icon hpe-add\" aria-hidden=\"true\"></span>\n    </button>\n\n    <span class=\"search-builder-group-add-field-label\">{{ addText }}</span>\n\n  </section>\n\n</main>\n\n<hr class=\"search-builder-group-divider\">\n",
                    providers: [SearchBuilderGroupService]
                },] },
    ];
    /** @nocollapse */
    SearchBuilderGroupComponent.ctorParameters = function () { return [
        { type: SearchBuilderGroupService, },
        { type: SearchBuilderService, },
    ]; };
    SearchBuilderGroupComponent.propDecorators = {
        "id": [{ type: Input },],
        "header": [{ type: Input },],
        "operator": [{ type: Input },],
        "addText": [{ type: Input },],
        "placeholder": [{ type: Input },],
        "showPlaceholder": [{ type: Input },],
        "add": [{ type: Output },],
        "remove": [{ type: Output },],
    };
    return SearchBuilderGroupComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var SearchBuilderOutletDirective = (function () {
    function SearchBuilderOutletDirective(_viewContainerRef, _componentFactoryResolver, _searchBuilderService) {
        this._viewContainerRef = _viewContainerRef;
        this._componentFactoryResolver = _componentFactoryResolver;
        this._searchBuilderService = _searchBuilderService;
    }
    /**
     * @return {?}
     */
    SearchBuilderOutletDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        // get the class from the type
        var /** @type {?} */ componentDefinition = this._searchBuilderService.getComponent(this.uxSearchBuilderOutlet);
        // create the component factory
        var /** @type {?} */ componentFactory = this._componentFactoryResolver.resolveComponentFactory(componentDefinition.component);
        // create the component instance
        this._componentRef = this._viewContainerRef.createComponent(componentFactory);
        // combine the predefined config with any dynmaic config
        var /** @type {?} */ config = Object.assign({}, componentDefinition.config, this.uxSearchBuilderOutletContext.config || {});
        // set the context and config property on the component instance
        this._componentRef.instance.context = this.uxSearchBuilderOutletContext;
        this._componentRef.instance.config = config;
    };
    SearchBuilderOutletDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[uxSearchBuilderOutlet]'
                },] },
    ];
    /** @nocollapse */
    SearchBuilderOutletDirective.ctorParameters = function () { return [
        { type: ViewContainerRef, },
        { type: ComponentFactoryResolver, },
        { type: SearchBuilderService, },
    ]; };
    SearchBuilderOutletDirective.propDecorators = {
        "uxSearchBuilderOutlet": [{ type: Input },],
        "uxSearchBuilderOutletContext": [{ type: Input },],
    };
    return SearchBuilderOutletDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var BaseSearchComponent = (function () {
    function BaseSearchComponent(_searchBuilderService, _searchBuilderGroupService) {
        this._searchBuilderService = _searchBuilderService;
        this._searchBuilderGroupService = _searchBuilderGroupService;
        this._id = this._searchBuilderService.generateComponentId();
        this._valid = true;
    }
    Object.defineProperty(BaseSearchComponent.prototype, "value", {
        /**
         * Get the current value of the component
         */
        get: /**
         * Get the current value of the component
         * @return {?}
         */
        function () {
            return this.context.value;
        },
        /**
         * Set the current value of the component
         */
        set: /**
         * Set the current value of the component
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.context.value = value;
            this._searchBuilderService.queryHasChanged();
            // if value has been set perform validation
            this.validate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseSearchComponent.prototype, "valid", {
        get: /**
         * @return {?}
         */
        function () {
            return this._valid;
        },
        set: /**
         * @param {?} valid
         * @return {?}
         */
        function (valid) {
            this._valid = valid;
            this._searchBuilderService.setValid(this._id, valid);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Make sure we clean up after ourselves
     */
    /**
     * Make sure we clean up after ourselves
     * @return {?}
     */
    BaseSearchComponent.prototype.ngOnDestroy = /**
     * Make sure we clean up after ourselves
     * @return {?}
     */
    function () {
        this.valid = true;
    };
    /**
     * Perform any required validation on the value
     */
    /**
     * Perform any required validation on the value
     * @return {?}
     */
    BaseSearchComponent.prototype.validate = /**
     * Perform any required validation on the value
     * @return {?}
     */
    function () {
        // if a custom validation function has been provided then use it
        this.valid = this.config.validation ? this.config.validation(this, this.value) : true;
    };
    BaseSearchComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-base-search',
                    template: ''
                },] },
    ];
    /** @nocollapse */
    BaseSearchComponent.ctorParameters = function () { return [
        { type: SearchBuilderService, },
        { type: SearchBuilderGroupService, },
    ]; };
    return BaseSearchComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var SearchTextComponent = (function (_super) {
    __extends(SearchTextComponent, _super);
    function SearchTextComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'text';
        return _this;
    }
    Object.defineProperty(SearchTextComponent.prototype, "label", {
        get: /**
         * @return {?}
         */
        function () {
            return this.config.label;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchTextComponent.prototype, "placeholder", {
        get: /**
         * @return {?}
         */
        function () {
            return this.config.placeholder || 'Enter text';
        },
        enumerable: true,
        configurable: true
    });
    SearchTextComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-search-text',
                    template: "<label class=\"form-label\" *ngIf=\"label\">{{ label }}</label>\n<input [placeholder]=\"placeholder\" [(ngModel)]=\"value\" class=\"form-control\">"
                },] },
    ];
    /** @nocollapse */
    SearchTextComponent.ctorParameters = function () { return []; };
    return SearchTextComponent;
}(BaseSearchComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var SearchDateComponent = (function (_super) {
    __extends(SearchDateComponent, _super);
    function SearchDateComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'date';
        return _this;
    }
    Object.defineProperty(SearchDateComponent.prototype, "label", {
        get: /**
         * @return {?}
         */
        function () {
            return this.config.label;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchDateComponent.prototype, "placeholder", {
        get: /**
         * @return {?}
         */
        function () {
            return this.config.placeholder || 'Enter date';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    SearchDateComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        // by default set to the current date if not specified
        if (!this.value) {
            this.value = new Date();
        }
    };
    SearchDateComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-search-date',
                    template: "<label class=\"form-label\" *ngIf=\"label\">{{ label }}</label>\n\n<div class=\"input-group date m-nil\">\n    <span class=\"input-group-addon\" tabindex=\"1\" (click)=\"popover.show()\">\n        <i class=\"hpe-icon hpe-calendar\" aria-hidden=\"true\"></i>\n    </span>\n    <input type=\"text\" #popover=\"ux-popover\" [ngModel]=\"value | date:'dd MMMM yyyy'\" [uxPopover]=\"popoverTemplate\"\n        placement=\"bottom\" popoverClass=\"date-time-picker-popover\" class=\"form-control\" aria-label=\"Selected date\" [placeholder]=\"placeholder\">\n</div>\n\n<ng-template #popoverTemplate>\n    <ux-date-time-picker [(date)]=\"value\" [showTime]=\"false\"></ux-date-time-picker>\n</ng-template>"
                },] },
    ];
    /** @nocollapse */
    SearchDateComponent.ctorParameters = function () { return []; };
    return SearchDateComponent;
}(BaseSearchComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var SearchDateRangeComponent = (function (_super) {
    __extends(SearchDateRangeComponent, _super);
    function SearchDateRangeComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'date-range';
        return _this;
    }
    Object.defineProperty(SearchDateRangeComponent.prototype, "label", {
        get: /**
         * @return {?}
         */
        function () {
            return this.config.label;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchDateRangeComponent.prototype, "from", {
        get: /**
         * @return {?}
         */
        function () {
            // if value does not exist the set it
            if (!this.value || !this.value.from) {
                this.from = new Date();
            }
            // ensure that the from value is a date object
            if (this.value.from instanceof Date === false) {
                this.value.from = new Date(this.value.from);
            }
            return this.value.from;
        },
        set: /**
         * @param {?} fromValue
         * @return {?}
         */
        function (fromValue) {
            // create new object based on the current value
            var /** @type {?} */ value = Object.assign({}, this.value);
            // ensure that the from value is a date
            if (fromValue instanceof Date === false) {
                fromValue = new Date(fromValue);
            }
            // set the latest value
            value.from = fromValue;
            // update the value object while ensuring immutability
            this.value = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchDateRangeComponent.prototype, "to", {
        get: /**
         * @return {?}
         */
        function () {
            // if value does not exist the set it
            if (!this.value || !this.value.to) {
                this.to = new Date();
            }
            // ensure that the to value is a date object
            if (this.value.to instanceof Date === false) {
                this.value.to = new Date(this.value.to);
            }
            return this.value.to;
        },
        set: /**
         * @param {?} toValue
         * @return {?}
         */
        function (toValue) {
            // create new object based on the current value
            var /** @type {?} */ value = Object.assign({}, this.value);
            // ensure that the to value is a date
            if (toValue instanceof Date === false) {
                toValue = new Date(toValue);
            }
            // set the latest value
            value.to = toValue;
            // update the value object while ensuring immutability
            this.value = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchDateRangeComponent.prototype, "fromLabel", {
        get: /**
         * @return {?}
         */
        function () {
            return this.config.fromLabel || 'From';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchDateRangeComponent.prototype, "toLabel", {
        get: /**
         * @return {?}
         */
        function () {
            return this.config.toLabel || 'To';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchDateRangeComponent.prototype, "fromPlaceholder", {
        get: /**
         * @return {?}
         */
        function () {
            return this.config.fromPlaceholder;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchDateRangeComponent.prototype, "toPlaceholder", {
        get: /**
         * @return {?}
         */
        function () {
            return this.config.toPlaceholder;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Override the default validation
     */
    /**
     * Override the default validation
     * @return {?}
     */
    SearchDateRangeComponent.prototype.validate = /**
     * Override the default validation
     * @return {?}
     */
    function () {
        // check if there is a config validation function
        if (this.config.validation) {
            return _super.prototype.validate.call(this);
        }
        // create copies of the dates so we can modify time value (to ignore it)
        var /** @type {?} */ from$$1 = new Date(this.value.from);
        var /** @type {?} */ to = new Date(this.value.to);
        // set the time to the same so we dont compare it
        from$$1.setHours(0, 0, 0, 0);
        to.setHours(0, 0, 0, 0);
        // valid if the from date is less than or equal to the to date
        this.valid = from$$1 <= to;
    };
    SearchDateRangeComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-search-date-range',
                    template: "<label class=\"form-label\" *ngIf=\"label\">{{ label }}</label>\n\n<div class=\"row\">\n    <div class=\"col-sm-12\">\n        <div class=\"form-inline\" [class.has-error]=\"!valid\">\n\n            <div class=\"form-group p-r-md\">\n                <label class=\"form-label m-r-xs\">{{ fromLabel }}</label>\n\n                <div class=\"input-group date m-nil\">\n                    <span class=\"input-group-addon p-r-xs\" tabindex=\"1\" (click)=\"fromPopover.show()\">\n                        <i class=\"hpe-icon hpe-calendar\" aria-hidden=\"true\"></i>\n                    </span>\n                    <input type=\"text\" #fromPopover=\"ux-popover\" [ngModel]=\"from | date:'dd MMMM yyyy'\" [uxPopover]=\"fromPopoverTemplate\" placement=\"bottom\"\n                        popoverClass=\"date-time-picker-popover\" class=\"form-control\" aria-label=\"Selected date\" [placeholder]=\"fromPlaceholder\">\n                </div>\n            </div>\n\n            <div class=\"form-group p-r-xs\">\n                <label class=\"form-label m-r-xs\">{{ toLabel }}</label>\n\n                <div class=\"input-group date m-nil\">\n                    <span class=\"input-group-addon\" tabindex=\"1\" (click)=\"toPopover.show()\">\n                        <i class=\"hpe-icon hpe-calendar\" aria-hidden=\"true\"></i>\n                    </span>\n                    <input type=\"text\" #toPopover=\"ux-popover\" [ngModel]=\"to | date:'dd MMMM yyyy'\" [uxPopover]=\"toPopoverTemplate\" placement=\"bottom\"\n                        popoverClass=\"date-time-picker-popover\" class=\"form-control\" aria-label=\"Selected date\" [placeholder]=\"toPlaceholder\">\n                </div>\n            </div>\n\n        </div>\n    </div>\n</div>\n\n<ng-template #fromPopoverTemplate>\n    <ux-date-time-picker [(date)]=\"from\" [showTime]=\"false\"></ux-date-time-picker>\n</ng-template>\n\n<ng-template #toPopoverTemplate>\n    <ux-date-time-picker [(date)]=\"to\" [showTime]=\"false\"></ux-date-time-picker>\n</ng-template>"
                },] },
    ];
    /** @nocollapse */
    SearchDateRangeComponent.ctorParameters = function () { return []; };
    return SearchDateRangeComponent;
}(BaseSearchComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var SearchSelectComponent = (function (_super) {
    __extends(SearchSelectComponent, _super);
    function SearchSelectComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.type = 'select';
        return _this;
    }
    Object.defineProperty(SearchSelectComponent.prototype, "label", {
        /**
         * Provide defaults for undefined properties
         */
        get: /**
         * Provide defaults for undefined properties
         * @return {?}
         */
        function () {
            return this.config.label;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchSelectComponent.prototype, "options", {
        get: /**
         * @return {?}
         */
        function () {
            return this.config.options || [];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchSelectComponent.prototype, "multiple", {
        get: /**
         * @return {?}
         */
        function () {
            return this.config.multiple || false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchSelectComponent.prototype, "placeholder", {
        get: /**
         * @return {?}
         */
        function () {
            return this.config.placeholder || 'Select item';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchSelectComponent.prototype, "dropDirection", {
        get: /**
         * @return {?}
         */
        function () {
            return this.config.dropDirection || 'down';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchSelectComponent.prototype, "allowNull", {
        get: /**
         * @return {?}
         */
        function () {
            return this.config.allowNull || false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchSelectComponent.prototype, "disabled", {
        get: /**
         * @return {?}
         */
        function () {
            return this.config.disabled || false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchSelectComponent.prototype, "maxHeight", {
        get: /**
         * @return {?}
         */
        function () {
            return this.config.maxHeight || '250px';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchSelectComponent.prototype, "pageSize", {
        get: /**
         * @return {?}
         */
        function () {
            return this.config.pageSize || 20;
        },
        enumerable: true,
        configurable: true
    });
    SearchSelectComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-search-select',
                    template: "<label class=\"form-label\" *ngIf=\"label\">{{ label }}</label>\n\n<ux-select [(value)]=\"value\" \n           [options]=\"options\" \n           [multiple]=\"multiple\" \n           [placeholder]=\"placeholder\" \n           [dropDirection]=\"dropDirection\"\n           [pageSize]=\"pageSize\"\n           [allowNull]=\"allowNull\"\n           [disabled]=\"disabled\"\n           [maxHeight]=\"maxHeight\"\n           [key]=\"config.key\"\n           [display]=\"config.display\"\n           [loadingTemplate]=\"config.loadingTemplate\"\n           [optionTemplate]=\"config.optionTemplate\"\n           [noOptionsTemplate]=\"config.noOptionsTemplate\">\n</ux-select>"
                },] },
    ];
    /** @nocollapse */
    SearchSelectComponent.ctorParameters = function () { return []; };
    return SearchSelectComponent;
}(BaseSearchComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var SearchBuilderComponent = (function () {
    /**
     * Register the default search builder components
     */
    function SearchBuilderComponent(_searchBuilderService) {
        var _this = this;
        this._searchBuilderService = _searchBuilderService;
        this.queryChange = new EventEmitter();
        this.valid = new EventEmitter(true);
        // watch for any query changes
        this._querySubscription = _searchBuilderService.queryChange.subscribe(function (query$$1) { return _this.queryChange.emit(query$$1); });
        // watch for any changes to the validation
        this._validSubscription = _searchBuilderService.validationChange.pipe(distinctUntilChanged()).subscribe(function (valid) { return _this.valid.emit(valid); });
    }
    Object.defineProperty(SearchBuilderComponent.prototype, "components", {
        set: /**
         * @param {?} components
         * @return {?}
         */
        function (components) {
            this._searchBuilderService.registerComponents(components);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SearchBuilderComponent.prototype, "query", {
        get: /**
         * @return {?}
         */
        function () {
            return this._searchBuilderService.getQuery();
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._searchBuilderService.setQuery(value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Remove any subscriptions and cleanup
     */
    /**
     * Remove any subscriptions and cleanup
     * @return {?}
     */
    SearchBuilderComponent.prototype.ngOnDestroy = /**
     * Remove any subscriptions and cleanup
     * @return {?}
     */
    function () {
        this._querySubscription.unsubscribe();
        this._validSubscription.unsubscribe();
    };
    SearchBuilderComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-search-builder',
                    template: "<ng-content></ng-content>",
                    providers: [SearchBuilderService]
                },] },
    ];
    /** @nocollapse */
    SearchBuilderComponent.ctorParameters = function () { return [
        { type: SearchBuilderService, },
    ]; };
    SearchBuilderComponent.propDecorators = {
        "components": [{ type: Input },],
        "query": [{ type: Input },],
        "queryChange": [{ type: Output },],
        "valid": [{ type: Output },],
    };
    return SearchBuilderComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var TypeaheadOptionEvent = (function () {
    function TypeaheadOptionEvent(option) {
        this.option = option;
    }
    return TypeaheadOptionEvent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var TypeaheadKeyService = (function () {
    function TypeaheadKeyService() {
    }
    /**
     * @param {?} event
     * @param {?} typeahead
     * @return {?}
     */
    TypeaheadKeyService.prototype.handleKey = /**
     * @param {?} event
     * @param {?} typeahead
     * @return {?}
     */
    function (event, typeahead) {
        if (typeahead) {
            switch (event.key) {
                case 'ArrowUp':
                case 'Up':
                    if (!typeahead.open) {
                        typeahead.open = true;
                    }
                    else {
                        typeahead.moveHighlight(-1);
                    }
                    event.preventDefault();
                    break;
                case 'ArrowDown':
                case 'Down':
                    if (!typeahead.open) {
                        typeahead.open = true;
                    }
                    else {
                        typeahead.moveHighlight(1);
                    }
                    event.preventDefault();
                    break;
                case 'Escape':
                case 'Esc':
                    typeahead.open = false;
                    break;
            }
        }
    };
    TypeaheadKeyService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    TypeaheadKeyService.ctorParameters = function () { return []; };
    return TypeaheadKeyService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var TypeaheadService = (function () {
    function TypeaheadService() {
        this.open$ = new BehaviorSubject(false);
        this.highlightedElement$ = new BehaviorSubject(null);
    }
    TypeaheadService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    TypeaheadService.ctorParameters = function () { return []; };
    return TypeaheadService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var /** @type {?} */ uniqueId = 0;
var TypeaheadComponent = (function () {
    function TypeaheadComponent(typeaheadElement, _cdRef, _service) {
        var _this = this;
        this.typeaheadElement = typeaheadElement;
        this._cdRef = _cdRef;
        this._service = _service;
        this.id = "ux-typeahead-" + ++uniqueId;
        this.openChange = new EventEmitter();
        this.dropDirection = 'down';
        this.maxHeight = '250px';
        this.multiselectable = false;
        this.openOnFilterChange = true;
        this.pageSize = 20;
        this.selectFirst = true;
        this.optionSelected = new EventEmitter();
        this.highlightedChange = new EventEmitter();
        this.highlightedElementChange = new EventEmitter();
        this.visibleOptions$ = new BehaviorSubject([]);
        this.loading = false;
        this.clicking = false;
        this.highlighted$ = new BehaviorSubject(null);
        this.highlightedKey = null;
        this._open = false;
        this._subscription = new Subscription();
        this.optionApi = {
            getKey: this.getKey.bind(this),
            getDisplay: this.getDisplay.bind(this),
            getDisplayHtml: this.getDisplayHtml.bind(this)
        };
        this.loadOptionsCallback = function (pageNum, pageSize, filter$$1) {
            if (typeof _this.options === 'function') {
                // Invoke the callback which may return an array or a promise.
                var /** @type {?} */ arrayOrPromise = _this.options(pageNum, pageSize, filter$$1);
                // Map the results to an array of TypeaheadVisibleOption.
                return Promise.resolve(arrayOrPromise).then(function (newOptions) {
                    if (!Array.isArray(newOptions)) {
                        return newOptions;
                    }
                    return newOptions.map(function (option) {
                        return {
                            value: option,
                            key: _this.getKey(option)
                        };
                    });
                });
            }
            return null;
        };
        this._subscription.add(this._service.open$.pipe(distinctUntilChanged()).subscribe(function (next) {
            _this.openChange.emit(next);
            if (next) {
                _this.initOptions();
            }
        }));
        this._subscription.add(this.highlighted$.subscribe(function (next) {
            _this.highlightedKey = next ? next.key : null;
            _this.highlightedChange.emit(next ? next.value : null);
        }));
        this._subscription.add(combineLatest(this._service.open$, this._service.highlightedElement$, this.visibleOptions$)
            .subscribe(function (_a) {
            var _b = __read(_a, 3), open = _b[0], highlightedElement = _b[1], visibleOptions = _b[2];
            _this.highlightedElementChange.emit(open && visibleOptions.length > 0 ? highlightedElement : null);
        }));
    }
    Object.defineProperty(TypeaheadComponent.prototype, "open", {
        get: /**
         * @return {?}
         */
        function () {
            return this._service.open$.getValue();
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._service.open$.next(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TypeaheadComponent.prototype, "highlighted", {
        get: /**
         * @return {?}
         */
        function () {
            var /** @type {?} */ value = this.highlighted$.getValue();
            return value ? value.value : null;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    TypeaheadComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        // Attach default loading template
        if (!this.loadingTemplate) {
            this.loadingTemplate = this._defaultLoadingTemplate;
        }
        // Attach default option template
        if (!this.optionTemplate) {
            this.optionTemplate = this._defaultOptionTemplate;
        }
        // Attach default "no results" template
        if (!this.noOptionsTemplate) {
            this.noOptionsTemplate = this._defaultNoOptionsTemplate;
        }
        this._cdRef.detectChanges();
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    TypeaheadComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        // Open the dropdown if the filter value updates
        if (changes["filter"]) {
            if (this.openOnFilterChange && changes["filter"].currentValue && changes["filter"].currentValue.length > 0) {
                this.open = true;
            }
        }
        // Re-filter visibleOptions
        this.updateOptions();
    };
    /**
     * @return {?}
     */
    TypeaheadComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._subscription.unsubscribe();
    };
    /**
     * @return {?}
     */
    TypeaheadComponent.prototype.mousedownHandler = /**
     * @return {?}
     */
    function () {
        this.clicking = true;
    };
    /**
     * @return {?}
     */
    TypeaheadComponent.prototype.mouseupHandler = /**
     * @return {?}
     */
    function () {
        this.clicking = false;
    };
    /**
     * @param {?} event
     * @return {?}
     */
    TypeaheadComponent.prototype.optionMousedownHandler = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        // Workaround to prevent focus changing when an option is clicked
        event.preventDefault();
    };
    /**
     * @param {?} event
     * @param {?} option
     * @return {?}
     */
    TypeaheadComponent.prototype.optionClickHandler = /**
     * @param {?} event
     * @param {?} option
     * @return {?}
     */
    function (event, option) {
        this.select(option);
    };
    /**
     * Returns the unique key value of the given option.
     */
    /**
     * Returns the unique key value of the given option.
     * @param {?} option
     * @return {?}
     */
    TypeaheadComponent.prototype.getKey = /**
     * Returns the unique key value of the given option.
     * @param {?} option
     * @return {?}
     */
    function (option) {
        if (typeof this.key === 'function') {
            return this.key(option);
        }
        if (typeof this.key === 'string' && option && option.hasOwnProperty(this.key)) {
            return option[/** @type {?} */ (this.key)];
        }
        return this.getDisplay(option);
    };
    /**
     * Returns the display value of the given option.
     */
    /**
     * Returns the display value of the given option.
     * @param {?} option
     * @return {?}
     */
    TypeaheadComponent.prototype.getDisplay = /**
     * Returns the display value of the given option.
     * @param {?} option
     * @return {?}
     */
    function (option) {
        if (typeof this.display === 'function') {
            return this.display(option);
        }
        if (typeof this.display === 'string' && option && option.hasOwnProperty(this.display)) {
            return option[/** @type {?} */ (this.display)];
        }
        return option;
    };
    /**
     * Returns the display value of the given option with HTML markup added to highlight the part which matches the current filter value.
     * @param option
     */
    /**
     * Returns the display value of the given option with HTML markup added to highlight the part which matches the current filter value.
     * @param {?} option
     * @return {?}
     */
    TypeaheadComponent.prototype.getDisplayHtml = /**
     * Returns the display value of the given option with HTML markup added to highlight the part which matches the current filter value.
     * @param {?} option
     * @return {?}
     */
    function (option) {
        var /** @type {?} */ displayText = this.getDisplay(option).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
        var /** @type {?} */ displayHtml = displayText;
        if (this.filter) {
            var /** @type {?} */ length_1 = this.filter.length;
            var /** @type {?} */ matchIndex = displayText.toLowerCase().indexOf(this.filter.toLowerCase());
            if (matchIndex >= 0) {
                var /** @type {?} */ highlight = "<span class=\"ux-filter-match\">" + displayText.substr(matchIndex, length_1) + "</span>";
                displayHtml = displayText.substr(0, matchIndex) + highlight + displayText.substr(matchIndex + length_1);
            }
        }
        return displayHtml;
    };
    /**
     * Returns true if the infinite scroll component should load
     */
    /**
     * Returns true if the infinite scroll component should load
     * @return {?}
     */
    TypeaheadComponent.prototype.isInfiniteScroll = /**
     * Returns true if the infinite scroll component should load
     * @return {?}
     */
    function () {
        return typeof this.options === 'function';
    };
    /**
     * Selects the given option, emitting the optionSelected event and closing the dropdown.
     */
    /**
     * Selects the given option, emitting the optionSelected event and closing the dropdown.
     * @param {?} option
     * @return {?}
     */
    TypeaheadComponent.prototype.select = /**
     * Selects the given option, emitting the optionSelected event and closing the dropdown.
     * @param {?} option
     * @return {?}
     */
    function (option) {
        if (!this.isDisabled(option)) {
            this.optionSelected.emit(new TypeaheadOptionEvent(option.value));
            this.highlighted$.next(null);
            this.open = false;
        }
    };
    /**
     * Returns true if the given option is part of the disabledOptions array.
     */
    /**
     * Returns true if the given option is part of the disabledOptions array.
     * @param {?} option
     * @return {?}
     */
    TypeaheadComponent.prototype.isDisabled = /**
     * Returns true if the given option is part of the disabledOptions array.
     * @param {?} option
     * @return {?}
     */
    function (option) {
        var _this = this;
        if (this.disabledOptions) {
            var /** @type {?} */ result = this.disabledOptions.find(function (selectedOption) {
                return _this.getKey(selectedOption) === option.key;
            });
            return result !== undefined;
        }
        return false;
    };
    /**
     * Set the given option as the current highlighted option, available in the highlightedOption parameter.
     */
    /**
     * Set the given option as the current highlighted option, available in the highlightedOption parameter.
     * @param {?} option
     * @return {?}
     */
    TypeaheadComponent.prototype.highlight = /**
     * Set the given option as the current highlighted option, available in the highlightedOption parameter.
     * @param {?} option
     * @return {?}
     */
    function (option) {
        if (!this.isDisabled(option)) {
            this.highlighted$.next(option);
        }
    };
    /**
     * Increment or decrement the highlighted option in the list. Disabled options are skipped.
     * @param d Value to be added to the index of the highlighted option, i.e. -1 to move backwards, +1 to move forwards.
     */
    /**
     * Increment or decrement the highlighted option in the list. Disabled options are skipped.
     * @param {?} d Value to be added to the index of the highlighted option, i.e. -1 to move backwards, +1 to move forwards.
     * @return {?}
     */
    TypeaheadComponent.prototype.moveHighlight = /**
     * Increment or decrement the highlighted option in the list. Disabled options are skipped.
     * @param {?} d Value to be added to the index of the highlighted option, i.e. -1 to move backwards, +1 to move forwards.
     * @return {?}
     */
    function (d) {
        var /** @type {?} */ visibleOptions = this.visibleOptions$.getValue();
        var /** @type {?} */ highlightIndex = this.indexOfVisibleOption(this.highlighted);
        var /** @type {?} */ newIndex = highlightIndex;
        var /** @type {?} */ disabled = true;
        var /** @type {?} */ inBounds = true;
        do {
            newIndex = newIndex + d;
            inBounds = (newIndex >= 0 && newIndex < visibleOptions.length);
            disabled = inBounds && this.isDisabled(visibleOptions[newIndex]);
        } while (inBounds && disabled);
        if (!disabled && inBounds) {
            this.highlighted$.next(visibleOptions[newIndex]);
        }
        return this.highlighted;
    };
    /**
     * Set up the options before the dropdown is displayed.
     */
    /**
     * Set up the options before the dropdown is displayed.
     * @return {?}
     */
    TypeaheadComponent.prototype.initOptions = /**
     * Set up the options before the dropdown is displayed.
     * @return {?}
     */
    function () {
        // Clear previous highlight
        this.highlighted$.next(null);
        if (this.selectFirst) {
            // This will highlight the first non-disabled option.
            this.moveHighlight(1);
        }
    };
    /**
     * Update the visibleOptions array with the current filter.
     */
    /**
     * Update the visibleOptions array with the current filter.
     * @return {?}
     */
    TypeaheadComponent.prototype.updateOptions = /**
     * Update the visibleOptions array with the current filter.
     * @return {?}
     */
    function () {
        var _this = this;
        if (typeof this.options === 'object') {
            var /** @type {?} */ normalisedInput_1 = (this.filter || '').toLowerCase();
            var /** @type {?} */ visibleOptions = this.options
                .filter(function (option) {
                return _this.getDisplay(option).toLowerCase().indexOf(normalisedInput_1) >= 0;
            })
                .map(function (value) {
                return {
                    value: value,
                    key: _this.getKey(value)
                };
            });
            this.visibleOptions$.next(visibleOptions);
        }
        this.initOptions();
    };
    /**
     * Return the index of the given option in the visibleOptions array. Returns -1 if the option is not currently visible.
     * @param {?} option
     * @return {?}
     */
    TypeaheadComponent.prototype.indexOfVisibleOption = /**
     * Return the index of the given option in the visibleOptions array. Returns -1 if the option is not currently visible.
     * @param {?} option
     * @return {?}
     */
    function (option) {
        if (option) {
            var /** @type {?} */ optionKey_1 = this.getKey(option);
            return this.visibleOptions$.getValue().findIndex(function (el) {
                return el.key === optionKey_1;
            });
        }
        return -1;
    };
    TypeaheadComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-typeahead',
                    template: "<div class=\"ux-typeahead-options\"\n    [uxInfiniteScroll]=\"loadOptionsCallback\"\n    [collection]=\"visibleOptions$ | async\"\n    (collectionChange)=\"visibleOptions$.next($event)\"\n    [enabled]=\"isInfiniteScroll()\"\n    [filter]=\"filter\"\n    [loadOnScroll]=\"true\"\n    [pageSize]=\"pageSize\"\n    [scrollElement]=\"typeaheadElement\"\n    (loading)=\"loading = true\"\n    (loaded)=\"loading = false\">\n\n    <ol *ngIf=\"(visibleOptions$ | async).length > 0\">\n        <li *ngFor=\"let option of (visibleOptions$ | async); let i = index\"\n            [attr.id]=\"id + '-option-' + i\"\n            [class.disabled]=\"isDisabled(option)\"\n            [class.highlighted]=\"highlightedKey === option.key\"\n            [attr.aria-selected]=\"multiselectable ? isDisabled(option) : null\"\n            [uxTypeaheadHighlight]=\"highlightedKey === option.key\"\n            [uxScrollIntoViewIf]=\"highlightedKey === option.key\"\n            [scrollParent]=\"typeaheadElement.nativeElement\"\n            (mousedown)=\"optionMousedownHandler($event)\"\n            (click)=\"optionClickHandler($event, option)\"\n            (mouseover)=\"highlight(option)\">\n\n            <ng-container [ngTemplateOutlet]=\"optionTemplate\"\n                [ngTemplateOutletContext]=\"{option: option.value, api: optionApi}\">\n            </ng-container>\n\n        </li>\n    </ol>\n\n    <div *uxInfiniteScrollLoading>\n        <ng-container [ngTemplateOutlet]=\"loadingTemplate\">\n        </ng-container>\n    </div>\n\n</div>\n<div *ngIf=\"(visibleOptions$ | async).length === 0 && !loading\">\n    <ng-container [ngTemplateOutlet]=\"noOptionsTemplate\">\n    </ng-container>\n</div>\n\n<ng-template #defaultLoadingTemplate>\n    <div class=\"ux-typeahead-loading\">\n        <div class=\"spinner spinner-accent spinner-bounce-middle\"></div>\n        <div>Loading...</div>\n    </div>\n</ng-template>\n\n<ng-template #defaultOptionTemplate let-option=\"option\" let-api=\"api\">\n    <span class=\"ux-typeahead-option\" [innerHtml]=\"api.getDisplayHtml(option)\"></span>\n</ng-template>\n\n<ng-template #defaultNoOptionsTemplate>\n    <span class=\"ux-typeahead-no-options\">No results</span>\n</ng-template>",
                    providers: [TypeaheadService],
                    host: {
                        'role': 'listbox',
                        '[class.open]': 'open',
                        '[class.drop-up]': 'dropDirection === "up"',
                        '[style.maxHeight]': 'maxHeight'
                    }
                },] },
    ];
    /** @nocollapse */
    TypeaheadComponent.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: ChangeDetectorRef, },
        { type: TypeaheadService, },
    ]; };
    TypeaheadComponent.propDecorators = {
        "id": [{ type: Input }, { type: HostBinding, args: ['attr.id',] },],
        "options": [{ type: Input },],
        "filter": [{ type: Input },],
        "open": [{ type: Input, args: ['open',] },],
        "openChange": [{ type: Output },],
        "display": [{ type: Input },],
        "key": [{ type: Input },],
        "disabledOptions": [{ type: Input },],
        "dropDirection": [{ type: Input },],
        "maxHeight": [{ type: Input },],
        "multiselectable": [{ type: Input }, { type: HostBinding, args: ['attr.aria-multiselectable',] },],
        "openOnFilterChange": [{ type: Input },],
        "pageSize": [{ type: Input },],
        "selectFirst": [{ type: Input },],
        "loadingTemplate": [{ type: Input },],
        "optionTemplate": [{ type: Input },],
        "noOptionsTemplate": [{ type: Input },],
        "optionSelected": [{ type: Output },],
        "highlightedChange": [{ type: Output },],
        "highlightedElementChange": [{ type: Output },],
        "_defaultLoadingTemplate": [{ type: ViewChild, args: ['defaultLoadingTemplate',] },],
        "_defaultOptionTemplate": [{ type: ViewChild, args: ['defaultOptionTemplate',] },],
        "_defaultNoOptionsTemplate": [{ type: ViewChild, args: ['defaultNoOptionsTemplate',] },],
        "mousedownHandler": [{ type: HostListener, args: ['mousedown',] },],
        "mouseupHandler": [{ type: HostListener, args: ['mouseup',] },],
    };
    return TypeaheadComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var InfiniteScrollLoadButtonDirective = (function () {
    function InfiniteScrollLoadButtonDirective(_element, _template, _viewContainer, _renderer) {
        this._element = _element;
        this._template = _template;
        this._viewContainer = _viewContainer;
        this._renderer = _renderer;
        this._visible = false;
        this._load = new Subject();
        this.load = /** @type {?} */ (this._load.asObservable());
    }
    Object.defineProperty(InfiniteScrollLoadButtonDirective.prototype, "visible", {
        get: /**
         * @return {?}
         */
        function () {
            return this._visible;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value !== this._visible) {
                if (value) {
                    this._viewContainer.createEmbeddedView(this._template);
                    // Template content follows the elementRef, which is a comment.
                    var /** @type {?} */ clickTarget = this.getNextElementSibling(this._template.elementRef.nativeElement);
                    this._renderer.listen(clickTarget, 'click', this.onClick.bind(this));
                }
                else {
                    this._viewContainer.clear();
                }
            }
            this._visible = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} event
     * @return {?}
     */
    InfiniteScrollLoadButtonDirective.prototype.onClick = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this._load.next(event);
    };
    /**
     * @param {?} element
     * @return {?}
     */
    InfiniteScrollLoadButtonDirective.prototype.getNextElementSibling = /**
     * @param {?} element
     * @return {?}
     */
    function (element) {
        var /** @type {?} */ next = element;
        while (next = next.nextSibling) {
            if (next.nodeType === 1) {
                return next;
            }
        }
        return null;
    };
    InfiniteScrollLoadButtonDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[uxInfiniteScrollLoadButton]'
                },] },
    ];
    /** @nocollapse */
    InfiniteScrollLoadButtonDirective.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: TemplateRef, },
        { type: ViewContainerRef, },
        { type: Renderer2, },
    ]; };
    InfiniteScrollLoadButtonDirective.propDecorators = {
        "visible": [{ type: Input, args: ['uxInfiniteScrollLoadButton',] },],
        "load": [{ type: Output },],
    };
    return InfiniteScrollLoadButtonDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var InfiniteScrollLoadingDirective = (function () {
    function InfiniteScrollLoadingDirective(_templateRef, _viewContainer) {
        this._templateRef = _templateRef;
        this._viewContainer = _viewContainer;
        this._visible = false;
    }
    Object.defineProperty(InfiniteScrollLoadingDirective.prototype, "visible", {
        get: /**
         * @return {?}
         */
        function () {
            return this._visible;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value !== this._visible) {
                if (value) {
                    this._viewContainer.createEmbeddedView(this._templateRef);
                }
                else {
                    this._viewContainer.clear();
                }
            }
            this._visible = value;
        },
        enumerable: true,
        configurable: true
    });
    InfiniteScrollLoadingDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[uxInfiniteScrollLoading]'
                },] },
    ];
    /** @nocollapse */
    InfiniteScrollLoadingDirective.ctorParameters = function () { return [
        { type: TemplateRef, },
        { type: ViewContainerRef, },
    ]; };
    InfiniteScrollLoadingDirective.propDecorators = {
        "visible": [{ type: Input, args: ['uxInfiniteScrollLoading',] },],
    };
    return InfiniteScrollLoadingDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var InfiniteScrollDirective = (function () {
    function InfiniteScrollDirective(_element) {
        this._element = _element;
        this._collection = [];
        this.enabled = true;
        this.loadOnInit = true;
        this.loadOnScroll = true;
        this.pageSize = 20;
        this.collectionChange = new EventEmitter();
        this.loadingEvent = new EventEmitter();
        this.loadedEvent = new EventEmitter();
        this.loadErrorEvent = new EventEmitter();
        this._nextPageNum = 0;
        this._updateRequests = new Subject();
        this._isLoading = new BehaviorSubject(false);
        this._isExhausted = new BehaviorSubject(false);
        this._loadButtonEnabled = new BehaviorSubject(false);
        this._subscriptions = [];
        this._loadButtonSubscriptions = [];
        this._onDestroy = new Subject();
        this._canLoadManually = this._isLoading.pipe(combineLatest$1(this._isExhausted, this._loadButtonEnabled, function (isLoading, isExhausted, loadButtonEnabled) {
            return !isLoading && !isExhausted && loadButtonEnabled;
        }));
    }
    Object.defineProperty(InfiniteScrollDirective.prototype, "collection", {
        get: /**
         * @return {?}
         */
        function () {
            return this._collection;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.collectionChange.emit(value);
            this._collection = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InfiniteScrollDirective.prototype, "scrollElement", {
        set: /**
         * @param {?} element
         * @return {?}
         */
        function (element) {
            this._scrollElement = element instanceof ElementRef ? element : new ElementRef(element);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    InfiniteScrollDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (!this._scrollElement) {
            this._scrollElement = this._element;
        }
        this._loadButtonEnabled.next(!this.loadOnScroll);
    };
    /**
     * @return {?}
     */
    InfiniteScrollDirective.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // There are two kinds of update requests: check and load.
        // Check requests are throttled and will only cause an update if more data is required
        // to fill the scrolling view, and it isn't already loading some.
        // Load requests are not throttled and always request a page of data.
        this._updateRequests.pipe(filter(function (request) { return request.check; }), auditTime(200), takeUntil(this._onDestroy)).subscribe(this.doRequest.bind(this));
        this._updateRequests.pipe(filter(function (request) { return !request.check; }), takeUntil(this._onDestroy)).subscribe(this.doRequest.bind(this));
        if (this.enabled) {
            // Subscribe to scroll events and DOM changes.
            this.attachEventHandlers();
        }
        // Connect the Load More button visible state.
        this._canLoadManually.pipe(takeUntil(this._onDestroy)).subscribe(function (canLoad) {
            _this._loadButtonQuery.forEach(function (loadButton) {
                loadButton.visible = canLoad;
            });
        });
        // Connect the loading indicator visible state.
        this._isLoading.pipe(takeUntil(this._onDestroy)).subscribe(function (isLoading) {
            _this._loadingIndicatorQuery.forEach(function (loading) {
                loading.visible = isLoading;
            });
        });
        // Link the Load More button click event to trigger an update.
        this.attachLoadButtonEvents();
        this._loadButtonQuery.changes.pipe(takeUntil(this._onDestroy)).subscribe(function () {
            _this.attachLoadButtonEvents();
        });
        // Initial update.
        if (this.loadOnInit) {
            this.loadNextPage();
        }
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    InfiniteScrollDirective.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        var /** @type {?} */ check = true;
        if (changes["enabled"] && changes["enabled"].currentValue !== changes["enabled"].previousValue) {
            if (changes["enabled"].currentValue) {
                this.attachEventHandlers();
                this.reset();
                check = false;
            }
            else {
                this.detachEventHandlers();
            }
        }
        if (this.enabled) {
            if (changes["filter"] && changes["filter"].currentValue !== changes["filter"].previousValue) {
                this.reset();
                check = false;
            }
            if (changes["loadOnScroll"]) {
                this._loadButtonEnabled.next(!changes["loadOnScroll"].currentValue);
            }
            if (changes["pageSize"] && changes["pageSize"].currentValue !== changes["pageSize"].previousValue) {
                this.reset();
                check = false;
            }
            this._updateRequests.next({
                check: check,
                pageNumber: this._nextPageNum,
                pageSize: this.pageSize,
                filter: this.filter
            });
        }
    };
    /**
     * @return {?}
     */
    InfiniteScrollDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.detachEventHandlers();
        this._onDestroy.next();
        this._onDestroy.complete();
    };
    /**
     * Request an additional page of data.
     */
    /**
     * Request an additional page of data.
     * @return {?}
     */
    InfiniteScrollDirective.prototype.loadNextPage = /**
     * Request an additional page of data.
     * @return {?}
     */
    function () {
        if (!this.enabled) {
            return;
        }
        this._updateRequests.next({
            check: false,
            pageNumber: this._nextPageNum,
            pageSize: this.pageSize,
            filter: this.filter
        });
    };
    /**
     * Request a check for whether an additional page of data is required. This is throttled.
     */
    /**
     * Request a check for whether an additional page of data is required. This is throttled.
     * @return {?}
     */
    InfiniteScrollDirective.prototype.check = /**
     * Request a check for whether an additional page of data is required. This is throttled.
     * @return {?}
     */
    function () {
        if (!this.enabled) {
            return;
        }
        this._updateRequests.next({
            check: true,
            pageNumber: this._nextPageNum,
            pageSize: this.pageSize,
            filter: this.filter
        });
    };
    /**
     * Clear the collection. Future requests will load from page 0.
     */
    /**
     * Clear the collection. Future requests will load from page 0.
     * @return {?}
     */
    InfiniteScrollDirective.prototype.reset = /**
     * Clear the collection. Future requests will load from page 0.
     * @return {?}
     */
    function () {
        if (!this.enabled) {
            return;
        }
        // Reset the page counter.
        this._nextPageNum = 0;
        this._pages = [];
        // Clear the collection (without changing the reference).
        if (this.collection) {
            this.collection.length = 0;
        }
        // Reset the exhausted flag, allowing the Load More button to appear.
        this._isExhausted.next(false);
        // Cancel any pending requests
        if (this._subscriptions) {
            this._subscriptions.forEach(function (request) { return request.unsubscribe(); });
        }
    };
    /**
     * Reload the data without clearing the view.
     */
    /**
     * Reload the data without clearing the view.
     * @return {?}
     */
    InfiniteScrollDirective.prototype.reload = /**
     * Reload the data without clearing the view.
     * @return {?}
     */
    function () {
        var _this = this;
        this._pages.forEach(function (page, i) { return _this.reloadPage(i); });
    };
    /**
     * Reload the data in a specific page without clearing the view.
     * @param pageNum Page number
     */
    /**
     * Reload the data in a specific page without clearing the view.
     * @param {?} pageNum Page number
     * @return {?}
     */
    InfiniteScrollDirective.prototype.reloadPage = /**
     * Reload the data in a specific page without clearing the view.
     * @param {?} pageNum Page number
     * @return {?}
     */
    function (pageNum) {
        if (!this.enabled) {
            return;
        }
        this._updateRequests.next({
            check: false,
            pageNumber: pageNum,
            pageSize: this.pageSize,
            filter: this.filter,
            reload: true
        });
    };
    /**
     * Attach scroll event handler and DOM observer.
     * @return {?}
     */
    InfiniteScrollDirective.prototype.attachEventHandlers = /**
     * Attach scroll event handler and DOM observer.
     * @return {?}
     */
    function () {
        // if the scrollElement is documentElement we must watch for a scroll event on the document
        var /** @type {?} */ target = this._scrollElement.nativeElement instanceof HTMLHtmlElement ? document : this._scrollElement.nativeElement;
        // Subscribe to the scroll event on the target element.
        this._scrollEventSub = fromEvent(target, 'scroll').subscribe(this.check.bind(this));
        // Subscribe to child DOM changes. The main effect of this is to check whether even more data is
        // required after the initial load.
        this._domObserver = new MutationObserver(this.check.bind(this));
        this._domObserver.observe(this._scrollElement.nativeElement, {
            childList: true,
            subtree: true
        });
    };
    /**
     * Detach scroll event handler and DOM observer.
     * @return {?}
     */
    InfiniteScrollDirective.prototype.detachEventHandlers = /**
     * Detach scroll event handler and DOM observer.
     * @return {?}
     */
    function () {
        if (this._scrollEventSub) {
            this._scrollEventSub.unsubscribe();
            this._scrollEventSub = null;
        }
        if (this._domObserver) {
            this._domObserver.disconnect();
            this._domObserver = null;
        }
    };
    /**
     * Remove any existing event subscriptions for the load button `load` event, then attach subscriptions
     * for any in the query.
     * @return {?}
     */
    InfiniteScrollDirective.prototype.attachLoadButtonEvents = /**
     * Remove any existing event subscriptions for the load button `load` event, then attach subscriptions
     * for any in the query.
     * @return {?}
     */
    function () {
        var _this = this;
        this._loadButtonSubscriptions.forEach(function (s) { return s.unsubscribe(); });
        this._loadButtonSubscriptions = this._loadButtonQuery.map(function (loadButton) { return loadButton.load.subscribe(_this.loadNextPage.bind(_this)); });
    };
    /**
     * Conditionally loads a page into the collection based on directive state and request parameters.
     * @param {?} request
     * @return {?}
     */
    InfiniteScrollDirective.prototype.doRequest = /**
     * Conditionally loads a page into the collection based on directive state and request parameters.
     * @param {?} request
     * @return {?}
     */
    function (request) {
        var _this = this;
        // Load a new page if the scroll position is beyond the threshhold and if the client code did not
        // cancel.
        if (this.needsData(request) && this.beginLoading(request)) {
            // Invoke the callback load function, which returns a promose or plain data.
            var /** @type {?} */ loadResult = this.load(request.pageNumber, request.pageSize, request.filter);
            var /** @type {?} */ observable = Array.isArray(loadResult) ? of(loadResult) : from(loadResult);
            var /** @type {?} */ subscription_1 = observable.pipe(first()).subscribe(function (items) {
                // Make sure that the parameters have not changed since the load started;
                // otherwise discard the results.
                if (request.filter === _this.filter && request.pageSize === _this.pageSize) {
                    if (items && items.length) {
                        _this.setPageItems(request.pageNumber, items);
                    }
                    // Emit the loaded event
                    // Emit the loaded event
                    _this.endLoading(request, items);
                }
            }, function (reason) {
                // Emit the loadError event
                // Emit the loadError event
                _this.endLoadingWithError(request, reason);
            }, function () {
                // remove this request from the list
                // remove this request from the list
                _this._subscriptions = _this._subscriptions.filter(function (s) { return s !== subscription_1; });
            });
            // add the subscription to the list of requests
            this._subscriptions.push(subscription_1);
        }
    };
    /**
     * Returns true if the request should be fulfilled.
     * @param {?} request
     * @return {?}
     */
    InfiniteScrollDirective.prototype.needsData = /**
     * Returns true if the request should be fulfilled.
     * @param {?} request
     * @return {?}
     */
    function (request) {
        if (!this.enabled) {
            return false;
        }
        // Always load for a load request
        if (!request.check) {
            return true;
        }
        // Ignore a check request when the end of data has been detected, or if data is currently loading.
        if (this._isExhausted.getValue() || this._isLoading.getValue()) {
            return false;
        }
        // Load if the remaining scroll area is <= the element height.
        if (this._scrollElement && this.loadOnScroll) {
            var /** @type {?} */ element = /** @type {?} */ (this._scrollElement.nativeElement);
            var /** @type {?} */ remainingScroll = element.scrollHeight -
                (element.scrollTop + element.clientHeight);
            return remainingScroll <= element.clientHeight;
        }
        return false;
    };
    /**
     * Updates state for the beginning of a load. Returns false if the `loading` event was cancelled.
     * @param {?} request
     * @return {?}
     */
    InfiniteScrollDirective.prototype.beginLoading = /**
     * Updates state for the beginning of a load. Returns false if the `loading` event was cancelled.
     * @param {?} request
     * @return {?}
     */
    function (request) {
        var /** @type {?} */ event = new InfiniteScrollLoadingEvent(request.pageNumber, request.pageSize, request.filter);
        this.loadingEvent.emit(event);
        this._isLoading.next(!event.defaultPrevented());
        return !event.defaultPrevented();
    };
    /**
     * @param {?} pageNum
     * @param {?} items
     * @return {?}
     */
    InfiniteScrollDirective.prototype.setPageItems = /**
     * @param {?} pageNum
     * @param {?} items
     * @return {?}
     */
    function (pageNum, items) {
        this._pages[pageNum] = items;
        this.collection = this._pages.reduce(function (previous, current) { return previous.concat(current); }, []);
    };
    /**
     * Updates state from a successful load. Raises the `loaded` event.
     * @param {?} request
     * @param {?=} data
     * @return {?}
     */
    InfiniteScrollDirective.prototype.endLoading = /**
     * Updates state from a successful load. Raises the `loaded` event.
     * @param {?} request
     * @param {?=} data
     * @return {?}
     */
    function (request, data) {
        this._isLoading.next(false);
        var /** @type {?} */ isExhausted = !!(data && data.length < this.pageSize);
        this._isExhausted.next(isExhausted);
        this.loadedEvent.emit(new InfiniteScrollLoadedEvent(request.pageNumber, request.pageSize, request.filter, data, isExhausted));
        if (!request.reload) {
            this._nextPageNum += 1;
        }
    };
    /**
     * Updates state from a failed load. Raises the `loadError` event.
     * @param {?} request
     * @param {?} error
     * @return {?}
     */
    InfiniteScrollDirective.prototype.endLoadingWithError = /**
     * Updates state from a failed load. Raises the `loadError` event.
     * @param {?} request
     * @param {?} error
     * @return {?}
     */
    function (request, error) {
        this._isLoading.next(false);
        this.loadErrorEvent.emit(new InfiniteScrollLoadErrorEvent(request.pageNumber, request.pageSize, request.filter, error));
    };
    InfiniteScrollDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[uxInfiniteScroll]',
                    exportAs: 'uxInfiniteScroll'
                },] },
    ];
    /** @nocollapse */
    InfiniteScrollDirective.ctorParameters = function () { return [
        { type: ElementRef, },
    ]; };
    InfiniteScrollDirective.propDecorators = {
        "load": [{ type: Input, args: ['uxInfiniteScroll',] },],
        "_collection": [{ type: Input, args: ['collection',] },],
        "scrollElement": [{ type: Input },],
        "enabled": [{ type: Input },],
        "filter": [{ type: Input },],
        "loadOnInit": [{ type: Input },],
        "loadOnScroll": [{ type: Input },],
        "pageSize": [{ type: Input },],
        "collectionChange": [{ type: Output },],
        "loadingEvent": [{ type: Output, args: ['loading',] },],
        "loadedEvent": [{ type: Output, args: ['loaded',] },],
        "loadErrorEvent": [{ type: Output, args: ['loadError',] },],
        "_loadButtonQuery": [{ type: ContentChildren, args: [InfiniteScrollLoadButtonDirective,] },],
        "_loadingIndicatorQuery": [{ type: ContentChildren, args: [InfiniteScrollLoadingDirective,] },],
    };
    return InfiniteScrollDirective;
}());
/**
 * Event raised before the `loading` function is called.
 */
var  /**
 * Event raised before the `loading` function is called.
 */
InfiniteScrollLoadingEvent = (function () {
    function InfiniteScrollLoadingEvent(pageNumber, pageSize, filter$$1) {
        this.pageNumber = pageNumber;
        this.pageSize = pageSize;
        this.filter = filter$$1;
        this._defaultPrevented = false;
    }
    /**
     * Prevents the default behaviour of the `loading` event (loading function will not be called).
     */
    /**
     * Prevents the default behaviour of the `loading` event (loading function will not be called).
     * @return {?}
     */
    InfiniteScrollLoadingEvent.prototype.preventDefault = /**
     * Prevents the default behaviour of the `loading` event (loading function will not be called).
     * @return {?}
     */
    function () {
        this._defaultPrevented = true;
    };
    /**
     * @return {?}
     */
    InfiniteScrollLoadingEvent.prototype.defaultPrevented = /**
     * @return {?}
     */
    function () {
        return this._defaultPrevented;
    };
    return InfiniteScrollLoadingEvent;
}());
/**
 * Event raised when the loading function result has been resolved and added to the collection.
 */
var  /**
 * Event raised when the loading function result has been resolved and added to the collection.
 */
InfiniteScrollLoadedEvent = (function () {
    function InfiniteScrollLoadedEvent(pageNumber, pageSize, filter$$1, data, exhausted) {
        this.pageNumber = pageNumber;
        this.pageSize = pageSize;
        this.filter = filter$$1;
        this.data = data;
        this.exhausted = exhausted;
    }
    return InfiniteScrollLoadedEvent;
}());
/**
 * Event raised if the loading function returns a rejected promise.
 */
var  /**
 * Event raised if the loading function returns a rejected promise.
 */
InfiniteScrollLoadErrorEvent = (function () {
    function InfiniteScrollLoadErrorEvent(pageNumber, pageSize, filter$$1, error) {
        this.pageNumber = pageNumber;
        this.pageSize = pageSize;
        this.filter = filter$$1;
        this.error = error;
    }
    return InfiniteScrollLoadErrorEvent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var InfiniteScrollModule = (function () {
    function InfiniteScrollModule() {
    }
    InfiniteScrollModule.decorators = [
        { type: NgModule, args: [{
                    imports: [],
                    exports: [
                        InfiniteScrollDirective,
                        InfiniteScrollLoadButtonDirective,
                        InfiniteScrollLoadingDirective
                    ],
                    declarations: [
                        InfiniteScrollDirective,
                        InfiniteScrollLoadButtonDirective,
                        InfiniteScrollLoadingDirective
                    ],
                    providers: [],
                },] },
    ];
    /** @nocollapse */
    InfiniteScrollModule.ctorParameters = function () { return []; };
    return InfiniteScrollModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ScrollIntoViewService = (function () {
    function ScrollIntoViewService() {
    }
    /**
     * @param {?} elem
     * @param {?} scrollParent
     * @return {?}
     */
    ScrollIntoViewService.prototype.scrollIntoView = /**
     * @param {?} elem
     * @param {?} scrollParent
     * @return {?}
     */
    function (elem, scrollParent) {
        var /** @type {?} */ offsetTop = (elem.getBoundingClientRect().top + scrollParent.scrollTop) - scrollParent.getBoundingClientRect().top;
        if (offsetTop < scrollParent.scrollTop) {
            scrollParent.scrollTop = offsetTop;
        }
        else {
            var /** @type {?} */ offsetBottom = offsetTop + elem.offsetHeight;
            if (offsetBottom > (scrollParent.scrollTop + scrollParent.clientHeight)) {
                scrollParent.scrollTop = offsetBottom - scrollParent.clientHeight;
            }
        }
    };
    ScrollIntoViewService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    ScrollIntoViewService.ctorParameters = function () { return []; };
    return ScrollIntoViewService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ScrollIntoViewIfDirective = (function () {
    function ScrollIntoViewIfDirective(_element, _scrollIntoViewService) {
        this._element = _element;
        this._scrollIntoViewService = _scrollIntoViewService;
        this.condition = false;
    }
    /**
     * @return {?}
     */
    ScrollIntoViewIfDirective.prototype.ngOnChanges = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.condition) {
            setTimeout(function () { return _this._scrollIntoViewService.scrollIntoView(_this._element.nativeElement, _this.scrollParent); });
        }
    };
    ScrollIntoViewIfDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[uxScrollIntoViewIf]',
                    providers: [ScrollIntoViewService]
                },] },
    ];
    /** @nocollapse */
    ScrollIntoViewIfDirective.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: ScrollIntoViewService, },
    ]; };
    ScrollIntoViewIfDirective.propDecorators = {
        "condition": [{ type: Input, args: ['uxScrollIntoViewIf',] },],
        "scrollParent": [{ type: Input },],
    };
    return ScrollIntoViewIfDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ScrollIntoViewDirective = (function () {
    function ScrollIntoViewDirective(_elementRef) {
        this._elementRef = _elementRef;
        /**
         * Allow a condition around whether or not this should scroll into view
         */
        this.uxScrollIntoView = true;
        /**
         * Allow user to provide the browser supported options
         */
        this.scrollIntoViewOptions = true;
    }
    /**
     * @return {?}
     */
    ScrollIntoViewDirective.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        if (this.uxScrollIntoView) {
            this._elementRef.nativeElement.scrollIntoView(this.scrollIntoViewOptions);
        }
    };
    ScrollIntoViewDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[uxScrollIntoView]'
                },] },
    ];
    /** @nocollapse */
    ScrollIntoViewDirective.ctorParameters = function () { return [
        { type: ElementRef, },
    ]; };
    ScrollIntoViewDirective.propDecorators = {
        "uxScrollIntoView": [{ type: Input },],
        "scrollIntoViewOptions": [{ type: Input },],
    };
    return ScrollIntoViewDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ScrollModule = (function () {
    function ScrollModule() {
    }
    ScrollModule.decorators = [
        { type: NgModule, args: [{
                    exports: [ScrollIntoViewIfDirective, ScrollIntoViewDirective],
                    declarations: [ScrollIntoViewIfDirective, ScrollIntoViewDirective]
                },] },
    ];
    /** @nocollapse */
    ScrollModule.ctorParameters = function () { return []; };
    return ScrollModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var TypeaheadHighlightDirective = (function () {
    function TypeaheadHighlightDirective(_service, _elementRef) {
        this._service = _service;
        this._elementRef = _elementRef;
    }
    Object.defineProperty(TypeaheadHighlightDirective.prototype, "highlight", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value) {
                this._service.highlightedElement$.next(this._elementRef.nativeElement);
            }
        },
        enumerable: true,
        configurable: true
    });
    TypeaheadHighlightDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[uxTypeaheadHighlight]'
                },] },
    ];
    /** @nocollapse */
    TypeaheadHighlightDirective.ctorParameters = function () { return [
        { type: TypeaheadService, },
        { type: ElementRef, },
    ]; };
    TypeaheadHighlightDirective.propDecorators = {
        "highlight": [{ type: Input, args: ['uxTypeaheadHighlight',] },],
    };
    return TypeaheadHighlightDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var TypeaheadModule$1 = (function () {
    function TypeaheadModule$$1() {
    }
    TypeaheadModule$$1.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        InfiniteScrollModule,
                        ScrollModule
                    ],
                    exports: [TypeaheadComponent],
                    declarations: [TypeaheadComponent, TypeaheadHighlightDirective],
                    providers: [TypeaheadKeyService],
                },] },
    ];
    /** @nocollapse */
    TypeaheadModule$$1.ctorParameters = function () { return []; };
    return TypeaheadModule$$1;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var /** @type {?} */ uniqueId$1 = 0;
var /** @type {?} */ SELECT_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(function () { return SelectComponent; }),
    multi: true
};
var SelectComponent = (function () {
    function SelectComponent(_element, _document, _typeaheadKeyService) {
        this._element = _element;
        this._document = _document;
        this._typeaheadKeyService = _typeaheadKeyService;
        this.id = "ux-select-" + ++uniqueId$1;
        this.allowNull = false;
        this.disabled = false;
        this.dropDirection = 'down';
        this.maxHeight = '250px';
        this.multiple = false;
        this.pageSize = 20;
        this.valueChange = new EventEmitter();
        this.inputChange = new EventEmitter();
        this.dropdownOpenChange = new EventEmitter();
        this.propagateChange = function (_) { };
        this._input$ = new BehaviorSubject('');
        this._dropdownOpen = false;
        this._subscription = new Subscription();
    }
    Object.defineProperty(SelectComponent.prototype, "value", {
        get: /**
         * @return {?}
         */
        function () {
            return this._value;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._value = value;
            this.valueChange.emit(value);
            this.propagateChange(value);
            // if we are not allow multiple selection update the input value (supporting ngModel)
            if (!this.multiple && value !== null) {
                this.input = this.getDisplay(value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectComponent.prototype, "input", {
        get: /**
         * @return {?}
         */
        function () {
            return this._input$.value;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._input$.next(value);
            this.inputChange.emit(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectComponent.prototype, "dropdownOpen", {
        get: /**
         * @return {?}
         */
        function () {
            return this._dropdownOpen;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._dropdownOpen = value;
            this.dropdownOpenChange.emit(value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    SelectComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // Changes to the input field
        var /** @type {?} */ onInput = this._input$.pipe(filter(function (value) { return _this.allowNull; }), filter(function (value) { return !_this.multiple && value !== _this.getDisplay(_this.value); })).subscribe(function (value) { return _this.value = null; });
        // Set up filter from input
        this.filter$ = this._input$.pipe(map(function (input) { return !_this.multiple && input === _this.getDisplay(_this.value) ? '' : input; }), debounceTime(200));
        // Open the dropdown when filter is nonempty.
        var /** @type {?} */ onFilter = this.filter$.pipe(filter(function (value) { return value && value.length > 0; })).subscribe(function () { return _this.dropdownOpen = true; });
        // store the subscriptions
        this._subscription.add(onInput);
        this._subscription.add(onFilter);
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    SelectComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (changes["multiple"] && !changes["multiple"].firstChange && changes["multiple"].currentValue !== changes["multiple"].previousValue) {
            this.input = '';
        }
    };
    /**
     * @return {?}
     */
    SelectComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._subscription.unsubscribe();
    };
    /**
     * @param {?} obj
     * @return {?}
     */
    SelectComponent.prototype.writeValue = /**
     * @param {?} obj
     * @return {?}
     */
    function (obj) {
        if (obj !== undefined && obj !== this._value) {
            this.value = obj;
        }
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    SelectComponent.prototype.registerOnChange = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.propagateChange = fn;
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    SelectComponent.prototype.registerOnTouched = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) { };
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    SelectComponent.prototype.setDisabledState = /**
     * @param {?} isDisabled
     * @return {?}
     */
    function (isDisabled) {
        this.disabled = isDisabled;
    };
    /**
     * @param {?} event
     * @return {?}
     */
    SelectComponent.prototype.inputClickHandler = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.selectInputText();
        this.dropdownOpen = true;
    };
    /**
     * @param {?} event
     * @return {?}
     */
    SelectComponent.prototype.inputBlurHandler = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        // If a click on the typeahead is in progress, just refocus the input.
        // This works around an issue in IE where clicking a scrollbar drops focus.
        if (this.singleTypeahead && this.singleTypeahead.clicking) {
            this.singleInput.nativeElement.focus();
            return;
        }
        // Close dropdown and reset text input if focus is lost
        setTimeout(function () {
            if (!_this._element.nativeElement.contains(_this._document.activeElement)) {
                _this.dropdownOpen = false;
                if (!_this.multiple) {
                    _this.input = _this.getDisplay(_this.value);
                }
            }
        }, 200);
    };
    /**
     * Key handler for single select only. Multiple select key handling is in TagInputComponent.
     */
    /**
     * Key handler for single select only. Multiple select key handling is in TagInputComponent.
     * @param {?} event
     * @return {?}
     */
    SelectComponent.prototype.inputKeyHandler = /**
     * Key handler for single select only. Multiple select key handling is in TagInputComponent.
     * @param {?} event
     * @return {?}
     */
    function (event) {
        // Standard keys for typeahead (up/down/esc)
        this._typeaheadKeyService.handleKey(event, this.singleTypeahead);
        switch (event.key) {
            case 'Enter':
                if (this._dropdownOpen) {
                    // Set the highlighted option as the value and close
                    this.value = this.singleTypeahead.highlighted;
                    this.dropdownOpen = false;
                }
                // Update the input field. If dropdown isn't open then reset it to the previous value.
                this.input = this.getDisplay(this.value);
                event.preventDefault();
                break;
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    SelectComponent.prototype.singleOptionSelected = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (event.option) {
            this.value = event.option;
            this.dropdownOpen = false;
        }
    };
    /**
     * Returns the display value of the given option.
     */
    /**
     * Returns the display value of the given option.
     * @param {?} option
     * @return {?}
     */
    SelectComponent.prototype.getDisplay = /**
     * Returns the display value of the given option.
     * @param {?} option
     * @return {?}
     */
    function (option) {
        if (option === null || option === undefined) {
            return '';
        }
        if (typeof this.display === 'function') {
            return this.display(option);
        }
        if (typeof this.display === 'string' && option.hasOwnProperty(this.display)) {
            return option[/** @type {?} */ (this.display)];
        }
        return option;
    };
    /**
     * @return {?}
     */
    SelectComponent.prototype.selectInputText = /**
     * @return {?}
     */
    function () {
        this.singleInput.nativeElement.select();
    };
    SelectComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-select',
                    template: "<ux-tag-input *ngIf=\"multiple\"\n    [id]=\"id + '-input'\"\n    [(tags)]=\"value\"\n    [(input)]=\"input\"\n    [addOnPaste]=\"false\"\n    [disabled]=\"disabled\"\n    [display]=\"display\"\n    [freeInput]=\"false\"\n    [placeholder]=\"placeholder\"\n    [showTypeaheadOnClick]=\"true\">\n\n    <ux-typeahead #multipleTypeahead\n        [id]=\"id + '-typeahead'\"\n        [options]=\"options\"\n        [filter]=\"filter$ | async\"\n        [(open)]=\"dropdownOpen\"\n        [display]=\"display\"\n        [key]=\"key\"\n        [disabledOptions]=\"value\"\n        [dropDirection]=\"dropDirection\"\n        [maxHeight]=\"maxHeight\"\n        [multiselectable]=\"true\"\n        [pageSize]=\"pageSize\"\n        [selectFirst]=\"true\"\n        [loadingTemplate]=\"loadingTemplate\"\n        [optionTemplate]=\"optionTemplate\"\n        [noOptionsTemplate]=\"noOptionsTemplate\">\n    </ux-typeahead>\n\n</ux-tag-input>\n\n<div *ngIf=\"!multiple\"\n    class=\"inner-addon right-addon\"\n    [class.disabled]=\"disabled\"\n    role=\"combobox\"\n    [attr.aria-expanded]=\"dropdownOpen\"\n    aria-haspopup=\"listbox\">\n\n    <i class=\"hpe-icon\"\n        [class.hpe-down]=\"dropDirection === 'down'\"\n        [class.hpe-up]=\"dropDirection === 'up'\"></i>\n\n    <input #singleInput type=\"text\" [attr.id]=\"id + '-input'\" class=\"form-control\"\n        [attr.aria-activedescendant]=\"highlightedElement?.id\"\n        aria-autocomplete=\"list\"\n        [attr.aria-controls]=\"singleTypeahead.id\"\n        aria-multiline=\"false\"\n        [(ngModel)]=\"input\"\n        [placeholder]=\"placeholder\"\n        [disabled]=\"disabled\"\n        (click)=\"inputClickHandler($event)\"\n        (blur)=\"inputBlurHandler($event)\"\n        (keydown)=\"inputKeyHandler($event)\">\n\n    <ux-typeahead #singleTypeahead\n        [id]=\"id + '-typeahead'\"\n        [options]=\"options\"\n        [filter]=\"filter$ | async\"\n        [(open)]=\"dropdownOpen\"\n        [display]=\"display\"\n        [key]=\"key\"\n        [dropDirection]=\"dropDirection\"\n        [maxHeight]=\"maxHeight\"\n        [multiselectable]=\"false\"\n        [openOnFilterChange]=\"false\"\n        [pageSize]=\"pageSize\"\n        [selectFirst]=\"true\"\n        [loadingTemplate]=\"loadingTemplate\"\n        [optionTemplate]=\"optionTemplate\"\n        [noOptionsTemplate]=\"noOptionsTemplate\"\n        (optionSelected)=\"singleOptionSelected($event)\"\n        (highlightedElementChange)=\"highlightedElement = $event\">\n    </ux-typeahead>\n\n</div>\n",
                    providers: [SELECT_VALUE_ACCESSOR]
                },] },
    ];
    /** @nocollapse */
    SelectComponent.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },
        { type: TypeaheadKeyService, },
    ]; };
    SelectComponent.propDecorators = {
        "id": [{ type: Input }, { type: HostBinding, args: ['attr.id',] },],
        "value": [{ type: Input },],
        "input": [{ type: Input },],
        "dropdownOpen": [{ type: Input },],
        "options": [{ type: Input },],
        "display": [{ type: Input },],
        "key": [{ type: Input },],
        "allowNull": [{ type: Input },],
        "disabled": [{ type: Input },],
        "dropDirection": [{ type: Input },],
        "maxHeight": [{ type: Input },],
        "multiple": [{ type: Input },],
        "pageSize": [{ type: Input },],
        "placeholder": [{ type: Input },],
        "loadingTemplate": [{ type: Input },],
        "noOptionsTemplate": [{ type: Input },],
        "optionTemplate": [{ type: Input },],
        "valueChange": [{ type: Output },],
        "inputChange": [{ type: Output },],
        "dropdownOpenChange": [{ type: Output },],
        "singleInput": [{ type: ViewChild, args: ['singleInput',] },],
        "multipleTypeahead": [{ type: ViewChild, args: ['multipleTypeahead',] },],
        "singleTypeahead": [{ type: ViewChild, args: ['singleTypeahead',] },],
    };
    return SelectComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var TagInputEvent = (function () {
    function TagInputEvent(tag) {
        this.tag = tag;
        this._defaultPrevented = false;
    }
    /**
     * @return {?}
     */
    TagInputEvent.prototype.preventDefault = /**
     * @return {?}
     */
    function () {
        this._defaultPrevented = true;
    };
    /**
     * @return {?}
     */
    TagInputEvent.prototype.defaultPrevented = /**
     * @return {?}
     */
    function () {
        return this._defaultPrevented;
    };
    return TagInputEvent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var /** @type {?} */ uniqueId$2 = 0;
var /** @type {?} */ TAGINPUT_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(function () { return TagInputComponent; }),
    multi: true
};
var /** @type {?} */ TAGINPUT_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(function () { return TagInputComponent; }),
    multi: true
};
var TagInputComponent = (function () {
    function TagInputComponent(_element, _document, _typeaheadKeyService) {
        this._element = _element;
        this._document = _document;
        this._typeaheadKeyService = _typeaheadKeyService;
        this.id = "ux-tag-input-" + ++uniqueId$2;
        this.tagsChange = new EventEmitter();
        this.inputChange = new EventEmitter();
        this.addOnPaste = true;
        this.disabled = false;
        this.enforceTagLimits = false;
        this.freeInput = true;
        this.maxTags = Number.MAX_VALUE;
        this.minTags = 0;
        this.placeholder = '';
        this.showTypeaheadOnClick = false;
        this.tagDelimiters = '';
        this.tagClass = function () { return undefined; };
        this.validationErrors = {};
        this.tagAdding = new EventEmitter();
        this.tagAdded = new EventEmitter();
        this.tagInvalidated = new EventEmitter();
        this.tagRemoving = new EventEmitter();
        this.tagRemoved = new EventEmitter();
        this.tagClick = new EventEmitter();
        this.selectedIndex = -1;
        this.tagApi = {
            getTagDisplay: this.getTagDisplay.bind(this),
            removeTagAt: this.removeTagAt.bind(this),
            canRemoveTagAt: this.canRemoveTagAt.bind(this)
        };
        this.valid = true;
        this.inputValid = true;
        this._input = '';
        this._tags = [];
        this._onChangeHandler = function () { };
        this._onTouchedHandler = function () { };
    }
    Object.defineProperty(TagInputComponent.prototype, "tags", {
        get: /**
         * @return {?}
         */
        function () {
            if (!this._tags) {
                this._tags = [];
            }
            return this._tags;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._tags = value;
            this._onChangeHandler(this._tags);
            this.tagsChange.emit(this._tags);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TagInputComponent.prototype, "input", {
        get: /**
         * @return {?}
         */
        function () {
            return this._input;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._input = value;
            this.inputChange.emit(value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    TagInputComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (!this.tagTemplate) {
            this.tagTemplate = this._defaultTagTemplate;
        }
    };
    /**
     * @return {?}
     */
    TagInputComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // Watch for optional child typeahead control
        this.connectTypeahead(this.typeaheadQuery.first);
        this.typeaheadQuery.changes.subscribe(function (query$$1) {
            _this.connectTypeahead(query$$1.first);
        });
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    TagInputComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (changes["disabled"]) {
            if (changes["disabled"].currentValue) {
                // Clear selection and close dropdown
                this.selectedIndex = -1;
                if (this.typeahead) {
                    this.typeahead.open = false;
                }
            }
        }
        // Update validation status
        this.validate();
    };
    /**
     * @param {?} value
     * @return {?}
     */
    TagInputComponent.prototype.writeValue = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (value) {
            this.tags = value;
        }
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    TagInputComponent.prototype.registerOnChange = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this._onChangeHandler = fn;
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    TagInputComponent.prototype.registerOnTouched = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this._onTouchedHandler = fn;
    };
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    TagInputComponent.prototype.setDisabledState = /**
     * @param {?} isDisabled
     * @return {?}
     */
    function (isDisabled) {
        this.disabled = isDisabled;
    };
    /**
     * @return {?}
     */
    TagInputComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this._typeaheadSubscription) {
            this._typeaheadSubscription.unsubscribe();
        }
    };
    /**
     * Validate the value of the control (tags property).
     */
    /**
     * Validate the value of the control (tags property).
     * @return {?}
     */
    TagInputComponent.prototype.validate = /**
     * Validate the value of the control (tags property).
     * @return {?}
     */
    function () {
        this.valid = true;
        var /** @type {?} */ tagRangeError = null;
        if (this.tags && (this.tags.length < this.minTags || this.tags.length > this.maxTags)) {
            tagRangeError = {
                given: this.tags.length,
                min: this.minTags,
                max: this.maxTags
            };
            this.valid = false;
        }
        this.validationErrors['tagRangeError'] = tagRangeError;
    };
    /**
     * @param {?} event
     * @return {?}
     */
    TagInputComponent.prototype.keyHandler = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.disabled) {
            return;
        }
        // Get the input field cursor location
        var /** @type {?} */ inputCursorPos = this.tagInput.nativeElement.selectionStart;
        // Determine if the input field has any text selected
        var /** @type {?} */ hasSelection = this.tagInput.nativeElement.selectionStart !== this.tagInput.nativeElement.selectionEnd;
        // Determine if a tag has focus
        var /** @type {?} */ tagSelected = this.isValidTagIndex(this.selectedIndex);
        var /** @type {?} */ inputLength = this.input ? this.input.length : 0;
        // Check whether the arrow keys can move the selection. Otherwise the input field takes the event.
        var /** @type {?} */ canNavigateLeft = tagSelected || (inputCursorPos <= 0 && !hasSelection);
        var /** @type {?} */ canNavigateRight = tagSelected || (inputCursorPos >= inputLength && !hasSelection);
        // Forward key events to the typeahead component.
        this._typeaheadKeyService.handleKey(event, this.typeahead);
        switch (event.key) {
            case 'Enter':
                // Check if a typeahead option is highlighted
                if (this.typeahead && this.typeahead.open && this.typeahead.highlighted) {
                    // Add the typeahead option as a tag, clear the input, and close the dropdown
                    this.commitTypeahead(this.typeahead.highlighted);
                    this.typeahead.open = false;
                }
                else {
                    // Validate and add the input text as a tag, if possible
                    this.commitInput();
                }
                event.preventDefault();
                break;
            case 'Backspace':
                if (canNavigateLeft) {
                    this.backspace();
                    event.stopPropagation();
                    event.preventDefault();
                }
                break;
            case 'Delete':
            case 'Del':
                if (tagSelected) {
                    this.removeTagAt(this.selectedIndex);
                }
                break;
            case 'ArrowLeft':
            case 'Left':
                if (canNavigateLeft) {
                    this.moveSelection(-1);
                    event.preventDefault();
                }
                break;
            case 'ArrowRight':
            case 'Right':
                if (canNavigateRight) {
                    this.moveSelection(1);
                    event.preventDefault();
                }
                break;
        }
        // Check for keys in the tagDelimiters
        if (this.tagDelimiters && this.tagDelimiters.indexOf(this.getKeyChar(event)) >= 0) {
            // Commit previous text
            this.commitInput();
            event.stopPropagation();
            event.preventDefault();
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    TagInputComponent.prototype.focusOutHandler = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        // If a click on the typeahead is in progress, don't do anything.
        // This works around an issue in IE where clicking a scrollbar drops focus.
        if (this.typeahead && this.typeahead.clicking) {
            return;
        }
        // Close the dropdown on blur
        setTimeout(function () {
            if (!_this._element.nativeElement.contains(_this._document.activeElement)) {
                _this.selectedIndex = -1;
                if (_this.typeahead) {
                    _this.typeahead.open = false;
                }
            }
        }, 200);
    };
    /**
     * @param {?} event
     * @param {?} tag
     * @param {?} index
     * @return {?}
     */
    TagInputComponent.prototype.tagClickHandler = /**
     * @param {?} event
     * @param {?} tag
     * @param {?} index
     * @return {?}
     */
    function (event, tag, index) {
        if (this.disabled) {
            return;
        }
        // Send tagClick event
        var /** @type {?} */ tagClickEvent = new TagInputEvent(tag);
        this.tagClick.emit(tagClickEvent);
        // Prevent focus if preventDefault() was called
        if (tagClickEvent.defaultPrevented()) {
            event.preventDefault();
            return;
        }
        // Select the tag (for IE that doesn't propagate focus)
        this.selectTagAt(index);
    };
    /**
     * @return {?}
     */
    TagInputComponent.prototype.inputClickHandler = /**
     * @return {?}
     */
    function () {
        if (this.disabled) {
            return;
        }
        if (this.typeahead && this.showTypeaheadOnClick) {
            this.typeahead.open = true;
        }
    };
    /**
     * @return {?}
     */
    TagInputComponent.prototype.inputFocusHandler = /**
     * @return {?}
     */
    function () {
        if (this.disabled) {
            return;
        }
        this.selectInput();
    };
    /**
     * @param {?} event
     * @return {?}
     */
    TagInputComponent.prototype.inputPasteHandler = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.disabled) {
            return;
        }
        if (this.addOnPaste) {
            // Get text from the clipboard
            var /** @type {?} */ input = null;
            if (event.clipboardData) {
                input = event.clipboardData.getData('text/plain');
            }
            else if ((/** @type {?} */ (window)).clipboardData) {
                // Internet Explorer only
                input = (/** @type {?} */ (window)).clipboardData.getData('Text');
            }
            // Commit the clipboard text directly
            if (this.commit(input)) {
                this.selectInput();
                event.stopPropagation();
                event.preventDefault();
            }
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    TagInputComponent.prototype.typeaheadOptionSelectedHandler = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.disabled) {
            return;
        }
        // When the typeahead sends the optionSelected event, commit the object directly
        this.commitTypeahead(event.option);
    };
    /**
     * Commit the current input value and clear the input field if successful.
     */
    /**
     * Commit the current input value and clear the input field if successful.
     * @return {?}
     */
    TagInputComponent.prototype.commitInput = /**
     * Commit the current input value and clear the input field if successful.
     * @return {?}
     */
    function () {
        if (this.commit(this.input)) {
            this.selectInput();
            this.input = '';
        }
    };
    /**
     * Commit the given tag object and clear the input if successful.
     */
    /**
     * Commit the given tag object and clear the input if successful.
     * @param {?} tag
     * @return {?}
     */
    TagInputComponent.prototype.commitTypeahead = /**
     * Commit the given tag object and clear the input if successful.
     * @param {?} tag
     * @return {?}
     */
    function (tag) {
        if (this.addTag(tag)) {
            this.selectInput();
            this.input = '';
        }
    };
    /**
     * Commit the given string value as one or more tags, if validation passes. Returns true if the tag(s) were created.
     */
    /**
     * Commit the given string value as one or more tags, if validation passes. Returns true if the tag(s) were created.
     * @param {?} input
     * @return {?}
     */
    TagInputComponent.prototype.commit = /**
     * Commit the given string value as one or more tags, if validation passes. Returns true if the tag(s) were created.
     * @param {?} input
     * @return {?}
     */
    function (input) {
        if (input && this.freeInput) {
            // Split the tags by the tagDelimiters if configured
            var /** @type {?} */ newTags = this.splitTagInput(input);
            // Check tag validation for all of the individual values
            var /** @type {?} */ allValid = true;
            try {
                for (var newTags_1 = __values(newTags), newTags_1_1 = newTags_1.next(); !newTags_1_1.done; newTags_1_1 = newTags_1.next()) {
                    var newTag = newTags_1_1.value;
                    var /** @type {?} */ valid = this.validateTag(newTag);
                    if (!valid) {
                        allValid = false;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (newTags_1_1 && !newTags_1_1.done && (_a = newTags_1.return)) _a.call(newTags_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            // Add the tags if all are valid
            if (allValid) {
                try {
                    for (var newTags_2 = __values(newTags), newTags_2_1 = newTags_2.next(); !newTags_2_1.done; newTags_2_1 = newTags_2.next()) {
                        var newTag = newTags_2_1.value;
                        this.addTag(this.createTag(newTag));
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (newTags_2_1 && !newTags_2_1.done && (_b = newTags_2.return)) _b.call(newTags_2);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
                return true;
            }
        }
        return false;
        var e_1, _a, e_2, _b;
    };
    /**
     * If no tag is selected, select the rightmost tag. If a tag is selected, remove it.
     */
    /**
     * If no tag is selected, select the rightmost tag. If a tag is selected, remove it.
     * @return {?}
     */
    TagInputComponent.prototype.backspace = /**
     * If no tag is selected, select the rightmost tag. If a tag is selected, remove it.
     * @return {?}
     */
    function () {
        if (this.disabled) {
            return;
        }
        if (!this.isValidTagIndex(this.selectedIndex)) {
            this.selectTagAt(this.tags.length - 1);
        }
        else {
            this.removeTagAt(this.selectedIndex);
        }
    };
    /**
     * Move the highlighted option forwards or backwards in the list. Wraps at the limits.
     * @param d Value to be added to the selected index, i.e. -1 to move backwards, +1 to move forwards.
     */
    /**
     * Move the highlighted option forwards or backwards in the list. Wraps at the limits.
     * @param {?} d Value to be added to the selected index, i.e. -1 to move backwards, +1 to move forwards.
     * @return {?}
     */
    TagInputComponent.prototype.moveSelection = /**
     * Move the highlighted option forwards or backwards in the list. Wraps at the limits.
     * @param {?} d Value to be added to the selected index, i.e. -1 to move backwards, +1 to move forwards.
     * @return {?}
     */
    function (d) {
        if (this.disabled) {
            return;
        }
        if (this.isValidSelectIndex(this.selectedIndex)) {
            this.selectedIndex += d;
            // Do wrapping of selection when out of bounds
            if (this.selectedIndex < 0) {
                this.selectedIndex = this.tags.length;
            }
            else if (this.selectedIndex > this.tags.length) {
                this.selectedIndex = 0;
            }
        }
    };
    /**
     * Returns a value to display for the given tag. Uses display function/property name if set, otherwise assumes that the tag is a simple string.
     */
    /**
     * Returns a value to display for the given tag. Uses display function/property name if set, otherwise assumes that the tag is a simple string.
     * @param {?} tag
     * @return {?}
     */
    TagInputComponent.prototype.getTagDisplay = /**
     * Returns a value to display for the given tag. Uses display function/property name if set, otherwise assumes that the tag is a simple string.
     * @param {?} tag
     * @return {?}
     */
    function (tag) {
        if (typeof this.display === 'function') {
            return this.display(tag);
        }
        if (typeof this.display === 'string') {
            return tag[/** @type {?} */ (this.display)];
        }
        return tag;
    };
    /**
     * Returns true if the given index is selected (tag index or input field).
     */
    /**
     * Returns true if the given index is selected (tag index or input field).
     * @param {?} index
     * @return {?}
     */
    TagInputComponent.prototype.isSelected = /**
     * Returns true if the given index is selected (tag index or input field).
     * @param {?} index
     * @return {?}
     */
    function (index) {
        return index === this.selectedIndex;
    };
    /**
     * Select the tag at the given index. Does nothing if disabled is true.
     */
    /**
     * Select the tag at the given index. Does nothing if disabled is true.
     * @param {?} tagIndex
     * @return {?}
     */
    TagInputComponent.prototype.selectTagAt = /**
     * Select the tag at the given index. Does nothing if disabled is true.
     * @param {?} tagIndex
     * @return {?}
     */
    function (tagIndex) {
        if (this.disabled) {
            return;
        }
        if (this.isValidTagIndex(tagIndex)) {
            this.selectedIndex = tagIndex;
        }
    };
    /**
     * Select the input field, giving it focus. Does nothing if disabled is true.
     */
    /**
     * Select the input field, giving it focus. Does nothing if disabled is true.
     * @return {?}
     */
    TagInputComponent.prototype.selectInput = /**
     * Select the input field, giving it focus. Does nothing if disabled is true.
     * @return {?}
     */
    function () {
        if (this.disabled) {
            return;
        }
        this.selectedIndex = this.tags.length;
    };
    /**
     * Remove the tag at the given index. Does nothing if disabled is true or the minTags property prevents removal.
     */
    /**
     * Remove the tag at the given index. Does nothing if disabled is true or the minTags property prevents removal.
     * @param {?} tagIndex
     * @return {?}
     */
    TagInputComponent.prototype.removeTagAt = /**
     * Remove the tag at the given index. Does nothing if disabled is true or the minTags property prevents removal.
     * @param {?} tagIndex
     * @return {?}
     */
    function (tagIndex) {
        if (this.disabled || !this.canRemoveTagAt(tagIndex)) {
            return;
        }
        // Check that the tagIndex is in range
        if (this.isValidTagIndex(tagIndex)) {
            var /** @type {?} */ tag = this.tags[tagIndex];
            var /** @type {?} */ tagRemovingEvent = new TagInputEvent(tag);
            this.tagRemoving.emit(tagRemovingEvent);
            if (!tagRemovingEvent.defaultPrevented()) {
                // Select input first to avoid issues with dropping focus
                this.selectInput();
                // Remove the tag
                this.tags.splice(tagIndex, 1);
                // Set focus again since indices have changed
                this.selectInput();
                this.tagRemoved.emit(new TagInputEvent(tag));
                this.validate();
            }
        }
    };
    /**
     * Returns true if the tag at the given index can be removed.
     */
    /**
     * Returns true if the tag at the given index can be removed.
     * @param {?} tagIndex
     * @return {?}
     */
    TagInputComponent.prototype.canRemoveTagAt = /**
     * Returns true if the tag at the given index can be removed.
     * @param {?} tagIndex
     * @return {?}
     */
    function (tagIndex) {
        return this.tags.length > this.minTags || !this.enforceTagLimits;
    };
    /**
     * Returns true if the input field should be available.
     */
    /**
     * Returns true if the input field should be available.
     * @return {?}
     */
    TagInputComponent.prototype.isInputVisible = /**
     * Returns true if the input field should be available.
     * @return {?}
     */
    function () {
        return this.tags.length < this.maxTags || !this.enforceTagLimits;
    };
    /**
     * Returns true if any part of the control has focus.
     */
    /**
     * Returns true if any part of the control has focus.
     * @return {?}
     */
    TagInputComponent.prototype.hasFocus = /**
     * Returns true if any part of the control has focus.
     * @return {?}
     */
    function () {
        return this.isValidSelectIndex(this.selectedIndex);
    };
    /**
     * @param {?} typeahead
     * @return {?}
     */
    TagInputComponent.prototype.connectTypeahead = /**
     * @param {?} typeahead
     * @return {?}
     */
    function (typeahead) {
        var _this = this;
        if (this._typeaheadSubscription) {
            this._typeaheadSubscription.unsubscribe();
            this._typeaheadSubscription = null;
        }
        this.typeahead = typeahead;
        if (this.typeahead) {
            // Set up event handler for selected options
            this._typeaheadSubscription = this.typeahead.optionSelected.subscribe(this.typeaheadOptionSelectedHandler.bind(this));
            // Set up event handler for the highlighted element
            // Added a delay to move it out of the current change detection cycle
            this._typeaheadSubscription.add(this.typeahead.highlightedElementChange.pipe(delay$1(0)).subscribe(function (element) {
                _this.highlightedElement = element;
            }));
        }
    };
    /**
     * Validate the given tagValue with the tagPattern, if set. Update validationErrors on validation failure.
     * @param {?} tagValue
     * @return {?}
     */
    TagInputComponent.prototype.validateTag = /**
     * Validate the given tagValue with the tagPattern, if set. Update validationErrors on validation failure.
     * @param {?} tagValue
     * @return {?}
     */
    function (tagValue) {
        var /** @type {?} */ inputPattern = null;
        this.inputValid = true;
        if (this.tagPattern && !this.tagPattern.test(tagValue)) {
            inputPattern = {
                given: tagValue,
                pattern: this.tagPattern
            };
            this.inputValid = false;
        }
        this.validationErrors['inputPattern'] = inputPattern;
        return this.inputValid;
    };
    /**
     * Create a tag object for the given tagValue. If createTagHandler is specified, use it; otherwise if displayProperty is specified, create an object with the tagValue as the single named property; otherwise return the tagValue itself.
     * @param {?} tagValue
     * @return {?}
     */
    TagInputComponent.prototype.createTag = /**
     * Create a tag object for the given tagValue. If createTagHandler is specified, use it; otherwise if displayProperty is specified, create an object with the tagValue as the single named property; otherwise return the tagValue itself.
     * @param {?} tagValue
     * @return {?}
     */
    function (tagValue) {
        var /** @type {?} */ tag = null;
        if (this.createTagHandler && typeof this.createTagHandler === 'function') {
            tag = this.createTagHandler(tagValue);
        }
        else if (typeof this.display === 'string') {
            tag = {};
            tag[/** @type {?} */ (this.display)] = tagValue;
        }
        else {
            tag = tagValue;
        }
        return tag;
    };
    /**
     * Add a tag object, calling the tagAdding and tagAdded events. Returns true if the tag was added to the tags array.
     * @param {?} tag
     * @return {?}
     */
    TagInputComponent.prototype.addTag = /**
     * Add a tag object, calling the tagAdding and tagAdded events. Returns true if the tag was added to the tags array.
     * @param {?} tag
     * @return {?}
     */
    function (tag) {
        if (tag) {
            // Verify that the new tag can be displayed
            var /** @type {?} */ displayValue = this.getTagDisplay(tag);
            if (displayValue && typeof displayValue === 'string' && displayValue.length > 0) {
                var /** @type {?} */ tagAddingEvent = new TagInputEvent(tag);
                this.tagAdding.emit(tagAddingEvent);
                if (!tagAddingEvent.defaultPrevented()) {
                    this.tags = this.tags || [];
                    this.tags.push(tag);
                    this.tagAdded.emit(new TagInputEvent(tag));
                    this.validate();
                    return true;
                }
            }
        }
        return false;
    };
    /**
     * Returns true if the given tagIndex is a valid tag index.
     * @param {?} tagIndex
     * @return {?}
     */
    TagInputComponent.prototype.isValidTagIndex = /**
     * Returns true if the given tagIndex is a valid tag index.
     * @param {?} tagIndex
     * @return {?}
     */
    function (tagIndex) {
        return tagIndex >= 0 && tagIndex < this.tags.length;
    };
    /**
     * Returns true if the given index is a valid selection index (tags or input field).
     * @param {?} index
     * @return {?}
     */
    TagInputComponent.prototype.isValidSelectIndex = /**
     * Returns true if the given index is a valid selection index (tags or input field).
     * @param {?} index
     * @return {?}
     */
    function (index) {
        return index >= 0 && index <= this.tags.length;
    };
    /**
     * Returns the character corresponding to the given key event, mainly for IE compatibility.
     * @param {?} event
     * @return {?}
     */
    TagInputComponent.prototype.getKeyChar = /**
     * Returns the character corresponding to the given key event, mainly for IE compatibility.
     * @param {?} event
     * @return {?}
     */
    function (event) {
        switch (event.key) {
            case 'Spacebar':
                return ' ';
        }
        return event.key;
    };
    /**
     * Returns an array of strings corresponding to the input string split by the tagDelimiters characters.
     * @param {?} input
     * @return {?}
     */
    TagInputComponent.prototype.splitTagInput = /**
     * Returns an array of strings corresponding to the input string split by the tagDelimiters characters.
     * @param {?} input
     * @return {?}
     */
    function (input) {
        var /** @type {?} */ tagValues = [input];
        if (this.tagDelimiters && typeof this.tagDelimiters === 'string') {
            var /** @type {?} */ escapedDelimiters = this.tagDelimiters.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
            var /** @type {?} */ delimiterRegex = new RegExp("[" + escapedDelimiters + "]", 'g');
            tagValues = input.split(delimiterRegex).filter(function (s) { return s.length > 0; });
        }
        return tagValues;
    };
    TagInputComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-tag-input',
                    template: "<ol [attr.role]=\"typeahead ? 'combobox' : 'none'\" [attr.aria-haspopup]=\"typeahead ? 'listbox' : null\">\n    <li *ngFor=\"let tag of tags; let i = index\" class=\"ux-tag\"\n        [class.disabled]=\"disabled\"\n        [ngClass]=\"tagClass(tag, i, isSelected(i))\"\n        [attr.tabindex]=\"disabled ? null : 0\"\n        [focusIf]=\"isSelected(i)\"\n        (click)=\"tagClickHandler($event, tag, i)\"\n        (focus)=\"selectTagAt(i)\">\n\n        <ng-container [ngTemplateOutlet]=\"tagTemplate\"\n            [ngTemplateOutletContext]=\"{tag: tag, index: i, disabled: disabled, api: tagApi}\">\n        </ng-container>\n\n    </li>\n    <li *ngIf=\"isInputVisible()\" class=\"ux-tag-input\" role=\"none\">\n        <input #tagInput type=\"text\" [attr.id]=\"id\" class=\"ux-tag-input\"\n            [(ngModel)]=\"input\"\n            [class.invalid]=\"!inputValid\"\n            [attr.aria-activedescendant]=\"highlightedElement?.id\"\n            [attr.aria-autocomplete]=\"typeahead ? 'list' : 'none'\"\n            [attr.aria-controls]=\"typeahead?.id\"\n            aria-multiline=\"false\"\n            [placeholder]=\"disabled ? '' : (placeholder || '')\"\n            [disabled]=\"disabled\"\n            [focusIf]=\"isSelected(tags.length)\"\n            (click)=\"inputClickHandler()\"\n            (focus)=\"inputFocusHandler()\"\n            (paste)=\"inputPasteHandler($event)\">\n    </li>\n</ol>\n\n<ng-content #typeahead></ng-content>\n\n<ng-template #defaultTagTemplate let-tag=\"tag\" let-index=\"index\" let-disabled=\"disabled\" let-api=\"api\">\n    <span class=\"ux-tag-text\">{{api.getTagDisplay(tag)}}</span>\n    <button *ngIf=\"api.canRemoveTagAt(index)\"\n        type=\"button\"\n        class=\"ux-tag-remove\"\n        aria-label=\"Remove Item\"\n        [disabled]=\"disabled\"\n        (click)=\"api.removeTagAt(index); $event.stopPropagation();\">\n        <span class=\"hpe-icon hpe-close\"></span>\n    </button>\n</ng-template>",
                    providers: [TAGINPUT_VALUE_ACCESSOR, TAGINPUT_VALIDATOR],
                    host: {
                        '[class.disabled]': 'disabled',
                        '[class.focus]': 'hasFocus()',
                        '[class.invalid]': '!valid || !inputValid'
                    }
                },] },
    ];
    /** @nocollapse */
    TagInputComponent.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] },] },
        { type: TypeaheadKeyService, },
    ]; };
    TagInputComponent.propDecorators = {
        "id": [{ type: Input }, { type: HostBinding, args: ['attr.id',] },],
        "tags": [{ type: Input, args: ['tags',] },],
        "tagsChange": [{ type: Output },],
        "input": [{ type: Input, args: ['input',] },],
        "inputChange": [{ type: Output },],
        "display": [{ type: Input },],
        "addOnPaste": [{ type: Input },],
        "disabled": [{ type: Input },],
        "enforceTagLimits": [{ type: Input },],
        "freeInput": [{ type: Input },],
        "maxTags": [{ type: Input },],
        "minTags": [{ type: Input },],
        "placeholder": [{ type: Input },],
        "showTypeaheadOnClick": [{ type: Input },],
        "tagDelimiters": [{ type: Input },],
        "tagPattern": [{ type: Input },],
        "tagTemplate": [{ type: Input },],
        "tagClass": [{ type: Input },],
        "validationErrors": [{ type: Input },],
        "createTagHandler": [{ type: Input, args: ['createTag',] },],
        "tagAdding": [{ type: Output },],
        "tagAdded": [{ type: Output },],
        "tagInvalidated": [{ type: Output },],
        "tagRemoving": [{ type: Output },],
        "tagRemoved": [{ type: Output },],
        "tagClick": [{ type: Output },],
        "typeaheadQuery": [{ type: ContentChildren, args: [TypeaheadComponent,] },],
        "tagInput": [{ type: ViewChild, args: ['tagInput',] },],
        "_defaultTagTemplate": [{ type: ViewChild, args: ['defaultTagTemplate',] },],
        "keyHandler": [{ type: HostListener, args: ['keydown', ['$event'],] },],
        "focusOutHandler": [{ type: HostListener, args: ['focusout', ['$event'],] },],
    };
    return TagInputComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var TagInputModule = (function () {
    function TagInputModule() {
    }
    TagInputModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        FormsModule,
                        FocusIfModule,
                        TypeaheadModule$1
                    ],
                    exports: [TagInputComponent],
                    declarations: [TagInputComponent],
                    providers: [],
                },] },
    ];
    /** @nocollapse */
    TagInputModule.ctorParameters = function () { return []; };
    return TagInputModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var SelectModule = (function () {
    function SelectModule() {
    }
    SelectModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        FormsModule,
                        InfiniteScrollModule,
                        TagInputModule,
                        TypeaheadModule$1
                    ],
                    exports: [SelectComponent],
                    declarations: [SelectComponent]
                },] },
    ];
    /** @nocollapse */
    SelectModule.ctorParameters = function () { return []; };
    return SelectModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var SearchBuilderModule = (function () {
    function SearchBuilderModule() {
    }
    SearchBuilderModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        FormsModule,
                        DateTimePickerModule,
                        PopoverModule,
                        SelectModule
                    ],
                    exports: [
                        SearchBuilderComponent,
                        SearchBuilderGroupComponent,
                        BaseSearchComponent
                    ],
                    declarations: [
                        SearchBuilderComponent,
                        SearchBuilderGroupComponent,
                        SearchTextComponent,
                        SearchDateComponent,
                        SearchDateRangeComponent,
                        SearchBuilderOutletDirective,
                        SearchSelectComponent,
                        BaseSearchComponent
                    ],
                    entryComponents: [
                        SearchTextComponent,
                        SearchDateComponent,
                        SearchDateRangeComponent,
                        SearchSelectComponent
                    ]
                },] },
    ];
    /** @nocollapse */
    SearchBuilderModule.ctorParameters = function () { return []; };
    return SearchBuilderModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var SidePanelCloseDirective = (function () {
    function SidePanelCloseDirective(_service) {
        this._service = _service;
    }
    /**
     * @return {?}
     */
    SidePanelCloseDirective.prototype.clickHandler = /**
     * @return {?}
     */
    function () {
        this._service.close();
    };
    SidePanelCloseDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[uxSidePanelClose]'
                },] },
    ];
    /** @nocollapse */
    SidePanelCloseDirective.ctorParameters = function () { return [
        { type: SidePanelService, },
    ]; };
    SidePanelCloseDirective.propDecorators = {
        "clickHandler": [{ type: HostListener, args: ['click',] },],
    };
    return SidePanelCloseDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var /** @type {?} */ EXPORTS$1 = [
    SidePanelComponent,
    SidePanelCloseDirective
];
var SidePanelModule = (function () {
    function SidePanelModule() {
    }
    SidePanelModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule
                    ],
                    exports: EXPORTS$1,
                    declarations: EXPORTS$1
                },] },
    ];
    /** @nocollapse */
    SidePanelModule.ctorParameters = function () { return []; };
    return SidePanelModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var SliderComponent = (function () {
    function SliderComponent(colorService, _changeDetectorRef) {
        this._changeDetectorRef = _changeDetectorRef;
        this.value = 0;
        this.valueChange = new EventEmitter();
        // expose enums to Angular view
        this.sliderType = SliderType;
        this.sliderStyle = SliderStyle;
        this.sliderSize = SliderSize;
        this.sliderSnap = SliderSnap;
        this.sliderThumb = SliderThumb;
        this.sliderTickType = SliderTickType;
        this.sliderThumbEvent = SliderThumbEvent;
        this.sliderCalloutTrigger = SliderCalloutTrigger;
        this.tracks = {
            lower: {
                size: 0,
                color: ''
            },
            middle: {
                size: 0,
                color: ''
            },
            upper: {
                size: 0,
                color: ''
            }
        };
        this.tooltips = {
            lower: {
                visible: false,
                position: 0,
                label: ''
            },
            upper: {
                visible: false,
                position: 0,
                label: ''
            }
        };
        this.thumbs = {
            lower: {
                hover: false,
                drag: false,
                position: 0,
                order: 100,
                value: /** @type {?} */ (null)
            },
            upper: {
                hover: false,
                drag: false,
                position: 0,
                order: 101,
                value: /** @type {?} */ (null)
            }
        };
        // store all the ticks to display
        this.ticks = [];
        // setup default options
        this.defaultOptions = {
            type: SliderType.Value,
            handles: {
                style: SliderStyle.Button,
                callout: {
                    trigger: SliderCalloutTrigger.None,
                    background: colorService.getColor('grey2').toHex(),
                    color: '#fff',
                    formatter: function (value) { return value; }
                },
                keyboard: {
                    major: 5,
                    minor: 1
                },
                aria: {
                    thumb: 'Slider value',
                    lowerThumb: 'Slider lower value',
                    upperThumb: 'Slider upper value'
                }
            },
            track: {
                height: SliderSize.Wide,
                min: 0,
                max: 100,
                ticks: {
                    snap: SliderSnap.None,
                    major: {
                        show: true,
                        steps: 10,
                        labels: true,
                        formatter: function (value) { return value; }
                    },
                    minor: {
                        show: true,
                        steps: 5,
                        labels: false,
                        formatter: function (value) { return value; }
                    }
                },
                colors: {
                    lower: colorService.getColor('grey6').toHex(),
                    range: colorService.getColor('accent').setAlpha(0.75).toRgba(),
                    higher: colorService.getColor('grey6').toHex()
                }
            }
        };
    }
    /**
     * @return {?}
     */
    SliderComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.updateOptions();
        this.updateValues();
        this.setThumbState(SliderThumb.Lower, false, false);
        this.setThumbState(SliderThumb.Upper, false, false);
        // emit the initial value
        this.valueChange.next(this.clone(this.value));
    };
    /**
     * @return {?}
     */
    SliderComponent.prototype.ngDoCheck = /**
     * @return {?}
     */
    function () {
        if (this.detectValueChange(this.value, this._value)) {
            this.updateValues();
            this._value = this.clone(this.value);
        }
    };
    /**
     * @return {?}
     */
    SliderComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // persistent tooltips will need positioned correctly at this stage
        setTimeout(function () {
            _this.updateTooltipPosition(SliderThumb.Lower);
            _this.updateTooltipPosition(SliderThumb.Upper);
            // mark as dirty
            // mark as dirty
            _this._changeDetectorRef.markForCheck();
        });
    };
    /**
     * @param {?} thumb
     * @param {?} snapTarget
     * @param {?} forwards
     * @return {?}
     */
    SliderComponent.prototype.snapToNearestTick = /**
     * @param {?} thumb
     * @param {?} snapTarget
     * @param {?} forwards
     * @return {?}
     */
    function (thumb, snapTarget, forwards) {
        // get the value for the thumb
        var value = this.getThumbState(thumb).value;
        // get the closest ticks - remove any tick if we are currently on it
        var /** @type {?} */ closest = this.getTickDistances(value, thumb, snapTarget)
            .filter(function (tick) { return tick.value !== value; })
            .find(function (tick) { return forwards ? tick.value > value : tick.value < value; });
        // If we have no ticks then move by a predefined amount
        if (closest) {
            return this.setThumbValue(thumb, this.validateValue(thumb, closest.value));
        }
        var /** @type {?} */ step = snapTarget === SliderSnap.Major ? this.options.handles.keyboard.major : this.options.handles.keyboard.minor;
        this.setThumbValue(thumb, this.validateValue(thumb, value + (forwards ? step : -step)));
    };
    /**
     * @param {?} thumb
     * @param {?} forwards
     * @return {?}
     */
    SliderComponent.prototype.snapToEnd = /**
     * @param {?} thumb
     * @param {?} forwards
     * @return {?}
     */
    function (thumb, forwards) {
        this.setThumbValue(thumb, this.validateValue(thumb, forwards ? this.options.track.max : this.options.track.min));
    };
    /**
     * @param {?} thumb
     * @return {?}
     */
    SliderComponent.prototype.getThumbValue = /**
     * @param {?} thumb
     * @return {?}
     */
    function (thumb) {
        return this.getThumbState(thumb).value;
    };
    /**
     * @param {?} thumb
     * @return {?}
     */
    SliderComponent.prototype.getFormattedValue = /**
     * @param {?} thumb
     * @return {?}
     */
    function (thumb) {
        return this.options.handles.callout.formatter(this.getThumbState(thumb).value);
    };
    /**
     * @param {?} thumb
     * @return {?}
     */
    SliderComponent.prototype.getThumbState = /**
     * @param {?} thumb
     * @return {?}
     */
    function (thumb) {
        return thumb === SliderThumb.Lower ? this.thumbs.lower : this.thumbs.upper;
    };
    /**
     * @param {?} thumb
     * @param {?} hover
     * @param {?} drag
     * @return {?}
     */
    SliderComponent.prototype.setThumbState = /**
     * @param {?} thumb
     * @param {?} hover
     * @param {?} drag
     * @return {?}
     */
    function (thumb, hover, drag) {
        if (thumb === SliderThumb.Lower) {
            this.thumbs.lower.hover = hover;
            this.thumbs.lower.drag = drag;
        }
        else {
            this.thumbs.upper.hover = hover;
            this.thumbs.upper.drag = drag;
        }
        // update the visibility of the tooltips
        this.updateTooltips(thumb);
    };
    /**
     * @param {?} thumb
     * @param {?} event
     * @return {?}
     */
    SliderComponent.prototype.thumbEvent = /**
     * @param {?} thumb
     * @param {?} event
     * @return {?}
     */
    function (thumb, event) {
        // get the current thumb state
        var /** @type {?} */ state$$1 = this.getThumbState(thumb);
        // update based upon event
        switch (event) {
            case SliderThumbEvent.DragStart:
                state$$1.drag = true;
                break;
            case SliderThumbEvent.DragEnd:
                state$$1.drag = false;
                break;
            case SliderThumbEvent.MouseOver:
                state$$1.hover = true;
                break;
            case SliderThumbEvent.MouseLeave:
                state$$1.hover = false;
                break;
            case SliderThumbEvent.None:
                state$$1.drag = false;
                state$$1.hover = false;
                break;
        }
        // update the thumb state
        this.setThumbState(thumb, state$$1.hover, state$$1.drag);
    };
    /**
     * @param {?} thumb
     * @return {?}
     */
    SliderComponent.prototype.getAriaValueText = /**
     * @param {?} thumb
     * @return {?}
     */
    function (thumb) {
        // get the current thumb value
        var /** @type {?} */ value = this.getThumbValue(thumb);
        // get all the ticks
        var /** @type {?} */ tick = this.ticks.find(function (_tick) { return _tick.value === value; });
        if (tick && tick.label) {
            return tick.label;
        }
        // otherwise simply display the formatted value
        return this.getFormattedValue(thumb);
    };
    /**
     * @param {?} thumb
     * @return {?}
     */
    SliderComponent.prototype.updateTooltips = /**
     * @param {?} thumb
     * @return {?}
     */
    function (thumb) {
        var /** @type {?} */ visible = false;
        var /** @type {?} */ state$$1 = this.getThumbState(thumb);
        switch (this.options.handles.callout.trigger) {
            case SliderCalloutTrigger.Persistent:
                visible = true;
                break;
            case SliderCalloutTrigger.Drag:
                visible = state$$1.drag;
                break;
            case SliderCalloutTrigger.Hover:
                visible = state$$1.hover || state$$1.drag;
                break;
            case SliderCalloutTrigger.Dynamic:
                visible = true;
                break;
        }
        // update the state for the corresponding thumb
        this.getTooltip(thumb).visible = visible;
        // update the tooltip text
        this.updateTooltipText(thumb);
        // update the tooltip positions
        this.updateTooltipPosition(thumb);
    };
    /**
     * @param {?} thumb
     * @return {?}
     */
    SliderComponent.prototype.updateTooltipText = /**
     * @param {?} thumb
     * @return {?}
     */
    function (thumb) {
        // get the thumb value
        var /** @type {?} */ state$$1 = this.getThumbState(thumb);
        var /** @type {?} */ tooltip = this.getTooltip(thumb);
        // store the formatted label
        tooltip.label = this.getFormattedValue(thumb).toString();
    };
    /**
     * @param {?} thumb
     * @return {?}
     */
    SliderComponent.prototype.getTooltipElement = /**
     * @param {?} thumb
     * @return {?}
     */
    function (thumb) {
        return thumb === SliderThumb.Lower ? this.lowerTooltip : this.upperTooltip;
    };
    /**
     * @param {?} thumb
     * @return {?}
     */
    SliderComponent.prototype.getTooltip = /**
     * @param {?} thumb
     * @return {?}
     */
    function (thumb) {
        return thumb === SliderThumb.Lower ? this.tooltips.lower : this.tooltips.upper;
    };
    /**
     * @param {?} thumb
     * @return {?}
     */
    SliderComponent.prototype.updateTooltipPosition = /**
     * @param {?} thumb
     * @return {?}
     */
    function (thumb) {
        var /** @type {?} */ tooltip = this.getTooltip(thumb);
        // if tooltip is not visible then stop here
        if (tooltip.visible === false) {
            return;
        }
        var /** @type {?} */ tooltipElement = this.getTooltipElement(thumb);
        // get the element widths
        var /** @type {?} */ thumbWidth;
        if (this.options.handles.style === SliderStyle.Button) {
            thumbWidth = this.options.track.height === SliderSize.Narrow ? 16 : 24;
        }
        else {
            thumbWidth = 2;
        }
        var /** @type {?} */ tooltipWidth = tooltipElement.nativeElement.offsetWidth;
        // calculate the tooltips new position
        var /** @type {?} */ tooltipPosition = Math.ceil((tooltipWidth - thumbWidth) / 2);
        // update tooltip position
        tooltip.position = -tooltipPosition;
        if (this.options.type === SliderType.Range && this.options.handles.callout.trigger === SliderCalloutTrigger.Dynamic) {
            this.preventTooltipOverlap(tooltip);
        }
    };
    /**
     * @param {?} tooltip
     * @return {?}
     */
    SliderComponent.prototype.preventTooltipOverlap = /**
     * @param {?} tooltip
     * @return {?}
     */
    function (tooltip) {
        var /** @type {?} */ trackWidth = this.track.nativeElement.offsetWidth;
        var /** @type {?} */ lower = (trackWidth / 100) * this.thumbs.lower.position;
        var /** @type {?} */ upper = (trackWidth / 100) * this.thumbs.upper.position;
        var /** @type {?} */ lowerWidth = this.lowerTooltip.nativeElement.offsetWidth / 2;
        var /** @type {?} */ upperWidth = this.upperTooltip.nativeElement.offsetWidth / 2;
        var /** @type {?} */ diff = (lower + lowerWidth) - (upper - upperWidth);
        // if the tooltips are closer than 16px then adjust so the dont move any close
        if (diff > 0) {
            if (tooltip === this.tooltips.lower && this.thumbs.lower.drag === false) {
                tooltip.position -= (diff / 2);
            }
            else if (tooltip === this.tooltips.upper && this.thumbs.upper.drag === false) {
                tooltip.position += (diff / 2);
            }
        }
    };
    /**
     * @param {?} value
     * @param {?} min
     * @param {?} max
     * @return {?}
     */
    SliderComponent.prototype.clamp = /**
     * @param {?} value
     * @param {?} min
     * @param {?} max
     * @return {?}
     */
    function (value, min, max) {
        return Math.min(Math.max(value, min), max);
    };
    /**
     * @param {?} event
     * @param {?} thumb
     * @return {?}
     */
    SliderComponent.prototype.updateThumbPosition = /**
     * @param {?} event
     * @param {?} thumb
     * @return {?}
     */
    function (event, thumb) {
        // get event position - either mouse or touch
        var /** @type {?} */ eventPosition = event instanceof MouseEvent ? event.clientX : event.touches && event.touches.length > 0 ? event.touches[0].clientX : null;
        // if event position is null do nothing
        if (eventPosition === null) {
            return;
        }
        // get mouse position
        var /** @type {?} */ mouseX = window.pageXOffset + eventPosition;
        // get track size and position
        var /** @type {?} */ trackBounds = this.track.nativeElement.getBoundingClientRect();
        // restrict the value within the range size
        var /** @type {?} */ position = this.clamp(mouseX - trackBounds.left, 0, trackBounds.width);
        // get fraction representation of location within the track
        var /** @type {?} */ fraction = (position / trackBounds.width);
        // convert to value within the range
        var /** @type {?} */ value = ((this.options.track.max - this.options.track.min) * fraction) + this.options.track.min;
        // ensure value is valid
        value = this.validateValue(thumb, value);
        // snap to a tick if required
        value = this.snapToTick(value, thumb);
        // update the value accordingly
        this.setThumbValue(thumb, value);
        this.updateOrder(thumb);
        this.updateValues();
        // update tooltip text & position
        this.updateTooltipText(thumb);
        // update the position of all visible tooltips
        this.updateTooltipPosition(SliderThumb.Lower);
        this.updateTooltipPosition(SliderThumb.Upper);
        // mark as dirty for change detection
        this._changeDetectorRef.markForCheck();
    };
    /**
     * @param {?} thumb
     * @return {?}
     */
    SliderComponent.prototype.updateOrder = /**
     * @param {?} thumb
     * @return {?}
     */
    function (thumb) {
        var /** @type {?} */ lower = thumb === SliderThumb.Lower ? 101 : 100;
        var /** @type {?} */ upper = thumb === SliderThumb.Lower ? 100 : 101;
        // The most recently used thumb should be above
        this.thumbs.lower.order = lower;
        this.thumbs.upper.order = upper;
    };
    /**
     * @param {?} value
     * @param {?} thumb
     * @param {?} snapTarget
     * @return {?}
     */
    SliderComponent.prototype.getTickDistances = /**
     * @param {?} value
     * @param {?} thumb
     * @param {?} snapTarget
     * @return {?}
     */
    function (value, thumb, snapTarget) {
        // if snap target is none then return original value
        if (snapTarget === SliderSnap.None) {
            return [];
        }
        // get filtered ticks
        var /** @type {?} */ ticks;
        switch (snapTarget) {
            case SliderSnap.Minor:
                ticks = this.ticks.filter(function (tick) { return tick.type === SliderTickType.Minor; });
                break;
            case SliderSnap.Major:
                ticks = this.ticks.filter(function (tick) { return tick.type === SliderTickType.Major; });
                break;
            default:
                ticks = this.ticks.slice(0);
        }
        // get the track limit
        var /** @type {?} */ lowerLimit = this.options.track.min;
        var /** @type {?} */ upperLimit = this.options.track.max;
        if (this.options.type === SliderType.Range && thumb === SliderThumb.Lower) {
            upperLimit = this.thumbs.upper.value;
        }
        if (this.options.type === SliderType.Range && thumb === SliderThumb.Upper) {
            lowerLimit = this.thumbs.lower.value;
        }
        // Find the closest tick to the current position
        var /** @type {?} */ range = ticks.filter(function (tick) { return tick.value >= lowerLimit && tick.value <= upperLimit; });
        // If there are no close ticks in the valid range then dont snap
        if (range.length === 0) {
            return [];
        }
        return range.sort(function (tickOne, tickTwo) {
            var /** @type {?} */ tickOneDelta = Math.max(tickOne.value, value) - Math.min(tickOne.value, value);
            var /** @type {?} */ tickTwoDelta = Math.max(tickTwo.value, value) - Math.min(tickTwo.value, value);
            return tickOneDelta - tickTwoDelta;
        });
    };
    /**
     * @param {?} value
     * @param {?} thumb
     * @return {?}
     */
    SliderComponent.prototype.snapToTick = /**
     * @param {?} value
     * @param {?} thumb
     * @return {?}
     */
    function (value, thumb) {
        var /** @type {?} */ tickDistances = this.getTickDistances(value, thumb, this.options.track.ticks.snap);
        // if there are no ticks return the current value
        if (tickDistances.length === 0) {
            return value;
        }
        // get the closest tick
        return tickDistances[0].value;
    };
    /**
     * @param {?} thumb
     * @param {?} value
     * @return {?}
     */
    SliderComponent.prototype.validateValue = /**
     * @param {?} thumb
     * @param {?} value
     * @return {?}
     */
    function (thumb, value) {
        // if slider is not a range value is always valid providing it is within the chart min and max values
        if (this.options.type === SliderType.Value) {
            return Math.max(Math.min(value, this.options.track.max), this.options.track.min);
        }
        // check if value is with chart ranges
        if (value > this.options.track.max) {
            return thumb === SliderThumb.Lower ? Math.min(this.options.track.max, this.thumbs.upper.value) : this.options.track.max;
        }
        if (value < this.options.track.min) {
            return thumb === SliderThumb.Upper ? Math.max(this.options.track.min, this.thumbs.lower.value) : this.options.track.min;
        }
        // otherwise we need to check to make sure lower thumb cannot go above higher and vice versa
        if (thumb === SliderThumb.Lower) {
            if (this.thumbs.upper.value === null) {
                return value;
            }
            return value <= this.thumbs.upper.value ? value : this.thumbs.upper.value;
        }
        if (thumb === SliderThumb.Upper) {
            if (this.thumbs.lower.value === null) {
                return value;
            }
            return value >= this.thumbs.lower.value ? value : this.thumbs.lower.value;
        }
    };
    /**
     * @return {?}
     */
    SliderComponent.prototype.updateOptions = /**
     * @return {?}
     */
    function () {
        // add in the default options that user hasn't specified
        this.options = this.deepMerge(this.options || {}, this.defaultOptions);
        this.updateTrackColors();
        this.updateTicks();
        this.updateValues();
    };
    /**
     * @return {?}
     */
    SliderComponent.prototype.updateValues = /**
     * @return {?}
     */
    function () {
        if (this.value === undefined || this.value === null) {
            this.value = 0;
        }
        var /** @type {?} */ lowerValue = typeof this.value === 'number' ? this.value : this.value.low;
        var /** @type {?} */ upperValue = typeof this.value === 'number' ? this.value : this.value.high;
        // validate values
        lowerValue = this.validateValue(SliderThumb.Lower, Number(lowerValue.toFixed(4)));
        upperValue = this.validateValue(SliderThumb.Upper, Number(upperValue.toFixed(4)));
        // calculate the positions as percentages
        var /** @type {?} */ lowerPosition = (((lowerValue - this.options.track.min) / (this.options.track.max - this.options.track.min)) * 100);
        var /** @type {?} */ upperPosition = (((upperValue - this.options.track.min) / (this.options.track.max - this.options.track.min)) * 100);
        // update thumb positions
        this.thumbs.lower.position = lowerPosition;
        this.thumbs.upper.position = upperPosition;
        // calculate the track sizes
        this.tracks.lower.size = lowerPosition;
        this.tracks.middle.size = upperPosition - lowerPosition;
        this.tracks.upper.size = this.options.type === SliderType.Value ? 100 - lowerPosition : 100 - upperPosition;
        // update the value input
        this.setValue(lowerValue, upperValue);
    };
    /**
     * @param {?} low
     * @param {?=} high
     * @return {?}
     */
    SliderComponent.prototype.setValue = /**
     * @param {?} low
     * @param {?=} high
     * @return {?}
     */
    function (low, high) {
        this.thumbs.lower.value = low;
        this.thumbs.upper.value = high;
        var /** @type {?} */ previousValue = this.clone(this._value);
        this.value = this.options.type === SliderType.Value ? low : { low: low, high: high };
        // call the event emitter if changes occured
        if (this.detectValueChange(this.value, previousValue)) {
            this.valueChange.emit(this.clone(this.value));
            this.updateTooltipText(SliderThumb.Lower);
            this.updateTooltipText(SliderThumb.Upper);
        }
        else {
            this.valueChange.emit(this.clone(this.value));
        }
    };
    /**
     * @param {?} thumb
     * @param {?} value
     * @return {?}
     */
    SliderComponent.prototype.setThumbValue = /**
     * @param {?} thumb
     * @param {?} value
     * @return {?}
     */
    function (thumb, value) {
        // update the thumb value
        this.getThumbState(thumb).value = value;
        // forward these changes to the value
        this.setValue(this.thumbs.lower.value, this.thumbs.upper.value);
    };
    /**
     * @return {?}
     */
    SliderComponent.prototype.updateTicks = /**
     * @return {?}
     */
    function () {
        // get tick options
        var /** @type {?} */ majorOptions = this.options.track.ticks.major;
        var /** @type {?} */ minorOptions = this.options.track.ticks.minor;
        // check if we should show ticks
        if (majorOptions.show === false && minorOptions.show === false) {
            this.ticks = [];
        }
        // create ticks for both major and minor - only get the ones to be shown
        var /** @type {?} */ majorTicks = this.getTicks(majorOptions, SliderTickType.Major).filter(function (tick) { return tick.showTicks; });
        var /** @type {?} */ minorTicks = this.getTicks(minorOptions, SliderTickType.Minor).filter(function (tick) { return tick.showTicks; });
        // remove any minor ticks that are on a major interval
        this.ticks = this.unionTicks(majorTicks, minorTicks);
    };
    /**
     * @return {?}
     */
    SliderComponent.prototype.updateTrackColors = /**
     * @return {?}
     */
    function () {
        // get colors for each part of the track
        var _a = this.options.track.colors, lower = _a.lower, range = _a.range, higher = _a.higher;
        // update the controller value
        this.tracks.lower.color = typeof lower === 'string' ? lower : "linear-gradient(to right, " + lower.join(', ') + ")";
        this.tracks.middle.color = typeof range === 'string' ? range : "linear-gradient(to right, " + range.join(', ') + ")";
        this.tracks.upper.color = typeof higher === 'string' ? higher : "linear-gradient(to right, " + higher.join(', ') + ")";
    };
    /**
     * @param {?} steps
     * @return {?}
     */
    SliderComponent.prototype.getSteps = /**
     * @param {?} steps
     * @return {?}
     */
    function (steps) {
        // if they are already an array just return it
        if (steps instanceof Array) {
            return steps;
        }
        var /** @type {?} */ output = [];
        // otherwise calculate the steps
        for (var /** @type {?} */ idx = this.options.track.min; idx <= this.options.track.max; idx += steps) {
            output.push(idx);
        }
        return output;
    };
    /**
     * @param {?} options
     * @param {?} type
     * @return {?}
     */
    SliderComponent.prototype.getTicks = /**
     * @param {?} options
     * @param {?} type
     * @return {?}
     */
    function (options, type) {
        // create an array to store the ticks and step points
        var /** @type {?} */ steps = this.getSteps(options.steps);
        // get some chart options
        var /** @type {?} */ min = this.options.track.min;
        var /** @type {?} */ max = this.options.track.max;
        // convert each step to a slider tick and remove invalid ticks
        return steps.map(function (step) {
            return {
                showTicks: options.show,
                showLabels: options.labels,
                type: type,
                position: ((step - min) / (max - min)) * 100,
                value: step,
                label: options.formatter(step)
            };
        }).filter(function (tick) { return tick.position >= 0 && tick.position <= 100; });
    };
    /**
     * @param {?} majorTicks
     * @param {?} minorTicks
     * @return {?}
     */
    SliderComponent.prototype.unionTicks = /**
     * @param {?} majorTicks
     * @param {?} minorTicks
     * @return {?}
     */
    function (majorTicks, minorTicks) {
        // get all ticks combined removing any minor ticks with the same value as major ticks
        return majorTicks.concat(minorTicks)
            .filter(function (tick, index, array) { return tick.type === SliderTickType.Major || !array.find(function (tk) { return tk.type === SliderTickType.Major && tk.position === tick.position; }); })
            .sort(function (t1, t2) { return t1.value - t2.value; });
    };
    /**
     * @template T
     * @param {?} destination
     * @param {?} source
     * @return {?}
     */
    SliderComponent.prototype.deepMerge = /**
     * @template T
     * @param {?} destination
     * @param {?} source
     * @return {?}
     */
    function (destination, source) {
        // loop though all of the properties in the source object
        for (var /** @type {?} */ prop in source) {
            // check if the destination object has the property
            if (!destination.hasOwnProperty(prop)) {
                // copy the property across
                destination[prop] = source[prop];
                continue;
            }
            // if the property exists and is not an object then skip
            if (typeof destination[prop] !== 'object') {
                continue;
            }
            // check if property is an array
            if (destination[prop] instanceof Array) {
                continue;
            }
            // if it is an object then perform a recursive check
            destination[prop] = this.deepMerge(destination[prop], source[prop]);
        }
        return destination;
    };
    /**
     * @param {?} value1
     * @param {?} value2
     * @return {?}
     */
    SliderComponent.prototype.detectValueChange = /**
     * @param {?} value1
     * @param {?} value2
     * @return {?}
     */
    function (value1, value2) {
        // compare two slider values
        if (this.isSliderValue(value1) && this.isSliderValue(value2)) {
            // references to the objects in the correct types
            var /** @type {?} */ obj1 = /** @type {?} */ (value1);
            var /** @type {?} */ obj2 = /** @type {?} */ (value2);
            return obj1.low !== obj2.low || obj1.high !== obj2.high;
        }
        // if not a slider value - should be number of nullable type - compare normally
        return value1 !== value2;
    };
    /**
     * Determines whether or not an object conforms to the
     * SliderValue interface.
     * @param {?} value - The object to check - this must be type any
     * @return {?}
     */
    SliderComponent.prototype.isSliderValue = /**
     * Determines whether or not an object conforms to the
     * SliderValue interface.
     * @param {?} value - The object to check - this must be type any
     * @return {?}
     */
    function (value) {
        // check if is an object
        if (typeof value !== 'object') {
            return false;
        }
        // next check if it contains the necessary properties
        return 'low' in value && 'high' in value;
    };
    /**
     * @param {?} value
     * @return {?}
     */
    SliderComponent.prototype.clone = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        // if it is not an object simply return the value
        if (typeof value !== 'object') {
            return value;
        }
        // create a new object from the existing one
        var /** @type {?} */ instance = __assign({}, value);
        // delete remove the value from the old object
        value = undefined;
        // return the new instance of the object
        return instance;
    };
    SliderComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-slider',
                    template: "<div class=\"track\" #track [class.narrow]=\"options.track.height === sliderSize.Narrow\" [class.wide]=\"options.track.height === sliderSize.Wide\" [class.range]=\"options.type === sliderType.Range\">\n\n    <!-- Section Beneath Lower Thumb -->\n    <div class=\"track-section track-lower\" [style.flex-grow]=\"tracks.lower.size\" [style.background]=\"tracks.lower.color\"></div>\n\n    <!-- Lower Thumb Button / Line -->\n    <div class=\"thumb lower\"\n        uxDrag\n        role=\"slider\"\n        tabindex=\"0\"\n        #lowerthumb\n        [attr.aria-label]=\"options.type === sliderType.Range ? options.handles.aria.lowerThumb : options.handles.aria.thumb\"\n        [attr.aria-valuemin]=\"options?.track?.min\"\n        [attr.aria-valuemax]=\"options.type === sliderType.Range ? getThumbValue(sliderThumb.Upper) : options?.track?.max\"\n        [attr.aria-valuenow]=\"getThumbValue(sliderThumb.Lower)\"\n        [attr.aria-valuetext]=\"getAriaValueText(sliderThumb.Lower)\"\n        [style.left.%]=\"thumbs.lower.position\"\n        [class.active]=\"thumbs.lower.drag\"\n        [style.z-index]=\"thumbs.lower.order\"\n        [class.button]=\"options.handles.style === sliderStyle.Button\"\n        [class.line]=\"options.handles.style === sliderStyle.Line\"\n        [class.narrow]=\"options.track.height === sliderSize.Narrow\"\n        [class.wide]=\"options.track.height === sliderSize.Wide\"\n        (dragstart)=\"thumbEvent(sliderThumb.Lower, sliderThumbEvent.DragStart); lowerthumb.focus()\"\n        (drag)=\"updateThumbPosition($event, sliderThumb.Lower)\"\n        (dragend)=\"thumbEvent(sliderThumb.Lower, sliderThumbEvent.DragEnd)\"\n        (mouseenter)=\"thumbEvent(sliderThumb.Lower, sliderThumbEvent.MouseOver)\"\n        (mouseleave)=\"thumbEvent(sliderThumb.Lower, sliderThumbEvent.MouseLeave)\"\n        (focus)=\"thumbEvent(sliderThumb.Lower, sliderThumbEvent.MouseOver)\"\n        (blur)=\"thumbEvent(sliderThumb.Lower, sliderThumbEvent.MouseLeave)\"\n        (keydown.ArrowLeft)=\"snapToNearestTick(sliderThumb.Lower, sliderSnap.All, false); $event.preventDefault()\"\n        (keydown.ArrowRight)=\"snapToNearestTick(sliderThumb.Lower, sliderSnap.All, true); $event.preventDefault()\"\n        (keydown.ArrowUp)=\"snapToNearestTick(sliderThumb.Lower, sliderSnap.All, false); $event.preventDefault()\"\n        (keydown.ArrowDown)=\"snapToNearestTick(sliderThumb.Lower, sliderSnap.All, true); $event.preventDefault()\"\n        (keydown.PageDown)=\"snapToNearestTick(sliderThumb.Lower, sliderSnap.Major, false); $event.preventDefault()\"\n        (keydown.PageUp)=\"snapToNearestTick(sliderThumb.Lower, sliderSnap.Major, true); $event.preventDefault()\"\n        (keydown.Home)=\"snapToEnd(sliderThumb.Lower, false); $event.preventDefault()\"\n        (keydown.End)=\"snapToEnd(sliderThumb.Lower, true); $event.preventDefault()\">\n\n        <!-- Lower Thumb Callout -->\n        <div class=\"tooltip top tooltip-lower\" #lowerTooltip\n            [class.tooltip-dynamic]=\"options.handles.callout.trigger === sliderCalloutTrigger.Dynamic && thumbs.lower.drag === false\"\n            [style.opacity]=\"tooltips.lower.visible ? 1 : 0\"\n            [style.left.px]=\"tooltips.lower.position\">\n\n            <div class=\"tooltip-arrow\" [style.border-top-color]=\"options.handles.callout.background\"></div>\n\n            <div class=\"tooltip-inner\"\n                [style.background-color]=\"options.handles.callout.background\"\n                [style.color]=\"options.handles.callout.color\">\n                {{ tooltips.lower.label }}\n            </div>\n        </div>\n\n    </div>\n\n    <!-- Section of Track Between Lower and Upper Thumbs -->\n    <div class=\"track-section track-range\" *ngIf=\"options.type === sliderType.Range\" [style.flex-grow]=\"tracks.middle.size\" [style.background]=\"tracks.middle.color\">\n    </div>\n\n    <!-- Upper Thumb Button / Line -->\n    <div class=\"thumb upper\"\n        uxDrag\n        role=\"slider\"\n        tabindex=\"0\"\n        #upperthumb\n        [attr.aria-label]=\"options.handles.aria.upperThumb\"\n        [attr.aria-valuemin]=\"getThumbValue(sliderThumb.Lower) || options?.track?.min\"\n        [attr.aria-valuemax]=\"options?.track?.max\"\n        [attr.aria-valuenow]=\"getThumbValue(sliderThumb.Upper)\"\n        [attr.aria-valuetext]=\"getAriaValueText(sliderThumb.Upper)\"\n        [hidden]=\"options.type !== sliderType.Range\"\n        [class.active]=\"thumbs.upper.drag\"\n        [style.left.%]=\"thumbs.upper.position\"\n        [style.z-index]=\"thumbs.upper.order\"\n        [class.button]=\"options.handles.style === sliderStyle.Button\"\n        [class.line]=\"options.handles.style === sliderStyle.Line\"\n        [class.narrow]=\"options.track.height === sliderSize.Narrow\"\n        [class.wide]=\"options.track.height === sliderSize.Wide\"\n        (dragstart)=\"thumbEvent(sliderThumb.Upper, sliderThumbEvent.DragStart); upperthumb.focus()\"\n        (drag)=\"updateThumbPosition($event, sliderThumb.Upper)\"\n        (dragend)=\"thumbEvent(sliderThumb.Upper, sliderThumbEvent.DragEnd)\"\n        (mouseenter)=\"thumbEvent(sliderThumb.Upper, sliderThumbEvent.MouseOver)\"\n        (mouseleave)=\"thumbEvent(sliderThumb.Upper, sliderThumbEvent.MouseLeave)\"\n        (focus)=\"thumbEvent(sliderThumb.Upper, sliderThumbEvent.MouseOver)\"\n        (blur)=\"thumbEvent(sliderThumb.Upper, sliderThumbEvent.MouseLeave)\"\n        (keydown.ArrowLeft)=\"snapToNearestTick(sliderThumb.Upper, sliderSnap.All, false); $event.preventDefault()\"\n        (keydown.ArrowRight)=\"snapToNearestTick(sliderThumb.Upper, sliderSnap.All, true); $event.preventDefault()\"\n        (keydown.ArrowUp)=\"snapToNearestTick(sliderThumb.Upper, sliderSnap.All, false); $event.preventDefault()\"\n        (keydown.ArrowDown)=\"snapToNearestTick(sliderThumb.Upper, sliderSnap.All, true); $event.preventDefault()\"\n        (keydown.PageDown)=\"snapToNearestTick(sliderThumb.Upper, sliderSnap.Major, false); $event.preventDefault()\"\n        (keydown.PageUp)=\"snapToNearestTick(sliderThumb.Upper, sliderSnap.Major, true); $event.preventDefault()\"\n        (keydown.Home)=\"snapToEnd(sliderThumb.Upper, false); $event.preventDefault()\"\n        (keydown.End)=\"snapToEnd(sliderThumb.Upper, true); $event.preventDefault()\">\n\n        <!-- Upper Thumb Callout -->\n        <div class=\"tooltip top tooltip-upper\" #upperTooltip\n            [class.tooltip-dynamic]=\"options.handles.callout.trigger === sliderCalloutTrigger.Dynamic && thumbs.upper.drag === false\"\n            [style.opacity]=\"tooltips.upper.visible ? 1 : 0\"\n            [style.left.px]=\"tooltips.upper.position\">\n\n            <div class=\"tooltip-arrow\" [style.border-top-color]=\"options.handles.callout.background\"></div>\n\n            <div class=\"tooltip-inner\"\n                *ngIf=\"options.type === sliderType.Range\"\n                [style.background-color]=\"options.handles.callout.background\"\n                [style.color]=\"options.handles.callout.color\">\n                {{ tooltips.upper.label }}\n            </div>\n        </div>\n    </div>\n\n    <!-- Section of Track Abover Upper Thumb -->\n    <div class=\"track-section track-higher\" [style.flex-grow]=\"tracks.upper.size\" [style.background]=\"tracks.upper.color\"></div>\n\n</div>\n\n<!-- Chart Ticks and Tick Labels -->\n<div class=\"tick-container\"\n    role=\"presentation\"\n    *ngIf=\"(options.track.ticks.major.show || options.track.ticks.minor.show) && options.handles.callout.trigger !== sliderCalloutTrigger.Dynamic\"\n    [class.show-labels]=\"options.track.ticks.major.labels || options.track.ticks.minor.labels\">\n\n    <div class=\"tick\"\n        *ngFor=\"let tick of ticks\"\n        [class.major]=\"tick.type === sliderTickType.Major\"\n        [class.minor]=\"tick.type === sliderTickType.Minor\"\n        [style.left.%]=\"tick.position\"\n        [hidden]=\"!tick.showTicks\">\n\n        <div class=\"tick-indicator\"></div>\n        <div class=\"tick-label\" aria-hidden=\"true\" [hidden]=\"!tick.showLabels\">{{ tick.label }}</div>\n    </div>\n</div>",
                    changeDetection: ChangeDetectionStrategy.OnPush
                },] },
    ];
    /** @nocollapse */
    SliderComponent.ctorParameters = function () { return [
        { type: ColorService, },
        { type: ChangeDetectorRef, },
    ]; };
    SliderComponent.propDecorators = {
        "value": [{ type: Input },],
        "options": [{ type: Input },],
        "valueChange": [{ type: Output },],
        "lowerTooltip": [{ type: ViewChild, args: ['lowerTooltip',] },],
        "upperTooltip": [{ type: ViewChild, args: ['upperTooltip',] },],
        "track": [{ type: ViewChild, args: ['track',] },],
    };
    return SliderComponent;
}());
/** @enum {number} */
var SliderType = {
    Value: 0,
    Range: 1,
};
SliderType[SliderType.Value] = "Value";
SliderType[SliderType.Range] = "Range";
/** @enum {number} */
var SliderStyle = {
    Button: 0,
    Line: 1,
};
SliderStyle[SliderStyle.Button] = "Button";
SliderStyle[SliderStyle.Line] = "Line";
/** @enum {number} */
var SliderSize = {
    Narrow: 0,
    Wide: 1,
};
SliderSize[SliderSize.Narrow] = "Narrow";
SliderSize[SliderSize.Wide] = "Wide";
/** @enum {number} */
var SliderCalloutTrigger = {
    None: 0,
    Hover: 1,
    Drag: 2,
    Persistent: 3,
    Dynamic: 4,
};
SliderCalloutTrigger[SliderCalloutTrigger.None] = "None";
SliderCalloutTrigger[SliderCalloutTrigger.Hover] = "Hover";
SliderCalloutTrigger[SliderCalloutTrigger.Drag] = "Drag";
SliderCalloutTrigger[SliderCalloutTrigger.Persistent] = "Persistent";
SliderCalloutTrigger[SliderCalloutTrigger.Dynamic] = "Dynamic";
/** @enum {number} */
var SliderSnap = {
    None: 0,
    Minor: 1,
    Major: 2,
    All: 3,
};
SliderSnap[SliderSnap.None] = "None";
SliderSnap[SliderSnap.Minor] = "Minor";
SliderSnap[SliderSnap.Major] = "Major";
SliderSnap[SliderSnap.All] = "All";
/** @enum {number} */
var SliderTickType = {
    Minor: 0,
    Major: 1,
};
SliderTickType[SliderTickType.Minor] = "Minor";
SliderTickType[SliderTickType.Major] = "Major";
/** @enum {number} */
var SliderThumbEvent = {
    None: 0,
    MouseOver: 1,
    MouseLeave: 2,
    DragStart: 3,
    DragEnd: 4,
};
SliderThumbEvent[SliderThumbEvent.None] = "None";
SliderThumbEvent[SliderThumbEvent.MouseOver] = "MouseOver";
SliderThumbEvent[SliderThumbEvent.MouseLeave] = "MouseLeave";
SliderThumbEvent[SliderThumbEvent.DragStart] = "DragStart";
SliderThumbEvent[SliderThumbEvent.DragEnd] = "DragEnd";
/** @enum {number} */
var SliderThumb = {
    Lower: 0,
    Upper: 1,
};
SliderThumb[SliderThumb.Lower] = "Lower";
SliderThumb[SliderThumb.Upper] = "Upper";

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var SliderModule = (function () {
    function SliderModule() {
    }
    SliderModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        ColorServiceModule,
                        DragModule
                    ],
                    exports: [SliderComponent],
                    declarations: [SliderComponent]
                },] },
    ];
    /** @nocollapse */
    SliderModule.ctorParameters = function () { return []; };
    return SliderModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var SparkComponent = (function () {
    function SparkComponent(_colorService) {
        this._colorService = _colorService;
        this.values = [];
        this.barHeight = 10;
        this._theme = 'primary';
        this._barColor = [];
    }
    Object.defineProperty(SparkComponent.prototype, "theme", {
        get: /**
         * @return {?}
         */
        function () {
            return this._theme;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._theme = this._colorService.resolveColorName(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SparkComponent.prototype, "trackColor", {
        get: /**
         * @return {?}
         */
        function () {
            return this._trackColor;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._trackColor = this._colorService.resolve(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SparkComponent.prototype, "barColor", {
        get: /**
         * @return {?}
         */
        function () {
            return this._barColor;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            var _this = this;
            if (Array.isArray(value)) {
                this._barColor = value.map(function (color) { return _this._colorService.resolve(color); });
            }
            else {
                this._barColor = [this._colorService.resolve(value)];
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SparkComponent.prototype, "value", {
        get: /**
         * @return {?}
         */
        function () {
            return this.values;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            // ensure 'value' is an array at this point
            var /** @type {?} */ values = Array.isArray(value) ? value : [value];
            // get the total value of all lines
            var /** @type {?} */ total = Math.max(values.reduce(function (previous, current) { return previous + current; }, 0), 100);
            // figure out the percentages for each spark line
            this.values = values.map(function (val) { return (val / total) * 100; });
        },
        enumerable: true,
        configurable: true
    });
    SparkComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-spark',
                    template: "<!-- Inline Spark Chart -->\n<div *ngIf=\"inlineLabel\" class=\"ux-spark-inline-label-container\">\n\n    <div class=\"ux-spark-inline-label-left\" [innerHtml]=\"inlineLabel\"></div>\n\n    <div class=\"ux-spark-line\">\n\n        <div class=\"ux-spark-top-container\" *ngIf=\"topLeftLabel || topRightLabel\">\n            <div class=\"ux-spark-label-top-left\" *ngIf=\"topLeftLabel\" [innerHtml]=\"topLeftLabel\"></div>\n            <div class=\"ux-spark-label-top-right\" *ngIf=\"topRightLabel\" [innerHtml]=\"topRightLabel\"></div>\n        </div>\n\n        <div class=\"ux-spark ux-inline ux-spark-theme-{{theme}}\" [style.height.px]=\"barHeight\" [style.backgroundColor]=\"trackColor\" [uxTooltip]=\"tooltip\">\n            <div class=\"ux-spark-bar\" *ngFor=\"let line of values; let idx = index;\" [style.width.%]=\"line\" [style.backgroundColor]=\"barColor[idx]\"></div>\n        </div>\n\n        <div class=\"ux-spark-bottom-container\" *ngIf=\"bottomLeftLabel || bottomRightLabel\">\n            <div class=\"ux-spark-label-bottom-left\" *ngIf=\"bottomLeftLabel\" [innerHtml]=\"bottomLeftLabel\"></div>\n            <div class=\"ux-spark-label-bottom-right\" *ngIf=\"bottomRightLabel\" [innerHtml]=\"bottomRightLabel\"></div>\n        </div>\n\n    </div>\n</div>\n\n<!-- End Inline Spark Chart -->\n\n\n<!-- Non Inline Spark Chart -->\n<div *ngIf=\"!inlineLabel\">\n\n    <div class=\"ux-spark-top-container\" *ngIf=\"topLeftLabel || topRightLabel\">\n        <div class=\"ux-spark-label-top-left\" *ngIf=\"topLeftLabel\" [innerHtml]=\"topLeftLabel\"></div>\n        <div class=\"ux-spark-label-top-right\" *ngIf=\"topRightLabel\" [innerHtml]=\"topRightLabel\"></div>\n    </div>\n\n    <div class=\"ux-spark ux-spark-theme-{{theme}}\" [class.ux-spark-multi-value]=\"values.length > 1\" [style.height.px]=\"barHeight\" [style.backgroundColor]=\"trackColor\"\n        [uxTooltip]=\"tooltip\">\n        <div class=\"ux-spark-bar\" *ngFor=\"let line of value; let idx = index;\" [style.width.%]=\"line\" [style.backgroundColor]=\"barColor[idx]\"></div>\n    </div>\n\n    <div class=\"ux-spark-bottom-container\" *ngIf=\"bottomLeftLabel || bottomRightLabel\">\n        <div class=\"ux-spark-label-bottom-left\" *ngIf=\"bottomLeftLabel\" [innerHtml]=\"bottomLeftLabel\"></div>\n        <div class=\"ux-spark-label-bottom-right\" *ngIf=\"bottomRightLabel\" [innerHtml]=\"bottomRightLabel\"></div>\n    </div>\n</div>\n\n<!-- End Non Inline Spark Chart -->",
                    changeDetection: ChangeDetectionStrategy.OnPush
                },] },
    ];
    /** @nocollapse */
    SparkComponent.ctorParameters = function () { return [
        { type: ColorService, },
    ]; };
    SparkComponent.propDecorators = {
        "barHeight": [{ type: Input },],
        "inlineLabel": [{ type: Input },],
        "topLeftLabel": [{ type: Input },],
        "topRightLabel": [{ type: Input },],
        "bottomLeftLabel": [{ type: Input },],
        "bottomRightLabel": [{ type: Input },],
        "tooltip": [{ type: Input },],
        "theme": [{ type: Input },],
        "trackColor": [{ type: Input },],
        "barColor": [{ type: Input },],
        "value": [{ type: Input },],
    };
    return SparkComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var SparkModule = (function () {
    function SparkModule() {
    }
    SparkModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        ColorServiceModule,
                        TooltipModule
                    ],
                    exports: [SparkComponent],
                    declarations: [SparkComponent]
                },] },
    ];
    /** @nocollapse */
    SparkModule.ctorParameters = function () { return []; };
    return SparkModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var TabsetService = (function () {
    function TabsetService() {
        this.tabs$ = new BehaviorSubject([]);
        this.active$ = new BehaviorSubject(null);
        this.focused$ = new BehaviorSubject(false);
        this.highlighted$ = new BehaviorSubject(null);
    }
    /**
     * @param {?} tab
     * @return {?}
     */
    TabsetService.prototype.add = /**
     * @param {?} tab
     * @return {?}
     */
    function (tab) {
        this.tabs$.next(__spread(this.tabs$.value, [tab]));
        // check if this is the only tab. If so select this by default
        if (!this.active$.value) {
            this.select(tab);
        }
    };
    /**
     * @param {?} tab
     * @return {?}
     */
    TabsetService.prototype.remove = /**
     * @param {?} tab
     * @return {?}
     */
    function (tab) {
        // remove the tab
        this.tabs$.next(this.tabs$.value.filter(function (_tab) { return _tab !== tab; }));
    };
    /**
     * @param {?} tab
     * @return {?}
     */
    TabsetService.prototype.select = /**
     * @param {?} tab
     * @return {?}
     */
    function (tab) {
        if (!tab.disabled) {
            this.active$.next(tab);
            this.highlighted$.next(tab);
        }
    };
    /**
     * @param {?} index
     * @return {?}
     */
    TabsetService.prototype.selectAtIndex = /**
     * @param {?} index
     * @return {?}
     */
    function (index) {
        // if there are no tabs then do nothing
        if (this.tabs$.value.length === 0) {
            return;
        }
        // check if the index is within the bounds
        if (index < 0) {
            return this.selectAtIndex(this.tabs$.value.length - 1);
        }
        else if (index >= this.tabs$.value.length) {
            return this.selectAtIndex(0);
        }
        var /** @type {?} */ target = this.tabs$.value[index];
        if (target) {
            this.select(target);
        }
    };
    /**
     * @return {?}
     */
    TabsetService.prototype.selectNextTab = /**
     * @return {?}
     */
    function () {
        // find the currently selected index
        var /** @type {?} */ index = this.tabs$.value.indexOf(this.active$.value);
        // check the tabs after the active one to see if there are any selectable tabs
        var /** @type {?} */ tabs = this.tabs$.value.slice(index + 1);
        try {
            // check if any of the tabs are not disabled
            for (var tabs_1 = __values(tabs), tabs_1_1 = tabs_1.next(); !tabs_1_1.done; tabs_1_1 = tabs_1.next()) {
                var tab = tabs_1_1.value;
                if (!tab.disabled) {
                    return this.select(tab);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (tabs_1_1 && !tabs_1_1.done && (_a = tabs_1.return)) _a.call(tabs_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        // if we reach here then no tab could be selected - select the first tab
        this.selectFirstTab();
        var e_1, _a;
    };
    /**
     * @return {?}
     */
    TabsetService.prototype.selectPreviousTab = /**
     * @return {?}
     */
    function () {
        // find the currently selected index
        var /** @type {?} */ index = this.tabs$.value.indexOf(this.active$.value);
        // check the tabs before the active one to see if there are any selectable tabs
        var /** @type {?} */ tabs = this.tabs$.value.slice(0, index);
        try {
            // check if any of the tabs are not disabled
            for (var _a = __values(tabs.reverse()), _b = _a.next(); !_b.done; _b = _a.next()) {
                var tab = _b.value;
                if (!tab.disabled) {
                    return this.select(tab);
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_2) throw e_2.error; }
        }
        // if we reach here then no previous tab could be selected - select the last tab
        this.selectLastTab();
        var e_2, _c;
    };
    /**
     * @return {?}
     */
    TabsetService.prototype.selectFirstTab = /**
     * @return {?}
     */
    function () {
        // find the index of the first non-disabled tab
        var /** @type {?} */ tabIndex = this.tabs$.value.findIndex(function (tab) { return !tab.disabled; });
        if (tabIndex !== -1) {
            this.selectAtIndex(tabIndex);
        }
    };
    /**
     * @return {?}
     */
    TabsetService.prototype.selectLastTab = /**
     * @return {?}
     */
    function () {
        // find the index of the first non-disabled tab
        var /** @type {?} */ tabIndex = this.tabs$.value.slice().reverse().findIndex(function (tab) { return !tab.disabled; });
        if (tabIndex !== -1) {
            this.selectAtIndex((this.tabs$.value.length - 1) - tabIndex);
        }
    };
    TabsetService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    TabsetService.ctorParameters = function () { return []; };
    return TabsetService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var TabsetComponent = (function () {
    function TabsetComponent(tabset) {
        this.tabset = tabset;
        this.minimal = true;
        this.stacked = 'none';
    }
    /**
     * Allow manual tab selected
     */
    /**
     * Allow manual tab selected
     * @param {?} tab
     * @return {?}
     */
    TabsetComponent.prototype.select = /**
     * Allow manual tab selected
     * @param {?} tab
     * @return {?}
     */
    function (tab) {
        this.tabset.select(tab);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    TabsetComponent.prototype.selectPreviousTab = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        // determine which arrow key is pressed
        var /** @type {?} */ arrowLeft = event.key === 'ArrowLeft' || event.keyCode === 37;
        var /** @type {?} */ arrowUp = event.key === 'ArrowUp' || event.keyCode === 38;
        // only perform action if the arrow key matches the orientation
        if (arrowLeft && this.stacked !== 'none' || arrowUp && this.stacked === 'none') {
            return;
        }
        // perform selection
        this.tabset.selectPreviousTab();
        // prevent the browser from scrolling when arrow keys are pressed
        event.preventDefault();
    };
    /**
     * @param {?} event
     * @return {?}
     */
    TabsetComponent.prototype.selectNextTab = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        // determine which arrow key is pressed
        var /** @type {?} */ arrowRight = event.key === 'ArrowRight' || event.keyCode === 39;
        var /** @type {?} */ arrowDown = event.key === 'ArrowDown' || event.keyCode === 40;
        // only perform action if the arrow key matches the orientation
        if (arrowRight && this.stacked !== 'none' || arrowDown && this.stacked === 'none') {
            return;
        }
        // perform selection
        this.tabset.selectNextTab();
        // prevent the browser from scrolling when arrow keys are pressed
        event.preventDefault();
    };
    TabsetComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-tabset',
                    template: "<!-- Nav tabs -->\n<ul role=\"tablist\"\n    class=\"nav nav-tabs\"\n    [class.minimal-tab]=\"minimal\"\n    [attr.aria-label]=\"ariaLabel\"\n    [attr.aria-orientation]=\"stacked === 'none' ? 'horizontal' : 'vertical'\">\n\n\t<li role=\"presentation\" \n        class=\"nav-item\"\n        *ngFor=\"let tab of tabset.tabs$ | async; let index = index\"\n        [class.active]=\"tab.active$ | async\"\n        [class.disabled]=\"tab.disabled\"\n        [ngClass]=\"tab.customClass\">\n\n        <a class=\"nav-link\"\n            [id]=\"tab.id\"\n            role=\"tab\"\n            [uxTabFocus]=\"tab\"\n            [tabindex]=\"(tab.active$ | async) ? 0 : -1\"\n            [class.highlighted]=\"(tabset.focused$ | async) && (tabset.highlighted$ | async) === tab\"            \n            (mousedown)=\"tabset.select(tab)\"\n            (focus)=\"tabset.focused$.next(true)\"\n            (blur)=\"tabset.focused$.next(false)\"\n            (mousedown)=\"tabset.focused$.next(true)\"\n            (keydown.ArrowUp)=\"selectPreviousTab($event)\"\n            (keydown.ArrowLeft)=\"selectPreviousTab($event)\"\n            (keydown.ArrowRight)=\"selectNextTab($event)\"\n            (keydown.ArrowDown)=\"selectNextTab($event)\"\n            (keydown.Home)=\"tabset.selectFirstTab(); $event.preventDefault()\"\n            (keydown.End)=\"tabset.selectLastTab(); $event.preventDefault()\"\n            [attr.aria-controls]=\"tab.id\"\n            [attr.aria-selected]=\"tab.active$ | async\"\n            [attr.aria-disabled]=\"tab.disabled\">\n\n            <span *ngIf=\"!tab.headingRef\">{{ tab.heading }}</span>\n\n            <ng-container *ngIf=\"tab.headingRef\" [ngTemplateOutlet]=\"tab.headingRef\"></ng-container>\n        </a>\n\n\t</li>\n\n</ul>\n\n<!-- Tab panes -->\n<div class=\"tab-content\">\n\t<ng-content></ng-content>\n</div>",
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [TabsetService],
                    host: {
                        '[class.tabs-left]': 'stacked === "left"',
                        '[class.tabs-right]': 'stacked === "right"',
                    }
                },] },
    ];
    /** @nocollapse */
    TabsetComponent.ctorParameters = function () { return [
        { type: TabsetService, },
    ]; };
    TabsetComponent.propDecorators = {
        "minimal": [{ type: Input },],
        "stacked": [{ type: Input },],
        "ariaLabel": [{ type: Input, args: ['aria-label',] },],
    };
    return TabsetComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var /** @type {?} */ uniqueTabId = 0;
var TabComponent = (function () {
    function TabComponent(_tabset) {
        var _this = this;
        this._tabset = _tabset;
        this.id = "ux-tab-" + ++uniqueTabId;
        this.disabled = false;
        this.select = new EventEmitter();
        this.deselect = new EventEmitter();
        this.active$ = this._tabset.active$.pipe(map(function (active) { return active === _this; }));
        _tabset.add(this);
        this._subscription = this.active$.subscribe(function (active) { return active ? _this.select.emit() : _this.deselect.emit(); });
    }
    Object.defineProperty(TabComponent.prototype, "active", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value) {
                this._tabset.select(this);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    TabComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._tabset.remove(this);
        this._subscription.unsubscribe();
    };
    TabComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-tab',
                    template: "<div role=\"tabpanel\"\n     class=\"tab-pane\"\n     [class.active]=\"active$ | async\"\n     [id]=\"id + '-panel'\"\n     [attr.aria-labelledby]=\"id\"\n     [attr.aria-hidden]=\"!(active$ | async)\">\n  <ng-content></ng-content>\n</div>",
                    changeDetection: ChangeDetectionStrategy.OnPush
                },] },
    ];
    /** @nocollapse */
    TabComponent.ctorParameters = function () { return [
        { type: TabsetService, },
    ]; };
    TabComponent.propDecorators = {
        "id": [{ type: Input },],
        "disabled": [{ type: Input },],
        "heading": [{ type: Input },],
        "customClass": [{ type: Input },],
        "select": [{ type: Output },],
        "deselect": [{ type: Output },],
        "active": [{ type: Input },],
    };
    return TabComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var TabHeadingDirective = (function () {
    function TabHeadingDirective(templateRef, tab) {
        tab.headingRef = templateRef;
    }
    TabHeadingDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[uxTabHeading]'
                },] },
    ];
    /** @nocollapse */
    TabHeadingDirective.ctorParameters = function () { return [
        { type: TemplateRef, },
        { type: TabComponent, },
    ]; };
    return TabHeadingDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var TabFocusDirective = (function () {
    function TabFocusDirective(_tabset, _elementRef) {
        this._tabset = _tabset;
        this._elementRef = _elementRef;
    }
    /**
     * @return {?}
     */
    TabFocusDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this._subscription = this._tabset.highlighted$.pipe(filter(function () { return _this._tabset.focused$.value === true; }), filter(function () { return _this._tabset.highlighted$.value === _this.uxTabFocus; })).subscribe(function () { return _this._elementRef.nativeElement.focus(); });
    };
    /**
     * @return {?}
     */
    TabFocusDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._subscription.unsubscribe();
    };
    TabFocusDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[uxTabFocus]'
                },] },
    ];
    /** @nocollapse */
    TabFocusDirective.ctorParameters = function () { return [
        { type: TabsetService, },
        { type: ElementRef, },
    ]; };
    TabFocusDirective.propDecorators = {
        "uxTabFocus": [{ type: Input },],
    };
    return TabFocusDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var TabsetModule = (function () {
    function TabsetModule() {
    }
    TabsetModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule
                    ],
                    exports: [TabsetComponent, TabComponent, TabHeadingDirective],
                    declarations: [TabsetComponent, TabComponent, TabHeadingDirective, TabFocusDirective],
                },] },
    ];
    /** @nocollapse */
    TabsetModule.ctorParameters = function () { return []; };
    return TabsetModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var TimelineComponent = (function () {
    function TimelineComponent() {
    }
    TimelineComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-timeline',
                    template: "<div class=\"timeline\">\n    <ng-content></ng-content>\n</div>\n"
                },] },
    ];
    /** @nocollapse */
    TimelineComponent.ctorParameters = function () { return []; };
    return TimelineComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var TimelineEventComponent = (function () {
    function TimelineEventComponent() {
    }
    TimelineEventComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-timeline-event',
                    template: "<div class=\"timeline-badge\" [ngClass]=\"badgeColor\">\n    <span>{{badgeTitle}}</span>\n</div>\n<div class=\"timeline-panel\">\n    <ng-content></ng-content>\n</div>\n"
                },] },
    ];
    /** @nocollapse */
    TimelineEventComponent.ctorParameters = function () { return []; };
    TimelineEventComponent.propDecorators = {
        "badgeColor": [{ type: Input },],
        "badgeTitle": [{ type: Input },],
    };
    return TimelineEventComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var TimelineModule = (function () {
    function TimelineModule() {
    }
    TimelineModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule
                    ],
                    exports: [
                        TimelineComponent,
                        TimelineEventComponent
                    ],
                    declarations: [
                        TimelineComponent,
                        TimelineEventComponent
                    ]
                },] },
    ];
    /** @nocollapse */
    TimelineModule.ctorParameters = function () { return []; };
    return TimelineModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var /** @type {?} */ TOGGLESWITCH_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(function () { return ToggleSwitchComponent; }),
    multi: true
};
var /** @type {?} */ uniqueToggleSwitchId = 0;
var ToggleSwitchComponent = (function () {
    function ToggleSwitchComponent() {
        this._toggleSwitchId = "ux-toggleswitch-" + ++uniqueToggleSwitchId;
        this.id = this._toggleSwitchId;
        this.tabindex = 0;
        this.clickable = true;
        this.disabled = false;
        this.ariaLabel = '';
        this.ariaLabelledby = null;
        this.valueChange = new EventEmitter();
        this._value = false;
        this.focused = false;
        this.onTouchedCallback = function () { };
        this.onChangeCallback = function () { };
    }
    Object.defineProperty(ToggleSwitchComponent.prototype, "value", {
        get: /**
         * @return {?}
         */
        function () {
            return this._value;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._value = value;
            // Update value output
            this.valueChange.emit(value);
            // Notify ngModel
            this.onChangeCallback(value);
            this.onTouchedCallback();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ToggleSwitchComponent.prototype, "inputId", {
        get: /**
         * @return {?}
         */
        function () {
            return (this.id || this._toggleSwitchId) + "-input";
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ToggleSwitchComponent.prototype.toggle = /**
     * @return {?}
     */
    function () {
        if (!this.disabled && this.clickable) {
            this.value = !this.value;
        }
    };
    /**
     * @param {?} value
     * @return {?}
     */
    ToggleSwitchComponent.prototype.writeValue = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this.value = !!value;
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    ToggleSwitchComponent.prototype.registerOnChange = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onChangeCallback = fn;
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    ToggleSwitchComponent.prototype.registerOnTouched = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onTouchedCallback = fn;
    };
    /**
     * @param {?} isDisabled
     * @return {?}
     */
    ToggleSwitchComponent.prototype.setDisabledState = /**
     * @param {?} isDisabled
     * @return {?}
     */
    function (isDisabled) {
        this.disabled = isDisabled;
    };
    ToggleSwitchComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-toggleswitch',
                    template: "<label [attr.for]=\"inputId\"\n       class=\"ux-toggleswitch\"\n       [class.ux-toggleswitch-checked]=\"value\"\n       [class.ux-toggleswitch-disabled]=\"disabled\"\n       [class.ux-toggleswitch-focused]=\"focused\">\n\n    <input class=\"ux-toggleswitch-input\"\n           type=\"checkbox\"\n           role=\"switch\"\n           [id]=\"inputId\"\n           [checked]=\"value\"\n           [disabled]=\"disabled\"\n           [attr.name]=\"name\"\n           [tabindex]=\"tabindex\"\n           [attr.aria-label]=\"ariaLabel\"\n           [attr.aria-labelledby]=\"ariaLabelledby\"\n           [attr.aria-checked]=\"value\"\n           (focus)=\"focused = true\"\n           (blur)=\"focused = false\"\n           (change)=\"toggle()\"\n           (click)=\"$event.stopPropagation()\">\n\n    <div class=\"ux-toggleswitch-container\">\n        <div class=\"ux-toggleswitch-bg\"></div>\n        <div class=\"ux-toggleswitch-nub\"></div>\n    </div>\n\n    <span class=\"ux-toggleswitch-label\">\n        <ng-content></ng-content>\n    </span>\n</label>",
                    providers: [TOGGLESWITCH_VALUE_ACCESSOR]
                },] },
    ];
    /** @nocollapse */
    ToggleSwitchComponent.ctorParameters = function () { return []; };
    ToggleSwitchComponent.propDecorators = {
        "id": [{ type: Input },],
        "name": [{ type: Input },],
        "tabindex": [{ type: Input },],
        "clickable": [{ type: Input },],
        "disabled": [{ type: Input },],
        "ariaLabel": [{ type: Input, args: ['aria-label',] },],
        "ariaLabelledby": [{ type: Input, args: ['aria-labelledby',] },],
        "valueChange": [{ type: Output },],
        "value": [{ type: Input },],
    };
    return ToggleSwitchComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ToggleSwitchModule = (function () {
    function ToggleSwitchModule() {
    }
    ToggleSwitchModule.decorators = [
        { type: NgModule, args: [{
                    imports: [FormsModule],
                    exports: [ToggleSwitchComponent],
                    declarations: [ToggleSwitchComponent]
                },] },
    ];
    /** @nocollapse */
    ToggleSwitchModule.ctorParameters = function () { return []; };
    return ToggleSwitchModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ToolbarSearchButtonDirective = (function () {
    function ToolbarSearchButtonDirective(_elementRef) {
        this._elementRef = _elementRef;
        this.clicked = new EventEmitter();
    }
    Object.defineProperty(ToolbarSearchButtonDirective.prototype, "width", {
        get: /**
         * @return {?}
         */
        function () {
            return this._elementRef.nativeElement.offsetWidth;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ToolbarSearchButtonDirective.prototype.clickHandler = /**
     * @return {?}
     */
    function () {
        this.clicked.emit();
    };
    ToolbarSearchButtonDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[uxToolbarSearchButton]'
                },] },
    ];
    /** @nocollapse */
    ToolbarSearchButtonDirective.ctorParameters = function () { return [
        { type: ElementRef, },
    ]; };
    ToolbarSearchButtonDirective.propDecorators = {
        "clicked": [{ type: Output },],
        "clickHandler": [{ type: HostListener, args: ['click',] },],
    };
    return ToolbarSearchButtonDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var /** @type {?} */ KEYS = {
    ENTER: 13,
    ESCAPE: 27
};
var ToolbarSearchFieldDirective = (function () {
    function ToolbarSearchFieldDirective(_elementRef, _ngModel) {
        this._elementRef = _elementRef;
        this._ngModel = _ngModel;
        this.cancel = new EventEmitter();
        this.submit = new EventEmitter();
    }
    Object.defineProperty(ToolbarSearchFieldDirective.prototype, "text", {
        get: /**
         * @return {?}
         */
        function () {
            // Use ngModel if specified on the host; otherwise read the DOM
            if (this._ngModel) {
                return this._ngModel.value;
            }
            return this._elementRef.nativeElement.value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ToolbarSearchFieldDirective.prototype.focus = /**
     * @return {?}
     */
    function () {
        var _this = this;
        setTimeout(function () {
            _this._elementRef.nativeElement.focus();
        });
    };
    /**
     * @return {?}
     */
    ToolbarSearchFieldDirective.prototype.blur = /**
     * @return {?}
     */
    function () {
        var _this = this;
        setTimeout(function () {
            _this._elementRef.nativeElement.blur();
        });
    };
    /**
     * @return {?}
     */
    ToolbarSearchFieldDirective.prototype.clear = /**
     * @return {?}
     */
    function () {
        // Use ngModel if specified on the host; otherwise use the DOM
        if (this._ngModel) {
            this._ngModel.reset();
        }
        else {
            this._elementRef.nativeElement.value = '';
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    ToolbarSearchFieldDirective.prototype.keydownHandler = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        setTimeout(function () {
            if (event.keyCode === KEYS.ENTER) {
                _this.submit.emit(_this.text);
            }
            else if (event.keyCode === KEYS.ESCAPE) {
                _this._elementRef.nativeElement.blur();
                _this.cancel.emit();
            }
        });
    };
    ToolbarSearchFieldDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[uxToolbarSearchField]'
                },] },
    ];
    /** @nocollapse */
    ToolbarSearchFieldDirective.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: NgModel, decorators: [{ type: Optional },] },
    ]; };
    ToolbarSearchFieldDirective.propDecorators = {
        "cancel": [{ type: Output },],
        "submit": [{ type: Output },],
        "keydownHandler": [{ type: HostListener, args: ['keydown', ['$event'],] },],
    };
    return ToolbarSearchFieldDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ToolbarSearchComponent = (function () {
    function ToolbarSearchComponent(_elementRef, _colorService, _document) {
        this._elementRef = _elementRef;
        this._colorService = _colorService;
        this._document = _document;
        this.direction = 'right';
        this.inverse = false;
        this.expandedChange = new EventEmitter();
        this.search = new EventEmitter();
        this._expanded = false;
        this.position = 'relative';
        this.backgroundColor = 'transparent';
    }
    Object.defineProperty(ToolbarSearchComponent.prototype, "expanded", {
        get: /**
         * @return {?}
         */
        function () {
            return this._expanded;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._expanded = value;
            this.expandedChange.emit(value);
            if (value) {
                // Set focus on the input when expanded
                this.field.focus();
            }
            else {
                // Clear text when contracted
                this.field.clear();
                // Remove focus (works around an IE issue where the caret remains visible)
                this.field.blur();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ToolbarSearchComponent.prototype, "background", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.backgroundColor = this._colorService.resolve(value) || 'transparent';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ToolbarSearchComponent.prototype, "expandedAnimation", {
        get: /**
         * @return {?}
         */
        function () {
            return {
                value: this.expanded ? 'expanded' : 'collapsed',
                params: {
                    initialWidth: this.button.width + 'px'
                }
            };
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ToolbarSearchComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // Subscribe to the submit event on the input field, triggering the search event
        this.field.submit.subscribe(function (text) { return _this.search.emit(text); });
        // Subscribe to cancel events coming from the input field
        this.field.cancel.subscribe(function () { return _this.expanded = false; });
        // Subscribe to the button click event
        this.button.clicked.subscribe(function () {
            if (_this.expanded && _this.field.text) {
                _this.search.emit(_this.field.text);
            }
            else {
                _this.expanded = !_this.expanded;
            }
        });
        // Create placeholder element to avoid changing layout when switching to position: absolute
        this.createPlaceholder();
    };
    /**
     * @param {?} event
     * @return {?}
     */
    ToolbarSearchComponent.prototype.animationStart = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (event.toState === 'expanded') {
            this.position = 'absolute';
            this.enablePlaceholder(true);
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    ToolbarSearchComponent.prototype.animationDone = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (event.toState === 'collapsed') {
            this.position = 'relative';
            this.enablePlaceholder(false);
        }
    };
    /**
     * @return {?}
     */
    ToolbarSearchComponent.prototype.createPlaceholder = /**
     * @return {?}
     */
    function () {
        // Get width and height of the component
        var /** @type {?} */ styles = getComputedStyle(this._elementRef.nativeElement);
        // Create invisible div with the same dimensions
        this._placeholder = this._document.createElement('div');
        this._placeholder.style.display = 'none';
        this._placeholder.style.width = this.button.width + 'px';
        this._placeholder.style.height = styles.height;
        this._placeholder.style.visibility = 'hidden';
        // Add as a sibling
        this._elementRef.nativeElement.parentNode.insertBefore(this._placeholder, this._elementRef.nativeElement);
    };
    /**
     * @param {?} enabled
     * @return {?}
     */
    ToolbarSearchComponent.prototype.enablePlaceholder = /**
     * @param {?} enabled
     * @return {?}
     */
    function (enabled) {
        this._placeholder.style.display = (enabled ? 'inline-block' : 'none');
    };
    ToolbarSearchComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-toolbar-search',
                    template: "<ng-content></ng-content>",
                    animations: [
                        trigger('expanded', [
                            state('collapsed', style({
                                width: '{{initialWidth}}'
                            }), {
                                params: { initialWidth: '30px' }
                            }),
                            state('expanded', style({
                                width: '100%'
                            })),
                            transition('collapsed <=> expanded', [animate('0.3s ease-out')])
                        ])
                    ]
                },] },
    ];
    /** @nocollapse */
    ToolbarSearchComponent.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: ColorService, },
        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT$1,] },] },
    ]; };
    ToolbarSearchComponent.propDecorators = {
        "expanded": [{ type: HostBinding, args: ['class.expanded',] }, { type: Input },],
        "direction": [{ type: Input }, { type: HostBinding, args: ['class',] },],
        "inverse": [{ type: Input }, { type: HostBinding, args: ['class.inverse',] },],
        "background": [{ type: Input },],
        "expandedChange": [{ type: Output },],
        "search": [{ type: Output },],
        "expandedAnimation": [{ type: HostBinding, args: ['@expanded',] },],
        "position": [{ type: HostBinding, args: ['style.position',] },],
        "backgroundColor": [{ type: HostBinding, args: ['style.background-color',] },],
        "field": [{ type: ContentChild, args: [ToolbarSearchFieldDirective,] },],
        "button": [{ type: ContentChild, args: [ToolbarSearchButtonDirective,] },],
        "animationStart": [{ type: HostListener, args: ['@expanded.start', ['$event'],] },],
        "animationDone": [{ type: HostListener, args: ['@expanded.done', ['$event'],] },],
    };
    return ToolbarSearchComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var /** @type {?} */ DECLARATIONS$6 = [
    ToolbarSearchComponent,
    ToolbarSearchFieldDirective,
    ToolbarSearchButtonDirective
];
var ToolbarSearchModule = (function () {
    function ToolbarSearchModule() {
    }
    ToolbarSearchModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule
                    ],
                    exports: DECLARATIONS$6,
                    declarations: DECLARATIONS$6,
                    providers: [],
                },] },
    ];
    /** @nocollapse */
    ToolbarSearchModule.ctorParameters = function () { return []; };
    return ToolbarSearchModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var VirtualScrollLoadingDirective = (function () {
    function VirtualScrollLoadingDirective() {
    }
    VirtualScrollLoadingDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[uxVirtualScrollLoading]'
                },] },
    ];
    /** @nocollapse */
    VirtualScrollLoadingDirective.ctorParameters = function () { return []; };
    return VirtualScrollLoadingDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var VirtualScrollLoadButtonDirective = (function () {
    function VirtualScrollLoadButtonDirective() {
    }
    VirtualScrollLoadButtonDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[uxVirtualScrollLoadButton]'
                },] },
    ];
    /** @nocollapse */
    VirtualScrollLoadButtonDirective.ctorParameters = function () { return []; };
    return VirtualScrollLoadButtonDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var VirtualScrollCellDirective = (function () {
    function VirtualScrollCellDirective() {
    }
    VirtualScrollCellDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[uxVirtualScrollCell]'
                },] },
    ];
    /** @nocollapse */
    VirtualScrollCellDirective.ctorParameters = function () { return []; };
    return VirtualScrollCellDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var VirtualScrollComponent = (function () {
    function VirtualScrollComponent(_elementRef, resizeService) {
        var _this = this;
        this._elementRef = _elementRef;
        this.collection = Observable.create();
        this.loadOnScroll = true;
        this.loading = new EventEmitter();
        this.cells = new BehaviorSubject([]);
        this.scrollTop = 0;
        this.isLoading = false;
        this.pageNumber = 0;
        this.data = [];
        this.loadingComplete = false;
        // watch for any future changes to size
        resizeService.addResizeListener(_elementRef.nativeElement).subscribe(function (event) { return _this._height = event.height; });
    }
    /**
     * @return {?}
     */
    VirtualScrollComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (!this.cellHeight) {
            throw new Error('Virtual Scroll Component requires "cellHeight" property to be defined.');
        }
        // subscribe to the collection
        this.setupObservable();
        // load the first page of data
        this.loadNextPage();
    };
    /**
     * @return {?}
     */
    VirtualScrollComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        // re-render cells now that we can display any loading indicator or loading button
        this.renderCells();
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    VirtualScrollComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (changes["collection"] && changes["collection"].currentValue !== changes["collection"].previousValue && !changes["collection"].isFirstChange()) {
            this.setupObservable();
            this.reset();
        }
    };
    /**
     * @return {?}
     */
    VirtualScrollComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._subscription.unsubscribe();
    };
    /**
     * @return {?}
     */
    VirtualScrollComponent.prototype.setupObservable = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // if there is a current subscription, unsubscribe
        if (this._subscription && this._subscription.unsubscribe) {
            this._subscription.unsubscribe();
        }
        this._subscription = this.collection.subscribe(function (collection) {
            (_a = _this.data).push.apply(_a, __spread(collection));
            _this.renderCells();
            _this.isLoading = false;
            var _a;
        }, null, function () {
            _this.loadingComplete = true;
        });
    };
    /**
     * @return {?}
     */
    VirtualScrollComponent.prototype.renderCells = /**
     * @return {?}
     */
    function () {
        this.cells.next(this.getVisibleCells());
        if (this.loadOnScroll && !this.isLoading && !this.loadingComplete) {
            var /** @type {?} */ remainingScroll = this._elementRef.nativeElement.scrollHeight - (this._elementRef.nativeElement.scrollTop + this._elementRef.nativeElement.clientHeight);
            // if the current cells take up less than the height of the component then load the next page
            if (remainingScroll <= this._elementRef.nativeElement.clientHeight) {
                this.loadNextPage();
            }
        }
    };
    /**
     * @return {?}
     */
    VirtualScrollComponent.prototype.getVisibleCells = /**
     * @return {?}
     */
    function () {
        // store the initial element height
        if (!this._height) {
            this._height = this._elementRef.nativeElement.offsetHeight;
        }
        // perform some calculations
        var /** @type {?} */ scrollTop = this._elementRef.nativeElement.scrollTop;
        var /** @type {?} */ startCell = Math.floor(scrollTop / this.cellHeight);
        var /** @type {?} */ endCell = Math.ceil(this._height / this.cellHeight) + 1;
        // update the scroll position
        this.scrollTop = scrollTop - (scrollTop % this.cellHeight);
        // return a sublist of items visible on the screen
        return this.data.slice(startCell, startCell + endCell);
    };
    /**
     * @return {?}
     */
    VirtualScrollComponent.prototype.getTotalHeight = /**
     * @return {?}
     */
    function () {
        return this.cellHeight * this.data.length;
    };
    /**
     * @return {?}
     */
    VirtualScrollComponent.prototype.loadNextPage = /**
     * @return {?}
     */
    function () {
        this.isLoading = true;
        this.loading.next(this.pageNumber);
        this.pageNumber++;
    };
    /**
     * @return {?}
     */
    VirtualScrollComponent.prototype.reset = /**
     * @return {?}
     */
    function () {
        // reset all values
        this.scrollTop = 0;
        this.data = [];
        this._height = undefined;
        this.pageNumber = 0;
        this.loadingComplete = false;
        // set scroll position
        this._elementRef.nativeElement.scrollTop = 0;
        // clear the current cells
        this.renderCells();
        // reload first page
        this.loadNextPage();
    };
    VirtualScrollComponent.decorators = [
        { type: Component, args: [{
                    selector: 'ux-virtual-scroll',
                    template: "<div class=\"virtual-scroll-content-height\" [style.height.px]=\"getTotalHeight()\"></div>\n<div class=\"virtual-scroll-content\" [style.transform]=\"'translateY(' + scrollTop + 'px)'\">\n\n    <!-- Virtually Render Cells -->\n    <ng-container *ngFor=\"let cell of cells | async\">\n        <ng-container *ngTemplateOutlet=\"cellTemplate; context: { cell: cell }\"></ng-container>\n    </ng-container>\n\n    <!-- Loading Indicator -->\n    <ng-container *ngIf=\"loadingIndicatorTemplate && isLoading\" [ngTemplateOutlet]=\"loadingIndicatorTemplate\"></ng-container>\n\n    <!-- Loading Button -->\n    <div class=\"virtual-scroll-load-button\" *ngIf=\"loadButtonTemplate && !loadOnScroll && !loadingComplete && !isLoading\" (click)=\"loadNextPage()\">\n        <ng-container *ngTemplateOutlet=\"loadButtonTemplate\"></ng-container>\n    </div>\n    \n</div>"
                },] },
    ];
    /** @nocollapse */
    VirtualScrollComponent.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: ResizeService, },
    ]; };
    VirtualScrollComponent.propDecorators = {
        "collection": [{ type: Input },],
        "cellHeight": [{ type: Input },],
        "loadOnScroll": [{ type: Input },],
        "loading": [{ type: Output },],
        "cellTemplate": [{ type: ContentChild, args: [VirtualScrollCellDirective, { read: TemplateRef },] },],
        "loadingIndicatorTemplate": [{ type: ContentChild, args: [VirtualScrollLoadingDirective, { read: TemplateRef },] },],
        "loadButtonTemplate": [{ type: ContentChild, args: [VirtualScrollLoadButtonDirective, { read: TemplateRef },] },],
        "renderCells": [{ type: HostListener, args: ['scroll',] },],
    };
    return VirtualScrollComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var /** @type {?} */ DECLARATIONS$7 = [
    VirtualScrollComponent,
    VirtualScrollLoadingDirective,
    VirtualScrollLoadButtonDirective,
    VirtualScrollCellDirective
];
var VirtualScrollModule = (function () {
    function VirtualScrollModule() {
    }
    VirtualScrollModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule,
                        ResizeModule
                    ],
                    exports: DECLARATIONS$7,
                    declarations: DECLARATIONS$7
                },] },
    ];
    /** @nocollapse */
    VirtualScrollModule.ctorParameters = function () { return []; };
    return VirtualScrollModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AutoGrowDirective = (function () {
    function AutoGrowDirective(_elementRef, _renderer) {
        this._elementRef = _elementRef;
        this._renderer = _renderer;
        // ensure this is a textarea or else throw error
        if (_elementRef.nativeElement.tagName.toLowerCase() !== 'textarea') {
            throw new Error('uxAutoGrow directive can only be used on <textarea> elements.');
        }
    }
    /**
     * @return {?}
     */
    AutoGrowDirective.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        this.update();
    };
    /**
     * @return {?}
     */
    AutoGrowDirective.prototype.update = /**
     * @return {?}
     */
    function () {
        // perform sizing
        this._renderer.setStyle(this._elementRef.nativeElement, 'overflowY', 'hidden');
        this._renderer.setStyle(this._elementRef.nativeElement, 'height', 'auto');
        // get the new total height and element height
        var scrollHeight = this._elementRef.nativeElement.scrollHeight;
        var maxHeight = getComputedStyle(this._elementRef.nativeElement).maxHeight;
        // determine what the maximum allowed height is
        var /** @type {?} */ maximum = !isNaN(parseFloat(maxHeight)) ? parseFloat(maxHeight) : Infinity;
        // if there is a max height specifed we want to show the scrollbars
        if (maximum < scrollHeight) {
            this._renderer.setStyle(this._elementRef.nativeElement, 'overflowY', 'auto');
            this._renderer.setStyle(this._elementRef.nativeElement, 'height', maximum + 'px');
        }
        else {
            this._renderer.setStyle(this._elementRef.nativeElement, 'height', scrollHeight + 'px');
        }
    };
    AutoGrowDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[uxAutoGrow]'
                },] },
    ];
    /** @nocollapse */
    AutoGrowDirective.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: Renderer2, },
    ]; };
    AutoGrowDirective.propDecorators = {
        "update": [{ type: HostListener, args: ['input',] },],
    };
    return AutoGrowDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AutoGrowModule = (function () {
    function AutoGrowModule() {
    }
    AutoGrowModule.decorators = [
        { type: NgModule, args: [{
                    exports: [AutoGrowDirective],
                    declarations: [AutoGrowDirective]
                },] },
    ];
    /** @nocollapse */
    AutoGrowModule.ctorParameters = function () { return []; };
    return AutoGrowModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var FixedHeaderTableDirective = (function () {
    function FixedHeaderTableDirective(_elementRef, _renderer) {
        this._elementRef = _elementRef;
        this._renderer = _renderer;
        this.tablePaging = new EventEmitter();
    }
    /**
     * @return {?}
     */
    FixedHeaderTableDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        // add class to the table
        this._renderer.addClass(this._elementRef.nativeElement, 'ux-fixed-header-table');
        // locate the important elements
        this._tableHead = this._elementRef.nativeElement.querySelector('thead');
        this._tableBody = this._elementRef.nativeElement.querySelector('tbody');
        // bind to scroll events on the table body
        this._renderer.listen(this._tableBody, 'scroll', this.onScroll.bind(this));
        // resize the table header to account for scrollbar
        this.setLayout();
        // trigger the loading of the first page
        this.tablePaging.emit();
    };
    /**
     * Get the table element
     * Primarily used by column width directive
     */
    /**
     * Get the table element
     * Primarily used by column width directive
     * @return {?}
     */
    FixedHeaderTableDirective.prototype.getTable = /**
     * Get the table element
     * Primarily used by column width directive
     * @return {?}
     */
    function () {
        return this._elementRef.nativeElement;
    };
    /**
     * Handle scroll events
     * @return {?}
     */
    FixedHeaderTableDirective.prototype.onScroll = /**
     * Handle scroll events
     * @return {?}
     */
    function () {
        // determine if we are scrolled to the bottom and if so load the next page
        if (this._tableBody.scrollTop === (this._tableBody.scrollHeight - this._tableBody.offsetHeight)) {
            this.tablePaging.emit();
        }
    };
    /**
     * Update the size of the table header to account for the scrollbar.
     * This is important to keep the columns aligned
     * @return {?}
     */
    FixedHeaderTableDirective.prototype.setLayout = /**
     * Update the size of the table header to account for the scrollbar.
     * This is important to keep the columns aligned
     * @return {?}
     */
    function () {
        // calculate the size of the scrollbar
        var /** @type {?} */ scrollbar = this._tableBody.offsetWidth - this._tableBody.clientWidth;
        // add padding to the header to account for this
        this._renderer.setStyle(this._tableHead, 'padding-right', scrollbar + 'px');
        // set the desired height of the table body
        this._renderer.setStyle(this._tableBody, 'height', typeof this.tableHeight === 'number' ? this.tableHeight + "px" : this.tableHeight);
    };
    FixedHeaderTableDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[uxFixedHeaderTable]'
                },] },
    ];
    /** @nocollapse */
    FixedHeaderTableDirective.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: Renderer2, },
    ]; };
    FixedHeaderTableDirective.propDecorators = {
        "tableHeight": [{ type: Input },],
        "tablePaging": [{ type: Output },],
    };
    return FixedHeaderTableDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var FixedHeaderTableModule = (function () {
    function FixedHeaderTableModule() {
    }
    FixedHeaderTableModule.decorators = [
        { type: NgModule, args: [{
                    exports: [FixedHeaderTableDirective],
                    declarations: [FixedHeaderTableDirective]
                },] },
    ];
    /** @nocollapse */
    FixedHeaderTableModule.ctorParameters = function () { return []; };
    return FixedHeaderTableModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var FloatLabelDirective = (function () {
    function FloatLabelDirective(_elementRef, _renderer) {
        this._elementRef = _elementRef;
        this._renderer = _renderer;
        this.mode = 'focus';
        this.raised = false;
        this._focused = false;
        this._eventHandles = [];
    }
    /**
     * @return {?}
     */
    FloatLabelDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this._eventHandles.push(this._renderer.listen(this.input, 'focus', this.inputFocus.bind(this)), this._renderer.listen(this.input, 'blur', this.inputBlur.bind(this)), this._renderer.listen(this.input, 'input', this.inputChange.bind(this)));
        // Check initial input value
        this.raised = this.hasText();
        // Ensure that the `for` attribute is set
        if (!this._elementRef.nativeElement.getAttribute('for') && this.input.getAttribute('id')) {
            this._renderer.setAttribute(this._elementRef.nativeElement, 'for', this.input.getAttribute('id'));
        }
    };
    /**
     * @return {?}
     */
    FloatLabelDirective.prototype.ngOnChanges = /**
     * @return {?}
     */
    function () {
        if (!(this.mode === 'focus' && this._focused)) {
            this.raised = this.hasText();
        }
    };
    /**
     * @return {?}
     */
    FloatLabelDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        // Unsubscribe event handles
        this._eventHandles.forEach(function (eventHandle) { return eventHandle(); });
    };
    /**
     * @return {?}
     */
    FloatLabelDirective.prototype.hasText = /**
     * @return {?}
     */
    function () {
        if (this.value === undefined) {
            return !!this.input.value;
        }
        return !!this.value;
    };
    /**
     * @return {?}
     */
    FloatLabelDirective.prototype.inputFocus = /**
     * @return {?}
     */
    function () {
        if (this.mode === 'focus') {
            this._focused = true;
            this.raised = true;
        }
    };
    /**
     * @return {?}
     */
    FloatLabelDirective.prototype.inputBlur = /**
     * @return {?}
     */
    function () {
        if (this.mode === 'focus') {
            this._focused = false;
            this.raised = this.hasText();
        }
    };
    /**
     * @return {?}
     */
    FloatLabelDirective.prototype.inputChange = /**
     * @return {?}
     */
    function () {
        if (this.mode === 'input') {
            this.raised = this.hasText();
        }
    };
    FloatLabelDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[uxFloatLabel]',
                    host: {
                        'class': 'ux-float-label'
                    }
                },] },
    ];
    /** @nocollapse */
    FloatLabelDirective.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: Renderer2, },
    ]; };
    FloatLabelDirective.propDecorators = {
        "input": [{ type: Input, args: ['uxFloatLabel',] },],
        "value": [{ type: Input },],
        "mode": [{ type: Input },],
        "raised": [{ type: HostBinding, args: ['class.ux-float-label-raised',] },],
    };
    return FloatLabelDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var FloatLabelModule = (function () {
    function FloatLabelModule() {
    }
    FloatLabelModule.decorators = [
        { type: NgModule, args: [{
                    imports: [],
                    exports: [FloatLabelDirective],
                    declarations: [FloatLabelDirective],
                    providers: [],
                },] },
    ];
    /** @nocollapse */
    FloatLabelModule.ctorParameters = function () { return []; };
    return FloatLabelModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var HelpCenterService = (function () {
    function HelpCenterService() {
        this.items = new BehaviorSubject([]);
    }
    /**
     * @param {?} item
     * @return {?}
     */
    HelpCenterService.prototype.registerItem = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        // get the current items
        var /** @type {?} */ items = this.items.getValue();
        // add the new item to the list
        items.push(item);
        // update the observable
        this.items.next(items);
    };
    /**
     * @param {?} item
     * @return {?}
     */
    HelpCenterService.prototype.unregisterItem = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        // get the current items
        var /** @type {?} */ items = this.items.getValue();
        // remove the item being unregistered
        items = items.filter(function (itm) { return itm !== item; });
        // update the observable
        this.items.next(items);
    };
    HelpCenterService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    HelpCenterService.ctorParameters = function () { return []; };
    return HelpCenterService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var HelpCenterItemDirective = (function () {
    function HelpCenterItemDirective(_helpCenterService) {
        this._helpCenterService = _helpCenterService;
    }
    /**
     * @return {?}
     */
    HelpCenterItemDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        // register the item in the service
        this._helpCenterService.registerItem(this.uxHelpCenterItem);
    };
    /**
     * @return {?}
     */
    HelpCenterItemDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        // remove this item when it is destroyed
        this._helpCenterService.unregisterItem(this.uxHelpCenterItem);
    };
    HelpCenterItemDirective.decorators = [
        { type: Directive, args: [{ selector: '[uxHelpCenterItem]' },] },
    ];
    /** @nocollapse */
    HelpCenterItemDirective.ctorParameters = function () { return [
        { type: HelpCenterService, },
    ]; };
    HelpCenterItemDirective.propDecorators = {
        "uxHelpCenterItem": [{ type: Input },],
    };
    return HelpCenterItemDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var HelpCenterModule = (function () {
    function HelpCenterModule() {
    }
    HelpCenterModule.decorators = [
        { type: NgModule, args: [{
                    imports: [],
                    exports: [HelpCenterItemDirective],
                    declarations: [HelpCenterItemDirective],
                    providers: [HelpCenterService],
                },] },
    ];
    /** @nocollapse */
    HelpCenterModule.ctorParameters = function () { return []; };
    return HelpCenterModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var HoverActionService = (function () {
    function HoverActionService() {
        this.active = new BehaviorSubject(false);
        this._focused = false;
        this._hovered = false;
        this._actions = [];
    }
    /**
     * @param {?} action
     * @return {?}
     */
    HoverActionService.prototype.register = /**
     * @param {?} action
     * @return {?}
     */
    function (action) {
        this._actions.push(action);
    };
    /**
     * @param {?} action
     * @return {?}
     */
    HoverActionService.prototype.unregister = /**
     * @param {?} action
     * @return {?}
     */
    function (action) {
        this._actions = this._actions.filter(function (actn) { return actn !== action; });
    };
    /**
     * @param {?} container
     * @return {?}
     */
    HoverActionService.prototype.setContainer = /**
     * @param {?} container
     * @return {?}
     */
    function (container) {
        this._container = container;
    };
    /**
     * @param {?} focus
     * @return {?}
     */
    HoverActionService.prototype.setFocusState = /**
     * @param {?} focus
     * @return {?}
     */
    function (focus) {
        this._focused = focus;
        this.updateVisibility();
    };
    /**
     * @param {?} hover
     * @return {?}
     */
    HoverActionService.prototype.setHoverState = /**
     * @param {?} hover
     * @return {?}
     */
    function (hover) {
        this._hovered = hover;
        this.updateVisibility();
    };
    /**
     * @return {?}
     */
    HoverActionService.prototype.next = /**
     * @return {?}
     */
    function () {
        // if container has focus then focus the first hover action
        if (this.containerHasFocus()) {
            this.focusActionAtIndex(0);
            return this.updateVisibility();
        }
        // if a hover action has focus then focus the next action
        if (this.actionHasFocus()) {
            var /** @type {?} */ index = this.getFocusedActionIndex() + 1;
            this.focusActionAtIndex(index);
            this.updateVisibility();
        }
    };
    /**
     * @return {?}
     */
    HoverActionService.prototype.previous = /**
     * @return {?}
     */
    function () {
        // if a hover action has focus then focus the previous action
        if (this.actionHasFocus()) {
            var /** @type {?} */ index = this.getFocusedActionIndex() - 1;
            if (index >= 0) {
                this.focusActionAtIndex(index);
            }
            else {
                this._container.focus();
            }
        }
        this.updateVisibility();
    };
    /**
     * @return {?}
     */
    HoverActionService.prototype.updateVisibility = /**
     * @return {?}
     */
    function () {
        this.active.next(this._focused || this._hovered || this.actionHasFocus());
    };
    /**
     * @param {?} index
     * @return {?}
     */
    HoverActionService.prototype.focusActionAtIndex = /**
     * @param {?} index
     * @return {?}
     */
    function (index) {
        if (index >= 0 && index < this._actions.length) {
            this._actions[index].focus();
        }
    };
    /**
     * @return {?}
     */
    HoverActionService.prototype.getFocusedActionIndex = /**
     * @return {?}
     */
    function () {
        var _this = this;
        return this._actions.findIndex(function (action) { return action === _this.getFocusedAction(); });
    };
    /**
     * @return {?}
     */
    HoverActionService.prototype.containerHasFocus = /**
     * @return {?}
     */
    function () {
        return this._focused;
    };
    /**
     * @return {?}
     */
    HoverActionService.prototype.actionHasFocus = /**
     * @return {?}
     */
    function () {
        return !!this.getFocusedAction();
    };
    /**
     * @return {?}
     */
    HoverActionService.prototype.getFocusedAction = /**
     * @return {?}
     */
    function () {
        return this._actions.find(function (action) { return action.focused; });
    };
    HoverActionService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    HoverActionService.ctorParameters = function () { return []; };
    return HoverActionService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var HoverActionContainerDirective = (function () {
    function HoverActionContainerDirective(_elementRef, _hoverActionService) {
        var _this = this;
        this._elementRef = _elementRef;
        this._hoverActionService = _hoverActionService;
        this.tabindex = 0;
        this.active = false;
        // register the container element with the service
        this._hoverActionService.setContainer(this);
        // apply a class based on the active state of the container and it's actions
        this.active$ = this._hoverActionService.active.subscribe(function (active) { return _this.active = active; });
    }
    /**
     * @return {?}
     */
    HoverActionContainerDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.active$.unsubscribe();
    };
    /**
     * @return {?}
     */
    HoverActionContainerDirective.prototype.focus = /**
     * @return {?}
     */
    function () {
        this._elementRef.nativeElement.focus();
    };
    /**
     * @return {?}
     */
    HoverActionContainerDirective.prototype.onFocus = /**
     * @return {?}
     */
    function () {
        this._hoverActionService.setFocusState(true);
    };
    /**
     * @return {?}
     */
    HoverActionContainerDirective.prototype.onBlur = /**
     * @return {?}
     */
    function () {
        this._hoverActionService.setFocusState(false);
    };
    /**
     * @return {?}
     */
    HoverActionContainerDirective.prototype.onHover = /**
     * @return {?}
     */
    function () {
        this._hoverActionService.setHoverState(true);
    };
    /**
     * @return {?}
     */
    HoverActionContainerDirective.prototype.onLeave = /**
     * @return {?}
     */
    function () {
        this._hoverActionService.setHoverState(false);
    };
    /**
     * @return {?}
     */
    HoverActionContainerDirective.prototype.next = /**
     * @return {?}
     */
    function () {
        this._hoverActionService.next();
    };
    HoverActionContainerDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[uxHoverActionContainer]',
                    providers: [HoverActionService],
                    host: {
                        '[class.hover-action-container-active]': 'active',
                        '[tabindex]': 'tabindex'
                    }
                },] },
    ];
    /** @nocollapse */
    HoverActionContainerDirective.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: HoverActionService, },
    ]; };
    HoverActionContainerDirective.propDecorators = {
        "tabindex": [{ type: Input },],
        "focus": [{ type: HostListener, args: ['click',] },],
        "onFocus": [{ type: HostListener, args: ['focus',] },],
        "onBlur": [{ type: HostListener, args: ['blur',] },],
        "onHover": [{ type: HostListener, args: ['mouseenter',] },],
        "onLeave": [{ type: HostListener, args: ['mouseleave',] },],
        "next": [{ type: HostListener, args: ['keydown.arrowright',] },],
    };
    return HoverActionContainerDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var HoverActionDirective = (function () {
    function HoverActionDirective(_elementRef, _hoverActionService) {
        var _this = this;
        this._elementRef = _elementRef;
        this._hoverActionService = _hoverActionService;
        this.tabindex = 1;
        this.active = false;
        this.focused = false;
        // register the action
        this._hoverActionService.register(this);
        // watch for changes to the activeness of the container
        this.active$ = this._hoverActionService.active.subscribe(function (active) { return _this.active = active; });
    }
    /**
     * @return {?}
     */
    HoverActionDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._hoverActionService.unregister(this);
        this.active$.unsubscribe();
    };
    /**
     * @return {?}
     */
    HoverActionDirective.prototype.focus = /**
     * @return {?}
     */
    function () {
        this._elementRef.nativeElement.focus();
    };
    /**
     * @return {?}
     */
    HoverActionDirective.prototype.onFocus = /**
     * @return {?}
     */
    function () {
        this.focused = true;
        this._hoverActionService.updateVisibility();
    };
    /**
     * @return {?}
     */
    HoverActionDirective.prototype.onBlur = /**
     * @return {?}
     */
    function () {
        this.focused = false;
        this._hoverActionService.updateVisibility();
    };
    /**
     * @param {?} event
     * @return {?}
     */
    HoverActionDirective.prototype.previous = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.stopPropagation();
        this._hoverActionService.previous();
    };
    /**
     * @param {?} event
     * @return {?}
     */
    HoverActionDirective.prototype.next = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.stopPropagation();
        this._hoverActionService.next();
    };
    HoverActionDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[uxHoverAction]',
                    host: {
                        '[class.hover-action-active]': 'active',
                        '[class.hover-action-focused]': 'focused',
                        '[tabindex]': 'tabindex'
                    }
                },] },
    ];
    /** @nocollapse */
    HoverActionDirective.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: HoverActionService, },
    ]; };
    HoverActionDirective.propDecorators = {
        "tabindex": [{ type: Input },],
        "onFocus": [{ type: HostListener, args: ['focus',] },],
        "onBlur": [{ type: HostListener, args: ['blur',] },],
        "previous": [{ type: HostListener, args: ['keydown.arrowleft', ['$event'],] },],
        "next": [{ type: HostListener, args: ['keydown.arrowright', ['$event'],] },],
    };
    return HoverActionDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var /** @type {?} */ DECLARATIONS$8 = [
    HoverActionDirective,
    HoverActionContainerDirective
];
var HoverActionModule = (function () {
    function HoverActionModule() {
    }
    HoverActionModule.decorators = [
        { type: NgModule, args: [{
                    exports: DECLARATIONS$8,
                    declarations: DECLARATIONS$8
                },] },
    ];
    /** @nocollapse */
    HoverActionModule.ctorParameters = function () { return []; };
    return HoverActionModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var LayoutSwitcherItemDirective = (function () {
    function LayoutSwitcherItemDirective(_templateRef, _viewContainerRef) {
        this._templateRef = _templateRef;
        this._viewContainerRef = _viewContainerRef;
    }
    /**
     * @return {?}
     */
    LayoutSwitcherItemDirective.prototype.getLayout = /**
     * @return {?}
     */
    function () {
        return this._templateRef;
    };
    /**
     * @return {?}
     */
    LayoutSwitcherItemDirective.prototype.getConfig = /**
     * @return {?}
     */
    function () {
        return this._config;
    };
    /**
     * @return {?}
     */
    LayoutSwitcherItemDirective.prototype.activate = /**
     * @return {?}
     */
    function () {
        this._embeddedView = this._viewContainerRef.createEmbeddedView(this._templateRef);
    };
    /**
     * @return {?}
     */
    LayoutSwitcherItemDirective.prototype.deactivate = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ index = this._viewContainerRef.indexOf(this._embeddedView);
        this._viewContainerRef.remove(index);
        this._embeddedView = null;
    };
    LayoutSwitcherItemDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[uxLayoutSwitcherItem]'
                },] },
    ];
    /** @nocollapse */
    LayoutSwitcherItemDirective.ctorParameters = function () { return [
        { type: TemplateRef, },
        { type: ViewContainerRef, },
    ]; };
    LayoutSwitcherItemDirective.propDecorators = {
        "_config": [{ type: Input, args: ['uxLayoutSwitcherItem',] },],
    };
    return LayoutSwitcherItemDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var LayoutSwitcherDirective = (function () {
    function LayoutSwitcherDirective(_elementRef, resizeService, _viewContainerRef) {
        var _this = this;
        this._elementRef = _elementRef;
        this._viewContainerRef = _viewContainerRef;
        // watch for changes to the container size
        resizeService.addResizeListener(_elementRef.nativeElement).subscribe(function (event) {
            _this._width = event.width;
            // render the appropriate layout
            // render the appropriate layout
            _this.updateActiveLayout();
        });
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    LayoutSwitcherDirective.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        // if the active group has changed then render the appropriate layout
        if (changes["group"].currentValue !== changes["group"].previousValue) {
            this.updateActiveLayout();
        }
    };
    /**
     * @return {?}
     */
    LayoutSwitcherDirective.prototype.getActiveLayout = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // if there are currently no layouts then do nothing
        if (!this._layouts) {
            return null;
        }
        // otherwise find layouts that match the active group and that meet the constraints
        return this._layouts.filter(function (layout) { return _this.group === layout.getConfig().group; }).find(function (layout) {
            var /** @type {?} */ minWidth = layout.getConfig().minWidth || 0;
            var /** @type {?} */ maxWidth = layout.getConfig().maxWidth || Infinity;
            return _this._width >= minWidth && _this._width < maxWidth;
        });
    };
    /**
     * @return {?}
     */
    LayoutSwitcherDirective.prototype.updateActiveLayout = /**
     * @return {?}
     */
    function () {
        // get the layout that should be shown
        var /** @type {?} */ layout = this.getActiveLayout();
        // check if we are currently showing the layout
        if (this._activeLayout === layout) {
            return;
        }
        // remove the current layout
        if (this._activeLayout) {
            this._activeLayout.deactivate();
        }
        // store the new active layout
        this._activeLayout = layout;
        // if there is an active layout then activate
        if (this._activeLayout) {
            this._activeLayout.activate();
        }
    };
    /**
     * @return {?}
     */
    LayoutSwitcherDirective.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        // store the initial current element width
        this._width = this._elementRef.nativeElement.offsetWidth;
        // render the appropriate layout - need a delay as Angular doesn't like changes like this in these lifecycle hooks
        requestAnimationFrame(this.updateActiveLayout.bind(this));
    };
    LayoutSwitcherDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[uxLayoutSwitcher]'
                },] },
    ];
    /** @nocollapse */
    LayoutSwitcherDirective.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: ResizeService, },
        { type: ViewContainerRef, },
    ]; };
    LayoutSwitcherDirective.propDecorators = {
        "group": [{ type: Input },],
        "_layouts": [{ type: ContentChildren, args: [LayoutSwitcherItemDirective,] },],
    };
    return LayoutSwitcherDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var /** @type {?} */ DECLARATIONS$9 = [
    LayoutSwitcherDirective,
    LayoutSwitcherItemDirective
];
var LayoutSwitcherModule = (function () {
    function LayoutSwitcherModule() {
    }
    LayoutSwitcherModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        ResizeModule
                    ],
                    exports: DECLARATIONS$9,
                    declarations: DECLARATIONS$9,
                    providers: [],
                },] },
    ];
    /** @nocollapse */
    LayoutSwitcherModule.ctorParameters = function () { return []; };
    return LayoutSwitcherModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var OverflowDirective = (function () {
    function OverflowDirective(_elementRef) {
        this._elementRef = _elementRef;
        /**
         * Allow overflow to be within a range before emitting
         */
        this.tolerance = 0;
        /**
         * Emit when there is a change to the overflow state - horizontal or vertical
         */
        this.uxOverflowObserver = new EventEmitter();
        /**
         * Emit when there is a change to overflow on the horizontal axis
         */
        this.uxOverflowHorizontalObserver = new EventEmitter();
        /**
         * Emit when there is a change to overflow on the vertical axis
         */
        this.uxOverflowVerticalObserver = new EventEmitter();
        /**
         * Store the overflow state on both axis
         */
        this._state = { horizontalOverflow: false, verticalOverflow: false };
        /**
         * Unsubscribe from all the observables
         */
        this._onDestroy = new Subject$1();
    }
    /** Set up the trigger if specified */
    /**
     * Set up the trigger if specified
     * @return {?}
     */
    OverflowDirective.prototype.ngOnInit = /**
     * Set up the trigger if specified
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.trigger) {
            this.trigger.pipe(takeUntil(this._onDestroy)).subscribe(function () { return _this.checkForOverflow(); });
        }
    };
    /** Perform an intial check for overflow */
    /**
     * Perform an intial check for overflow
     * @return {?}
     */
    OverflowDirective.prototype.ngAfterViewInit = /**
     * Perform an intial check for overflow
     * @return {?}
     */
    function () {
        var _this = this;
        requestAnimationFrame(function () { return _this.checkForOverflow(); });
    };
    /** Unsubscribe from the trigger */
    /**
     * Unsubscribe from the trigger
     * @return {?}
     */
    OverflowDirective.prototype.ngOnDestroy = /**
     * Unsubscribe from the trigger
     * @return {?}
     */
    function () {
        this._onDestroy.next();
        this._onDestroy.complete();
    };
    /** Programmatically trigger check for overflow */
    /**
     * Programmatically trigger check for overflow
     * @return {?}
     */
    OverflowDirective.prototype.checkForOverflow = /**
     * Programmatically trigger check for overflow
     * @return {?}
     */
    function () {
        var _a = this._elementRef.nativeElement, offsetWidth = _a.offsetWidth, offsetHeight = _a.offsetHeight, scrollWidth = _a.scrollWidth, scrollHeight = _a.scrollHeight;
        var /** @type {?} */ horizontalOverflow = (scrollWidth - offsetWidth) > this.tolerance;
        var /** @type {?} */ verticalOverflow = (scrollHeight - offsetHeight) > this.tolerance;
        if (horizontalOverflow !== this._state.horizontalOverflow) {
            this.uxOverflowHorizontalObserver.emit(horizontalOverflow);
        }
        if (verticalOverflow !== this._state.verticalOverflow) {
            this.uxOverflowVerticalObserver.emit(verticalOverflow);
        }
        if (horizontalOverflow !== this._state.horizontalOverflow || verticalOverflow !== this._state.verticalOverflow) {
            this.uxOverflowObserver.emit((horizontalOverflow || verticalOverflow));
        }
        // store the state
        this._state = { horizontalOverflow: horizontalOverflow, verticalOverflow: verticalOverflow };
    };
    OverflowDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[uxOverflowObserver], [uxOverflowHorizontalObserver], [uxOverflowVerticalObserver]',
                    exportAs: 'ux-overflow-observer'
                },] },
    ];
    /** @nocollapse */
    OverflowDirective.ctorParameters = function () { return [
        { type: ElementRef, },
    ]; };
    OverflowDirective.propDecorators = {
        "trigger": [{ type: Input },],
        "tolerance": [{ type: Input },],
        "uxOverflowObserver": [{ type: Output },],
        "uxOverflowHorizontalObserver": [{ type: Output },],
        "uxOverflowVerticalObserver": [{ type: Output },],
    };
    return OverflowDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ObserversModule$1 = (function () {
    function ObserversModule$$1() {
    }
    ObserversModule$$1.decorators = [
        { type: NgModule, args: [{
                    exports: [OverflowDirective],
                    declarations: [OverflowDirective]
                },] },
    ];
    /** @nocollapse */
    ObserversModule$$1.ctorParameters = function () { return []; };
    return ObserversModule$$1;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/** @enum {number} */
var KeyCode = {
    UpArrow: 38,
    DownArrow: 40,
    Spacebar: 32,
};
KeyCode[KeyCode.UpArrow] = "UpArrow";
KeyCode[KeyCode.DownArrow] = "DownArrow";
KeyCode[KeyCode.Spacebar] = "Spacebar";

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var SelectionStrategy = (function () {
    function SelectionStrategy(selectionService) {
        this.selectionService = selectionService;
    }
    /**
     * @param {?} selectionService
     * @return {?}
     */
    SelectionStrategy.prototype.setSelectionService = /**
     * @param {?} selectionService
     * @return {?}
     */
    function (selectionService) {
        this.selectionService = selectionService;
    };
    /**
     * @param {?} event
     * @param {?} data
     * @return {?}
     */
    SelectionStrategy.prototype.mousedown = /**
     * @param {?} event
     * @param {?} data
     * @return {?}
     */
    function (event, data) { };
    /**
     * @param {?} event
     * @param {?} data
     * @return {?}
     */
    SelectionStrategy.prototype.click = /**
     * @param {?} event
     * @param {?} data
     * @return {?}
     */
    function (event, data) { };
    /**
     * @param {?} event
     * @param {?} data
     * @return {?}
     */
    SelectionStrategy.prototype.keydown = /**
     * @param {?} event
     * @param {?} data
     * @return {?}
     */
    function (event, data) { };
    /**
     * Select the item - default behavior
     */
    /**
     * Select the item - default behavior
     * @param {...?} data
     * @return {?}
     */
    SelectionStrategy.prototype.select = /**
     * Select the item - default behavior
     * @param {...?} data
     * @return {?}
     */
    function () {
        var data = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            data[_i] = arguments[_i];
        }
        (_a = this.selectionService).select.apply(_a, __spread(data));
        var _a;
    };
    /**
     * Toggle the item's selected state - default behavior
     */
    /**
     * Toggle the item's selected state - default behavior
     * @param {...?} data
     * @return {?}
     */
    SelectionStrategy.prototype.toggle = /**
     * Toggle the item's selected state - default behavior
     * @param {...?} data
     * @return {?}
     */
    function () {
        var data = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            data[_i] = arguments[_i];
        }
        (_a = this.selectionService).toggle.apply(_a, __spread(data));
        var _a;
    };
    /**
     * Deselect the item - default behavior
     */
    /**
     * Deselect the item - default behavior
     * @param {...?} data
     * @return {?}
     */
    SelectionStrategy.prototype.deselect = /**
     * Deselect the item - default behavior
     * @param {...?} data
     * @return {?}
     */
    function () {
        var data = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            data[_i] = arguments[_i];
        }
        (_a = this.selectionService).deselect.apply(_a, __spread(data));
        var _a;
    };
    /**
     * Select all items - default behavior
     */
    /**
     * Select all items - default behavior
     * @return {?}
     */
    SelectionStrategy.prototype.selectAll = /**
     * Select all items - default behavior
     * @return {?}
     */
    function () {
        this.select.apply(this, __spread(this.selectionService.dataset));
    };
    /**
     * Deselect all items - default behavior
     */
    /**
     * Deselect all items - default behavior
     * @return {?}
     */
    SelectionStrategy.prototype.deselectAll = /**
     * Deselect all items - default behavior
     * @return {?}
     */
    function () {
        this.deselect.apply(this, __spread(this.selectionService.dataset));
    };
    /**
     * @return {?}
     */
    SelectionStrategy.prototype.destroy = /**
     * @return {?}
     */
    function () { };
    return SelectionStrategy;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var RowSelectionStrategy = (function (_super) {
    __extends(RowSelectionStrategy, _super);
    function RowSelectionStrategy() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._selection = { start: null, end: null };
        return _this;
    }
    /**
     * By default on shift click the browser will highlight
     * text. This looks bad and we don't want this to occur
     */
    /**
     * By default on shift click the browser will highlight
     * text. This looks bad and we don't want this to occur
     * @param {?} event
     * @return {?}
     */
    RowSelectionStrategy.prototype.mousedown = /**
     * By default on shift click the browser will highlight
     * text. This looks bad and we don't want this to occur
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.preventDefault();
    };
    /**
     * When a row is clicked we want to handle selection
     */
    /**
     * When a row is clicked we want to handle selection
     * @param {?} event
     * @param {?} data
     * @return {?}
     */
    RowSelectionStrategy.prototype.click = /**
     * When a row is clicked we want to handle selection
     * @param {?} event
     * @param {?} data
     * @return {?}
     */
    function (event, data) {
        // determine which modifier keys are pressed
        var ctrlKey = event.ctrlKey, shiftKey = event.shiftKey;
        // if the shift key is pressed we want to perform a multiple selection
        if (shiftKey) {
            return this.multipleSelect(data);
        }
        // if the control key is pressed we want to perform an additive toggle selection
        if (ctrlKey) {
            return this.toggle(data);
        }
        // perform a single selection where all other rows are deselected
        this.singleSelect(data);
    };
    /**
     * To support full keyboard control we need to support the following:
     * 1. Arrow keys to navigate up and down
     * 2. Spacebar to toggle selection
     * 3. Shift + Arrow keys to multiple select
     * 4. Ctrl + Arrow keys to allow retained selection and navigation
     */
    /**
     * To support full keyboard control we need to support the following:
     * 1. Arrow keys to navigate up and down
     * 2. Spacebar to toggle selection
     * 3. Shift + Arrow keys to multiple select
     * 4. Ctrl + Arrow keys to allow retained selection and navigation
     * @param {?} event
     * @param {?} data
     * @return {?}
     */
    RowSelectionStrategy.prototype.keydown = /**
     * To support full keyboard control we need to support the following:
     * 1. Arrow keys to navigate up and down
     * 2. Spacebar to toggle selection
     * 3. Shift + Arrow keys to multiple select
     * 4. Ctrl + Arrow keys to allow retained selection and navigation
     * @param {?} event
     * @param {?} data
     * @return {?}
     */
    function (event, data) {
        switch (event.keyCode) {
            case KeyCode.UpArrow:
            case KeyCode.DownArrow:
                event.preventDefault();
                this.navigate(event, data);
                break;
            case KeyCode.Spacebar:
                event.preventDefault();
                this.selectionService.strategy.toggle(data, true);
                break;
        }
    };
    /**
     * Override the standard toggle function to store or clear the
     * most recently selected item
     */
    /**
     * Override the standard toggle function to store or clear the
     * most recently selected item
     * @param {?} data
     * @param {?=} activate
     * @return {?}
     */
    RowSelectionStrategy.prototype.toggle = /**
     * Override the standard toggle function to store or clear the
     * most recently selected item
     * @param {?} data
     * @param {?=} activate
     * @return {?}
     */
    function (data, activate) {
        if (activate === void 0) { activate = false; }
        _super.prototype.toggle.call(this, data);
        // store or clear the selection
        this.selectionService.isSelected(data) ? this.setSelectionStart(data) : this.clearSelection();
        // if we want to keep the item activated then activate
        if (activate) {
            this.selectionService.activate(data);
        }
    };
    /**
     * Clear all other selected items and select only
     * the most recently selected item
     * @param {?} data
     * @return {?}
     */
    RowSelectionStrategy.prototype.singleSelect = /**
     * Clear all other selected items and select only
     * the most recently selected item
     * @param {?} data
     * @return {?}
     */
    function (data) {
        // deselect all other rows if neither modifier key is pressed
        this.deselectAll();
        // select the current row
        this.select(data);
        // store the current item as the selection start
        this.setSelectionStart(data);
    };
    /**
     * Handle multiple selection:
     * 1. If no start item selected - select it
     * 2. If a start item has been selected - select all in between
     * 3. If a start and end item have been selected clear the range and then select the new range
     */
    /**
     * Handle multiple selection:
     * 1. If no start item selected - select it
     * 2. If a start item has been selected - select all in between
     * 3. If a start and end item have been selected clear the range and then select the new range
     * @param {?} data
     * @return {?}
     */
    RowSelectionStrategy.prototype.multipleSelect = /**
     * Handle multiple selection:
     * 1. If no start item selected - select it
     * 2. If a start item has been selected - select all in between
     * 3. If a start and end item have been selected clear the range and then select the new range
     * @param {?} data
     * @return {?}
     */
    function (data) {
        // if no selection currently exists then perform initial selection
        if (!this._selection.start) {
            // select the row
            this.select(data);
            // store the starting point
            return this.setSelectionStart(data);
        }
        // if a multiple selection already took place - clear the previous selection
        if (this._selection.start && this._selection.end) {
            this.deselect.apply(this, __spread(this.getSelectedItems()));
        }
        // set the new selection end point
        this.setSelectionEnd(data);
        // select all the items in the range
        this.select.apply(this, __spread(this.getSelectedItems()));
    };
    /**
     * Set the selection start point. If there was previously a
     * selection end point then clear it as this is a new selection
     * @param {?} data
     * @return {?}
     */
    RowSelectionStrategy.prototype.setSelectionStart = /**
     * Set the selection start point. If there was previously a
     * selection end point then clear it as this is a new selection
     * @param {?} data
     * @return {?}
     */
    function (data) {
        this._selection.start = data;
        this._selection.end = null;
        // activate the item
        this.selectionService.activate(data);
    };
    /**
     * Set the selection end point
     * @param {?} data
     * @return {?}
     */
    RowSelectionStrategy.prototype.setSelectionEnd = /**
     * Set the selection end point
     * @param {?} data
     * @return {?}
     */
    function (data) {
        this._selection.end = data;
        // activate the item
        this.selectionService.activate(data);
    };
    /**
     * Clear both start and end selection points
     */
    /**
     * Clear both start and end selection points
     * @param {?=} deactivate
     * @return {?}
     */
    RowSelectionStrategy.prototype.clearSelection = /**
     * Clear both start and end selection points
     * @param {?=} deactivate
     * @return {?}
     */
    function (deactivate) {
        if (deactivate === void 0) { deactivate = true; }
        // reset the selected item
        this._selection = { start: null, end: null };
        // remove the current active item
        if (deactivate) {
            this.selectionService.deactivate();
        }
    };
    /**
     * Determine all the items affected by the current selection.
     * Note that the end point may be above the start point so
     * we need to account for this.
     * @return {?}
     */
    RowSelectionStrategy.prototype.getSelectedItems = /**
     * Determine all the items affected by the current selection.
     * Note that the end point may be above the start point so
     * we need to account for this.
     * @return {?}
     */
    function () {
        // get the latest dataset
        var dataset = this.selectionService.dataset;
        // get the indexes of the start and end point
        var /** @type {?} */ startIdx = dataset.indexOf(this._selection.start);
        var /** @type {?} */ endIdx = dataset.indexOf(this._selection.end);
        // get the region of the array that is selected - note the endIdx may be before the startIdx so account for this
        return dataset.slice(Math.min(startIdx, endIdx), Math.max(startIdx, endIdx) + 1);
    };
    /**
     * Activate the sibling item when arrow keys are pressed
     * @param {?} event
     * @param {?} data
     * @return {?}
     */
    RowSelectionStrategy.prototype.navigate = /**
     * Activate the sibling item when arrow keys are pressed
     * @param {?} event
     * @param {?} data
     * @return {?}
     */
    function (event, data) {
        // determine which modifier keys are pressed
        var ctrlKey = event.ctrlKey, shiftKey = event.shiftKey;
        // if no modifier keys are pressed then deselect all and clear the selection
        if (!ctrlKey && !shiftKey) {
            this.deselectAll();
            this.clearSelection(false);
        }
        // activate the sibling - if the up arrow is pressed then navigate to the previous sibling
        var /** @type {?} */ sibling = this.selectionService.activateSibling(event.keyCode === KeyCode.UpArrow);
        // if the shift key is pressed then we also want to toggle the state if the item
        if (shiftKey && sibling) {
            // if there is no current selection start then select the current row
            if (!this._selection.start) {
                this.multipleSelect(data);
            }
            this.multipleSelect(sibling);
        }
    };
    return RowSelectionStrategy;
}(SelectionStrategy));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var RowAltSelectionStrategy = (function (_super) {
    __extends(RowAltSelectionStrategy, _super);
    function RowAltSelectionStrategy() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @param {?} event
     * @param {?} data
     * @return {?}
     */
    RowAltSelectionStrategy.prototype.keydown = /**
     * @param {?} event
     * @param {?} data
     * @return {?}
     */
    function (event, data) {
        switch (event.keyCode) {
            case KeyCode.UpArrow:
            case KeyCode.DownArrow:
                event.preventDefault();
                this.handleCursorKey(event, data);
                break;
            case KeyCode.Spacebar:
                event.preventDefault();
                this.selectionService.strategy.toggle(data);
                break;
        }
    };
    /**
     * Select the sibling item when arrow keys are pressed
     * @param {?} event
     * @param {?} data
     * @return {?}
     */
    RowAltSelectionStrategy.prototype.handleCursorKey = /**
     * Select the sibling item when arrow keys are pressed
     * @param {?} event
     * @param {?} data
     * @return {?}
     */
    function (event, data) {
        // determine which modifier keys are pressed
        var ctrlKey = event.ctrlKey, shiftKey = event.shiftKey;
        // if no modifier keys are pressed then deselect all and clear the selection
        if (!ctrlKey && !shiftKey) {
            this.deselectAll();
            this.clearSelection(false);
        }
        if (ctrlKey) {
            this.selectionService.activateSibling(event.keyCode === KeyCode.UpArrow);
        }
        else {
            var /** @type {?} */ sibling = this.selectionService.getSibling(event.keyCode === KeyCode.UpArrow);
            this.multipleSelect(sibling ? sibling : data);
        }
    };
    return RowAltSelectionStrategy;
}(RowSelectionStrategy));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var SimpleSelectionStrategy = (function (_super) {
    __extends(SimpleSelectionStrategy, _super);
    function SimpleSelectionStrategy() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * When the item is clicked simply toggle the current selected state
     */
    /**
     * When the item is clicked simply toggle the current selected state
     * @param {?} event
     * @param {?} data
     * @return {?}
     */
    SimpleSelectionStrategy.prototype.click = /**
     * When the item is clicked simply toggle the current selected state
     * @param {?} event
     * @param {?} data
     * @return {?}
     */
    function (event, data) {
        this.toggle(data);
    };
    /**
     * Add basic keyboard support for navigating
     * and selecting/deselecting items
     */
    /**
     * Add basic keyboard support for navigating
     * and selecting/deselecting items
     * @param {?} event
     * @param {?} data
     * @return {?}
     */
    SimpleSelectionStrategy.prototype.keydown = /**
     * Add basic keyboard support for navigating
     * and selecting/deselecting items
     * @param {?} event
     * @param {?} data
     * @return {?}
     */
    function (event, data) {
        switch (event.keyCode) {
            case KeyCode.UpArrow:
                event.preventDefault();
                return this.selectionService.activateSibling(true);
            case KeyCode.DownArrow:
                event.preventDefault();
                return this.selectionService.activateSibling(false);
            case KeyCode.Spacebar:
                event.preventDefault();
                return this.toggle(data);
        }
    };
    /**
     * Override the standard toggle function to always activate the item
     */
    /**
     * Override the standard toggle function to always activate the item
     * @param {?} data
     * @return {?}
     */
    SimpleSelectionStrategy.prototype.toggle = /**
     * Override the standard toggle function to always activate the item
     * @param {?} data
     * @return {?}
     */
    function (data) {
        _super.prototype.toggle.call(this, data);
        this.selectionService.activate(data);
    };
    return SimpleSelectionStrategy;
}(SelectionStrategy));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var SelectionService = (function () {
    function SelectionService() {
        this._selection = new Set();
        this.dataset = [];
        this.enabled = true;
        this.clickEnabled = true;
        this.keyboardEnabled = true;
        this.strategy = new SimpleSelectionStrategy(this);
        this.active$ = new BehaviorSubject(null);
        this.focusTarget$ = new BehaviorSubject(null);
        this.selection$ = new BehaviorSubject([]);
        this._strategyToDestroy = this.strategy;
    }
    /**
     * @return {?}
     */
    SelectionService.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this._strategyToDestroy) {
            this._strategyToDestroy.destroy();
        }
    };
    /**
     * If the item is not currently selected then add it
     * to the list of selected items
     */
    /**
     * If the item is not currently selected then add it
     * to the list of selected items
     * @param {...?} selections
     * @return {?}
     */
    SelectionService.prototype.select = /**
     * If the item is not currently selected then add it
     * to the list of selected items
     * @param {...?} selections
     * @return {?}
     */
    function () {
        var _this = this;
        var selections = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            selections[_i] = arguments[_i];
        }
        // add each selection to the set
        selections.forEach(function (selection) { return _this._selection.add(selection); });
        // propagate the changes
        this.selectionHasMutated();
    };
    /**
     * Remove an item from the list of selected items
     */
    /**
     * Remove an item from the list of selected items
     * @param {...?} selections
     * @return {?}
     */
    SelectionService.prototype.deselect = /**
     * Remove an item from the list of selected items
     * @param {...?} selections
     * @return {?}
     */
    function () {
        var _this = this;
        var selections = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            selections[_i] = arguments[_i];
        }
        // remove each item from the set
        selections.forEach(function (selection) { return _this._selection.delete(selection); });
        // propagate the changes
        this.selectionHasMutated();
    };
    /**
     * Toggle the selected state of any specified items
     */
    /**
     * Toggle the selected state of any specified items
     * @param {...?} selections
     * @return {?}
     */
    SelectionService.prototype.toggle = /**
     * Toggle the selected state of any specified items
     * @param {...?} selections
     * @return {?}
     */
    function () {
        var _this = this;
        var selections = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            selections[_i] = arguments[_i];
        }
        selections.forEach(function (selection) { return _this.isSelected(selection) ? _this.deselect(selection) : _this.select(selection); });
    };
    /**
     * Determine whether or not a specific item is currently selected
     */
    /**
     * Determine whether or not a specific item is currently selected
     * @param {?} data
     * @return {?}
     */
    SelectionService.prototype.isSelected = /**
     * Determine whether or not a specific item is currently selected
     * @param {?} data
     * @return {?}
     */
    function (data) {
        return this._selection.has(data);
    };
    /**
     * Return an observable specifically for notifying the subscriber
     * only when the selection state of a specific object has changed
     */
    /**
     * Return an observable specifically for notifying the subscriber
     * only when the selection state of a specific object has changed
     * @param {?} data
     * @return {?}
     */
    SelectionService.prototype.selected$ = /**
     * Return an observable specifically for notifying the subscriber
     * only when the selection state of a specific object has changed
     * @param {?} data
     * @return {?}
     */
    function (data) {
        var _this = this;
        return this.selection$.pipe(map(function () { return _this.isSelected(data); }), distinctUntilChanged());
    };
    /**
     * Define how selections should be performed.
     * This allows us to use an strategy pattern to handle the various keyboard
     * and mouse interactions while keeping each mode separated and
     * easily extensible if we want to add more modes in future!
     */
    /**
     * Define how selections should be performed.
     * This allows us to use an strategy pattern to handle the various keyboard
     * and mouse interactions while keeping each mode separated and
     * easily extensible if we want to add more modes in future!
     * @param {?} mode
     * @return {?}
     */
    SelectionService.prototype.setMode = /**
     * Define how selections should be performed.
     * This allows us to use an strategy pattern to handle the various keyboard
     * and mouse interactions while keeping each mode separated and
     * easily extensible if we want to add more modes in future!
     * @param {?} mode
     * @return {?}
     */
    function (mode) {
        if (this._strategyToDestroy) {
            // Destroy previous strategy if it was created internally
            this._strategyToDestroy.destroy();
            this._strategyToDestroy = null;
        }
        if (mode instanceof SelectionStrategy) {
            // Custom strategy - pass in the service instance
            this.strategy = mode;
            this.strategy.setSelectionService(this);
        }
        else {
            switch (mode.toLowerCase().trim()) {
                case 'simple':
                    this.strategy = this._strategyToDestroy = new SimpleSelectionStrategy(this);
                    break;
                case 'row':
                    this.strategy = this._strategyToDestroy = new RowSelectionStrategy(this);
                    break;
                case 'row-alt':
                    this.strategy = this._strategyToDestroy = new RowAltSelectionStrategy(this);
                    break;
                default:
                    throw new Error("The selection mode '" + mode + "' does not exist. Valid modes are 'simple', 'row', or 'row-alt'.");
            }
        }
    };
    /**
     * Set the current active item
     */
    /**
     * Set the current active item
     * @param {?} data
     * @return {?}
     */
    SelectionService.prototype.activate = /**
     * Set the current active item
     * @param {?} data
     * @return {?}
     */
    function (data) {
        this.active$.next(data);
    };
    /**
     * Deactive all items
     */
    /**
     * Deactive all items
     * @return {?}
     */
    SelectionService.prototype.deactivate = /**
     * Deactive all items
     * @return {?}
     */
    function () {
        this.active$.next(null);
    };
    /**
     * Return the next or previous sibling of the current active item.
     * @param previous If true, the previous sibling will be returned.
     */
    /**
     * Return the next or previous sibling of the current active item.
     * @param {?=} previous If true, the previous sibling will be returned.
     * @return {?}
     */
    SelectionService.prototype.getSibling = /**
     * Return the next or previous sibling of the current active item.
     * @param {?=} previous If true, the previous sibling will be returned.
     * @return {?}
     */
    function (previous) {
        if (previous === void 0) { previous = false; }
        // get the currently active item
        var /** @type {?} */ current = this.active$.getValue();
        // check if there is a current active item
        if (!current) {
            return;
        }
        // get the index of the current item
        var /** @type {?} */ idx = this.dataset.indexOf(current);
        var /** @type {?} */ target = this.dataset[previous ? idx - 1 : idx + 1];
        return target;
    };
    /**
     * Activate the sibling of the current active item.
     * If previous is set to true the previous sibling will be activated
     * rather than the next sibling. This function will also return the
     * data of the newly activated sibling
     */
    /**
     * Activate the sibling of the current active item.
     * If previous is set to true the previous sibling will be activated
     * rather than the next sibling. This function will also return the
     * data of the newly activated sibling
     * @param {?=} previous
     * @return {?}
     */
    SelectionService.prototype.activateSibling = /**
     * Activate the sibling of the current active item.
     * If previous is set to true the previous sibling will be activated
     * rather than the next sibling. This function will also return the
     * data of the newly activated sibling
     * @param {?=} previous
     * @return {?}
     */
    function (previous) {
        if (previous === void 0) { previous = false; }
        var /** @type {?} */ target = this.getSibling(previous);
        // check if the target exists
        if (target) {
            this.activate(target);
        }
        return target;
    };
    /**
     * @param {?} disabled
     * @return {?}
     */
    SelectionService.prototype.setDisabled = /**
     * @param {?} disabled
     * @return {?}
     */
    function (disabled) {
        // store the current disabled state
        this.enabled = !disabled;
        // clear any stateful data
        this.active$.next(null);
        this._selection.clear();
        // emit the selection change information
        this.selectionHasMutated();
    };
    /**
     * @return {?}
     */
    SelectionService.prototype.selectionHasMutated = /**
     * @return {?}
     */
    function () {
        this.selection$.next(Array.from(this._selection));
    };
    SelectionService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    SelectionService.ctorParameters = function () { return []; };
    return SelectionService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var SelectionItemDirective = (function () {
    function SelectionItemDirective(_selectionService, _elementRef) {
        this._selectionService = _selectionService;
        this._elementRef = _elementRef;
        this.tabindex = null;
        this.selectedChange = new EventEmitter();
        this.active = false;
        this._selected = false;
        this._managedTabIndex = -1;
        this._subscriptions = new Subscription();
    }
    Object.defineProperty(SelectionItemDirective.prototype, "selected", {
        get: /**
         * @return {?}
         */
        function () {
            return this._selected;
        },
        set: /**
         * @param {?} selected
         * @return {?}
         */
        function (selected) {
            selected ? this.select() : this.deselect();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionItemDirective.prototype, "attrTabIndex", {
        get: /**
         * @return {?}
         */
        function () {
            return (this.tabindex !== null) ? this.tabindex : this._managedTabIndex;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    SelectionItemDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // if there is no associated data then throw an error
        if (!this.uxSelectionItem) {
            throw new Error('The uxSelectionItem directive must have data associated with it.');
        }
        // subscribe to selection changes on this item
        this._subscriptions.add(this._selectionService.selected$(this.uxSelectionItem).subscribe(function (selected) {
            // store the selected state
            // store the selected state
            _this._selected = selected;
            // emit the selected state
            // emit the selected state
            _this.selectedChange.emit(selected);
        }));
        // subscribe to changes to the active state
        this._subscriptions.add(this._selectionService.active$.pipe(map(function (active) { return active === _this.uxSelectionItem; })).subscribe(function (active) {
            // store the focus state
            // store the focus state
            _this.active = active;
            // if it is active then focus the element
            if (active === true) {
                _this._selectionService.focusTarget$.next(_this.uxSelectionItem);
                _this._elementRef.nativeElement.focus();
            }
        }));
        // Subscribe to changes to the focus target
        // This is mostly the same as active$, except that it has an initial value of the first item in the collection.
        this._subscriptions.add(this._selectionService.focusTarget$.subscribe(function (focusTarget) {
            _this._managedTabIndex = (focusTarget === _this.uxSelectionItem) ? 0 : -1;
        }));
    };
    /**
     * @return {?}
     */
    SelectionItemDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._subscriptions.unsubscribe();
    };
    /**
     * @param {?} event
     * @return {?}
     */
    SelectionItemDirective.prototype.click = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this._selectionService.enabled && this._selectionService.clickEnabled) {
            this._selectionService.strategy.click(event, this.uxSelectionItem);
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    SelectionItemDirective.prototype.mousedown = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this._selectionService.enabled && this._selectionService.clickEnabled) {
            this._selectionService.strategy.mousedown(event, this.uxSelectionItem);
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    SelectionItemDirective.prototype.keydown = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this._selectionService.enabled && this._selectionService.keyboardEnabled) {
            this._selectionService.strategy.keydown(event, this.uxSelectionItem);
        }
    };
    /**
     * @return {?}
     */
    SelectionItemDirective.prototype.focus = /**
     * @return {?}
     */
    function () {
        // If tabbed to from outside the component, activate.
        if (this._selectionService.active$.getValue() !== this.uxSelectionItem) {
            this._selectionService.activate(this.uxSelectionItem);
        }
    };
    /**
     * Select this item using the current strategy
     */
    /**
     * Select this item using the current strategy
     * @return {?}
     */
    SelectionItemDirective.prototype.select = /**
     * Select this item using the current strategy
     * @return {?}
     */
    function () {
        if (this._selectionService.enabled) {
            this._selectionService.strategy.select(this.uxSelectionItem);
        }
    };
    /**
     * Deselect this item using the current strategy
     */
    /**
     * Deselect this item using the current strategy
     * @return {?}
     */
    SelectionItemDirective.prototype.deselect = /**
     * Deselect this item using the current strategy
     * @return {?}
     */
    function () {
        if (this._selectionService.enabled) {
            this._selectionService.strategy.deselect(this.uxSelectionItem);
        }
    };
    SelectionItemDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[uxSelectionItem]',
                    exportAs: 'ux-selection-item'
                },] },
    ];
    /** @nocollapse */
    SelectionItemDirective.ctorParameters = function () { return [
        { type: SelectionService, },
        { type: ElementRef, },
    ]; };
    SelectionItemDirective.propDecorators = {
        "uxSelectionItem": [{ type: Input },],
        "selected": [{ type: Input }, { type: HostBinding, args: ['class.ux-selection-selected',] },],
        "tabindex": [{ type: Input },],
        "selectedChange": [{ type: Output },],
        "active": [{ type: HostBinding, args: ['class.ux-selection-focused',] },],
        "attrTabIndex": [{ type: HostBinding, args: ['attr.tabindex',] },],
        "click": [{ type: HostListener, args: ['click', ['$event'],] },],
        "mousedown": [{ type: HostListener, args: ['mousedown', ['$event'],] },],
        "keydown": [{ type: HostListener, args: ['keydown', ['$event'],] },],
        "focus": [{ type: HostListener, args: ['focus',] },],
    };
    return SelectionItemDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var SelectionDirective = (function () {
    function SelectionDirective(_selectionService, _cdRef) {
        var _this = this;
        this._selectionService = _selectionService;
        this._cdRef = _cdRef;
        this.tabindex = null;
        this.uxSelectionChange = new EventEmitter();
        this._subscriptions = new Subscription();
        this._subscriptions.add(_selectionService.selection$.subscribe(function (items) { return _this.uxSelectionChange.emit(items); }));
    }
    Object.defineProperty(SelectionDirective.prototype, "uxSelection", {
        set: /**
         * @param {?} items
         * @return {?}
         */
        function (items) {
            (_a = this._selectionService).select.apply(_a, __spread(items));
            var _a;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionDirective.prototype, "disabled", {
        set: /**
         * @param {?} disabled
         * @return {?}
         */
        function (disabled) {
            this._selectionService.setDisabled(disabled);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionDirective.prototype, "mode", {
        set: /**
         * @param {?} mode
         * @return {?}
         */
        function (mode) {
            this._selectionService.setMode(mode);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionDirective.prototype, "clickSelection", {
        set: /**
         * @param {?} enabled
         * @return {?}
         */
        function (enabled) {
            this._selectionService.clickEnabled = enabled;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SelectionDirective.prototype, "keyboardSelection", {
        set: /**
         * @param {?} enabled
         * @return {?}
         */
        function (enabled) {
            this._selectionService.keyboardEnabled = enabled;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    SelectionDirective.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // provide the initial list of selection items
        this.update();
        // if the list changes then inform the service
        this._subscriptions.add(this.items.changes.subscribe(function () { return _this.update(); }));
        // The above could trigger a change in the computed tabindex for selection items
        this._cdRef.detectChanges();
    };
    /**
     * @return {?}
     */
    SelectionDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._subscriptions.unsubscribe();
    };
    /**
     * Update the dataset to reflect the latest selection items
     */
    /**
     * Update the dataset to reflect the latest selection items
     * @return {?}
     */
    SelectionDirective.prototype.update = /**
     * Update the dataset to reflect the latest selection items
     * @return {?}
     */
    function () {
        this._selectionService.dataset = this.items.map(function (item) { return item.uxSelectionItem; });
        // Make sure that a tab target has been defined so that the component can be tabbed to.
        if (this._selectionService.focusTarget$.getValue() === null && this._selectionService.dataset.length > 0) {
            this._selectionService.focusTarget$.next(this._selectionService.dataset[0]);
        }
    };
    /**
     * Select all the items in the list
     */
    /**
     * Select all the items in the list
     * @return {?}
     */
    SelectionDirective.prototype.selectAll = /**
     * Select all the items in the list
     * @return {?}
     */
    function () {
        if (this._selectionService.enabled) {
            this._selectionService.strategy.selectAll();
        }
    };
    /**
     * Deselect all currently selected items
     */
    /**
     * Deselect all currently selected items
     * @return {?}
     */
    SelectionDirective.prototype.deselectAll = /**
     * Deselect all currently selected items
     * @return {?}
     */
    function () {
        if (this._selectionService.enabled) {
            this._selectionService.strategy.deselectAll();
        }
    };
    SelectionDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[uxSelection]',
                    exportAs: 'ux-selection',
                    providers: [SelectionService]
                },] },
    ];
    /** @nocollapse */
    SelectionDirective.ctorParameters = function () { return [
        { type: SelectionService, },
        { type: ChangeDetectorRef, },
    ]; };
    SelectionDirective.propDecorators = {
        "uxSelection": [{ type: Input },],
        "disabled": [{ type: Input },],
        "mode": [{ type: Input },],
        "clickSelection": [{ type: Input },],
        "keyboardSelection": [{ type: Input },],
        "tabindex": [{ type: Input }, { type: HostBinding, args: ['attr.tabindex',] },],
        "uxSelectionChange": [{ type: Output },],
        "items": [{ type: ContentChildren, args: [SelectionItemDirective,] },],
    };
    return SelectionDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var SelectionModule = (function () {
    function SelectionModule() {
    }
    SelectionModule.decorators = [
        { type: NgModule, args: [{
                    imports: [
                        CommonModule
                    ],
                    declarations: [SelectionDirective, SelectionItemDirective],
                    exports: [SelectionDirective, SelectionItemDirective]
                },] },
    ];
    /** @nocollapse */
    SelectionModule.ctorParameters = function () { return []; };
    return SelectionModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ContactsNg1Component = (function (_super) {
    __extends(ContactsNg1Component, _super);
    function ContactsNg1Component(elementRef, injector) {
        var _this = _super.call(this, 'contactGroup', elementRef, injector) || this;
        _this.overflowClick = new EventEmitter();
        return _this;
    }
    ContactsNg1Component.decorators = [
        { type: Directive, args: [{
                    selector: 'contact-group'
                },] },
    ];
    /** @nocollapse */
    ContactsNg1Component.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: Injector, },
    ]; };
    ContactsNg1Component.propDecorators = {
        "contacts": [{ type: Input },],
        "organization": [{ type: Input },],
        "size": [{ type: Input },],
        "colors": [{ type: Input },],
        "maxContacts": [{ type: Input },],
        "overflowClick": [{ type: Output },],
    };
    return ContactsNg1Component;
}(UpgradeComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ExpandInputNg1Component = (function (_super) {
    __extends(ExpandInputNg1Component, _super);
    function ExpandInputNg1Component(elementRef, injector) {
        var _this = _super.call(this, 'expandInput', elementRef, injector) || this;
        _this.focus = new EventEmitter();
        return _this;
    }
    ExpandInputNg1Component.decorators = [
        { type: Directive, args: [{
                    selector: 'expand-input'
                },] },
    ];
    /** @nocollapse */
    ExpandInputNg1Component.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: Injector, },
    ]; };
    ExpandInputNg1Component.propDecorators = {
        "elname": [{ type: Input },],
        "placeHolder": [{ type: Input },],
        "className": [{ type: Input },],
        "clearTextIcon": [{ type: Input },],
        "closeSearch": [{ type: Input },],
        "expandAlways": [{ type: Input },],
        "onEnter": [{ type: Input },],
        "focus": [{ type: Output },],
    };
    return ExpandInputNg1Component;
}(UpgradeComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var FloatingActionButtonNg1Component = (function (_super) {
    __extends(FloatingActionButtonNg1Component, _super);
    function FloatingActionButtonNg1Component(elementRef, injector) {
        var _this = _super.call(this, 'floatingActionButton', elementRef, injector) || this;
        _this.items = [];
        return _this;
    }
    FloatingActionButtonNg1Component.decorators = [
        { type: Directive, args: [{
                    selector: 'floating-action-button'
                },] },
    ];
    /** @nocollapse */
    FloatingActionButtonNg1Component.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: Injector, },
    ]; };
    FloatingActionButtonNg1Component.propDecorators = {
        "items": [{ type: Input },],
        "primary": [{ type: Input },],
        "direction": [{ type: Input },],
        "fabTooltip": [{ type: Input },],
        "fabTooltipPlacement": [{ type: Input },],
    };
    return FloatingActionButtonNg1Component;
}(UpgradeComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var FlotNg1Component = (function (_super) {
    __extends(FlotNg1Component, _super);
    function FlotNg1Component(elementRef, injector) {
        var _this = _super.call(this, 'uxFlotNg1', elementRef, injector) || this;
        _this.onPlotClick = new EventEmitter();
        _this.onPlotHover = new EventEmitter();
        return _this;
    }
    FlotNg1Component.decorators = [
        { type: Directive, args: [{
                    selector: 'flot'
                },] },
    ];
    /** @nocollapse */
    FlotNg1Component.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: Injector, },
    ]; };
    FlotNg1Component.propDecorators = {
        "dataset": [{ type: Input },],
        "options": [{ type: Input },],
        "callback": [{ type: Input },],
        "donutLabels": [{ type: Input },],
        "onPlotClick": [{ type: Output },],
        "onPlotHover": [{ type: Output },],
    };
    return FlotNg1Component;
}(UpgradeComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var GridNg1Component = (function (_super) {
    __extends(GridNg1Component, _super);
    function GridNg1Component(elementRef, injector) {
        var _this = _super.call(this, 'grid', elementRef, injector) || this;
        _this.source = [];
        _this.columns = [];
        return _this;
    }
    GridNg1Component.decorators = [
        { type: Directive, args: [{
                    selector: 'grid'
                },] },
    ];
    /** @nocollapse */
    GridNg1Component.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: Injector, },
    ]; };
    GridNg1Component.propDecorators = {
        "source": [{ type: Input },],
        "columns": [{ type: Input },],
        "options": [{ type: Input },],
        "events": [{ type: Input },],
        "plugins": [{ type: Input },],
    };
    return GridNg1Component;
}(UpgradeComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var HierarchyBarNg1Component = (function (_super) {
    __extends(HierarchyBarNg1Component, _super);
    function HierarchyBarNg1Component(elementRef, injector) {
        return _super.call(this, 'hierarchyBar', elementRef, injector) || this;
    }
    HierarchyBarNg1Component.decorators = [
        { type: Directive, args: [{
                    selector: 'hierarchy-bar'
                },] },
    ];
    /** @nocollapse */
    HierarchyBarNg1Component.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: Injector, },
    ]; };
    HierarchyBarNg1Component.propDecorators = {
        "data": [{ type: Input },],
        "options": [{ type: Input },],
        "selectNode": [{ type: Input },],
        "containerClass": [{ type: Input },],
    };
    return HierarchyBarNg1Component;
}(UpgradeComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var MarqueeWizardNg1Component = (function (_super) {
    __extends(MarqueeWizardNg1Component, _super);
    function MarqueeWizardNg1Component(elementRef, injector) {
        var _this = _super.call(this, 'marqueeWizard', elementRef, injector) || this;
        _this.wizardStepsChange = new EventEmitter();
        return _this;
    }
    MarqueeWizardNg1Component.decorators = [
        { type: Directive, args: [{
                    selector: 'marquee-wizard'
                },] },
    ];
    /** @nocollapse */
    MarqueeWizardNg1Component.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: Injector, },
    ]; };
    MarqueeWizardNg1Component.propDecorators = {
        "wizardIcon": [{ type: Input },],
        "wizardSteps": [{ type: Input },],
        "buttonOptions": [{ type: Input },],
        "onChanging": [{ type: Input },],
        "onFinished": [{ type: Input },],
        "onFinishing": [{ type: Input },],
        "onCanceled": [{ type: Input },],
        "isVisited": [{ type: Input },],
        "sideInfo": [{ type: Input },],
        "wizardStepsChange": [{ type: Output },],
    };
    return MarqueeWizardNg1Component;
}(UpgradeComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var NestedDonutNg1Component = (function (_super) {
    __extends(NestedDonutNg1Component, _super);
    function NestedDonutNg1Component(elementRef, injector) {
        return _super.call(this, 'uxNestedDonutNg1', elementRef, injector) || this;
    }
    NestedDonutNg1Component.decorators = [
        { type: Directive, args: [{
                    selector: 'nested-donut'
                },] },
    ];
    /** @nocollapse */
    NestedDonutNg1Component.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: Injector, },
    ]; };
    NestedDonutNg1Component.propDecorators = {
        "dataset": [{ type: Input },],
        "options": [{ type: Input },],
    };
    return NestedDonutNg1Component;
}(UpgradeComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var OrganizationChartNg1Component = (function (_super) {
    __extends(OrganizationChartNg1Component, _super);
    function OrganizationChartNg1Component(elementRef, injector) {
        var _this = _super.call(this, 'uxOrganizationChartNg1', elementRef, injector) || this;
        _this.dataChange = new EventEmitter();
        _this.optionsChange = new EventEmitter();
        return _this;
    }
    OrganizationChartNg1Component.decorators = [
        { type: Directive, args: [{
                    selector: 'organization-chart'
                },] },
    ];
    /** @nocollapse */
    OrganizationChartNg1Component.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: Injector, },
    ]; };
    OrganizationChartNg1Component.propDecorators = {
        "data": [{ type: Input },],
        "options": [{ type: Input },],
        "dataChange": [{ type: Output },],
        "optionsChange": [{ type: Output },],
    };
    return OrganizationChartNg1Component;
}(UpgradeComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var PartitionMapNg1Component = (function (_super) {
    __extends(PartitionMapNg1Component, _super);
    function PartitionMapNg1Component(elementRef, injector) {
        return _super.call(this, 'uxPartitionMapNg1', elementRef, injector) || this;
    }
    PartitionMapNg1Component.decorators = [
        { type: Directive, args: [{
                    selector: 'partition-map'
                },] },
    ];
    /** @nocollapse */
    PartitionMapNg1Component.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: Injector, },
    ]; };
    PartitionMapNg1Component.propDecorators = {
        "chartData": [{ type: Input },],
        "chartOptions": [{ type: Input },],
        "chartLoading": [{ type: Input },],
    };
    return PartitionMapNg1Component;
}(UpgradeComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var PeityBarChartNg1Component = (function (_super) {
    __extends(PeityBarChartNg1Component, _super);
    function PeityBarChartNg1Component(elementRef, injector) {
        return _super.call(this, 'uxPeityBarChartNg1', elementRef, injector) || this;
    }
    PeityBarChartNg1Component.decorators = [
        { type: Directive, args: [{
                    selector: 'bar-chart'
                },] },
    ];
    /** @nocollapse */
    PeityBarChartNg1Component.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: Injector, },
    ]; };
    PeityBarChartNg1Component.propDecorators = {
        "data": [{ type: Input },],
        "options": [{ type: Input },],
    };
    return PeityBarChartNg1Component;
}(UpgradeComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var PeityLineChartNg1Component = (function (_super) {
    __extends(PeityLineChartNg1Component, _super);
    function PeityLineChartNg1Component(elementRef, injector) {
        return _super.call(this, 'uxPeityLineChartNg1', elementRef, injector) || this;
    }
    PeityLineChartNg1Component.decorators = [
        { type: Directive, args: [{
                    selector: 'line-chart'
                },] },
    ];
    /** @nocollapse */
    PeityLineChartNg1Component.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: Injector, },
    ]; };
    PeityLineChartNg1Component.propDecorators = {
        "data": [{ type: Input },],
        "options": [{ type: Input },],
    };
    return PeityLineChartNg1Component;
}(UpgradeComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var PeityPieChartNg1Component = (function (_super) {
    __extends(PeityPieChartNg1Component, _super);
    function PeityPieChartNg1Component(elementRef, injector) {
        return _super.call(this, 'uxPeityPieChartNg1', elementRef, injector) || this;
    }
    PeityPieChartNg1Component.decorators = [
        { type: Directive, args: [{
                    selector: 'pie-chart'
                },] },
    ];
    /** @nocollapse */
    PeityPieChartNg1Component.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: Injector, },
    ]; };
    PeityPieChartNg1Component.propDecorators = {
        "data": [{ type: Input },],
        "options": [{ type: Input },],
    };
    return PeityPieChartNg1Component;
}(UpgradeComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var PeityUpdatingLineChartNg1Component = (function (_super) {
    __extends(PeityUpdatingLineChartNg1Component, _super);
    function PeityUpdatingLineChartNg1Component(elementRef, injector) {
        return _super.call(this, 'uxPeityUpdatingLineChartNg1', elementRef, injector) || this;
    }
    PeityUpdatingLineChartNg1Component.decorators = [
        { type: Directive, args: [{
                    selector: 'updating-line-chart'
                },] },
    ];
    /** @nocollapse */
    PeityUpdatingLineChartNg1Component.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: Injector, },
    ]; };
    PeityUpdatingLineChartNg1Component.propDecorators = {
        "data": [{ type: Input },],
        "options": [{ type: Input },],
        "method": [{ type: Input },],
        "updateinterval": [{ type: Input },],
    };
    return PeityUpdatingLineChartNg1Component;
}(UpgradeComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var SankeyNg1Component = (function (_super) {
    __extends(SankeyNg1Component, _super);
    function SankeyNg1Component(elementRef, injector) {
        return _super.call(this, 'uxSankeyNg1', elementRef, injector) || this;
    }
    SankeyNg1Component.decorators = [
        { type: Directive, args: [{
                    selector: 'sankey'
                },] },
    ];
    /** @nocollapse */
    SankeyNg1Component.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: Injector, },
    ]; };
    SankeyNg1Component.propDecorators = {
        "chartSize": [{ type: Input },],
        "chartData": [{ type: Input },],
        "options": [{ type: Input },],
        "click": [{ type: Input },],
    };
    return SankeyNg1Component;
}(UpgradeComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var SearchToolbarNg1Component = (function (_super) {
    __extends(SearchToolbarNg1Component, _super);
    function SearchToolbarNg1Component(elementRef, injector) {
        return _super.call(this, 'searchToolbar', elementRef, injector) || this;
    }
    SearchToolbarNg1Component.decorators = [
        { type: Directive, args: [{
                    selector: 'search-toolbar'
                },] },
    ];
    /** @nocollapse */
    SearchToolbarNg1Component.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: Injector, },
    ]; };
    SearchToolbarNg1Component.propDecorators = {
        "searchTypeahead": [{ type: Input },],
        "placeHolder": [{ type: Input },],
        "closeSearch": [{ type: Input },],
        "onSearch": [{ type: Input },],
        "onFocus": [{ type: Input },],
    };
    return SearchToolbarNg1Component;
}(UpgradeComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var SelectTableNg1Component = (function (_super) {
    __extends(SelectTableNg1Component, _super);
    function SelectTableNg1Component(elementRef, injector) {
        var _this = _super.call(this, 'selectTable', elementRef, injector) || this;
        _this.selectedChange = new EventEmitter();
        return _this;
    }
    SelectTableNg1Component.decorators = [
        { type: Directive, args: [{
                    selector: 'select-table'
                },] },
    ];
    /** @nocollapse */
    SelectTableNg1Component.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: Injector, },
    ]; };
    SelectTableNg1Component.propDecorators = {
        "values": [{ type: Input },],
        "multipleSelect": [{ type: Input },],
        "selectKey": [{ type: Input },],
        "selected": [{ type: Input },],
        "searchText": [{ type: Input },],
        "tableHeight": [{ type: Input },],
        "selectHiddenItems": [{ type: Input },],
        "selectedChange": [{ type: Output },],
    };
    return SelectTableNg1Component;
}(UpgradeComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var /** @type {?} */ SLIDER_CHART_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(function () { return SliderChartNg1Component; }),
    multi: true
};
var SliderChartNg1Component = (function (_super) {
    __extends(SliderChartNg1Component, _super);
    function SliderChartNg1Component(elementRef, injector) {
        var _this = _super.call(this, 'sliderChart', elementRef, injector) || this;
        _this.ngModelChange = new EventEmitter();
        return _this;
    }
    /**
     * @param {?} obj
     * @return {?}
     */
    SliderChartNg1Component.prototype.writeValue = /**
     * @param {?} obj
     * @return {?}
     */
    function (obj) { };
    /**
     * @param {?} fn
     * @return {?}
     */
    SliderChartNg1Component.prototype.registerOnChange = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) { };
    /**
     * @param {?} fn
     * @return {?}
     */
    SliderChartNg1Component.prototype.registerOnTouched = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) { };
    SliderChartNg1Component.decorators = [
        { type: Directive, args: [{
                    selector: 'slider-chart',
                    providers: [SLIDER_CHART_VALUE_ACCESSOR]
                },] },
    ];
    /** @nocollapse */
    SliderChartNg1Component.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: Injector, },
    ]; };
    SliderChartNg1Component.propDecorators = {
        "sliderOptions": [{ type: Input },],
        "ngModel": [{ type: Input },],
        "chartOptions": [{ type: Input },],
        "chartData": [{ type: Input },],
        "ngModelChange": [{ type: Output },],
    };
    return SliderChartNg1Component;
}(UpgradeComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var SocialChartNg1Component = (function (_super) {
    __extends(SocialChartNg1Component, _super);
    function SocialChartNg1Component(elementRef, injector) {
        return _super.call(this, 'uxSocialChartNg1', elementRef, injector) || this;
    }
    SocialChartNg1Component.decorators = [
        { type: Directive, args: [{
                    selector: 'social-chart'
                },] },
    ];
    /** @nocollapse */
    SocialChartNg1Component.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: Injector, },
    ]; };
    SocialChartNg1Component.propDecorators = {
        "data": [{ type: Input },],
        "options": [{ type: Input },],
        "width": [{ type: Input },],
        "height": [{ type: Input },],
        "api": [{ type: Input },],
        "communities": [{ type: Input },],
        "detailStyle": [{ type: Input },],
        "popoverStyle": [{ type: Input },],
        "nodeDetail": [{ type: Input },],
        "edgeDetail": [{ type: Input },],
        "nodePopover": [{ type: Input },],
        "edgePopover": [{ type: Input },],
        "forceAtlasDuration": [{ type: Input },],
        "nodeSizeAttribute": [{ type: Input },],
        "startMaximized": [{ type: Input },],
        "startMaximised": [{ type: Input },],
        "showMaximizeControl": [{ type: Input },],
        "showMaximiseControl": [{ type: Input },],
        "socialChartContainer": [{ type: Input },],
        "fullscreenButtonPosition": [{ type: Input },],
        "localStrings": [{ type: Input },],
        "chartTitle": [{ type: Input },],
        "titleDisplayTime": [{ type: Input },],
        "edgeWeightInfluence": [{ type: Input },],
        "minLabels": [{ type: Input },],
    };
    return SocialChartNg1Component;
}(UpgradeComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var SortDirectionToggleNg1Component = (function (_super) {
    __extends(SortDirectionToggleNg1Component, _super);
    function SortDirectionToggleNg1Component(elementRef, injector) {
        return _super.call(this, 'sortDirectionToggle', elementRef, injector) || this;
    }
    SortDirectionToggleNg1Component.decorators = [
        { type: Directive, args: [{
                    selector: 'sort-direction-toggle'
                },] },
    ];
    /** @nocollapse */
    SortDirectionToggleNg1Component.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: Injector, },
    ]; };
    SortDirectionToggleNg1Component.propDecorators = {
        "label": [{ type: Input },],
        "sorters": [{ type: Input },],
        "descend": [{ type: Input },],
    };
    return SortDirectionToggleNg1Component;
}(UpgradeComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var TreeGridNg1Component = (function (_super) {
    __extends(TreeGridNg1Component, _super);
    function TreeGridNg1Component(elementRef, injector) {
        var _this = _super.call(this, 'treegrid', elementRef, injector) || this;
        _this.optionsChange = new EventEmitter();
        _this.selectedChange = new EventEmitter();
        _this.currentRowChange = new EventEmitter();
        _this.treeDataChange = new EventEmitter();
        return _this;
    }
    TreeGridNg1Component.decorators = [
        { type: Directive, args: [{
                    selector: 'treegrid'
                },] },
    ];
    /** @nocollapse */
    TreeGridNg1Component.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: Injector, },
    ]; };
    TreeGridNg1Component.propDecorators = {
        "data": [{ type: Input },],
        "columns": [{ type: Input },],
        "treeData": [{ type: Input },],
        "selected": [{ type: Input },],
        "currentRow": [{ type: Input },],
        "options": [{ type: Input },],
        "optionsChange": [{ type: Output },],
        "selectedChange": [{ type: Output },],
        "currentRowChange": [{ type: Output },],
        "treeDataChange": [{ type: Output },],
    };
    return TreeGridNg1Component;
}(UpgradeComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ThumbnailNg1Component = (function (_super) {
    __extends(ThumbnailNg1Component, _super);
    function ThumbnailNg1Component(elementRef, injector) {
        return _super.call(this, 'thumbnail', elementRef, injector) || this;
    }
    ThumbnailNg1Component.decorators = [
        { type: Directive, args: [{
                    selector: 'thumbnail'
                },] },
    ];
    /** @nocollapse */
    ThumbnailNg1Component.ctorParameters = function () { return [
        { type: ElementRef, },
        { type: Injector, },
    ]; };
    ThumbnailNg1Component.propDecorators = {
        "url": [{ type: Input },],
        "show": [{ type: Input },],
        "width": [{ type: Input },],
        "height": [{ type: Input },],
    };
    return ThumbnailNg1Component;
}(UpgradeComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var NavigationMenuService = (function () {
    function NavigationMenuService(_navigationMenuService) {
        this._navigationMenuService = _navigationMenuService;
    }
    /**
     * @return {?}
     */
    NavigationMenuService.prototype.show = /**
     * @return {?}
     */
    function () {
        this._navigationMenuService.show();
    };
    /**
     * @return {?}
     */
    NavigationMenuService.prototype.hide = /**
     * @return {?}
     */
    function () {
        this._navigationMenuService.hide();
    };
    /**
     * @return {?}
     */
    NavigationMenuService.prototype.visible = /**
     * @return {?}
     */
    function () {
        return this._navigationMenuService.visible();
    };
    /**
     * @return {?}
     */
    NavigationMenuService.prototype.collapseAtWidth = /**
     * @return {?}
     */
    function () {
        return this._navigationMenuService.collapseAtWidth();
    };
    /**
     * @param {?} width
     * @return {?}
     */
    NavigationMenuService.prototype.setCollapseAtWidth = /**
     * @param {?} width
     * @return {?}
     */
    function (width) {
        this._navigationMenuService.setCollapseAtWidth(width);
    };
    /**
     * @return {?}
     */
    NavigationMenuService.prototype.setDefaultCollapseAtWidth = /**
     * @return {?}
     */
    function () {
        this._navigationMenuService.setDefaultCollapseAtWidth();
    };
    NavigationMenuService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    NavigationMenuService.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: ['$navigationMenu',] },] },
    ]; };
    return NavigationMenuService;
}());
/**
 * @param {?} injector
 * @return {?}
 */
function navigationMenuServiceFactory(injector) {
    return injector.get('$navigationMenu');
}
var /** @type {?} */ navigationMenuServiceProvider = {
    provide: '$navigationMenu',
    useFactory: navigationMenuServiceFactory,
    deps: ['$injector']
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var PdfService = (function () {
    function PdfService(_pdfService) {
        this._pdfService = _pdfService;
    }
    /**
     * @param {?} columns
     * @param {?} rows
     * @param {?=} options
     * @return {?}
     */
    PdfService.prototype.createTable = /**
     * @param {?} columns
     * @param {?} rows
     * @param {?=} options
     * @return {?}
     */
    function (columns, rows, options) {
        if (options === void 0) { options = {}; }
        return this._pdfService.createTable(columns, rows, options);
    };
    PdfService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    PdfService.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: ['$pdf',] },] },
    ]; };
    return PdfService;
}());
/**
 * @param {?} injector
 * @return {?}
 */
function pdfServiceFactory(injector) {
    return injector.get('$pdf');
}
var /** @type {?} */ pdfServiceProvider = {
    provide: '$pdf',
    useFactory: pdfServiceFactory,
    deps: ['$injector']
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var TimeAgoService = (function () {
    function TimeAgoService(_timeAgoService) {
        this._timeAgoService = _timeAgoService;
    }
    /**
     * @param {?} strings
     * @return {?}
     */
    TimeAgoService.prototype.setStrings = /**
     * @param {?} strings
     * @return {?}
     */
    function (strings) {
        this._timeAgoService.setStrings(strings);
    };
    /**
     * @param {?} past
     * @param {?} present
     * @return {?}
     */
    TimeAgoService.prototype.timeSince = /**
     * @param {?} past
     * @param {?} present
     * @return {?}
     */
    function (past, present) {
        return this._timeAgoService.timeSince(past, present);
    };
    /**
     * @param {?} moment
     * @return {?}
     */
    TimeAgoService.prototype.timeSinceNow = /**
     * @param {?} moment
     * @return {?}
     */
    function (moment) {
        return this._timeAgoService.timeSinceNow(moment);
    };
    TimeAgoService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    TimeAgoService.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: ['timeAgoService',] },] },
    ]; };
    return TimeAgoService;
}());
/**
 * @param {?} injector
 * @return {?}
 */
function timeAgoServiceFactory(injector) {
    return injector.get('timeAgoService');
}
var /** @type {?} */ timeAgoServiceProvider = {
    provide: 'timeAgoService',
    useFactory: timeAgoServiceFactory,
    deps: ['$injector']
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var /** @type {?} */ declarations = [
    ContactsNg1Component,
    ExpandInputNg1Component,
    FloatingActionButtonNg1Component,
    FlotNg1Component,
    GridNg1Component,
    HierarchyBarNg1Component,
    MarqueeWizardNg1Component,
    NestedDonutNg1Component,
    OrganizationChartNg1Component,
    PartitionMapNg1Component,
    PeityBarChartNg1Component,
    PeityLineChartNg1Component,
    PeityPieChartNg1Component,
    PeityUpdatingLineChartNg1Component,
    SankeyNg1Component,
    SearchToolbarNg1Component,
    SelectTableNg1Component,
    SliderChartNg1Component,
    SocialChartNg1Component,
    SortDirectionToggleNg1Component,
    TreeGridNg1Component,
    ThumbnailNg1Component,
];
var HybridModule = (function () {
    function HybridModule() {
    }
    HybridModule.decorators = [
        { type: NgModule, args: [{
                    imports: [],
                    exports: declarations,
                    declarations: declarations,
                    providers: [
                        navigationMenuServiceProvider,
                        pdfServiceProvider,
                        timeAgoServiceProvider,
                        TimeAgoService,
                        PdfService,
                        NavigationMenuService,
                    ],
                },] },
    ];
    /** @nocollapse */
    HybridModule.ctorParameters = function () { return []; };
    return HybridModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var StringFilterPipe = (function () {
    function StringFilterPipe() {
    }
    /**
     * @param {?} items
     * @param {?} value
     * @return {?}
     */
    StringFilterPipe.prototype.transform = /**
     * @param {?} items
     * @param {?} value
     * @return {?}
     */
    function (items, value) {
        if (!items) {
            return [];
        }
        return items.filter(function (it) { return it.toLowerCase().indexOf(value.toLowerCase()) >= 0; });
    };
    StringFilterPipe.decorators = [
        { type: Pipe, args: [{
                    name: 'stringFilter'
                },] },
        { type: Injectable },
    ];
    /** @nocollapse */
    StringFilterPipe.ctorParameters = function () { return []; };
    return StringFilterPipe;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var StringFilterModule = (function () {
    function StringFilterModule() {
    }
    StringFilterModule.decorators = [
        { type: NgModule, args: [{
                    exports: [StringFilterPipe],
                    declarations: [StringFilterPipe]
                },] },
    ];
    /** @nocollapse */
    StringFilterModule.ctorParameters = function () { return []; };
    return StringFilterModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var CookieAdapter = (function () {
    function CookieAdapter() {
    }
    /**
     * @param {?} key
     * @return {?}
     */
    CookieAdapter.prototype.getItem = /**
     * @param {?} key
     * @return {?}
     */
    function (key) {
        if (document.cookie) {
            // get all the cookies for this site
            var /** @type {?} */ cookies = document.cookie.split(';');
            // process the cookies into a from we can easily manage
            var /** @type {?} */ match = cookies
                .map(function (cookie) { return ({ key: cookie.split('=')[0].trim(), value: cookie.split('=')[1].trim() }); })
                .find(function (cookie) { return cookie.key === key; });
            return match ? match.value : null;
        }
        return null;
    };
    /**
     * @param {?} key
     * @param {?} value
     * @return {?}
     */
    CookieAdapter.prototype.setItem = /**
     * @param {?} key
     * @param {?} value
     * @return {?}
     */
    function (key, value) {
        document.cookie = key + "=" + value + "; path=/";
    };
    /**
     * @param {?} key
     * @return {?}
     */
    CookieAdapter.prototype.removeItem = /**
     * @param {?} key
     * @return {?}
     */
    function (key) {
        document.cookie.split(';').forEach(function (cookie) {
            var /** @type {?} */ eqPos = cookie.indexOf('=');
            var /** @type {?} */ name = eqPos > -1 ? cookie.substr(0, eqPos).trim() : cookie;
            if (name === key) {
                document.cookie = cookie.trim().replace(/=.*/, "=;expires=" + new Date().toUTCString() + ";path=/");
            }
        });
    };
    /**
     * @return {?}
     */
    CookieAdapter.prototype.clear = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // call remove item on each cookie
        document.cookie.split(';').map(function (cookie) { return cookie.split('=')[0].trim(); })
            .forEach(function (cookie) { return _this.removeItem(cookie); });
    };
    /**
     * @return {?}
     */
    CookieAdapter.prototype.getSupported = /**
     * @return {?}
     */
    function () {
        // cookies are supported in all browsers
        return this;
    };
    return CookieAdapter;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var LocalStorageAdapter = (function () {
    function LocalStorageAdapter() {
    }
    /**
     * @param {?} key
     * @return {?}
     */
    LocalStorageAdapter.prototype.getItem = /**
     * @param {?} key
     * @return {?}
     */
    function (key) {
        return localStorage.getItem(key);
    };
    /**
     * @param {?} key
     * @param {?} value
     * @return {?}
     */
    LocalStorageAdapter.prototype.setItem = /**
     * @param {?} key
     * @param {?} value
     * @return {?}
     */
    function (key, value) {
        localStorage.setItem(key, value);
    };
    /**
     * @param {?} key
     * @return {?}
     */
    LocalStorageAdapter.prototype.removeItem = /**
     * @param {?} key
     * @return {?}
     */
    function (key) {
        localStorage.removeItem(key);
    };
    /**
     * @return {?}
     */
    LocalStorageAdapter.prototype.clear = /**
     * @return {?}
     */
    function () {
        localStorage.clear();
    };
    /**
     * @return {?}
     */
    LocalStorageAdapter.prototype.getSupported = /**
     * @return {?}
     */
    function () {
        // if local storage variable does not exist fall back to cookies
        if (!localStorage) {
            return new CookieAdapter();
        }
        // try to make a test save to local storage to see if there are any exceptions
        try {
            localStorage.setItem('ux-persistent-data-service', 'ux-persistent-data-service');
            localStorage.removeItem('ux-persistent-data-service');
            return this;
        }
        catch (/** @type {?} */ err) {
            return new CookieAdapter();
        }
    };
    return LocalStorageAdapter;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var SessionStorageAdapter = (function () {
    function SessionStorageAdapter() {
    }
    /**
     * @param {?} key
     * @return {?}
     */
    SessionStorageAdapter.prototype.getItem = /**
     * @param {?} key
     * @return {?}
     */
    function (key) {
        return sessionStorage.getItem(key);
    };
    /**
     * @param {?} key
     * @param {?} value
     * @return {?}
     */
    SessionStorageAdapter.prototype.setItem = /**
     * @param {?} key
     * @param {?} value
     * @return {?}
     */
    function (key, value) {
        sessionStorage.setItem(key, value);
    };
    /**
     * @param {?} key
     * @return {?}
     */
    SessionStorageAdapter.prototype.removeItem = /**
     * @param {?} key
     * @return {?}
     */
    function (key) {
        sessionStorage.removeItem(key);
    };
    /**
     * @return {?}
     */
    SessionStorageAdapter.prototype.clear = /**
     * @return {?}
     */
    function () {
        sessionStorage.clear();
    };
    /**
     * @return {?}
     */
    SessionStorageAdapter.prototype.getSupported = /**
     * @return {?}
     */
    function () {
        // if local storage variable does not exist fall back to cookies
        if (!sessionStorage) {
            return new CookieAdapter();
        }
        // try to make a test save to local storage to see if there are any exceptions
        try {
            sessionStorage.setItem('ux-persistent-data-service', 'ux-persistent-data-service');
            sessionStorage.removeItem('ux-persistent-data-service');
            return this;
        }
        catch (/** @type {?} */ err) {
            return new CookieAdapter();
        }
    };
    return SessionStorageAdapter;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var PersistentDataService = (function () {
    function PersistentDataService() {
    }
    /**
     * Save the item in some form of persistent storage
     */
    /**
     * Save the item in some form of persistent storage
     * @param {?} key
     * @param {?} value
     * @param {?=} type
     * @return {?}
     */
    PersistentDataService.prototype.setItem = /**
     * Save the item in some form of persistent storage
     * @param {?} key
     * @param {?} value
     * @param {?=} type
     * @return {?}
     */
    function (key, value, type) {
        if (type === void 0) { type = PersistentDataStorageType.LocalStorage; }
        this.getAdapter(type).setItem(key, value);
    };
    /**
     * Get a stored value from persistent storage
     */
    /**
     * Get a stored value from persistent storage
     * @param {?} key
     * @param {?=} type
     * @return {?}
     */
    PersistentDataService.prototype.getItem = /**
     * Get a stored value from persistent storage
     * @param {?} key
     * @param {?=} type
     * @return {?}
     */
    function (key, type) {
        if (type === void 0) { type = PersistentDataStorageType.LocalStorage; }
        return this.getAdapter(type).getItem(key);
    };
    /**
     * Remove a stored value from persistent storage
     */
    /**
     * Remove a stored value from persistent storage
     * @param {?} key
     * @param {?=} type
     * @return {?}
     */
    PersistentDataService.prototype.removeItem = /**
     * Remove a stored value from persistent storage
     * @param {?} key
     * @param {?=} type
     * @return {?}
     */
    function (key, type) {
        if (type === void 0) { type = PersistentDataStorageType.LocalStorage; }
        this.getAdapter(type).removeItem(key);
    };
    /**
     * Remove a stored value from persistent storage
     */
    /**
     * Remove a stored value from persistent storage
     * @param {?=} type
     * @return {?}
     */
    PersistentDataService.prototype.clear = /**
     * Remove a stored value from persistent storage
     * @param {?=} type
     * @return {?}
     */
    function (type) {
        if (type === void 0) { type = PersistentDataStorageType.LocalStorage; }
        this.getAdapter(type).clear();
    };
    /**
     * Return the appropriate adapter based on the type requested
     * @param {?} type
     * @return {?}
     */
    PersistentDataService.prototype.getAdapter = /**
     * Return the appropriate adapter based on the type requested
     * @param {?} type
     * @return {?}
     */
    function (type) {
        switch (type) {
            case PersistentDataStorageType.Cookie:
                return new CookieAdapter();
            case PersistentDataStorageType.LocalStorage:
                var /** @type {?} */ localStorageAdapter = new LocalStorageAdapter();
                return localStorageAdapter.getSupported();
            case PersistentDataStorageType.SessionStorage:
                var /** @type {?} */ sessionStorageAdapter = new SessionStorageAdapter();
                return sessionStorageAdapter.getSupported();
        }
    };
    PersistentDataService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    PersistentDataService.ctorParameters = function () { return []; };
    return PersistentDataService;
}());
/** @enum {number} */
var PersistentDataStorageType = {
    LocalStorage: 0,
    Cookie: 1,
    SessionStorage: 2,
};
PersistentDataStorageType[PersistentDataStorageType.LocalStorage] = "LocalStorage";
PersistentDataStorageType[PersistentDataStorageType.Cookie] = "Cookie";
PersistentDataStorageType[PersistentDataStorageType.SessionStorage] = "SessionStorage";

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var PersistentDataModule = (function () {
    function PersistentDataModule() {
    }
    PersistentDataModule.decorators = [
        { type: NgModule, args: [{
                    providers: [PersistentDataService],
                },] },
    ];
    /** @nocollapse */
    PersistentDataModule.ctorParameters = function () { return []; };
    return PersistentDataModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * @abstract
 */
var  /**
 * @abstract
 */
StorageAdapter = (function () {
    function StorageAdapter() {
    }
    return StorageAdapter;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

export { BreadcrumbsComponent, BreadcrumbsModule, CardTabsModule, CardTabsService, CardTabsetComponent, CardTabComponent, CardTabContentDirective, CheckboxModule, CHECKBOX_VALUE_ACCESSOR, CheckboxComponent, ColumnSortingModule, ColumnSortingComponent, ColumnSortingState, ColumnSortingDirective, ConduitSubject, ConduitZoneComponent, ConduitZone, ConduitComponent, CONDUITS, Conduit, defaultConduitProps, DashboardModule, DashboardComponent, DashboardService, defaultOptions, ActionDirection, Rounding, DashboardDragHandleDirective, DashboardWidgetComponent, DateTimePickerModule, DateTimePickerComponent, DateTimePickerService, DatePickerMode, ModeDirection, DatePickerHeaderEvent, DateTimePickerConfig, EboxModule, EboxComponent, EboxHeaderDirective, EboxContentDirective, FacetsModule, FacetContainerComponent, FacetSelect, FacetDeselect, FacetDeselectAll, FacetHeaderComponent, FacetBaseComponent, FacetCheckListComponent, FacetTypeaheadListComponent, FacetTypeaheadHighlight, Facet, FilterModule, FilterContainerComponent, FilterAddEvent, FilterRemoveEvent, FilterRemoveAllEvent, FilterBaseComponent, FilterDropdownComponent, FilterDynamicComponent, FlippableCardModule, FlippableCardComponent, FlippableCardFrontDirective, FlippableCardBackDirective, FloatingActionButtonsModule, FloatingActionButtonsComponent, FloatingActionButtonComponent, HierarchyBarModule, HierarchyBarService, HierarchyBarComponent, ItemDisplayPanelModule, ItemDisplayPanelContentDirective, ItemDisplayPanelFooterDirective, ItemDisplayPanelComponent, MarqueeWizardStepComponent, MarqueeWizardComponent, MarqueeWizardModule, MediaPlayerModule, MediaPlayerComponent, MediaPlayerBaseExtensionDirective, MediaPlayerControlsExtensionComponent, MediaPlayerTimelineExtensionComponent, NavigationModule, NavigationComponent, NavigationItemComponent, NotificationModule, NotificationService, NotificationListComponent, NumberPickerModule, NUMBER_PICKER_VALUE_ACCESSOR, NumberPickerComponent, PageHeaderModule, PageHeaderComponent, PageHeaderNavigationComponent, PageHeaderIconMenuComponent, PageHeaderCustomMenuDirective, PopoverModule, PopoverComponent, PopoverDirective, ProgressBarModule, ProgressBarComponent, RadioButtonModule, RADIOBUTTON_VALUE_ACCESSOR, RadioButtonComponent, SearchBuilderGroupComponent, SearchBuilderGroupService, SearchBuilderOutletDirective, BaseSearchComponent, SearchTextComponent, SearchDateComponent, SearchDateRangeComponent, SearchSelectComponent, SearchBuilderComponent, SearchBuilderService, SearchBuilderModule, SELECT_VALUE_ACCESSOR, SelectComponent, SelectModule, SidePanelComponent, SidePanelCloseDirective, SidePanelModule, SliderModule, SliderComponent, SliderType, SliderStyle, SliderSize, SliderCalloutTrigger, SliderSnap, SliderTickType, SliderThumbEvent, SliderThumb, SparkModule, SparkComponent, SpinButtonModule, SPIN_BUTTON_VALUE_ACCESSOR, SpinButtonComponent, TabsetModule, TabsetComponent, TabsetService, TabComponent, TabHeadingDirective, TabFocusDirective, TagInputEvent, TagInputComponent, TagInputModule, TimePickerModule, TIME_PICKER_VALUE_ACCESSOR, TimePickerComponent, TimeFormatPipe, TimelineModule, TimelineComponent, TimelineEventComponent, ToggleSwitchModule, ToggleSwitchComponent, ToolbarSearchModule, ToolbarSearchComponent, ToolbarSearchFieldDirective, ToolbarSearchButtonDirective, TooltipModule, TooltipComponent, TooltipDirective$1 as TooltipDirective, TooltipService, TypeaheadOptionEvent, TypeaheadKeyService, TypeaheadComponent, TypeaheadModule$1 as TypeaheadModule, VirtualScrollModule, VirtualScrollComponent, VirtualScrollLoadingDirective, VirtualScrollLoadButtonDirective, VirtualScrollCellDirective, WizardModule, WizardComponent, StepChangingEvent, WizardStepComponent, AutoGrowModule, AutoGrowDirective, ClickOutsideModule, ClickOutsideDirective, DragModule, DragDirective, FixedHeaderTableModule, FixedHeaderTableDirective, FloatLabelDirective, FloatLabelModule, FocusIfDirective, FocusIfModule, HelpCenterModule, HelpCenterService, HelpCenterItemDirective, HoverActionModule, HoverActionContainerDirective, HoverActionDirective, InfiniteScrollDirective, InfiniteScrollLoadingEvent, InfiniteScrollLoadedEvent, InfiniteScrollLoadErrorEvent, InfiniteScrollLoadButtonDirective, InfiniteScrollLoadingDirective, InfiniteScrollModule, LayoutSwitcherModule, LayoutSwitcherDirective, LayoutSwitcherItemDirective, MenuNavigationItemDirective, MenuNavigationDirective, MenuNavigationModule, ObserversModule$1 as ObserversModule, OverflowDirective, ReorderableModule, ReorderableDirective, ReorderableHandleDirective, ReorderableModelDirective, ReorderableService, ReorderableGroup, ResizeService, ResizeDirective, ResizeModule, ScrollModule as ScrollIntoViewIfModule, ScrollIntoViewIfDirective, ScrollIntoViewDirective, ScrollIntoViewService, ScrollModule, SelectionItemDirective, SelectionDirective, SelectionModule, SelectionService, SelectionStrategy, ContactsNg1Component, ExpandInputNg1Component, FloatingActionButtonNg1Component, FlotNg1Component, GridNg1Component, HierarchyBarNg1Component, MarqueeWizardNg1Component, NestedDonutNg1Component, OrganizationChartNg1Component, PartitionMapNg1Component, PeityBarChartNg1Component, PeityLineChartNg1Component, PeityPieChartNg1Component, PeityUpdatingLineChartNg1Component, SankeyNg1Component, SearchToolbarNg1Component, SelectTableNg1Component, SLIDER_CHART_VALUE_ACCESSOR, SliderChartNg1Component, SocialChartNg1Component, SortDirectionToggleNg1Component, TreeGridNg1Component, ThumbnailNg1Component, NavigationMenuService, navigationMenuServiceFactory, navigationMenuServiceProvider, PdfService, pdfServiceFactory, pdfServiceProvider, TimeAgoService, timeAgoServiceFactory, timeAgoServiceProvider, HybridModule, DurationPipeModule, DurationPipe, FileSizePipeModule, FileSizePipe, StringFilterPipe, StringFilterModule, AudioServiceModule, AudioService, ColorServiceModule, ColorService, ThemeColor, colorSets, FrameExtractionModule, FrameExtractionService, PersistentDataModule, PersistentDataService, PersistentDataStorageType, StorageAdapter, CookieAdapter, LocalStorageAdapter, SessionStorageAdapter, DayViewComponent as ɵd, DayViewService as ɵe, HeaderComponent as ɵc, MonthViewComponent as ɵf, MonthViewService as ɵg, TimeViewComponent as ɵj, YearViewComponent as ɵh, YearViewService as ɵi, FloatingActionButtonsService as ɵk, MarqueeWizardService as ɵm, MediaPlayerService as ɵn, PageHeaderNavigationDropdownItemComponent as ɵs, PageHeaderNavigationItemComponent as ɵr, PageHeaderNavigationSecondaryItemDirective as ɵt, PageHeaderService as ɵq, SidePanelService as ɵl, TypeaheadHighlightDirective as ɵv, TypeaheadService as ɵu, HoverActionService as ɵw, MenuNavigationToggleDirective as ɵp, MenuNavigationService as ɵo };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXgtYXNwZWN0cy11eC1hc3BlY3RzLmpzLm1hcCIsInNvdXJjZXMiOlsibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvYnJlYWRjcnVtYnMvYnJlYWRjcnVtYnMuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvYnJlYWRjcnVtYnMvYnJlYWRjcnVtYnMubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvcmVzaXplL3Jlc2l6ZS5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvcmVzaXplL3Jlc2l6ZS5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9yZXNpemUvcmVzaXplLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2NhcmQtdGFicy9jYXJkLXRhYi9jYXJkLXRhYi1jb250ZW50LmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2NhcmQtdGFicy9jYXJkLXRhYnMuc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2NhcmQtdGFicy9jYXJkLXRhYi9jYXJkLXRhYi5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9jYXJkLXRhYnMvY2FyZC10YWJzZXQvY2FyZC10YWJzZXQuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvY2FyZC10YWJzL2NhcmQtdGFicy5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9jaGVja2JveC9jaGVja2JveC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9jaGVja2JveC9jaGVja2JveC5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9jb2x1bW4tc29ydGluZy9jb2x1bW4tc29ydGluZy5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9jb2x1bW4tc29ydGluZy9jb2x1bW4tc29ydGluZy5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9jb2x1bW4tc29ydGluZy9jb2x1bW4tc29ydGluZy5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9jb25kdWl0L2NvbmR1aXQtc3ViamVjdC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2NvbmR1aXQvY29uZHVpdC11dGlscy50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2NvbmR1aXQvY29uZHVpdC16b25lLnNlcnZpY2UudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9jb25kdWl0L2NvbmR1aXQuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvY29uZHVpdC9jb25kdWl0LXpvbmUuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvY29uZHVpdC9pbnRlcmZhY2VzL2NvbmR1aXQtcHJvcGVydGllcy50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2NvbmR1aXQvY29uZHVpdC5kZWNvcmF0b3IudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9kYXNoYm9hcmQvZGFzaGJvYXJkLnNlcnZpY2UudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9kYXNoYm9hcmQvZGFzaGJvYXJkLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2Rhc2hib2FyZC93aWRnZXQvZGFzaGJvYXJkLXdpZGdldC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9kcmFnL2RyYWcuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZGFzaGJvYXJkL2RyYWctaGFuZGxlL2RyYWctaGFuZGxlLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL2RyYWcvZHJhZy5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9kYXNoYm9hcmQvZGFzaGJvYXJkLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3NwaW4tYnV0dG9uL3NwaW4tYnV0dG9uLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3NwaW4tYnV0dG9uL3NwaW4tYnV0dG9uLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3RpbWUtcGlja2VyL3RpbWUtZm9ybWF0LnBpcGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy90aW1lLXBpY2tlci90aW1lLXBpY2tlci5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy90aW1lLXBpY2tlci90aW1lLXBpY2tlci5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9kYXRlLXRpbWUtcGlja2VyL2RhdGUtdGltZS1waWNrZXIudXRpbHMudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9kYXRlLXRpbWUtcGlja2VyL2RhdGUtdGltZS1waWNrZXIuY29uZmlnLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZGF0ZS10aW1lLXBpY2tlci9kYXRlLXRpbWUtcGlja2VyLnNlcnZpY2UudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9kYXRlLXRpbWUtcGlja2VyL2RhdGUtdGltZS1waWNrZXIuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZGF0ZS10aW1lLXBpY2tlci9kYXktdmlldy9kYXktdmlldy5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZGF0ZS10aW1lLXBpY2tlci9kYXktdmlldy9kYXktdmlldy5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9kYXRlLXRpbWUtcGlja2VyL2hlYWRlci9oZWFkZXIuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZGF0ZS10aW1lLXBpY2tlci9tb250aC12aWV3L21vbnRoLXZpZXcuc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2RhdGUtdGltZS1waWNrZXIvbW9udGgtdmlldy9tb250aC12aWV3LmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2RhdGUtdGltZS1waWNrZXIvdGltZS12aWV3L3RpbWUtdmlldy5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9kYXRlLXRpbWUtcGlja2VyL3llYXItdmlldy95ZWFyLXZpZXcuc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2RhdGUtdGltZS1waWNrZXIveWVhci12aWV3L3llYXItdmlldy5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9mb2N1cy1pZi9mb2N1cy1pZi5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9mb2N1cy1pZi9mb2N1cy1pZi5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9kYXRlLXRpbWUtcGlja2VyL2RhdGUtdGltZS1waWNrZXIubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZWJveC9lYm94LmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2Vib3gvZWJveC5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9mYWNldHMvZmFjZXQtZXZlbnRzLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZmFjZXRzL2ZhY2V0LWNvbnRhaW5lci5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9mYWNldHMvYmFzZS9mYWNldC1iYXNlL2ZhY2V0LWJhc2UuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZmFjZXRzL2Jhc2UvZmFjZXQtaGVhZGVyL2ZhY2V0LWhlYWRlci5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9mYWNldHMvZmFjZXQtY2hlY2stbGlzdC9mYWNldC1jaGVjay1saXN0LmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2ZhY2V0cy9mYWNldC10eXBlYWhlYWQtbGlzdC9mYWNldC10eXBlYWhlYWQtbGlzdC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy90b29sdGlwL3Rvb2x0aXAuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdG9vbHRpcC90b29sdGlwLnNlcnZpY2UudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy90b29sdGlwL3Rvb2x0aXAuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdG9vbHRpcC90b29sdGlwLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL3Jlb3JkZXJhYmxlL3Jlb3JkZXJhYmxlLWhhbmRsZS5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9yZW9yZGVyYWJsZS9yZW9yZGVyYWJsZS1tb2RlbC5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9yZW9yZGVyYWJsZS9kcmFndWxhLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvcmVvcmRlcmFibGUvcmVvcmRlcmFibGUuc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL3Jlb3JkZXJhYmxlL3Jlb3JkZXJhYmxlLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL3Jlb3JkZXJhYmxlL3Jlb3JkZXJhYmxlLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2ZhY2V0cy9mYWNldHMubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZmFjZXRzL21vZGVscy9mYWNldC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2ZpbHRlcnMvZmlsdGVyLWNvbnRhaW5lci5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9maWx0ZXJzL2ZpbHRlci1iYXNlL2ZpbHRlci1iYXNlLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2ZpbHRlcnMvZmlsdGVyLWRyb3Bkb3duL2ZpbHRlci1kcm9wZG93bi5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9maWx0ZXJzL2ZpbHRlci1keW5hbWljL2ZpbHRlci1keW5hbWljLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2ZpbHRlcnMvZmlsdGVyLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2ZsaXBwYWJsZS1jYXJkL2ZsaXBwYWJsZS1jYXJkLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2ZsaXBwYWJsZS1jYXJkL2ZsaXBwYWJsZS1jYXJkLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2Zsb2F0aW5nLWFjdGlvbi1idXR0b25zL2Zsb2F0aW5nLWFjdGlvbi1idXR0b25zLnNlcnZpY2UudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9mbG9hdGluZy1hY3Rpb24tYnV0dG9ucy9mbG9hdGluZy1hY3Rpb24tYnV0dG9ucy5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9mbG9hdGluZy1hY3Rpb24tYnV0dG9ucy9mbG9hdGluZy1hY3Rpb24tYnV0dG9uLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2Zsb2F0aW5nLWFjdGlvbi1idXR0b25zL2Zsb2F0aW5nLWFjdGlvbi1idXR0b25zLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2hpZXJhcmNoeS1iYXIvaGllcmFyY2h5LWJhci5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvaGllcmFyY2h5LWJhci9oaWVyYXJjaHktYmFyLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL2NsaWNrLW91dHNpZGUvY2xpY2stb3V0c2lkZS5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9jbGljay1vdXRzaWRlL2NsaWNrLW91dHNpZGUubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvcG9wb3Zlci9wb3BvdmVyLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3BvcG92ZXIvcG9wb3Zlci5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9wb3BvdmVyL3BvcG92ZXIubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvaGllcmFyY2h5LWJhci9oaWVyYXJjaHktYmFyLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3NpZGUtcGFuZWwvc2lkZS1wYW5lbC5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvc2lkZS1wYW5lbC9zaWRlLXBhbmVsLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2l0ZW0tZGlzcGxheS1wYW5lbC9pdGVtLWRpc3BsYXktcGFuZWwuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvaXRlbS1kaXNwbGF5LXBhbmVsL2l0ZW0tZGlzcGxheS1wYW5lbC5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy93aXphcmQvd2l6YXJkLXN0ZXAuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvd2l6YXJkL3dpemFyZC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy93aXphcmQvd2l6YXJkLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL21hcnF1ZWUtd2l6YXJkL21hcnF1ZWUtd2l6YXJkLnNlcnZpY2UudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9tYXJxdWVlLXdpemFyZC9tYXJxdWVlLXdpemFyZC1zdGVwLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL21hcnF1ZWUtd2l6YXJkL21hcnF1ZWUtd2l6YXJkLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL21hcnF1ZWUtd2l6YXJkL21hcnF1ZWUtd2l6YXJkLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9zZXJ2aWNlcy9hdWRpby9hdWRpby5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL3NlcnZpY2VzL2F1ZGlvL2F1ZGlvLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9zZXJ2aWNlcy9mcmFtZS1leHRyYWN0aW9uL2ZyYW1lLWV4dHJhY3Rpb24uc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9zZXJ2aWNlcy9mcmFtZS1leHRyYWN0aW9uL2ZyYW1lLWV4dHJhY3Rpb24ubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvbWVkaWEtcGxheWVyL21lZGlhLXBsYXllci5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvbWVkaWEtcGxheWVyL21lZGlhLXBsYXllci5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9tZWRpYS1wbGF5ZXIvZXh0ZW5zaW9ucy9iYXNlLWV4dGVuc2lvbi5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9tZWRpYS1wbGF5ZXIvZXh0ZW5zaW9ucy90aW1lbGluZS90aW1lbGluZS5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9tZWRpYS1wbGF5ZXIvZXh0ZW5zaW9ucy9jb250cm9scy9jb250cm9scy5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvcGlwZXMvZHVyYXRpb24vZHVyYXRpb24ucGlwZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9waXBlcy9kdXJhdGlvbi9kdXJhdGlvbi5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvcGlwZXMvZmlsZS1zaXplL2ZpbGUtc2l6ZS5waXBlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL3BpcGVzL2ZpbGUtc2l6ZS9maWxlLXNpemUubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvbWVkaWEtcGxheWVyL21lZGlhLXBsYXllci5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9uYXZpZ2F0aW9uL25hdmlnYXRpb24uY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvbmF2aWdhdGlvbi9uYXZpZ2F0aW9uLWl0ZW0vbmF2aWdhdGlvbi1pdGVtLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL25hdmlnYXRpb24vbmF2aWdhdGlvbi5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvc2VydmljZXMvY29sb3IvY29sb3Iuc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9zZXJ2aWNlcy9jb2xvci9jb2xvci5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9ub3RpZmljYXRpb24vbm90aWZpY2F0aW9uLnNlcnZpY2UudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9ub3RpZmljYXRpb24vbm90aWZpY2F0aW9uLWxpc3QuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvbm90aWZpY2F0aW9uL25vdGlmaWNhdGlvbi5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9udW1iZXItcGlja2VyL251bWJlci1waWNrZXIuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvbnVtYmVyLXBpY2tlci9udW1iZXItcGlja2VyLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL21lbnUtbmF2aWdhdGlvbi9tZW51LW5hdmlnYXRpb24uc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL21lbnUtbmF2aWdhdGlvbi9tZW51LW5hdmlnYXRpb24taXRlbS5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9tZW51LW5hdmlnYXRpb24vbWVudS1uYXZpZ2F0aW9uLXRvZ2dsZS5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9tZW51LW5hdmlnYXRpb24vbWVudS1uYXZpZ2F0aW9uLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL21lbnUtbmF2aWdhdGlvbi9tZW51LW5hdmlnYXRpb24ubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvcGFnZS1oZWFkZXIvY3VzdG9tLW1lbnUvY3VzdG9tLW1lbnUuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvcGFnZS1oZWFkZXIvcGFnZS1oZWFkZXIuc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3BhZ2UtaGVhZGVyL2ljb24tbWVudS9pY29uLW1lbnUuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvcGFnZS1oZWFkZXIvbmF2aWdhdGlvbi9uYXZpZ2F0aW9uLWRyb3Bkb3duLWl0ZW0vbmF2aWdhdGlvbi1kcm9wZG93bi1pdGVtLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3BhZ2UtaGVhZGVyL25hdmlnYXRpb24vbmF2aWdhdGlvbi1pdGVtL25hdmlnYXRpb24taXRlbS5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9wYWdlLWhlYWRlci9uYXZpZ2F0aW9uL25hdmlnYXRpb24tc2Vjb25kYXJ5LWl0ZW0vbmF2aWdhdGlvbi1zZWNvbmRhcnktaXRlbS5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9wYWdlLWhlYWRlci9uYXZpZ2F0aW9uL25hdmlnYXRpb24uY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvcGFnZS1oZWFkZXIvcGFnZS1oZWFkZXIuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvcGFnZS1oZWFkZXIvcGFnZS1oZWFkZXIubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvcHJvZ3Jlc3MtYmFyL3Byb2dyZXNzLWJhci5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9wcm9ncmVzcy1iYXIvcHJvZ3Jlc3MtYmFyLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3JhZGlvYnV0dG9uL3JhZGlvYnV0dG9uLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3JhZGlvYnV0dG9uL3JhZGlvYnV0dG9uLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3NlYXJjaC1idWlsZGVyL3NlYXJjaC1idWlsZGVyLnNlcnZpY2UudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9zZWFyY2gtYnVpbGRlci9zZWFyY2gtYnVpbGRlci1ncm91cC9zZWFyY2gtYnVpbGRlci1ncm91cC5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvc2VhcmNoLWJ1aWxkZXIvc2VhcmNoLWJ1aWxkZXItZ3JvdXAvc2VhcmNoLWJ1aWxkZXItZ3JvdXAuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvc2VhcmNoLWJ1aWxkZXIvc2VhcmNoLWJ1aWxkZXItb3V0bGV0L3NlYXJjaC1idWlsZGVyLW91dGxldC5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9zZWFyY2gtYnVpbGRlci9zZWFyY2gtY29tcG9uZW50cy9iYXNlLXNlYXJjaC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9zZWFyY2gtYnVpbGRlci9zZWFyY2gtY29tcG9uZW50cy90ZXh0L3RleHQuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvc2VhcmNoLWJ1aWxkZXIvc2VhcmNoLWNvbXBvbmVudHMvZGF0ZS9kYXRlLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3NlYXJjaC1idWlsZGVyL3NlYXJjaC1jb21wb25lbnRzL2RhdGUtcmFuZ2UvZGF0ZS1yYW5nZS5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9zZWFyY2gtYnVpbGRlci9zZWFyY2gtY29tcG9uZW50cy9zZWxlY3Qvc2VsZWN0LmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3NlYXJjaC1idWlsZGVyL3NlYXJjaC1idWlsZGVyLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3R5cGVhaGVhZC90eXBlYWhlYWQtZXZlbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy90eXBlYWhlYWQvdHlwZWFoZWFkLWtleS5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdHlwZWFoZWFkL3R5cGVhaGVhZC5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdHlwZWFoZWFkL3R5cGVhaGVhZC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9pbmZpbml0ZS1zY3JvbGwvaW5maW5pdGUtc2Nyb2xsLWxvYWQtYnV0dG9uLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL2luZmluaXRlLXNjcm9sbC9pbmZpbml0ZS1zY3JvbGwtbG9hZGluZy5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9pbmZpbml0ZS1zY3JvbGwvaW5maW5pdGUtc2Nyb2xsLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL2luZmluaXRlLXNjcm9sbC9pbmZpbml0ZS1zY3JvbGwubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvc2Nyb2xsL3Njcm9sbC1pbnRvLXZpZXcuc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL3Njcm9sbC9zY3JvbGwtaW50by12aWV3LWlmLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL3Njcm9sbC9zY3JvbGwtaW50by12aWV3LmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL3Njcm9sbC9zY3JvbGwubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdHlwZWFoZWFkL3R5cGVhaGVhZC1oaWdobGlnaHQuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdHlwZWFoZWFkL3R5cGVhaGVhZC5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9zZWxlY3Qvc2VsZWN0LmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3RhZy1pbnB1dC90YWctaW5wdXQtZXZlbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy90YWctaW5wdXQvdGFnLWlucHV0LmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3RhZy1pbnB1dC90YWctaW5wdXQubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvc2VsZWN0L3NlbGVjdC5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9zZWFyY2gtYnVpbGRlci9zZWFyY2gtYnVpbGRlci5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9zaWRlLXBhbmVsL3NpZGUtcGFuZWwtY2xvc2UuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvc2lkZS1wYW5lbC9zaWRlLXBhbmVsLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3NsaWRlci9zbGlkZXIuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvc2xpZGVyL3NsaWRlci5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9zcGFyay9zcGFyay5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9zcGFyay9zcGFyay5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy90YWJzZXQvdGFic2V0LnNlcnZpY2UudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy90YWJzZXQvdGFic2V0LmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3RhYnNldC90YWIvdGFiLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3RhYnNldC90YWIvdGFiLWhlYWRpbmcuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdGFic2V0L3RhYi90YWItZm9jdXMuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdGFic2V0L3RhYnNldC5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy90aW1lbGluZS90aW1lbGluZS5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy90aW1lbGluZS90aW1lbGluZS1ldmVudC90aW1lbGluZS1ldmVudC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy90aW1lbGluZS90aW1lbGluZS5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy90b2dnbGVzd2l0Y2gvdG9nZ2xlc3dpdGNoLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3RvZ2dsZXN3aXRjaC90b2dnbGVzd2l0Y2gubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdG9vbGJhci1zZWFyY2gvdG9vbGJhci1zZWFyY2gtYnV0dG9uLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3Rvb2xiYXItc2VhcmNoL3Rvb2xiYXItc2VhcmNoLWZpZWxkLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3Rvb2xiYXItc2VhcmNoL3Rvb2xiYXItc2VhcmNoLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3Rvb2xiYXItc2VhcmNoL3Rvb2xiYXItc2VhcmNoLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3ZpcnR1YWwtc2Nyb2xsL2RpcmVjdGl2ZXMvdmlydHVhbC1zY3JvbGwtbG9hZGluZy5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy92aXJ0dWFsLXNjcm9sbC9kaXJlY3RpdmVzL3ZpcnR1YWwtc2Nyb2xsLWxvYWQtYnV0dG9uLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3ZpcnR1YWwtc2Nyb2xsL2RpcmVjdGl2ZXMvdmlydHVhbC1zY3JvbGwtY2VsbC5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy92aXJ0dWFsLXNjcm9sbC92aXJ0dWFsLXNjcm9sbC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy92aXJ0dWFsLXNjcm9sbC92aXJ0dWFsLXNjcm9sbC5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9hdXRvLWdyb3cvYXV0by1ncm93LmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL2F1dG8tZ3Jvdy9hdXRvLWdyb3cubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvZml4ZWQtaGVhZGVyLXRhYmxlL2ZpeGVkLWhlYWRlci10YWJsZS5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9maXhlZC1oZWFkZXItdGFibGUvZml4ZWQtaGVhZGVyLXRhYmxlLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL2Zsb2F0LWxhYmVsL2Zsb2F0LWxhYmVsLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL2Zsb2F0LWxhYmVsL2Zsb2F0LWxhYmVsLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL2hlbHAtY2VudGVyL2hlbHAtY2VudGVyLnNlcnZpY2UudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9oZWxwLWNlbnRlci9oZWxwLWNlbnRlci1pdGVtLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL2hlbHAtY2VudGVyL2hlbHAtY2VudGVyLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL2hvdmVyLWFjdGlvbi9ob3Zlci1hY3Rpb24uc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL2hvdmVyLWFjdGlvbi9ob3Zlci1hY3Rpb24tY29udGFpbmVyLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL2hvdmVyLWFjdGlvbi9ob3Zlci1hY3Rpb24uZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvaG92ZXItYWN0aW9uL2hvdmVyLWFjdGlvbi5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9sYXlvdXQtc3dpdGNoZXIvbGF5b3V0LXN3aXRjaGVyLWl0ZW0uZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvbGF5b3V0LXN3aXRjaGVyL2xheW91dC1zd2l0Y2hlci5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9sYXlvdXQtc3dpdGNoZXIvbGF5b3V0LXN3aXRjaGVyLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL29ic2VydmVycy9vdmVyZmxvdy9vdmVyZmxvdy1vYnNlcnZlci5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9vYnNlcnZlcnMvb2JzZXJ2ZXJzLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL3NlbGVjdGlvbi9zdHJhdGVnaWVzL3NlbGVjdGlvbi5zdHJhdGVneS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL3NlbGVjdGlvbi9zdHJhdGVnaWVzL3Jvdy1zZWxlY3Rpb24uc3RyYXRlZ3kudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9zZWxlY3Rpb24vc3RyYXRlZ2llcy9yb3ctYWx0LXNlbGVjdGlvbi5zdHJhdGVneS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL3NlbGVjdGlvbi9zdHJhdGVnaWVzL3NpbXBsZS1zZWxlY3Rpb24uc3RyYXRlZ3kudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9zZWxlY3Rpb24vc2VsZWN0aW9uLnNlcnZpY2UudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9zZWxlY3Rpb24vc2VsZWN0aW9uLWl0ZW0uZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvc2VsZWN0aW9uL3NlbGVjdGlvbi5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9zZWxlY3Rpb24vc2VsZWN0aW9uLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9oeWJyaWQvY29tcG9uZW50cy9jb250YWN0cy9jb250YWN0cy5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvaHlicmlkL2NvbXBvbmVudHMvZXhwYW5kLWlucHV0L2V4cGFuZC1pbnB1dC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvaHlicmlkL2NvbXBvbmVudHMvZmxvYXRpbmctYWN0aW9uLWJ1dHRvbi9mbG9hdGluZy1hY3Rpb24tYnV0dG9uLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9oeWJyaWQvY29tcG9uZW50cy9mbG90L2Zsb3QuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2h5YnJpZC9jb21wb25lbnRzL2dyaWQvZ3JpZC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvaHlicmlkL2NvbXBvbmVudHMvaGllcmFyY2h5LWJhci9oaWVyYXJjaHktYmFyLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9oeWJyaWQvY29tcG9uZW50cy9tYXJxdWVlLXdpemFyZC9tYXJxdWVlLXdpemFyZC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvaHlicmlkL2NvbXBvbmVudHMvbmVzdGVkLWRvbnV0L25lc3RlZC1kb251dC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvaHlicmlkL2NvbXBvbmVudHMvb3JnYW5pemF0aW9uLWNoYXJ0L29yZ2FuaXphdGlvbi1jaGFydC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvaHlicmlkL2NvbXBvbmVudHMvcGFydGl0aW9uLW1hcC9wYXJ0aXRpb24tbWFwLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9oeWJyaWQvY29tcG9uZW50cy9wZWl0eS1jaGFydC9wZWl0eS1iYXItY2hhcnQuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2h5YnJpZC9jb21wb25lbnRzL3BlaXR5LWNoYXJ0L3BlaXR5LWxpbmUtY2hhcnQuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2h5YnJpZC9jb21wb25lbnRzL3BlaXR5LWNoYXJ0L3BlaXR5LXBpZS1jaGFydC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvaHlicmlkL2NvbXBvbmVudHMvcGVpdHktY2hhcnQvcGVpdHktdXBkYXRpbmctbGluZS1jaGFydC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvaHlicmlkL2NvbXBvbmVudHMvc2Fua2V5LWNoYXJ0L3NhbmtleS5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvaHlicmlkL2NvbXBvbmVudHMvc2VhcmNoLXRvb2xiYXIvc2VhcmNoLXRvb2xiYXIuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2h5YnJpZC9jb21wb25lbnRzL3NlbGVjdC10YWJsZS9zZWxlY3QtdGFibGUuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2h5YnJpZC9jb21wb25lbnRzL3NsaWRlci1jaGFydC9zbGlkZXItY2hhcnQuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2h5YnJpZC9jb21wb25lbnRzL3NvY2lhbC1jaGFydC9zb2NpYWwtY2hhcnQuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2h5YnJpZC9jb21wb25lbnRzL3NvcnQtZGlyZWN0aW9uLXRvZ2dsZS9zb3J0LWRpcmVjdGlvbi10b2dnbGUuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2h5YnJpZC9jb21wb25lbnRzL3RyZWUtZ3JpZC90cmVlLWdyaWQuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2h5YnJpZC9jb21wb25lbnRzL3RodW1ibmFpbC90aHVtYm5haWwuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2h5YnJpZC9zZXJ2aWNlcy9uYXZpZ2F0aW9uLW1lbnUvbmF2aWdhdGlvbi1tZW51LnNlcnZpY2UudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvaHlicmlkL3NlcnZpY2VzL3BkZi9wZGYuc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9oeWJyaWQvc2VydmljZXMvdGltZS1hZ28vdGltZS1hZ28uc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9oeWJyaWQvaHlicmlkLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9waXBlcy9zdHJpbmctZmlsdGVyL3N0cmluZy1maWx0ZXIucGlwZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9waXBlcy9zdHJpbmctZmlsdGVyL3N0cmluZy1maWx0ZXIubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL3NlcnZpY2VzL3BlcnNpc3RlbnQtZGF0YS9hZGFwdGVycy9jb29raWUtYWRhcHRlci50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9zZXJ2aWNlcy9wZXJzaXN0ZW50LWRhdGEvYWRhcHRlcnMvbG9jYWwtc3RvcmFnZS1hZGFwdGVyLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL3NlcnZpY2VzL3BlcnNpc3RlbnQtZGF0YS9hZGFwdGVycy9zZXNzaW9uLXN0b3JhZ2UtYWRhcHRlci50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9zZXJ2aWNlcy9wZXJzaXN0ZW50LWRhdGEvcGVyc2lzdGVudC1kYXRhLnNlcnZpY2UudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvc2VydmljZXMvcGVyc2lzdGVudC1kYXRhL3BlcnNpc3RlbnQtZGF0YS5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvc2VydmljZXMvcGVyc2lzdGVudC1kYXRhL2FkYXB0ZXJzL3N0b3JhZ2UtYWRhcHRlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtYnJlYWRjcnVtYnMnLFxuICAgIHRlbXBsYXRlOiBgPG5hdiBhcmlhLWxhYmVsPVwiQnJlYWRjcnVtYlwiPlxuICAgIDxvbCBjbGFzcz1cImJyZWFkY3J1bWJcIj5cbiAgICAgICAgPGxpICpuZ0Zvcj1cImxldCBjcnVtYiBvZiBjcnVtYnNcIj5cblxuICAgICAgICAgICAgPCEtLSBJZiB0aGVyZSBpcyBhIHJvdXRlciBsaW5rIHRoZW4gdXNlIGEgdGFnIC0tPlxuICAgICAgICAgICAgPGEgKm5nSWY9XCJjcnVtYi5yb3V0ZXJMaW5rIHx8IGNydW1iLm9uQ2xpY2tcIlxuICAgICAgICAgICAgICAgIHRhYmluZGV4PVwiMFwiXG4gICAgICAgICAgICAgICAgW3JvdXRlckxpbmtdPVwiY3J1bWIucm91dGVyTGlua1wiXG4gICAgICAgICAgICAgICAgW2ZyYWdtZW50XT1cImNydW1iLmZyYWdtZW50XCJcbiAgICAgICAgICAgICAgICBbcXVlcnlQYXJhbXNdPVwiY3J1bWIucXVlcnlQYXJhbXNcIlxuICAgICAgICAgICAgICAgIChjbGljayk9XCJjbGlja0NydW1iKCRldmVudCwgY3J1bWIpXCI+XG4gICAgICAgICAgICAgICAge3sgY3J1bWIudGl0bGUgfX1cbiAgICAgICAgICAgIDwvYT5cblxuICAgICAgICAgICAgPCEtLSBJZiB0aGVyZSBpcyBub3Qgcm91dGVyIGxpbmsgdGhlbiBkaXNwbGF5IHRleHQgaW4gYSBzcGFuIC0tPlxuICAgICAgICAgICAgPHNwYW4gKm5nSWY9XCIhY3J1bWIucm91dGVyTGluayAmJiAhY3J1bWIub25DbGlja1wiPnt7IGNydW1iLnRpdGxlIH19PC9zcGFuPlxuICAgICAgICA8L2xpPlxuICAgIDwvb2w+XG48L25hdj5gXG59KVxuXG5leHBvcnQgY2xhc3MgQnJlYWRjcnVtYnNDb21wb25lbnQge1xuXG4gICAgQElucHV0KCkgY3J1bWJzOiBCcmVhZGNydW1iW107XG5cbiAgICBjbGlja0NydW1iKGV2ZW50OiBNb3VzZUV2ZW50LCBjcnVtYjogQnJlYWRjcnVtYikge1xuICAgICAgICBpZiAoY3J1bWIub25DbGljaykge1xuICAgICAgICAgICAgY3J1bWIub25DbGljay5jYWxsKG51bGwsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBCcmVhZGNydW1iIHtcbiAgICB0aXRsZTogc3RyaW5nO1xuICAgIHJvdXRlckxpbms/OiBzdHJpbmc7XG4gICAgZnJhZ21lbnQ/OiBzdHJpbmc7XG4gICAgcXVlcnlQYXJhbXM/OiBhbnk7XG4gICAgb25DbGljaz86IChldmVudDogTW91c2VFdmVudCkgPT4gdm9pZDtcbn0iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBCcmVhZGNydW1ic0NvbXBvbmVudCB9IGZyb20gJy4vYnJlYWRjcnVtYnMuY29tcG9uZW50JztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBSb3V0ZXJNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLCBcbiAgICAgICAgUm91dGVyTW9kdWxlXG4gICAgXSxcbiAgICBleHBvcnRzOiBbQnJlYWRjcnVtYnNDb21wb25lbnRdLFxuICAgIGRlY2xhcmF0aW9uczogW0JyZWFkY3J1bWJzQ29tcG9uZW50XVxufSlcbmV4cG9ydCBjbGFzcyBCcmVhZGNydW1ic01vZHVsZSB7IH1cbiIsImltcG9ydCB7IEluamVjdGFibGUsIE5nWm9uZSwgT25EZXN0cm95LCBSZW5kZXJlcjIsIFJlbmRlcmVyRmFjdG9yeTIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcbmltcG9ydCB7IGZyb21FdmVudCB9IGZyb20gJ3J4anMvb2JzZXJ2YWJsZS9mcm9tRXZlbnQnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcy9TdWJzY3JpcHRpb24nO1xuXG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBSZXNpemVTZXJ2aWNlIGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICAgIHByaXZhdGUgX3JlbmRlcmVyOiBSZW5kZXJlcjI7XG4gICAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuXG4gICAgY29uc3RydWN0b3IocmVuZGVyZXJGYWN0b3J5OiBSZW5kZXJlckZhY3RvcnkyLCBwcml2YXRlIF9uZ1pvbmU6IE5nWm9uZSkge1xuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IHJlbmRlcmVyRmFjdG9yeS5jcmVhdGVSZW5kZXJlcihudWxsLCBudWxsKTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuXG4gICAgYWRkUmVzaXplTGlzdGVuZXIobmF0aXZlRWxlbWVudDogSFRNTEVsZW1lbnQpOiBCZWhhdmlvclN1YmplY3Q8UmVzaXplRGltZW5zaW9ucz4ge1xuXG4gICAgICAgIC8vIGNyZWF0ZSBhIGJlaGF2aW9yIHN1YmplY3Qgc3ViamVjdFxuICAgICAgICBjb25zdCBzdWJqZWN0ID0gbmV3IEJlaGF2aW9yU3ViamVjdDxSZXNpemVEaW1lbnNpb25zPih7IHdpZHRoOiBuYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoLCBoZWlnaHQ6IG5hdGl2ZUVsZW1lbnQub2Zmc2V0SGVpZ2h0IH0pO1xuXG4gICAgICAgIC8vIGRldGVybWluZSB0aGUgc3R5bGUgb2YgdGhlIGVsZW1lbnRcbiAgICAgICAgY29uc3QgZGlzcGxheU1vZGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShuYXRpdmVFbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKCdkaXNwbGF5Jyk7XG5cbiAgICAgICAgLy8gY3JlYXRlIHRoZSBpZnJhbWUgZWxlbWVudFxuICAgICAgICBjb25zdCBpZnJhbWU6IEhUTUxJRnJhbWVFbGVtZW50ID0gdGhpcy5fcmVuZGVyZXIuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG5cbiAgICAgICAgLy8gc3R5bGUgdGhlIGlmcmFtZSB0byBiZSBpbnZpc2libGUgYnV0IGZpbGwgY29udGFpbmluZyBlbGVtZW50XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldFN0eWxlKGlmcmFtZSwgJ3Bvc2l0aW9uJywgJ2Fic29sdXRlJyk7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldFN0eWxlKGlmcmFtZSwgJ3dpZHRoJywgJzEwMCUnKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0U3R5bGUoaWZyYW1lLCAnaGVpZ2h0JywgJzEwMCUnKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0U3R5bGUoaWZyYW1lLCAndG9wJywgJzAnKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0U3R5bGUoaWZyYW1lLCAncmlnaHQnLCAnMCcpO1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRTdHlsZShpZnJhbWUsICdib3R0b20nLCAnMCcpO1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRTdHlsZShpZnJhbWUsICdsZWZ0JywgJzAnKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0U3R5bGUoaWZyYW1lLCAnei1pbmRleCcsICctMScpO1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRTdHlsZShpZnJhbWUsICdvcGFjaXR5JywgJzAnKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0U3R5bGUoaWZyYW1lLCAnYm9yZGVyJywgJ25vbmUnKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0U3R5bGUoaWZyYW1lLCAnbWFyZ2luJywgJzAnKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0U3R5bGUoaWZyYW1lLCAncG9pbnRlci1ldmVudHMnLCAnbm9uZScpO1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRTdHlsZShpZnJhbWUsICdvdmVyZmxvdycsICdoaWRkZW4nKTtcblxuICAgICAgICAvLyBlbnN1cmUgdGhlIGlmcmFtZSBpZ25vcmVzIGFueSB0YWJiaW5nXG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEF0dHJpYnV0ZShpZnJhbWUsICd0YWJpbmRleCcsICctMScpO1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRBdHRyaWJ1dGUoaWZyYW1lLCAnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuXG4gICAgICAgIC8vIHN0YXRpY2FsbHkgcG9zaXRpb25lZCBlbGVtZW50cyBuZWVkIGNoYW5nZWQgdG8gcmVsYXRpdmUgZm9yIHRoaXMgbWV0aG9kIHRvIHdvcmtcbiAgICAgICAgaWYgKGRpc3BsYXlNb2RlICE9PSAncmVsYXRpdmUnICYmIGRpc3BsYXlNb2RlICE9PSAnYWJzb2x1dGUnICYmIGRpc3BsYXlNb2RlICE9PSAnZml4ZWQnKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRTdHlsZShuYXRpdmVFbGVtZW50LCAncG9zaXRpb24nLCAncmVsYXRpdmUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCB0aGUgaWZyYW1lIHRvIHRoZSBjb250YWluZXIgZWxlbWVudFxuICAgICAgICB0aGlzLl9yZW5kZXJlci5hcHBlbmRDaGlsZChuYXRpdmVFbGVtZW50LCBpZnJhbWUpO1xuXG4gICAgICAgIHRoaXMud2FpdFVudGlsUmVhZHkoaWZyYW1lLCAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpZnJhbWVEb2MgPSBpZnJhbWUuY29udGVudERvY3VtZW50IHx8IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50IGFzIERvY3VtZW50O1xuXG4gICAgICAgICAgICBjb25zdCBhdHRhY2hMaXN0ZW5lciA9ICgpID0+IHtcblxuICAgICAgICAgICAgICAgIC8vIHdhdGNoIGZvciBhbnkgZnV0dXJlIHJlc2l6ZXMgLSBydW4gaW5zaWRlIG5nem9uZSBhcyBhbiBpZnJhbWUgZXZlbnQgbGlzdGVuZXIgaXMgbm90IHBhdGNoZWRcbiAgICAgICAgICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24uYWRkKGZyb21FdmVudChpZnJhbWUuY29udGVudFdpbmRvdywgJ3Jlc2l6ZScpLnN1YnNjcmliZSgoZXZlbnQ6IFJlc2l6ZURpbWVuc2lvbnMpID0+XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX25nWm9uZS5ydW4oKCkgPT4gc3ViamVjdC5uZXh0KHsgd2lkdGg6IG5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGgsIGhlaWdodDogbmF0aXZlRWxlbWVudC5vZmZzZXRIZWlnaHQgfSkpXG4gICAgICAgICAgICAgICAgKSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoaWZyYW1lRG9jLnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgICAgICAgICAgICBhdHRhY2hMaXN0ZW5lcigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIC8vIHdhaXQgZm9yIGlmcmFtZSB0byBsb2FkXG4gICAgICAgICAgICAgICAgaWZyYW1lLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoKSA9PiBhdHRhY2hMaXN0ZW5lcigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cblxuICAgICAgICByZXR1cm4gc3ViamVjdDtcbiAgICB9XG5cbiAgICBwcml2YXRlIHdhaXRVbnRpbFJlYWR5KGlmcmFtZTogSFRNTElGcmFtZUVsZW1lbnQsIGNhbGxiYWNrOiAoKSA9PiB2b2lkKSB7XG4gICAgICAgIGlmIChpZnJhbWUuY29udGVudERvY3VtZW50IHx8IGlmcmFtZS5jb250ZW50V2luZG93KSB7XG4gICAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLndhaXRVbnRpbFJlYWR5KGlmcmFtZSwgY2FsbGJhY2spKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZXNpemVEaW1lbnNpb25zIHtcbiAgICB3aWR0aDogbnVtYmVyO1xuICAgIGhlaWdodDogbnVtYmVyO1xufSIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgTmdab25lLCBPbkRlc3Ryb3ksIE9uSW5pdCwgT3V0cHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBkZWJvdW5jZVRpbWUgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBSZXNpemVEaW1lbnNpb25zLCBSZXNpemVTZXJ2aWNlIH0gZnJvbSAnLi9yZXNpemUuc2VydmljZSc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3V4UmVzaXplXScsXG4gICAgcHJvdmlkZXJzOiBbUmVzaXplU2VydmljZV1cbn0pXG5leHBvcnQgY2xhc3MgUmVzaXplRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuXG4gICAgQElucHV0KCkgdGhyb3R0bGU6IG51bWJlciA9IDA7XG4gICAgQE91dHB1dCgpIHV4UmVzaXplOiBFdmVudEVtaXR0ZXI8UmVzaXplRGltZW5zaW9ucz4gPSBuZXcgRXZlbnRFbWl0dGVyPFJlc2l6ZURpbWVuc2lvbnM+KCk7XG5cbiAgICBwcml2YXRlIF9zdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIHByaXZhdGUgX3Jlc2l6ZVNlcnZpY2U6IFJlc2l6ZVNlcnZpY2UsIHByaXZhdGUgX25nWm9uZTogTmdab25lKSB7IH1cblxuICAgIG5nT25Jbml0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24gPSB0aGlzLl9yZXNpemVTZXJ2aWNlLmFkZFJlc2l6ZUxpc3RlbmVyKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudClcbiAgICAgICAgICAgIC5waXBlKGRlYm91bmNlVGltZSh0aGlzLnRocm90dGxlKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKGV2ZW50OiBSZXNpemVEaW1lbnNpb25zKSA9PiB0aGlzLl9uZ1pvbmUucnVuKCgpID0+IHRoaXMudXhSZXNpemUuZW1pdChldmVudCkpKTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxufSIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IFJlc2l6ZURpcmVjdGl2ZSB9IGZyb20gJy4vcmVzaXplLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBSZXNpemVTZXJ2aWNlIH0gZnJvbSAnLi9yZXNpemUuc2VydmljZSc7XG5cbkBOZ01vZHVsZSh7XG4gICAgZXhwb3J0czogW1Jlc2l6ZURpcmVjdGl2ZV0sXG4gICAgZGVjbGFyYXRpb25zOiBbUmVzaXplRGlyZWN0aXZlXSxcbiAgICBwcm92aWRlcnM6IFtSZXNpemVTZXJ2aWNlXVxufSlcbmV4cG9ydCBjbGFzcyBSZXNpemVNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBEaXJlY3RpdmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW3V4Q2FyZFRhYkNvbnRlbnRdJ1xufSlcbmV4cG9ydCBjbGFzcyBDYXJkVGFiQ29udGVudERpcmVjdGl2ZSB7IH1cbiIsImltcG9ydCB7IEluamVjdGFibGUsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcy9CZWhhdmlvclN1YmplY3QnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcy9TdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgZmlsdGVyIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgQ2FyZFRhYkNvbXBvbmVudCB9IGZyb20gJy4vY2FyZC10YWIvY2FyZC10YWIuY29tcG9uZW50JztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIENhcmRUYWJzU2VydmljZSBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG5cbiAgdGFiJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8Q2FyZFRhYkNvbXBvbmVudD4obnVsbCk7XG4gIHRhYnMkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxDYXJkVGFiQ29tcG9uZW50W10+KFtdKTtcbiAgcG9zaXRpb24kID0gbmV3IEJlaGF2aW9yU3ViamVjdDxzdHJpbmc+KCd0b3AnKTtcblxuICBwcml2YXRlIF9zdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICBjb25zdHJ1Y3RvcigpIHtcblxuICAgIC8vIHdoZW4gYSB0YWIgaXMgYWRkZWQgb3IgcmVtb3ZlZCBlbnN1cmUgd2UgYWx3YXlzIHNlbGVjdCBvbmUgaWYgYW55IGFyZSBhdmFpbGFibGVcbiAgICB0aGlzLl9zdWJzY3JpcHRpb24gPSB0aGlzLnRhYnMkLnBpcGUoXG4gICAgICBmaWx0ZXIodGFicyA9PiAhdGhpcy50YWIkLnZhbHVlIHx8ICF0YWJzLmZpbmQodGFiID0+IHRhYiA9PT0gdGhpcy50YWIkLnZhbHVlKSksXG4gICAgKS5zdWJzY3JpYmUodGFicyA9PiB0aGlzLnRhYiQubmV4dCh0YWJzLmxlbmd0aCA+IDAgPyB0YWJzWzBdIDogbnVsbCkpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEgdGFiIHRvIHRoZSBsaXN0IG9mIHRhYnNcbiAgICovXG4gIGFkZFRhYih0YWI6IENhcmRUYWJDb21wb25lbnQpOiB2b2lkIHtcbiAgICB0aGlzLnRhYnMkLm5leHQoWy4uLnRoaXMudGFicyQudmFsdWUsIHRhYl0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIHRhYiBmcm9tIHRoZSBsaXN0XG4gICAqL1xuICByZW1vdmVUYWIodGFiOiBDYXJkVGFiQ29tcG9uZW50KTogdm9pZCB7XG4gICAgdGhpcy50YWJzJC5uZXh0KHRoaXMudGFicyQudmFsdWUuZmlsdGVyKF90YWIgPT4gX3RhYiAhPT0gdGFiKSk7XG4gIH1cblxuICAvKipcbiAgICogU2VsZWN0IHRoZSB0YWJcbiAgICovXG4gIHNlbGVjdCh0YWI6IENhcmRUYWJDb21wb25lbnQpOiB2b2lkIHtcbiAgICB0aGlzLnRhYiQubmV4dCh0YWIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgcG9zaXRpb24gb2YgdGhlIHRhYiBjb250ZW50XG4gICAqL1xuICBzZXRQb3NpdGlvbihwb3NpdGlvbjogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy5wb3NpdGlvbiQubmV4dChwb3NpdGlvbik7XG4gIH1cbn1cbiIsImltcG9ydCB7IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDb21wb25lbnQsIENvbnRlbnRDaGlsZCwgT25EZXN0cm95LCBUZW1wbGF0ZVJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMvT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBtYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBDYXJkVGFic1NlcnZpY2UgfSBmcm9tICcuLi9jYXJkLXRhYnMuc2VydmljZSc7XG5pbXBvcnQgeyBDYXJkVGFiQ29udGVudERpcmVjdGl2ZSB9IGZyb20gJy4vY2FyZC10YWItY29udGVudC5kaXJlY3RpdmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICd1eC1jYXJkLXRhYicsXG4gIHRlbXBsYXRlOiBgPG5nLWNvbnRlbnQgKm5nSWY9XCJhY3RpdmUkIHwgYXN5bmNcIj48L25nLWNvbnRlbnQ+YCxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgQ2FyZFRhYkNvbXBvbmVudCBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG5cbiAgYWN0aXZlJDogT2JzZXJ2YWJsZTxib29sZWFuPiA9IHRoaXMuX3RhYlNlcnZpY2UudGFiJC5waXBlKG1hcCh0YWIgPT4gdGFiID09PSB0aGlzKSk7XG4gIEBDb250ZW50Q2hpbGQoQ2FyZFRhYkNvbnRlbnREaXJlY3RpdmUsIHsgcmVhZDogVGVtcGxhdGVSZWYgfSkgY29udGVudDogVGVtcGxhdGVSZWY8YW55PjtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF90YWJTZXJ2aWNlOiBDYXJkVGFic1NlcnZpY2UpIHtcbiAgICB0aGlzLl90YWJTZXJ2aWNlLmFkZFRhYih0aGlzKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMuX3RhYlNlcnZpY2UucmVtb3ZlVGFiKHRoaXMpO1xuICB9XG5cbn1cbiIsImltcG9ydCB7IENvbXBvbmVudCwgRWxlbWVudFJlZiwgSG9zdEJpbmRpbmcsIElucHV0LCBWaWV3Q2hpbGQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFJlc2l6ZURpbWVuc2lvbnMgfSBmcm9tICcuLi8uLi8uLi9kaXJlY3RpdmVzL3Jlc2l6ZSc7XG5pbXBvcnQgeyBDYXJkVGFiQ29tcG9uZW50IH0gZnJvbSAnLi4vY2FyZC10YWIvY2FyZC10YWIuY29tcG9uZW50JztcbmltcG9ydCB7IENhcmRUYWJzU2VydmljZSB9IGZyb20gJy4uL2NhcmQtdGFicy5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAndXgtY2FyZC10YWJzZXQnLFxuICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJjYXJkLXRhYi1jb250ZW50XCIgcm9sZT1cInRhYnBhbmVsXCIgKm5nSWY9XCIodGFiU2VydmljZS50YWIkIHwgYXN5bmMpXCI+XG4gICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuPC9kaXY+XG5cbjxkaXYgY2xhc3M9XCJjYXJkLXRhYnNcIiAjdGFicz5cblxuICAgIDxidXR0b24gY2xhc3M9XCJjYXJkLXRhYnMtcGFnaW5nLWJ0biBjYXJkLXRhYnMtcGFnaW5nLWJ0bi1wcmV2aW91c1wiIGFyaWEtbGFiZWw9XCJQcmV2aW91cyBUYWJzXCIgKGNsaWNrKT1cInByZXZpb3VzKClcIiAqbmdJZj1cIm9mZnNldCA8IGJvdW5kcy5sb3dlclwiPlxuICAgICAgICA8aSBjbGFzcz1cImhwZS1pY29uIGhwZS1wcmV2aW91c1wiPjwvaT5cbiAgICA8L2J1dHRvbj5cblxuICAgIDxkaXYgY2xhc3M9XCJjYXJkLXRhYnMtbGlzdFwiIHJvbGU9XCJ0YWJsaXN0XCIgI3RhYmxpc3QgKHV4UmVzaXplKT1cInJlc2l6ZSgkZXZlbnQpXCIgW3N0eWxlLnRyYW5zZm9ybV09XCIndHJhbnNsYXRlWCgnICsgb2Zmc2V0ICsgJ3B4KSdcIj5cblxuICAgICAgICA8ZGl2IGNsYXNzPVwiY2FyZC10YWJcIlxuICAgICAgICAgICAgcm9sZT1cInRhYlwiXG4gICAgICAgICAgICB0YWJpbmRleD1cIjBcIiAjY2FyZFxuICAgICAgICAgICAgKm5nRm9yPVwibGV0IHRhYiBvZiB0YWJTZXJ2aWNlLnRhYnMkIHwgYXN5bmNcIlxuICAgICAgICAgICAgW25nQ2xhc3NdPVwidGFiU2VydmljZS5wb3NpdGlvbiQgfCBhc3luY1wiXG4gICAgICAgICAgICBbY2xhc3MuYWN0aXZlXT1cInRhYi5hY3RpdmUkIHwgYXN5bmNcIlxuICAgICAgICAgICAgW2F0dHIuYXJpYS1zZWxlY3RlZF09XCJ0YWIuYWN0aXZlJCB8IGFzeW5jXCJcbiAgICAgICAgICAgIChjbGljayk9XCJzZWxlY3QodGFiLCBjYXJkKVwiXG4gICAgICAgICAgICAoZm9jdXMpPVwidGFicy5zY3JvbGxMZWZ0ID0gMFwiXG4gICAgICAgICAgICAoa2V5ZG93bi5lbnRlcik9XCJzZWxlY3QodGFiLCBjYXJkKVwiPlxuXG4gICAgICAgICAgICA8bmctY29udGFpbmVyIFtuZ1RlbXBsYXRlT3V0bGV0XT1cInRhYi5jb250ZW50XCI+PC9uZy1jb250YWluZXI+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgPC9kaXY+XG5cbiAgICA8YnV0dG9uIGNsYXNzPVwiY2FyZC10YWJzLXBhZ2luZy1idG4gY2FyZC10YWJzLXBhZ2luZy1idG4tbmV4dFwiIGFyaWEtbGFiZWw9XCJOZXh0IFRhYnNcIiAoY2xpY2spPVwibmV4dCgpXCIgKm5nSWY9XCJvZmZzZXQgPiBib3VuZHMudXBwZXJcIj5cbiAgICAgICAgPGkgY2xhc3M9XCJocGUtaWNvbiBocGUtbmV4dFwiPjwvaT5cbiAgICA8L2J1dHRvbj5cbjwvZGl2PmAsXG4gIHByb3ZpZGVyczogW0NhcmRUYWJzU2VydmljZV1cbn0pXG5leHBvcnQgY2xhc3MgQ2FyZFRhYnNldENvbXBvbmVudCB7XG5cbiAgQEhvc3RCaW5kaW5nKCdjbGFzcycpXG4gIEBJbnB1dCgpIHNldCBwb3NpdGlvbihkaXJlY3Rpb246IHN0cmluZykge1xuICAgIHRoaXMudGFiU2VydmljZS5zZXRQb3NpdGlvbihkaXJlY3Rpb24pO1xuICB9XG5cbiAgZ2V0IHBvc2l0aW9uKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMudGFiU2VydmljZS5wb3NpdGlvbiQuZ2V0VmFsdWUoKTtcbiAgfVxuXG4gIEBWaWV3Q2hpbGQoJ3RhYmxpc3QnKSB0YWJsaXN0OiBFbGVtZW50UmVmO1xuXG4gIG9mZnNldDogbnVtYmVyID0gMDtcbiAgYm91bmRzOiBDYXJkVGFic0JvdW5kcyA9IHsgbG93ZXI6IDAsIHVwcGVyOiAwIH07XG5cbiAgcHJpdmF0ZSBfd2lkdGg6IG51bWJlcjtcbiAgcHJpdmF0ZSBfaW5uZXJXaWR0aDogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyB0YWJTZXJ2aWNlOiBDYXJkVGFic1NlcnZpY2UpIHt9XG5cbiAgc2VsZWN0KHRhYjogQ2FyZFRhYkNvbXBvbmVudCwgZWxlbWVudDogSFRNTEVsZW1lbnQpOiB2b2lkIHtcbiAgICAvLyBzZWxlY3QgdGhlIHRhYlxuICAgIHRoaXMudGFiU2VydmljZS5zZWxlY3QodGFiKTtcblxuICAgIC8vIGVuc3VyZSB0aGUgdGFiIGlzIG1vdmVkIGludG8gdmlldyBpZiByZXF1aXJlZFxuICAgIHRoaXMubW92ZUludG9WaWV3KGVsZW1lbnQpO1xuICB9XG5cbiAgcmVzaXplKGRpbWVuc2lvbnM6IFJlc2l6ZURpbWVuc2lvbnMpOiB2b2lkIHtcbiAgICB0aGlzLl93aWR0aCA9IGRpbWVuc2lvbnMud2lkdGg7XG4gICAgdGhpcy5faW5uZXJXaWR0aCA9IHRoaXMudGFibGlzdC5uYXRpdmVFbGVtZW50LnNjcm9sbFdpZHRoO1xuXG4gICAgdGhpcy5ib3VuZHMubG93ZXIgPSAwO1xuICAgIHRoaXMuYm91bmRzLnVwcGVyID0gLSh0aGlzLl9pbm5lcldpZHRoIC0gdGhpcy5fd2lkdGgpO1xuICB9XG5cbiAgcHJldmlvdXMoKTogdm9pZCB7XG4gICAgdGhpcy5vZmZzZXQgKz0gdGhpcy5fd2lkdGg7XG5cbiAgICAvLyBlbnN1cmUgaXQgcmVtYWlucyB3aXRoaW4gdGhlIGFsbG93ZWQgYm91bmRzXG4gICAgdGhpcy5vZmZzZXQgPSBNYXRoLm1pbih0aGlzLm9mZnNldCwgdGhpcy5ib3VuZHMubG93ZXIpO1xuICB9XG5cbiAgbmV4dCgpOiB2b2lkIHtcbiAgICB0aGlzLm9mZnNldCAtPSB0aGlzLl93aWR0aDtcblxuICAgIC8vIGVuc3VyZSBpdCByZW1haW5zIHdpdGhpbiB0aGUgYWxsb3dlZCBib3VuZHNcbiAgICB0aGlzLm9mZnNldCA9IE1hdGgubWF4KHRoaXMub2Zmc2V0LCB0aGlzLmJvdW5kcy51cHBlcik7XG4gIH1cblxuICBwcml2YXRlIG1vdmVJbnRvVmlldyhlbGVtZW50OiBIVE1MRWxlbWVudCk6IHZvaWQge1xuXG4gICAgLy8gaWYgd2UgZG9udCBoYXZlIHRoZSBkaW1lbnNpb25zIHdlIGNhbnQgY2hlY2tcbiAgICBpZiAoIXRoaXMuX3dpZHRoIHx8ICF0aGlzLl9pbm5lcldpZHRoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gZ2V0IHRoZSBjdXJyZW50IGVsZW1lbnQgYm91bmRzXG4gICAgY29uc3QgeyBvZmZzZXRMZWZ0LCBvZmZzZXRXaWR0aCB9ID0gZWxlbWVudDtcbiAgICBjb25zdCB7IG1hcmdpbkxlZnQsIG1hcmdpblJpZ2h0IH0gPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuXG4gICAgLy8gY2FsY3VsYXRlIHRoZSB2aXNpYmxlIGFyZWFcbiAgICBjb25zdCB2aWV3cG9ydFN0YXJ0ID0gTWF0aC5hYnModGhpcy5vZmZzZXQpO1xuICAgIGNvbnN0IHZpZXdwb3J0RW5kID0gdmlld3BvcnRTdGFydCArIHRoaXMuX3dpZHRoO1xuICAgIGNvbnN0IGNhcmRXaWR0aCA9IHBhcnNlRmxvYXQobWFyZ2luTGVmdCkgKyBvZmZzZXRXaWR0aCArIHBhcnNlRmxvYXQobWFyZ2luUmlnaHQpO1xuXG4gICAgLy8gaWYgd2UgbmVlZCB0byBtb3ZlIHRvIHRoZSBsZWZ0IC0gZmlndXJlIG91dCBob3cgbXVjaFxuICAgIGlmIChvZmZzZXRMZWZ0IDwgdmlld3BvcnRTdGFydCkge1xuICAgICAgdGhpcy5vZmZzZXQgLT0gKG9mZnNldExlZnQgLSBwYXJzZUZsb2F0KG1hcmdpbkxlZnQpKSAtIHZpZXdwb3J0U3RhcnQ7XG4gICAgfVxuICAgIFxuICAgIC8vIGlmIHdlIG5lZWQgdG8gbW92ZSB0byB0aGUgcmlnaHQgLSBmaWd1cmUgb3V0IGhvdyBtdWNoXG4gICAgaWYgKChvZmZzZXRMZWZ0ICsgY2FyZFdpZHRoKSA+IHZpZXdwb3J0RW5kKSB7XG4gICAgICB0aGlzLm9mZnNldCAtPSAob2Zmc2V0TGVmdCArIGNhcmRXaWR0aCkgLSB2aWV3cG9ydEVuZDtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBDYXJkVGFic0JvdW5kcyB7XG4gIGxvd2VyOiBudW1iZXI7XG4gIHVwcGVyOiBudW1iZXI7XG59XG4iLCJpbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFJlc2l6ZU1vZHVsZSB9IGZyb20gJy4uLy4uL2RpcmVjdGl2ZXMvcmVzaXplL2luZGV4JztcbmltcG9ydCB7IENhcmRUYWJDb250ZW50RGlyZWN0aXZlIH0gZnJvbSAnLi9jYXJkLXRhYi9jYXJkLXRhYi1jb250ZW50LmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBDYXJkVGFiQ29tcG9uZW50IH0gZnJvbSAnLi9jYXJkLXRhYi9jYXJkLXRhYi5jb21wb25lbnQnO1xuaW1wb3J0IHsgQ2FyZFRhYnNldENvbXBvbmVudCB9IGZyb20gJy4vY2FyZC10YWJzZXQvY2FyZC10YWJzZXQuY29tcG9uZW50JztcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW1xuICAgIENvbW1vbk1vZHVsZSxcbiAgICBSZXNpemVNb2R1bGVcbiAgXSxcbiAgZGVjbGFyYXRpb25zOiBbQ2FyZFRhYnNldENvbXBvbmVudCwgQ2FyZFRhYkNvbXBvbmVudCwgQ2FyZFRhYkNvbnRlbnREaXJlY3RpdmVdLFxuICBleHBvcnRzOiBbQ2FyZFRhYnNldENvbXBvbmVudCwgQ2FyZFRhYkNvbXBvbmVudCwgQ2FyZFRhYkNvbnRlbnREaXJlY3RpdmVdXG59KVxuZXhwb3J0IGNsYXNzIENhcmRUYWJzTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIElucHV0LCBPdXRwdXQsIGZvcndhcmRSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBOR19WQUxVRV9BQ0NFU1NPUiB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuZXhwb3J0IGNvbnN0IENIRUNLQk9YX1ZBTFVFX0FDQ0VTU09SOiBhbnkgPSB7XG4gICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gQ2hlY2tib3hDb21wb25lbnQpLFxuICAgIG11bHRpOiB0cnVlXG59O1xuXG5sZXQgdW5pcXVlQ2hlY2tib3hJZCA9IDA7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtY2hlY2tib3gnLFxuICAgIHRlbXBsYXRlOiBgPGxhYmVsIFthdHRyLmZvcl09XCJpbnB1dElkXCJcbiAgICAgICBjbGFzcz1cInV4LWNoZWNrYm94XCJcbiAgICAgICBbY2xhc3MudXgtY2hlY2tib3gtY2hlY2tlZF09XCJ2YWx1ZSA9PT0gdHJ1ZVwiXG4gICAgICAgW2NsYXNzLnV4LWNoZWNrYm94LWluZGV0ZXJtaW5hdGVdPVwiaW5kZXRlcm1pbmF0ZVwiXG4gICAgICAgW2NsYXNzLnV4LWNoZWNrYm94LXNpbXBsaWZpZWRdPVwic2ltcGxpZmllZFwiXG4gICAgICAgW2NsYXNzLnV4LWNoZWNrYm94LWRpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICBbY2xhc3MudXgtY2hlY2tib3gtZm9jdXNlZF09XCJmb2N1c2VkXCI+XG5cbiAgICA8ZGl2IGNsYXNzPVwidXgtY2hlY2tib3gtY29udGFpbmVyXCI+XG4gICAgICAgIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIlxuICAgICAgICAgICAgICAgY2xhc3M9XCJ1eC1jaGVja2JveC1pbnB1dFwiXG4gICAgICAgICAgICAgICBbaWRdPVwiaW5wdXRJZFwiXG4gICAgICAgICAgICAgICBbcmVxdWlyZWRdPVwicmVxdWlyZWRcIlxuICAgICAgICAgICAgICAgW2NoZWNrZWRdPVwidmFsdWVcIlxuICAgICAgICAgICAgICAgW2F0dHIudmFsdWVdPVwidmFsdWVcIlxuICAgICAgICAgICAgICAgW2Rpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICAgICAgICAgIFthdHRyLm5hbWVdPVwibmFtZVwiXG4gICAgICAgICAgICAgICBbdGFiaW5kZXhdPVwidGFiaW5kZXhcIlxuICAgICAgICAgICAgICAgW2luZGV0ZXJtaW5hdGVdPVwiaW5kZXRlcm1pbmF0ZVwiXG4gICAgICAgICAgICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cImFyaWFMYWJlbFwiXG4gICAgICAgICAgICAgICBbYXR0ci5hcmlhLWxhYmVsbGVkYnldPVwiYXJpYUxhYmVsbGVkYnlcIlxuICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1jaGVja2VkXT1cImFyaWFDaGVja2VkXCJcbiAgICAgICAgICAgICAgIChmb2N1cyk9XCJmb2N1c2VkID0gdHJ1ZVwiXG4gICAgICAgICAgICAgICAoYmx1cik9XCJmb2N1c2VkID0gZmFsc2VcIlxuICAgICAgICAgICAgICAgKGNoYW5nZSk9XCIkZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcIlxuICAgICAgICAgICAgICAgKGNsaWNrKT1cInRvZ2dsZSgpXCI+XG4gICAgPC9kaXY+XG5cbiAgICA8c3BhbiBjbGFzcz1cInV4LWNoZWNrYm94LWxhYmVsXCI+XG4gICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICA8L3NwYW4+XG48L2xhYmVsPlxuYCxcbiAgICBwcm92aWRlcnM6IFtDSEVDS0JPWF9WQUxVRV9BQ0NFU1NPUl1cbn0pXG5leHBvcnQgY2xhc3MgQ2hlY2tib3hDb21wb25lbnQgaW1wbGVtZW50cyBDb250cm9sVmFsdWVBY2Nlc3NvciB7XG5cbiAgICBwcml2YXRlIF9jaGVja2JveElkOiBzdHJpbmcgPSBgdXgtY2hlY2tib3gtJHsrK3VuaXF1ZUNoZWNrYm94SWR9YDtcblxuICAgIEBJbnB1dCgpIGlkOiBzdHJpbmcgPSB0aGlzLl9jaGVja2JveElkO1xuICAgIEBJbnB1dCgpIG5hbWU6IHN0cmluZyB8IG51bGw7XG4gICAgQElucHV0KCkgcmVxdWlyZWQ6IGJvb2xlYW47XG4gICAgQElucHV0KCkgdGFiaW5kZXg6IG51bWJlciA9IDA7XG4gICAgQElucHV0KCkgY2xpY2thYmxlOiBib29sZWFuID0gdHJ1ZTtcbiAgICBASW5wdXQoKSBzaW1wbGlmaWVkOiBib29sZWFuID0gZmFsc2U7XG4gICAgQElucHV0KCkgaW5kZXRlcm1pbmF0ZVZhbHVlOiBhbnkgPSAtMTtcbiAgICBASW5wdXQoKSBkaXNhYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIEBJbnB1dCgnYXJpYS1sYWJlbCcpIGFyaWFMYWJlbDogc3RyaW5nID0gJyc7XG4gICAgQElucHV0KCdhcmlhLWxhYmVsbGVkYnknKSBhcmlhTGFiZWxsZWRieTogc3RyaW5nID0gbnVsbDtcblxuICAgIEBPdXRwdXQoKSB2YWx1ZUNoYW5nZTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuICAgIEBJbnB1dCgpXG4gICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgfVxuXG4gICAgc2V0IHZhbHVlKHZhbHVlOiBhbnkpIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcblxuICAgICAgICAvLyBkZXRlcm1pbmUgaWYgaXQgaXMgaW4gdGhlIGluZGV0ZXJtaW5hdGUgc3RhdGVcbiAgICAgICAgdGhpcy5pbmRldGVybWluYXRlID0gdGhpcy5fdmFsdWUgPT09IHRoaXMuaW5kZXRlcm1pbmF0ZVZhbHVlO1xuXG4gICAgICAgIC8vIGRldGVybWluZSB0aGUgY2hlY2tlZCBzdGF0ZVxuICAgICAgICB0aGlzLmFyaWFDaGVja2VkID0gdGhpcy5pbmRldGVybWluYXRlID8gJ21peGVkJyA6IHRoaXMuX3ZhbHVlO1xuXG4gICAgICAgIC8vIGludm9rZSBjaGFuZ2UgZXZlbnRcbiAgICAgICAgdGhpcy52YWx1ZUNoYW5nZS5lbWl0KHRoaXMuX3ZhbHVlKTtcblxuICAgICAgICAvLyBjYWxsIGNhbGxiYWNrXG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjayh0aGlzLl92YWx1ZSk7XG4gICAgICAgIHRoaXMub25Ub3VjaGVkQ2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICBnZXQgaW5wdXRJZCgpOiBzdHJpbmcgeyBcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuaWQgfHwgdGhpcy5fY2hlY2tib3hJZH0taW5wdXRgO1xuICAgIH1cblxuICAgIHByaXZhdGUgX3ZhbHVlOiBhbnkgPSBmYWxzZTtcblxuICAgIGluZGV0ZXJtaW5hdGU6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBhcmlhQ2hlY2tlZDogYm9vbGVhbiB8IHN0cmluZztcbiAgICBmb2N1c2VkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBvblRvdWNoZWRDYWxsYmFjazogKCkgPT4gdm9pZCA9ICgpID0+IHsgfTtcbiAgICBvbkNoYW5nZUNhbGxiYWNrOiAoXzogYW55KSA9PiB2b2lkID0gKCkgPT4geyB9O1xuXG4gICAgdG9nZ2xlKCk6IHZvaWQge1xuXG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkIHx8ICF0aGlzLmNsaWNrYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMudmFsdWUgPT09IHRoaXMuaW5kZXRlcm1pbmF0ZVZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRvZ2dsZSB0aGUgY2hlY2tlZCBzdGF0ZVxuICAgICAgICB0aGlzLnZhbHVlID0gIXRoaXMudmFsdWU7XG4gICAgfVxuXG4gICAgLy8gRnVuY3Rpb25zIHJlcXVpcmVkIHRvIHVwZGF0ZSBuZ01vZGVsXG5cbiAgICB3cml0ZVZhbHVlKHZhbHVlOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLl92YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm46IGFueSk6IHZvaWQge1xuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2sgPSBmbjtcbiAgICB9XG5cbiAgICByZWdpc3Rlck9uVG91Y2hlZChmbjogYW55KTogdm9pZCB7XG4gICAgICAgIHRoaXMub25Ub3VjaGVkQ2FsbGJhY2sgPSBmbjtcbiAgICB9XG5cbiAgICBzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQ6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGlzRGlzYWJsZWQ7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Rm9ybXNNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuaW1wb3J0IHsgQ2hlY2tib3hDb21wb25lbnQgfSBmcm9tICcuL2NoZWNrYm94LmNvbXBvbmVudCc7XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW0Zvcm1zTW9kdWxlXSxcbiAgICBleHBvcnRzOiBbQ2hlY2tib3hDb21wb25lbnRdLFxuICAgIGRlY2xhcmF0aW9uczogW0NoZWNrYm94Q29tcG9uZW50XVxufSlcbmV4cG9ydCBjbGFzcyBDaGVja2JveE1vZHVsZSB7IH1cbiIsImltcG9ydCB7IENvbHVtblNvcnRpbmdEaXJlY3RpdmUsIENvbHVtblNvcnRpbmdPcmRlciB9IGZyb20gJy4vY29sdW1uLXNvcnRpbmcuZGlyZWN0aXZlJztcbmltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIE91dHB1dCwgRXZlbnRFbWl0dGVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtY29sdW1uLXNvcnRpbmcnLFxuICAgIHRlbXBsYXRlOiBgPGRpdiBjbGFzcz1cInV4LWNvbHVtbi1zb3J0aW5nXCI+XG4gICAgPGkgY2xhc3M9XCJ1eC1jb2x1bW4tc29ydGluZy1pY29uIGhwZS1pY29uXCIgXG4gICAgICAgIFtjbGFzcy5ocGUtYXNjZW5kXT1cInN0YXRlID09PSBjb2x1bW5Tb3J0aW5nU3RhdGUuQXNjZW5kaW5nXCIgXG4gICAgICAgIFtjbGFzcy5ocGUtZGVzY2VuZF09XCJzdGF0ZSA9PT0gY29sdW1uU29ydGluZ1N0YXRlLkRlc2NlbmRpbmdcIiBcbiAgICAgICAgW2NsYXNzLmNvbHVtbi1zb3J0aW5nLWljb24taGlkZGVuXT1cInN0YXRlID09PSBjb2x1bW5Tb3J0aW5nU3RhdGUuTm9Tb3J0XCI+PC9pPlxuICAgIDxwIGNsYXNzPVwidXgtY29sdW1uLXNvcnRpbmctbnVtYmVyXCI+e3sgb3JkZXJOdW1iZXIgfX08L3A+XG48L2Rpdj5gLFxuICAgIGV4cG9ydEFzOiAndXgtY29sdW1uLXNvcnRpbmcnXG59KVxuZXhwb3J0IGNsYXNzIENvbHVtblNvcnRpbmdDb21wb25lbnQge1xuXG4gICAgQElucHV0KCkgc3RhdGU6IENvbHVtblNvcnRpbmdTdGF0ZTtcbiAgICBASW5wdXQoKSBrZXk6IHN0cmluZztcbiAgICBASW5wdXQoKSBvcmRlck51bWJlcjogbnVtYmVyO1xuICAgIEBPdXRwdXQoKSBzdGF0ZUNoYW5nZTogRXZlbnRFbWl0dGVyPENvbHVtblNvcnRpbmdTdGF0ZT4gPSBuZXcgRXZlbnRFbWl0dGVyPENvbHVtblNvcnRpbmdTdGF0ZT4oKTtcblxuICAgIHByaXZhdGUgX3BhcmVudDogQ29sdW1uU29ydGluZ0RpcmVjdGl2ZTtcbiAgICBjb2x1bW5Tb3J0aW5nU3RhdGUgPSBDb2x1bW5Tb3J0aW5nU3RhdGU7XG5cbiAgICBpbml0UGFyZW50KHBhcmVudDogQ29sdW1uU29ydGluZ0RpcmVjdGl2ZSkge1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG5cbiAgICAgICAgLy8gd2F0Y2ggZm9yIGFueSBldmVudHNcbiAgICAgICAgdGhpcy5fcGFyZW50LmV2ZW50cy5zdWJzY3JpYmUoZXZlbnQgPT4ge1xuXG4gICAgICAgICAgICBsZXQgaWR4ID0gZXZlbnQuZmluZEluZGV4KGNvbHVtbiA9PiBjb2x1bW4ua2V5ID09PSB0aGlzLmtleSk7XG5cbiAgICAgICAgICAgIGlmIChpZHggPT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gQ29sdW1uU29ydGluZ1N0YXRlLk5vU29ydDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gb25seSBzdG9yZSB0aGUgbnVtYmVyIGlmIHdlIGhhdmUgMiBvciBtb3JlIGNvbHVtbnMgYmVpbmcgc29ydGVkXG4gICAgICAgICAgICBpZiAoZXZlbnQubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMub3JkZXJOdW1iZXIgPSBpZHggPT09IC0xID8gbnVsbCA6IGlkeCArIDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMub3JkZXJOdW1iZXIgPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnN0YXRlQ2hhbmdlLmVtaXQodGhpcy5zdGF0ZSk7XG5cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgY2hhbmdlU3RhdGUoKTogQ29sdW1uU29ydGluZ09yZGVyW10ge1xuXG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBDb2x1bW5Tb3J0aW5nU3RhdGUuQXNjZW5kaW5nKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gQ29sdW1uU29ydGluZ1N0YXRlLkRlc2NlbmRpbmc7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gQ29sdW1uU29ydGluZ1N0YXRlLkRlc2NlbmRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBDb2x1bW5Tb3J0aW5nU3RhdGUuTm9Tb3J0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IENvbHVtblNvcnRpbmdTdGF0ZS5Bc2NlbmRpbmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpbmZvcm0gcGFyZW50XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnQudG9nZ2xlQ29sdW1uKHRoaXMua2V5LCB0aGlzLnN0YXRlKTtcblxuICAgIH1cbn1cblxuZXhwb3J0IGVudW0gQ29sdW1uU29ydGluZ1N0YXRlIHtcbiAgICBBc2NlbmRpbmcsXG4gICAgRGVzY2VuZGluZyxcbiAgICBOb1NvcnRcbn0iLCJpbXBvcnQgeyBDb2x1bW5Tb3J0aW5nQ29tcG9uZW50LCBDb2x1bW5Tb3J0aW5nU3RhdGUgfSBmcm9tICcuL2NvbHVtbi1zb3J0aW5nLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBEaXJlY3RpdmUsIEhvc3QsIFF1ZXJ5TGlzdCwgQ29udGVudENoaWxkcmVuLCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3V4Q29sdW1uU29ydGluZ10nXG59KVxuZXhwb3J0IGNsYXNzIENvbHVtblNvcnRpbmdEaXJlY3RpdmUge1xuXG4gICAgQElucHV0KCkgc2luZ2xlU29ydDogYm9vbGVhbjtcbiAgICBAQ29udGVudENoaWxkcmVuKENvbHVtblNvcnRpbmdDb21wb25lbnQpIGNvbXBvbmVudHM6IFF1ZXJ5TGlzdDxDb2x1bW5Tb3J0aW5nQ29tcG9uZW50PjtcblxuICAgIGV2ZW50czogU3ViamVjdDxDb2x1bW5Tb3J0aW5nT3JkZXJbXT4gPSBuZXcgU3ViamVjdDxDb2x1bW5Tb3J0aW5nT3JkZXJbXT4oKTtcbiAgICBvcmRlcjogQ29sdW1uU29ydGluZ09yZGVyW10gPSBbXTtcblxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnRzLmZvckVhY2goY29tcG9uZW50ID0+IGNvbXBvbmVudC5pbml0UGFyZW50KHRoaXMpKTtcbiAgICB9XG5cbiAgICB0b2dnbGVDb2x1bW4oa2V5OiBzdHJpbmcsIHN0YXRlOiBDb2x1bW5Tb3J0aW5nU3RhdGUpIHtcblxuICAgICAgICBpZiAodGhpcy5zaW5nbGVTb3J0KSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUgPT09IENvbHVtblNvcnRpbmdTdGF0ZS5Ob1NvcnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9yZGVyID0gW107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMub3JkZXIgPSBbe2tleToga2V5LCBzdGF0ZTogc3RhdGV9XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHJlb3JkZXIgY29sdW1ucyBoZXJlXG4gICAgICAgICAgICBsZXQgaWR4ID0gdGhpcy5vcmRlci5maW5kSW5kZXgoY29sdW1uID0+IGNvbHVtbi5rZXkgPT09IGtleSk7XG5cbiAgICAgICAgICAgIC8vIGlmIHdhc250IHByZXZpb3VzbHkgc2VsZWN0ZWQgYWRkIHRvIGxpc3RcbiAgICAgICAgICAgIGlmIChpZHggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcmRlci5wdXNoKHsga2V5OiBrZXksIHN0YXRlOiBzdGF0ZX0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gQ29sdW1uU29ydGluZ1N0YXRlLkFzY2VuZGluZyB8fCBzdGF0ZSA9PT0gQ29sdW1uU29ydGluZ1N0YXRlLkRlc2NlbmRpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9yZGVyLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgICAgICAgIHRoaXMub3JkZXIucHVzaCh7IGtleToga2V5LCBzdGF0ZTogc3RhdGV9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcmRlci5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5uZXh0KHRoaXMub3JkZXIpO1xuICAgICAgICAgICAgLy8gcmV0dXJuIHRoZSBvcmRlclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3JkZXI7XG5cbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29sdW1uU29ydGluZ09yZGVyIHtcbiAgICBrZXk6IHN0cmluZztcbiAgICBzdGF0ZTogQ29sdW1uU29ydGluZ1N0YXRlOyBcbn0iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBDb2x1bW5Tb3J0aW5nQ29tcG9uZW50IH0gZnJvbSAnLi9jb2x1bW4tc29ydGluZy5jb21wb25lbnQnO1xuXG5pbXBvcnQgeyBDb2x1bW5Tb3J0aW5nRGlyZWN0aXZlIH0gZnJvbSAnLi9jb2x1bW4tc29ydGluZy5kaXJlY3RpdmUnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGV4cG9ydHM6IFtDb2x1bW5Tb3J0aW5nQ29tcG9uZW50LCBDb2x1bW5Tb3J0aW5nRGlyZWN0aXZlXSxcbiAgICBkZWNsYXJhdGlvbnM6IFtDb2x1bW5Tb3J0aW5nQ29tcG9uZW50LCBDb2x1bW5Tb3J0aW5nRGlyZWN0aXZlXVxufSlcbmV4cG9ydCBjbGFzcyBDb2x1bW5Tb3J0aW5nTW9kdWxlIHsgfSIsImltcG9ydCB7IGRpc3RpbmN0VW50aWxDaGFuZ2VkLCBmaWx0ZXIsIHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzL1N1YmplY3QnO1xuaW1wb3J0IHsgQ29uZHVpdFpvbmUgfSBmcm9tICcuL2NvbmR1aXQtem9uZS5zZXJ2aWNlJztcbmltcG9ydCB7IENvbmR1aXRFdmVudCB9IGZyb20gJy4vaW50ZXJmYWNlcy9jb25kdWl0LWV2ZW50JztcbmltcG9ydCB7IENvbmR1aXRNZXRhZGF0YSB9IGZyb20gJy4vaW50ZXJmYWNlcy9jb25kdWl0LW1ldGFkYXRhJztcblxuZXhwb3J0IGNsYXNzIENvbmR1aXRTdWJqZWN0IHtcblxuICAgIHByaXZhdGUgX3N1YmplY3Q6IFN1YmplY3Q8YW55PjtcbiAgICBwcml2YXRlIF9vbkRlc3Ryb3kgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGNvbmR1aXQ6IENvbmR1aXRNZXRhZGF0YSwgcHJpdmF0ZSBfem9uZTogQ29uZHVpdFpvbmUsIHB1YmxpYyB6b25lSWQ6IHN0cmluZykge1xuXG4gICAgICAgIC8vIHN0b3JlIHRoZSB0YXJnZXQgc3ViamVjdCBvYmplY3RcbiAgICAgICAgdGhpcy5fc3ViamVjdCA9IGNvbmR1aXQuc3ViamVjdDtcblxuICAgICAgICAvLyBjaGVjayBpZiB0aGVyZSBhcmUgYW55IGNvbmR1aXRzIHRoYXQgaGF2ZSBzdXBwbGllZCBhbiBpbml0aWFsIHZhbHVlXG4gICAgICAgIHRoaXMuZ2V0SW5pdGlhbFZhbHVlKCk7XG5cbiAgICAgICAgLy8gc3Vic2NyaWJlIHRvIGNoYW5nZXMgdG8gdGhlIHNvdXJjZSBzdWJqZWN0XG4gICAgICAgIHRoaXMuX3N1YmplY3QucGlwZShkaXN0aW5jdFVudGlsQ2hhbmdlZChjb25kdWl0LmNoYW5nZURldGVjdGlvbiksIHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSh0aGlzLm9uT3V0cHV0LmJpbmQodGhpcykpO1xuXG4gICAgICAgIC8vIHN1YnNjcmliZSB0byB0aGUgem9uZSBldmVudHMgYW5kIHJvb3Qgem9uZSBldmVudHNcbiAgICAgICAgX3pvbmUuZ2V0RXZlbnRzKCkucGlwZShmaWx0ZXIoZXZlbnQgPT4gZXZlbnQuY29uZHVpdC5pZCA9PT0gY29uZHVpdC5pZCksIHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUodGhpcy5vbklucHV0LmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIC8qKiBDaGVjayBhbGwgYWxsb3cgaW5wdXRzIHRvIHNlZSBpZiB0aGVyZSBpcyBhIHZhbHVlIHdlIHNob3VsZCBpbml0aWFsbHkgc2V0IHRoZSBjb25kdWl0IHRvICovXG4gICAgZ2V0SW5pdGlhbFZhbHVlKCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGlmIHdlIGRvIG5vdCBhY2NlcHQgaW5wdXRzIHRoZW4gZG8gbm90aGluZ1xuICAgICAgICBpZiAodGhpcy5jb25kdWl0LmFjY2VwdHNJbnB1dCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJldHVybiBhbGwgc3ViamVjdHMgdGhhdCBhcmUgMSkgTm90IGl0c2VsZiAyKSBJbiBhIHpvbmUgdGhhdCBpcyBsaXN0ZWQgaW4gYWNjZXB0c0lucHV0IDMpIEhhdmUgYSBjdXJyZW50VmFsdWUgc2V0XG4gICAgICAgIGNvbnN0IHN1YmplY3RzID0gdGhpcy5fem9uZS5nZXRTdWJqZWN0cygpLmZpbHRlcihzdWJqZWN0ID0+IHtcblxuICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBpdHNlbGYgb3IgaWYgaXQgaGFzIG5vdCB2YWx1ZSB0byBnaXZlIHVzIHRoZW4gZG8gbm90aGluZ1xuICAgICAgICAgICAgaWYgKHN1YmplY3QgPT09IHRoaXMgfHwgc3ViamVjdC5jb25kdWl0LmlkICE9PSB0aGlzLmNvbmR1aXQuaWQgfHwgIXN1YmplY3QuY29uZHVpdC5oYXNPd25Qcm9wZXJ0eSgnY3VycmVudFZhbHVlJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIGFjY2VwdHNJbnB1dCBpcyB0cnVlIHRoZW4gd2UgcmV0dXJuIGV2ZXJ5IHRpbWVcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmR1aXQuYWNjZXB0c0lucHV0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuY29uZHVpdC5hY2NlcHRzSW5wdXQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZHVpdC5hY2NlcHRzSW5wdXQuaW5kZXhPZihzdWJqZWN0LnpvbmVJZCkgIT09IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBpZiB0aGVyZSBhcmUgbm8gbWF0Y2hlcyB0aGVuIGRvIG5vdGhpbmdcbiAgICAgICAgaWYgKHN1YmplY3RzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gb3RoZXJ3aXNlIHNvcnQgYnkgdGhlIGxhc3QgbW9kaWZpZWQgZmllbGRcbiAgICAgICAgc3ViamVjdHMuc29ydCgoc3ViamVjdE9uZSwgc3ViamVjdFR3bykgPT4gc3ViamVjdE9uZS5jb25kdWl0Lmxhc3RNb2RpZmllZC5nZXRUaW1lKCkgPCBzdWJqZWN0VHdvLmNvbmR1aXQubGFzdE1vZGlmaWVkLmdldFRpbWUoKSA/IDEgOiAtMSk7XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBtb3N0IHJlY2VudCB2YWx1ZVxuICAgICAgICB0aGlzLl9zdWJqZWN0Lm5leHQoc3ViamVjdHNbMF0uY29uZHVpdC5jdXJyZW50VmFsdWUpO1xuICAgIH1cblxuICAgIC8qKiBUaGlzIHdpbGwgYmUgdHJpZ2dlcmVkIHdoZW4gYSBjb25kdWl0cyB2YWx1ZSBoYXMgY2hhbmdlZCAqL1xuICAgIG9uSW5wdXQoZXZlbnQ6IENvbmR1aXRFdmVudCk6IHZvaWQge1xuICAgICAgICAvLyBpZiB3ZSBkb250IGFjY2VwdCBpbnB1dCBvciB3ZSBlbWl0dGVkIHRoaXMgdmFsdWUgdGhlbiBkbyBub3RoaW5nXG4gICAgICAgIGlmICh0aGlzLmNvbmR1aXQuYWNjZXB0c0lucHV0ID09PSBmYWxzZSB8fCBldmVudC5jb25kdWl0ID09PSB0aGlzLmNvbmR1aXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZSBjb25kdWl0IHByb2R1Y2VzIG91dHB1dCAtIGlmIG5vdCB3ZSBvbmx5IGRvIHNvbWV0aGluZyBpZiB3ZSBhcmUgaW4gdGhlIHNhbWUgem9uZVxuICAgICAgICBpZiAoZXZlbnQuY29uZHVpdC5wcm9kdWNlc091dHB1dCA9PT0gZmFsc2UgJiYgZXZlbnQuem9uZUlkICE9PSB0aGlzLnpvbmVJZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgd2Ugb25seSBhY2NlcHQgaW5wdXRzIGZyb20gc3BlY2lmaWMgem9uZXNcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5jb25kdWl0LmFjY2VwdHNJbnB1dCkpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBldmVudCBjYW1lIGZyb20gYW4gYWNjZXB0YWJsZSB6b25lXG4gICAgICAgICAgICBpZiAoIXRoaXMuY29uZHVpdC5hY2NlcHRzSW5wdXQuZmluZCh6b25lID0+IHpvbmUgPT09IGV2ZW50LnpvbmVJZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiByZXF1aXJlZCB0cmFuc2Zvcm0gdGhlIHZhbHVlXG4gICAgICAgIGNvbnN0IG91dHB1dFZhbHVlID0gdGhpcy5jb25kdWl0Lm1hcCA/IHRoaXMuY29uZHVpdC5tYXAoZXZlbnQudmFsdWUpIDogZXZlbnQudmFsdWU7XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBzdWJqZWN0XG4gICAgICAgIHRoaXMuX3N1YmplY3QubmV4dChvdXRwdXRWYWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqIFRoaXMgd2lsbCBiZSBmaXJlZCB3aGVuIHRoaXMgY29uZHVpdCBlbWl0cyBhIG5ldyB2YWx1ZSAqL1xuICAgIG9uT3V0cHV0KHZhbHVlOiBhbnkpOiB2b2lkIHtcblxuICAgICAgICAvLyBzdG9yZSB0aGUgbW9zdCByZWNlbnQgdmFsdWUgYW5kIHdoZW4gaXQgd2FzIG1vZGlmaWVkIC0gY2FuIGJlIHVzZWQgZm9yIGFueSBuZXcgY29uZHVpdHMgdG8gbG9va3VwIGEgdmFsdWVcbiAgICAgICAgdGhpcy5jb25kdWl0LmN1cnJlbnRWYWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmNvbmR1aXQubGFzdE1vZGlmaWVkID0gbmV3IERhdGUoKTtcblxuICAgICAgICAvLyBjaGVjayBpZiB0aGlzIHNob3VsZCBwcm9kdWNlIG91dHB1dFxuICAgICAgICBpZiAodGhpcy5jb25kdWl0LnByb2R1Y2VzT3V0cHV0KSB7XG4gICAgICAgICAgICB0aGlzLl96b25lLmVtaXQoeyBjb25kdWl0OiB0aGlzLmNvbmR1aXQsIHpvbmVJZDogdGhpcy56b25lSWQsIHZhbHVlIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIFVuc3Vic2NyaWJlIG9uY2UgdGhpcyBzdWJqZWN0IGlzIGRlc3Ryb3llZCAqL1xuICAgIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX29uRGVzdHJveS5uZXh0KCk7XG4gICAgICAgIHRoaXMuX29uRGVzdHJveS5jb21wbGV0ZSgpO1xuICAgIH1cbn1cbiIsIi8qKiBUaGlzIHV0aWxpdHkgaXMgdG8gZW5zdXJlIGEgYWxsIGZ1bmN0aW9ucyB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZSBhcmUgY2FsbGVkIGluIGFsbCBzdXBlciBjbGFzc2VzICovXG5leHBvcnQgZnVuY3Rpb24gaW52b2tlU3VwZXJGdW5jdGlvbih0YXJnZXQ6IG9iamVjdCwgZnVuY3Rpb25OYW1lOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAvLyBnZXQgYWxsIGluc3RhbmNlcyBvZiB0aGUgZnVuY3Rpb25cbiAgICBjb25zdCBmdW5jdGlvbkxpc3Q6IEZ1bmN0aW9uW10gPSBbXTtcblxuICAgIC8vIHN0b3JlIHRoZSBjdXJyZW50IHByb3RvdHlwZSB3ZSBhcmUgY2hlY2tpbmdcbiAgICBsZXQgcHJvdG90eXBlOiBhbnkgPSB0YXJnZXQ7XG5cbiAgICAvLyBsb29rIHRocm91Z2ggZXZlcnkgYmFzZSBjbGFzcyBhbmQgY2hlY2sgaXRcbiAgICBkbyB7XG4gICAgICAgIGlmIChwcm90b3R5cGUuaGFzT3duUHJvcGVydHkoZnVuY3Rpb25OYW1lKSkge1xuICAgICAgICAgICAgZnVuY3Rpb25MaXN0LnB1c2gocHJvdG90eXBlW2Z1bmN0aW9uTmFtZV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvdG90eXBlID0gcHJvdG90eXBlLl9fcHJvdG9fXztcbiAgICB9IHdoaWxlIChwcm90b3R5cGUuX19wcm90b19fKTtcblxuICAgIC8vIGF1Z21lbnQgdGhlIHRvcCBsZXZlbCBmdW5jdGlvbiB0byBjYWxsIGFsbCB0aGUgZnVuY3Rpb25zXG4gICAgdGFyZ2V0W2Z1bmN0aW9uTmFtZV0gPSBmdW5jdGlvbiAoLi4uYXJnczogYW55W10pIHtcbiAgICAgICAgZnVuY3Rpb25MaXN0LmZvckVhY2goZnVuYyA9PiBmdW5jLmNhbGwodGFyZ2V0LCAuLi5hcmdzKSk7XG4gICAgfTtcbn1cbiIsImltcG9ydCB7IEluamVjdGFibGUsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XG5pbXBvcnQgeyBDb25kdWl0U3ViamVjdCB9IGZyb20gJy4vY29uZHVpdC1zdWJqZWN0JztcbmltcG9ydCB7IENvbmR1aXRFdmVudCB9IGZyb20gJy4vaW50ZXJmYWNlcy9jb25kdWl0LWV2ZW50JztcbmltcG9ydCB7IENvbmR1aXRNZXRhZGF0YSB9IGZyb20gJy4vaW50ZXJmYWNlcy9jb25kdWl0LW1ldGFkYXRhJztcbmltcG9ydCB7IENvbmR1aXRQcm9wZXJ0aWVzIH0gZnJvbSAnLi9pbnRlcmZhY2VzL2NvbmR1aXQtcHJvcGVydGllcyc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBDb25kdWl0Wm9uZSBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG5cbiAgICAvKiogQ3JlYXRlIGEgZ2xvYmFsIHN1YmplY3Qgc3RvcmUgKi9cbiAgICBzdGF0aWMgc3ViamVjdHM6IENvbmR1aXRTdWJqZWN0W10gPSBbXTtcblxuICAgIC8qKiBFeHBvc2UgYW4gZXZlbnQgc3RyZWFtIG9mIG5ldyB2YWx1ZXMgKi9cbiAgICBzdGF0aWMgZXZlbnRzID0gbmV3IFN1YmplY3Q8Q29uZHVpdEV2ZW50PigpO1xuXG4gICAgLyoqIFN0b3JlIHRoZSB6b25lIG5hbWUgKi9cbiAgICBwcml2YXRlIF96b25lSWQ6IHN0cmluZztcblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICAvLyBmaW5kIGFsbCBjb25kdWl0IHN1YmplY3RzIHRoYXQgYXJlIHBhcnQgb2YgdGhpcyB6b25lXG4gICAgICAgIENvbmR1aXRab25lLnN1YmplY3RzLmZpbHRlcihfc3ViamVjdCA9PiBfc3ViamVjdC56b25lSWQgPT09IHRoaXMuX3pvbmVJZClcbiAgICAgICAgICAgIC5mb3JFYWNoKF9zdWJqZWN0ID0+IHRoaXMudW5yZWdpc3RlckNvbmR1aXQoX3N1YmplY3QuY29uZHVpdCkpO1xuICAgIH1cblxuICAgIC8qKiBTdG9yZSByZWZlcmVuY2UgdG8gdGhlIHJlcG9zaXRvcnkgYW5kIGJlZ2luIHdhdGNoaW5nIGZvciBhbmQgZW1pdHRpbmcgY2hhbmdlcyAqL1xuICAgIHJlZ2lzdGVyQ29uZHVpdChjb25kdWl0OiBDb25kdWl0TWV0YWRhdGEpOiB2b2lkIHtcbiAgICAgICAgQ29uZHVpdFpvbmUuc3ViamVjdHMucHVzaChuZXcgQ29uZHVpdFN1YmplY3QoY29uZHVpdCwgdGhpcywgdGhpcy5fem9uZUlkKSk7XG4gICAgfVxuXG4gICAgLyoqIERlc3Ryb3kgYSBjb25kdWl0ICovXG4gICAgdW5yZWdpc3RlckNvbmR1aXQoY29uZHVpdDogQ29uZHVpdE1ldGFkYXRhKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHN1YmplY3QgPSB0aGlzLmdldENvbmR1aXRTdWJqZWN0KGNvbmR1aXQuc3ViamVjdCk7XG5cbiAgICAgICAgaWYgKHN1YmplY3QpIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgc3ViamVjdCBmcm9tIHRoZSBpbnRlcm5hbCBsaXN0IG9mIGNvbmR1aXQgc3ViamVjdHNcbiAgICAgICAgICAgIENvbmR1aXRab25lLnN1YmplY3RzID0gQ29uZHVpdFpvbmUuc3ViamVjdHMuZmlsdGVyKF9zdWJqZWN0ID0+IF9zdWJqZWN0ICE9PSBzdWJqZWN0KTtcblxuICAgICAgICAgICAgLy8gcGVyZm9ybSBhbGwgdW5zdWJzY3JpcHRpb25zXG4gICAgICAgICAgICBzdWJqZWN0LmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBQcm92aWRlIHRoZSB6b25lIHdpdGggYW4gSUQgKi9cbiAgICBzZXRab25lSWQoem9uZUlkOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fem9uZUlkID0gem9uZUlkO1xuICAgIH1cblxuICAgIC8qKiBFbWl0IGEgdmFsdWUgdG8gYWxsIHpvbmVzIGZvciBjaGVja2luZyAqL1xuICAgIGVtaXQoZXZlbnQ6IENvbmR1aXRFdmVudCk6IHZvaWQge1xuICAgICAgICBDb25kdWl0Wm9uZS5ldmVudHMubmV4dChldmVudCk7XG4gICAgfVxuXG4gICAgLyoqIFJldHJpZXZlIGEgY29uZHVpdCBzdWJzamVjdCBvYmplY3QgZnJvbSB0aGUgcnhqcyBzdWJqZWN0ICovXG4gICAgZ2V0Q29uZHVpdFN1YmplY3Qoc3ViamVjdDogU3ViamVjdDxhbnk+KTogQ29uZHVpdFN1YmplY3QgfCBudWxsIHtcbiAgICAgICAgcmV0dXJuIENvbmR1aXRab25lLnN1YmplY3RzLmZpbmQoX3N1YmplY3QgPT4gX3N1YmplY3QuY29uZHVpdC5zdWJqZWN0ID09PSBzdWJqZWN0KTtcbiAgICB9XG5cbiAgICAvKiogR2V0IGFsbCBzdWJqZWN0cyBmcm9tIGFsbCB6b25lcyAqL1xuICAgIGdldFN1YmplY3RzKCk6IENvbmR1aXRTdWJqZWN0W10ge1xuICAgICAgICByZXR1cm4gQ29uZHVpdFpvbmUuc3ViamVjdHM7XG4gICAgfVxuXG4gICAgLyoqIEFsdGVyIHRoZSBwcm9wZXJ0aWVzIG9mIGEgY29uZHVpdCBkeW5hbWljYWxseSAqL1xuICAgIHNldENvbmR1aXRQcm9wZXJ0aWVzKHN1YmplY3Q6IFN1YmplY3Q8YW55PiwgcHJvcGVydGllczogUGFydGlhbDxDb25kdWl0UHJvcGVydGllcz4pOiB2b2lkIHtcblxuICAgICAgICAvLyBmaW5kIHRoZSBjb25kdWl0IHdpdGggdGhlIG1hdGNoaW5nIHN1YmplY3RcbiAgICAgICAgY29uc3QgY29uZHVpdFN1YmplY3QgPSB0aGlzLmdldFN1YmplY3RzKCkuZmluZChfY29uZHVpdCA9PiBfY29uZHVpdC5jb25kdWl0LnN1YmplY3QgPT09IHN1YmplY3QpO1xuXG4gICAgICAgIC8vIGlmIGEgbWF0Y2ggd2FzIGZvdW5kIHVwZGF0ZSB0aGUgcHJvcGVydGllc1xuICAgICAgICBpZiAoY29uZHVpdFN1YmplY3QpIHtcblxuICAgICAgICAgICAgLy8gdXBkYXRlIGVhY2ggc3BlY2lmaWVkIHByb3BlcnR5XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gcHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIGNvbmR1aXRTdWJqZWN0LmNvbmR1aXRbcHJvcF0gPSBwcm9wZXJ0aWVzW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIFByb2dyYW1tYXRpY2FsbHkgY3JlYXRlIGEgY29uZHVpdCBhdCBydW50aW1lICovXG4gICAgY3JlYXRlQ29uZHVpdChzdWJqZWN0OiBTdWJqZWN0PGFueT4sIHByb3BlcnRpZXM6IENvbmR1aXRQcm9wZXJ0aWVzKTogdm9pZCB7XG5cbiAgICAgICAgLy8gcmVnaXN0ZXIgdGhlIGNvbmR1aXQgd2l0aCB0aGUgem9uZVxuICAgICAgICB0aGlzLnJlZ2lzdGVyQ29uZHVpdCh7IC4uLnByb3BlcnRpZXMsIHN1YmplY3QgfSk7XG4gICAgfVxuXG4gICAgLyoqIFJlZ2lzdGVyIGFsbCBjb25kdWl0cyBpbiBhIGNvbXBvbmVudCAqL1xuICAgIHJlZ2lzdGVyQ29uZHVpdHMoY29tcG9uZW50OiBhbnkpOiB2b2lkIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29tcG9uZW50Ll9jb25kdWl0cykpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudC5fY29uZHVpdHMuZm9yRWFjaCgoY29uZHVpdDogQ29uZHVpdE1ldGFkYXRhKSA9PiB0aGlzLnJlZ2lzdGVyQ29uZHVpdCh7IC4uLmNvbmR1aXQsIHN1YmplY3Q6IGNvbXBvbmVudFtjb25kdWl0LnByb3BlcnR5S2V5XSB9KSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogUmVnaXN0ZXIgYWxsIGNvbmR1aXRzIGluIGEgY29tcG9uZW50ICovXG4gICAgdW5yZWdpc3RlckNvbmR1aXRzKGNvbXBvbmVudDogYW55KTogdm9pZCB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbXBvbmVudC5fY29uZHVpdHMpKSB7XG4gICAgICAgICAgICBjb21wb25lbnQuX2NvbmR1aXRzLmZvckVhY2goKGNvbmR1aXQ6IENvbmR1aXRNZXRhZGF0YSkgPT4gdGhpcy51bnJlZ2lzdGVyQ29uZHVpdChjb25kdWl0KSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogUmV0dXJuIHRoZSBnbG9iYWwgZXZlbnQgc3RyZWFtICovXG4gICAgZ2V0RXZlbnRzKCk6IFN1YmplY3Q8Q29uZHVpdEV2ZW50PiB7XG4gICAgICAgIHJldHVybiBDb25kdWl0Wm9uZS5ldmVudHM7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgT25EZXN0cm95LCBPbkluaXQsIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcbmltcG9ydCB7IGludm9rZVN1cGVyRnVuY3Rpb24gfSBmcm9tICcuL2NvbmR1aXQtdXRpbHMnO1xuaW1wb3J0IHsgQ29uZHVpdFpvbmUgfSBmcm9tICcuL2NvbmR1aXQtem9uZS5zZXJ2aWNlJztcbmltcG9ydCB7IENvbmR1aXRQcm9wZXJ0aWVzIH0gZnJvbSAnLi9pbnRlcmZhY2VzL2NvbmR1aXQtcHJvcGVydGllcyc7XG5cbmV4cG9ydCBjbGFzcyBDb25kdWl0Q29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuXG4gICAgY29uc3RydWN0b3IoQE9wdGlvbmFsKCkgcHJvdGVjdGVkIF96b25lOiBDb25kdWl0Wm9uZSkge1xuICAgICAgICAvLyB3ZSB3YW50IHRvIGVuc3VyZSB0aGVzZSBmdW5jdGlvbnMgZ2V0IGNhbGxlZCBldmVuIGlmIGEgY2xhc3Mgb3ZlcnJpZGVzIHRoZW1cbiAgICAgICAgaW52b2tlU3VwZXJGdW5jdGlvbih0aGlzLCAnbmdPbkluaXQnKTtcbiAgICAgICAgaW52b2tlU3VwZXJGdW5jdGlvbih0aGlzLCAnbmdPbkRlc3Ryb3knKTtcbiAgICB9XG5cbiAgICAvKiogV2UgbmVlZCB0byByZWdpc3RlciB0aGUgY29uZHVpdHMgd2l0aCB0aGUgem9uZSB3aGVuIHRoZSBjb21wb25lbnQgaXMgaW5pdGlhbGlzZWQgKi9cbiAgICBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICAgICAgLy8gcmVnaXN0ZXIgdGhlIGNvbmR1aXQgaW4gdGhlIHpvbmUgYW5kIGVuc3VyZSBpdCBnZXRzIHRoZSBjb3JyZWN0IGluc3RhbmNlIG9mIHRoZSB0YXJnZXRcbiAgICAgICAgdGhpcy5fem9uZS5yZWdpc3RlckNvbmR1aXRzKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKiBXZSBuZWVkIHRvIHVucmVnaXN0ZXIgdGhlIGNvbmR1aXRzIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQgKi9cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fem9uZS51bnJlZ2lzdGVyQ29uZHVpdHModGhpcyk7XG4gICAgfVxuXG4gICAgLyoqIEFsdGVyIHRoZSBwcm9wZXJ0aWVzIG9mIGEgY29uZHVpdCBkeW5hbWljYWxseSAqL1xuICAgIHNldENvbmR1aXRQcm9wZXJ0aWVzKHN1YmplY3Q6IFN1YmplY3Q8YW55PiwgcHJvcGVydGllczogUGFydGlhbDxDb25kdWl0UHJvcGVydGllcz4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fem9uZS5zZXRDb25kdWl0UHJvcGVydGllcyhzdWJqZWN0LCBwcm9wZXJ0aWVzKTtcbiAgICB9XG5cbiAgICAvKiogUHJvZ3JhbW1hdGljYWxseSBjcmVhdGUgYSBjb25kdWl0IGF0IHJ1bnRpbWUgKi9cbiAgICBjcmVhdGVDb25kdWl0KHN1YmplY3Q6IFN1YmplY3Q8YW55PiwgcHJvcGVydGllczogQ29uZHVpdFByb3BlcnRpZXMpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fem9uZS5jcmVhdGVDb25kdWl0KHN1YmplY3QsIHByb3BlcnRpZXMpO1xuICAgIH1cblxufVxuIiwiaW1wb3J0IHsgT25Jbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb25kdWl0Q29tcG9uZW50IH0gZnJvbSAnLi9jb25kdWl0LmNvbXBvbmVudCc7XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBDb25kdWl0Wm9uZUNvbXBvbmVudCBleHRlbmRzIENvbmR1aXRDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xuICAgIGFic3RyYWN0IHpvbmVJZDogc3RyaW5nO1xuXG4gICAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3pvbmUuc2V0Wm9uZUlkKHRoaXMuem9uZUlkKTtcbiAgICB9XG59XG4iLCJleHBvcnQgaW50ZXJmYWNlIENvbmR1aXRQcm9wZXJ0aWVzIHtcbiAgICBpZDogbnVtYmVyIHwgc3RyaW5nO1xuICAgIGFjY2VwdHNJbnB1dD86IGJvb2xlYW4gfCBzdHJpbmdbXTtcbiAgICBwcm9kdWNlc091dHB1dD86IGJvb2xlYW47XG4gICAgY2hhbmdlRGV0ZWN0aW9uPzogKHg6IGFueSwgeTogYW55KSA9PiBib29sZWFuO1xuICAgIG1hcD86IGFueTtcbn1cblxuZXhwb3J0IGNvbnN0IGRlZmF1bHRDb25kdWl0UHJvcHM6IFBhcnRpYWw8Q29uZHVpdFByb3BlcnRpZXM+ID0ge1xuICAgIGFjY2VwdHNJbnB1dDogdHJ1ZSxcbiAgICBwcm9kdWNlc091dHB1dDogdHJ1ZSxcbn07XG4iLCJpbXBvcnQgeyBDb25kdWl0TWV0YWRhdGEgfSBmcm9tICcuL2ludGVyZmFjZXMvY29uZHVpdC1tZXRhZGF0YSc7XG5pbXBvcnQgeyBDb25kdWl0UHJvcGVydGllcywgZGVmYXVsdENvbmR1aXRQcm9wcyB9IGZyb20gJy4vaW50ZXJmYWNlcy9jb25kdWl0LXByb3BlcnRpZXMnO1xuXG4vKiogRXhwb3NlIHRoZSBwcm9wZXJ0eSB0aGF0IGNvbmR1aXRzIHdpbGwgYmUgc3RvcmVkIGluICovXG5leHBvcnQgY29uc3QgQ09ORFVJVFMgPSAnX2NvbmR1aXRzJztcblxuLyoqIENyZWF0ZSB0aGUgY29uZHVpdCBwcm9wZXJ0eSBkZWNvcmF0b3IgKi9cbmV4cG9ydCBmdW5jdGlvbiBDb25kdWl0KHByb3BlcnRpZXM6IENvbmR1aXRQcm9wZXJ0aWVzIHwgRnVuY3Rpb24pOiBQcm9wZXJ0eURlY29yYXRvciB7XG4gICAgcmV0dXJuICh0YXJnZXQ6IE9iamVjdCwgcHJvcGVydHlLZXk6IHN0cmluZykgPT4ge1xuXG4gICAgICAgIGlmICh0eXBlb2YgcHJvcGVydGllcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcHJvcGVydGllcyA9IHByb3BlcnRpZXMuY2FsbChudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoZSB0YXJnZXQgZG9lcyBub3QgYWxyZWFkeSBoYXZlIGEgY29uZHVpdCBsaXN0IHRoZW4gY3JlYXRlIG9uZVxuICAgICAgICBpZiAoIXRhcmdldC5oYXNPd25Qcm9wZXJ0eShDT05EVUlUUykpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIENPTkRVSVRTLCB7IHZhbHVlOiBbXSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCB0aGUgY29uZHVpdCB0byB0aGUgbGlzdCBlbnN1cmluZyBhbGwgcmVxdWlyZWQgcHJvcGVydGllcyBhcmUgcHJvdmlkZWRcbiAgICAgICAgdGFyZ2V0W0NPTkRVSVRTXS5wdXNoKHsgLi4uZGVmYXVsdENvbmR1aXRQcm9wcywgLi4ucHJvcGVydGllcywgdGFyZ2V0LCBwcm9wZXJ0eUtleSB9IGFzIENvbmR1aXRNZXRhZGF0YSk7XG4gICAgfTtcbn1cbiIsImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzL09ic2VydmFibGUnO1xuaW1wb3J0IHsgZGVsYXksIGRpc3RpbmN0VW50aWxDaGFuZ2VkLCBmaWx0ZXIsIG1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzL1N1YmplY3QnO1xuaW1wb3J0IHsgRGFzaGJvYXJkT3B0aW9ucyB9IGZyb20gJy4vZGFzaGJvYXJkLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBEYXNoYm9hcmRXaWRnZXRDb21wb25lbnQgfSBmcm9tICcuL3dpZGdldC9kYXNoYm9hcmQtd2lkZ2V0LmNvbXBvbmVudCc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBEYXNoYm9hcmRTZXJ2aWNlIHtcblxuICAgIHByaXZhdGUgX3dpZGdldE9yaWdpbjogeyBjb2x1bW4/OiBudW1iZXIsIHJvdz86IG51bWJlciwgY29sdW1uU3Bhbj86IG51bWJlciwgcm93U3Bhbj86IG51bWJlciB9O1xuICAgIHByaXZhdGUgX2FjdGlvbldpZGdldDogRGFzaGJvYXJkQWN0aW9uO1xuICAgIHByaXZhdGUgX3Jvd0hlaWdodDogbnVtYmVyID0gMDtcbiAgICBwcml2YXRlIF9jYWNoZTogRGFzaGJvYXJkQ2FjaGVbXTtcbiAgICBwcml2YXRlIF9tb3VzZUV2ZW50OiBNb3VzZUV2ZW50O1xuXG4gICAgd2lkZ2V0cyQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PERhc2hib2FyZFdpZGdldENvbXBvbmVudFtdPihbXSk7XG4gICAgb3B0aW9ucyQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PERhc2hib2FyZE9wdGlvbnM+KGRlZmF1bHRPcHRpb25zKTtcbiAgICBkaW1lbnNpb25zJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8RGFzaGJvYXJkRGltZW5zaW9ucz4oe30pO1xuICAgIGhlaWdodCQ6IE9ic2VydmFibGU8bnVtYmVyPiA9IHRoaXMuZGltZW5zaW9ucyQucGlwZShkZWxheSgwKSwgbWFwKChkaW1lbnNpb25zOiBEYXNoYm9hcmREaW1lbnNpb25zKSA9PiBkaW1lbnNpb25zLmhlaWdodCksIGRpc3RpbmN0VW50aWxDaGFuZ2VkKCkpO1xuICAgIHBsYWNlaG9sZGVyJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8RGFzaGJvYXJkUGxhY2Vob2xkZXI+KHsgdmlzaWJsZTogZmFsc2UsIHg6IDAsIHk6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDAgfSk7XG4gICAgbGF5b3V0JCA9IG5ldyBTdWJqZWN0PERhc2hib2FyZExheW91dERhdGFbXT4oKTtcbiAgICBzdGFja2VkJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4oZmFsc2UpO1xuXG4gICAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMkLmdldFZhbHVlKCk7XG4gICAgfVxuXG4gICAgZ2V0IHdpZGdldHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpZGdldHMkLmdldFZhbHVlKCk7XG4gICAgfVxuXG4gICAgZ2V0IHN0YWNrZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YWNrZWQkLmdldFZhbHVlKCk7XG4gICAgfVxuXG4gICAgZ2V0IGRpbWVuc2lvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpbWVuc2lvbnMkLmdldFZhbHVlKCk7XG4gICAgfVxuXG4gICAgZ2V0IGNvbHVtbldpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaW1lbnNpb25zLndpZHRoIC8gdGhpcy5vcHRpb25zLmNvbHVtbnM7XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubGF5b3V0JC5zdWJzY3JpYmUodGhpcy5zZXRMYXlvdXREYXRhLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLnN0YWNrZWQkLnBpcGUoZmlsdGVyKHN0YWNrZWQgPT4gc3RhY2tlZCA9PT0gdHJ1ZSkpLnN1YnNjcmliZSh0aGlzLnVwZGF0ZVdoZW5TdGFja2VkLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLndpZGdldHMkLnBpcGUoZGVsYXkoMCkpLnN1YnNjcmliZSgoKSA9PiB0aGlzLnJlbmRlckRhc2hib2FyZCgpKTtcbiAgICAgICAgdGhpcy5kaW1lbnNpb25zJC5waXBlKGRlbGF5KDApKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5yZW5kZXJEYXNoYm9hcmQoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgd2lkZ2V0IHRvIHRoZSBkYXNoYm9hcmRcbiAgICAgKiBAcGFyYW0gd2lkZ2V0IFRoZSB3aWRnZXQgY29tcG9uZW50IHRvIGFkZCB0byB0aGUgZGFzaGJvYXJkXG4gICAgICovXG4gICAgYWRkV2lkZ2V0KHdpZGdldDogRGFzaGJvYXJkV2lkZ2V0Q29tcG9uZW50KTogdm9pZCB7XG4gICAgICAgIHRoaXMud2lkZ2V0cyQubmV4dChbLi4udGhpcy53aWRnZXRzJC5nZXRWYWx1ZSgpLCB3aWRnZXRdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSB3aWRnZXQgZnJvbSB0aGUgZGFzaGJvYXJkXG4gICAgICogQHBhcmFtIHdpZGdldCBUaGUgd2lkZ2V0IHRvIHJlbW92ZVxuICAgICAqL1xuICAgIHJlbW92ZVdpZGdldCh3aWRnZXQ6IERhc2hib2FyZFdpZGdldENvbXBvbmVudCk6IHZvaWQge1xuICAgICAgICB0aGlzLndpZGdldHMkLm5leHQodGhpcy53aWRnZXRzJC5nZXRWYWx1ZSgpLmZpbHRlcihfd2lkZ2V0ID0+IF93aWRnZXQgIT09IHdpZGdldCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlIHRoYXQgdGhlIGRhc2hib2FyZCBlbGVtZW50IGhhcyBiZWVuIHJlc2l6ZWRcbiAgICAgKiBAcGFyYW0gd2lkdGggVGhlIHdpZHRoIG9mIHRoZSBkYXNoYm9hcmQgZWxlbWVudCBpbiBweFxuICAgICAqIEBwYXJhbSBoZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgZGFzaGJvYXJkIGVsZW1lbnQgaW4gcHhcbiAgICAgKi9cbiAgICBzZXREaW1lbnNpb25zKHdpZHRoOiBudW1iZXIgPSB0aGlzLmRpbWVuc2lvbnMud2lkdGgsIGhlaWdodDogbnVtYmVyID0gdGhpcy5kaW1lbnNpb25zLmhlaWdodCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5kaW1lbnNpb25zLndpZHRoICE9PSB3aWR0aCB8fCB0aGlzLmRpbWVuc2lvbnMuaGVpZ2h0ICE9PSBoZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuZGltZW5zaW9ucyQubmV4dCh7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9kdWNlIGFuIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgcmVxdWlyZWQgbGF5b3V0IGRhdGEuXG4gICAgICogVGhpcyBjYW4gYmUgdXNlZnVsIGZvciBleHBvcnRpbmcvc2F2aW5nIGEgbGF5b3V0XG4gICAgICovXG4gICAgZ2V0TGF5b3V0RGF0YSgpOiBEYXNoYm9hcmRMYXlvdXREYXRhW10ge1xuICAgICAgICByZXR1cm4gdGhpcy53aWRnZXRzLm1hcCh3aWRnZXQgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHsgaWQ6IHdpZGdldC5pZCwgY29sOiB3aWRnZXQuZ2V0Q29sdW1uKCksIHJvdzogd2lkZ2V0LmdldFJvdygpLCBjb2xTcGFuOiB3aWRnZXQuZ2V0Q29sdW1uU3BhbigpLCByb3dTcGFuOiB3aWRnZXQuZ2V0Um93U3BhbigpIH07XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBvc2l0aW9uIHdpZGdldHMgcHJvZ3JhbWF0aWNhbGx5XG4gICAgICovXG4gICAgc2V0TGF5b3V0RGF0YSh3aWRnZXRzOiBEYXNoYm9hcmRMYXlvdXREYXRhW10pOiB2b2lkIHtcblxuICAgICAgICAvLyBpdGVyYXRlIHRocm91Z2ggZWFjaCB3aWRnZXQgZGF0YSBhbmQgZmluZCBhIG1hdGNoXG4gICAgICAgIHdpZGdldHMuZm9yRWFjaCh3aWRnZXQgPT4ge1xuXG4gICAgICAgICAgICAvLyBmaW5kIHRoZSBtYXRjaGluZyB3aWRnZXRcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMud2lkZ2V0cy5maW5kKF93aWRnZXQgPT4gX3dpZGdldC5pZCA9PT0gd2lkZ2V0LmlkKTtcblxuICAgICAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRhcmdldC5zZXRDb2x1bW4od2lkZ2V0LmNvbCk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnNldFJvdyh3aWRnZXQucm93KTtcbiAgICAgICAgICAgICAgICB0YXJnZXQuc2V0Q29sdW1uU3Bhbih3aWRnZXQuY29sU3Bhbik7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnNldFJvd1NwYW4od2lkZ2V0LnJvd1NwYW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIHBvc2l0aW9ucyBhbmQgc2l6ZXMgb2YgdGhlIHdpZGdldHNcbiAgICAgKi9cbiAgICByZW5kZXJEYXNoYm9hcmQoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBkaW1lbnNpb25zIG9mIHRoZSBkYXNoYm9hcmRcbiAgICAgICAgdGhpcy5fcm93SGVpZ2h0ID0gdGhpcy5vcHRpb25zLnJvd0hlaWdodCB8fCB0aGlzLmNvbHVtbldpZHRoO1xuXG4gICAgICAgIC8vIGVuc3VyZSB0aGUgY29sdW1uIHdpZHRoIGlzIG5vdCBiZWxvdyB0aGUgbWluIHdpZHRoc1xuICAgICAgICB0aGlzLnN0YWNrZWQkLm5leHQodGhpcy5jb2x1bW5XaWR0aCA8IHRoaXMub3B0aW9ucy5taW5XaWR0aCk7XG5cbiAgICAgICAgLy8gZW5zdXJlIHRoZSByb3cgaGVpZ2h0IGlzIG5vdCBiZWxvdyB0aGUgbWluIHdpZHRoc1xuICAgICAgICBpZiAodGhpcy5fcm93SGVpZ2h0IDwgdGhpcy5vcHRpb25zLm1pbldpZHRoKSB7XG4gICAgICAgICAgICB0aGlzLl9yb3dIZWlnaHQgPSB0aGlzLm9wdGlvbnMubWluV2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldERhc2hib2FyZExheW91dCgpO1xuXG4gICAgICAgIC8vIGl0ZXJhdGUgdGhyb3VnaCBlYWNoIHdpZGdldCBhbmQgc2V0IHRoZSBzaXplIC0gZXhjZXB0IHRoZSBvbmUgYmVpbmcgcmVzaXplZFxuICAgICAgICB0aGlzLndpZGdldHMuZmlsdGVyKHdpZGdldCA9PiAhdGhpcy5fYWN0aW9uV2lkZ2V0IHx8IHdpZGdldCAhPT0gdGhpcy5fYWN0aW9uV2lkZ2V0LndpZGdldClcbiAgICAgICAgICAgIC5mb3JFYWNoKHdpZGdldCA9PiB3aWRnZXQucmVuZGVyKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZSB3aGVyZSB3aWRnZXRzIHNob3VsZCBiZSBwb3NpdGlvbmVkIGJhc2VkIG9uIHRoZWlyIHBvc2l0aW9ucywgd2lkdGggYW5kIHRoZSBzaXplIG9mIHRoZSBjb250YWluZXJcbiAgICAgKi9cbiAgICBzZXREYXNoYm9hcmRMYXlvdXQoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gZmluZCBhbnkgd2lkZ2V0cyB0aGF0IGRvIG5vdCBjdXJyZW50bHkgaGF2ZSBhIHBvc2l0aW9uIHNldFxuICAgICAgICB0aGlzLndpZGdldHMuZmlsdGVyKHdpZGdldCA9PiB3aWRnZXQuZ2V0Q29sdW1uKCkgPT09IHVuZGVmaW5lZCB8fCB3aWRnZXQuZ2V0Um93KCkgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIC5mb3JFYWNoKHdpZGdldCA9PiB0aGlzLnNldFdpZGdldFBvc2l0aW9uKHdpZGdldCkpO1xuXG4gICAgICAgIHRoaXMuc2V0RGFzaGJvYXJkSGVpZ2h0KCk7XG4gICAgfVxuXG4gICAgdXBkYXRlV2hlblN0YWNrZWQoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gaXRlcmF0ZSB0aHJvdWdoIGVhY2ggd2lkZ2V0IHNldCBpdCdzIHN0YWNrZWQgc3RhdGUgYW5kXG4gICAgICAgIHRoaXMuZ2V0V2lkZ2V0c0J5T3JkZXIoKS5mb3JFYWNoKCh3aWRnZXQsIGlkeCkgPT4ge1xuICAgICAgICAgICAgd2lkZ2V0LnNldENvbHVtbigwKTtcbiAgICAgICAgICAgIHdpZGdldC5zZXRSb3coaWR4KTtcbiAgICAgICAgfSk7XG5cbiAgICB9XG5cbiAgICBnZXRXaWRnZXRzQnlPcmRlcigpOiBEYXNoYm9hcmRXaWRnZXRDb21wb25lbnRbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpZGdldHMuc29ydCgodzEsIHcyKSA9PiB7XG5cbiAgICAgICAgICAgIGNvbnN0IHcxUG9zaXRpb24gPSB3MS5nZXRDb2x1bW4oKSAqIHcxLmdldFJvdygpO1xuICAgICAgICAgICAgY29uc3QgdzJQb3NpdGlvbiA9IHcyLmdldENvbHVtbigpICogdzIuZ2V0Um93KCk7XG5cbiAgICAgICAgICAgIGlmICh3MVBvc2l0aW9uIDwgdzJQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHcxUG9zaXRpb24gPiB3MlBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kIGEgcG9zaXRpb24gdGhhdCBhIHdpZGdldCBjYW4gZml0IGluIHRoZSBkYXNoYm9hcmRcbiAgICAgKiBAcGFyYW0gd2lkZ2V0IFRoZSB3aWRnZXQgdG8gdHJ5IGFuZCBwb3NpdGlvblxuICAgICAqL1xuICAgIHNldFdpZGdldFBvc2l0aW9uKHdpZGdldDogRGFzaGJvYXJkV2lkZ2V0Q29tcG9uZW50KTogdm9pZCB7XG5cbiAgICAgICAgLy8gZmluZCBhIHBvc2l0aW9uIGZvciB0aGUgd2lkZ2V0XG4gICAgICAgIGxldCBwb3NpdGlvbiA9IDA7XG4gICAgICAgIGxldCBzdWNjZXNzID0gZmFsc2U7XG5cbiAgICAgICAgLy8gcmVwZWF0IHVudGlsIGEgc3BhY2UgaXMgZm91bmRcbiAgICAgICAgd2hpbGUgKCFzdWNjZXNzKSB7XG5cbiAgICAgICAgICAgIC8vIGdldCBhIHBvc2l0aW9uIHRvIHRyeVxuICAgICAgICAgICAgY29uc3QgY29sdW1uID0gcG9zaXRpb24gJSB0aGlzLm9wdGlvbnMuY29sdW1ucztcbiAgICAgICAgICAgIGNvbnN0IHJvdyA9IE1hdGguZmxvb3IocG9zaXRpb24gLyB0aGlzLm9wdGlvbnMuY29sdW1ucyk7XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIHRoZSBjdXJyZW50IHBvc2l0aW9uXG4gICAgICAgICAgICBpZiAodGhpcy5nZXRQb3NpdGlvbkF2YWlsYWJsZShjb2x1bW4sIHJvdywgd2lkZ2V0LmdldENvbHVtblNwYW4oKSwgd2lkZ2V0LmdldFJvd1NwYW4oKSkpIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB3aWRnZXQuc2V0Q29sdW1uKGNvbHVtbik7XG4gICAgICAgICAgICAgICAgd2lkZ2V0LnNldFJvdyhyb3cpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvbHVtbiA9PT0gMCAmJiB3aWRnZXQuY29sU3BhbiA+IHRoaXMub3B0aW9ucy5jb2x1bW5zKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXNoYm9hcmQgd2lkZ2V0cyBoYXZlIGEgY29sU3BhbiBncmVhdGVyIHRoYW4gdGhlIG1heCBudW1iZXIgb2YgZGFzaGJvYXJkIGNvbHVtbnMhJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBvc2l0aW9uKys7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIHBvc2l0aW9uIGluIHRoZSBkYXNoYm9hcmQgaXMgdmFjYW50IG9yIG5vdFxuICAgICAqL1xuICAgIGdldFBvc2l0aW9uQXZhaWxhYmxlKGNvbHVtbjogbnVtYmVyLCByb3c6IG51bWJlciwgY29sdW1uU3BhbjogbnVtYmVyLCByb3dTcGFuOiBudW1iZXIsIGlnbm9yZVdpZGdldD86IERhc2hib2FyZFdpZGdldENvbXBvbmVudCk6IGJvb2xlYW4ge1xuXG4gICAgICAgIC8vIGdldCBhIGxpc3Qgb2YgZ3JpZCBzcGFjZXMgdGhhdCBhcmUgcG9wdWxhdGVkXG4gICAgICAgIGNvbnN0IHNwYWNlcyA9IHRoaXMuZ2V0T2NjdXBpZWRTcGFjZXMoKTtcblxuICAgICAgICAvLyBjaGVjayBpZiB0aGUgYmxvY2sgd291bGQgc3RpbGwgYmUgaW4gYm91bmRzXG4gICAgICAgIGlmIChjb2x1bW4gKyBjb2x1bW5TcGFuID4gdGhpcy5vcHRpb25zLmNvbHVtbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIGVhY2ggcmVxdWlyZWQgcG9zaXRpb25cbiAgICAgICAgZm9yIChsZXQgeCA9IGNvbHVtbjsgeCA8IGNvbHVtbiArIGNvbHVtblNwYW47IHgrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IHJvdzsgeSA8IHJvdyArIHJvd1NwYW47IHkrKykge1xuICAgICAgICAgICAgICAgIGlmIChzcGFjZXMuZmluZChibG9jayA9PiBibG9jay5jb2x1bW4gPT09IHggJiYgYmxvY2sucm93ID09PSB5ICYmIGJsb2NrLndpZGdldCAhPT0gaWdub3JlV2lkZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZ2V0T2NjdXBpZWRTcGFjZXMoKTogRGFzaGJvYXJkU3BhY2VbXSB7XG5cbiAgICAgICAgLy8gZmluZCBhbGwgc3BhY2VzIHRoYXQgYXJlIGN1cnJlbnRseSBvY2N1cGllZFxuICAgICAgICByZXR1cm4gdGhpcy53aWRnZXRzLmZpbHRlcih3aWRnZXQgPT4gd2lkZ2V0LmdldENvbHVtbigpICE9PSB1bmRlZmluZWQgJiYgd2lkZ2V0LmdldFJvdygpICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAucmVkdWNlKCh2YWx1ZSwgd2lkZ2V0KSA9PiB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmZvckVhY2hCbG9jayh3aWRnZXQsIChjb2x1bW4sIHJvdykgPT4gdmFsdWUucHVzaCh7IHdpZGdldDogd2lkZ2V0LCBjb2x1bW46IGNvbHVtbiwgcm93OiByb3cgfSkpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfSwgW10pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJlZ2luIHJlc2l6aW5nIGEgd2lkZ2V0XG4gICAgICogQHBhcmFtIGFjdGlvbiBUaGUgdGhlIHdpZGdldCB0byByZXNpemVcbiAgICAgKi9cbiAgICBvblJlc2l6ZVN0YXJ0KGFjdGlvbjogRGFzaGJvYXJkQWN0aW9uKTogdm9pZCB7XG5cbiAgICAgICAgLy8gc3RvcmUgdGhlIG1vdXNlIGV2ZW50XG4gICAgICAgIHRoaXMuX21vdXNlRXZlbnQgPSBhY3Rpb24uZXZlbnQ7XG4gICAgICAgIHRoaXMuX2FjdGlvbldpZGdldCA9IGFjdGlvbjtcblxuICAgICAgICAvLyBicmluZyB0aGUgd2lkZ2V0IHRvIHRoZSBmb250XG4gICAgICAgIHRoaXMuYnJpbmdUb0Zyb250KGFjdGlvbi53aWRnZXQpO1xuICAgIH1cblxuICAgIG9uUmVzaXplRHJhZyhhY3Rpb246IERhc2hib2FyZEFjdGlvbik6IHZvaWQge1xuXG4gICAgICAgIGNvbnN0IG1vdXNlUG9zWCA9IHRoaXMuX21vdXNlRXZlbnQucGFnZVggLSBwYWdlWE9mZnNldDtcbiAgICAgICAgY29uc3QgbW91c2VQb3NZID0gdGhpcy5fbW91c2VFdmVudC5wYWdlWSAtIHBhZ2VZT2Zmc2V0O1xuXG4gICAgICAgIC8vIGlmIHRoZXJlIHdhcyBubyBtb3ZlbWVudCB0aGVuIGRvIG5vdGhpbmdcbiAgICAgICAgaWYgKGFjdGlvbi5ldmVudC54ID09PSBtb3VzZVBvc1ggJiYgYWN0aW9uLmV2ZW50LnkgPT09IG1vdXNlUG9zWSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBzdG9yZWQgbW91c2UgZXZlbnRcbiAgICAgICAgdGhpcy5fbW91c2VFdmVudCA9IGFjdGlvbi5ldmVudDtcblxuICAgICAgICAvLyBnZXQgaGFuZGxlIGZvciBkaXJlY3Rpb25cbiAgICAgICAgY29uc3QgeyBoYW5kbGUgfSA9IGFjdGlvbjtcblxuICAgICAgICAvLyBnZXQgdGhlIGJvdW5kcyBvZiB0aGUgaGFuZGxlXG4gICAgICAgIGNvbnN0IGJvdW5kcyA9IGhhbmRsZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICAvLyBnZXQgdGhlIGNlbnRlciBvZiB0aGUgaGFuZGxlXG4gICAgICAgIGNvbnN0IGNlbnRlclggPSBib3VuZHMubGVmdCArIChib3VuZHMud2lkdGggLyAyKTtcbiAgICAgICAgY29uc3QgY2VudGVyWSA9IGJvdW5kcy50b3AgKyAoYm91bmRzLmhlaWdodCAvIDIpO1xuXG4gICAgICAgIC8vIGdldCB0aGUgY3VycmVudCBtb3VzZSBwb3NpdGlvblxuICAgICAgICBjb25zdCBtb3VzZVggPSBtb3VzZVBvc1ggLSBjZW50ZXJYO1xuICAgICAgICBjb25zdCBtb3VzZVkgPSBtb3VzZVBvc1kgLSBjZW50ZXJZO1xuXG4gICAgICAgIC8vIHN0b3JlIHRoZSBuZXcgcHJvcG9zZWQgZGltZW5zaW9ucyBmb3IgdGhlIHdpZGdldFxuICAgICAgICBjb25zdCBkaW1lbnNpb25zOiBEYXNoYm9hcmRXaWRnZXREaW1lbnNpb25zID0ge1xuICAgICAgICAgICAgeDogYWN0aW9uLndpZGdldC54LFxuICAgICAgICAgICAgeTogYWN0aW9uLndpZGdldC55LFxuICAgICAgICAgICAgd2lkdGg6IGFjdGlvbi53aWRnZXQud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGFjdGlvbi53aWRnZXQuaGVpZ2h0XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gdXBkYXRlIHdpZGdldCBiYXNlZCBvbiB0aGUgaGFuZGxlIGJlaW5nIGRyYWdnZWRcbiAgICAgICAgc3dpdGNoIChhY3Rpb24uZGlyZWN0aW9uKSB7XG5cbiAgICAgICAgICAgIGNhc2UgQWN0aW9uRGlyZWN0aW9uLlJpZ2h0OlxuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMud2lkdGggKz0gbW91c2VYO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIEFjdGlvbkRpcmVjdGlvbi5MZWZ0OlxuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMueCArPSBtb3VzZVg7XG4gICAgICAgICAgICAgICAgZGltZW5zaW9ucy53aWR0aCAtPSBtb3VzZVg7XG5cbiAgICAgICAgICAgICAgICBpZiAoZGltZW5zaW9ucy53aWR0aCA8IHRoaXMub3B0aW9ucy5taW5XaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaWZmZXJlbmNlID0gdGhpcy5vcHRpb25zLm1pbldpZHRoIC0gZGltZW5zaW9ucy53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9ucy54IC09IGRpZmZlcmVuY2U7XG4gICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMud2lkdGggKz0gZGlmZmVyZW5jZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBBY3Rpb25EaXJlY3Rpb24uQm90dG9tOlxuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMuaGVpZ2h0ICs9IG1vdXNlWTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBBY3Rpb25EaXJlY3Rpb24uVG9wOlxuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMueSArPSBtb3VzZVk7XG4gICAgICAgICAgICAgICAgZGltZW5zaW9ucy5oZWlnaHQgLT0gbW91c2VZO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRpbWVuc2lvbnMuaGVpZ2h0IDwgdGhpcy5vcHRpb25zLm1pbkhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaWZmZXJlbmNlID0gdGhpcy5vcHRpb25zLm1pbkhlaWdodCAtIGRpbWVuc2lvbnMuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb25zLnkgLT0gZGlmZmVyZW5jZTtcbiAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9ucy5oZWlnaHQgKz0gZGlmZmVyZW5jZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIC8vIFN1cHBvcnQgcmVzaXppbmcgb24gbXVsdGlwbGUgYXhpcyBzaW11bHRhbmVvdXNseVxuICAgICAgICAgICAgY2FzZSBBY3Rpb25EaXJlY3Rpb24uVG9wTGVmdDpcblxuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMueCArPSBtb3VzZVg7XG4gICAgICAgICAgICAgICAgZGltZW5zaW9ucy53aWR0aCAtPSBtb3VzZVg7XG5cbiAgICAgICAgICAgICAgICBpZiAoZGltZW5zaW9ucy53aWR0aCA8IHRoaXMub3B0aW9ucy5taW5XaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaWZmZXJlbmNlID0gdGhpcy5vcHRpb25zLm1pbldpZHRoIC0gZGltZW5zaW9ucy53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9ucy54IC09IGRpZmZlcmVuY2U7XG4gICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMud2lkdGggKz0gZGlmZmVyZW5jZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zLnkgKz0gbW91c2VZO1xuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMuaGVpZ2h0IC09IG1vdXNlWTtcblxuICAgICAgICAgICAgICAgIGlmIChkaW1lbnNpb25zLmhlaWdodCA8IHRoaXMub3B0aW9ucy5taW5IZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlmZmVyZW5jZSA9IHRoaXMub3B0aW9ucy5taW5IZWlnaHQgLSBkaW1lbnNpb25zLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9ucy55IC09IGRpZmZlcmVuY2U7XG4gICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMuaGVpZ2h0ICs9IGRpZmZlcmVuY2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIEFjdGlvbkRpcmVjdGlvbi5Ub3BSaWdodDpcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zLndpZHRoICs9IG1vdXNlWDtcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zLnkgKz0gbW91c2VZO1xuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMuaGVpZ2h0IC09IG1vdXNlWTtcblxuICAgICAgICAgICAgICAgIGlmIChkaW1lbnNpb25zLmhlaWdodCA8IHRoaXMub3B0aW9ucy5taW5IZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlmZmVyZW5jZSA9IHRoaXMub3B0aW9ucy5taW5IZWlnaHQgLSBkaW1lbnNpb25zLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9ucy55IC09IGRpZmZlcmVuY2U7XG4gICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMuaGVpZ2h0ICs9IGRpZmZlcmVuY2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIEFjdGlvbkRpcmVjdGlvbi5Cb3R0b21MZWZ0OlxuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMuaGVpZ2h0ICs9IG1vdXNlWTtcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zLnggKz0gbW91c2VYO1xuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMud2lkdGggLT0gbW91c2VYO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRpbWVuc2lvbnMud2lkdGggPCB0aGlzLm9wdGlvbnMubWluV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlmZmVyZW5jZSA9IHRoaXMub3B0aW9ucy5taW5XaWR0aCAtIGRpbWVuc2lvbnMud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMueCAtPSBkaWZmZXJlbmNlO1xuICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb25zLndpZHRoICs9IGRpZmZlcmVuY2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIEFjdGlvbkRpcmVjdGlvbi5Cb3R0b21SaWdodDpcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zLmhlaWdodCArPSBtb3VzZVk7XG4gICAgICAgICAgICAgICAgZGltZW5zaW9ucy53aWR0aCArPSBtb3VzZVg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjdXJyZW50V2lkdGggPSBhY3Rpb24ud2lkZ2V0LnggKyBhY3Rpb24ud2lkZ2V0LndpZHRoO1xuICAgICAgICBjb25zdCBjdXJyZW50SGVpZ2h0ID0gYWN0aW9uLndpZGdldC55ICsgYWN0aW9uLndpZGdldC5oZWlnaHQ7XG5cbiAgICAgICAgLy8gZW5zdXJlIHZhbHVlcyBhcmUgd2l0aGluIHRoZSBkYXNoYm9hcmQgYm91bmRzXG4gICAgICAgIGlmIChkaW1lbnNpb25zLnggPCAwKSB7XG4gICAgICAgICAgICBkaW1lbnNpb25zLnggPSAwO1xuICAgICAgICAgICAgZGltZW5zaW9ucy53aWR0aCA9IGN1cnJlbnRXaWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkaW1lbnNpb25zLnkgPCAwKSB7XG4gICAgICAgICAgICBkaW1lbnNpb25zLnkgPSAwO1xuICAgICAgICAgICAgZGltZW5zaW9ucy5oZWlnaHQgPSBjdXJyZW50SGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChkaW1lbnNpb25zLnggKyBkaW1lbnNpb25zLndpZHRoKSA+IHRoaXMuZGltZW5zaW9ucy53aWR0aCkge1xuICAgICAgICAgICAgZGltZW5zaW9ucy53aWR0aCA9IHRoaXMuZGltZW5zaW9ucy53aWR0aCAtIGRpbWVuc2lvbnMueDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoZSBwcm9wb3NlZCB3aWR0aCBpcyBzbWFsbGVyIHRoYW4gYWxsb3dlZCB0aGVuIHJlc2V0IHdpZHRoIHRvIG1pbmltdW0gYW5kIGlnbm9yZSB4IGNoYW5nZXNcbiAgICAgICAgaWYgKGRpbWVuc2lvbnMud2lkdGggPCB0aGlzLm9wdGlvbnMubWluV2lkdGgpIHtcbiAgICAgICAgICAgIGRpbWVuc2lvbnMueCA9IGFjdGlvbi53aWRnZXQueDtcbiAgICAgICAgICAgIGRpbWVuc2lvbnMud2lkdGggPSB0aGlzLm9wdGlvbnMubWluV2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aGUgcHJvcG9zZWQgaGVpZ2h0IGlzIHNtYWxsZXIgdGhhbiBhbGxvd2VkIHRoZW4gcmVzZXQgaGVpZ2h0IHRvIG1pbmltdW0gYW5kIGlnbm9yZSB5IGNoYW5nZXNcbiAgICAgICAgaWYgKGRpbWVuc2lvbnMuaGVpZ2h0IDwgdGhpcy5vcHRpb25zLm1pbkhlaWdodCkge1xuICAgICAgICAgICAgZGltZW5zaW9ucy55ID0gYWN0aW9uLndpZGdldC55O1xuICAgICAgICAgICAgZGltZW5zaW9ucy5oZWlnaHQgPSB0aGlzLm9wdGlvbnMubWluSGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSB3aWRnZXQgYWN0dWFsIHZhbHVlc1xuICAgICAgICBhY3Rpb24ud2lkZ2V0LnNldEJvdW5kcyhkaW1lbnNpb25zLngsIGRpbWVuc2lvbnMueSwgZGltZW5zaW9ucy53aWR0aCwgZGltZW5zaW9ucy5oZWlnaHQpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSBwbGFjZWhvbGRlciBwb3NpdGlvbiBhbmQgdmFsdWVcbiAgICAgICAgdGhpcy5zZXRQbGFjZWhvbGRlckJvdW5kcyh0cnVlLCBkaW1lbnNpb25zLngsIGRpbWVuc2lvbnMueSwgZGltZW5zaW9ucy53aWR0aCwgZGltZW5zaW9ucy5oZWlnaHQpO1xuXG4gICAgICAgIC8vIHNob3cgdGhlIHdpZGdldCBwb3NpdGlvbnMgaWYgdGhlIGN1cnJlbnQgcG9zaXRpb25zIGFuZCBzaXplcyB3ZXJlIHRvIHBlcnNpc3RcbiAgICAgICAgdGhpcy51cGRhdGVXaWRnZXRQb3NpdGlvbnMoYWN0aW9uLndpZGdldCk7XG4gICAgfVxuXG4gICAgb25SZXNpemVFbmQoKTogdm9pZCB7XG5cbiAgICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSB0aGlzLnBsYWNlaG9sZGVyJC5nZXRWYWx1ZSgpO1xuXG4gICAgICAgIC8vIGNvbW1pdCByZXNpemUgY2hhbmdlc1xuICAgICAgICB0aGlzLmNvbW1pdFdpZGdldENoYW5nZXMoKTtcblxuICAgICAgICAvLyBoaWRlIHBsYWNlaG9sZGVyXG4gICAgICAgIHBsYWNlaG9sZGVyLnZpc2libGUgPSBmYWxzZTtcblxuICAgICAgICAvLyB1cGRhdGUgdGhlIHBsYWNlaG9sZGVyXG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXIkLm5leHQocGxhY2Vob2xkZXIpO1xuXG4gICAgICAgIHRoaXMuX2FjdGlvbldpZGdldCA9IG51bGw7XG4gICAgICAgIHRoaXMuX21vdXNlRXZlbnQgPSBudWxsO1xuXG4gICAgICAgIC8vIGVuc3VyZSBhbnkgdmFjYW50IHVwcGVyIHNwYWNlcyBhcmUgZmlsbGVkIHdoZXJlIHJlcXVpcmVkXG4gICAgICAgIHRoaXMuc2hpZnRXaWRnZXRzVXAoKTtcblxuICAgICAgICAvLyB1cGRhdGUgZGFzaGJvYXJkIGhlaWdodFxuICAgICAgICB0aGlzLnNldERhc2hib2FyZEhlaWdodCgpO1xuXG4gICAgICAgIC8vIGVtaXQgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGxheW91dFxuICAgICAgICB0aGlzLmxheW91dCQubmV4dCh0aGlzLmdldExheW91dERhdGEoKSk7XG4gICAgfVxuXG4gICAgb25EcmFnU3RhcnQoYWN0aW9uOiBEYXNoYm9hcmRBY3Rpb24pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5vblJlc2l6ZVN0YXJ0KGFjdGlvbik7XG5cbiAgICAgICAgLy8gc3RvcmUgdGhlIHN0YXJ0aW5nIHBsYWNlaG9sZGVyIHBvc2l0aW9uXG4gICAgICAgIHRoaXMuc2V0V2lkZ2V0T3JpZ2luKCk7XG5cbiAgICAgICAgdGhpcy5jYWNoZVdpZGdldHMoKTtcbiAgICB9XG5cbiAgICBvbkRyYWdFbmQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMub25SZXNpemVFbmQoKTtcblxuICAgICAgICB0aGlzLl93aWRnZXRPcmlnaW4gPSB7fTtcbiAgICB9XG5cbiAgICBvbkRyYWcoYWN0aW9uOiBEYXNoYm9hcmRBY3Rpb24pOiB2b2lkIHtcblxuICAgICAgICAvLyBpZiB0aGVyZSB3YXMgbm8gbW92ZW1lbnQgdGhlbiBkbyBub3RoaW5nXG4gICAgICAgIGlmIChhY3Rpb24uZXZlbnQucGFnZVggPT09IHRoaXMuX21vdXNlRXZlbnQucGFnZVggJiYgYWN0aW9uLmV2ZW50LnBhZ2VZID09PSB0aGlzLl9tb3VzZUV2ZW50LnBhZ2VZKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgdGhlIGN1cnJlbnQgbW91c2UgcG9zaXRpb25cbiAgICAgICAgY29uc3QgbW91c2VYID0gYWN0aW9uLmV2ZW50LnBhZ2VYIC0gdGhpcy5fbW91c2VFdmVudC5wYWdlWDtcbiAgICAgICAgY29uc3QgbW91c2VZID0gYWN0aW9uLmV2ZW50LnBhZ2VZIC0gdGhpcy5fbW91c2VFdmVudC5wYWdlWTtcblxuICAgICAgICAvLyBzdG9yZSB0aGUgbGF0ZXN0IGV2ZW50XG4gICAgICAgIHRoaXMuX21vdXNlRXZlbnQgPSBhY3Rpb24uZXZlbnQ7XG5cbiAgICAgICAgY29uc3QgZGltZW5zaW9uczogRGFzaGJvYXJkV2lkZ2V0RGltZW5zaW9ucyA9IHtcbiAgICAgICAgICAgIHg6IGFjdGlvbi53aWRnZXQueCArIG1vdXNlWCxcbiAgICAgICAgICAgIHk6IGFjdGlvbi53aWRnZXQueSArIG1vdXNlWSxcbiAgICAgICAgICAgIHdpZHRoOiBhY3Rpb24ud2lkZ2V0LndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBhY3Rpb24ud2lkZ2V0LmhlaWdodFxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMucmVzdG9yZVdpZGdldHModHJ1ZSk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHdpZGdldCBwb3NpdGlvblxuICAgICAgICBhY3Rpb24ud2lkZ2V0LnNldEJvdW5kcyhkaW1lbnNpb25zLngsIGRpbWVuc2lvbnMueSwgZGltZW5zaW9ucy53aWR0aCwgZGltZW5zaW9ucy5oZWlnaHQpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSBwbGFjZWhvbGRlciBwb3NpdGlvbiBhbmQgdmFsdWVcbiAgICAgICAgdGhpcy5zZXRQbGFjZWhvbGRlckJvdW5kcyh0cnVlLCBkaW1lbnNpb25zLngsIGRpbWVuc2lvbnMueSwgZGltZW5zaW9ucy53aWR0aCwgZGltZW5zaW9ucy5oZWlnaHQpO1xuXG4gICAgICAgIC8vIHNob3cgdGhlIHdpZGdldCBwb3NpdGlvbnMgaWYgdGhlIGN1cnJlbnQgcG9zaXRpb25zIGFuZCBzaXplcyB3ZXJlIHRvIHBlcnNpc3RcbiAgICAgICAgdGhpcy5zaGlmdFdpZGdldHMoKTtcblxuICAgICAgICB0aGlzLnNldERhc2hib2FyZEhlaWdodCgpO1xuICAgIH1cblxuICAgIGdldFJvd0hlaWdodCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fcm93SGVpZ2h0O1xuICAgIH1cblxuICAgIGNhY2hlV2lkZ2V0cygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fY2FjaGUgPSB0aGlzLndpZGdldHMubWFwKHdpZGdldCA9PiAoeyBpZDogd2lkZ2V0LmlkLCBjb2x1bW46IHdpZGdldC5nZXRDb2x1bW4oKSwgcm93OiB3aWRnZXQuZ2V0Um93KCkgfSkpO1xuICAgIH1cblxuICAgIHJlc3RvcmVXaWRnZXRzKGlnbm9yZUFjdGlvbldpZGdldDogYm9vbGVhbiA9IGZhbHNlKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2NhY2hlLmZpbHRlcih3aWRnZXQgPT4gIWlnbm9yZUFjdGlvbldpZGdldCB8fCB3aWRnZXQuaWQgIT09IHRoaXMuX2FjdGlvbldpZGdldC53aWRnZXQuaWQpLmZvckVhY2god2lkZ2V0ID0+IHtcblxuICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSB0aGlzLndpZGdldHMuZmluZCh3Z3QgPT4gd2d0LmlkID09PSB3aWRnZXQuaWQpO1xuXG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBtYXRjaC5zZXRDb2x1bW4od2lkZ2V0LmNvbHVtbik7XG4gICAgICAgICAgICAgICAgbWF0Y2guc2V0Um93KHdpZGdldC5yb3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGRyYWdnaW5nIGFueSB3aWRnZXRzIHRoYXQgbmVlZCB0byBiZSBtb3ZlZCBzaG91bGQgYmUgbW92ZWQgdG8gYW4gYXBwcm9wcmlhdGUgcG9zaXRpb25cbiAgICAgKi9cbiAgICBzaGlmdFdpZGdldHMoKTogdm9pZCB7XG5cbiAgICAgICAgbGV0IHdpZGdldHNUb01vdmU6IERhc2hib2FyZFdpZGdldENvbXBvbmVudFtdID0gW107XG5cbiAgICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSB0aGlzLnBsYWNlaG9sZGVyJC5nZXRWYWx1ZSgpO1xuXG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBhbnkgd2lkZ2V0cyB1bmRlciB0aGUgcGxhY2Vob2xkZXJcbiAgICAgICAgZm9yIChsZXQgcm93ID0gcGxhY2Vob2xkZXIucm93OyByb3cgPCBwbGFjZWhvbGRlci5yb3cgKyBwbGFjZWhvbGRlci5yb3dTcGFuOyByb3crKykge1xuICAgICAgICAgICAgZm9yIChsZXQgY29sdW1uID0gcGxhY2Vob2xkZXIuY29sdW1uOyBjb2x1bW4gPCBwbGFjZWhvbGRlci5jb2x1bW4gKyBwbGFjZWhvbGRlci5jb2x1bW5TcGFuOyBjb2x1bW4rKykge1xuXG4gICAgICAgICAgICAgICAgLy8gc3RvcmUgcmVmZXJlbmNlIHRvIGFueSB3aWRnZXRzIHRoYXQgbmVlZCBtb3ZlZFxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0T2NjdXBpZWRTcGFjZXMoKVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKHNwYWNlID0+IHNwYWNlLmNvbHVtbiA9PT0gY29sdW1uICYmIHNwYWNlLnJvdyA9PT0gcm93ICYmIHNwYWNlLndpZGdldCAhPT0gdGhpcy5fYWN0aW9uV2lkZ2V0LndpZGdldClcbiAgICAgICAgICAgICAgICAgICAgLmZvckVhY2goc3BhY2UgPT4gd2lkZ2V0c1RvTW92ZS5wdXNoKHNwYWNlLndpZGdldCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVtb3ZlIGFueSBkdXBsaWNhdGVzXG4gICAgICAgIHdpZGdldHNUb01vdmUgPSB3aWRnZXRzVG9Nb3ZlLmZpbHRlcigod2lkZ2V0LCBpZHgsIGFycmF5KSA9PiBhcnJheS5pbmRleE9mKHdpZGdldCkgPT09IGlkeCk7XG5cbiAgICAgICAgLy8gaWYgbm8gd2lkZ2V0cyBuZWVkIG1vdmVkIHRoZW4gd2UgY2FuIHN0b3AgaGVyZVxuICAgICAgICBpZiAod2lkZ2V0c1RvTW92ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNyZWF0ZSBhIGR1cGxpY2F0ZSB3ZSBjYW4gdXNlIHRvIGtlZXAgdHJhY2sgb2Ygd2hpY2ggaGF2ZSBiZWVuIG1vdmVkXG4gICAgICAgIGNvbnN0IHVubW92ZWRXaWRnZXRzID0gd2lkZ2V0c1RvTW92ZS5zbGljZSgpO1xuXG4gICAgICAgIC8vIGF0dGVtcHQgdG8gbW92ZSBhbnkgd2lkZ2V0cyB0byB0aGUgcHJldmlvdXMgd2lkZ2V0IHBvc2l0aW9uXG4gICAgICAgIHdpZGdldHNUb01vdmUuZm9yRWFjaCh3aWRnZXQgPT4ge1xuXG4gICAgICAgICAgICAvLyBnZXQgYSBncmlkIG9mZiBhbGwgb2NjdXBpZWQgc3BhY2VzIC0gdGFraW5nIGludG8gYWNjb3VudCB0aGUgcGxhY2Vob2xkZXIgYW5kIGlnbm9yaW5nIHdpZGdldHMgdGhhdCBuZWVkIG1vdmVkXG4gICAgICAgICAgICBjb25zdCBncmlkID0gdGhpcy5nZXRPY2N1cGllZFNwYWNlcygpLmZpbHRlcihzcGFjZSA9PiAhdW5tb3ZlZFdpZGdldHMuZmluZCh3Z3QgPT4gd2d0ID09PSBzcGFjZS53aWRnZXQpKTtcblxuICAgICAgICAgICAgLy8gaXRlcmF0ZSBlYWNoIGZyZWUgYmxvY2tcbiAgICAgICAgICAgIGZvciAobGV0IHJvdyA9IHRoaXMuX3dpZGdldE9yaWdpbi5yb3c7IHJvdyA8IHRoaXMuX3dpZGdldE9yaWdpbi5yb3cgKyB0aGlzLl93aWRnZXRPcmlnaW4ucm93U3Bhbjsgcm93KyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjb2x1bW4gPSB0aGlzLl93aWRnZXRPcmlnaW4uY29sdW1uOyBjb2x1bW4gPCB0aGlzLl93aWRnZXRPcmlnaW4uY29sdW1uICsgdGhpcy5fd2lkZ2V0T3JpZ2luLmNvbHVtblNwYW47IGNvbHVtbisrKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIGlmIHRoZSBibG9jayBjYW4gZml0IGluIHRoaXMgc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlcXVpcmVkU3BhY2VzID0gdGhpcy5nZXRSZXF1aXJlZFNwYWNlc0Zyb21Qb2ludCh3aWRnZXQsIGNvbHVtbiwgcm93KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiB3aWRnZXQgd291bGQgZml0IGluIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgIGxldCBhdmFpbGFibGUgPSByZXF1aXJlZFNwYWNlcy5ldmVyeShzcGFjZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWdyaWQuZmluZChncmlkU3BhY2UgPT4gZ3JpZFNwYWNlLmNvbHVtbiA9PT0gc3BhY2UuY29sdW1uICYmIGdyaWRTcGFjZS5yb3cgPT09IHNwYWNlLnJvdykgJiYgc3BhY2UuY29sdW1uIDwgdGhpcy5nZXRDb2x1bW5Db3VudCgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoYXZhaWxhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWRnZXQuc2V0Q29sdW1uKGNvbHVtbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWRnZXQuc2V0Um93KHJvdyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bm1vdmVkV2lkZ2V0cy5zcGxpY2UodW5tb3ZlZFdpZGdldHMuZmluZEluZGV4KHdndCA9PiB3Z3QgPT09IHdpZGdldCksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB3ZSBnZXQgdG8gaGVyZSB0aGVuIHdlIGNhbid0IHNpbXBseSBzd2FwIHRoZSBwb3NpdGlvbnMgLSBuZXh0IHRyeSBtb3ZpbmcgcmlnaHRcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbldpZGdldE1vdmVSaWdodCh3aWRnZXQsIHRydWUpKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBhZnRlciB0aGUgc2hpZnQgY2hlY2sgaWYgcGxhY2Vob2xkZXIgcG9zaXRpb24gaXMgc3RpbGwgdmFsaWRcbiAgICAgICAgICAgICAgICB0aGlzLnZhbGlkYXRlUGxhY2Vob2xkZXJQb3NpdGlvbihBY3Rpb25EaXJlY3Rpb24uUmlnaHQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbmV4dCB0cnkgbW92aW5nIGxlZnRcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbldpZGdldE1vdmVMZWZ0KHdpZGdldCwgdHJ1ZSkpIHtcblxuICAgICAgICAgICAgICAgIC8vIGFmdGVyIHRoZSBzaGlmdCBjaGVjayBpZiBwbGFjZWhvbGRlciBwb3NpdGlvbiBpcyBzdGlsbCB2YWxpZFxuICAgICAgICAgICAgICAgIHRoaXMudmFsaWRhdGVQbGFjZWhvbGRlclBvc2l0aW9uKEFjdGlvbkRpcmVjdGlvbi5MZWZ0KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGRldGVybWluZSB0aGUgZGlzdGFuY2UgdGhhdCB0aGUgd2lkZ2V0IG5lZWRzIHRvIGJlIG1vdmVkIGRvd25cbiAgICAgICAgICAgIGxldCBkaXN0YW5jZSA9ICh0aGlzLl9hY3Rpb25XaWRnZXQud2lkZ2V0LmdldFJvdygpIC0gd2lkZ2V0LmdldFJvdygpKSArIHRoaXMuX2FjdGlvbldpZGdldC53aWRnZXQuZ2V0Um93U3BhbigpO1xuXG4gICAgICAgICAgICAvLyBhcyBhIGxhc3QgcmVzb3J0IG1vdmUgdGhlIHdpZGdldCBkb3dud2FyZHNcbiAgICAgICAgICAgIHRoaXMubW92ZVdpZGdldERvd24od2lkZ2V0LCBkaXN0YW5jZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFmdGVyIHNoaWZ0cyBoYXZlIHRha2VuIHBsYWNlIHdlIHNob3VsZCB2ZXJpZnkgdGhlIHBsYWNlIGhvbGRlciBwb3NpdGlvbiBpcyBzdGlsbCB2YWxpZFxuICAgICAqIEBwYXJhbSBzaGlmdERpcmVjdGlvbiAtIHRoZSBwb3NpdGlvbiB3aWRnZXRzIHdlcmUgc2hpZnRlZFxuICAgICAqL1xuICAgIHZhbGlkYXRlUGxhY2Vob2xkZXJQb3NpdGlvbihzaGlmdERpcmVjdGlvbjogQWN0aW9uRGlyZWN0aW9uKSB7XG5cbiAgICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSB0aGlzLnBsYWNlaG9sZGVyJC5nZXRWYWx1ZSgpO1xuXG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZSBwbGFjZWhvbGRlciBpcyBvdmVyIGEgd2lkZ2V0XG4gICAgICAgIGlmICh0aGlzLmdldFdpZGdldHNBdFBvc2l0aW9uKHBsYWNlaG9sZGVyLmNvbHVtbiwgcGxhY2Vob2xkZXIucm93LCB0cnVlKS5sZW5ndGggPiAwKSB7XG5cbiAgICAgICAgICAgIC8vIG1vdmUgdGhlIHBsYWNlaG9sZGVyIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb25cbiAgICAgICAgICAgIHN3aXRjaCAoc2hpZnREaXJlY3Rpb24pIHtcblxuICAgICAgICAgICAgICAgIGNhc2UgQWN0aW9uRGlyZWN0aW9uLkxlZnQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0UGxhY2Vob2xkZXJCb3VuZHMocGxhY2Vob2xkZXIudmlzaWJsZSwgcGxhY2Vob2xkZXIueCArIHRoaXMuZ2V0Q29sdW1uV2lkdGgoKSwgcGxhY2Vob2xkZXIueSwgcGxhY2Vob2xkZXIud2lkdGgsIHBsYWNlaG9sZGVyLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBBY3Rpb25EaXJlY3Rpb24uUmlnaHQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0UGxhY2Vob2xkZXJCb3VuZHMocGxhY2Vob2xkZXIudmlzaWJsZSwgcGxhY2Vob2xkZXIueCAtIHRoaXMuZ2V0Q29sdW1uV2lkdGgoKSwgcGxhY2Vob2xkZXIueSwgcGxhY2Vob2xkZXIud2lkdGgsIHBsYWNlaG9sZGVyLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB2YWxpZGF0ZSB0aGlzIG5ldyBwb3NpdGlvbiBhZ2FpblxuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZVBsYWNlaG9sZGVyUG9zaXRpb24oc2hpZnREaXJlY3Rpb24pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIGlmIGEgd2lkZ2V0IGNhbiBiZSBtb3ZlZCBsZWZ0IC0gb3IgaWYgaXQgY2FuIG1vdmUgdGhlIHdpZGdldHMgdG8gdGhlIHJpZ2h0IHRvIG1ha2Ugc3BhY2UgZm9yIHRoZSB3aWRnZXRcbiAgICAgKi9cbiAgICBjYW5XaWRnZXRNb3ZlTGVmdCh3aWRnZXQ6IERhc2hib2FyZFdpZGdldENvbXBvbmVudCwgcGVyZm9ybU1vdmU6IGJvb2xlYW4gPSBmYWxzZSk6IGJvb2xlYW4ge1xuXG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZSB3aWRnZXQgaXMgdGhlIGFjdGlvbiB3aWRnZXQgb3Igb2NjdXBpZXMgdGhlIGZpcnN0IGNvbHVtblxuICAgICAgICBpZiAod2lkZ2V0ID09PSB0aGlzLl9hY3Rpb25XaWRnZXQud2lkZ2V0IHx8IHdpZGdldC5nZXRDb2x1bW4oKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmluZCB0aGUgcG9zaXRpb25zIHJlcXVpcmVkXG4gICAgICAgIGNvbnN0IHRhcmdldFNwYWNlcyA9IHRoaXMuZ2V0T2NjdXBpZWRTcGFjZXMoKS5maWx0ZXIoc3BhY2UgPT4gc3BhY2Uud2lkZ2V0ID09PSB3aWRnZXQpLm1hcChzcGFjZSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geyBjb2x1bW46IHNwYWNlLmNvbHVtbiAtIHdpZGdldC5nZXRDb2x1bW5TcGFuKCksIHJvdzogc3BhY2Uucm93LCB3aWRnZXQ6IHNwYWNlLndpZGdldCB9O1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBjaGVjayBpZiB0aGVyZSBhcmUgd2lkZ2V0IGluIHRoZSByZXF1aXJlZCBwb3NpdGlvbnMgYW5kIGlmIHNvLCBjYW4gdGhleSBtb3ZlIHJpZ2h0P1xuICAgICAgICBjb25zdCBtb3ZlYWJsZSA9IHRhcmdldFNwYWNlcy5ldmVyeShzcGFjZSA9PiB0aGlzLmdldFdpZGdldHNBdFBvc2l0aW9uKHNwYWNlLmNvbHVtbiwgc3BhY2Uucm93KS5maWx0ZXIod2d0ID0+IHdndCAhPT0gc3BhY2Uud2lkZ2V0KS5ldmVyeSh3Z3QgPT4gdGhpcy5jYW5XaWRnZXRNb3ZlTGVmdCh3Z3QpKSk7XG5cbiAgICAgICAgaWYgKHBlcmZvcm1Nb3ZlICYmIG1vdmVhYmxlKSB7XG5cbiAgICAgICAgICAgIC8vIG1vdmUgYWxsIHdpZGdldHMgdG8gdGhlIHJpZ2h0XG4gICAgICAgICAgICB0YXJnZXRTcGFjZXMuZm9yRWFjaChzcGFjZSA9PiB0aGlzLmdldFdpZGdldHNBdFBvc2l0aW9uKHNwYWNlLmNvbHVtbiwgc3BhY2Uucm93KS5maWx0ZXIod2d0ID0+IHdndCAhPT0gc3BhY2Uud2lkZ2V0KS5mb3JFYWNoKHdndCA9PiB0aGlzLmNhbldpZGdldE1vdmVMZWZ0KHdndCwgdHJ1ZSkpKTtcblxuICAgICAgICAgICAgLy8gbW92ZSBjdXJyZW50IHdpZGdldCB0byB0aGUgcmlnaHRcbiAgICAgICAgICAgIHdpZGdldC5zZXRDb2x1bW4od2lkZ2V0LmdldENvbHVtbigpIC0gMSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbW92ZWFibGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIGlmIGEgd2lkZ2V0IGNhbiBiZSBtb3ZlZCByaWdodCAtIG9yIGlmIGl0IGNhbiBtb3ZlIHRoZSB3aWRnZXRzIHRvIHRoZSByaWdodCB0byBtYWtlIHNwYWNlIGZvciB0aGUgd2lkZ2V0XG4gICAgICovXG4gICAgY2FuV2lkZ2V0TW92ZVJpZ2h0KHdpZGdldDogRGFzaGJvYXJkV2lkZ2V0Q29tcG9uZW50LCBwZXJmb3JtTW92ZTogYm9vbGVhbiA9IGZhbHNlKTogYm9vbGVhbiB7XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlIHdpZGdldCBpcyB0aGUgZHJhZ2dpbmcgd2lkZ2V0IG9yIHRoZSB3aWRnZXQgb2NjdXBpZXMgdGhlIGZpbmFsIGNvbHVtblxuICAgICAgICBpZiAod2lkZ2V0ID09PSB0aGlzLl9hY3Rpb25XaWRnZXQud2lkZ2V0IHx8IHdpZGdldC5nZXRDb2x1bW4oKSArIHdpZGdldC5nZXRDb2x1bW5TcGFuKCkgPT09IHRoaXMub3B0aW9ucy5jb2x1bW5zKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaW5kIHRoZSBwb3NpdGlvbnMgcmVxdWlyZWRcbiAgICAgICAgY29uc3QgdGFyZ2V0U3BhY2VzID0gdGhpcy5nZXRPY2N1cGllZFNwYWNlcygpLmZpbHRlcihzcGFjZSA9PiBzcGFjZS53aWRnZXQgPT09IHdpZGdldCkubWFwKHNwYWNlID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7IGNvbHVtbjogc3BhY2UuY29sdW1uICsgd2lkZ2V0LmdldENvbHVtblNwYW4oKSwgcm93OiBzcGFjZS5yb3csIHdpZGdldDogc3BhY2Uud2lkZ2V0IH07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSB3aWRnZXQgaW4gdGhlIHJlcXVpcmVkIHBvc2l0aW9ucyBhbmQgaWYgc28sIGNhbiB0aGV5IG1vdmUgcmlnaHQ/XG4gICAgICAgIGNvbnN0IG1vdmVhYmxlID0gdGFyZ2V0U3BhY2VzLmV2ZXJ5KHNwYWNlID0+IHRoaXMuZ2V0V2lkZ2V0c0F0UG9zaXRpb24oc3BhY2UuY29sdW1uLCBzcGFjZS5yb3cpLmZpbHRlcih3Z3QgPT4gd2d0ICE9PSBzcGFjZS53aWRnZXQpLmV2ZXJ5KHdndCA9PiB0aGlzLmNhbldpZGdldE1vdmVSaWdodCh3Z3QpKSk7XG5cbiAgICAgICAgaWYgKHBlcmZvcm1Nb3ZlICYmIG1vdmVhYmxlKSB7XG5cbiAgICAgICAgICAgIC8vIG1vdmUgYWxsIHdpZGdldHMgdG8gdGhlIHJpZ2h0XG4gICAgICAgICAgICB0YXJnZXRTcGFjZXMuZm9yRWFjaChzcGFjZSA9PiB0aGlzLmdldFdpZGdldHNBdFBvc2l0aW9uKHNwYWNlLmNvbHVtbiwgc3BhY2Uucm93KS5maWx0ZXIod2d0ID0+IHdndCAhPT0gc3BhY2Uud2lkZ2V0KS5mb3JFYWNoKHdndCA9PiB0aGlzLmNhbldpZGdldE1vdmVSaWdodCh3Z3QsIHRydWUpKSk7XG5cbiAgICAgICAgICAgIC8vIG1vdmUgY3VycmVudCB3aWRnZXQgdG8gdGhlIHJpZ2h0XG4gICAgICAgICAgICB3aWRnZXQuc2V0Q29sdW1uKHdpZGdldC5nZXRDb2x1bW4oKSArIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1vdmVhYmxlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0b3JlIHRoZSBpbml0aWFsIHBvc2l0aW9uIG9mIHRoZSB3aWRnZXQgYmVpbmcgZHJhZ2dlZFxuICAgICAqL1xuICAgIHNldFdpZGdldE9yaWdpbigpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fd2lkZ2V0T3JpZ2luID0ge1xuICAgICAgICAgICAgY29sdW1uOiB0aGlzLl9hY3Rpb25XaWRnZXQud2lkZ2V0LmdldENvbHVtbigpLFxuICAgICAgICAgICAgcm93OiB0aGlzLl9hY3Rpb25XaWRnZXQud2lkZ2V0LmdldFJvdygpLFxuICAgICAgICAgICAgY29sdW1uU3BhbjogdGhpcy5fYWN0aW9uV2lkZ2V0LndpZGdldC5nZXRDb2x1bW5TcGFuKCksXG4gICAgICAgICAgICByb3dTcGFuOiB0aGlzLl9hY3Rpb25XaWRnZXQud2lkZ2V0LmdldFJvd1NwYW4oKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBhbGwgdGhlIHJlcXVpcmVkIHBvc2l0aW9ucyBpcyBhIHdpZGdldCB3YXMgdG8gYmUgcG9zaXRpb25lZCBhdCBhIHBhcnRpY3VsYXIgcG9pbnRcbiAgICAgKi9cbiAgICBnZXRSZXF1aXJlZFNwYWNlc0Zyb21Qb2ludCh3aWRnZXQ6IERhc2hib2FyZFdpZGdldENvbXBvbmVudCwgY29sdW1uOiBudW1iZXIsIHJvdzogbnVtYmVyKTogRGFzaGJvYXJkU3BhY2VbXSB7XG4gICAgICAgIGNvbnN0IHNwYWNlczogRGFzaGJvYXJkU3BhY2VbXSA9IFtdO1xuXG4gICAgICAgIGZvciAobGV0IHkgPSByb3c7IHkgPCByb3cgKyB3aWRnZXQuZ2V0Um93U3BhbigpOyB5KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSBjb2x1bW47IHggPCBjb2x1bW4gKyB3aWRnZXQuZ2V0Q29sdW1uU3BhbigpOyB4KyspIHtcbiAgICAgICAgICAgICAgICBzcGFjZXMucHVzaCh7IGNvbHVtbjogeCwgcm93OiB5LCB3aWRnZXQ6IHdpZGdldCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzcGFjZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUG9zaXRpb24gd2lkZ2V0cyBiYXNlZCBvbiB0aGUgcG9zaXRpb24gb2YgdGhlIHBsYWNlaG9sZGVyIC0gdGhpcyBpcyB0ZW1wb3JhcnkgdW50aWwgY29uZmlybWVkXG4gICAgICovXG4gICAgdXBkYXRlV2lkZ2V0UG9zaXRpb25zKHdpZGdldDogRGFzaGJvYXJkV2lkZ2V0Q29tcG9uZW50KSB7XG5cbiAgICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSB0aGlzLnBsYWNlaG9sZGVyJC5nZXRWYWx1ZSgpO1xuXG4gICAgICAgIC8vIGNoZWNrIGFsbCBzcGFjZXMgdGhlIHBsYWNlaG9sZGVyIHdpbGwgb2NjdXB5IGFuZCBtb3ZlIGFueSB3aWRnZXQgY3VycmVudGx5IGluIHRoZW0gZG93blxuICAgICAgICBmb3IgKGxldCBjb2x1bW4gPSBwbGFjZWhvbGRlci5jb2x1bW47IGNvbHVtbiA8IHBsYWNlaG9sZGVyLmNvbHVtbiArIHBsYWNlaG9sZGVyLmNvbHVtblNwYW47IGNvbHVtbisrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCByb3cgPSBwbGFjZWhvbGRlci5yb3c7IHJvdyA8IHBsYWNlaG9sZGVyLnJvdyArIHBsYWNlaG9sZGVyLnJvd1NwYW47IHJvdysrKSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmdldFdpZGdldHNBdFBvc2l0aW9uKGNvbHVtbiwgcm93LCB0cnVlKVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKHdndCA9PiB3Z3QgIT09IHdpZGdldClcbiAgICAgICAgICAgICAgICAgICAgLmZvckVhY2god2d0ID0+IHRoaXMubW92ZVdpZGdldERvd24od2d0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1cGRhdGUgdGhlIGhlaWdodCBvZiB0aGUgZGFzaGJvYXJkXG4gICAgICAgIHRoaXMuc2V0RGFzaGJvYXJkSGVpZ2h0KCk7XG5cbiAgICAgICAgLy8gaWYgd2UgYXJlbnQgZHJhZ2dpbmcgdGhlIHRvcCBoYW5kbGUgdGhlbiBmaWxsIHNwYWNlc1xuICAgICAgICBpZiAodGhpcy5fYWN0aW9uV2lkZ2V0LmRpcmVjdGlvbiAhPT0gQWN0aW9uRGlyZWN0aW9uLlRvcCAmJlxuICAgICAgICAgICAgdGhpcy5fYWN0aW9uV2lkZ2V0LmRpcmVjdGlvbiAhPT0gQWN0aW9uRGlyZWN0aW9uLlRvcExlZnQgJiZcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvbldpZGdldC5kaXJlY3Rpb24gIT09IEFjdGlvbkRpcmVjdGlvbi5Ub3BSaWdodCkge1xuICAgICAgICAgICAgdGhpcy5zaGlmdFdpZGdldHNVcCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIGlmIGEgd2lkZ2V0IGlzIG9jY3VweWluZyBhIHNwZWNpZmljIHJvdyBhbmQgY29sdW1uXG4gICAgICogQHBhcmFtIGNvbHVtbiBUaGUgY29sdW1ucyB0byBjaGVjayBpZiBvY2N1cGllZFxuICAgICAqIEBwYXJhbSByb3cgVGhlIHJvdyB0byBjaGVjayBpZiBvY2N1cGllZFxuICAgICAqIEBwYXJhbSBpZ25vcmVSZXNpemluZyBXaGV0aGVyIG9yIG5vdCB0byBpZ25vcmUgdGhlIHdpZGdldCBjdXJyZW50bHkgYmVpbmcgcmVzaXplZFxuICAgICAqL1xuICAgIGdldFdpZGdldHNBdFBvc2l0aW9uKGNvbHVtbjogbnVtYmVyLCByb3c6IG51bWJlciwgaWdub3JlUmVzaXppbmc6IGJvb2xlYW4gPSBmYWxzZSk6IERhc2hib2FyZFdpZGdldENvbXBvbmVudFtdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T2NjdXBpZWRTcGFjZXMoKVxuICAgICAgICAgICAgLmZpbHRlcihzcGFjZSA9PiBzcGFjZS5jb2x1bW4gPT09IGNvbHVtbiAmJiBzcGFjZS5yb3cgPT09IHJvdylcbiAgICAgICAgICAgIC5maWx0ZXIoc3BhY2UgPT4gc3BhY2Uud2lkZ2V0ICE9PSB0aGlzLl9hY3Rpb25XaWRnZXQud2lkZ2V0IHx8ICFpZ25vcmVSZXNpemluZylcbiAgICAgICAgICAgIC5tYXAoc3BhY2UgPT4gc3BhY2Uud2lkZ2V0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIHBsYWNlaG9sZGVyIHZpc2liaWxpdHksIHBvc2l0aW9uIGFuZCBzaXplXG4gICAgICovXG4gICAgc2V0UGxhY2Vob2xkZXJCb3VuZHModmlzaWJsZTogYm9vbGVhbiwgeDogbnVtYmVyLCB5OiBudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKTogdm9pZCB7XG5cbiAgICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSB0aGlzLnBsYWNlaG9sZGVyJC5nZXRWYWx1ZSgpO1xuXG4gICAgICAgIGNvbnN0IHJvdW5kaW5nID0gdGhpcy5fYWN0aW9uV2lkZ2V0LmRpcmVjdGlvbiA9PT0gQWN0aW9uRGlyZWN0aW9uLkxlZnQgfHxcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvbldpZGdldC5kaXJlY3Rpb24gPT09IEFjdGlvbkRpcmVjdGlvbi5Ub3AgPyBSb3VuZGluZy5Sb3VuZERvd25CZWxvd0hhbGYgOiBSb3VuZGluZy5Sb3VuZFVwT3ZlckhhbGY7XG5cbiAgICAgICAgcGxhY2Vob2xkZXIudmlzaWJsZSA9IHZpc2libGU7XG5cbiAgICAgICAgcGxhY2Vob2xkZXIuY29sdW1uID0gdGhpcy5nZXRQbGFjZWhvbGRlckNvbHVtbih4LCB3aWR0aCk7XG4gICAgICAgIHBsYWNlaG9sZGVyLnJvdyA9IHRoaXMuZ2V0UGxhY2Vob2xkZXJSb3coeSwgaGVpZ2h0KTtcbiAgICAgICAgcGxhY2Vob2xkZXIuY29sdW1uU3BhbiA9IHRoaXMuZ2V0UGxhY2Vob2xkZXJDb2x1bW5TcGFuKHdpZHRoKTtcbiAgICAgICAgcGxhY2Vob2xkZXIucm93U3BhbiA9IHRoaXMuZ2V0UGxhY2Vob2xkZXJSb3dTcGFuKGhlaWdodCk7XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBtYXhpbXVtIG51bWJlciBvZiByb3dzXG4gICAgICAgIGNvbnN0IHJvd0NvdW50ID0gdGhpcy53aWRnZXRzLmZpbHRlcih3aWRnZXQgPT4gd2lkZ2V0ICE9PSB0aGlzLl9hY3Rpb25XaWRnZXQud2lkZ2V0KVxuICAgICAgICAgICAgLnJlZHVjZSgocHJldmlvdXMsIHdpZGdldCkgPT4gTWF0aC5tYXgod2lkZ2V0LmdldFJvdygpICsgd2lkZ2V0LmdldFJvd1NwYW4oKSwgcHJldmlvdXMpLCAwKTtcblxuICAgICAgICAvLyBjb25zdHJhaW4gbWF4aW11bSBwbGFjZWhvbGRlciByb3dcbiAgICAgICAgcGxhY2Vob2xkZXIucm93ID0gTWF0aC5taW4ocGxhY2Vob2xkZXIucm93LCByb3dDb3VudCk7XG5cbiAgICAgICAgcGxhY2Vob2xkZXIueCA9IChwbGFjZWhvbGRlci5jb2x1bW4gKiB0aGlzLmdldENvbHVtbldpZHRoKCkpICsgdGhpcy5vcHRpb25zLnBhZGRpbmc7XG4gICAgICAgIHBsYWNlaG9sZGVyLnkgPSAocGxhY2Vob2xkZXIucm93ICogdGhpcy5fcm93SGVpZ2h0KSArIHRoaXMub3B0aW9ucy5wYWRkaW5nO1xuICAgICAgICBwbGFjZWhvbGRlci53aWR0aCA9IChwbGFjZWhvbGRlci5jb2x1bW5TcGFuICogdGhpcy5nZXRDb2x1bW5XaWR0aCgpKSAtICh0aGlzLm9wdGlvbnMucGFkZGluZyAqIDIpO1xuICAgICAgICBwbGFjZWhvbGRlci5oZWlnaHQgPSAocGxhY2Vob2xkZXIucm93U3BhbiAqIHRoaXMuX3Jvd0hlaWdodCkgLSAodGhpcy5vcHRpb25zLnBhZGRpbmcgKiAyKTtcblxuICAgICAgICAvLyBzZXQgdGhlIHZhbHVlcyBvZiB0aGUgd2lkZ2V0IHRvIG1hdGNoIHRoZSB2YWx1ZXMgb2YgdGhlIHBsYWNlaG9sZGVyIC0gaG93ZXZlciBkbyBub3QgcmVuZGVyIHRoZSBjaGFuZ2VzXG4gICAgICAgIHRoaXMuX2FjdGlvbldpZGdldC53aWRnZXQuc2V0Q29sdW1uKHBsYWNlaG9sZGVyLmNvbHVtbiwgZmFsc2UpO1xuICAgICAgICB0aGlzLl9hY3Rpb25XaWRnZXQud2lkZ2V0LnNldFJvdyhwbGFjZWhvbGRlci5yb3csIGZhbHNlKTtcbiAgICAgICAgdGhpcy5fYWN0aW9uV2lkZ2V0LndpZGdldC5zZXRDb2x1bW5TcGFuKHBsYWNlaG9sZGVyLmNvbHVtblNwYW4sIGZhbHNlKTtcbiAgICAgICAgdGhpcy5fYWN0aW9uV2lkZ2V0LndpZGdldC5zZXRSb3dTcGFuKHBsYWNlaG9sZGVyLnJvd1NwYW4sIGZhbHNlKTtcblxuICAgICAgICAvLyB1cGRhdGUgdGhlIHBsYWNlaG9sZGVyXG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXIkLm5leHQocGxhY2Vob2xkZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcGxhY2Vob2xkZXIgY29sdW1uIHBvc2l0aW9uXG4gICAgICovXG4gICAgZ2V0UGxhY2Vob2xkZXJDb2x1bW4oeDogbnVtYmVyLCB3aWR0aDogbnVtYmVyKTogbnVtYmVyIHtcblxuICAgICAgICBjb25zdCBjb2x1bW4gPSB0aGlzLmdldENvbHVtbkZyb21QeCh4LCB0aGlzLl9hY3Rpb25XaWRnZXQuZGlyZWN0aW9uID09PSBBY3Rpb25EaXJlY3Rpb24uTW92ZSA/IFJvdW5kaW5nLlJvdW5kVXBPdmVySGFsZiA6IFJvdW5kaW5nLlJvdW5kRG93bik7XG4gICAgICAgIGNvbnN0IGNvbHVtblNwYW4gPSBNYXRoLmZsb29yKHdpZHRoIC8gdGhpcy5nZXRDb2x1bW5XaWR0aCgpKTtcbiAgICAgICAgY29uc3QgdXBwZXJMaW1pdCA9IHRoaXMuZ2V0Q29sdW1uQ291bnQoKSAtIGNvbHVtblNwYW47XG5cbiAgICAgICAgLy8gaWYgd2UgYXJlbnQgZHJhZ2dpbmcgbGVmdCB0aGVuIGp1c3QgcmV0dXJuIHRoZSBjb2x1bW5cbiAgICAgICAgaWYgKHRoaXMuX2FjdGlvbldpZGdldC5kaXJlY3Rpb24gIT09IEFjdGlvbkRpcmVjdGlvbi5MZWZ0ICYmXG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25XaWRnZXQuZGlyZWN0aW9uICE9PSBBY3Rpb25EaXJlY3Rpb24uVG9wTGVmdCAmJlxuICAgICAgICAgICAgdGhpcy5fYWN0aW9uV2lkZ2V0LmRpcmVjdGlvbiAhPT0gQWN0aW9uRGlyZWN0aW9uLkJvdHRvbUxlZnQpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heChNYXRoLm1pbihjb2x1bW4sIHVwcGVyTGltaXQpLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdldCBhbnkgb3ZlcmZsb3dcbiAgICAgICAgY29uc3Qgb3ZlcmZsb3cgPSB3aWR0aCAlIHRoaXMuZ2V0Q29sdW1uV2lkdGgoKTtcblxuICAgICAgICByZXR1cm4gKHggPD0gMCB8fCBvdmVyZmxvdyA9PT0gMCB8fCBjb2x1bW5TcGFuID09PSAwIHx8IG92ZXJmbG93ID4gKHRoaXMuZ2V0Q29sdW1uV2lkdGgoKSAvIDIpKSA/XG4gICAgICAgICAgICBNYXRoLm1heChNYXRoLm1pbihjb2x1bW4sIHVwcGVyTGltaXQpLCAwKSA6XG4gICAgICAgICAgICBNYXRoLm1heChNYXRoLm1pbihjb2x1bW4gKyAxLCB1cHBlckxpbWl0KSwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjb2x1bW4gc3BhbiBvZiB0aGUgcGxhY2Vob2xkZXJcbiAgICAgKi9cbiAgICBnZXRQbGFjZWhvbGRlckNvbHVtblNwYW4od2lkdGg6IG51bWJlcik6IG51bWJlciB7XG5cbiAgICAgICAgY29uc3QgY29sdW1uU3BhbiA9IHRoaXMuZ2V0Q29sdW1uRnJvbVB4KHdpZHRoKTtcblxuICAgICAgICAvLyBpZiB3ZSBhcmVudCBkcmFnZ2luZyByaWdodCBvciBsZWZ0IHRoZW4ganVzdCByZXR1cm4gdGhlIGNvbHVtbiBzcGFuXG4gICAgICAgIGlmICh0aGlzLl9hY3Rpb25XaWRnZXQuZGlyZWN0aW9uICE9PSBBY3Rpb25EaXJlY3Rpb24uUmlnaHQgJiZcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvbldpZGdldC5kaXJlY3Rpb24gIT09IEFjdGlvbkRpcmVjdGlvbi5Ub3BSaWdodCAmJlxuICAgICAgICAgICAgdGhpcy5fYWN0aW9uV2lkZ2V0LmRpcmVjdGlvbiAhPT0gQWN0aW9uRGlyZWN0aW9uLkJvdHRvbVJpZ2h0ICYmXG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25XaWRnZXQuZGlyZWN0aW9uICE9PSBBY3Rpb25EaXJlY3Rpb24uTGVmdCAmJlxuICAgICAgICAgICAgdGhpcy5fYWN0aW9uV2lkZ2V0LmRpcmVjdGlvbiAhPT0gQWN0aW9uRGlyZWN0aW9uLlRvcExlZnQgJiZcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvbldpZGdldC5kaXJlY3Rpb24gIT09IEFjdGlvbkRpcmVjdGlvbi5Cb3R0b21MZWZ0KSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoY29sdW1uU3BhbiwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgdGhlIGN1cnJlbnQgY29sdW1uIHNwYW4gYW5kIGFueSBvdmVyZmxvd1xuICAgICAgICBjb25zdCBvdmVyZmxvdyA9IHdpZHRoICUgdGhpcy5nZXRDb2x1bW5XaWR0aCgpO1xuXG4gICAgICAgIHJldHVybiAoY29sdW1uU3BhbiA+IDAgJiYgb3ZlcmZsb3cgPiAodGhpcy5nZXRDb2x1bW5XaWR0aCgpIC8gMikpID8gTWF0aC5tYXgoY29sdW1uU3BhbiArIDEsIDEpIDogTWF0aC5tYXgoY29sdW1uU3BhbiwgMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSByb3cgcG9zaXRpb24gb2YgdGhlIHBsYWNlaG9sZGVyXG4gICAgICovXG4gICAgZ2V0UGxhY2Vob2xkZXJSb3coeTogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcik6IG51bWJlciB7XG5cbiAgICAgICAgY29uc3Qgcm93ID0gdGhpcy5nZXRSb3dGcm9tUHgoeSwgdGhpcy5fYWN0aW9uV2lkZ2V0LmRpcmVjdGlvbiA9PT0gQWN0aW9uRGlyZWN0aW9uLk1vdmUgPyBSb3VuZGluZy5Sb3VuZFVwT3ZlckhhbGYgOiBSb3VuZGluZy5Sb3VuZERvd24pO1xuICAgICAgICBjb25zdCByb3dTcGFuID0gTWF0aC5jZWlsKGhlaWdodCAvIHRoaXMuX3Jvd0hlaWdodCk7XG5cbiAgICAgICAgLy8gaWYgd2UgYXJlbnQgZHJhZ2dpbmcgdXAgdGhlbiBqdXN0IHJldHVybiB0aGUgcm93XG4gICAgICAgIGlmICh0aGlzLl9hY3Rpb25XaWRnZXQuZGlyZWN0aW9uICE9PSBBY3Rpb25EaXJlY3Rpb24uVG9wICYmXG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25XaWRnZXQuZGlyZWN0aW9uICE9PSBBY3Rpb25EaXJlY3Rpb24uVG9wTGVmdCAmJlxuICAgICAgICAgICAgdGhpcy5fYWN0aW9uV2lkZ2V0LmRpcmVjdGlvbiAhPT0gQWN0aW9uRGlyZWN0aW9uLlRvcFJpZ2h0KSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgocm93LCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdldCBhbnkgb3ZlcmZsb3dcbiAgICAgICAgbGV0IG92ZXJmbG93ID0gaGVpZ2h0IDwgdGhpcy5fcm93SGVpZ2h0ID8gMCA6IGhlaWdodCAlIHRoaXMuX3Jvd0hlaWdodDtcblxuICAgICAgICByZXR1cm4gKHkgPD0gMCB8fCByb3dTcGFuID09PSAwIHx8IG92ZXJmbG93ID09PSAwIHx8IG92ZXJmbG93ID4gKHRoaXMuX3Jvd0hlaWdodCAvIDIpKSA/IE1hdGgubWF4KHJvdywgMCkgOiBNYXRoLm1heChyb3cgKyAxLCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHJvdyBzcGFuIG9mIHRoZSBwbGFjZWhvbGRlclxuICAgICAqL1xuICAgIGdldFBsYWNlaG9sZGVyUm93U3BhbihoZWlnaHQ6IG51bWJlcik6IG51bWJlciB7XG5cbiAgICAgICAgY29uc3Qgcm93U3BhbiA9IHRoaXMuZ2V0Um93RnJvbVB4KGhlaWdodCk7XG5cbiAgICAgICAgLy8gaWYgd2UgYXJlbnQgZHJhZ2dpbmcgdXAgb3IgZG93biB0aGVuIGp1c3QgcmV0dXJuIHRoZSBjb2x1bW4gc3BhblxuICAgICAgICBpZiAodGhpcy5fYWN0aW9uV2lkZ2V0LmRpcmVjdGlvbiAhPT0gQWN0aW9uRGlyZWN0aW9uLlRvcCAmJlxuICAgICAgICAgICAgdGhpcy5fYWN0aW9uV2lkZ2V0LmRpcmVjdGlvbiAhPT0gQWN0aW9uRGlyZWN0aW9uLlRvcExlZnQgJiZcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvbldpZGdldC5kaXJlY3Rpb24gIT09IEFjdGlvbkRpcmVjdGlvbi5Ub3BSaWdodCAmJlxuICAgICAgICAgICAgdGhpcy5fYWN0aW9uV2lkZ2V0LmRpcmVjdGlvbiAhPT0gQWN0aW9uRGlyZWN0aW9uLkJvdHRvbSAmJlxuICAgICAgICAgICAgdGhpcy5fYWN0aW9uV2lkZ2V0LmRpcmVjdGlvbiAhPT0gQWN0aW9uRGlyZWN0aW9uLkJvdHRvbUxlZnQgJiZcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvbldpZGdldC5kaXJlY3Rpb24gIT09IEFjdGlvbkRpcmVjdGlvbi5Cb3R0b21SaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KHJvd1NwYW4sIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBjdXJyZW50IGNvbHVtbiBzcGFuIGFuZCBhbnkgb3ZlcmZsb3dcbiAgICAgICAgY29uc3Qgb3ZlcmZsb3cgPSBoZWlnaHQgJSB0aGlzLl9yb3dIZWlnaHQ7XG5cbiAgICAgICAgcmV0dXJuIChvdmVyZmxvdyA+ICh0aGlzLl9yb3dIZWlnaHQgLyAyKSkgPyBNYXRoLm1heChyb3dTcGFuICsgMSwgMSkgOiBNYXRoLm1heChyb3dTcGFuLCAxKTtcbiAgICB9XG5cbiAgICBnZXRDb2x1bW5Gcm9tUHgoeDogbnVtYmVyLCByb3VuZGluZzogUm91bmRpbmcgPSBSb3VuZGluZy5Sb3VuZERvd24pOiBudW1iZXIge1xuXG4gICAgICAgIGNvbnN0IGNvbHVtbiA9IE1hdGguZmxvb3IoeCAvIE1hdGguZmxvb3IodGhpcy5nZXRDb2x1bW5XaWR0aCgpKSk7XG4gICAgICAgIGNvbnN0IG92ZXJmbG93ID0gKHggJSBNYXRoLmZsb29yKHRoaXMuZ2V0Q29sdW1uV2lkdGgoKSkpO1xuICAgICAgICBjb25zdCBoYWxmID0gdGhpcy5nZXRDb2x1bW5XaWR0aCgpIC8gMjtcblxuICAgICAgICBzd2l0Y2ggKHJvdW5kaW5nKSB7XG5cbiAgICAgICAgICAgIGNhc2UgUm91bmRpbmcuUm91bmREb3duOlxuICAgICAgICAgICAgICAgIHJldHVybiBjb2x1bW47XG5cbiAgICAgICAgICAgIGNhc2UgUm91bmRpbmcuUm91bmREb3duQmVsb3dIYWxmOlxuICAgICAgICAgICAgICAgIHJldHVybiBvdmVyZmxvdyA8IGhhbGYgPyBjb2x1bW4gOiBjb2x1bW4gKyAxO1xuXG4gICAgICAgICAgICBjYXNlIFJvdW5kaW5nLlJvdW5kVXBPdmVySGFsZjpcbiAgICAgICAgICAgICAgICByZXR1cm4gb3ZlcmZsb3cgPiBoYWxmID8gY29sdW1uICsgMSA6IGNvbHVtbjtcblxuICAgICAgICAgICAgY2FzZSBSb3VuZGluZy5Sb3VuZFVwOlxuICAgICAgICAgICAgICAgIHJldHVybiBvdmVyZmxvdyA+IDAgPyBjb2x1bW4gKyAxIDogY29sdW1uO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBnZXRSb3dGcm9tUHgoeTogbnVtYmVyLCByb3VuZGluZzogUm91bmRpbmcgPSBSb3VuZGluZy5Sb3VuZERvd24pOiBudW1iZXIge1xuXG4gICAgICAgIGNvbnN0IHJvdyA9IE1hdGguZmxvb3IoeSAvIE1hdGguZmxvb3IodGhpcy5fcm93SGVpZ2h0KSk7XG4gICAgICAgIGNvbnN0IG92ZXJmbG93ID0gKHkgJSBNYXRoLmZsb29yKHRoaXMuX3Jvd0hlaWdodCkpO1xuICAgICAgICBjb25zdCBoYWxmID0gdGhpcy5fcm93SGVpZ2h0IC8gMjtcblxuICAgICAgICBzd2l0Y2ggKHJvdW5kaW5nKSB7XG5cbiAgICAgICAgICAgIGNhc2UgUm91bmRpbmcuUm91bmREb3duOlxuICAgICAgICAgICAgICAgIHJldHVybiByb3c7XG5cbiAgICAgICAgICAgIGNhc2UgUm91bmRpbmcuUm91bmREb3duQmVsb3dIYWxmOlxuICAgICAgICAgICAgICAgIHJldHVybiBvdmVyZmxvdyA8IGhhbGYgPyByb3cgOiByb3cgKyAxO1xuXG4gICAgICAgICAgICBjYXNlIFJvdW5kaW5nLlJvdW5kVXBPdmVySGFsZjpcbiAgICAgICAgICAgICAgICByZXR1cm4gb3ZlcmZsb3cgPiBoYWxmID8gcm93ICsgMSA6IHJvdztcblxuICAgICAgICAgICAgY2FzZSBSb3VuZGluZy5Sb3VuZFVwOlxuICAgICAgICAgICAgICAgIHJldHVybiBvdmVyZmxvdyA+IDAgPyByb3cgKyAxIDogcm93O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29tbWl0V2lkZ2V0Q2hhbmdlcygpOiB2b2lkIHtcblxuICAgICAgICBjb25zdCBwbGFjZWhvbGRlciA9IHRoaXMucGxhY2Vob2xkZXIkLmdldFZhbHVlKCk7XG5cbiAgICAgICAgLy8gY2hlY2sgdGhhdCB3ZSBoYXZlIGFsbCB0aGUgdmFsdWVzIHdlIG5lZWRcbiAgICAgICAgaWYgKHBsYWNlaG9sZGVyLmNvbHVtbiA9PT0gdW5kZWZpbmVkIHx8IHBsYWNlaG9sZGVyLnJvdyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICBwbGFjZWhvbGRlci5jb2x1bW5TcGFuID09PSB1bmRlZmluZWQgfHwgcGxhY2Vob2xkZXIucm93U3BhbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fYWN0aW9uV2lkZ2V0KSB7XG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25XaWRnZXQud2lkZ2V0LnNldENvbHVtbihwbGFjZWhvbGRlci5jb2x1bW4pO1xuICAgICAgICAgICAgdGhpcy5fYWN0aW9uV2lkZ2V0LndpZGdldC5zZXRSb3cocGxhY2Vob2xkZXIucm93KTtcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvbldpZGdldC53aWRnZXQuc2V0Q29sdW1uU3BhbihwbGFjZWhvbGRlci5jb2x1bW5TcGFuKTtcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvbldpZGdldC53aWRnZXQuc2V0Um93U3BhbihwbGFjZWhvbGRlci5yb3dTcGFuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlc2V0IGFsbCBwbGFjZWhvbGRlciB2YWx1ZXNcbiAgICAgICAgcGxhY2Vob2xkZXIuY29sdW1uID0gdW5kZWZpbmVkO1xuICAgICAgICBwbGFjZWhvbGRlci5yb3cgPSB1bmRlZmluZWQ7XG4gICAgICAgIHBsYWNlaG9sZGVyLmNvbHVtblNwYW4gPSB1bmRlZmluZWQ7XG4gICAgICAgIHBsYWNlaG9sZGVyLnJvd1NwYW4gPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgLy8gZW1pdCB0aGUgbmV3IHBsYWNlaG9sZGVyIHZhbHVlc1xuICAgICAgICB0aGlzLnBsYWNlaG9sZGVyJC5uZXh0KHBsYWNlaG9sZGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgY29sdW1uIHdpZHRoXG4gICAgICovXG4gICAgZ2V0Q29sdW1uV2lkdGgoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IodGhpcy5jb2x1bW5XaWR0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBudW1iZXIgb2Ygcm93cyBwb3B1bGF0ZWQgd2l0aCB3aWRnZXRzXG4gICAgICovXG4gICAgZ2V0Um93Q291bnQoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lkZ2V0cy5yZWR1Y2UoKHByZXZpb3VzLCB3aWRnZXQpID0+IE1hdGgubWF4KHdpZGdldC5nZXRSb3coKSArIHdpZGdldC5nZXRSb3dTcGFuKCksIHByZXZpb3VzKSwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBoZWlnaHQgb2YgdGhlIGRhc2hib2FyZCBjb250YWluZXIgZWxlbWVudFxuICAgICAqL1xuICAgIHNldERhc2hib2FyZEhlaWdodCgpOiB2b2lkIHtcblxuICAgICAgICAvLyBzaXplIHRoZSBkYXNoYm9hcmQgY29udGFpbmVyIHRvIGVuc3VyZSBhbGwgcm93cyBmaXRcbiAgICAgICAgbGV0IHJvd0NvdW50ID0gdGhpcy5nZXRSb3dDb3VudCgpO1xuXG4gICAgICAgIC8vIGlmIHdlIHNob3VsZCBzaG93IGFuIGVtcHR5IHJvdyBpbmNyZW1lbnQgdGhlIHJvdyBjb3VudCBieSAxXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZW1wdHlSb3cpIHtcbiAgICAgICAgICAgIHJvd0NvdW50Kys7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldERpbWVuc2lvbnModW5kZWZpbmVkLCByb3dDb3VudCAqIHRoaXMuX3Jvd0hlaWdodCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3JkZXJzIHRoZSB6LWluZGV4IG9mIGFsbCB3aWRnZXRzIHRvIG1vdmUgdGhlIGFjdGl2ZSBvbmUgdG8gdGhlIGZyb250XG4gICAgICogQHBhcmFtIHdpZGdldCBUaGUgd2lkZ2V0IHRoYXQgc2hvdWxkIGJlIGJyb3VnaHQgdG8gdGhlIGZyb250XG4gICAgICovXG4gICAgYnJpbmdUb0Zyb250KHdpZGdldDogRGFzaGJvYXJkV2lkZ2V0Q29tcG9uZW50KTogdm9pZCB7XG4gICAgICAgIHRoaXMud2lkZ2V0cy5mb3JFYWNoKF93aWRnZXQgPT4gX3dpZGdldCA9PT0gd2lkZ2V0ID8gX3dpZGdldC5icmluZ1RvRnJvbnQoKSA6IF93aWRnZXQuc2VuZFRvQmFjaygpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNb3ZlIGEgd2lkZ2V0IGRvd24gLSBpZiB3aWRnZXRzIGFyZSBpbiB0aGUgcG9zaXRpb24gYmVsb3csIHRoZW4gbW92ZSB0aGVtIGRvd24gZnVydGhlclxuICAgICAqIEBwYXJhbSB3aWRnZXQgVGhlIHdpZGdldCB0byBtb3ZlIGRvd253YXJkc1xuICAgICAqL1xuICAgIG1vdmVXaWRnZXREb3duKHdpZGdldDogRGFzaGJvYXJkV2lkZ2V0Q29tcG9uZW50LCBkaXN0YW5jZTogbnVtYmVyID0gMSk6IHZvaWQge1xuXG4gICAgICAgIC8vIG1vdmUgdGhlIHdpZGdldCBkb3duIG9uZSBwb3NpdGlvblxuICAgICAgICB3aWRnZXQuc2V0Um93KHdpZGdldC5nZXRSb3coKSArIGRpc3RhbmNlKTtcblxuICAgICAgICAvLyBjaGVjayBldmVyeSBzcGFjZSB0aGUgd2lkZ2V0IG9jY3VwaWVzIGZvciBjb2xsaXNpb25zXG4gICAgICAgIHRoaXMuZm9yRWFjaEJsb2NrKHdpZGdldCwgKGNvbHVtbiwgcm93KSA9PlxuICAgICAgICAgICAgdGhpcy5nZXRXaWRnZXRzQXRQb3NpdGlvbihjb2x1bW4sIHJvdywgdHJ1ZSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKHdndCA9PiB3Z3QgIT09IHdpZGdldClcbiAgICAgICAgICAgICAgICAuZm9yRWFjaCh3Z3QgPT4gdGhpcy5tb3ZlV2lkZ2V0RG93bih3Z3QsIGRpc3RhbmNlKSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdpZGdldHMgc2hvdWxkIG5vdCBiZSBhbGxvd2VkIHRvIGhhdmUgYSB2YWNhbnQgc3BhY2UgYWJvdmUgdGhlbSAtIGlmIHRoZXJlIGlzIG9uZSB0aGV5IHNob3VsZCBtb3ZlIHVwd2FyZHMgdG8gZmlsbCBpdFxuICAgICAqL1xuICAgIHNoaWZ0V2lkZ2V0c1VwKCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGNoZWNrIHdoZXRoZXIgb3Igbm90IGNoYW5nZXMgaGF2ZSBiZWVuIG1hZGUgLSBpZiBzbyB3ZSBuZWVkIHRvIHJlcGVhdCB1bnRpbCBzdGFibGVcbiAgICAgICAgbGV0IHN0YWJsZSA9IHRydWU7XG5cbiAgICAgICAgLy8gaXRlcmF0ZSBlYWNoIHdpZGdldCBhbmRcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2god2lkZ2V0ID0+IHtcblxuICAgICAgICAgICAgLy8gaWYgd2lkZ2V0IGlzIGFscmVhZHkgb24gdGhlIHRvcCByb3cgdGhlbiBkbyBub3RoaW5nXG4gICAgICAgICAgICBpZiAod2lkZ2V0LmdldFJvdygpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB3ZSBhcmUgY3VycmVudGx5IGRyYWdnaW5nIGFuZCB0aGlzIGlzIHRoZSBkcmFnZ2luZyB3aWRnZXQgdGhlbiBza2lwXG4gICAgICAgICAgICBpZiAodGhpcy5fYWN0aW9uV2lkZ2V0ICYmIHRoaXMuX2FjdGlvbldpZGdldC53aWRnZXQgPT09IHdpZGdldCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0UG9zaXRpb25BdmFpbGFibGUod2lkZ2V0LmdldENvbHVtbigpLCB3aWRnZXQuZ2V0Um93KCkgLSAxLCB3aWRnZXQuZ2V0Q29sdW1uU3BhbigpLCAxKSkge1xuICAgICAgICAgICAgICAgIHdpZGdldC5zZXRSb3cod2lkZ2V0LmdldFJvdygpIC0gMSk7XG4gICAgICAgICAgICAgICAgc3RhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGlmIGNoYW5nZXMgb2NjdXJyZWQgdGhlbiB3ZSBzaG91bGQgcmVwZWF0IHRoZSBwcm9jZXNzXG4gICAgICAgIGlmICghc3RhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLnNoaWZ0V2lkZ2V0c1VwKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlIG92ZXIgZWFjaCBzcGFjZSBhIHdpZGdldCBvY2N1cGllZFxuICAgICAqIEBwYXJhbSB3aWRnZXQgVGhlIHdpZGdldCB0byBkZXRlcm1pbmUgc3BhY2VzXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgZm9yIGVhY2ggc3BhY2UsIHNob3VsZCBleHBlY3QgYSBjb2x1bW4gYW5kIHJvdyBhcmd1bWVudCB3aXRodCBoZSBjb250ZXh0IGJlaW5nIHRoZSB3aWRnZXRcbiAgICAgKi9cbiAgICBmb3JFYWNoQmxvY2sod2lkZ2V0OiBEYXNoYm9hcmRXaWRnZXRDb21wb25lbnQsIGNhbGxiYWNrOiAoY29sdW1uOiBudW1iZXIsIHJvdzogbnVtYmVyKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgICAgIGZvciAobGV0IHJvdyA9IHdpZGdldC5nZXRSb3coKTsgcm93IDwgd2lkZ2V0LmdldFJvdygpICsgd2lkZ2V0LmdldFJvd1NwYW4oKTsgcm93KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGNvbHVtbiA9IHdpZGdldC5nZXRDb2x1bW4oKTsgY29sdW1uIDwgd2lkZ2V0LmdldENvbHVtbigpICsgd2lkZ2V0LmdldENvbHVtblNwYW4oKTsgY29sdW1uKyspIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKHdpZGdldCwgY29sdW1uLCByb3cpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGNvbHVtbnMgYXZhaWxhYmxlXG4gICAgICovXG4gICAgZ2V0Q29sdW1uQ291bnQoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhY2tlZCA/IDEgOiB0aGlzLm9wdGlvbnMuY29sdW1ucztcbiAgICB9XG59XG5cbmV4cG9ydCBjb25zdCBkZWZhdWx0T3B0aW9uczogRGFzaGJvYXJkT3B0aW9ucyA9IHsgY29sdW1uczogNSwgcGFkZGluZzogNSwgbWluV2lkdGg6IDEwMCwgbWluSGVpZ2h0OiAxMDAsIGVtcHR5Um93OiB0cnVlIH07XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGFzaGJvYXJkRGltZW5zaW9ucyB7XG4gICAgd2lkdGg/OiBudW1iZXI7XG4gICAgaGVpZ2h0PzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERhc2hib2FyZFdpZGdldERpbWVuc2lvbnMge1xuICAgIHg6IG51bWJlcjtcbiAgICB5OiBudW1iZXI7XG4gICAgd2lkdGg6IG51bWJlcjtcbiAgICBoZWlnaHQ6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEYXNoYm9hcmRBY3Rpb24ge1xuICAgIHdpZGdldDogRGFzaGJvYXJkV2lkZ2V0Q29tcG9uZW50O1xuICAgIGRpcmVjdGlvbjogQWN0aW9uRGlyZWN0aW9uO1xuICAgIGV2ZW50OiBNb3VzZUV2ZW50O1xuICAgIGhhbmRsZT86IEhUTUxFbGVtZW50O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERhc2hib2FyZFNwYWNlIHtcbiAgICB3aWRnZXQ6IERhc2hib2FyZFdpZGdldENvbXBvbmVudDtcbiAgICBjb2x1bW46IG51bWJlcjtcbiAgICByb3c6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEYXNoYm9hcmRQbGFjZWhvbGRlciB7XG4gICAgdmlzaWJsZTogYm9vbGVhbjtcbiAgICB4OiBudW1iZXI7XG4gICAgeTogbnVtYmVyO1xuICAgIHdpZHRoOiBudW1iZXI7XG4gICAgaGVpZ2h0OiBudW1iZXI7XG4gICAgY29sdW1uPzogbnVtYmVyO1xuICAgIHJvdz86IG51bWJlcjtcbiAgICBjb2x1bW5TcGFuPzogbnVtYmVyO1xuICAgIHJvd1NwYW4/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGFzaGJvYXJkQ2FjaGUge1xuICAgIGlkOiBzdHJpbmc7XG4gICAgY29sdW1uOiBudW1iZXI7XG4gICAgcm93OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGFzaGJvYXJkTGF5b3V0RGF0YSB7XG4gICAgaWQ6IHN0cmluZztcbiAgICBjb2w6IG51bWJlcjtcbiAgICByb3c6IG51bWJlcjtcbiAgICBjb2xTcGFuOiBudW1iZXI7XG4gICAgcm93U3BhbjogbnVtYmVyO1xufVxuXG5leHBvcnQgZW51bSBBY3Rpb25EaXJlY3Rpb24ge1xuICAgIFRvcCA9IDAsXG4gICAgVG9wUmlnaHQgPSAxLFxuICAgIFJpZ2h0ID0gMixcbiAgICBCb3R0b21SaWdodCA9IDMsXG4gICAgQm90dG9tID0gNCxcbiAgICBCb3R0b21MZWZ0ID0gNSxcbiAgICBMZWZ0ID0gNixcbiAgICBUb3BMZWZ0ID0gNyxcbiAgICBNb3ZlID0gOFxufVxuXG5leHBvcnQgZW51bSBSb3VuZGluZyB7XG4gICAgUm91bmREb3duLFxuICAgIFJvdW5kRG93bkJlbG93SGFsZixcbiAgICBSb3VuZFVwLFxuICAgIFJvdW5kVXBPdmVySGFsZlxufSIsImltcG9ydCB7IEFmdGVyVmlld0luaXQsIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDb21wb25lbnQsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE91dHB1dCwgVmlld0NoaWxkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBSZXNpemVEaW1lbnNpb25zIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9yZXNpemUvcmVzaXplLnNlcnZpY2UnO1xuaW1wb3J0IHsgRGFzaGJvYXJkTGF5b3V0RGF0YSwgRGFzaGJvYXJkU2VydmljZSwgZGVmYXVsdE9wdGlvbnMgfSBmcm9tICcuL2Rhc2hib2FyZC5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1kYXNoYm9hcmQnLFxuICAgIHRlbXBsYXRlOiBgPGRpdiAjZGFzaGJvYXJkIGNsYXNzPVwiZGFzaGJvYXJkLWNvbnRhaW5lclwiIFtzdHlsZS5oZWlnaHQucHhdPVwiZGFzaGJvYXJkU2VydmljZS5oZWlnaHQkIHwgYXN5bmNcIj5cbiAgICA8ZGl2ICh1eFJlc2l6ZSk9XCJvblJlc2l6ZSgkZXZlbnQpXCIgW3Rocm90dGxlXT1cIjE2XCIgY2xhc3M9XCJkYXNoYm9hcmRcIj5cbiAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgIDwvZGl2PlxuICAgIFxuICAgIDxkaXYgY2xhc3M9XCJwb3NpdGlvbi1pbmRpY2F0b3JcIiAqbmdJZj1cIihkYXNoYm9hcmRTZXJ2aWNlLnBsYWNlaG9sZGVyJCB8IGFzeW5jKS52aXNpYmxlXCIgXG4gICAgICAgIFtzdHlsZS5sZWZ0LnB4XT1cIihkYXNoYm9hcmRTZXJ2aWNlLnBsYWNlaG9sZGVyJCB8IGFzeW5jKS54XCIgXG4gICAgICAgIFtzdHlsZS50b3AucHhdPVwiKGRhc2hib2FyZFNlcnZpY2UucGxhY2Vob2xkZXIkIHwgYXN5bmMpLnlcIiBcbiAgICAgICAgW3N0eWxlLndpZHRoLnB4XT1cIihkYXNoYm9hcmRTZXJ2aWNlLnBsYWNlaG9sZGVyJCB8IGFzeW5jKS53aWR0aFwiXG4gICAgICAgIFtzdHlsZS5oZWlnaHQucHhdPVwiKGRhc2hib2FyZFNlcnZpY2UucGxhY2Vob2xkZXIkIHwgYXN5bmMpLmhlaWdodFwiPjwvZGl2PlxuPC9kaXY+YCxcbiAgICBwcm92aWRlcnM6IFtEYXNoYm9hcmRTZXJ2aWNlXSxcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxufSlcbmV4cG9ydCBjbGFzcyBEYXNoYm9hcmRDb21wb25lbnQgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0IHtcblxuICAgIEBJbnB1dCgpIHNldCBsYXlvdXQobGF5b3V0OiBEYXNoYm9hcmRMYXlvdXREYXRhW10pIHtcbiAgICAgICAgaWYgKGxheW91dCkge1xuICAgICAgICAgICAgdGhpcy5kYXNoYm9hcmRTZXJ2aWNlLmxheW91dCQubmV4dChsYXlvdXQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgQElucHV0KCkgc2V0IG9wdGlvbnMob3B0aW9uczogRGFzaGJvYXJkT3B0aW9ucykge1xuICAgICAgICB0aGlzLmRhc2hib2FyZFNlcnZpY2Uub3B0aW9ucyQubmV4dCh7IC4uLmRlZmF1bHRPcHRpb25zLCAuLi5vcHRpb25zIH0pO1xuICAgIH1cblxuICAgIEBPdXRwdXQoKSBsYXlvdXRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPERhc2hib2FyZExheW91dERhdGFbXT4oKTtcblxuICAgIEBWaWV3Q2hpbGQoJ2Rhc2hib2FyZCcpIGRhc2hib2FyZEVsZW1lbnQ6IEVsZW1lbnRSZWY7XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZGFzaGJvYXJkU2VydmljZTogRGFzaGJvYXJkU2VydmljZSkge1xuICAgICAgICBkYXNoYm9hcmRTZXJ2aWNlLmxheW91dCQuc3Vic2NyaWJlKGxheW91dCA9PiB0aGlzLmxheW91dENoYW5nZS5lbWl0KGxheW91dCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgaW5pdGlhbCBkaW1lbnNpb25zXG4gICAgICovXG4gICAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLmRhc2hib2FyZFNlcnZpY2Uuc2V0RGltZW5zaW9ucyh0aGlzLmRhc2hib2FyZEVsZW1lbnQubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aCwgdGhpcy5kYXNoYm9hcmRFbGVtZW50Lm5hdGl2ZUVsZW1lbnQub2Zmc2V0SGVpZ2h0KTtcbiAgICB9XG5cbiAgICBvblJlc2l6ZShldmVudDogUmVzaXplRGltZW5zaW9ucyk6IHZvaWQge1xuICAgICAgICB0aGlzLmRhc2hib2FyZFNlcnZpY2Uuc2V0RGltZW5zaW9ucyhldmVudC53aWR0aCwgZXZlbnQuaGVpZ2h0KTtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGFzaGJvYXJkT3B0aW9ucyB7XG4gICAgY29sdW1ucz86IG51bWJlcjtcbiAgICBwYWRkaW5nPzogbnVtYmVyO1xuICAgIG1pbldpZHRoPzogbnVtYmVyO1xuICAgIG1pbkhlaWdodD86IG51bWJlcjtcbiAgICByb3dIZWlnaHQ/OiBudW1iZXI7XG4gICAgZW1wdHlSb3c/OiBib29sZWFuO1xufSIsImltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIE9uSW5pdCwgT25EZXN0cm95LCBIb3N0QmluZGluZywgQWZ0ZXJWaWV3SW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRGFzaGJvYXJkU2VydmljZSwgQWN0aW9uRGlyZWN0aW9uIH0gZnJvbSAnLi4vZGFzaGJvYXJkLnNlcnZpY2UnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcy9TdWJzY3JpcHRpb24nO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LWRhc2hib2FyZC13aWRnZXQnLFxuICAgIHRlbXBsYXRlOiBgPGRpdiBjbGFzcz1cIndpZGdldC1jb250ZW50IHdpZGdldC1jb2wtc3Bhbi17eyBnZXRDb2x1bW5TcGFuKCkgfX0gd2lkZ2V0LXJvdy1zcGFuLXt7IGdldFJvd1NwYW4oKSB9fVwiPlxuICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbjwvZGl2PlxuXG48ZGl2IHV4RHJhZyAjaGFuZGxlVG9wIGNsYXNzPVwicmVzaXplci1oYW5kbGUgaGFuZGxlLXRvcFwiIFxuICAgIChkcmFnc3RhcnQpPVwiZHJhZ3N0YXJ0KGhhbmRsZVRvcCwgJGV2ZW50LCAwKVwiXG4gICAgKGRyYWcpPVwiZHJhZyhoYW5kbGVUb3AsICRldmVudCwgMClcIlxuICAgIChkcmFnZW5kKT1cImRyYWdlbmQoKVwiXG4gICAgW3N0eWxlLnRvcC5weF09XCJwYWRkaW5nXCIgXG4gICAgW2hpZGRlbl09XCIhcmVzaXphYmxlXCI+XG48L2Rpdj5cblxuPGRpdiB1eERyYWcgI2hhbmRsZVRvcFJpZ2h0IGNsYXNzPVwicmVzaXplci1oYW5kbGUgaGFuZGxlLXRvcC1yaWdodFwiIFxuICAgIChkcmFnc3RhcnQpPVwiZHJhZ3N0YXJ0KGhhbmRsZVRvcFJpZ2h0LCAkZXZlbnQsIDEpXCJcbiAgICAoZHJhZyk9XCJkcmFnKGhhbmRsZVRvcFJpZ2h0LCAkZXZlbnQsIDEpXCJcbiAgICAoZHJhZ2VuZCk9XCJkcmFnZW5kKClcIlxuICAgIFtzdHlsZS50b3AucHhdPVwicGFkZGluZ1wiIFxuICAgIFtzdHlsZS5yaWdodC5weF09XCJwYWRkaW5nXCIgXG4gICAgW2hpZGRlbl09XCIhcmVzaXphYmxlICYmICEoZGFzaGJvYXJkU2VydmljZS5zdGFja2VkJCB8IGFzeW5jKVwiPlxuPC9kaXY+XG5cbjxkaXYgdXhEcmFnICNoYW5kbGVSaWdodCBjbGFzcz1cInJlc2l6ZXItaGFuZGxlIGhhbmRsZS1yaWdodFwiIFxuICAgIChkcmFnc3RhcnQpPVwiZHJhZ3N0YXJ0KGhhbmRsZVJpZ2h0LCAkZXZlbnQsIDIpXCJcbiAgICAoZHJhZyk9XCJkcmFnKGhhbmRsZVJpZ2h0LCAkZXZlbnQsIDIpXCJcbiAgICAoZHJhZ2VuZCk9XCJkcmFnZW5kKClcIlxuICAgIFtzdHlsZS5yaWdodC5weF09XCJwYWRkaW5nXCIgXG4gICAgW2hpZGRlbl09XCIhcmVzaXphYmxlIHx8IChkYXNoYm9hcmRTZXJ2aWNlLnN0YWNrZWQkIHwgYXN5bmMpXCI+XG48L2Rpdj5cblxuPGRpdiB1eERyYWcgI2hhbmRsZUJvdHRvbVJpZ2h0IGNsYXNzPVwicmVzaXplci1oYW5kbGUgaGFuZGxlLWJvdHRvbS1yaWdodFwiIFxuICAgIChkcmFnc3RhcnQpPVwiZHJhZ3N0YXJ0KGhhbmRsZUJvdHRvbVJpZ2h0LCAkZXZlbnQsIDMpXCJcbiAgICAoZHJhZyk9XCJkcmFnKGhhbmRsZUJvdHRvbVJpZ2h0LCAkZXZlbnQsIDMpXCJcbiAgICAoZHJhZ2VuZCk9XCJkcmFnZW5kKClcIlxuICAgIFtzdHlsZS5ib3R0b20ucHhdPVwicGFkZGluZ1wiIFxuICAgIFtzdHlsZS5yaWdodC5weF09XCJwYWRkaW5nXCIgXG4gICAgW2hpZGRlbl09XCIhcmVzaXphYmxlICYmICEoZGFzaGJvYXJkU2VydmljZS5zdGFja2VkJCB8IGFzeW5jKVwiPlxuPC9kaXY+XG5cbjxkaXYgdXhEcmFnICNoYW5kbGVCb3R0b20gY2xhc3M9XCJyZXNpemVyLWhhbmRsZSBoYW5kbGUtYm90dG9tXCIgXG4gICAgKGRyYWdzdGFydCk9XCJkcmFnc3RhcnQoaGFuZGxlQm90dG9tLCAkZXZlbnQsIDQpXCJcbiAgICAoZHJhZyk9XCJkcmFnKGhhbmRsZUJvdHRvbSwgJGV2ZW50LCA0KVwiXG4gICAgKGRyYWdlbmQpPVwiZHJhZ2VuZCgpXCJcbiAgICBbc3R5bGUuYm90dG9tLnB4XT1cInBhZGRpbmdcIiBcbiAgICBbaGlkZGVuXT1cIiFyZXNpemFibGVcIj5cbjwvZGl2PlxuXG48ZGl2IHV4RHJhZyAjaGFuZGxlQm90dG9tTGVmdCBjbGFzcz1cInJlc2l6ZXItaGFuZGxlIGhhbmRsZS1ib3R0b20tbGVmdFwiIFxuICAgIChkcmFnc3RhcnQpPVwiZHJhZ3N0YXJ0KGhhbmRsZUJvdHRvbUxlZnQsICRldmVudCwgNSlcIlxuICAgIChkcmFnKT1cImRyYWcoaGFuZGxlQm90dG9tTGVmdCwgJGV2ZW50LCA1KVwiXG4gICAgKGRyYWdlbmQpPVwiZHJhZ2VuZCgpXCJcbiAgICBbc3R5bGUuYm90dG9tLnB4XT1cInBhZGRpbmdcIiBcbiAgICBbc3R5bGUubGVmdC5weF09XCJwYWRkaW5nXCIgXG4gICAgW2hpZGRlbl09XCIhcmVzaXphYmxlICYmICEoZGFzaGJvYXJkU2VydmljZS5zdGFja2VkJCB8IGFzeW5jKVwiPlxuPC9kaXY+XG5cbjxkaXYgdXhEcmFnICNoYW5kbGVMZWZ0IGNsYXNzPVwicmVzaXplci1oYW5kbGUgaGFuZGxlLWxlZnRcIiBcbiAgICAoZHJhZ3N0YXJ0KT1cImRyYWdzdGFydChoYW5kbGVMZWZ0LCAkZXZlbnQsIDYpXCJcbiAgICAoZHJhZyk9XCJkcmFnKGhhbmRsZUxlZnQsICRldmVudCwgNilcIlxuICAgIChkcmFnZW5kKT1cImRyYWdlbmQoKVwiXG4gICAgW3N0eWxlLmxlZnQucHhdPVwicGFkZGluZ1wiIFxuICAgIFtoaWRkZW5dPVwiIXJlc2l6YWJsZSB8fCAoZGFzaGJvYXJkU2VydmljZS5zdGFja2VkJCB8IGFzeW5jKVwiPlxuPC9kaXY+XG5cbjxkaXYgdXhEcmFnICNoYW5kbGVUb3BMZWZ0IGNsYXNzPVwicmVzaXplci1oYW5kbGUgaGFuZGxlLXRvcC1sZWZ0XCIgXG4gICAgKGRyYWdzdGFydCk9XCJkcmFnc3RhcnQoaGFuZGxlVG9wTGVmdCwgJGV2ZW50LCA3KVwiXG4gICAgKGRyYWcpPVwiZHJhZyhoYW5kbGVUb3BMZWZ0LCAkZXZlbnQsIDcpXCJcbiAgICAoZHJhZ2VuZCk9XCJkcmFnZW5kKClcIlxuICAgIFtzdHlsZS50b3AucHhdPVwicGFkZGluZ1wiIFxuICAgIFtzdHlsZS5sZWZ0LnB4XT1cInBhZGRpbmdcIiBcbiAgICBbaGlkZGVuXT1cIiFyZXNpemFibGUgJiYgIShkYXNoYm9hcmRTZXJ2aWNlLnN0YWNrZWQkIHwgYXN5bmMpXCI+XG48L2Rpdj5gXG59KVxuZXhwb3J0IGNsYXNzIERhc2hib2FyZFdpZGdldENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgQWZ0ZXJWaWV3SW5pdCwgT25EZXN0cm95IHtcblxuICAgIEBJbnB1dCgpIGlkOiBzdHJpbmc7XG4gICAgQElucHV0KCkgY29sOiBudW1iZXI7XG4gICAgQElucHV0KCkgcm93OiBudW1iZXI7XG4gICAgQElucHV0KCkgY29sU3BhbjogbnVtYmVyID0gMTtcbiAgICBASW5wdXQoKSByb3dTcGFuOiBudW1iZXIgPSAxO1xuICAgIEBJbnB1dCgpIHJlc2l6YWJsZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS5sZWZ0LnB4JykgeDogbnVtYmVyID0gMDtcbiAgICBASG9zdEJpbmRpbmcoJ3N0eWxlLnRvcC5weCcpIHk6IG51bWJlciA9IDA7XG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS53aWR0aC5weCcpIHdpZHRoOiBudW1iZXIgPSAxMDA7XG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS5oZWlnaHQucHgnKSBoZWlnaHQ6IG51bWJlciA9IDEwMDtcbiAgICBASG9zdEJpbmRpbmcoJ3N0eWxlLnBhZGRpbmcucHgnKSBwYWRkaW5nOiBudW1iZXIgPSAwO1xuICAgIEBIb3N0QmluZGluZygnc3R5bGUuei1pbmRleCcpIHpJbmRleDogbnVtYmVyID0gMDtcblxuICAgIHByaXZhdGUgX2NvbHVtbjogU3RhY2thYmxlVmFsdWUgPSB7IHJlZ3VsYXI6IHVuZGVmaW5lZCwgc3RhY2tlZDogdW5kZWZpbmVkIH07XG4gICAgcHJpdmF0ZSBfcm93OiBTdGFja2FibGVWYWx1ZSA9IHsgcmVndWxhcjogdW5kZWZpbmVkLCBzdGFja2VkOiB1bmRlZmluZWQgfTtcbiAgICBwcml2YXRlIF9jb2x1bW5TcGFuOiBTdGFja2FibGVWYWx1ZSA9IHsgcmVndWxhcjogMSwgc3RhY2tlZDogMSB9O1xuICAgIHByaXZhdGUgX3Jvd1NwYW46IFN0YWNrYWJsZVZhbHVlID0geyByZWd1bGFyOiAxLCBzdGFja2VkOiAxIH07XG4gICAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZGFzaGJvYXJkU2VydmljZTogRGFzaGJvYXJkU2VydmljZSkge1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24gPSBkYXNoYm9hcmRTZXJ2aWNlLm9wdGlvbnMkLnN1YnNjcmliZSgoKSA9PiB0aGlzLnVwZGF0ZSgpKTtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpOiB2b2lkIHtcblxuICAgICAgICB0aGlzLl9jb2x1bW5TcGFuLnJlZ3VsYXIgPSB0aGlzLmNvbFNwYW47XG4gICAgICAgIHRoaXMuX3Jvd1NwYW4ucmVndWxhciA9IHRoaXMucm93U3BhbjtcblxuICAgICAgICBpZiAoIXRoaXMuaWQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignRGFzaGJvYXJkIFdpZGdldCBpcyBtaXNzaW5nIGFuIElELicpO1xuXG4gICAgICAgICAgICAvLyBzZXQgcmFuZG9tIGlkIC0ga2VlcHMgdGhpbmdzIHdvcmtpbmcgYnV0IHByZXZlbnRzIGV4cG9ydGluZyBvZiBwb3NpdGlvbnNcbiAgICAgICAgICAgIHRoaXMuaWQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMDApLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgICAgIC8vIGFkZCB0aGUgd2lkZ2V0IHRvIHRoZSBkYXNoYm9hcmRcbiAgICAgICAgdGhpcy5kYXNoYm9hcmRTZXJ2aWNlLmFkZFdpZGdldCh0aGlzKTtcblxuICAgICAgICAvLyBhcHBseSB0aGUgY3VycmVudCBvcHRpb25zXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSWYgY29tcG9uZW50IGlzIHJlbW92ZWQsIHRoZW4gdW5yZWdpc3RlciBpdCBmcm9tIHRoZSBzZXJ2aWNlXG4gICAgICovXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLmRhc2hib2FyZFNlcnZpY2UucmVtb3ZlV2lkZ2V0KHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBjdXJyZW50IGRhc2hib2FyZCBvcHRpb25zXG4gICAgICovXG4gICAgdXBkYXRlKCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGdldCB0aGUgY3VycmVudCBvcHRpb25zIGF0IHRoZSB0aW1lIFxuICAgICAgICBjb25zdCB7IHBhZGRpbmcsIGNvbHVtbnMgfSA9IHRoaXMuZGFzaGJvYXJkU2VydmljZS5vcHRpb25zO1xuXG4gICAgICAgIHRoaXMucGFkZGluZyA9IHBhZGRpbmc7XG4gICAgICAgIHRoaXMuX2NvbHVtblNwYW4uc3RhY2tlZCA9IGNvbHVtbnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBhY3R1YWwgcG9zaXRpb24gYW5kIHNpemUgdmFsdWVzXG4gICAgICovXG4gICAgcmVuZGVyKCk6IHZvaWQge1xuICAgICAgICB0aGlzLnggPSB0aGlzLmdldENvbHVtbigpICogdGhpcy5kYXNoYm9hcmRTZXJ2aWNlLmdldENvbHVtbldpZHRoKCk7XG4gICAgICAgIHRoaXMueSA9IHRoaXMuZ2V0Um93KCkgKiB0aGlzLmRhc2hib2FyZFNlcnZpY2UuZ2V0Um93SGVpZ2h0KCk7XG4gICAgICAgIHRoaXMud2lkdGggPSB0aGlzLmdldENvbHVtblNwYW4oKSAqIHRoaXMuZGFzaGJvYXJkU2VydmljZS5nZXRDb2x1bW5XaWR0aCgpO1xuICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMuZ2V0Um93U3BhbigpICogdGhpcy5kYXNoYm9hcmRTZXJ2aWNlLmdldFJvd0hlaWdodCgpO1xuICAgIH1cblxuICAgIGdldENvbHVtbigpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTdGFja2FibGVWYWx1ZSh0aGlzLl9jb2x1bW4pO1xuICAgIH1cblxuICAgIGdldFJvdygpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTdGFja2FibGVWYWx1ZSh0aGlzLl9yb3cpO1xuICAgIH1cblxuICAgIHNldENvbHVtbihjb2x1bW46IG51bWJlciwgcmVuZGVyOiBib29sZWFuID0gdHJ1ZSk6IHZvaWQge1xuICAgICAgICB0aGlzLnNldFN0YWNrYWJsZVZhbHVlKHRoaXMuX2NvbHVtbiwgY29sdW1uKTtcblxuICAgICAgICBpZiAocmVuZGVyKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0Um93KHJvdzogbnVtYmVyLCByZW5kZXI6IGJvb2xlYW4gPSB0cnVlKTogdm9pZCB7XG4gICAgICAgIHRoaXMuc2V0U3RhY2thYmxlVmFsdWUodGhpcy5fcm93LCByb3cpO1xuXG4gICAgICAgIGlmIChyZW5kZXIpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRDb2x1bW5TcGFuKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFN0YWNrYWJsZVZhbHVlKHRoaXMuX2NvbHVtblNwYW4pO1xuICAgIH1cblxuICAgIGdldFJvd1NwYW4oKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RhY2thYmxlVmFsdWUodGhpcy5fcm93U3Bhbik7XG4gICAgfVxuXG4gICAgc2V0Q29sdW1uU3Bhbihjb2x1bW5TcGFuOiBudW1iZXIsIHJlbmRlcjogYm9vbGVhbiA9IHRydWUpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zZXRTdGFja2FibGVWYWx1ZSh0aGlzLl9jb2x1bW5TcGFuLCBjb2x1bW5TcGFuKTtcblxuICAgICAgICBpZiAocmVuZGVyKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0Um93U3Bhbihyb3dTcGFuOiBudW1iZXIsIHJlbmRlcjogYm9vbGVhbiA9IHRydWUpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zZXRTdGFja2FibGVWYWx1ZSh0aGlzLl9yb3dTcGFuLCByb3dTcGFuKTtcblxuICAgICAgICBpZiAocmVuZGVyKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYnJpbmdUb0Zyb250KCk6IHZvaWQge1xuICAgICAgICB0aGlzLnpJbmRleCA9IDE7XG4gICAgfVxuXG4gICAgc2VuZFRvQmFjaygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy56SW5kZXggPSAwO1xuICAgIH1cblxuICAgIHNldEJvdW5kcyh4OiBudW1iZXIsIHk6IG51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB9XG5cbiAgICBkcmFnc3RhcnQoaGFuZGxlOiBIVE1MRWxlbWVudCwgZXZlbnQ6IE1vdXNlRXZlbnQsIGRpcmVjdGlvbjogQWN0aW9uRGlyZWN0aW9uKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZGFzaGJvYXJkU2VydmljZS5vblJlc2l6ZVN0YXJ0KHsgd2lkZ2V0OiB0aGlzLCBkaXJlY3Rpb246IGRpcmVjdGlvbiwgZXZlbnQ6IGV2ZW50LCBoYW5kbGU6IGhhbmRsZSB9KTtcbiAgICB9XG5cbiAgICBkcmFnKGhhbmRsZTogSFRNTEVsZW1lbnQsIGV2ZW50OiBNb3VzZUV2ZW50LCBkaXJlY3Rpb246IEFjdGlvbkRpcmVjdGlvbik6IHZvaWQge1xuICAgICAgICB0aGlzLmRhc2hib2FyZFNlcnZpY2Uub25SZXNpemVEcmFnKHsgd2lkZ2V0OiB0aGlzLCBkaXJlY3Rpb246IGRpcmVjdGlvbiwgZXZlbnQ6IGV2ZW50LCBoYW5kbGU6IGhhbmRsZSB9KTtcbiAgICB9XG5cbiAgICBkcmFnZW5kKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmRhc2hib2FyZFNlcnZpY2Uub25SZXNpemVFbmQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbGxvd3MgYXV0b21hdGljIHNldHRpbmcgb2Ygc3RhY2thYmxlIHZhbHVlXG4gICAgICogQHBhcmFtIHByb3BlcnR5IFRoZSBjdXJyZW50IFN0YWNrYWJsZVZhbHVlIG9iamVjdFxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0IGluIHRoZSBhcHByb3ByaWF0ZSBmaWVsZFxuICAgICAqL1xuICAgIHByaXZhdGUgc2V0U3RhY2thYmxlVmFsdWUocHJvcGVydHk6IFN0YWNrYWJsZVZhbHVlLCB2YWx1ZTogbnVtYmVyKTogdm9pZCB7XG5cbiAgICAgICAgaWYgKHRoaXMuZGFzaGJvYXJkU2VydmljZS5zdGFja2VkKSB7XG4gICAgICAgICAgICBwcm9wZXJ0eS5zdGFja2VkID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9wZXJ0eS5yZWd1bGFyID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGFwcHJvcHJpYXRlIHZhbHVlIGZyb20gYSBzdGFja2FibGUgdmFsdWVcbiAgICAgKiBAcGFyYW0gcHJvcGVydHkgVGhlIFN0YWNrYWJsZSB2YWx1ZSBvYmplY3RcbiAgICAgKi9cbiAgICBwcml2YXRlIGdldFN0YWNrYWJsZVZhbHVlKHByb3BlcnR5OiBTdGFja2FibGVWYWx1ZSk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhc2hib2FyZFNlcnZpY2Uuc3RhY2tlZCA/IHByb3BlcnR5LnN0YWNrZWQgOiBwcm9wZXJ0eS5yZWd1bGFyO1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBTdGFja2FibGVWYWx1ZSB7XG4gICAgcmVndWxhcjogbnVtYmVyO1xuICAgIHN0YWNrZWQ6IG51bWJlcjtcbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE5nWm9uZSwgT25EZXN0cm95LCBPdXRwdXQsIFJlbmRlcmVyMiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgZnJvbUV2ZW50IH0gZnJvbSAncnhqcy9vYnNlcnZhYmxlL2Zyb21FdmVudCc7XG5pbXBvcnQgeyB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbdXhEcmFnXSdcbn0pXG5leHBvcnQgY2xhc3MgRHJhZ0RpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG5cbiAgICAvKiogRGV0ZW1pbmUgaWYgd2Ugc2hvdWxkIHNob3cgYSBjbG9uZSB3aGVuIGRyYWdnaW5nICovXG4gICAgQElucHV0KCkgY2xvbmU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKiBFbWl0IGFuIGV2ZW50IHdoZW4gZHJhZ2dpbmcgc3RhcnRzICovXG4gICAgQE91dHB1dCgpIGRyYWdzdGFydCA9IG5ldyBFdmVudEVtaXR0ZXI8TW91c2VFdmVudD4oKTtcblxuICAgIC8qKiBFbWl0IGFuIGV2ZW50IHdoZW4gdGhlIG1vdXNlIG1vdmVzIHdoaWxlIGRyYWdnaW5nICovXG4gICAgQE91dHB1dCgpIGRyYWcgPSBuZXcgRXZlbnRFbWl0dGVyPE1vdXNlRXZlbnQ+KCk7XG5cbiAgICAvKiogRW1pdCBhbiBldmVudCB3aGVuIHRoZSBkcmFnZ2luZyBmaW5pc2hlcyAqL1xuICAgIEBPdXRwdXQoKSBkcmFnZW5kID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuXG4gICAgLyoqIFN0b3JlIHRoZSBlbGVtZW50IHdlIGhhdmUgY2xvbmVkICovXG4gICAgcHJpdmF0ZSBfY2xvbmU6IEVsZW1lbnQ7XG5cbiAgICAvKiogU3RvcmUgdGhlIG1vdXNlIG9mZnNldCBmb3IgdGhlIGNsb25lZCBlbGVtZW50IHBvc2l0aW9uICovXG4gICAgcHJpdmF0ZSBfb2Zmc2V0OiB7IHg6IG51bWJlciwgeTogbnVtYmVyIH07XG5cbiAgICAvKiogQ3JlYXRlIGFuIG9ic2VydmFibGUgZnJvbSB0aGUgbW91c2UgZG93biBldmVudCAqL1xuICAgIHByaXZhdGUgX21vdXNlZG93biQgPSBmcm9tRXZlbnQ8TW91c2VFdmVudD4odGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnbW91c2Vkb3duJyk7XG5cbiAgICAvKiogQ3JlYXRlIGFuIG9ic2VydmFibGUgZnJvbSB0aGUgbW91c2UgbW92ZSBldmVudCAqL1xuICAgIHByaXZhdGUgX21vdXNlbW92ZSQgPSBmcm9tRXZlbnQ8TW91c2VFdmVudD4oZG9jdW1lbnQsICdtb3VzZW1vdmUnKTtcblxuICAgIC8qKiBDcmVhdGUgYW4gb2JzZXJ2YWJsZSBmcm9tIHRoZSBtb3VzZSB1cCBldmVudCAqL1xuICAgIHByaXZhdGUgX21vdXNldXAkID0gZnJvbUV2ZW50PE1vdXNlRXZlbnQ+KGRvY3VtZW50LCAnbW91c2V1cCcpO1xuXG4gICAgLyoqIFVzZSBhbiBvYnNlcnZhYmxlIHRvIHVuc3Vic2NyaWJlIGZyb20gYWxsIHN1YnNjcmlwdGlvbnMgKi9cbiAgICBwcm90ZWN0ZWQgX29uRGVzdHJveSA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmLCBwcml2YXRlIF9uZ1pvbmU6IE5nWm9uZSwgcHJpdmF0ZSBfcmVuZGVyZXI6IFJlbmRlcmVyMikge1xuICAgICAgICB0aGlzLl9tb3VzZWRvd24kLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZSh0aGlzLmRyYWdTdGFydC5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICAvKiogRW1pdCBldmVudHMgYW5kIGNyZWF0ZSBjbG9uZSB3aGVuIGRyYWcgc3RhcnRzICovXG4gICAgZHJhZ1N0YXJ0KGV2ZW50OiBNb3VzZUV2ZW50KTogdm9pZCB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgaWYgKHRoaXMuY2xvbmUpIHtcbiAgICAgICAgICAgIC8vIGNsb25lIHRoZSBub2RlXG4gICAgICAgICAgICB0aGlzLmNsb25lTm9kZShldmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhcHBseSBhIGNsYXNzIHRvIHRoZSBlbGVtZW50IGJlaW5nIGRyYWdnZWRcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAndXgtZHJhZy1kcmFnZ2luZycpO1xuXG4gICAgICAgIC8vIGVtaXQgdGhlIGRyYWcgc3RhcnQgZXZlbnRcbiAgICAgICAgdGhpcy5fbmdab25lLnJ1bigoKSA9PiB0aGlzLmRyYWdzdGFydC5lbWl0KGV2ZW50KSk7XG5cbiAgICAgICAgdGhpcy5fbW91c2Vtb3ZlJC5waXBlKHRha2VVbnRpbCh0aGlzLl9tb3VzZXVwJCksIHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSh0aGlzLmRyYWdNb3ZlLmJpbmQodGhpcyksIG51bGwsIHRoaXMuZHJhZ0VuZC5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICAvKiogRW1pdCBldmVudCBhbmQgdXBkYXRlIGNsb25lIHBvc2l0aW9uIHdoZW4gZHJhZ2dpbmcgbW92ZXMgKi9cbiAgICBkcmFnTW92ZShldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGlmICh0aGlzLl9jbG9uZSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVOb2RlUG9zaXRpb24oZXZlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZW1pdCB0aGUgZHJhZyBzdGFydCBldmVudFxuICAgICAgICB0aGlzLl9uZ1pvbmUucnVuKCgpID0+IHRoaXMuZHJhZy5lbWl0KGV2ZW50KSk7XG4gICAgfVxuXG4gICAgLyoqIEVtaXQgZXZlbnQgYW5kIGRlc3Ryb3kgY2xvbmUgd2hlbiBkcmFnZ2luZyBlbmRzICovXG4gICAgZHJhZ0VuZCgpOiB2b2lkIHtcbiAgICAgICAgLy8gaWYgdGhlcmUgd2FzIGEgY2xvbmUsIHJlbW92ZSBpdFxuICAgICAgICBpZiAodGhpcy5fY2xvbmUpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnJlbW92ZUNoaWxkKGRvY3VtZW50LmJvZHksIHRoaXMuX2Nsb25lKTtcbiAgICAgICAgICAgIHRoaXMuX2Nsb25lID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbW92ZSB0aGUgZHJhZ2dpbmcgY2xhc3NcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIucmVtb3ZlQ2xhc3ModGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAndXgtZHJhZy1kcmFnZ2luZycpO1xuXG4gICAgICAgIHRoaXMuX25nWm9uZS5ydW4oKCkgPT4gdGhpcy5kcmFnZW5kLmVtaXQoKSk7XG4gICAgfVxuXG4gICAgLyoqIENyZWF0ZSBhbiBleGFjdCBjbG9uZSBvZiBhbiBlbGVtZW50ICovXG4gICAgY2xvbmVOb2RlKGV2ZW50OiBNb3VzZUV2ZW50KTogdm9pZCB7XG5cbiAgICAgICAgLy8gZHVwbGljYXRlIHRoZSBub2RlXG4gICAgICAgIHRoaXMuX2Nsb25lID0gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmNsb25lTm9kZSh0cnVlKTtcblxuICAgICAgICAvLyBzdG9yZSB0aGUgcG9zaXRpb24gd2l0aGluIHRoZSBkcmFnZ2FibGUgZWxlbWVudFxuICAgICAgICBjb25zdCB7IHRvcCwgbGVmdCB9ID0gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB0aGlzLl9vZmZzZXQgPSB7IHg6IGV2ZW50LmNsaWVudFggLSBsZWZ0LCB5OiBldmVudC5jbGllbnRZIC0gdG9wIH07XG5cbiAgICAgICAgLy8gaW5saW5lIGFsbCBzdHlsZXMgc28gaXQgbG9va3MgaWRlbnRpY2FsIHJlZ2FyZGxlc3Mgb2YgaXRzIHBvc2l0aW9uIGluIHRoZSBET01cbiAgICAgICAgdGhpcy5pbmxpbmVTdHlsZXModGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCB0aGlzLl9jbG9uZSk7XG5cbiAgICAgICAgLy8gZW5zdXJlIHdlIGNhbiBlYXNpbHkgcG9zaXRpb24gdGhlIG5vZGUgYW4gaXQgaXMgYWJvdmUgYWxsIG90aGVyIGVsZW1lbnRzXG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEF0dHJpYnV0ZSh0aGlzLl9jbG9uZSwgJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0U3R5bGUodGhpcy5fY2xvbmUsICdwb3NpdGlvbicsICdhYnNvbHV0ZScpO1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRTdHlsZSh0aGlzLl9jbG9uZSwgJ3otaW5kZXgnLCAnOTk5OTknKTtcblxuICAgICAgICAvLyBhcHBseSBhIGNsYXNzIHRvIGFsbG93IGN1c3RvbSBzdHlsaW5nXG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLmFkZENsYXNzKHRoaXMuX2Nsb25lLCAndXgtZHJhZy1kcmFnZ2luZy1jbG9uZScpO1xuXG4gICAgICAgIC8vIGluc2VydCB0aGUgY2xvbmVkIGVsZW1lbnRcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuYm9keSwgdGhpcy5fY2xvbmUpO1xuXG4gICAgICAgIC8vIHNldCB0aGUgY2xvbmVkIGVsZW1lbnQgaW5pdGlhbCBwb3NpdGlvblxuICAgICAgICB0aGlzLnVwZGF0ZU5vZGVQb3NpdGlvbihldmVudCk7XG4gICAgfVxuXG4gICAgLyoqIFBvc2l0aW9uIHRoZSBjbG9uZSByZWxhdGl2ZSB0byB0aGUgbW91c2UgKi9cbiAgICB1cGRhdGVOb2RlUG9zaXRpb24oZXZlbnQ6IE1vdXNlRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0U3R5bGUodGhpcy5fY2xvbmUsICdsZWZ0JywgKGV2ZW50LnBhZ2VYIC0gdGhpcy5fb2Zmc2V0LngpICsgJ3B4Jyk7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldFN0eWxlKHRoaXMuX2Nsb25lLCAndG9wJywgKGV2ZW50LnBhZ2VZIC0gdGhpcy5fb2Zmc2V0LnkpICsgJ3B4Jyk7XG4gICAgfVxuXG4gICAgLyoqIElubGluZSBhbGwgc3R5bGVzIHRvIGVuc3VyZSBzdHlsaW5nIGlzIGNvbnNpc3RlbnQgcmVnYXJkbGVzcyBvZiBpdHMgcG9zaXRpb24gaW4gdGhlIGRvbSAqL1xuICAgIGlubGluZVN0eWxlcyhzb3VyY2U6IEVsZW1lbnQsIHRhcmdldDogRWxlbWVudCk6IHZvaWQge1xuICAgICAgICAvLyBnZXQgYWxsIHRoZSBjb21wdXRlZCBzdHlsZXMgZnJvbSB0aGUgc291cmNlIGVsZW1lbnRcbiAgICAgICAgY29uc3Qgc3R5bGVzID0gZ2V0Q29tcHV0ZWRTdHlsZShzb3VyY2UpO1xuXG4gICAgICAgIC8vIGlubGluZSBldmVyeSBzcGVjaWZpZWQgc3R5bGVcbiAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgc3R5bGVzLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IHN0eWxlID0gc3R5bGVzLml0ZW0oaWR4KTtcblxuICAgICAgICAgICAgaWYgKHN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRTdHlsZSh0YXJnZXQsIHN0eWxlc1tpZHhdLCBzdHlsZXNbc3R5bGVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVuc3VyZSB3ZSBkb250IGNhcHR1cmUgYW55IG1vdmUgZXZlbnRzXG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldFN0eWxlKHRhcmdldCwgJ3BvaW50ZXItZXZlbnRzJywgJ25vbmUnKTtcblxuICAgICAgICAvLyBkbyB0aGUgc2FtZSBmb3IgYWxsIHRoZSBjaGlsZCBlbGVtZW50c1xuICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBzb3VyY2UuY2hpbGRyZW4ubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgdGhpcy5pbmxpbmVTdHlsZXMoc291cmNlLmNoaWxkcmVuW2lkeF0sIHRhcmdldC5jaGlsZHJlbltpZHhdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBVbnN1YnNjcmliZSBmcm9tIGFsbCBzdWJzY3JpcHRpb25zICovXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX29uRGVzdHJveS5uZXh0KCk7XG4gICAgICAgIHRoaXMuX29uRGVzdHJveS5jb21wbGV0ZSgpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIE5nWm9uZSwgUmVuZGVyZXIyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBEcmFnRGlyZWN0aXZlIH0gZnJvbSAnLi4vLi4vLi4vZGlyZWN0aXZlcy9kcmFnL2RyYWcuZGlyZWN0aXZlJztcbmltcG9ydCB7IEFjdGlvbkRpcmVjdGlvbiwgRGFzaGJvYXJkU2VydmljZSB9IGZyb20gJy4uL2Rhc2hib2FyZC5zZXJ2aWNlJztcbmltcG9ydCB7IERhc2hib2FyZFdpZGdldENvbXBvbmVudCB9IGZyb20gJy4uL3dpZGdldC9kYXNoYm9hcmQtd2lkZ2V0LmNvbXBvbmVudCc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3V4RGFzaGJvYXJkV2lkZ2V0RHJhZ0hhbmRsZV0sIFt1eC1kYXNoYm9hcmQtd2lkZ2V0LWRyYWctaGFuZGxlXSdcbn0pXG5leHBvcnQgY2xhc3MgRGFzaGJvYXJkRHJhZ0hhbmRsZURpcmVjdGl2ZSBleHRlbmRzIERyYWdEaXJlY3RpdmUge1xuXG4gICAgY29uc3RydWN0b3Iod2lkZ2V0OiBEYXNoYm9hcmRXaWRnZXRDb21wb25lbnQsIGRhc2hib2FyZFNlcnZpY2U6IERhc2hib2FyZFNlcnZpY2UsIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIG5nWm9uZTogTmdab25lLCByZW5kZXJlcjogUmVuZGVyZXIyKSB7XG4gICAgICAgIHN1cGVyKGVsZW1lbnRSZWYsIG5nWm9uZSwgcmVuZGVyZXIpO1xuXG4gICAgICAgIHRoaXMuZHJhZ3N0YXJ0LnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKChldmVudDogTW91c2VFdmVudCkgPT4gZGFzaGJvYXJkU2VydmljZS5vbkRyYWdTdGFydCh7IHdpZGdldDogd2lkZ2V0LCBkaXJlY3Rpb246IEFjdGlvbkRpcmVjdGlvbi5Nb3ZlLCBldmVudDogZXZlbnQgfSkpO1xuXG4gICAgICAgIHRoaXMuZHJhZy5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoZXZlbnQ6IE1vdXNlRXZlbnQpID0+IGRhc2hib2FyZFNlcnZpY2Uub25EcmFnKHsgd2lkZ2V0OiB3aWRnZXQsIGRpcmVjdGlvbjogQWN0aW9uRGlyZWN0aW9uLk1vdmUsIGV2ZW50OiBldmVudCB9KSk7XG5cbiAgICAgICAgdGhpcy5kcmFnZW5kLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IGRhc2hib2FyZFNlcnZpY2Uub25EcmFnRW5kKCkpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBEcmFnRGlyZWN0aXZlIH0gZnJvbSAnLi9kcmFnLmRpcmVjdGl2ZSc7XG5cbkBOZ01vZHVsZSh7XG4gICAgZXhwb3J0czogW0RyYWdEaXJlY3RpdmVdLFxuICAgIGRlY2xhcmF0aW9uczogW0RyYWdEaXJlY3RpdmVdXG59KVxuZXhwb3J0IGNsYXNzIERyYWdNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IERhc2hib2FyZENvbXBvbmVudCB9IGZyb20gJy4vZGFzaGJvYXJkLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBEYXNoYm9hcmRXaWRnZXRDb21wb25lbnQgfSBmcm9tICcuL3dpZGdldC9kYXNoYm9hcmQtd2lkZ2V0LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBEYXNoYm9hcmRTZXJ2aWNlIH0gZnJvbSAnLi9kYXNoYm9hcmQuc2VydmljZSc7XG5pbXBvcnQgeyBEYXNoYm9hcmREcmFnSGFuZGxlRGlyZWN0aXZlIH0gZnJvbSAnLi9kcmFnLWhhbmRsZS9kcmFnLWhhbmRsZS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgUmVzaXplTW9kdWxlIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9yZXNpemUvaW5kZXgnO1xuaW1wb3J0IHsgRHJhZ01vZHVsZSB9IGZyb20gJy4uLy4uL2RpcmVjdGl2ZXMvZHJhZy9pbmRleCc7XG5cbmNvbnN0IERFQ0xBUkFUSU9OUzogYW55W10gPSBbXG4gICAgRGFzaGJvYXJkQ29tcG9uZW50LFxuICAgIERhc2hib2FyZFdpZGdldENvbXBvbmVudCxcbiAgICBEYXNoYm9hcmREcmFnSGFuZGxlRGlyZWN0aXZlXG5dO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBSZXNpemVNb2R1bGUsXG4gICAgICAgIERyYWdNb2R1bGVcbiAgICBdLFxuICAgIGV4cG9ydHM6IERFQ0xBUkFUSU9OUyxcbiAgICBkZWNsYXJhdGlvbnM6IERFQ0xBUkFUSU9OUyxcbiAgICBwcm92aWRlcnM6IFtEYXNoYm9hcmRTZXJ2aWNlXSxcbn0pXG5leHBvcnQgY2xhc3MgRGFzaGJvYXJkTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT3V0cHV0LCBWaWV3RW5jYXBzdWxhdGlvbiwgZm9yd2FyZFJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29udHJvbFZhbHVlQWNjZXNzb3IsIE5HX1ZBTFVFX0FDQ0VTU09SIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5leHBvcnQgY29uc3QgU1BJTl9CVVRUT05fVkFMVUVfQUNDRVNTT1I6IGFueSA9IHtcbiAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBTcGluQnV0dG9uQ29tcG9uZW50KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1zcGluLWJ1dHRvbicsXG4gICAgdGVtcGxhdGU6IGA8YnV0dG9uIGNsYXNzPVwic3Bpbi1idXR0b25cIlxuICAgICAgICAqbmdJZj1cInNwaW5uZXJzXCJcbiAgICAgICAgdGFiaW5kZXg9XCItMVwiXG4gICAgICAgIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAgICAgIFthdHRyLmFyaWEtbGFiZWxdPVwiaW5jcmVtZW50QXJpYUxhYmVsXCJcbiAgICAgICAgW2F0dHIuYXJpYS1kaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAgICAgIChjbGljayk9XCJ0cmlnZ2VySW5jcmVtZW50KClcIj5cblxuICA8c3BhbiBjbGFzcz1cImhwZS1pY29uIGhwZS11cFwiPjwvc3Bhbj5cbjwvYnV0dG9uPlxuXG48aW5wdXQgW3R5cGVdPVwidHlwZVwiXG4gICAgICAgcm9sZT1cInNwaW5idXR0b25cIlxuICAgICAgIFttaW5dPVwibWluXCJcbiAgICAgICBbbWF4XT1cIm1heFwiXG4gICAgICAgW3RhYmluZGV4XT1cIjBcIlxuICAgICAgIGNsYXNzPVwiZm9ybS1jb250cm9sXCJcbiAgICAgICBbcGxhY2Vob2xkZXJdPVwicGxhY2Vob2xkZXJcIlxuICAgICAgIFtyZWFkT25seV09XCJyZWFkT25seVwiXG4gICAgICAgW2Rpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cImlucHV0QXJpYUxhYmVsXCJcbiAgICAgICBbYXR0ci5hcmlhLWRpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICBbYXR0ci5hcmlhLXZhbHVlbWluXT1cIm1pblwiXG4gICAgICAgW2F0dHIuYXJpYS12YWx1ZW5vd109XCJ2YWx1ZVwiXG4gICAgICAgW2F0dHIuYXJpYS12YWx1ZW1heF09XCJtYXhcIlxuICAgICAgIFthdHRyLmFyaWEtcmVhZG9ubHldPVwicmVhZE9ubHlcIlxuICAgICAgIFtuZ01vZGVsXT1cInZhbHVlXCJcbiAgICAgICAobmdNb2RlbENoYW5nZSk9XCJ2YWx1ZUNoYW5nZS5lbWl0KCRldmVudClcIlxuICAgICAgICh3aGVlbCk9XCJzY3JvbGwoJGV2ZW50KVwiXG4gICAgICAgKGtleWRvd24uYXJyb3d1cCk9XCJhcnJvd2tleXMgPyB0cmlnZ2VySW5jcmVtZW50KCkgOiBudWxsOyAkZXZlbnQucHJldmVudERlZmF1bHQoKVwiXG4gICAgICAgKGtleWRvd24uYXJyb3dkb3duKT1cImFycm93a2V5cyA/IHRyaWdnZXJEZWNyZW1lbnQoKSA6IG51bGw7ICRldmVudC5wcmV2ZW50RGVmYXVsdCgpXCI+XG5cbjxidXR0b24gY2xhc3M9XCJzcGluLWJ1dHRvblwiXG4gICAgICAgICpuZ0lmPVwic3Bpbm5lcnNcIlxuICAgICAgICB0YWJpbmRleD1cIi0xXCJcbiAgICAgICAgW2Rpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XCJkZWNyZW1lbnRBcmlhTGFiZWxcIlxuICAgICAgICBbYXR0ci5hcmlhLWRpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICAgKGNsaWNrKT1cInRyaWdnZXJEZWNyZW1lbnQoKVwiPlxuXG4gIDxzcGFuIGNsYXNzPVwiaHBlLWljb24gaHBlLWRvd25cIj48L3NwYW4+XG48L2J1dHRvbj5gLFxuICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgcHJvdmlkZXJzOiBbU1BJTl9CVVRUT05fVkFMVUVfQUNDRVNTT1JdXG59KVxuZXhwb3J0IGNsYXNzIFNwaW5CdXR0b25Db21wb25lbnQgaW1wbGVtZW50cyBDb250cm9sVmFsdWVBY2Nlc3NvciB7XG5cbiAgICBASW5wdXQoKSBzZXQgdmFsdWUodmFsdWU6IGFueSkge1xuICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2sodmFsdWUpO1xuICAgICAgICB0aGlzLm9uVG91Y2hlZENhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgZ2V0IHZhbHVlKCk6IGFueSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICB9XG5cbiAgICBASW5wdXQoKSB0eXBlOiBzdHJpbmcgPSAndGV4dCc7XG4gICAgQElucHV0KCkgbWluOiBudW1iZXI7XG4gICAgQElucHV0KCkgbWF4OiBudW1iZXI7XG4gICAgQElucHV0KCkgcGxhY2Vob2xkZXI6IHN0cmluZyA9ICcnO1xuICAgIEBJbnB1dCgpIGRpc2FibGVkOiBib29sZWFuID0gZmFsc2U7XG4gICAgQElucHV0KCkgc3Bpbm5lcnM6IGJvb2xlYW4gPSB0cnVlO1xuICAgIEBJbnB1dCgpIHJlYWRPbmx5OiBib29sZWFuID0gdHJ1ZTtcbiAgICBASW5wdXQoKSBzY3JvbGxpbmc6IGJvb2xlYW4gPSB0cnVlO1xuICAgIEBJbnB1dCgpIGFycm93a2V5czogYm9vbGVhbiA9IHRydWU7XG5cbiAgICBASW5wdXQoKSBpbmNyZW1lbnRBcmlhTGFiZWw6IHN0cmluZztcbiAgICBASW5wdXQoKSBpbnB1dEFyaWFMYWJlbDogc3RyaW5nO1xuICAgIEBJbnB1dCgpIGRlY3JlbWVudEFyaWFMYWJlbDogc3RyaW5nO1xuXG4gICAgQE91dHB1dCgpIHZhbHVlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgICBAT3V0cHV0KCkgaW5jcmVtZW50ID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuICAgIEBPdXRwdXQoKSBkZWNyZW1lbnQgPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG5cbiAgICBvblRvdWNoZWRDYWxsYmFjazogKCkgPT4gdm9pZCA9ICgpID0+IHsgfTtcbiAgICBvbkNoYW5nZUNhbGxiYWNrOiAoXzogYW55KSA9PiB2b2lkID0gKCkgPT4geyB9O1xuXG4gICAgcHJpdmF0ZSBfdmFsdWU6IGFueTtcblxuICAgIHNjcm9sbChldmVudDogV2hlZWxFdmVudCk6IHZvaWQge1xuXG4gICAgICAgIGlmICghdGhpcy5zY3JvbGxpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldmVudC5kZWx0YVkgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXJEZWNyZW1lbnQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlckluY3JlbWVudCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICB0cmlnZ2VySW5jcmVtZW50KCk6IHZvaWQge1xuICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5jcmVtZW50LmVtaXQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRyaWdnZXJEZWNyZW1lbnQoKTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5kZWNyZW1lbnQuZW1pdCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZTogYW55KTogdm9pZCB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICByZWdpc3Rlck9uQ2hhbmdlKGZuOiAoXzogYW55KSA9PiB2b2lkKTogdm9pZCB7XG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjayA9IGZuO1xuICAgIH1cblxuICAgIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiAoKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgICAgIHRoaXMub25Ub3VjaGVkQ2FsbGJhY2sgPSBmbjtcbiAgICB9XG5cbiAgICBzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQ6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGlzRGlzYWJsZWQ7XG4gICAgfVxuXG59IiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBGb3Jtc01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IFNwaW5CdXR0b25Db21wb25lbnQgfSBmcm9tICcuL3NwaW4tYnV0dG9uLmNvbXBvbmVudCc7XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlXG4gICAgXSxcbiAgICBleHBvcnRzOiBbU3BpbkJ1dHRvbkNvbXBvbmVudF0sXG4gICAgZGVjbGFyYXRpb25zOiBbU3BpbkJ1dHRvbkNvbXBvbmVudF1cbn0pXG5leHBvcnQgY2xhc3MgU3BpbkJ1dHRvbk1vZHVsZSB7IH0iLCJpbXBvcnQgeyBQaXBlLCBQaXBlVHJhbnNmb3JtIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBQaXBlKHtcbiAgbmFtZTogJ3RpbWVGb3JtYXQnXG59KVxuZXhwb3J0IGNsYXNzIFRpbWVGb3JtYXRQaXBlIGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSB7XG5cbiAgdHJhbnNmb3JtKHZhbHVlOiBudW1iZXIpOiBzdHJpbmcgfCBudW1iZXIge1xuICAgIHJldHVybiB2YWx1ZSA8IDEwID8gJzAnICsgdmFsdWUgOiB2YWx1ZTtcbiAgfVxuXG59IiwiaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT25EZXN0cm95LCBPdXRwdXQsIFZpZXdFbmNhcHN1bGF0aW9uLCBmb3J3YXJkUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb250cm9sVmFsdWVBY2Nlc3NvciwgTkdfVkFMVUVfQUNDRVNTT1IgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QgfSBmcm9tICdyeGpzL0JlaGF2aW9yU3ViamVjdCc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcy9PYnNlcnZhYmxlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IGRpc3RpbmN0VW50aWxDaGFuZ2VkLCBtYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmV4cG9ydCBjb25zdCBUSU1FX1BJQ0tFUl9WQUxVRV9BQ0NFU1NPUjogYW55ID0ge1xuICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFRpbWVQaWNrZXJDb21wb25lbnQpLFxuICAgIG11bHRpOiB0cnVlXG59O1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LXRpbWUtcGlja2VyJyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJ0aW1lLXBpY2tlclwiIGFyaWEtbGFiZWw9XCJUaW1lIHBpY2tlclwiPlxuXG4gICAgPGRpdiBjbGFzcz1cInRpbWUtcGlja2VyLWNvbHVtblwiIFtjbGFzcy5oYXMtZXJyb3JdPVwiISh2YWxpZCQgfCBhc3luYylcIiAqbmdJZj1cInNob3dIb3Vyc1wiPlxuXG4gICAgICAgIDx1eC1zcGluLWJ1dHRvblxuICAgICAgICAgICAgdHlwZT1cIm51bWJlclwiXG4gICAgICAgICAgICBjbGFzcz1cInRpbWUtc3Bpbm5lclwiXG4gICAgICAgICAgICBwbGFjZWhvbGRlcj1cIkhIXCJcbiAgICAgICAgICAgIFttaW5dPVwiMFwiXG4gICAgICAgICAgICBbbWF4XT1cInNob3dNZXJpZGlhbiA/IDEyIDogMjNcIlxuICAgICAgICAgICAgW3ZhbHVlXT1cImhvdXIkIHwgYXN5bmMgfCB0aW1lRm9ybWF0XCJcbiAgICAgICAgICAgICh2YWx1ZUNoYW5nZSk9XCJob3VyQ2hhbmdlKCRldmVudClcIlxuICAgICAgICAgICAgW3NwaW5uZXJzXT1cInNob3dTcGlubmVyc1wiXG4gICAgICAgICAgICBbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuICAgICAgICAgICAgW3JlYWRPbmx5XT1cInJlYWRPbmx5XCJcbiAgICAgICAgICAgIGlucHV0QXJpYUxhYmVsPVwiaG91clwiXG4gICAgICAgICAgICBpbmNyZW1lbnRBcmlhTGFiZWw9XCJJbmNyZW1lbnQgdGhlIGhvdXJcIlxuICAgICAgICAgICAgZGVjcmVtZW50QXJpYUxhYmVsPVwiRGVjcmVtZW50IHRoZSBob3VyXCJcbiAgICAgICAgICAgIChpbmNyZW1lbnQpPVwiaW5jcmVtZW50SG91cigpXCJcbiAgICAgICAgICAgIChkZWNyZW1lbnQpPVwiZGVjcmVtZW50SG91cigpXCI+XG4gICAgICAgIDwvdXgtc3Bpbi1idXR0b24+XG5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJ0aW1lLXBpY2tlci1zZXBhcmF0b3JcIiAqbmdJZj1cInNob3dNaW51dGVzXCI+OjwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cInRpbWUtcGlja2VyLWNvbHVtblwiIFtjbGFzcy5oYXMtZXJyb3JdPVwiISh2YWxpZCQgfCBhc3luYylcIiAqbmdJZj1cInNob3dNaW51dGVzXCI+XG5cbiAgICAgICAgPHV4LXNwaW4tYnV0dG9uXG4gICAgICAgICAgICB0eXBlPVwibnVtYmVyXCJcbiAgICAgICAgICAgIGNsYXNzPVwidGltZS1zcGlubmVyXCJcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiTU1cIlxuICAgICAgICAgICAgW21pbl09XCIwXCJcbiAgICAgICAgICAgIFttYXhdPVwiNTlcIlxuICAgICAgICAgICAgW3ZhbHVlXT1cIm1pbnV0ZSQgfCBhc3luYyB8IHRpbWVGb3JtYXRcIlxuICAgICAgICAgICAgKHZhbHVlQ2hhbmdlKT1cIm1pbnV0ZUNoYW5nZSgkZXZlbnQpXCJcbiAgICAgICAgICAgIFtzcGlubmVyc109XCJzaG93U3Bpbm5lcnNcIlxuICAgICAgICAgICAgW2Rpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICAgICAgIFtyZWFkT25seV09XCJyZWFkT25seVwiXG4gICAgICAgICAgICBpbnB1dEFyaWFMYWJlbD1cIm1pbnV0ZVwiXG4gICAgICAgICAgICBpbmNyZW1lbnRBcmlhTGFiZWw9XCJJbmNyZW1lbnQgdGhlIG1pbnV0ZVwiXG4gICAgICAgICAgICBkZWNyZW1lbnRBcmlhTGFiZWw9XCJEZWNyZW1lbnQgdGhlIG1pbnV0ZVwiXG4gICAgICAgICAgICAoaW5jcmVtZW50KT1cImluY3JlbWVudE1pbnV0ZSgpXCJcbiAgICAgICAgICAgIChkZWNyZW1lbnQpPVwiZGVjcmVtZW50TWludXRlKClcIj5cbiAgICAgICAgPC91eC1zcGluLWJ1dHRvbj5cblxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cInRpbWUtcGlja2VyLXNlcGFyYXRvclwiICpuZ0lmPVwic2hvd1NlY29uZHNcIj46PC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwidGltZS1waWNrZXItY29sdW1uXCIgW2NsYXNzLmhhcy1lcnJvcl09XCIhKHZhbGlkJCB8IGFzeW5jKVwiICpuZ0lmPVwic2hvd1NlY29uZHNcIj5cblxuICAgICAgICA8dXgtc3Bpbi1idXR0b25cbiAgICAgICAgICAgIHR5cGU9XCJudW1iZXJcIlxuICAgICAgICAgICAgY2xhc3M9XCJ0aW1lLXNwaW5uZXJcIlxuICAgICAgICAgICAgdHlwZT1cIm51bWJlclwiXG4gICAgICAgICAgICBwbGFjZWhvbGRlcj1cIlNTXCJcbiAgICAgICAgICAgIFttaW5dPVwiMFwiXG4gICAgICAgICAgICBbbWF4XT1cIjU5XCJcbiAgICAgICAgICAgIFt2YWx1ZV09XCJzZWNvbmQkIHwgYXN5bmMgfCB0aW1lRm9ybWF0XCJcbiAgICAgICAgICAgICh2YWx1ZUNoYW5nZSk9XCJzZWNvbmRDaGFuZ2UoJGV2ZW50KVwiXG4gICAgICAgICAgICBbc3Bpbm5lcnNdPVwic2hvd1NwaW5uZXJzXCJcbiAgICAgICAgICAgIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAgICAgICAgICBbcmVhZE9ubHldPVwicmVhZE9ubHlcIlxuICAgICAgICAgICAgaW5wdXRBcmlhTGFiZWw9XCJzZWNvbmRzXCJcbiAgICAgICAgICAgIGluY3JlbWVudEFyaWFMYWJlbD1cIkluY3JlbWVudCB0aGUgc2Vjb25kXCJcbiAgICAgICAgICAgIGRlY3JlbWVudEFyaWFMYWJlbD1cIkRlY3JlbWVudCB0aGUgc2Vjb25kXCJcbiAgICAgICAgICAgIChpbmNyZW1lbnQpPVwiaW5jcmVtZW50U2Vjb25kKClcIlxuICAgICAgICAgICAgKGRlY3JlbWVudCk9XCJkZWNyZW1lbnRTZWNvbmQoKVwiPlxuICAgICAgICA8L3V4LXNwaW4tYnV0dG9uPlxuXG4gICAgPC9kaXY+XG48L2Rpdj5cblxuPGRpdiBjbGFzcz1cInRpbWUtcGlja2VyLW1lcmlkaWFuXCIgKm5nSWY9XCJzaG93TWVyaWRpYW5cIj5cblxuICAgIDxkaXYgY2xhc3M9XCJidG4tZ3JvdXBcIiByb2xlPVwicmFkaW9ncm91cFwiPlxuXG4gICAgICAgIDxidXR0b24gY2xhc3M9XCJidG4gYnV0dG9uLXRvZ2dsZS1hY2NlbnRcIlxuICAgICAgICAgICAgICAgICpuZ0Zvcj1cImxldCBtZXJpZGlhbiBvZiBtZXJpZGlhbnNcIlxuICAgICAgICAgICAgICAgIHJvbGU9XCJyYWRpb1wiXG4gICAgICAgICAgICAgICAgdGFiaW5kZXg9XCIwXCJcbiAgICAgICAgICAgICAgICBbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuICAgICAgICAgICAgICAgIChjbGljayk9XCJzZWxlY3RNZXJpZGlhbihtZXJpZGlhbilcIlxuICAgICAgICAgICAgICAgIFtjbGFzcy5hY3RpdmVdPVwibWVyaWRpYW4gPT09IChtZXJpZGlhbiQgfCBhc3luYylcIlxuICAgICAgICAgICAgICAgIFthdHRyLmFyaWEtbGFiZWxdPVwibWVyaWRpYW5cIlxuICAgICAgICAgICAgICAgIFthdHRyLmFyaWEtY2hlY2tlZF09XCJtZXJpZGlhbiA9PT0gKG1lcmlkaWFuJCB8IGFzeW5jKVwiXG4gICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1kaXNhYmxlZF09XCJkaXNhYmxlZFwiPlxuICAgICAgICAgICAgICAgIHt7IG1lcmlkaWFuIH19XG4gICAgICAgIDwvYnV0dG9uPlxuXG4gICAgPC9kaXY+XG48L2Rpdj5gLFxuICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgcHJvdmlkZXJzOiBbVElNRV9QSUNLRVJfVkFMVUVfQUNDRVNTT1JdLFxuICAgIGhvc3Q6IHtcbiAgICAgICAgJ2FyaWEtbGFiZWwnOiAnVGltZSBQaWNrZXInXG4gICAgfVxufSlcbmV4cG9ydCBjbGFzcyBUaW1lUGlja2VyQ29tcG9uZW50IGltcGxlbWVudHMgQ29udHJvbFZhbHVlQWNjZXNzb3IsIE9uRGVzdHJveSB7XG5cbiAgICBASW5wdXQoKSBhcnJvd2tleXM6IGJvb2xlYW4gPSB0cnVlO1xuICAgIEBJbnB1dCgpIG1vdXNld2hlZWw6IGJvb2xlYW4gPSB0cnVlO1xuICAgIEBJbnB1dCgpIGRpc2FibGVkOiBib29sZWFuID0gZmFsc2U7XG4gICAgQElucHV0KCkgcmVhZE9ubHk6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIEBJbnB1dCgpIHNob3dNZXJpZGlhbjogYm9vbGVhbiA9IGZhbHNlO1xuICAgIEBJbnB1dCgpIHNob3dIb3VyczogYm9vbGVhbiA9IHRydWU7XG4gICAgQElucHV0KCkgc2hvd01pbnV0ZXM6IGJvb2xlYW4gPSB0cnVlO1xuICAgIEBJbnB1dCgpIHNob3dTZWNvbmRzOiBib29sZWFuID0gZmFsc2U7XG4gICAgQElucHV0KCkgc2hvd1NwaW5uZXJzOiBib29sZWFuID0gdHJ1ZTtcblxuICAgIEBJbnB1dCgpIGhvdXJTdGVwOiBudW1iZXIgPSAxO1xuICAgIEBJbnB1dCgpIG1pbnV0ZVN0ZXA6IG51bWJlciA9IDE7XG4gICAgQElucHV0KCkgc2Vjb25kU3RlcDogbnVtYmVyID0gMTtcblxuICAgIEBJbnB1dCgpIG1pbjogRGF0ZTtcbiAgICBASW5wdXQoKSBtYXg6IERhdGU7XG4gICAgQElucHV0KCkgbWVyaWRpYW5zOiBzdHJpbmdbXSA9IFsnQU0nLCAnUE0nXTtcblxuICAgIEBJbnB1dCgpIHNldCB2YWx1ZSh2YWx1ZTogRGF0ZSkge1xuICAgICAgICB0aGlzLnZhbHVlJC5uZXh0KG5ldyBEYXRlKHZhbHVlKSk7XG4gICAgICAgIHRoaXMudmFsdWVDaGFuZ2UuZW1pdCh0aGlzLnZhbHVlJC52YWx1ZSk7XG5cbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKHRoaXMudmFsdWUkLnZhbHVlKTtcbiAgICAgICAgdGhpcy5vblRvdWNoZWRDYWxsYmFjaygpO1xuICAgIH1cblxuICAgIGdldCB2YWx1ZSgpOiBEYXRlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMudmFsdWUkLnZhbHVlKTtcbiAgICB9XG5cbiAgICBAT3V0cHV0KCkgdmFsdWVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPERhdGU+KCk7XG4gICAgQE91dHB1dCgpIGlzVmFsaWQgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XG5cbiAgICBvblRvdWNoZWRDYWxsYmFjazogKCkgPT4gdm9pZCA9ICgpID0+IHsgfTtcbiAgICBvbkNoYW5nZUNhbGxiYWNrOiAoXzogRGF0ZSkgPT4gdm9pZCA9ICgpID0+IHsgfTtcblxuICAgIHZhbHVlJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8RGF0ZT4obmV3IERhdGUoKSk7XG5cbiAgICAvLyBjcmVhdGUgb2JzZXJ2YWJsZXMgdGhhdCBhcmUgZGVyaXZlZCBmcm9tIHRoZSBsYXRlc3QgdmFsdWVcbiAgICBob3VyJDogT2JzZXJ2YWJsZTxudW1iZXI+ID0gdGhpcy52YWx1ZSQucGlwZShtYXAoZGF0ZSA9PiBkYXRlLmdldEhvdXJzKCkpLCBtYXAoaG91ciA9PiB0aGlzLnNob3dNZXJpZGlhbiA/IHRoaXMuZ2V0TWVyaWRpYW5UaW1lKGhvdXIpIDogaG91cikpO1xuICAgIG1pbnV0ZSQ6IE9ic2VydmFibGU8bnVtYmVyPiA9IHRoaXMudmFsdWUkLnBpcGUobWFwKGRhdGUgPT4gZGF0ZS5nZXRNaW51dGVzKCkpKTtcbiAgICBzZWNvbmQkOiBPYnNlcnZhYmxlPG51bWJlcj4gPSB0aGlzLnZhbHVlJC5waXBlKG1hcChkYXRlID0+IGRhdGUuZ2V0U2Vjb25kcygpKSk7XG4gICAgbWVyaWRpYW4kOiBPYnNlcnZhYmxlPHN0cmluZz4gPSB0aGlzLnZhbHVlJC5waXBlKG1hcChkYXRlID0+IGRhdGUuZ2V0SG91cnMoKSA8IDEyID8gdGhpcy5tZXJpZGlhbnNbMF0gOiB0aGlzLm1lcmlkaWFuc1sxXSkpO1xuICAgIHZhbGlkJDogT2JzZXJ2YWJsZTxib29sZWFuPiA9IHRoaXMudmFsdWUkLnBpcGUobWFwKGRhdGUgPT4gdGhpcy5jaGVja1ZhbGlkaXR5KGRhdGUpKSk7XG5cbiAgICBwcml2YXRlIF9tZXJpZGlhbjogc3RyaW5nID0gdGhpcy5tZXJpZGlhbnNbMF07XG4gICAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gdGhpcy52YWxpZCQucGlwZShkaXN0aW5jdFVudGlsQ2hhbmdlZCgpKS5zdWJzY3JpYmUodmFsaWQgPT4gdGhpcy5pc1ZhbGlkLmVtaXQodmFsaWQpKTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZTogRGF0ZSk6IHZvaWQge1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmVnaXN0ZXJPbkNoYW5nZShmbjogKF86IERhdGUpID0+IHZvaWQpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrID0gZm47XG4gICAgfVxuXG4gICAgcmVnaXN0ZXJPblRvdWNoZWQoZm46ICgpID0+IHZvaWQpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5vblRvdWNoZWRDYWxsYmFjayA9IGZuO1xuICAgIH1cblxuICAgIHNldERpc2FibGVkU3RhdGUoaXNEaXNhYmxlZDogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gaXNEaXNhYmxlZDtcbiAgICB9XG5cbiAgICBnZXRNZXJpZGlhblRpbWUoaG91cjogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIGhvdXIgPiAxMiA/IGhvdXIgLSAxMiA6IGhvdXI7XG4gICAgfVxuXG4gICAgc2V0SG91cihob3VyOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgZGF0ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgIGRhdGUuc2V0SG91cnMoaG91ciA/IGhvdXIgOiAwKTtcblxuICAgICAgICB0aGlzLnZhbHVlID0gZGF0ZTtcbiAgICB9XG5cbiAgICBzZXRNaW51dGUobWludXRlOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgZGF0ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgIGRhdGUuc2V0TWludXRlcyhtaW51dGUgPyBtaW51dGUgOiAwKTtcblxuICAgICAgICB0aGlzLnZhbHVlID0gZGF0ZTtcbiAgICB9XG5cbiAgICBzZXRTZWNvbmRzKHNlY29uZHM6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBjb25zdCBkYXRlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgZGF0ZS5zZXRTZWNvbmRzKHNlY29uZHMgPyBzZWNvbmRzIDogMCk7XG5cbiAgICAgICAgdGhpcy52YWx1ZSA9IGRhdGU7XG4gICAgfVxuXG4gICAgaW5jcmVtZW50SG91cihhcnJvd2tleTogYm9vbGVhbiA9IGZhbHNlKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkIHx8IGFycm93a2V5ICYmICF0aGlzLmFycm93a2V5cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXRIb3VyKHRoaXMudmFsdWUuZ2V0SG91cnMoKSArIHRoaXMuaG91clN0ZXApO1xuICAgIH1cblxuICAgIGRlY3JlbWVudEhvdXIoYXJyb3drZXk6IGJvb2xlYW4gPSBmYWxzZSk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCB8fCBhcnJvd2tleSAmJiAhdGhpcy5hcnJvd2tleXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0SG91cih0aGlzLnZhbHVlLmdldEhvdXJzKCkgLSB0aGlzLmhvdXJTdGVwKTtcbiAgICB9XG5cbiAgICBpbmNyZW1lbnRNaW51dGUoYXJyb3drZXk6IGJvb2xlYW4gPSBmYWxzZSk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCB8fCBhcnJvd2tleSAmJiAhdGhpcy5hcnJvd2tleXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0TWludXRlKHRoaXMudmFsdWUuZ2V0TWludXRlcygpICsgdGhpcy5taW51dGVTdGVwKTtcbiAgICB9XG5cbiAgICBkZWNyZW1lbnRNaW51dGUoYXJyb3drZXk6IGJvb2xlYW4gPSBmYWxzZSk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCB8fCBhcnJvd2tleSAmJiAhdGhpcy5hcnJvd2tleXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0TWludXRlKHRoaXMudmFsdWUuZ2V0TWludXRlcygpIC0gdGhpcy5taW51dGVTdGVwKTtcbiAgICB9XG5cbiAgICBpbmNyZW1lbnRTZWNvbmQoYXJyb3drZXk6IGJvb2xlYW4gPSBmYWxzZSk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCB8fCBhcnJvd2tleSAmJiAhdGhpcy5hcnJvd2tleXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0U2Vjb25kcyh0aGlzLnZhbHVlLmdldFNlY29uZHMoKSArIHRoaXMuc2Vjb25kU3RlcCk7XG4gICAgfVxuXG4gICAgZGVjcmVtZW50U2Vjb25kKGFycm93a2V5OiBib29sZWFuID0gZmFsc2UpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQgfHwgYXJyb3drZXkgJiYgIXRoaXMuYXJyb3drZXlzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldFNlY29uZHModGhpcy52YWx1ZS5nZXRTZWNvbmRzKCkgLSB0aGlzLnNlY29uZFN0ZXApO1xuICAgIH1cblxuICAgIHNlbGVjdE1lcmlkaWFuKG1lcmlkaWFuOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fbWVyaWRpYW4gPSBtZXJpZGlhbjtcblxuICAgICAgICAvLyBnZXQgdGhlIGN1cnJlbnQgdGltZVxuICAgICAgICBjb25zdCBob3VyID0gdGhpcy52YWx1ZS5nZXRIb3VycygpO1xuXG4gICAgICAgIC8vIGlmIHdlIGhhdmUgc2VsZWN0ZWQgQU1cbiAgICAgICAgaWYgKG1lcmlkaWFuID09PSB0aGlzLm1lcmlkaWFuc1swXSkge1xuICAgICAgICAgICAgaWYgKGhvdXIgPj0gMTIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEhvdXIoaG91ciAtIDEyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHdlIGhhdmUgc2VsZWN0ZWQgUE1cbiAgICAgICAgaWYgKG1lcmlkaWFuID09PSB0aGlzLm1lcmlkaWFuc1sxXSkge1xuICAgICAgICAgICAgaWYgKGhvdXIgPCAxMikge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0SG91cihob3VyICsgMTIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2hlY2tWYWxpZGl0eShkYXRlOiBEYXRlKTogYm9vbGVhbiB7XG4gICAgICAgIGxldCB2YWxpZCA9IHRydWU7XG5cbiAgICAgICAgaWYgKHRoaXMubWluICYmIGRhdGUuZ2V0VGltZSgpIDw9IHRoaXMubWluLmdldFRpbWUoKSkge1xuICAgICAgICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm1heCAmJiBkYXRlLmdldFRpbWUoKSA+PSB0aGlzLm1heC5nZXRUaW1lKCkpIHtcbiAgICAgICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsaWQ7XG4gICAgfVxuXG4gICAgaG91ckNoYW5nZSh2YWx1ZTogc3RyaW5nKTogdm9pZCB7XG5cbiAgICAgICAgLy8gY29udmVydCB0aGUgc3RyaW5nIHRvIGEgbnVtYmVyXG4gICAgICAgIGxldCBob3VyID0gcGFyc2VJbnQodmFsdWUpO1xuICAgICAgICBsZXQgY3VycmVudEhvdXIgPSB0aGlzLnZhbHVlLmdldEhvdXJzKCk7XG5cbiAgICAgICAgLy8gaWYgdGhlIHZhbHVlIGhhc24ndCBjaGFuZ2VkLCBkbyBub3RoaW5nXG4gICAgICAgIGlmIChob3VyID09PSBjdXJyZW50SG91cikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZW5zdXJlIHRoZSBob3VycyBpcyB2YWxpZFxuICAgICAgICBpZiAoIWlzTmFOKGhvdXIpKSB7XG4gICAgICAgICAgICBpZiAoaG91ciA8IDApIHtcbiAgICAgICAgICAgICAgICBob3VyID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGhvdXIgPiAodGhpcy5zaG93TWVyaWRpYW4gPyAxMiA6IDIzKSkge1xuICAgICAgICAgICAgICAgIGhvdXIgPSB0aGlzLnNob3dNZXJpZGlhbiA/IDEyIDogMjM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBob3VyID0gaXNOYU4oaG91cikgPyBjdXJyZW50SG91ciA6IGhvdXI7XG5cbiAgICAgICAgLy8gaWYgdGhlIG51bWJlciBpcyBpbnZhbGlkIHRoZW4gcmVzdG9yZSBpdCB0byB0aGUgcHJldmlvdXMgdmFsdWVcbiAgICAgICAgaWYgKHRoaXMuX21lcmlkaWFuID09PSB0aGlzLm1lcmlkaWFuc1swXSkge1xuICAgICAgICAgICAgaWYgKGhvdXIgPj0gMTIpIHtcbiAgICAgICAgICAgICAgICBob3VyIC09IDEyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBzZWxlY3RlZCBQTVxuICAgICAgICBpZiAodGhpcy5fbWVyaWRpYW4gPT09IHRoaXMubWVyaWRpYW5zWzFdKSB7XG4gICAgICAgICAgICBpZiAoaG91ciA8IDEyKSB7XG4gICAgICAgICAgICAgICAgaG91ciArPSAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0SG91cihob3VyKTtcbiAgICB9XG5cbiAgICBtaW51dGVDaGFuZ2UodmFsdWU6IHN0cmluZyk6IHZvaWQge1xuXG4gICAgICAgIC8vIGNvbnZlcnQgdGhlIHN0cmluZyB0byBhIG51bWJlclxuICAgICAgICBsZXQgbWludXRlID0gcGFyc2VJbnQodmFsdWUpO1xuICAgICAgICBsZXQgY3VycmVudE1pbnV0ZSA9IHRoaXMudmFsdWUuZ2V0TWludXRlcygpO1xuXG4gICAgICAgIC8vIGlmIHRoZSB2YWx1ZSBoYXNuJ3QgY2hhbmdlZCwgZG8gbm90aGluZ1xuICAgICAgICBpZiAobWludXRlID09PSBjdXJyZW50TWludXRlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBlbnN1cmUgdGhlIGhvdXJzIGlzIHZhbGlkXG4gICAgICAgIGlmICghaXNOYU4obWludXRlKSkge1xuICAgICAgICAgICAgaWYgKG1pbnV0ZSA8IDApIHtcbiAgICAgICAgICAgICAgICBtaW51dGUgPSA1OTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1pbnV0ZSA+IDU5KSB7XG4gICAgICAgICAgICAgICAgbWludXRlID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoZSBudW1iZXIgaXMgaW52YWxpZCB0aGVuIHJlc3RvcmUgaXQgdG8gdGhlIHByZXZpb3VzIHZhbHVlXG4gICAgICAgIHRoaXMuc2V0TWludXRlKGlzTmFOKG1pbnV0ZSkgPyBjdXJyZW50TWludXRlIDogbWludXRlKTtcbiAgICB9XG5cbiAgICBzZWNvbmRDaGFuZ2UodmFsdWU6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICAvLyBjb252ZXJ0IHRoZSBzdHJpbmcgdG8gYSBudW1iZXJcbiAgICAgICAgbGV0IHNlY29uZCA9IHBhcnNlSW50KHZhbHVlKTtcbiAgICAgICAgbGV0IGN1cnJlbnRTZWNvbmQgPSB0aGlzLnZhbHVlLmdldFNlY29uZHMoKTtcblxuICAgICAgICAvLyBpZiB0aGUgdmFsdWUgaGFzbid0IGNoYW5nZWQsIGRvIG5vdGhpbmdcbiAgICAgICAgaWYgKHNlY29uZCA9PT0gY3VycmVudFNlY29uZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZW5zdXJlIHRoZSBob3VycyBpcyB2YWxpZFxuICAgICAgICBpZiAoIWlzTmFOKHNlY29uZCkpIHtcbiAgICAgICAgICAgIGlmIChzZWNvbmQgPCAwKSB7XG4gICAgICAgICAgICAgICAgc2Vjb25kID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNlY29uZCA+IDU5KSB7XG4gICAgICAgICAgICAgICAgc2Vjb25kID0gNTk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aGUgbnVtYmVyIGlzIGludmFsaWQgdGhlbiByZXN0b3JlIGl0IHRvIHRoZSBwcmV2aW91cyB2YWx1ZVxuICAgICAgICB0aGlzLnNldFNlY29uZHMoaXNOYU4oc2Vjb25kKSA/IGN1cnJlbnRTZWNvbmQgOiBzZWNvbmQpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZvcm1zTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgU3BpbkJ1dHRvbk1vZHVsZSB9IGZyb20gJy4uL3NwaW4tYnV0dG9uL2luZGV4JztcbmltcG9ydCB7IFRpbWVGb3JtYXRQaXBlIH0gZnJvbSAnLi90aW1lLWZvcm1hdC5waXBlJztcbmltcG9ydCB7IFRpbWVQaWNrZXJDb21wb25lbnQgfSBmcm9tICcuL3RpbWUtcGlja2VyLmNvbXBvbmVudCc7XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlLFxuICAgICAgICBTcGluQnV0dG9uTW9kdWxlXG4gICAgXSxcbiAgICBleHBvcnRzOiBbVGltZVBpY2tlckNvbXBvbmVudF0sXG4gICAgZGVjbGFyYXRpb25zOiBbVGltZVBpY2tlckNvbXBvbmVudCwgVGltZUZvcm1hdFBpcGVdLFxufSlcbmV4cG9ydCBjbGFzcyBUaW1lUGlja2VyTW9kdWxlIHsgfSIsImltcG9ydCB7IERhdGVUaW1lUGlja2VyVGltZXpvbmUgfSBmcm9tICcuL2RhdGUtdGltZS1waWNrZXIuc2VydmljZSc7XG5cblxuLyoqXG4gKiBDb252ZXJ0IGEgc2luZ2xlIGRpbWVuc2lvbiBhcnJheSB0byBhIGRvdWJsZSBkaW1lbnNpb24gYXJyYXlcbiAqIEBwYXJhbSBpdGVtcyB0aGUgc2luZ2xlIGRpbWVuc2lvbiBhcnJheSB0byBjb252ZXJ0XG4gKiBAcGFyYW0gY29sdW1ucyB0aGUgbnVtYmVyIG9mIGl0ZW1zIGVhY2ggYXJyYXkgc2hvdWxkIGhhdmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdyaWRpZnk8VD4oaXRlbXM6IFRbXSwgY29sdW1uczogbnVtYmVyKTogVFtdW10ge1xuXG4gICAgLy8gY3JlYXRlIGEgY29weSBvZiBhcnJheSBzbyBub3QgdG8gZWZmZWN0IHRoZSBvcmlnaW5hbFxuICAgIGl0ZW1zID0gaXRlbXMuc2xpY2UoMCk7XG5cbiAgICBjb25zdCBncmlkOiBUW11bXSA9IFtdO1xuXG4gICAgd2hpbGUgKGl0ZW1zLmxlbmd0aCkge1xuICAgICAgICBncmlkLnB1c2goaXRlbXMuc3BsaWNlKDAsIGNvbHVtbnMpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ3JpZDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gYXJyYXkgb2YgbnVtYmVycyBiZXR3ZWVuIHR3byBsaW1pdHNcbiAqIEBwYXJhbSBzdGFydCB0aGUgbG93ZXIgbGltaXRcbiAqIEBwYXJhbSBlbmQgdGhlIHVwcGVyIGxpbWl0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYW5nZShzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlcik6IG51bWJlcltdIHtcbiAgICBjb25zdCBsaXN0OiBudW1iZXJbXSA9IFtdO1xuXG4gICAgZm9yIChsZXQgaWR4ID0gc3RhcnQ7IGlkeCA8PSBlbmQ7IGlkeCsrKSB7XG4gICAgICAgIGxpc3QucHVzaChpZHgpO1xuICAgIH1cblxuICAgIHJldHVybiBsaXN0O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBhcnJheSBvZiBkYXRlcyBiZXR3ZWVuIHR3byBwb2ludHNcbiAqIEBwYXJhbSBzdGFydCB0aGUgZGF0ZSB0byBzdGFydCB0aGUgYXJyYXlcbiAqIEBwYXJhbSBlbmQgdGhlIGRhdGUgdG8gZW5kIHRoZSBhcnJheVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGF0ZVJhbmdlKHN0YXJ0OiBEYXRlLCBlbmQ6IERhdGUpOiBEYXRlW10ge1xuXG4gICAgbGV0IGRhdGVzOiBEYXRlW10gPSBbXTtcblxuICAgIC8vIGxvb3AgdGhyb3VnaCBhbGwgdGhlIGRheXMgYmV0d2VlbiB0aGUgZGF0ZSByYW5nZVxuICAgIHdoaWxlIChzdGFydCA8PSBlbmQpIHtcblxuICAgICAgICAvLyBhZGQgdGhlIGRhdGUgdG8gdGhlIGFycmF5XG4gICAgICAgIGRhdGVzLnB1c2gobmV3IERhdGUoc3RhcnQpKTtcblxuICAgICAgICAvLyBtb3ZlIHRvIHRoZSBuZXh0IGRheVxuICAgICAgICBzdGFydC5zZXREYXRlKHN0YXJ0LmdldERhdGUoKSArIDEpO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRlcztcbn1cblxuLyoqXG4gKiBDb21wYXJlIHR3byBkYXRlcyB0byBzZWUgaWYgdGhleSBhcmUgb24gdGhlIHNhbWUgZGF5XG4gKiBAcGFyYW0gZGF5MSB0aGUgZmlyc3QgZGF0ZSB0byBjb21wYXJlXG4gKiBAcGFyYW0gZGF5MiB0aGUgc2Vjb25kIGRhdGUgdG8gY29tcGFyZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcGFyZURheXMoZGF5MTogRGF0ZSwgZGF5MjogRGF0ZSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBkYXkxLmdldERhdGUoKSA9PT0gZGF5Mi5nZXREYXRlKCkgJiZcbiAgICAgICAgZGF5MS5nZXRNb250aCgpID09PSBkYXkyLmdldE1vbnRoKCkgJiZcbiAgICAgICAgZGF5MS5nZXRGdWxsWWVhcigpID09PSBkYXkyLmdldEZ1bGxZZWFyKCk7XG59XG5cbi8qKlxuICogRGF0ZSBjb21wYXJpc29uIGZvciB1c2UgcHJpbWFyaWx5IHdpdGggZGlzdGluY3RVbnRpbENoYW5nZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRhdGVDb21wYXJhdG9yKGRhdGVPbmU6IERhdGUsIGRhdGVUd286IERhdGUpOiBib29sZWFuIHtcbiAgICByZXR1cm4gZGF0ZU9uZS5nZXRUaW1lKCkgPT09IGRhdGVUd28uZ2V0VGltZSgpO1xufVxuXG4vKipcbiAqIFRpbWV6b25lIGNvbXBhcmlzb24gZm9yIHVzZSBwcmltYXJpbHkgd2l0aCBkaXN0aW5jdFVudGlsQ2hhbmdlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gdGltZXpvbmVDb21wYXJhdG9yKHpvbmVPbmU6IERhdGVUaW1lUGlja2VyVGltZXpvbmUsIHpvbmVUd286IERhdGVUaW1lUGlja2VyVGltZXpvbmUpOiBib29sZWFuIHtcbiAgICByZXR1cm4gem9uZU9uZS5uYW1lID09PSB6b25lVHdvLm5hbWUgJiYgem9uZU9uZS5vZmZzZXQgPT09IHpvbmVUd28ub2Zmc2V0O1xufVxuXG4vKipcbiAqIEV4cG9ydCBhbiBhcnJheSBvZiBhbGwgdGhlIGF2YWlsYWJsZSBtb250aHNcbiAqL1xuZXhwb3J0IGNvbnN0IG1vbnRocyA9IFsnSmFudWFyeScsICdGZWJydWFyeScsICdNYXJjaCcsICdBcHJpbCcsICdNYXknLCAnSnVuZScsICdKdWx5JywgJ0F1Z3VzdCcsICdTZXB0ZW1iZXInLCAnT2N0b2JlcicsICdOb3ZlbWJlcicsICdEZWNlbWJlciddO1xuZXhwb3J0IGNvbnN0IG1vbnRoc1Nob3J0ID0gbW9udGhzLm1hcChtb250aCA9PiBtb250aC5zdWJzdHJpbmcoMCwgMykpO1xuXG4vKipcbiAqIEV4cG9ydCBhbiBhcnJheSBvZiBhbGwgdGhlIGF2YWlsYWJsZSBkYXlzIG9mIHRoZSB3ZWVrXG4gKi9cbmV4cG9ydCBjb25zdCB3ZWVrZGF5cyA9IFsnTW9uZGF5JywgJ1R1ZXNkYXknLCAnV2VkbmVzZGF5JywgJ1RodXJzZGF5JywgJ0ZyaWRheScsICdTYXR1cmRheScsICdTdW5kYXknXTtcbmV4cG9ydCBjb25zdCB3ZWVrZGF5c1Nob3J0ID0gd2Vla2RheXMubWFwKHdlZWtkYXkgPT4gd2Vla2RheS5zdWJzdHJpbmcoMCwgMykpOyIsIi8qKlxuICogQWRkIGEgY29uZmlnIHNlcnZpY2UgdG8gYWxsb3cgYW4gYXBwbGljYXRpb25cbiAqIHRvIGN1c3RvbWl6ZSB0aGUgZGF0ZSB0aW1lIHBpY2tlciBkZWZhdWx0IHNldHRpbmdzXG4gKiBhY3Jvc3MgdGhlIGVudGlyZSBhcHBsaWNhdGlvblxuICovXG5cbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IHdlZWtkYXlzU2hvcnQgfSBmcm9tICcuL2RhdGUtdGltZS1waWNrZXIudXRpbHMnO1xuaW1wb3J0IHsgRGF0ZVRpbWVQaWNrZXJUaW1lem9uZSB9IGZyb20gJy4vZGF0ZS10aW1lLXBpY2tlci5zZXJ2aWNlJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIERhdGVUaW1lUGlja2VyQ29uZmlnIHtcblxuICAgIHNob3dEYXRlOiBib29sZWFuID0gdHJ1ZTtcbiAgICBzaG93VGltZTogYm9vbGVhbiA9IHRydWU7XG4gICAgc2hvd1RpbWV6b25lOiBib29sZWFuID0gdHJ1ZTtcbiAgICBzaG93U2Vjb25kczogYm9vbGVhbiA9IGZhbHNlO1xuICAgIHNob3dNZXJpZGlhbjogYm9vbGVhbiA9IHRydWU7XG4gICAgc2hvd1NwaW5uZXJzOiBib29sZWFuID0gdHJ1ZTtcbiAgICB3ZWVrZGF5czogc3RyaW5nW10gPSB3ZWVrZGF5c1Nob3J0O1xuICAgIG5vd0J0blRleHQ6IHN0cmluZyA9ICdUb2RheSc7XG5cbiAgICB0aW1lem9uZXM6IERhdGVUaW1lUGlja2VyVGltZXpvbmVbXSA9IFtcbiAgICAgICAgeyBuYW1lOiAnR01ULTExJywgb2Zmc2V0OiA2NjAgfSxcbiAgICAgICAgeyBuYW1lOiAnR01ULTEwJywgb2Zmc2V0OiA2MDAgfSxcbiAgICAgICAgeyBuYW1lOiAnR01ULTknLCBvZmZzZXQ6IDU0MCB9LFxuICAgICAgICB7IG5hbWU6ICdHTVQtOCcsIG9mZnNldDogNDgwIH0sXG4gICAgICAgIHsgbmFtZTogJ0dNVC03Jywgb2Zmc2V0OiA0MjAgfSxcbiAgICAgICAgeyBuYW1lOiAnR01ULTYnLCBvZmZzZXQ6IDM2MCB9LFxuICAgICAgICB7IG5hbWU6ICdHTVQtNScsIG9mZnNldDogMzAwIH0sXG4gICAgICAgIHsgbmFtZTogJ0dNVC00Jywgb2Zmc2V0OiAyNDAgfSxcbiAgICAgICAgeyBuYW1lOiAnR01ULTMnLCBvZmZzZXQ6IDE4MCB9LFxuICAgICAgICB7IG5hbWU6ICdHTVQtMicsIG9mZnNldDogMTIwIH0sXG4gICAgICAgIHsgbmFtZTogJ0dNVC0xJywgb2Zmc2V0OiA2MCB9LFxuICAgICAgICB7IG5hbWU6ICdHTVQnLCBvZmZzZXQ6IDAgfSxcbiAgICAgICAgeyBuYW1lOiAnR01UKzEnLCBvZmZzZXQ6IC02MCB9LFxuICAgICAgICB7IG5hbWU6ICdHTVQrMicsIG9mZnNldDogLTEyMCB9LFxuICAgICAgICB7IG5hbWU6ICdHTVQrMycsIG9mZnNldDogLTE4MCB9LFxuICAgICAgICB7IG5hbWU6ICdHTVQrNCcsIG9mZnNldDogLTI0MCB9LFxuICAgICAgICB7IG5hbWU6ICdHTVQrNScsIG9mZnNldDogLTMwMCB9LFxuICAgICAgICB7IG5hbWU6ICdHTVQrNicsIG9mZnNldDogLTM2MCB9LFxuICAgICAgICB7IG5hbWU6ICdHTVQrNycsIG9mZnNldDogLTQyMCB9LFxuICAgICAgICB7IG5hbWU6ICdHTVQrOCcsIG9mZnNldDogLTQ4MCB9LFxuICAgICAgICB7IG5hbWU6ICdHTVQrOScsIG9mZnNldDogLTU0MCB9LFxuICAgICAgICB7IG5hbWU6ICdHTVQrMTAnLCBvZmZzZXQ6IC02MDAgfSxcbiAgICAgICAgeyBuYW1lOiAnR01UKzExJywgb2Zmc2V0OiAtNjYwIH0sXG4gICAgICAgIHsgbmFtZTogJ0dNVCsxMicsIG9mZnNldDogLTcyMCB9XG4gICAgXTtcbn0iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QgfSBmcm9tICdyeGpzL0JlaGF2aW9yU3ViamVjdCc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IGRpc3RpbmN0VW50aWxDaGFuZ2VkIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgRGF0ZVRpbWVQaWNrZXJDb25maWcgfSBmcm9tICcuL2RhdGUtdGltZS1waWNrZXIuY29uZmlnJztcbmltcG9ydCB7IGRhdGVDb21wYXJhdG9yIH0gZnJvbSAnLi9kYXRlLXRpbWUtcGlja2VyLnV0aWxzJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIERhdGVUaW1lUGlja2VyU2VydmljZSB7XG5cbiAgICBtb2RlJDogQmVoYXZpb3JTdWJqZWN0PERhdGVQaWNrZXJNb2RlPiA9IG5ldyBCZWhhdmlvclN1YmplY3Q8RGF0ZVBpY2tlck1vZGU+KERhdGVQaWNrZXJNb2RlLkRheSk7XG4gICAgZGF0ZSQ6IEJlaGF2aW9yU3ViamVjdDxEYXRlPiA9IG5ldyBCZWhhdmlvclN1YmplY3Q8RGF0ZT4obmV3IERhdGUoKSk7XG4gICAgdGltZXpvbmUkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxEYXRlVGltZVBpY2tlclRpbWV6b25lPih0aGlzLmdldEN1cnJlbnRUaW1lem9uZSgpKTtcbiAgICBzZWxlY3RlZCQ6IEJlaGF2aW9yU3ViamVjdDxEYXRlPiA9IG5ldyBCZWhhdmlvclN1YmplY3Q8RGF0ZT4obmV3IERhdGUoKSk7XG5cbiAgICAvLyB0aGUgbW9udGggYW5kIHllYXIgdG8gZGlzcGxheSBpbiB0aGUgdmlld3BvcnRcbiAgICBtb250aCQ6IEJlaGF2aW9yU3ViamVjdDxudW1iZXI+ID0gbmV3IEJlaGF2aW9yU3ViamVjdDxudW1iZXI+KG5ldyBEYXRlKCkuZ2V0TW9udGgoKSk7XG4gICAgeWVhciQ6IEJlaGF2aW9yU3ViamVjdDxudW1iZXI+ID0gbmV3IEJlaGF2aW9yU3ViamVjdDxudW1iZXI+KG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKSk7XG5cbiAgICBzaG93RGF0ZSQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+KHRoaXMuX2NvbmZpZy5zaG93RGF0ZSk7XG4gICAgc2hvd1RpbWUkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPih0aGlzLl9jb25maWcuc2hvd1RpbWUpO1xuICAgIHNob3dUaW1lem9uZSQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+KHRoaXMuX2NvbmZpZy5zaG93VGltZXpvbmUpO1xuICAgIHNob3dTZWNvbmRzJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4odGhpcy5fY29uZmlnLnNob3dTZWNvbmRzKTtcbiAgICBzaG93TWVyaWRpYW4kID0gbmV3IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPih0aGlzLl9jb25maWcuc2hvd01lcmlkaWFuKTtcbiAgICBzaG93U3Bpbm5lcnMkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPih0aGlzLl9jb25maWcuc2hvd1NwaW5uZXJzKTtcbiAgICB3ZWVrZGF5cyQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PHN0cmluZ1tdPih0aGlzLl9jb25maWcud2Vla2RheXMpO1xuICAgIG5vd0J0blRleHQkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxzdHJpbmc+KHRoaXMuX2NvbmZpZy5ub3dCdG5UZXh0KTtcbiAgICB0aW1lem9uZXMkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxEYXRlVGltZVBpY2tlclRpbWV6b25lW10+KHRoaXMuX2NvbmZpZy50aW1lem9uZXMpO1xuXG4gICAgaGVhZGVyJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8c3RyaW5nPihudWxsKTtcbiAgICBoZWFkZXJFdmVudCQgPSBuZXcgU3ViamVjdDxEYXRlUGlja2VySGVhZGVyRXZlbnQ+KCk7XG4gICAgbW9kZURpcmVjdGlvbjogTW9kZURpcmVjdGlvbiA9IE1vZGVEaXJlY3Rpb24uTm9uZTtcblxuICAgIHByaXZhdGUgX3N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfY29uZmlnOiBEYXRlVGltZVBpY2tlckNvbmZpZykge1xuXG4gICAgICAgIC8vIHdoZW4gdGhlIGFjdGl2ZSBkYXRlIGNoYW5nZXMgc2V0IHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgZGF0ZVxuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24gPSB0aGlzLnNlbGVjdGVkJC5waXBlKGRpc3RpbmN0VW50aWxDaGFuZ2VkKGRhdGVDb21wYXJhdG9yKSkuc3Vic2NyaWJlKGRhdGUgPT4ge1xuXG4gICAgICAgICAgICAvLyB0aGUgbW9udGggYW5kIHllYXIgZGlzcGxheWVkIGluIHRoZSB2aWV3cG9ydCBzaG91bGQgcmVmbGVjdCB0aGUgbmV3bHkgc2VsZWN0ZWQgaXRlbXNcbiAgICAgICAgICAgIHRoaXMuc2V0Vmlld3BvcnRNb250aChkYXRlLmdldE1vbnRoKCkpO1xuICAgICAgICAgICAgdGhpcy5zZXRWaWV3cG9ydFllYXIoZGF0ZS5nZXRGdWxsWWVhcigpKTtcblxuICAgICAgICAgICAgLy8gZW1pdCB0aGUgbmV3IGRhdGUgdG8gdGhlIGNvbXBvbmVudCBob3N0XG4gICAgICAgICAgICB0aGlzLmRhdGUkLm5leHQoZGF0ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG5cbiAgICBzZXRWaWV3cG9ydE1vbnRoKG1vbnRoOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgaWYgKG1vbnRoIDwgMCkge1xuICAgICAgICAgICAgdGhpcy5tb250aCQubmV4dCgxMSk7XG4gICAgICAgICAgICB0aGlzLnllYXIkLm5leHQodGhpcy55ZWFyJC52YWx1ZSAtIDEpO1xuICAgICAgICB9IGVsc2UgaWYgKG1vbnRoID4gMTEpIHtcbiAgICAgICAgICAgIHRoaXMubW9udGgkLm5leHQoMCk7XG4gICAgICAgICAgICB0aGlzLnllYXIkLm5leHQodGhpcy55ZWFyJC52YWx1ZSArIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tb250aCQubmV4dChtb250aCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRWaWV3cG9ydFllYXIoeWVhcjogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMueWVhciQubmV4dCh5ZWFyKTtcbiAgICB9XG5cbiAgICBzZXREYXRlKGRheTogbnVtYmVyLCBtb250aDogbnVtYmVyLCB5ZWFyOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHRoaXMuc2VsZWN0ZWQkLnZhbHVlKTtcblxuICAgICAgICBkYXRlLnNldERhdGUoZGF5KTtcbiAgICAgICAgZGF0ZS5zZXRNb250aChtb250aCk7XG4gICAgICAgIGRhdGUuc2V0RnVsbFllYXIoeWVhcik7XG5cbiAgICAgICAgdGhpcy5zZWxlY3RlZCQubmV4dChkYXRlKTtcbiAgICB9XG5cbiAgICBzZXREYXRlVG9Ob3coKTogdm9pZCB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWQkLm5leHQobmV3IERhdGUoKSk7XG4gICAgfVxuXG4gICAgc2V0Vmlld3BvcnRNb2RlKG1vZGU6IERhdGVQaWNrZXJNb2RlKTogdm9pZCB7XG4gICAgICAgIHRoaXMubW9kZSQubmV4dChtb2RlKTtcbiAgICB9XG5cbiAgICBnb1RvQ2hpbGRNb2RlKCk6IHZvaWQge1xuICAgICAgICB0aGlzLm1vZGVEaXJlY3Rpb24gPSBNb2RlRGlyZWN0aW9uLkRlc2NlbmQ7XG5cbiAgICAgICAgc3dpdGNoICh0aGlzLm1vZGUkLnZhbHVlKSB7XG5cbiAgICAgICAgICAgIGNhc2UgRGF0ZVBpY2tlck1vZGUuWWVhcjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRWaWV3cG9ydE1vZGUoRGF0ZVBpY2tlck1vZGUuTW9udGgpO1xuXG4gICAgICAgICAgICBjYXNlIERhdGVQaWNrZXJNb2RlLk1vbnRoOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNldFZpZXdwb3J0TW9kZShEYXRlUGlja2VyTW9kZS5EYXkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ29Ub1BhcmVudE1vZGUoKTogdm9pZCB7XG4gICAgICAgIHRoaXMubW9kZURpcmVjdGlvbiA9IE1vZGVEaXJlY3Rpb24uQXNjZW5kO1xuXG4gICAgICAgIHN3aXRjaCAodGhpcy5tb2RlJC52YWx1ZSkge1xuXG4gICAgICAgICAgICBjYXNlIERhdGVQaWNrZXJNb2RlLkRheTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRWaWV3cG9ydE1vZGUoRGF0ZVBpY2tlck1vZGUuTW9udGgpO1xuXG4gICAgICAgICAgICBjYXNlIERhdGVQaWNrZXJNb2RlLk1vbnRoOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNldFZpZXdwb3J0TW9kZShEYXRlUGlja2VyTW9kZS5ZZWFyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdvVG9OZXh0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLmhlYWRlckV2ZW50JC5uZXh0KERhdGVQaWNrZXJIZWFkZXJFdmVudC5OZXh0KTtcbiAgICB9XG5cbiAgICBnb1RvUHJldmlvdXMoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuaGVhZGVyRXZlbnQkLm5leHQoRGF0ZVBpY2tlckhlYWRlckV2ZW50LlByZXZpb3VzKTtcbiAgICB9XG5cbiAgICBzZXRIZWFkZXIoaGVhZGVyOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5oZWFkZXIkLm5leHQoaGVhZGVyKTtcbiAgICB9XG5cbiAgICBnZXRDdXJyZW50VGltZXpvbmUoKTogRGF0ZVRpbWVQaWNrZXJUaW1lem9uZSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IG5ldyBEYXRlKCkuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbmZpZy50aW1lem9uZXMuZmluZCh0aW1lem9uZSA9PiB0aW1lem9uZS5vZmZzZXQgPT09IG9mZnNldCk7XG4gICAgfVxuXG4gICAgc2V0VGltZXpvbmUodGltZXpvbmU6IERhdGVUaW1lUGlja2VyVGltZXpvbmUpOiB2b2lkIHtcbiAgICAgICAgdGhpcy50aW1lem9uZSQubmV4dCh0aW1lem9uZSk7XG4gICAgfVxufVxuXG5leHBvcnQgZW51bSBEYXRlUGlja2VyTW9kZSB7XG4gICAgRGF5LFxuICAgIE1vbnRoLFxuICAgIFllYXJcbn1cblxuZXhwb3J0IGVudW0gTW9kZURpcmVjdGlvbiB7XG4gICAgTm9uZSxcbiAgICBBc2NlbmQsXG4gICAgRGVzY2VuZFxufVxuXG5leHBvcnQgZW51bSBEYXRlUGlja2VySGVhZGVyRXZlbnQge1xuICAgIFByZXZpb3VzLFxuICAgIE5leHRcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEYXRlVGltZVBpY2tlclRpbWV6b25lIHtcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgb2Zmc2V0OiBudW1iZXI7XG59IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIElucHV0LCBPbkRlc3Ryb3ksIE91dHB1dCwgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IGRpc3RpbmN0VW50aWxDaGFuZ2VkIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgRGF0ZVBpY2tlck1vZGUsIERhdGVUaW1lUGlja2VyU2VydmljZSwgRGF0ZVRpbWVQaWNrZXJUaW1lem9uZSB9IGZyb20gJy4vZGF0ZS10aW1lLXBpY2tlci5zZXJ2aWNlJztcbmltcG9ydCB7IGRhdGVDb21wYXJhdG9yLCB0aW1lem9uZUNvbXBhcmF0b3IgfSBmcm9tICcuL2RhdGUtdGltZS1waWNrZXIudXRpbHMnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICd1eC1kYXRlLXRpbWUtcGlja2VyJyxcbiAgdGVtcGxhdGU6IGA8ZGl2IGNsYXNzPVwiY2FsZW5kYXItY29udGFpbmVyXCI+XG5cbiAgPHV4LWRhdGUtdGltZS1waWNrZXItaGVhZGVyPjwvdXgtZGF0ZS10aW1lLXBpY2tlci1oZWFkZXI+XG5cbiAgPG5nLWNvbnRhaW5lciAqbmdJZj1cImRhdGVwaWNrZXIuc2hvd0RhdGUkIHwgYXN5bmNcIiBbbmdTd2l0Y2hdPVwiZGF0ZXBpY2tlci5tb2RlJCB8IGFzeW5jXCI+XG5cbiAgICAgIDwhLS0gRGlzcGxheSBkYXlzIGluIHRoZSBjdXJyZW50IG1vbnRoIC0tPlxuICAgICAgPHV4LWRhdGUtdGltZS1waWNrZXItZGF5LXZpZXcgKm5nU3dpdGNoQ2FzZT1cIkRhdGVQaWNrZXJNb2RlLkRheVwiPjwvdXgtZGF0ZS10aW1lLXBpY2tlci1kYXktdmlldz5cblxuICAgICAgPCEtLSBEaXNwbGF5IHRoZSBtb250aHMgaW4gdGhlIGN1cnJlbnQgeWVhciAtLT5cbiAgICAgIDx1eC1kYXRlLXRpbWUtcGlja2VyLW1vbnRoLXZpZXcgKm5nU3dpdGNoQ2FzZT1cIkRhdGVQaWNrZXJNb2RlLk1vbnRoXCI+PC91eC1kYXRlLXRpbWUtcGlja2VyLW1vbnRoLXZpZXc+XG5cbiAgICAgIDwhLS0gRGlzcGxheSBhIGRlY2FkZSAtLT5cbiAgICAgIDx1eC1kYXRlLXRpbWUtcGlja2VyLXllYXItdmlldyAqbmdTd2l0Y2hDYXNlPVwiRGF0ZVBpY2tlck1vZGUuWWVhclwiPjwvdXgtZGF0ZS10aW1lLXBpY2tlci15ZWFyLXZpZXc+XG5cbiAgPC9uZy1jb250YWluZXI+XG5cbiAgPCEtLSBEaXNwbGF5IGEgVGltZSBQaWNrZXIgLS0+XG4gIDx1eC1kYXRlLXRpbWUtcGlja2VyLXRpbWUtdmlldyAqbmdJZj1cImRhdGVwaWNrZXIuc2hvd1RpbWUkIHwgYXN5bmNcIj48L3V4LWRhdGUtdGltZS1waWNrZXItdGltZS12aWV3PlxuXG48L2Rpdj5cblxuPGJ1dHRvbiBjbGFzcz1cIm5vdy1idXR0b25cIiBhcmlhLWxhYmVsPVwiU2V0IGRhdGUgdG8gbm93XCIgKGNsaWNrKT1cInNldFRvTm93KClcIj57eyBkYXRlcGlja2VyLm5vd0J0blRleHQkIHwgYXN5bmMgfX08L2J1dHRvbj5gLFxuICBwcm92aWRlcnM6IFtEYXRlVGltZVBpY2tlclNlcnZpY2VdLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxufSlcbmV4cG9ydCBjbGFzcyBEYXRlVGltZVBpY2tlckNvbXBvbmVudCBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG5cbiAgcHJpdmF0ZSBfdGltZXpvbmU6IERhdGVUaW1lUGlja2VyVGltZXpvbmU7XG5cbiAgQElucHV0KCkgc2V0IHNob3dEYXRlKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5kYXRlcGlja2VyLnNob3dEYXRlJC5uZXh0KHZhbHVlKTtcbiAgfVxuXG4gIEBJbnB1dCgpIHNldCBzaG93VGltZSh2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuZGF0ZXBpY2tlci5zaG93VGltZSQubmV4dCh2YWx1ZSk7XG4gIH1cblxuICBASW5wdXQoKSBzZXQgc2hvd1RpbWV6b25lKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5kYXRlcGlja2VyLnNob3dUaW1lem9uZSQubmV4dCh2YWx1ZSk7XG4gIH1cblxuICBASW5wdXQoKSBzZXQgc2hvd1NlY29uZHModmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLmRhdGVwaWNrZXIuc2hvd1NlY29uZHMkLm5leHQodmFsdWUpO1xuICB9XG5cbiAgQElucHV0KCkgc2V0IHNob3dNZXJpZGlhbih2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuZGF0ZXBpY2tlci5zaG93TWVyaWRpYW4kLm5leHQodmFsdWUpO1xuICB9XG5cbiAgQElucHV0KCkgc2V0IHNob3dTcGlubmVycyh2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuZGF0ZXBpY2tlci5zaG93U3Bpbm5lcnMkLm5leHQodmFsdWUpO1xuICB9XG5cbiAgQElucHV0KCkgc2V0IHdlZWtkYXlzKHZhbHVlOiBzdHJpbmdbXSkge1xuICAgIHRoaXMuZGF0ZXBpY2tlci53ZWVrZGF5cyQubmV4dCh2YWx1ZSk7XG4gIH1cblxuICBASW5wdXQoKSBzZXQgbm93QnRuVGV4dCh2YWx1ZTogc3RyaW5nKSB7XG4gICAgdGhpcy5kYXRlcGlja2VyLm5vd0J0blRleHQkLm5leHQodmFsdWUpO1xuICB9XG5cbiAgQElucHV0KCkgc2V0IHRpbWV6b25lcyh2YWx1ZTogRGF0ZVRpbWVQaWNrZXJUaW1lem9uZVtdKSB7XG4gICAgdGhpcy5kYXRlcGlja2VyLnRpbWV6b25lcyQubmV4dCh2YWx1ZSk7XG4gIH1cblxuXG4gIEBPdXRwdXQoKSBkYXRlQ2hhbmdlOiBFdmVudEVtaXR0ZXI8RGF0ZT4gPSBuZXcgRXZlbnRFbWl0dGVyPERhdGU+KCk7XG4gIEBPdXRwdXQoKSB0aW1lem9uZUNoYW5nZTogRXZlbnRFbWl0dGVyPERhdGVUaW1lUGlja2VyVGltZXpvbmU+ID0gbmV3IEV2ZW50RW1pdHRlcjxEYXRlVGltZVBpY2tlclRpbWV6b25lPigpO1xuXG4gIEBJbnB1dCgpXG4gIHNldCBkYXRlKHZhbHVlOiBEYXRlKSB7XG4gICAgaWYgKCFkYXRlQ29tcGFyYXRvcih2YWx1ZSwgdGhpcy5kYXRlcGlja2VyLnNlbGVjdGVkJC52YWx1ZSkpIHtcbiAgICAgIHRoaXMuZGF0ZXBpY2tlci5zZWxlY3RlZCQubmV4dChuZXcgRGF0ZSh2YWx1ZSkpO1xuICAgIH1cbiAgfVxuXG4gIEBJbnB1dCgpXG4gIHNldCB0aW1lem9uZSh2YWx1ZTogRGF0ZVRpbWVQaWNrZXJUaW1lem9uZSkge1xuICAgIHRoaXMuZGF0ZXBpY2tlci50aW1lem9uZSQubmV4dCh2YWx1ZSk7XG4gIH1cblxuICAvLyBleHBvc2UgZW51bSB0byB2aWV3XG4gIERhdGVQaWNrZXJNb2RlID0gRGF0ZVBpY2tlck1vZGU7XG5cbiAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBkYXRlcGlja2VyOiBEYXRlVGltZVBpY2tlclNlcnZpY2UpIHtcbiAgICBjb25zdCB2YWx1ZUNoYW5nZSA9IGRhdGVwaWNrZXIuc2VsZWN0ZWQkLnBpcGUoZGlzdGluY3RVbnRpbENoYW5nZWQoZGF0ZUNvbXBhcmF0b3IpKVxuICAgICAgLnN1YnNjcmliZShkYXRlID0+IHRoaXMuZGF0ZUNoYW5nZS5lbWl0KGRhdGUpKTtcblxuICAgIGNvbnN0IHRpbWV6b25lQ2hhbmdlID0gZGF0ZXBpY2tlci50aW1lem9uZSQucGlwZShkaXN0aW5jdFVudGlsQ2hhbmdlZCh0aW1lem9uZUNvbXBhcmF0b3IpKVxuICAgICAgLnN1YnNjcmliZSgodGltZXpvbmU6IERhdGVUaW1lUGlja2VyVGltZXpvbmUpID0+IHRoaXMudGltZXpvbmVDaGFuZ2UuZW1pdCh0aW1lem9uZSkpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gIH1cblxuICAvKipcbiAgICogQ2hhbmdlIHRoZSBkYXRlIHRvIHRoZSBjdXJyZW50IGRhdGUgYW5kIHRpbWVcbiAgICovXG4gIHNldFRvTm93KCk6IHZvaWQge1xuXG4gICAgLy8gc2V0IHRoZSBkYXRlIHRvIHRoZSBjdXJyZW50IG1vbWVudFxuICAgIHRoaXMuZGF0ZXBpY2tlci5zZXREYXRlVG9Ob3coKTtcbiAgfVxufSIsImltcG9ydCB7IEluamVjdGFibGUsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcy9CZWhhdmlvclN1YmplY3QnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcy9TdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgY29tYmluZUxhdGVzdCB9IGZyb20gJ3J4anMvb2JzZXJ2YWJsZS9jb21iaW5lTGF0ZXN0JztcbmltcG9ydCB7IERhdGVUaW1lUGlja2VyU2VydmljZSwgTW9kZURpcmVjdGlvbiB9IGZyb20gJy4uL2RhdGUtdGltZS1waWNrZXIuc2VydmljZSc7XG5pbXBvcnQgeyBjb21wYXJlRGF5cywgZGF0ZVJhbmdlLCBncmlkaWZ5LCBtb250aHMgfSBmcm9tICcuLi9kYXRlLXRpbWUtcGlja2VyLnV0aWxzJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIERheVZpZXdTZXJ2aWNlIGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICAgIGdyaWQkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxEYXlWaWV3SXRlbVtdW10+KFtbXV0pO1xuICAgIGZvY3VzZWQkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxGb2N1c2VkRGF5SXRlbT4obnVsbCk7XG5cbiAgICBwcml2YXRlIF9zdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX2RhdGVwaWNrZXI6IERhdGVUaW1lUGlja2VyU2VydmljZSkge1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24gPSBjb21iaW5lTGF0ZXN0KF9kYXRlcGlja2VyLm1vbnRoJCwgX2RhdGVwaWNrZXIueWVhciQpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKChbbW9udGgsIHllYXJdKSA9PiB0aGlzLmNyZWF0ZURheUdyaWQobW9udGgsIHllYXIpKTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuXG4gICAgc2V0Rm9jdXMoZGF5OiBudW1iZXIsIG1vbnRoOiBudW1iZXIsIHllYXI6IG51bWJlcik6IHZvaWQge1xuICAgICAgICB0aGlzLmZvY3VzZWQkLm5leHQoeyBkYXk6IGRheSwgbW9udGg6IG1vbnRoLCB5ZWFyOiB5ZWFyIH0pO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgZGF0ZSBwaWNrZXIgdG8gc2hvdyB0aGUgcmVxdWlyZWQgbW9udGggYW5kIHllYXJcbiAgICAgICAgdGhpcy5fZGF0ZXBpY2tlci5zZXRWaWV3cG9ydE1vbnRoKG1vbnRoKTtcbiAgICAgICAgdGhpcy5fZGF0ZXBpY2tlci5zZXRWaWV3cG9ydFllYXIoeWVhcik7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmVhdGVEYXlHcmlkKG1vbnRoOiBudW1iZXIsIHllYXI6IG51bWJlcik6IHZvaWQge1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgaGVhZGVyXG4gICAgICAgIHRoaXMuX2RhdGVwaWNrZXIuc2V0SGVhZGVyKG1vbnRoc1ttb250aF0gKyAnICcgKyB5ZWFyKTtcblxuICAgICAgICAvLyBmaW5kIHRoZSBsb3dlciBhbmQgdXBwZXIgYm91bmRhcmllc1xuICAgICAgICBjb25zdCBzdGFydCA9IG5ldyBEYXRlKHllYXIsIG1vbnRoLCAxKTtcbiAgICAgICAgY29uc3QgZW5kID0gbmV3IERhdGUoeWVhciwgbW9udGggKyAxLCAwKTtcblxuICAgICAgICAvLyB3ZSBhbHdheXMgd2FudCB0byBzaG93IGZyb20gdGhlIHN1bmRheSAtIHRoaXMgbWF5IGluY2x1ZGUgc2hvd2luZyBzb21lIGRhdGVzIGZyb20gdGhlIHByZXZpb3VzIG1vbnRoXG4gICAgICAgIHN0YXJ0LnNldERhdGUoc3RhcnQuZ2V0RGF0ZSgpIC0gc3RhcnQuZ2V0RGF5KCkpO1xuXG4gICAgICAgIC8vIHdlIGFsc28gd2FudCB0byBtYWtlIHN1cmUgdGhhdCB0aGUgcmFuZ2UgZW5kcyBvbiBhIHNhdHVyZGF5XG4gICAgICAgIGVuZC5zZXREYXRlKGVuZC5nZXREYXRlKCkgKyAoNiAtIGVuZC5nZXREYXkoKSkpO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBhbiBhcnJheSBvZiBhbGwgdGhlIGRheXMgdG8gZGlzcGxheVxuICAgICAgICBjb25zdCBkYXRlczogRGF5Vmlld0l0ZW1bXSA9IGRhdGVSYW5nZShzdGFydCwgZW5kKS5tYXAoZGF0ZSA9PiAoe1xuICAgICAgICAgICAgZGF5OiBkYXRlLmdldERhdGUoKSxcbiAgICAgICAgICAgIG1vbnRoOiBkYXRlLmdldE1vbnRoKCksXG4gICAgICAgICAgICB5ZWFyOiBkYXRlLmdldEZ1bGxZZWFyKCksXG4gICAgICAgICAgICBkYXRlOiBkYXRlLFxuICAgICAgICAgICAgaXNUb2RheTogdGhpcy5pc1RvZGF5KGRhdGUpLFxuICAgICAgICAgICAgaXNBY3RpdmU6IHRoaXMuaXNBY3RpdmUoZGF0ZSksXG4gICAgICAgICAgICBpc0N1cnJlbnRNb250aDogZGF0ZS5nZXRNb250aCgpID09PSBtb250aFxuICAgICAgICB9KSk7XG5cbiAgICAgICAgLy8gdHVybiB0aGUgZGF0ZXMgaW50byBhIGdyaWRcbiAgICAgICAgY29uc3QgaXRlbXM6IERheVZpZXdJdGVtW11bXSA9IGdyaWRpZnkoZGF0ZXMsIDcpO1xuXG4gICAgICAgIHRoaXMuZ3JpZCQubmV4dChpdGVtcyk7XG5cbiAgICAgICAgLy8gaWYgbm8gaXRlbSBoYXMgeWV0IGJlZW4gZm9jdXNlZCB0aGVuIGZvY3VzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIG1vbnRoXG4gICAgICAgIGlmICgodGhpcy5fZGF0ZXBpY2tlci5tb2RlRGlyZWN0aW9uID09PSBNb2RlRGlyZWN0aW9uLk5vbmUgfHwgdGhpcy5fZGF0ZXBpY2tlci5tb2RlRGlyZWN0aW9uID09PSBNb2RlRGlyZWN0aW9uLkRlc2NlbmQpICYmIHRoaXMuZm9jdXNlZCQudmFsdWUgPT09IG51bGwpIHtcblxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIHNlbGVjdGVkIGl0ZW0gaXMgdmlzaWJsZVxuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWREYXkgPSBkYXRlcy5maW5kKGRheSA9PiBkYXkuaXNDdXJyZW50TW9udGggJiYgZGF5LmlzQWN0aXZlKTtcblxuICAgICAgICAgICAgaWYgKHNlbGVjdGVkRGF5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRGb2N1cyhzZWxlY3RlZERheS5kYXksIHNlbGVjdGVkRGF5Lm1vbnRoLCBzZWxlY3RlZERheS55ZWFyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAvLyBmaW5kIHRoZSBmaXJzdCBkYXkgb2YgdGhlIG1vbnRoXG4gICAgICAgICAgICAgICAgY29uc3QgZmlyc3QgPSBkYXRlcy5maW5kKGRhdGUgPT4gZGF0ZS5kYXkgPT09IDEpO1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIGZvY3VzIHRoZSBkYXRlXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRGb2N1cyhmaXJzdC5kYXksIGZpcnN0Lm1vbnRoLCBmaXJzdC55ZWFyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAqIERldGVybWluZSB3aGV0aGVyIG9yIG5vdCBhIHNwZWNpZmljIGRhdGUgaXMgdG9kYXlcbiAgICogQHBhcmFtIGRhdGUgVGhlIGRhdGUgdG8gY2hlY2tcbiAgICovXG4gICAgcHJpdmF0ZSBpc1RvZGF5KGRhdGU6IERhdGUpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGNvbXBhcmVEYXlzKG5ldyBEYXRlKCksIGRhdGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciBvciBub3QgYSBzcGVjaWZpYyBkYXRlIGlzIHRoZSBzZWxlY3RlZCBvbmVcbiAgICAgKiBAcGFyYW0gZGF0ZSB0aGUgZGF0ZSB0byBjaGVja1xuICAgICAqL1xuICAgIHByaXZhdGUgaXNBY3RpdmUoZGF0ZTogRGF0ZSk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gY29tcGFyZURheXModGhpcy5fZGF0ZXBpY2tlci5zZWxlY3RlZCQudmFsdWUsIGRhdGUpO1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBEYXlWaWV3SXRlbSB7XG4gICAgZGF5OiBudW1iZXI7XG4gICAgbW9udGg6IG51bWJlcjtcbiAgICB5ZWFyOiBudW1iZXI7XG4gICAgZGF0ZTogRGF0ZTtcbiAgICBpc1RvZGF5OiBib29sZWFuO1xuICAgIGlzQWN0aXZlOiBib29sZWFuO1xuICAgIGlzQ3VycmVudE1vbnRoOiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZvY3VzZWREYXlJdGVtIHtcbiAgICBkYXk6IG51bWJlcjtcbiAgICBtb250aDogbnVtYmVyO1xuICAgIHllYXI6IG51bWJlcjtcbn0iLCJpbXBvcnQgeyBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgQ29tcG9uZW50LCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IERhdGVQaWNrZXJIZWFkZXJFdmVudCwgRGF0ZVRpbWVQaWNrZXJTZXJ2aWNlIH0gZnJvbSAnLi4vZGF0ZS10aW1lLXBpY2tlci5zZXJ2aWNlJztcbmltcG9ydCB7IERheVZpZXdJdGVtLCBEYXlWaWV3U2VydmljZSB9IGZyb20gJy4vZGF5LXZpZXcuc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ3V4LWRhdGUtdGltZS1waWNrZXItZGF5LXZpZXcnLFxuICB0ZW1wbGF0ZTogYDx0YWJsZSBjbGFzcz1cImNhbGVuZGFyXCI+XG4gICAgPHRoZWFkPlxuICAgICAgICA8dHI+XG4gICAgICAgICAgICA8dGggKm5nRm9yPVwibGV0IGRheSBvZiBkYXRlUGlja2VyLndlZWtkYXlzJCB8IGFzeW5jXCIgY2xhc3M9XCJ3ZWVrZGF5XCIgW2F0dHIuYXJpYS1sYWJlbF09XCJkYXlcIj57eyBkYXkgfX08L3RoPlxuICAgICAgICA8L3RyPlxuICAgIDwvdGhlYWQ+XG5cbiAgICA8dGJvZHkgcm9sZT1cImdyaWRcIj5cbiAgICAgICAgPHRyIHJvbGU9XCJyb3dcIiAqbmdGb3I9XCJsZXQgcm93IG9mIGRheVNlcnZpY2UuZ3JpZCQgfCBhc3luYzsgdHJhY2tCeTogdHJhY2tXZWVrQnlGblwiPlxuXG4gICAgICAgICAgICA8dGQgKm5nRm9yPVwibGV0IGl0ZW0gb2Ygcm93OyB0cmFja0J5OiB0cmFja0RheUJ5Rm5cIiBjbGFzcz1cImRhdGUtY2VsbFwiIHJvbGU9XCJncmlkY2VsbFwiPlxuXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImRhdGUtYnV0dG9uXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIFtmb2N1c0lmXT1cIihkYXlTZXJ2aWNlLmZvY3VzZWQkIHwgYXN5bmMpPy5kYXkgPT09IGl0ZW0uZGF5ICYmIChkYXlTZXJ2aWNlLmZvY3VzZWQkIHwgYXN5bmMpPy5tb250aCA9PT0gaXRlbS5tb250aCAmJiAoZGF5U2VydmljZS5mb2N1c2VkJCB8IGFzeW5jKT8ueWVhciA9PT0gaXRlbS55ZWFyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIFthdHRyLmFyaWEtbGFiZWxdPVwiaXRlbS5kYXRlIHwgZGF0ZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLXNlbGVjdGVkXT1cIml0ZW0uaXNBY3RpdmVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1oaWRkZW5dPVwiIWl0ZW0uaXNDdXJyZW50TW9udGhcIlxuICAgICAgICAgICAgICAgICAgICAgICAgW2NsYXNzLmN1cnJlbnRdPVwiaXRlbS5pc1RvZGF5XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIFtjbGFzcy5hY3RpdmVdPVwiaXRlbS5pc0FjdGl2ZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICBbY2xhc3MucHJldmlld109XCIhaXRlbS5pc0N1cnJlbnRNb250aFwiXG4gICAgICAgICAgICAgICAgICAgICAgICBbdGFiaW5kZXhdPVwiZ2V0VGFiYmFibGUoaXRlbSkgPyAwIDogLTFcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKGNsaWNrKT1cInNlbGVjdChpdGVtLmRhdGUpOyAkZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKGtleWRvd24uQXJyb3dMZWZ0KT1cImZvY3VzRGF0ZShpdGVtLCAtMSk7ICRldmVudC5wcmV2ZW50RGVmYXVsdCgpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIChrZXlkb3duLkFycm93UmlnaHQpPVwiZm9jdXNEYXRlKGl0ZW0sIDEpOyAkZXZlbnQucHJldmVudERlZmF1bHQoKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAoa2V5ZG93bi5BcnJvd1VwKT1cImZvY3VzRGF0ZShpdGVtLCAtNyk7ICRldmVudC5wcmV2ZW50RGVmYXVsdCgpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIChrZXlkb3duLkFycm93RG93bik9XCJmb2N1c0RhdGUoaXRlbSwgNyk7ICRldmVudC5wcmV2ZW50RGVmYXVsdCgpXCI+XG5cbiAgICAgICAgICAgICAgICAgICAge3sgaXRlbS5kYXRlLmdldERhdGUoKSB9fVxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuXG4gICAgICAgICAgICA8L3RkPlxuICAgICAgICA8L3RyPlxuICAgIDwvdGJvZHk+XG48L3RhYmxlPmAsXG4gIHByb3ZpZGVyczogW0RheVZpZXdTZXJ2aWNlXSxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgRGF5Vmlld0NvbXBvbmVudCBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG5cbiAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgY29uc3RydWN0b3IocHVibGljIGRhdGVQaWNrZXI6IERhdGVUaW1lUGlja2VyU2VydmljZSwgcHVibGljIGRheVNlcnZpY2U6IERheVZpZXdTZXJ2aWNlKSB7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gZGF0ZVBpY2tlci5oZWFkZXJFdmVudCRcbiAgICAgIC5zdWJzY3JpYmUoZXZlbnQgPT4gZXZlbnQgPT09IERhdGVQaWNrZXJIZWFkZXJFdmVudC5OZXh0ID8gdGhpcy5uZXh0KCkgOiB0aGlzLnByZXZpb3VzKCkpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gIH1cblxuICAvKipcbiAgICogTmF2aWdhdGUgdG8gdGhlIHByZXZpb3VzIHBhZ2Ugb2YgZGF0ZXNcbiAgICovXG4gIHByZXZpb3VzKCk6IHZvaWQge1xuICAgIHRoaXMuZGF0ZVBpY2tlci5zZXRWaWV3cG9ydE1vbnRoKHRoaXMuZGF0ZVBpY2tlci5tb250aCQudmFsdWUgLSAxKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBOYXZpZ2F0ZSB0byB0aGUgbmV4dCBwYWdlIG9mIGRhdGVzXG4gICAqL1xuICBuZXh0KCk6IHZvaWQge1xuICAgIHRoaXMuZGF0ZVBpY2tlci5zZXRWaWV3cG9ydE1vbnRoKHRoaXMuZGF0ZVBpY2tlci5tb250aCQudmFsdWUgKyAxKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWxlY3QgYSBwYXJ0aWN1bGFyIGRhdGVcbiAgICogQHBhcmFtIGRhdGUgdGhlIGRhdGUgdG8gc2VsZWN0XG4gICAqL1xuICBzZWxlY3QoZGF0ZTogRGF0ZSk6IHZvaWQge1xuICAgIC8vIHVwZGF0ZSB0aGUgY3VycmVudCBkYXRlIG9iamVjdFxuICAgIHRoaXMuZGF0ZVBpY2tlci5zZXREYXRlKGRhdGUuZ2V0RGF0ZSgpLCBkYXRlLmdldE1vbnRoKCksIGRhdGUuZ2V0RnVsbFllYXIoKSk7XG5cbiAgICAvLyBmb2N1cyB0aGUgbmV3bHkgc2VsZWN0ZWQgZGF0ZVxuICAgIHRoaXMuZGF5U2VydmljZS5zZXRGb2N1cyhkYXRlLmdldERhdGUoKSwgZGF0ZS5nZXRNb250aCgpLCBkYXRlLmdldEZ1bGxZZWFyKCkpO1xuICB9XG5cbiAgdHJhY2tXZWVrQnlGbihpbmRleDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICB0cmFja0RheUJ5Rm4oaW5kZXg6IG51bWJlciwgaXRlbTogRGF5Vmlld0l0ZW0pOiBzdHJpbmcge1xuICAgIHJldHVybiBgJHsgaXRlbS5kYXkgfSAkeyBpdGVtLm1vbnRoIH0gJHsgaXRlbS55ZWFyIH1gO1xuICB9XG5cbiAgZm9jdXNEYXRlKGl0ZW06IERheVZpZXdJdGVtLCBkYXlPZmZzZXQ6IG51bWJlcik6IHZvaWQge1xuXG4gICAgLy8gZGV0ZXJtaW5lIHRoZSBkYXRlIG9mIHRoZSBkYXlcbiAgICBjb25zdCB0YXJnZXQgPSBuZXcgRGF0ZShpdGVtLmRhdGUuc2V0RGF0ZShpdGVtLmRhdGUuZ2V0RGF0ZSgpICsgZGF5T2Zmc2V0KSk7XG5cbiAgICAvLyBpZGVudGlmeSB3aGljaCBkYXRlIHNob3VsZCBiZSBmb2N1c2VkXG4gICAgdGhpcy5kYXlTZXJ2aWNlLnNldEZvY3VzKHRhcmdldC5nZXREYXRlKCksIHRhcmdldC5nZXRNb250aCgpLCB0YXJnZXQuZ2V0RnVsbFllYXIoKSk7XG4gIH1cblxuICBnZXRUYWJiYWJsZShpdGVtOiBEYXlWaWV3SXRlbSk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGZvY3VzZWQgPSB0aGlzLmRheVNlcnZpY2UuZm9jdXNlZCQudmFsdWU7XG4gICAgY29uc3QgZ3JpZCA9IHRoaXMuZGF5U2VydmljZS5ncmlkJC52YWx1ZTtcblxuICAgIC8vIGlmIHRoZXJlIGlzIGEgZm9jdXNlZCBtb250aCBjaGVjayBpZiB0aGlzIGlzIGl0XG4gICAgaWYgKGZvY3VzZWQpIHtcblxuICAgICAgLy8gY2hlY2sgaWYgdGhlIGZvY3VzZWQgZGF5IGlzIHZpc2libGVcbiAgICAgIGNvbnN0IGlzRm9jdXNlZERheVZpc2libGUgPSAhIWdyaWQuZmluZChyb3cgPT4gISFyb3cuZmluZChfaXRlbSA9PiBfaXRlbS5kYXkgPT09IGZvY3VzZWQuZGF5ICYmIF9pdGVtLm1vbnRoID09PSBmb2N1c2VkLm1vbnRoICYmIF9pdGVtLnllYXIgPT09IGZvY3VzZWQueWVhcikpO1xuXG4gICAgICBpZiAoaXNGb2N1c2VkRGF5VmlzaWJsZSkge1xuICAgICAgICByZXR1cm4gZm9jdXNlZC5kYXkgPT09IGl0ZW0uZGF5ICYmIGZvY3VzZWQubW9udGggPT09IGl0ZW0ubW9udGggJiYgZm9jdXNlZC55ZWFyID09PSBpdGVtLnllYXI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlcmUgaXMgbm8gZm9jdXNhYmxlIGRheSB0aGVuIGNoZWNrIGlmIHRoZXJlIGlzIGEgc2VsZWN0ZWQgZGF5XG4gICAgY29uc3QgaXNTZWxlY3RlZERheVZpc2libGUgPSAhIWdyaWQuZmluZChyb3cgPT4gISFyb3cuZmluZChkYXkgPT4gZGF5LmlzQWN0aXZlKSk7XG5cbiAgICBpZiAoaXNTZWxlY3RlZERheVZpc2libGUpIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0uaXNBY3RpdmU7XG4gICAgfVxuXG4gICAgLy8gb3RoZXJ3aXNlIG1ha2UgdGhlIGZpcnN0IGRheSB0YWJiYWJsZVxuICAgIHJldHVybiBpdGVtLmRheSA9PT0gMTtcbiAgfVxuXG59IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMvT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBtYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBEYXRlUGlja2VyTW9kZSwgRGF0ZVRpbWVQaWNrZXJTZXJ2aWNlIH0gZnJvbSAnLi4vZGF0ZS10aW1lLXBpY2tlci5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1kYXRlLXRpbWUtcGlja2VyLWhlYWRlcicsXG4gICAgdGVtcGxhdGU6IGA8aGVhZGVyIGNsYXNzPVwiaGVhZGVyXCI+XG5cbiAgPGJ1dHRvbiBjbGFzcz1cImhlYWRlci1uYXZpZ2F0aW9uXCJcbiAgICAgICAgICAoY2xpY2spPVwicHJldmlvdXMoKTsgJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXCJcbiAgICAgICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cInByZXZpb3VzQXJpYSQgfCBhc3luY1wiXG4gICAgICAgICAgdGFiaW5kZXg9XCIwXCI+XG5cbiAgICA8aSBjbGFzcz1cImhwZS1pY29uIGhwZS1wcmV2aW91c1wiPjwvaT5cbiAgPC9idXR0b24+XG5cbiAgPGJ1dHRvbiBjbGFzcz1cImhlYWRlci10aXRsZVwiXG4gICAgICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XCJoZWFkZXJBcmlhJCB8IGFzeW5jXCJcbiAgICAgICAgICBbY2xhc3MuYWN0aXZlXT1cImNhbkFzY2VuZCQgfCBhc3luY1wiXG4gICAgICAgICAgKGNsaWNrKT1cImFzY2VuZCgpOyAkZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcIlxuICAgICAgICAgIFt0YWJpbmRleF09XCIoY2FuQXNjZW5kJCB8IGFzeW5jKSA/IDAgOiAtMVwiPlxuICAgICAgIHt7IGRhdGVwaWNrZXIuaGVhZGVyJCB8IGFzeW5jIH19XG4gIDwvYnV0dG9uPlxuXG4gIDxidXR0b24gY2xhc3M9XCJoZWFkZXItbmF2aWdhdGlvblwiXG4gICAgICAgICAgKGNsaWNrKT1cIm5leHQoKTsgJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXCJcbiAgICAgICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cIm5leHRBcmlhJCB8IGFzeW5jXCJcbiAgICAgICAgICB0YWJpbmRleD1cIjBcIj5cblxuICAgIDxpIGNsYXNzPVwiaHBlLWljb24gaHBlLW5leHRcIj48L2k+XG4gIDwvYnV0dG9uPlxuPC9oZWFkZXI+YCxcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxufSlcbmV4cG9ydCBjbGFzcyBIZWFkZXJDb21wb25lbnQge1xuXG4gICAgY2FuQXNjZW5kJDogT2JzZXJ2YWJsZTxib29sZWFuPiA9IHRoaXMuZGF0ZXBpY2tlci5tb2RlJC5waXBlKG1hcChtb2RlID0+IG1vZGUgIT09IERhdGVQaWNrZXJNb2RlLlllYXIpKTtcbiAgICBcbiAgICBtb2RlJDogT2JzZXJ2YWJsZTxzdHJpbmc+ID0gdGhpcy5kYXRlcGlja2VyLm1vZGUkLnBpcGUobWFwKG1vZGUgPT4ge1xuICAgICAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgICAgICAgIGNhc2UgRGF0ZVBpY2tlck1vZGUuRGF5OlxuICAgICAgICAgICAgICAgIHJldHVybiAnRGF5JztcbiAgICAgICAgICAgIGNhc2UgRGF0ZVBpY2tlck1vZGUuTW9udGg6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdNb250aCc7XG4gICAgICAgICAgICBjYXNlIERhdGVQaWNrZXJNb2RlLlllYXI6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdZZWFyJztcbiAgICAgICAgfVxuICAgIH0pKTtcblxuICAgIGhlYWRlckFyaWEkOiBPYnNlcnZhYmxlPHN0cmluZz4gPSB0aGlzLmRhdGVwaWNrZXIubW9kZSQucGlwZShtYXAobW9kZSA9PiB7XG4gICAgICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgICAgICAgY2FzZSBEYXRlUGlja2VyTW9kZS5EYXk6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdTd2l0Y2ggdG8gc2hvdyBtb250aHMgaW4gdGhlIHllYXInO1xuICAgICAgICAgICAgY2FzZSBEYXRlUGlja2VyTW9kZS5Nb250aDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1N3aXRjaCB0byBzaG93IHllYXJzIGluIHRoZSBkZWNhZGUnO1xuICAgICAgICAgICAgY2FzZSBEYXRlUGlja2VyTW9kZS5ZZWFyOlxuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgIH0pKTtcblxuICAgIHByZXZpb3VzQXJpYSQ6IE9ic2VydmFibGU8c3RyaW5nPiA9IHRoaXMuZGF0ZXBpY2tlci5tb2RlJC5waXBlKG1hcChtb2RlID0+IHtcbiAgICAgICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICAgICAgICBjYXNlIERhdGVQaWNrZXJNb2RlLkRheTpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1ByZXZpb3VzIG1vbnRoJztcbiAgICAgICAgICAgIGNhc2UgRGF0ZVBpY2tlck1vZGUuTW9udGg6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdQcmV2aW91cyB5ZWFyJztcbiAgICAgICAgICAgIGNhc2UgRGF0ZVBpY2tlck1vZGUuWWVhcjpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1ByZXZpb3VzIGRlY2FkZSc7XG4gICAgICAgIH1cbiAgICB9KSk7XG5cbiAgICBuZXh0QXJpYSQ6IE9ic2VydmFibGU8c3RyaW5nPiA9IHRoaXMuZGF0ZXBpY2tlci5tb2RlJC5waXBlKG1hcChtb2RlID0+IHtcbiAgICAgICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICAgICAgICBjYXNlIERhdGVQaWNrZXJNb2RlLkRheTpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ05leHQgbW9udGgnO1xuICAgICAgICAgICAgY2FzZSBEYXRlUGlja2VyTW9kZS5Nb250aDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ05leHQgeWVhcic7XG4gICAgICAgICAgICBjYXNlIERhdGVQaWNrZXJNb2RlLlllYXI6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdOZXh0IGRlY2FkZSc7XG4gICAgICAgIH1cbiAgICB9KSk7XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZGF0ZXBpY2tlcjogRGF0ZVRpbWVQaWNrZXJTZXJ2aWNlKSB7IH1cblxuICAgIHByZXZpb3VzKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmRhdGVwaWNrZXIuZ29Ub1ByZXZpb3VzKCk7XG4gICAgfVxuXG4gICAgYXNjZW5kKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmRhdGVwaWNrZXIuZ29Ub1BhcmVudE1vZGUoKTtcbiAgICB9XG5cbiAgICBuZXh0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLmRhdGVwaWNrZXIuZ29Ub05leHQoKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgSW5qZWN0YWJsZSwgT25EZXN0cm95IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QgfSBmcm9tICdyeGpzL0JlaGF2aW9yU3ViamVjdCc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBEYXRlVGltZVBpY2tlclNlcnZpY2UsIE1vZGVEaXJlY3Rpb24gfSBmcm9tICcuLi9kYXRlLXRpbWUtcGlja2VyLnNlcnZpY2UnO1xuaW1wb3J0IHsgZ3JpZGlmeSwgbW9udGhzU2hvcnQsIHJhbmdlIH0gZnJvbSAnLi4vZGF0ZS10aW1lLXBpY2tlci51dGlscyc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBNb250aFZpZXdTZXJ2aWNlIGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICAgIGdyaWQkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxNb250aFZpZXdJdGVtW11bXT4oW1tdXSk7XG4gICAgZm9jdXNlZCQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PEZvY3VzZWRNb250aEl0ZW0+KG51bGwpO1xuXG4gICAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9kYXRlcGlja2VyOiBEYXRlVGltZVBpY2tlclNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gX2RhdGVwaWNrZXIueWVhciQuc3Vic2NyaWJlKHllYXIgPT4gdGhpcy5jcmVhdGVNb250aEdyaWQoeWVhcikpO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG5cbiAgICBzZXRGb2N1cyhtb250aDogbnVtYmVyLCB5ZWFyOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5mb2N1c2VkJC5uZXh0KHsgbW9udGg6IG1vbnRoLCB5ZWFyOiB5ZWFyIH0pO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgdmlld3BvcnQgdG8gZW5zdXJlIGZvY3VzZWQgbW9udGggaXMgdmlzaWJsZVxuICAgICAgICB0aGlzLl9kYXRlcGlja2VyLnNldFZpZXdwb3J0WWVhcih5ZWFyKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGNyZWF0ZU1vbnRoR3JpZCh5ZWFyOiBudW1iZXIpOiB2b2lkIHtcblxuICAgICAgICAvLyB1cGRhdGUgdGhlIGhlYWRlclxuICAgICAgICB0aGlzLl9kYXRlcGlja2VyLnNldEhlYWRlcih5ZWFyLnRvU3RyaW5nKCkpO1xuXG4gICAgICAgIC8vIGdldCB0aGUgY3VycmVudCB5ZWFyIGFuZCBtb250aFxuICAgICAgICBjb25zdCBjdXJyZW50TW9udGggPSBuZXcgRGF0ZSgpLmdldE1vbnRoKCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRZZWFyID0gbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpO1xuXG4gICAgICAgIC8vIGdldCB0aGUgY3VycmVudGx5IHNlbGVjdGVkIG1vbnRoXG4gICAgICAgIGNvbnN0IGFjdGl2ZU1vbnRoID0gdGhpcy5fZGF0ZXBpY2tlci5zZWxlY3RlZCQudmFsdWUuZ2V0TW9udGgoKTtcbiAgICAgICAgY29uc3QgYWN0aXZlWWVhciA9IHRoaXMuX2RhdGVwaWNrZXIuc2VsZWN0ZWQkLnZhbHVlLmdldEZ1bGxZZWFyKCk7XG5cbiAgICAgICAgLy8gY3JlYXRlIGEgNHgzIGdyaWQgb2YgbW9udGggbnVtYmVyc1xuICAgICAgICBjb25zdCBtb250aHM6IE1vbnRoVmlld0l0ZW1bXSA9IHJhbmdlKDAsIDExKS5tYXAobW9udGggPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBtb250aHNTaG9ydFttb250aF0sXG4gICAgICAgICAgICAgICAgbW9udGg6IG1vbnRoLFxuICAgICAgICAgICAgICAgIHllYXI6IHllYXIsXG4gICAgICAgICAgICAgICAgaXNDdXJyZW50TW9udGg6IHllYXIgPT09IGN1cnJlbnRZZWFyICYmIG1vbnRoID09PSBjdXJyZW50TW9udGgsXG4gICAgICAgICAgICAgICAgaXNBY3RpdmVNb250aDogeWVhciA9PT0gYWN0aXZlWWVhciAmJiBtb250aCA9PT0gYWN0aXZlTW9udGhcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIG1hcCB0aGVzZSB0byB0aGUgYXBwcm9wcmlhdGUgZm9ybWF0XG4gICAgICAgIGNvbnN0IGl0ZW1zOiBNb250aFZpZXdJdGVtW11bXSA9IGdyaWRpZnkobW9udGhzLCA0KTtcblxuICAgICAgICAvLyB1cGRhdGUgdGhlIGdyaWRcbiAgICAgICAgdGhpcy5ncmlkJC5uZXh0KGl0ZW1zKTtcblxuICAgICAgICAvLyBpZiB0aGVyZSBpcyBubyBmb2N1c2VkIG1vbnRoIHNlbGVjdCB0aGUgZmlyc3Qgb25lXG4gICAgICAgIGlmICh0aGlzLl9kYXRlcGlja2VyLm1vZGVEaXJlY3Rpb24gPT09IE1vZGVEaXJlY3Rpb24uRGVzY2VuZCAmJiB0aGlzLmZvY3VzZWQkLnZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBzZWxlY3RlZCBtb250aCBpcyBpbiB2aWV3XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RlZE1vbnRoID0gbW9udGhzLmZpbmQobW9udGggPT4gbW9udGguaXNBY3RpdmVNb250aCk7XG5cbiAgICAgICAgICAgIHRoaXMuc2V0Rm9jdXMoc2VsZWN0ZWRNb250aCA/IHNlbGVjdGVkTW9udGgubW9udGggOiAwLCB5ZWFyKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBNb250aFZpZXdJdGVtIHtcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgbW9udGg6IG51bWJlcjtcbiAgICB5ZWFyOiBudW1iZXI7XG4gICAgaXNDdXJyZW50TW9udGg6IGJvb2xlYW47XG4gICAgaXNBY3RpdmVNb250aDogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGb2N1c2VkTW9udGhJdGVtIHtcbiAgICBtb250aDogbnVtYmVyO1xuICAgIHllYXI6IG51bWJlcjtcbn0iLCJpbXBvcnQgeyBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgQ29tcG9uZW50LCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IERhdGVQaWNrZXJIZWFkZXJFdmVudCwgRGF0ZVRpbWVQaWNrZXJTZXJ2aWNlIH0gZnJvbSAnLi4vZGF0ZS10aW1lLXBpY2tlci5zZXJ2aWNlJztcbmltcG9ydCB7IE1vbnRoVmlld0l0ZW0sIE1vbnRoVmlld1NlcnZpY2UgfSBmcm9tICcuL21vbnRoLXZpZXcuc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtZGF0ZS10aW1lLXBpY2tlci1tb250aC12aWV3JyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJjYWxlbmRhclwiIHJvbGU9XCJncmlkXCI+XG4gIDxkaXYgY2xhc3M9XCJjYWxlbmRhci1yb3dcIiAqbmdGb3I9XCJsZXQgcm93IG9mIG1vbnRoU2VydmljZS5ncmlkJCB8IGFzeW5jOyB0cmFja0J5OiB0cmFja1Jvd0J5Rm5cIiByb2xlPVwicm93XCI+XG5cbiAgICA8YnV0dG9uIHJvbGU9XCJncmlkY2VsbFwiXG4gICAgICAgICBjbGFzcz1cImNhbGVuZGFyLWl0ZW1cIlxuICAgICAgICAgKm5nRm9yPVwibGV0IGl0ZW0gb2Ygcm93OyB0cmFja0J5OiB0cmFja01vbnRoQnlGblwiXG4gICAgICAgICBbZm9jdXNJZl09XCIobW9udGhTZXJ2aWNlLmZvY3VzZWQkIHwgYXN5bmMpPy5tb250aCA9PT0gaXRlbS5tb250aCAmJiAobW9udGhTZXJ2aWNlLmZvY3VzZWQkIHwgYXN5bmMpPy55ZWFyID09PSBpdGVtLnllYXJcIlxuICAgICAgICAgW3RhYmluZGV4XT1cImdldFRhYmJhYmxlKGl0ZW0pID8gMCA6IC0xXCJcbiAgICAgICAgIFthdHRyLmFyaWEtbGFiZWxdPVwiaXRlbS5uYW1lICsgJyAnICsgaXRlbS55ZWFyXCJcbiAgICAgICAgIFthdHRyLmFyaWEtc2VsZWN0ZWRdPVwiaXRlbS5pc0FjdGl2ZU1vbnRoXCJcbiAgICAgICAgIFtjbGFzcy5hY3RpdmVdPVwiaXRlbS5pc0FjdGl2ZU1vbnRoXCJcbiAgICAgICAgIFtjbGFzcy5jdXJyZW50XT1cIml0ZW0uaXNDdXJyZW50TW9udGhcIlxuICAgICAgICAgKGNsaWNrKT1cInNlbGVjdChpdGVtLm1vbnRoKTsgJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXCJcbiAgICAgICAgIChrZXlkb3duLkFycm93TGVmdCk9XCJmb2N1c01vbnRoKGl0ZW0sIC0xKTsgJGV2ZW50LnByZXZlbnREZWZhdWx0KClcIlxuICAgICAgICAgKGtleWRvd24uQXJyb3dSaWdodCk9XCJmb2N1c01vbnRoKGl0ZW0sIDEpOyAkZXZlbnQucHJldmVudERlZmF1bHQoKVwiXG4gICAgICAgICAoa2V5ZG93bi5BcnJvd1VwKT1cImZvY3VzTW9udGgoaXRlbSwgLTQpOyAkZXZlbnQucHJldmVudERlZmF1bHQoKVwiXG4gICAgICAgICAoa2V5ZG93bi5BcnJvd0Rvd24pPVwiZm9jdXNNb250aChpdGVtLCA0KTsgJGV2ZW50LnByZXZlbnREZWZhdWx0KClcIj5cbiAgICAgICAgIHt7IGl0ZW0ubmFtZSB9fVxuICAgIDwvYnV0dG9uPlxuICA8L2Rpdj5cbjwvZGl2PlxuYCxcbiAgICBwcm92aWRlcnM6IFtNb250aFZpZXdTZXJ2aWNlXSxcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxufSlcbmV4cG9ydCBjbGFzcyBNb250aFZpZXdDb21wb25lbnQgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuXG4gICAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9kYXRlUGlja2VyOiBEYXRlVGltZVBpY2tlclNlcnZpY2UsIHB1YmxpYyBtb250aFNlcnZpY2U6IE1vbnRoVmlld1NlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gX2RhdGVQaWNrZXIuaGVhZGVyRXZlbnQkXG4gICAgICAgICAgICAuc3Vic2NyaWJlKGV2ZW50ID0+IGV2ZW50ID09PSBEYXRlUGlja2VySGVhZGVyRXZlbnQuTmV4dCA/IHRoaXMubmV4dCgpIDogdGhpcy5wcmV2aW91cygpKTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR28gdG8gdGhlIHByZXZpb3VzIHllYXJcbiAgICAgKi9cbiAgICBwcmV2aW91cygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fZGF0ZVBpY2tlci5zZXRWaWV3cG9ydFllYXIodGhpcy5fZGF0ZVBpY2tlci55ZWFyJC52YWx1ZSAtIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdvIHRvIHRoZSBuZXh0IHllYXJcbiAgICAgKi9cbiAgICBuZXh0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9kYXRlUGlja2VyLnNldFZpZXdwb3J0WWVhcih0aGlzLl9kYXRlUGlja2VyLnllYXIkLnZhbHVlICsgMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0IGEgbW9udGggaW4gdGhlIGNhbGVuZGFyXG4gICAgICogQHBhcmFtIG1vbnRoIHRoZSBpbmRleCBvZiB0aGUgbW9udGggdG8gc2VsZWN0XG4gICAgICovXG4gICAgc2VsZWN0KG1vbnRoOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fZGF0ZVBpY2tlci5zZXRWaWV3cG9ydE1vbnRoKG1vbnRoKTtcblxuICAgICAgICAvLyBzaG93IHRoZSBkYXkgcGlja2VyXG4gICAgICAgIHRoaXMuX2RhdGVQaWNrZXIuZ29Ub0NoaWxkTW9kZSgpO1xuICAgIH1cblxuICAgIGZvY3VzTW9udGgoaXRlbTogTW9udGhWaWV3SXRlbSwgbW9udGhPZmZzZXQ6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBsZXQgdGFyZ2V0TW9udGggPSBpdGVtLm1vbnRoICsgbW9udGhPZmZzZXQ7XG4gICAgICAgIGxldCB0YXJnZXRZZWFyID0gaXRlbS55ZWFyO1xuXG4gICAgICAgIGlmICh0YXJnZXRNb250aCA8IDApIHtcbiAgICAgICAgICAgIHRhcmdldE1vbnRoICs9IDEyO1xuICAgICAgICAgICAgdGFyZ2V0WWVhciAtPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRhcmdldE1vbnRoID49IDEyKSB7XG4gICAgICAgICAgICB0YXJnZXRNb250aCAtPSAxMjtcbiAgICAgICAgICAgIHRhcmdldFllYXIgKz0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubW9udGhTZXJ2aWNlLnNldEZvY3VzKHRhcmdldE1vbnRoLCB0YXJnZXRZZWFyKTtcbiAgICB9XG5cbiAgICB0cmFja1Jvd0J5Rm4oaW5kZXg6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG5cbiAgICB0cmFja01vbnRoQnlGbihpbmRleDogbnVtYmVyLCBpdGVtOiBNb250aFZpZXdJdGVtKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIGAke2l0ZW0ubW9udGh9ICR7aXRlbS55ZWFyfWA7XG4gICAgfVxuXG4gICAgZ2V0VGFiYmFibGUoaXRlbTogTW9udGhWaWV3SXRlbSk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBmb2N1c2VkID0gdGhpcy5tb250aFNlcnZpY2UuZm9jdXNlZCQudmFsdWU7XG4gICAgICAgIGNvbnN0IGdyaWQgPSB0aGlzLm1vbnRoU2VydmljZS5ncmlkJC52YWx1ZTtcblxuICAgICAgICAvLyBpZiB0aGVyZSBpcyBhIGZvY3VzZWQgbW9udGggY2hlY2sgaWYgdGhpcyBpcyBpdFxuICAgICAgICBpZiAoZm9jdXNlZCkge1xuXG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgZm9jdXNlZCBtb250aCBpcyB2aXNpYmxlXG4gICAgICAgICAgICBjb25zdCBpc0ZvY3VzZWRNb250aFZpc2libGUgPSAhIWdyaWQuZmluZChyb3cgPT4gISFyb3cuZmluZChfaXRlbSA9PiBfaXRlbS5tb250aCA9PT0gZm9jdXNlZC5tb250aCAmJiBfaXRlbS55ZWFyID09PSBmb2N1c2VkLnllYXIpKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGlzRm9jdXNlZE1vbnRoVmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmb2N1c2VkLm1vbnRoID09PSBpdGVtLm1vbnRoICYmIGZvY3VzZWQueWVhciA9PT0gaXRlbS55ZWFyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gZm9jdXNhYmxlIG1vbnRoIHRoZW4gY2hlY2sgaWYgdGhlcmUgaXMgYSBzZWxlY3RlZCBtb250aFxuICAgICAgICBjb25zdCBpc1NlbGVjdGVkTW9udGhWaXNpYmxlID0gISFncmlkLmZpbmQocm93ID0+ICEhcm93LmZpbmQobW9udGggPT4gbW9udGguaXNBY3RpdmVNb250aCkpO1xuXG4gICAgICAgIGlmIChpc1NlbGVjdGVkTW9udGhWaXNpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS5pc0FjdGl2ZU1vbnRoO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gb3RoZXJ3aXNlIG1ha2UgdGhlIGZpcnN0IG1vbnRoIHRhYmJhYmxlXG4gICAgICAgIHJldHVybiBpdGVtLm1vbnRoID09PSAwO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBDb21wb25lbnQsIENoYW5nZURldGVjdGlvblN0cmF0ZWd5IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBEYXRlVGltZVBpY2tlclNlcnZpY2UgfSBmcm9tICcuLi9kYXRlLXRpbWUtcGlja2VyLnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LWRhdGUtdGltZS1waWNrZXItdGltZS12aWV3JyxcbiAgICB0ZW1wbGF0ZTogYDx1eC10aW1lLXBpY2tlciAqbmdJZj1cImRhdGVwaWNrZXIuc2hvd1RpbWUkIHwgYXN5bmNcIlxuICAgIFt2YWx1ZV09XCJkYXRlcGlja2VyLnNlbGVjdGVkJCB8IGFzeW5jXCJcbiAgICAodmFsdWVDaGFuZ2UpPVwiZGF0ZXBpY2tlci5zZWxlY3RlZCQubmV4dCgkZXZlbnQpXCJcbiAgICBbc2hvd1NlY29uZHNdPVwiZGF0ZXBpY2tlci5zaG93U2Vjb25kcyQgfCBhc3luY1wiXG4gICAgW3Nob3dNZXJpZGlhbl09XCJkYXRlcGlja2VyLnNob3dNZXJpZGlhbiQgfCBhc3luY1wiXG4gICAgW3Nob3dTcGlubmVyc109XCJkYXRlcGlja2VyLnNob3dTcGlubmVycyQgfCBhc3luY1wiPlxuPC91eC10aW1lLXBpY2tlcj5cblxuPG5nLWNvbnRhaW5lciAqbmdJZj1cImRhdGVwaWNrZXIuc2hvd1RpbWV6b25lJCB8IGFzeW5jXCI+XG5cbiAgICA8ZGl2IGNsYXNzPVwidGltZS16b25lLXBpY2tlclwiICpuZ0lmPVwiZGF0ZXBpY2tlci5zaG93U3Bpbm5lcnMkIHwgYXN5bmNcIj5cblxuICAgICAgICA8dXgtc3Bpbi1idXR0b25cbiAgICAgICAgICAgIGNsYXNzPVwidGltZS16b25lLXNwaW5uZXJcIlxuICAgICAgICAgICAgW3ZhbHVlXT1cIihkYXRlcGlja2VyLnRpbWV6b25lJCB8IGFzeW5jKS5uYW1lXCJcbiAgICAgICAgICAgIFtyZWFkT25seV09XCJ0cnVlXCJcbiAgICAgICAgICAgIChpbmNyZW1lbnQpPVwiaW5jcmVtZW50VGltZXpvbmUoKVwiXG4gICAgICAgICAgICAoZGVjcmVtZW50KT1cImRlY3JlbWVudFRpbWV6b25lKClcIlxuICAgICAgICAgICAgaW5wdXRBcmlhTGFiZWw9XCJUaW1lIFpvbmVcIlxuICAgICAgICAgICAgaW5jcmVtZW50QXJpYUxhYmVsPVwiU3dpdGNoIHRvIHRoZSBuZXh0IHRpbWUgem9uZVwiXG4gICAgICAgICAgICBkZWNyZW1lbnRBcmlhTGFiZWw9XCJTd2l0Y2ggdG8gdGhlIHByZXZpb3VzIHRpbWUgem9uZVwiPlxuICAgICAgICA8L3V4LXNwaW4tYnV0dG9uPlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cInRpbWUtem9uZS1waWNrZXJcIiAqbmdJZj1cIiEoZGF0ZXBpY2tlci5zaG93U3Bpbm5lcnMkIHwgYXN5bmMpXCI+XG5cbiAgICAgICAgPHNlbGVjdCBjbGFzcz1cImZvcm0tY29udHJvbCB0aW1lLXpvbmUtc2VsZWN0XCJcbiAgICAgICAgICAgICAgICB0YWJpbmRleD1cIjBcIlxuICAgICAgICAgICAgICAgIFtuZ01vZGVsXT1cIihkYXRlcGlja2VyLnRpbWV6b25lJCB8IGFzeW5jKS5uYW1lXCJcbiAgICAgICAgICAgICAgICAobmdNb2RlbENoYW5nZSk9XCJzZWxlY3RUaW1lem9uZSgkZXZlbnQpXCJcbiAgICAgICAgICAgICAgICBhcmlhLWxhYmVsPVwiVGltZXpvbmVcIlxuICAgICAgICAgICAgICAgIFthdHRyLmFyaWEtdmFsdWVub3ddPVwiKGRhdGVwaWNrZXIudGltZXpvbmUkIHwgYXN5bmMpLm5hbWVcIj5cblxuICAgICAgICAgICAgPG9wdGlvbiAqbmdGb3I9XCJsZXQgem9uZSBvZiBkYXRlcGlja2VyLnRpbWV6b25lcyQgfCBhc3luY1wiXG4gICAgICAgICAgICAgICAgICAgIFtzZWxlY3RlZF09XCJ6b25lLm5hbWUgPT09IChkYXRlcGlja2VyLnRpbWV6b25lJCB8IGFzeW5jKS5uYW1lXCJcbiAgICAgICAgICAgICAgICAgICAgW3ZhbHVlXT1cInpvbmUubmFtZVwiPlxuICAgICAgICAgICAgICAgIHt7IHpvbmU/Lm5hbWUgfX1cbiAgICAgICAgICAgIDwvb3B0aW9uPlxuXG4gICAgICAgIDwvc2VsZWN0PlxuICAgIDwvZGl2PlxuXG48L25nLWNvbnRhaW5lcj5cbmAsXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgVGltZVZpZXdDb21wb25lbnQge1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGRhdGVwaWNrZXI6IERhdGVUaW1lUGlja2VyU2VydmljZSkgeyB9XG5cbiAgICBzZWxlY3RUaW1lem9uZShuYW1lOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgdGltZXpvbmVzID0gdGhpcy5kYXRlcGlja2VyLnRpbWV6b25lcyQudmFsdWU7XG4gICAgICAgIFxuICAgICAgICAvLyBmaW5kIG1hdGNoaW5nIHRpbWV6b25lXG4gICAgICAgIGNvbnN0IHRpbWV6b25lID0gdGltZXpvbmVzLmZpbmQoX3RpbWV6b25lID0+IF90aW1lem9uZS5uYW1lID09PSBuYW1lKTtcblxuICAgICAgICBpZiAodGltZXpvbmUpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0ZXBpY2tlci5zZXRUaW1lem9uZSh0aW1lem9uZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpbmNyZW1lbnRUaW1lem9uZSgpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgdGltZXpvbmUgPSB0aGlzLmRhdGVwaWNrZXIudGltZXpvbmUkLnZhbHVlO1xuICAgICAgICBjb25zdCB0aW1lem9uZXMgPSB0aGlzLmRhdGVwaWNrZXIudGltZXpvbmVzJC52YWx1ZTtcblxuICAgICAgICBjb25zdCBjdXJyZW50Wm9uZSA9IHRpbWV6b25lcy5maW5kSW5kZXgoem9uZSA9PiB6b25lLm5hbWUgPT09IHRpbWV6b25lLm5hbWUgJiYgem9uZS5vZmZzZXQgPT09IHRpbWV6b25lLm9mZnNldCk7XG5cbiAgICAgICAgLy8gdHJ5IHRvIGdldCB0aGUgcHJldmlvdXMgem9uZVxuICAgICAgICB0aGlzLmRhdGVwaWNrZXIuc2V0VGltZXpvbmUodGltZXpvbmVzW2N1cnJlbnRab25lICsgMV0gPyB0aW1lem9uZXNbY3VycmVudFpvbmUgKyAxXSA6IHRpbWV6b25lc1tjdXJyZW50Wm9uZV0pO1xuICAgIH1cblxuICAgIGRlY3JlbWVudFRpbWV6b25lKCk6IHZvaWQge1xuICAgICAgICBjb25zdCB0aW1lem9uZSA9IHRoaXMuZGF0ZXBpY2tlci50aW1lem9uZSQudmFsdWU7XG4gICAgICAgIGNvbnN0IHRpbWV6b25lcyA9IHRoaXMuZGF0ZXBpY2tlci50aW1lem9uZXMkLnZhbHVlO1xuXG4gICAgICAgIGNvbnN0IGN1cnJlbnRab25lID0gdGltZXpvbmVzLmZpbmRJbmRleCh6b25lID0+IHpvbmUubmFtZSA9PT0gdGltZXpvbmUubmFtZSAmJiB6b25lLm9mZnNldCA9PT0gdGltZXpvbmUub2Zmc2V0KTtcblxuICAgICAgICAvLyB0cnkgdG8gZ2V0IHRoZSBwcmV2aW91cyB6b25lXG4gICAgICAgIHRoaXMuZGF0ZXBpY2tlci5zZXRUaW1lem9uZSh0aW1lem9uZXNbY3VycmVudFpvbmUgLSAxXSA/IHRpbWV6b25lc1tjdXJyZW50Wm9uZSAtIDFdIDogdGltZXpvbmVzW2N1cnJlbnRab25lXSk7XG4gICAgfVxufSIsImltcG9ydCB7IEluamVjdGFibGUsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcy9CZWhhdmlvclN1YmplY3QnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcy9TdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgRGF0ZVBpY2tlckhlYWRlckV2ZW50LCBEYXRlVGltZVBpY2tlclNlcnZpY2UgfSBmcm9tICcuLi9kYXRlLXRpbWUtcGlja2VyLnNlcnZpY2UnO1xuaW1wb3J0IHsgZ3JpZGlmeSwgcmFuZ2UgfSBmcm9tICcuLi9kYXRlLXRpbWUtcGlja2VyLnV0aWxzJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFllYXJWaWV3U2VydmljZSBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG5cbiAgICBncmlkJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8WWVhclZpZXdJdGVtW11bXT4oW1tdXSk7XG4gICAgZm9jdXNlZCQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PG51bWJlcj4obnVsbCk7XG5cbiAgICBwcml2YXRlIF95ZWFyOiBudW1iZXIgPSBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCk7XG5cbiAgICBwcml2YXRlIF9zdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9kYXRlcGlja2VyOiBEYXRlVGltZVBpY2tlclNlcnZpY2UpIHtcbiAgICAgICAgY29uc3QgeWVhciA9IF9kYXRlcGlja2VyLnllYXIkLnN1YnNjcmliZShfeWVhciA9PiB0aGlzLmNyZWF0ZVllYXJHcmlkKF95ZWFyKSk7XG5cbiAgICAgICAgY29uc3QgZXZlbnQgPSBfZGF0ZXBpY2tlci5oZWFkZXJFdmVudCRcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoX2V2ZW50ID0+IF9ldmVudCA9PT0gRGF0ZVBpY2tlckhlYWRlckV2ZW50Lk5leHQgPyB0aGlzLmdvVG9OZXh0RGVjYWRlKCkgOiB0aGlzLmdvVG9QcmV2aW91c0RlY2FkZSgpKTtcblxuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24uYWRkKHllYXIpO1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24uYWRkKGV2ZW50KTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuXG4gICAgc2V0Rm9jdXMoeWVhcjogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZm9jdXNlZCQubmV4dCh5ZWFyKTtcbiAgICAgICAgdGhpcy5jcmVhdGVZZWFyR3JpZCh5ZWFyKTtcbiAgICB9XG5cbiAgICBnb1RvUHJldmlvdXNEZWNhZGUoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuY3JlYXRlWWVhckdyaWQodGhpcy5feWVhciAtIDEwKTtcbiAgICB9XG5cbiAgICBnb1RvTmV4dERlY2FkZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5jcmVhdGVZZWFyR3JpZCh0aGlzLl95ZWFyICsgMTApO1xuICAgIH1cblxuICAgIHByaXZhdGUgY3JlYXRlWWVhckdyaWQoeWVhcjogbnVtYmVyID0gdGhpcy5feWVhcik6IHZvaWQge1xuXG4gICAgICAgIHRoaXMuX3llYXIgPSB5ZWFyO1xuXG4gICAgICAgIC8vIGdldCB0aGUgeWVhcnMgdG8gZGlzcGxheVxuICAgICAgICBjb25zdCBkZWNhZGUgPSB0aGlzLmdldERlY2FkZSh5ZWFyKTtcblxuICAgICAgICBjb25zdCBjdXJyZW50WWVhciA9IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKTtcblxuICAgICAgICAvLyBwcm9kdWNlIGl0ZW1zIGluIHRoZSBjb3JyZWN0IGZvcm1hdFxuICAgICAgICBjb25zdCBpdGVtczogWWVhclZpZXdJdGVtW10gPSBkZWNhZGUucmFuZ2UubWFwKF95ZWFyID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgeWVhcjogX3llYXIsXG4gICAgICAgICAgICAgICAgaXNDdXJyZW50WWVhcjogX3llYXIgPT09IGN1cnJlbnRZZWFyLFxuICAgICAgICAgICAgICAgIGlzQWN0aXZlWWVhcjogX3llYXIgPT09IHRoaXMuX2RhdGVwaWNrZXIueWVhciQudmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgaGVhZGVyIHRleHRcbiAgICAgICAgdGhpcy5fZGF0ZXBpY2tlci5zZXRIZWFkZXIoZGVjYWRlLnN0YXJ0ICsgJyAtICcgKyBkZWNhZGUuZW5kKTtcblxuICAgICAgICAvLyBjcmVhdGUgdGhlIGdyaWRcbiAgICAgICAgdGhpcy5ncmlkJC5uZXh0KGdyaWRpZnkoaXRlbXMsIDQpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHllYXJzIGluIHRoZSBjdXJyZW50IGRlY2FkZSB0byBkaXNwbGF5XG4gICAgICovXG4gICAgcHJpdmF0ZSBnZXREZWNhZGUoeWVhcjogbnVtYmVyKTogWWVhclJhbmdlIHtcblxuICAgICAgICAvLyBmaWd1cmUgdGhlIHN0YXJ0IGFuZCBlbmQgcG9pbnRzXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gKHllYXIgLSAoeWVhciAlIDEwKSk7XG4gICAgICAgIGNvbnN0IGVuZCA9IHN0YXJ0ICsgOTtcblxuICAgICAgICAvLyBjcmVhdGUgYW4gYXJyYXkgY29udGFpbmluZyBhbGwgdGhlIG51bWJlcnMgYmV0d2VlbiB0aGUgc3RhcnQgYW5kIGVuZCBwb2ludHNcbiAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCwgcmFuZ2U6IHJhbmdlKHN0YXJ0LCBlbmQpIH07XG4gICAgfVxufVxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgWWVhclJhbmdlIHtcbiAgICBzdGFydDogbnVtYmVyO1xuICAgIGVuZDogbnVtYmVyO1xuICAgIHJhbmdlOiBudW1iZXJbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBZZWFyVmlld0l0ZW0ge1xuICAgIHllYXI6IG51bWJlcjtcbiAgICBpc0N1cnJlbnRZZWFyOiBib29sZWFuO1xuICAgIGlzQWN0aXZlWWVhcjogYm9vbGVhbjtcbn0iLCJpbXBvcnQgeyBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBEYXRlVGltZVBpY2tlclNlcnZpY2UgfSBmcm9tICcuLi9kYXRlLXRpbWUtcGlja2VyLnNlcnZpY2UnO1xuaW1wb3J0IHsgWWVhclZpZXdJdGVtLCBZZWFyVmlld1NlcnZpY2UgfSBmcm9tICcuL3llYXItdmlldy5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAndXgtZGF0ZS10aW1lLXBpY2tlci15ZWFyLXZpZXcnLFxuICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJjYWxlbmRhclwiIHJvbGU9XCJncmlkXCI+XG4gIDxkaXYgY2xhc3M9XCJjYWxlbmRhci1yb3dcIiByb2xlPVwicm93XCIgKm5nRm9yPVwibGV0IHJvdyBvZiB5ZWFyU2VydmljZS5ncmlkJCB8IGFzeW5jOyB0cmFja0J5OiB0cmFja1Jvd0J5Rm5cIj5cblxuICAgIDxidXR0b24gKm5nRm9yPVwibGV0IGl0ZW0gb2Ygcm93OyB0cmFja0J5OiB0cmFja1llYXJCeUZuXCJcbiAgICAgICAgIHJvbGU9XCJncmlkY2VsbFwiXG4gICAgICAgICBjbGFzcz1cImNhbGVuZGFyLWl0ZW1cIlxuICAgICAgICAgW2ZvY3VzSWZdPVwiKHllYXJTZXJ2aWNlLmZvY3VzZWQkIHwgYXN5bmMpID09PSBpdGVtLnllYXJcIlxuICAgICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XCJpdGVtLnllYXJcIlxuICAgICAgICAgW2F0dHIuYXJpYS1zZWxlY3RlZF09XCJpdGVtLmlzQWN0aXZlWWVhclwiXG4gICAgICAgICBbY2xhc3MuY3VycmVudF09XCJpdGVtLmlzQ3VycmVudFllYXJcIlxuICAgICAgICAgW2NsYXNzLmFjdGl2ZV09XCJpdGVtLmlzQWN0aXZlWWVhclwiXG4gICAgICAgICAoY2xpY2spPVwic2VsZWN0KGl0ZW0ueWVhcik7ICRldmVudC5zdG9wUHJvcGFnYXRpb24oKVwiXG4gICAgICAgICAoa2V5ZG93bi5BcnJvd0xlZnQpPVwiZm9jdXNZZWFyKGl0ZW0sIC0xKTsgJGV2ZW50LnByZXZlbnREZWZhdWx0KClcIlxuICAgICAgICAgKGtleWRvd24uQXJyb3dSaWdodCk9XCJmb2N1c1llYXIoaXRlbSwgMSk7ICRldmVudC5wcmV2ZW50RGVmYXVsdCgpXCJcbiAgICAgICAgIChrZXlkb3duLkFycm93VXApPVwiZm9jdXNZZWFyKGl0ZW0sIC00KTsgJGV2ZW50LnByZXZlbnREZWZhdWx0KClcIlxuICAgICAgICAgKGtleWRvd24uQXJyb3dEb3duKT1cImZvY3VzWWVhcihpdGVtLCA0KTsgJGV2ZW50LnByZXZlbnREZWZhdWx0KClcIlxuICAgICAgICAgW3RhYmluZGV4XT1cImdldFRhYmJhYmxlKGl0ZW0pID8gMCA6IC0xXCI+XG4gICAgICAgICB7eyBpdGVtLnllYXIgfX1cbiAgICA8L2J1dHRvbj5cbiAgPC9kaXY+XG48L2Rpdj5cbmAsXG4gIHByb3ZpZGVyczogW1llYXJWaWV3U2VydmljZV0sXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG59KVxuZXhwb3J0IGNsYXNzIFllYXJWaWV3Q29tcG9uZW50IHtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9kYXRlUGlja2VyOiBEYXRlVGltZVBpY2tlclNlcnZpY2UsIHB1YmxpYyB5ZWFyU2VydmljZTogWWVhclZpZXdTZXJ2aWNlKSB7fVxuXG4gIHNlbGVjdCh5ZWFyOiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLl9kYXRlUGlja2VyLnNldFZpZXdwb3J0WWVhcih5ZWFyKTtcblxuICAgIC8vIHNob3cgdGhlIG1vbnRoIHBpY2tlclxuICAgIHRoaXMuX2RhdGVQaWNrZXIuZ29Ub0NoaWxkTW9kZSgpO1xuICB9XG5cbiAgZm9jdXNZZWFyKGl0ZW06IFllYXJWaWV3SXRlbSwgeWVhck9mZnNldDogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy55ZWFyU2VydmljZS5zZXRGb2N1cyhpdGVtLnllYXIgKyB5ZWFyT2Zmc2V0KTtcbiAgfVxuXG4gIHRyYWNrUm93QnlGbihpbmRleDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICB0cmFja1llYXJCeUZuKGluZGV4OiBudW1iZXIsIGl0ZW06IFllYXJWaWV3SXRlbSk6IG51bWJlciB7XG4gICAgcmV0dXJuIGl0ZW0ueWVhcjtcbiAgfVxuXG4gIGdldFRhYmJhYmxlKGl0ZW06IFllYXJWaWV3SXRlbSk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGZvY3VzZWQgPSB0aGlzLnllYXJTZXJ2aWNlLmZvY3VzZWQkLnZhbHVlO1xuICAgIGNvbnN0IGdyaWQgPSB0aGlzLnllYXJTZXJ2aWNlLmdyaWQkLnZhbHVlO1xuXG4gICAgLy8gaWYgdGhlcmUgaXMgYSBmb2N1c2VkIHllYXIgY2hlY2sgaWYgdGhpcyBpcyBpdFxuICAgIGlmIChmb2N1c2VkKSB7XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlIGZvY3VzZWQgeWVhciBpcyB2aXNpYmxlXG4gICAgICAgIGNvbnN0IGlzRm9jdXNlZFllYXJWaXNpYmxlID0gISFncmlkLmZpbmQocm93ID0+ICEhcm93LmZpbmQoX2l0ZW0gPT4gX2l0ZW0ueWVhciA9PT0gZm9jdXNlZCkpO1xuXG4gICAgICAgIGlmIChpc0ZvY3VzZWRZZWFyVmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZvY3VzZWQgPT09IGl0ZW0ueWVhcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIHRoZXJlIGlzIG5vIGZvY3VzYWJsZSB5ZWFyIHRoZW4gY2hlY2sgaWYgdGhlcmUgaXMgYSBzZWxlY3RlZCB5ZWFyXG4gICAgY29uc3QgaXNTZWxlY3RlZFllYXJWaXNpYmxlID0gISFncmlkLmZpbmQocm93ID0+ICEhcm93LmZpbmQoeWVhciA9PiB5ZWFyLmlzQWN0aXZlWWVhcikpO1xuXG4gICAgaWYgKGlzU2VsZWN0ZWRZZWFyVmlzaWJsZSkge1xuICAgICAgICByZXR1cm4gaXRlbS5pc0FjdGl2ZVllYXI7XG4gICAgfVxuXG4gICAgLy8gb3RoZXJ3aXNlIG1ha2UgdGhlIGZpcnN0IG1vbnRoIHRhYmJhYmxlXG4gICAgcmV0dXJuIGdyaWRbMF1bMF0ueWVhciA9PT0gaXRlbS55ZWFyO1xufVxuXG59XG4iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW2ZvY3VzSWZdJ1xufSlcbmV4cG9ydCBjbGFzcyBGb2N1c0lmRGlyZWN0aXZlIHtcblxuICAgIEBJbnB1dCgpIGZvY3VzSWZEZWxheTogbnVtYmVyID0gMDtcblxuICAgIEBJbnB1dCgpXG4gICAgc2V0IGZvY3VzSWYoZm9jdXM6IGJvb2xlYW4pIHtcblxuICAgICAgICAvLyBpZiBhIHRpbWVvdXQgaXMgcGVuZGluZyB0aGVuIGNhbmNlbCBpdFxuICAgICAgICBpZiAoIWZvY3VzICYmIHRoaXMuX3RpbWVvdXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KTtcbiAgICAgICAgICAgIHRoaXMuX3RpbWVvdXQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZvY3VzICYmIHRoaXMuX3RpbWVvdXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3RpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICB9LCB0aGlzLmZvY3VzSWZEZWxheSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIF90aW1lb3V0OiBudW1iZXIgPSBudWxsO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZikgeyB9XG59IiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZvY3VzSWZEaXJlY3RpdmUgfSBmcm9tICcuL2ZvY3VzLWlmLmRpcmVjdGl2ZSc7XG5cblxuQE5nTW9kdWxlKHtcbiAgICBleHBvcnRzOiBbRm9jdXNJZkRpcmVjdGl2ZV0sXG4gICAgZGVjbGFyYXRpb25zOiBbRm9jdXNJZkRpcmVjdGl2ZV1cbn0pXG5leHBvcnQgY2xhc3MgRm9jdXNJZk1vZHVsZSB7IH1cbiIsImltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRm9ybXNNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBTcGluQnV0dG9uTW9kdWxlIH0gZnJvbSAnLi4vc3Bpbi1idXR0b24vaW5kZXgnO1xuaW1wb3J0IHsgVGltZVBpY2tlck1vZHVsZSB9IGZyb20gJy4uL3RpbWUtcGlja2VyL2luZGV4JztcbmltcG9ydCB7IERhdGVUaW1lUGlja2VyQ29tcG9uZW50IH0gZnJvbSAnLi9kYXRlLXRpbWUtcGlja2VyLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBEYXRlVGltZVBpY2tlckNvbmZpZyB9IGZyb20gJy4vZGF0ZS10aW1lLXBpY2tlci5jb25maWcnO1xuaW1wb3J0IHsgRGF5Vmlld0NvbXBvbmVudCB9IGZyb20gJy4vZGF5LXZpZXcvZGF5LXZpZXcuY29tcG9uZW50JztcbmltcG9ydCB7IEhlYWRlckNvbXBvbmVudCB9IGZyb20gJy4vaGVhZGVyL2hlYWRlci5jb21wb25lbnQnO1xuaW1wb3J0IHsgTW9udGhWaWV3Q29tcG9uZW50IH0gZnJvbSAnLi9tb250aC12aWV3L21vbnRoLXZpZXcuY29tcG9uZW50JztcbmltcG9ydCB7IFRpbWVWaWV3Q29tcG9uZW50IH0gZnJvbSAnLi90aW1lLXZpZXcvdGltZS12aWV3LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBZZWFyVmlld0NvbXBvbmVudCB9IGZyb20gJy4veWVhci12aWV3L3llYXItdmlldy5jb21wb25lbnQnO1xuaW1wb3J0IHsgRm9jdXNJZk1vZHVsZSB9IGZyb20gJy4uLy4uL2RpcmVjdGl2ZXMvZm9jdXMtaWYvaW5kZXgnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgVGltZVBpY2tlck1vZHVsZSxcbiAgICAgICAgU3BpbkJ1dHRvbk1vZHVsZSxcbiAgICAgICAgRm9jdXNJZk1vZHVsZVxuICAgIF0sXG4gICAgZXhwb3J0czogW0RhdGVUaW1lUGlja2VyQ29tcG9uZW50XSxcbiAgICBkZWNsYXJhdGlvbnM6IFtEYXRlVGltZVBpY2tlckNvbXBvbmVudCwgSGVhZGVyQ29tcG9uZW50LCBEYXlWaWV3Q29tcG9uZW50LCBNb250aFZpZXdDb21wb25lbnQsIFllYXJWaWV3Q29tcG9uZW50LCBUaW1lVmlld0NvbXBvbmVudF0sXG4gICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIERhdGVUaW1lUGlja2VyQ29uZmlnXG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBEYXRlVGltZVBpY2tlck1vZHVsZSB7IH1cbiIsImltcG9ydCB7IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDb21wb25lbnQsIERpcmVjdGl2ZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LWVib3gnLFxuICAgIHRlbXBsYXRlOiBgPGRpdiBjbGFzcz1cInV4LWVib3gtaGVhZGVyXCI+XG4gICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwidXgtZWJveC1oZWFkZXJcIj48L25nLWNvbnRlbnQ+XG48L2Rpdj5cblxuPGRpdiBjbGFzcz1cInV4LWVib3gtY29udGVudFwiPlxuICAgIDxuZy1jb250ZW50IHNlbGVjdD1cInV4LWVib3gtY29udGVudFwiPjwvbmctY29udGVudD5cbjwvZGl2PmAsXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgRWJveENvbXBvbmVudCB7IH1cblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICd1eC1lYm94LWhlYWRlcidcbn0pXG5leHBvcnQgY2xhc3MgRWJveEhlYWRlckRpcmVjdGl2ZSB7IH1cblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICd1eC1lYm94LWNvbnRlbnQnXG59KVxuZXhwb3J0IGNsYXNzIEVib3hDb250ZW50RGlyZWN0aXZlIHsgfVxuIiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgRWJveENvbXBvbmVudCwgRWJveENvbnRlbnREaXJlY3RpdmUsIEVib3hIZWFkZXJEaXJlY3RpdmUgfSBmcm9tICcuL2Vib3guY29tcG9uZW50JztcblxuQE5nTW9kdWxlKHtcbiAgICBleHBvcnRzOiBbRWJveENvbXBvbmVudCwgRWJveENvbnRlbnREaXJlY3RpdmUsIEVib3hIZWFkZXJEaXJlY3RpdmVdLFxuICAgIGRlY2xhcmF0aW9uczogW0Vib3hDb21wb25lbnQsIEVib3hDb250ZW50RGlyZWN0aXZlLCBFYm94SGVhZGVyRGlyZWN0aXZlXVxufSlcbmV4cG9ydCBjbGFzcyBFYm94TW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgRmFjZXQgfSBmcm9tICcuL21vZGVscy9mYWNldCc7XG5cbmV4cG9ydCBjbGFzcyBGYWNldFNlbGVjdCB7XG4gICAgY29uc3RydWN0b3IocHVibGljIGZhY2V0OiBGYWNldCkge31cbn1cblxuZXhwb3J0IGNsYXNzIEZhY2V0RGVzZWxlY3Qge1xuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBmYWNldDogRmFjZXQpIHt9XG59XG5cbmV4cG9ydCBjbGFzcyBGYWNldERlc2VsZWN0QWxsIHtcbiAgICBjb25zdHJ1Y3RvcigpIHt9XG59XG5cbmV4cG9ydCB0eXBlIEZhY2V0RXZlbnQgPSBGYWNldFNlbGVjdCB8IEZhY2V0RGVzZWxlY3QgfCBGYWNldERlc2VsZWN0QWxsOyIsImltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIEV2ZW50RW1pdHRlciwgT3V0cHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGYWNldEV2ZW50LCBGYWNldFNlbGVjdCwgRmFjZXREZXNlbGVjdCwgRmFjZXREZXNlbGVjdEFsbCB9IGZyb20gJy4vZmFjZXQtZXZlbnRzJztcbmltcG9ydCB7IEZhY2V0IH0gZnJvbSAnLi9tb2RlbHMvZmFjZXQnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LWZhY2V0LWNvbnRhaW5lcicsXG4gICAgdGVtcGxhdGU6IGA8IS0tIERpc3BsYXkgQW55IFNlbGVjdGVkIEZhY2V0cyAtLT5cbjxkaXYgY2xhc3M9XCJmYWNldHMtc2VsZWN0ZWQtY29udGFpbmVyXCI+XG5cbiAgICA8IS0tIERpc3BsYXkgVGl0bGUgYW4gQ2xlYXIgQnV0dG9uIC0tPlxuICAgIDxkaXYgY2xhc3M9XCJmYWNldHMtc2VsZWN0ZWQtaGVhZGVyLWNvbnRhaW5lclwiPlxuXG4gICAgICAgIDwhLS0gU2hvdyBUaGUgU2VsZWN0ZWQgVGV4dCAtLT5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJmYWNldHMtc2VsZWN0ZWQtaGVhZGVyLWxhYmVsXCI+e3sgaGVhZGVyIH19PC9zcGFuPlxuXG4gICAgICAgIDwhLS0gQWRkIGEgQ2xlYXIgQnV0dG9uIC0tPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiZmFjZXRzLXNlbGVjdGVkLWNsZWFyLWJ1dHRvblwiIHRhYmluZGV4PVwiMFwiIFt1eFRvb2x0aXBdPVwiY2xlYXJUb29sdGlwXCIgcGxhY2VtZW50PVwibGVmdFwiIChjbGljayk9XCJkZXNlbGVjdEFsbEZhY2V0cygpXCJcbiAgICAgICAgICAgIChrZXl1cC5lbnRlcik9XCJkZXNlbGVjdEFsbEZhY2V0cygpXCIgKm5nSWY9XCJmYWNldHMubGVuZ3RoID4gMFwiPlxuXG4gICAgICAgICAgICA8c3ZnIGNsYXNzPVwiZmFjZXRzLXNlbGVjdGVkLWNsZWFyLWdyYXBoaWNcIiB2aWV3Qm94PVwiMCAwIDE5IDEyXCIgc2hhcGUtcmVuZGVyaW5nPVwiZ2VvbWV0cmljUHJlY2lzaW9uXCI+XG4gICAgICAgICAgICAgICAgPHJlY3QgY2xhc3M9XCJsaWdodC1ncmV5XCIgeD1cIjBcIiB5PVwiMlwiIHdpZHRoPVwiN1wiIGhlaWdodD1cIjJcIj48L3JlY3Q+XG4gICAgICAgICAgICAgICAgPHJlY3QgY2xhc3M9XCJkYXJrLWdyZXlcIiB4PVwiMFwiIHk9XCI1XCIgd2lkdGg9XCI5XCIgaGVpZ2h0PVwiMlwiPjwvcmVjdD5cbiAgICAgICAgICAgICAgICA8cmVjdCBjbGFzcz1cImxpZ2h0LWdyZXlcIiB4PVwiMFwiIHk9XCI4XCIgd2lkdGg9XCI3XCIgaGVpZ2h0PVwiMlwiPjwvcmVjdD5cbiAgICAgICAgICAgICAgICA8cGF0aCBjbGFzcz1cImRhcmstZ3JleVwiIGQ9XCJNOSwxIGgxIGw5LDkgdjEgaC0xIGwtOSwtOSB2LTEgWlwiPjwvcGF0aD5cbiAgICAgICAgICAgICAgICA8cGF0aCBjbGFzcz1cImRhcmstZ3JleVwiIGQ9XCJNOSwxMSB2LTEgbDksLTkgaDEgdjEgbC05LDkgaC0xIFpcIj48L3BhdGg+XG4gICAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgPC9kaXY+XG5cbiAgICA8L2Rpdj5cblxuICAgIDwhLS0gRGlzcGxheSBUYWdzIEZvciBTZWxlY3RlZCBJdGVtcyAtLT5cbiAgICA8ZGl2IGNsYXNzPVwiZmFjZXRzLXNlbGVjdGVkLWxpc3RcIiB1eFJlb3JkZXJhYmxlIFtyZW9yZGVyaW5nRGlzYWJsZWRdPVwiIWZhY2V0c1Jlb3JkZXJhYmxlXCIgWyhyZW9yZGVyYWJsZU1vZGVsKV09XCJmYWNldHNcIiAocmVvcmRlcmFibGVNb2RlbENoYW5nZSk9XCJmYWNldHNDaGFuZ2UuZW1pdChmYWNldHMpXCI+XG5cbiAgICAgICAgPCEtLSBTaG93IFNlbGVjdGVkIFRhZ3MgLS0+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJmYWNldC1zZWxlY3RlZC10YWdcIiB0YWJpbmRleD1cIjBcIiAqbmdGb3I9XCJsZXQgZmFjZXQgb2YgZmFjZXRzXCIgKG1vdXNlZG93bik9XCIkZXZlbnQucHJldmVudERlZmF1bHQoKVwiIChjbGljayk9XCJkZXNlbGVjdEZhY2V0KGZhY2V0KVwiIChrZXl1cC5lbnRlcik9XCJkZXNlbGVjdEZhY2V0KGZhY2V0KVwiXG4gICAgICAgICAgICAgW3V4UmVvcmRlcmFibGVNb2RlbF09XCJmYWNldFwiPlxuXG4gICAgICAgICAgICA8IS0tIERpc3BsYXkgTGFiZWwgLS0+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImZhY2V0LXNlbGVjdGVkLXRhZy1sYWJlbFwiIHV4UmVvcmRlcmFibGVIYW5kbGU+e3sgZmFjZXQudGl0bGUgfX08L3NwYW4+XG5cbiAgICAgICAgICAgIDwhLS0gRGlzcGxheSBSZW1vdmUgSWNvbiAtLT5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaHBlLWljb24gaHBlLWNsb3NlXCI+PC9zcGFuPlxuICAgICAgICA8L2Rpdj5cblxuICAgIDwvZGl2PlxuXG4gICAgPCEtLSBTaG93IE1lc3NhZ2UgSGVyZSBpZiBObyBGYWNldHMgU2VsZWN0ZWQgLS0+XG4gICAgPHAgY2xhc3M9XCJmYWNldHMtc2VsZWN0ZWQtbm9uZS1sYWJlbFwiICpuZ0lmPVwiZW1wdHlUZXh0ICYmIGZhY2V0cy5sZW5ndGggPT09IDBcIj57eyBlbXB0eVRleHQgfX08L3A+XG5cbjwvZGl2PlxuXG48IS0tIEFueSBGYWNldCBFbGVtZW50cyBTaG91bGQgYmUgQWRkZWQgSGVyZSBCeSBVc2VyIC0tPlxuPGRpdiBjbGFzcz1cImZhY2V0cy1yZWdpb25cIj5cbiAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG48L2Rpdj5gXG59KVxuZXhwb3J0IGNsYXNzIEZhY2V0Q29udGFpbmVyQ29tcG9uZW50IHtcblxuICAgIEBJbnB1dCgpIGhlYWRlcjogc3RyaW5nID0gJ1NlbGVjdGVkOic7XG4gICAgQElucHV0KCkgY2xlYXJUb29sdGlwOiBzdHJpbmcgPSAnQ2xlYXIgQWxsJztcbiAgICBASW5wdXQoKSBlbXB0eVRleHQ6IHN0cmluZyA9ICdObyBJdGVtcyc7XG4gICAgQElucHV0KCkgZmFjZXRzOiBGYWNldFtdID0gW107XG4gICAgQElucHV0KCkgZmFjZXRzUmVvcmRlcmFibGU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIEBPdXRwdXQoKSBmYWNldHNDaGFuZ2U6IEV2ZW50RW1pdHRlcjxGYWNldFtdPiA9IG5ldyBFdmVudEVtaXR0ZXI8RmFjZXRbXT4oKTtcbiAgICBAT3V0cHV0KCkgZXZlbnRzOiBFdmVudEVtaXR0ZXI8RmFjZXRFdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPEZhY2V0RXZlbnQ+KCk7XG5cbiAgICBzZWxlY3RGYWNldChmYWNldDogRmFjZXQpOiB2b2lkIHtcbiAgICAgICAgLy8gcHVzaCB0aGUgZmFjZXQgb24gdG8gdGhlIGxpc3RcbiAgICAgICAgdGhpcy5mYWNldHMucHVzaChmYWNldCk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSB0d28gd2F5IGJpbmRpbmdcbiAgICAgICAgdGhpcy5mYWNldHNDaGFuZ2UuZW1pdCh0aGlzLmZhY2V0cyk7XG5cbiAgICAgICAgLy8gdHJpZ2dlciBldmVudFxuICAgICAgICB0aGlzLnRyaWdnZXJFdmVudChuZXcgRmFjZXRTZWxlY3QoZmFjZXQpKTtcbiAgICB9XG5cbiAgICBkZXNlbGVjdEZhY2V0KGZhY2V0OiBGYWNldCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGZpbmQgdGhlIGluZGV4IG9mIHRoZSBpdGVtIGluIHRoZSBzZWxlY3RlZCBhcnJheVxuICAgICAgICBsZXQgaWR4ID0gdGhpcy5mYWNldHMuZmluZEluZGV4KHNlbGVjdGVkRmFjZXQgPT4gZmFjZXQgPT09IHNlbGVjdGVkRmFjZXQpO1xuXG4gICAgICAgIC8vIGlmIG1hdGNoIHRoZXJlIHdhcyBubyBtYXRjaCB0aGVuIGZpbmlzaFxuICAgICAgICBpZiAoaWR4ID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVtb3ZlIHRoZSBsYXN0IGl0ZW1cbiAgICAgICAgdGhpcy5mYWNldHMuc3BsaWNlKGlkeCwgMSk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSB0d28gd2F5IGJpbmRpbmdcbiAgICAgICAgdGhpcy5mYWNldHNDaGFuZ2UuZW1pdCh0aGlzLmZhY2V0cyk7XG5cbiAgICAgICAgLy8gdHJpZ2dlciBldmVudFxuICAgICAgICB0aGlzLnRyaWdnZXJFdmVudChuZXcgRmFjZXREZXNlbGVjdChmYWNldCkpO1xuICAgIH1cblxuICAgIGRlc2VsZWN0QWxsRmFjZXRzKCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGVtcHR5IHRoZSBzZWxlY3RlZCBhcnJheVxuICAgICAgICB0aGlzLmZhY2V0cyA9IFtdO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgdHdvIHdheSBiaW5kaW5nXG4gICAgICAgIHRoaXMuZmFjZXRzQ2hhbmdlLmVtaXQodGhpcy5mYWNldHMpO1xuXG4gICAgICAgIC8vIHRyaWdnZXIgZXZlbnRcbiAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnQobmV3IEZhY2V0RGVzZWxlY3RBbGwoKSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB0cmlnZ2VyRXZlbnQoZXZlbnQ6IEZhY2V0RXZlbnQpIHtcbiAgICAgICAgdGhpcy5ldmVudHMubmV4dChldmVudCk7XG4gICAgfVxufSIsImltcG9ydCB7IENvbXBvbmVudCwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBIb3N0LCBJbnB1dCwgT25EZXN0cm95LCBPbkluaXQsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgZmlsdGVyLCB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcbmltcG9ydCB7IEZhY2V0Q29udGFpbmVyQ29tcG9uZW50IH0gZnJvbSAnLi4vLi4vZmFjZXQtY29udGFpbmVyLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBGYWNldERlc2VsZWN0LCBGYWNldERlc2VsZWN0QWxsLCBGYWNldEV2ZW50LCBGYWNldFNlbGVjdCB9IGZyb20gJy4uLy4uL2ZhY2V0LWV2ZW50cyc7XG5pbXBvcnQgeyBGYWNldCB9IGZyb20gJy4uLy4uL21vZGVscy9mYWNldCc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtZmFjZXQtYmFzZScsXG4gICAgdGVtcGxhdGU6ICcnLFxufSlcbmV4cG9ydCBjbGFzcyBGYWNldEJhc2VDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG5cbiAgICBASW5wdXQoKSBzZWxlY3RlZDogRmFjZXRbXSA9IFtdO1xuICAgIEBPdXRwdXQoKSBzZWxlY3RlZENoYW5nZTogRXZlbnRFbWl0dGVyPEZhY2V0W10+ID0gbmV3IEV2ZW50RW1pdHRlcjxGYWNldFtdPigpO1xuICAgIEBPdXRwdXQoKSBldmVudHM6IFN1YmplY3Q8RmFjZXRFdmVudD4gPSBuZXcgU3ViamVjdDxGYWNldEV2ZW50PigpO1xuXG4gICAgcHJvdGVjdGVkIF9vbkRlc3Ryb3kgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gICAgY29uc3RydWN0b3IoIEBIb3N0KCkgcHJpdmF0ZSBmYWNldENvbnRhaW5lcjogRmFjZXRDb250YWluZXJDb21wb25lbnQsIHB1YmxpYyBfZWxlbWVudFJlZjogRWxlbWVudFJlZikge1xuXG4gICAgICAgIGlmIChmYWNldENvbnRhaW5lcikge1xuXG4gICAgICAgICAgICAvLyBzdWJzY3JpYmUgdG8gYW55IGRlc2VsZWN0IGV2ZW50cyBmcm9tIHRoZSBmYWNldCBjb250YWluZXJcbiAgICAgICAgICAgIGZhY2V0Q29udGFpbmVyLmV2ZW50cy5waXBlKFxuICAgICAgICAgICAgICAgIGZpbHRlcihldmVudCA9PiBldmVudCBpbnN0YW5jZW9mIEZhY2V0RGVzZWxlY3QpLFxuICAgICAgICAgICAgICAgIGZpbHRlcigoZXZlbnQ6IEZhY2V0RGVzZWxlY3QpID0+ICEhdGhpcy5zZWxlY3RlZC5maW5kKGZhY2V0ID0+IGZhY2V0ID09PSBldmVudC5mYWNldCkpLFxuICAgICAgICAgICAgICAgIHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpXG4gICAgICAgICAgICApLnN1YnNjcmliZSgoZXZlbnQ6IEZhY2V0RGVzZWxlY3QpID0+IHRoaXMuZGVzZWxlY3RGYWNldChldmVudC5mYWNldCkpO1xuXG4gICAgICAgICAgICAvLyBzdWJzY3JpYmUgdG8gYW55IGRlc2VsZWN0IGFsbCBldmVudHMgZnJvbSBmYWNldCBjb250YWluZXJcbiAgICAgICAgICAgIGZhY2V0Q29udGFpbmVyLmV2ZW50cy5waXBlKFxuICAgICAgICAgICAgICAgIGZpbHRlcihldmVudCA9PiBldmVudCBpbnN0YW5jZW9mIEZhY2V0RGVzZWxlY3RBbGwpLFxuICAgICAgICAgICAgICAgIHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpXG4gICAgICAgICAgICApLnN1YnNjcmliZShfID0+IHRoaXMuZGVzZWxlY3RBbGwoKSk7XG5cbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5nT25Jbml0KCk6IHZvaWQge1xuICAgICAgICAvLyBjaGVjayBpZiB0aGVyZSBzaG91bGQgYmUgYW55IGZhY2V0cyBpbml0aWFsbHkgc2VsZWN0ZWRcbiAgICAgICAgaWYgKHRoaXMuZmFjZXRDb250YWluZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQuZm9yRWFjaChmYWNldCA9PiB0aGlzLmZhY2V0Q29udGFpbmVyLnNlbGVjdEZhY2V0KGZhY2V0KSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fb25EZXN0cm95Lm5leHQoKTtcbiAgICAgICAgdGhpcy5fb25EZXN0cm95LmNvbXBsZXRlKCk7XG4gICAgfVxuXG4gICAgc2VsZWN0RmFjZXQoZmFjZXQ6IEZhY2V0KTogdm9pZCB7XG5cbiAgICAgICAgLy8gaWYgdGhlIGZhY2V0IGlzIGRpc2FibGVkIGl0IHNob3VsZCBub3QgYmUgc2VsZWN0ZWRcbiAgICAgICAgaWYgKGZhY2V0LmRpc2FibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgdGhlIGZhY2V0IHRvIHRoZSBsaXN0IG9mIHNlbGVjdGVkIGZhY2V0c1xuICAgICAgICB0aGlzLnNlbGVjdGVkLnB1c2goZmFjZXQpO1xuXG4gICAgICAgIC8vIHNlbmQgdGhlIG5ldyB2YWx1ZSB0byB0aGUgZXZlbnQgZW1pdHRlclxuICAgICAgICB0aGlzLnNlbGVjdGVkQ2hhbmdlLmVtaXQodGhpcy5zZWxlY3RlZCk7XG5cbiAgICAgICAgLy8gZmlyZSB0aGUgZXZlbnQgdG8gdGhlIG9ic2VydmFibGVcbiAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnQobmV3IEZhY2V0U2VsZWN0KGZhY2V0KSk7XG5cbiAgICAgICAgLy8gdGVsbCB0aGUgZmFjZXQgY29udGFpbmVyIGFib3V0IHRoZSBzZWxlY3RlZCBmYWNldFxuICAgICAgICBpZiAodGhpcy5mYWNldENvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhpcy5mYWNldENvbnRhaW5lci5zZWxlY3RGYWNldChmYWNldCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZXNlbGVjdEZhY2V0KGZhY2V0OiBGYWNldCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGZpbmQgZmFjZXQgdG8gcmVtb3ZlXG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMuc2VsZWN0ZWQuZmluZEluZGV4KHNlbGVjdGVkRmFjZXQgPT4gc2VsZWN0ZWRGYWNldCA9PT0gZmFjZXQpO1xuXG4gICAgICAgIC8vIG9ubHkgY29udGludWUgaWYgZmFjZXQgaXMgZm91bmRcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuXG4gICAgICAgICAgICAvLyByZW1vdmUgdGhlIGZhY2V0IGZyb20gdGhlIHNlbGVjdGVkIGxpc3RcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgICAgICAgICAgLy8gZW1pdCB0aGUgY2hhbmdlcyB0byBzZWxlY3RlZCBldmVudCBlbWl0dGVyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkQ2hhbmdlLmVtaXQodGhpcy5zZWxlY3RlZCk7XG5cbiAgICAgICAgICAgIC8vIGZpcmUgdGhlIGV2ZW50IHRvIHRoZSBvYnNlcnZhYmxlXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXJFdmVudChuZXcgRmFjZXREZXNlbGVjdChmYWNldCkpO1xuXG4gICAgICAgICAgICAvLyBkZXNlbGVjdCB0aGUgZmFjZXQgaW4gdGhlIGZhY2V0IGNvbnRhaW5lclxuICAgICAgICAgICAgaWYgKHRoaXMuZmFjZXRDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZhY2V0Q29udGFpbmVyLmRlc2VsZWN0RmFjZXQoZmFjZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGVzZWxlY3RBbGwoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gcmVtb3ZlIGFsbCBzZWxlY3RlZCBmYWNldHNcbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9IFtdO1xuXG4gICAgICAgIC8vIGZpcmUgdGhlIGV2ZW50IHRvIHRoZSBvYnNlcnZhYmxlXG4gICAgICAgIHRoaXMudHJpZ2dlckV2ZW50KG5ldyBGYWNldERlc2VsZWN0QWxsKCkpO1xuXG4gICAgICAgIC8vIGVtaXQgdGhlIGNoYW5nZXMgdG8gdGhlIHNlbGVjdGVkIGV2ZW50IGVtaXR0ZXJcbiAgICAgICAgdGhpcy5zZWxlY3RlZENoYW5nZS5lbWl0KHRoaXMuc2VsZWN0ZWQpO1xuICAgIH1cblxuICAgIHRvZ2dsZUZhY2V0U2VsZWN0aW9uKGZhY2V0OiBGYWNldCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGlmIHRoZSBmYWNldCBpcyBzZWxlY3RlZCB0aGVuIGRlc2VsZWN0IC0gb3RoZXJ3aXNlIHNlbGVjdCBpdFxuICAgICAgICBpZiAodGhpcy5pc0ZhY2V0U2VsZWN0ZWQoZmFjZXQpKSB7XG4gICAgICAgICAgICB0aGlzLmRlc2VsZWN0RmFjZXQoZmFjZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RGYWNldChmYWNldCk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGlzRmFjZXRTZWxlY3RlZChmYWNldDogRmFjZXQpOiBib29sZWFuIHtcbiAgICAgICAgLy8gZGV0ZXJtaW5lIGlmIGEgZmFjZXQgaXMgY3VycmVudGx5IHNlbGVjdGVkXG4gICAgICAgIHJldHVybiAhIXRoaXMuc2VsZWN0ZWQuZmluZChzZWxlY3RlZEZhY2V0ID0+IHNlbGVjdGVkRmFjZXQgPT09IGZhY2V0KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHRyaWdnZXJFdmVudChldmVudDogRmFjZXRFdmVudCk6IHZvaWQge1xuICAgICAgICB0aGlzLmV2ZW50cy5uZXh0KGV2ZW50KTtcbiAgICB9XG59IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBPdXRwdXQsIEV2ZW50RW1pdHRlciwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1mYWNldC1oZWFkZXInLFxuICAgIHRlbXBsYXRlOiBgPHNwYW4gY2xhc3M9XCJmYWNldC1oZWFkZXItdGl0bGVcIj57eyBoZWFkZXIgfX08L3NwYW4+XG48c3BhbiBjbGFzcz1cImhwZS1pY29uXCIgW2NsYXNzLmhwZS1kb3duXT1cImV4cGFuZGVkXCIgW2NsYXNzLmhwZS1wcmV2aW91c109XCIhZXhwYW5kZWRcIiAqbmdJZj1cImNhbkV4cGFuZFwiPjwvc3Bhbj5gLFxuICAgIGhvc3Q6IHtcbiAgICAgICAgJ3RhYmluZGV4JzogJzAnLFxuICAgICAgICAnKGNsaWNrKSc6ICd0b2dnbGVFeHBhbmQoKScsXG4gICAgICAgICcoa2V5dXAuZW50ZXIpJzogJ3RvZ2dsZUV4cGFuZCgpJ1xuICAgIH1cbn0pXG5leHBvcnQgY2xhc3MgRmFjZXRIZWFkZXJDb21wb25lbnQge1xuXG4gICAgQElucHV0KCkgaGVhZGVyOiBzdHJpbmc7XG4gICAgQElucHV0KCkgY2FuRXhwYW5kOiBib29sZWFuID0gdHJ1ZTsgICAgXG4gICAgQElucHV0KCkgZXhwYW5kZWQ6IGJvb2xlYW4gPSB0cnVlO1xuICAgIEBPdXRwdXQoKSBleHBhbmRlZENoYW5nZTogRXZlbnRFbWl0dGVyPGJvb2xlYW4+ID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG4gICAgdG9nZ2xlRXhwYW5kKCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGlmIG5vdCBleHBhbmRhYmxlIHRoZW4gZG8gbm90aGluZ1xuICAgICAgICBpZiAodGhpcy5jYW5FeHBhbmQpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwYW5kZWQgPSAhdGhpcy5leHBhbmRlZDtcbiAgICAgICAgICAgIHRoaXMuZXhwYW5kZWRDaGFuZ2UuZW1pdCh0aGlzLmV4cGFuZGVkKTtcbiAgICAgICAgfVxuICAgIH1cbn0iLCJpbXBvcnQgeyBDb21wb25lbnQsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGYWNldEJhc2VDb21wb25lbnQgfSBmcm9tICcuLi9iYXNlL2ZhY2V0LWJhc2UvZmFjZXQtYmFzZS5jb21wb25lbnQnO1xuaW1wb3J0IHsgRmFjZXQgfSBmcm9tICcuLi9tb2RlbHMvZmFjZXQnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LWZhY2V0LWNoZWNrLWxpc3QnLFxuICAgIHRlbXBsYXRlOiBgPHV4LWZhY2V0LWhlYWRlciBbaGVhZGVyXT1cImhlYWRlclwiIFsoZXhwYW5kZWQpXT1cImV4cGFuZGVkXCI+PC91eC1mYWNldC1oZWFkZXI+XG5cbjwhLS0gQ3JlYXRlIGEgY29udGFpbmVyIHdoaWNoIHdpbGwgc2hvdyB3aGVuIHNlY3Rpb24gaXMgZXhwYW5kZWQgLS0+XG48ZGl2IGNsYXNzPVwiZmFjZXQtY2hlY2stbGlzdC1jb250YWluZXJcIiBbY2xhc3MuZmFjZXQtY2hlY2stbGlzdC1zY3JvbGxiYXJdPVwic2Nyb2xsYmFyXCIgKm5nSWY9XCJleHBhbmRlZFwiPlxuXG4gICAgPCEtLSBJdGVyYXRlIHRocm91Z2ggZWFjaCBwb3NzaWJsZSBmYWNldCAtLT5cbiAgICA8ZGl2IGNsYXNzPVwiZmFjZXQtY2hlY2stbGlzdC1pdGVtXCIgKm5nRm9yPVwibGV0IGZhY2V0IG9mIGZhY2V0c1wiIFtjbGFzcy5mYWNldC1hY3RpdmVdPVwiaXNGYWNldFNlbGVjdGVkKGZhY2V0KVwiIHRhYmluZGV4PVwiMFwiXG4gICAgICAgIChjbGljayk9XCJ0b2dnbGVGYWNldFNlbGVjdGlvbihmYWNldClcIiAoa2V5dXAuZW50ZXIpPVwidG9nZ2xlRmFjZXRTZWxlY3Rpb24oZmFjZXQpXCIgW2NsYXNzLmRpc2FibGVkXT1cImZhY2V0LmRpc2FibGVkXCI+XG5cbiAgICAgICAgPCEtLSBTaG93IGNoZWNrIGljb24gdG8gaW5kaWNhdGUgdGhlIHN0YXRlIC0tPlxuICAgICAgICA8c3BhbiBjbGFzcz1cImZhY2V0LWNoZWNrLWxpc3QtaXRlbS1jaGVja1wiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJocGUtaWNvbiBocGUtYWN0aXZlXCI+PC9zcGFuPlxuICAgICAgICA8L3NwYW4+XG5cbiAgICAgICAgPCEtLSBEaXNwbGF5IHRoZSB0aXRsZSAtLT5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJmYWNldC1jaGVjay1saXN0LWl0ZW0tdGl0bGVcIj57eyBmYWNldC50aXRsZSB9fTwvc3Bhbj5cblxuICAgICAgICA8IS0tIERpc3BsYXkgdGhlIGNvdW50IGlmIHNwZWNpZmllZCAtLT5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJmYWNldC1jaGVjay1saXN0LWl0ZW0tY291bnRcIiAqbmdJZj1cImZhY2V0LmNvdW50ICE9PSB1bmRlZmluZWRcIj4oe3sgZmFjZXQuY291bnQgfX0pPC9zcGFuPlxuICAgIDwvZGl2PlxuPC9kaXY+YFxufSlcbmV4cG9ydCBjbGFzcyBGYWNldENoZWNrTGlzdENvbXBvbmVudCBleHRlbmRzIEZhY2V0QmFzZUNvbXBvbmVudCB7XG5cbiAgICBASW5wdXQoKSBmYWNldHM6IEZhY2V0W10gPSBbXTtcbiAgICBASW5wdXQoKSBoZWFkZXI6IHN0cmluZztcbiAgICBASW5wdXQoKSBzY3JvbGxiYXI6IGJvb2xlYW4gPSB0cnVlO1xuICAgIEBJbnB1dCgpIGV4cGFuZGVkOiBib29sZWFuID0gdHJ1ZTtcbn0iLCJpbXBvcnQgeyBDb21wb25lbnQsIElucHV0LCBPbkluaXQsIFBpcGUsIFBpcGVUcmFuc2Zvcm0gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFR5cGVhaGVhZE1hdGNoIH0gZnJvbSAnbmd4LWJvb3RzdHJhcC90eXBlYWhlYWQnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMvT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBmcm9tIH0gZnJvbSAncnhqcy9vYnNlcnZhYmxlL2Zyb20nO1xuaW1wb3J0IHsgb2YgfSBmcm9tICdyeGpzL29ic2VydmFibGUvb2YnO1xuaW1wb3J0IHsgbWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgRmFjZXRCYXNlQ29tcG9uZW50IH0gZnJvbSAnLi4vYmFzZS9mYWNldC1iYXNlL2ZhY2V0LWJhc2UuY29tcG9uZW50JztcbmltcG9ydCB7IEZhY2V0IH0gZnJvbSAnLi4vbW9kZWxzL2ZhY2V0JztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1mYWNldC10eXBlYWhlYWQtbGlzdCcsXG4gICAgdGVtcGxhdGU6IGA8dXgtZmFjZXQtaGVhZGVyIFtoZWFkZXJdPVwiaGVhZGVyXCIgWyhleHBhbmRlZCldPVwiZXhwYW5kZWRcIj48L3V4LWZhY2V0LWhlYWRlcj5cblxuPGRpdiBjbGFzcz1cImZhY2V0LXR5cGVhaGVhZC1saXN0LWNvbnRhaW5lclwiICpuZ0lmPVwiZXhwYW5kZWRcIj5cblxuICAgIDxkaXYgY2xhc3M9XCJmYWNldC10eXBlYWhlYWQtbGlzdC1zZWxlY3RlZC1jb250YWluZXJcIiAqbmdJZj1cInN1Z2dlc3Rpb25zPy5sZW5ndGggPiAwXCI+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cImZhY2V0LXR5cGVhaGVhZC1saXN0LXNlbGVjdGVkLW9wdGlvblwiIHRhYmluZGV4PVwiMFwiICpuZ0Zvcj1cImxldCBmYWNldCBvZiBzdWdnZXN0aW9uc1wiIChjbGljayk9XCJ0b2dnbGVGYWNldFNlbGVjdGlvbihmYWNldClcIlxuICAgICAgICAgICAgKGtleXVwLmVudGVyKT1cInRvZ2dsZUZhY2V0U2VsZWN0aW9uKGZhY2V0KVwiPlxuXG4gICAgICAgICAgICA8dXgtY2hlY2tib3ggW2NsaWNrYWJsZV09XCJmYWxzZVwiIFt2YWx1ZV09XCJpc0ZhY2V0U2VsZWN0ZWQoZmFjZXQpXCIgW3NpbXBsaWZpZWRdPVwic2ltcGxpZmllZFwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZmFjZXQtdHlwZWFoZWFkLWxpc3Qtc2VsZWN0ZWQtb3B0aW9uLXRpdGxlXCI+e3sgZmFjZXQudGl0bGUgfX08L3NwYW4+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJmYWNldC10eXBlYWhlYWQtbGlzdC1zZWxlY3RlZC1vcHRpb24tY291bnRcIj4oe3sgZmFjZXQuY291bnQgfX0pPC9zcGFuPlxuICAgICAgICAgICAgPC91eC1jaGVja2JveD5cblxuICAgICAgICA8L2Rpdj5cblxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cImZhY2V0LXR5cGVhaGVhZC1saXN0LWNvbnRyb2xcIj5cblxuICAgICAgICA8IS0tIENyZWF0ZSBUeXBlYWhlYWQgQ29udHJvbCAtLT5cbiAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiBbcGxhY2Vob2xkZXJdPVwidHlwZWFoZWFkQ29uZmlnPy5wbGFjZWhvbGRlclwiIFt0eXBlYWhlYWRdPVwidHlwZWFoZWFkT3B0aW9uc1wiIFsobmdNb2RlbCldPVwic2VhcmNoUXVlcnlcIlxuICAgICAgICAgICAgW3R5cGVhaGVhZE1pbkxlbmd0aF09XCJ0eXBlYWhlYWRDb25maWc/Lm1pbkNoYXJhY3RlcnNcIiBbdHlwZWFoZWFkT3B0aW9uc0xpbWl0XT1cInR5cGVhaGVhZENvbmZpZz8ubWF4UmVzdWx0c1wiIFt0eXBlYWhlYWRXYWl0TXNdPVwidHlwZWFoZWFkQ29uZmlnPy5kZWxheVwiXG4gICAgICAgICAgICAodHlwZWFoZWFkT25TZWxlY3QpPVwic2VsZWN0T3B0aW9uKCRldmVudClcIiBbdHlwZWFoZWFkSXRlbVRlbXBsYXRlXT1cImZhY2V0T3B0aW9uVGVtcGxhdGVcIiAoa2V5dXAuQXJyb3dVcCk9XCJzY3JvbGxUb0ZvY3VzZWQoKVwiIChrZXl1cC5BcnJvd0Rvd24pPVwic2Nyb2xsVG9Gb2N1c2VkKClcIj5cblxuICAgIDwvZGl2PlxuXG48L2Rpdj5cblxuPG5nLXRlbXBsYXRlICNmYWNldE9wdGlvblRlbXBsYXRlIGxldC1tb2RlbD1cIml0ZW1cIiBsZXQtaW5kZXg9XCJpbmRleFwiPlxuICAgIDxwIGNsYXNzPVwiZmFjZXQtdHlwZWFoZWFkLWxpc3Qtb3B0aW9uXCI+PHNwYW4gW2lubmVySFRNTF09XCJtb2RlbC50aXRsZSB8IGZhY2V0VHlwZWFoZWFkSGlnaGxpZ2h0OiBzZWFyY2hRdWVyeVwiPjwvc3Bhbj4gPHNwYW4gY2xhc3M9XCJmYWNldC10eXBlYWhlYWQtbGlzdC1vcHRpb24tY291bnRcIlxuICAgICAgICAgICAgKm5nSWY9XCJtb2RlbC5jb3VudFwiPih7eyBtb2RlbC5jb3VudCB9fSk8L3NwYW4+PC9wPlxuPC9uZy10ZW1wbGF0ZT5gXG59KVxuZXhwb3J0IGNsYXNzIEZhY2V0VHlwZWFoZWFkTGlzdENvbXBvbmVudCBleHRlbmRzIEZhY2V0QmFzZUNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG5cbiAgICBASW5wdXQoKSBmYWNldHM6IEZhY2V0W10gfCBPYnNlcnZhYmxlPEZhY2V0W10+O1xuICAgIEBJbnB1dCgpIGhlYWRlcjogc3RyaW5nO1xuICAgIEBJbnB1dCgpIGV4cGFuZGVkOiBib29sZWFuID0gdHJ1ZTtcbiAgICBASW5wdXQoKSB0eXBlYWhlYWRDb25maWc6IEZhY2V0VHlwZWFoZWFkTGlzdENvbmZpZyA9IHt9O1xuICAgIEBJbnB1dCgpIHN1Z2dlc3Rpb25zOiBGYWNldFtdID0gW107XG4gICAgQElucHV0KCkgc2ltcGxpZmllZDogYm9vbGVhbiA9IHRydWU7XG5cbiAgICB0eXBlYWhlYWRPcHRpb25zOiBPYnNlcnZhYmxlPEZhY2V0W10+O1xuICAgIHNlYXJjaFF1ZXJ5OiBzdHJpbmc7XG5cbiAgICBwcml2YXRlIF9uYXRpdmVFbGVtZW50OiBIVE1MRWxlbWVudCA9IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCBhcyBIVE1MRWxlbWVudDtcbiAgICBwcml2YXRlIF9kZWZhdWx0VHlwZWFoZWFkQ29uZmlnOiBGYWNldFR5cGVhaGVhZExpc3RDb25maWcgPSB7XG4gICAgICAgIHBsYWNlaG9sZGVyOiAnJyxcbiAgICAgICAgbWF4UmVzdWx0czogNTAsXG4gICAgICAgIG1pbkNoYXJhY3RlcnM6IDFcbiAgICB9O1xuXG4gICAgbmdPbkluaXQoKSB7XG5cbiAgICAgICAgLy8gd3JhcCB0aGUgb2JzZXJ2YWJsZSBhbmQgZmlsdGVyIG91dCBhbnkgYWxyZWFkeSBzZWxlY3RlZCBpdGVtcyBvciBhbnkgZGlzYWJsZWQgaXRlbXNcbiAgICAgICAgaWYgKHRoaXMuZmFjZXRzIGluc3RhbmNlb2YgT2JzZXJ2YWJsZSkge1xuXG4gICAgICAgICAgICAvLyBoYW5kbGUgYW4gb2JzZXJ2YWJsZSBvZiBkYXRhXG4gICAgICAgICAgICB0aGlzLnR5cGVhaGVhZE9wdGlvbnMgPSBmcm9tKHRoaXMuZmFjZXRzKS5waXBlKG1hcCgoZmFjZXRzOiBGYWNldFtdKSA9PiB7XG5cbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgZGlzYWJsZWQgZmFjZXRzLCBzZWxlY3RlZCBmYWNldHMgYW5kIGZhY2V0cyB0aGF0IGRvbnQgbWF0Y2ggc2VhcmNoIHRlcm1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFjZXRzLmZpbHRlcihmYWNldCA9PiAhZmFjZXQuZGlzYWJsZWQpXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZmFjZXQgPT4gIXRoaXMuc2VsZWN0ZWQuZmluZChzZWxlY3RlZEZhY2V0ID0+IHNlbGVjdGVkRmFjZXQgPT09IGZhY2V0KSlcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmYWNldCA9PiBmYWNldC50aXRsZS50b1VwcGVyQ2FzZSgpLmluY2x1ZGVzKHRoaXMuc2VhcmNoUXVlcnkudG9VcHBlckNhc2UoKSkpO1xuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIC8vIGhhbmRsZSBhbiBhcnJheSBvZiBkYXRhXG4gICAgICAgICAgICB0aGlzLnR5cGVhaGVhZE9wdGlvbnMgPSBvZih0aGlzLmZhY2V0cykucGlwZShtYXAoKGZhY2V0czogRmFjZXRbXSkgPT4ge1xuXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGRpc2FibGVkIGZhY2V0cywgc2VsZWN0ZWQgZmFjZXRzIGFuZCBmYWNldHMgdGhhdCBkb250IG1hdGNoIHNlYXJjaCB0ZXJtXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhY2V0cy5maWx0ZXIoZmFjZXQgPT4gIWZhY2V0LmRpc2FibGVkKVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZhY2V0ID0+ICF0aGlzLnNlbGVjdGVkLmZpbmQoc2VsZWN0ZWRGYWNldCA9PiBzZWxlY3RlZEZhY2V0ID09PSBmYWNldCkpXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZmFjZXQgPT4gZmFjZXQudGl0bGUudG9VcHBlckNhc2UoKS5pbmNsdWRlcyh0aGlzLnNlYXJjaFF1ZXJ5LnRvVXBwZXJDYXNlKCkpKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHByb3ZpZGUgZGVmYXVsdCB2YWx1ZXMgZm9yIHR5cGVhaGVhZCBjb25maWdcbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiB0aGlzLl9kZWZhdWx0VHlwZWFoZWFkQ29uZmlnKSB7XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHByb3AgaGFzIGJlZW4gZGVmaW5lZCBpbiB0aGUgdXNlcnMgdHlwZWFoZWFkIGNvbmZpZyAtIGlmIG5vdCBzZXQgZGVmYXVsdCB2YWx1ZVxuICAgICAgICAgICAgaWYgKHRoaXMudHlwZWFoZWFkQ29uZmlnLmhhc093blByb3BlcnR5KHByb3ApID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudHlwZWFoZWFkQ29uZmlnW3Byb3BdID0gdGhpcy5fZGVmYXVsdFR5cGVhaGVhZENvbmZpZ1twcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNlbGVjdE9wdGlvbih0eXBlYWhlYWRPcHRpb246IFR5cGVhaGVhZE1hdGNoKSB7XG5cbiAgICAgICAgLy8gY2hlY2sgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIGl0ZW0gaXMgbm90IGN1cnJlbnRseSBzZWxlY3RlZFxuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZC5maW5kKGZhY2V0ID0+IGZhY2V0ID09PSB0eXBlYWhlYWRPcHRpb24uaXRlbSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNlbGVjdCB0aGUgZmFjZXRcbiAgICAgICAgdGhpcy5zZWxlY3RGYWNldCh0eXBlYWhlYWRPcHRpb24uaXRlbSk7XG5cbiAgICAgICAgLy8gY2xlYXIgdGhlIHR5cGVhaGVhZFxuICAgICAgICB0aGlzLnNlYXJjaFF1ZXJ5ID0gJyc7XG4gICAgfVxuXG4gICAgc2Nyb2xsVG9Gb2N1c2VkKCk6IHZvaWQge1xuXG4gICAgICAgIGxldCBkcm9wZG93biA9IHRoaXMuX25hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcignLmRyb3Bkb3duLW1lbnUnKTtcblxuICAgICAgICAvLyBkZWxheSB0byBhbGxvdyB0aGUgdHlwZWFoZWFkIHVpIHRvIHVwZGF0ZVxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcblxuICAgICAgICAgICAgLy8gZmluZCB0aGUgY3VycmVudGx5IGFjdGl2ZSBlbGVtZW50IGlmIHRoZXJlIGlzIG9uZVxuICAgICAgICAgICAgbGV0IGFjdGl2ZUVsZW1lbnQgPSBkcm9wZG93bi5xdWVyeVNlbGVjdG9yKCcuZHJvcGRvd24tbWVudSA+IGxpLmFjdGl2ZScpO1xuXG4gICAgICAgICAgICBpZiAoYWN0aXZlRWxlbWVudCkge1xuXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgZWxlbWVudCBpcyBub3QgaW4gdmlld1xuICAgICAgICAgICAgICAgIGxldCBlbGVtZW50Qm91bmRzID0gYWN0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICBsZXQgZHJvcGRvd25Cb3VuZHMgPSBkcm9wZG93bi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50Qm91bmRzLnRvcCA8IGRyb3Bkb3duQm91bmRzLnRvcCkge1xuICAgICAgICAgICAgICAgICAgICBkcm9wZG93bi5zY3JvbGxUb3AgKz0gZWxlbWVudEJvdW5kcy50b3AgLSBkcm9wZG93bkJvdW5kcy50b3A7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRCb3VuZHMuYm90dG9tID4gZHJvcGRvd25Cb3VuZHMuYm90dG9tKSB7XG4gICAgICAgICAgICAgICAgICAgIGRyb3Bkb3duLnNjcm9sbFRvcCArPSBlbGVtZW50Qm91bmRzLmJvdHRvbSAtIGRyb3Bkb3duQm91bmRzLmJvdHRvbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZhY2V0VHlwZWFoZWFkTGlzdENvbmZpZyB7XG4gICAgcGxhY2Vob2xkZXI/OiBzdHJpbmc7XG4gICAgbWluQ2hhcmFjdGVycz86IG51bWJlcjtcbiAgICBtYXhSZXN1bHRzPzogbnVtYmVyO1xuICAgIGRlbGF5PzogbnVtYmVyO1xufVxuXG5AUGlwZSh7XG4gICAgbmFtZTogJ2ZhY2V0VHlwZWFoZWFkSGlnaGxpZ2h0J1xufSlcbmV4cG9ydCBjbGFzcyBGYWNldFR5cGVhaGVhZEhpZ2hsaWdodCBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0ge1xuICAgIHRyYW5zZm9ybSh2YWx1ZTogc3RyaW5nLCBzZWFyY2hRdWVyeTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgbGV0IHJlZ2V4ID0gbmV3IFJlZ0V4cChzZWFyY2hRdWVyeSwgJ2knKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UocmVnZXgsIGA8YiBjbGFzcz1cImZhY2V0LXR5cGVhaGVhZC1oaWdobGlnaHRlZFwiPiR7IHZhbHVlLm1hdGNoKHJlZ2V4KSB9PC9iPmApO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgQ2hhbmdlRGV0ZWN0b3JSZWYsIENvbXBvbmVudCwgVGVtcGxhdGVSZWYsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQW5jaG9yUGxhY2VtZW50IH0gZnJvbSAnLi90b29sdGlwLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcblxubGV0IHVuaXF1ZVRvb2x0aXBJZCA9IDA7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ3V4LXRvb2x0aXAnLFxuICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJ0b29sdGlwIGluXCIgW2lkXT1cImlkXCIgW2F0dHIucm9sZV09XCJyb2xlXCIgW25nQ2xhc3NdPVwiW3BsYWNlbWVudCwgY3VzdG9tQ2xhc3NdXCI+XG4gICAgPGRpdiBjbGFzcz1cInRvb2x0aXAtYXJyb3dcIj48L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwidG9vbHRpcC1pbm5lclwiIChjZGtPYnNlcnZlQ29udGVudCk9XCJyZXBvc2l0aW9uKClcIj5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cIiFpc1RlbXBsYXRlUmVmXCI+e3sgY29udGVudCB9fTwvbmctY29udGFpbmVyPlxuICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiaXNUZW1wbGF0ZVJlZlwiIFtuZ1RlbXBsYXRlT3V0bGV0XT1cImNvbnRlbnRcIiBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVwiY29udGV4dFwiPjwvbmctY29udGFpbmVyPlxuICAgIDwvZGl2PlxuPC9kaXY+YCxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgVG9vbHRpcENvbXBvbmVudCBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG5cbiAgLyoqIERlZmluZSBhIHVuaXF1ZSBpZCBmb3IgZWFjaCB0b29sdGlwICovXG4gIGlkOiBzdHJpbmcgPSBgdXgtdG9vbHRpcC0keysrdW5pcXVlVG9vbHRpcElkfWA7XG5cbiAgLyoqIERlZmluZSB0aGUgdG9vbHRpcCByb2xlICovXG4gIHJvbGU6IHN0cmluZyA9ICd0b29sdGlwJztcblxuICAvKiogVGhlIGNvbnRlbnQgb2YgdGhlIHRvb2x0aXAsIGVpdGhlciBhIHN0cmluZyBvciBhIFRlbXBsYXRlUmVmIGZvciBmdXJ0aGVyIGN1c3RvbWl6YXRpb24gKi9cbiAgY29udGVudDogc3RyaW5nIHwgVGVtcGxhdGVSZWY8YW55PjtcblxuICAvKiogQWxsb3cgdGhlIHVzZXIgdG8gc3VwcGx5IGEgY29udGV4dCBmb3IgdGhlIHRvb2x0aXAgVGVtcGxhdGVSZWYgKi9cbiAgY29udGV4dDogYW55O1xuXG4gIC8qKiBUaGUgcG9zaXRpb24gdGhlIHRvb2x0aXAgc2hvdWxkIGRpc3BsYXkgcmVsYXRpdmUgdG8gdGhlIGFzc29jaWF0ZWQgZWxlbWVudCAqL1xuICBwbGFjZW1lbnQ6IEFuY2hvclBsYWNlbWVudDtcblxuICAvKiogQWxsb3cgYSBjdXN0b20gY2xhc3MgdG8gYmUgYWRkZWQgdG8gdGhlIHRvb2x0aXAgdG8gYWxsb3cgY3VzdG9tIHN0eWxpbmcgKi9cbiAgY3VzdG9tQ2xhc3M6IHN0cmluZyA9ICcnO1xuXG4gIC8qKiBJbmRpY2F0ZXMgd2hldGhlciBvciBub3QgdGhlIGNvbnRlbnQgaXMgYSBzdHJpbmcgb3IgYSBUZW1wbGF0ZVJlZiAqL1xuICBpc1RlbXBsYXRlUmVmOiBib29sZWFuID0gZmFsc2U7XG5cbiAgLyoqIEVtaXQgd2hlbiB0aGUgdG9vbHRpcCBuZWVkIHRvIHVwZGF0ZSBpdCdzIHBvc2l0aW9uICovXG4gIHJlcG9zaXRpb24kID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgX2NoYW5nZURldGVjdG9yUmVmOiBDaGFuZ2VEZXRlY3RvclJlZikge31cblxuICAvKiogQ2xlYW51cCBhZnRlciB0aGUgY29tcG9uZW50IGlzIGRlc3Ryb3llZCAqL1xuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLnJlcG9zaXRpb24kLmNvbXBsZXRlKCk7XG4gIH1cblxuICAvKiogSW5mb3JtIHRoZSBwYXJlbnQgZGlyZWN0aXZlIHRoYXQgaXQgbmVlZHMgdG8gcmVjYWx1bGF0ZSB0aGUgcG9zaXRpb24gKi9cbiAgcmVwb3NpdGlvbigpOiB2b2lkIHtcbiAgICB0aGlzLnJlcG9zaXRpb24kLm5leHQoKTtcbiAgfVxuXG4gIC8qKiBUaGlzIHdpbGwgdXBkYXRlIHRoZSBjb250ZW50IG9mIHRoZSB0b29sdGlwIGFuZCB0cmlnZ2VyIGNoYW5nZSBkZXRlY3Rpb24gKi9cbiAgc2V0Q29udGVudChjb250ZW50OiBzdHJpbmcgfCBUZW1wbGF0ZVJlZjxhbnk+KTogdm9pZCB7XG4gICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICB0aGlzLmlzVGVtcGxhdGVSZWYgPSBjb250ZW50IGluc3RhbmNlb2YgVGVtcGxhdGVSZWY7XG4gICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gIH1cblxuICAvKiogVGhpcyB3aWxsIHVwZGF0ZSB0aGUgdG9vbHRpcCBwbGFjZW1lbnQgYW5kIHRyaWdnZXIgY2hhbmdlIGRldGVjdGlvbiAqL1xuICBzZXRQbGFjZW1lbnQocGxhY2VtZW50OiBBbmNob3JQbGFjZW1lbnQpIHtcblxuICAgIGlmICghcGxhY2VtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5wbGFjZW1lbnQgPSBwbGFjZW1lbnQ7XG4gICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gIH1cblxuICAvKiogVGhpcyB3aWxsIHNldCBhIGN1c3RvbSBjbGFzcyBvbiB0aGUgdG9vbHRpcCBhbmQgdHJpZ2dlciBjaGFuZ2UgZGV0ZWN0aW9uICovXG4gIHNldENsYXNzKGN1c3RvbUNsYXNzOiBzdHJpbmcpOiB2b2lkIHtcblxuICAgIGlmICghY3VzdG9tQ2xhc3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmN1c3RvbUNsYXNzID0gY3VzdG9tQ2xhc3M7XG4gICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gIH1cblxuICAvKiogVXBkYXRlcyB0aGUgY29udGV4dCB1c2VkIGJ5IHRoZSBUZW1wbGF0ZVJlZiAqL1xuICBzZXRDb250ZXh0KGNvbnRleHQ6IGFueSk6IHZvaWQge1xuXG4gICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgfVxuXG4gIC8qKiBTcGVjaWZ5IHRoZSB0b29sdGlwIHJvbGUgYXR0cmlidXRlICovXG4gIHNldFJvbGUocm9sZTogc3RyaW5nKTogdm9pZCB7XG5cbiAgICBpZiAoIXJvbGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnJvbGUgPSByb2xlO1xuICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICB9XG59IiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVG9vbHRpcENvbXBvbmVudCB9IGZyb20gJy4vdG9vbHRpcC5jb21wb25lbnQnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBUb29sdGlwU2VydmljZSB7XG4gICAgc2hvd24kID0gbmV3IFN1YmplY3Q8VG9vbHRpcENvbXBvbmVudD4oKTtcbn0iLCJpbXBvcnQgeyBPcmlnaW5Db25uZWN0aW9uUG9zaXRpb24sIE92ZXJsYXksIE92ZXJsYXlDb25uZWN0aW9uUG9zaXRpb24sIE92ZXJsYXlSZWYsIFNjcm9sbERpc3BhdGNoZXIgfSBmcm9tICdAYW5ndWxhci9jZGsvb3ZlcmxheSc7XG5pbXBvcnQgeyBDb21wb25lbnRQb3J0YWwgfSBmcm9tICdAYW5ndWxhci9jZGsvcG9ydGFsJztcbmltcG9ydCB7IENoYW5nZURldGVjdG9yUmVmLCBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE9uQ2hhbmdlcywgT25EZXN0cm95LCBPbkluaXQsIE91dHB1dCwgUmVuZGVyZXIyLCBTaW1wbGVDaGFuZ2VzLCBUZW1wbGF0ZVJlZiwgVmlld0NvbnRhaW5lclJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XG5pbXBvcnQgeyBmcm9tRXZlbnQgfSBmcm9tICdyeGpzL29ic2VydmFibGUvZnJvbUV2ZW50JztcbmltcG9ydCB7IGZpbHRlciwgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgVG9vbHRpcENvbXBvbmVudCB9IGZyb20gJy4vdG9vbHRpcC5jb21wb25lbnQnO1xuaW1wb3J0IHsgVG9vbHRpcFNlcnZpY2UgfSBmcm9tICcuL3Rvb2x0aXAuc2VydmljZSc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3V4VG9vbHRpcF0nLFxuICAgIGV4cG9ydEFzOiAndXgtdG9vbHRpcCdcbn0pXG5leHBvcnQgY2xhc3MgVG9vbHRpcERpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCwgT25DaGFuZ2VzLCBPbkRlc3Ryb3kge1xuXG4gICAgLyoqIENvbnRhaW5zIHRoZSBjb250ZW50IG9mIHRoZSB0b29sdGlwIG9yIGEgVGVtcGxhdGVSZWYgZm9yIG1vcmUgZGV0YWlsZWQgY29udGVudCAqL1xuICAgIEBJbnB1dCgndXhUb29sdGlwJykgY29udGVudDogc3RyaW5nIHwgVGVtcGxhdGVSZWY8YW55PjtcblxuICAgIC8qKiBBbGxvdyB0aGUgdG9vbHRpcCB0byBiZSBjb25kaXRpb25hbGx5IGRpc2FibGVkICovXG4gICAgQElucHV0KCd0b29sdGlwRGlzYWJsZWQnKSBkaXNhYmxlZDogYm9vbGVhbjtcblxuICAgIC8qKiBBbGwgdGhlIHVzZXIgdG8gYWRkIGEgY3VzdG9tIGNsYXNzIHRvIHRoZSB0b29sdGlwICovXG4gICAgQElucHV0KCd0b29sdGlwQ2xhc3MnKSBjdXN0b21DbGFzczogc3RyaW5nID0gJyc7XG5cbiAgICAvKiogQWxsIHRoZSB1c2VyIHRvIGFkZCBhIHJvbGUgdG8gdGhlIHRvb2x0aXAgLSBkZWZhdWx0IGlzIHRvb2x0aXAgKi9cbiAgICBASW5wdXQoJ3Rvb2x0aXBSb2xlJykgcm9sZTogc3RyaW5nID0gJ3Rvb2x0aXAnO1xuXG4gICAgLyoqIFByb3ZpZGUgdGhlIFRlbXBsYXRlUmVmIGEgY29udGV4dCBvYmplY3QgKi9cbiAgICBASW5wdXQoJ3Rvb2x0aXBDb250ZXh0JykgY29udGV4dDogYW55ID0ge307XG5cbiAgICAvKiogRGVsYXkgdGhlIHNob3dpbmcgb2YgdGhlIHRvb2x0aXAgYnkgYSBudW1iZXIgb2YgbWlsaXNlY29uZHMgKi9cbiAgICBASW5wdXQoJ3Rvb2x0aXBEZWxheScpIGRlbGF5OiBudW1iZXIgPSAwO1xuXG4gICAgLyoqIFByb2dyYW1tYXRpY2FsbHkgc2hvdyBhbmQgaGlkZSB0aGUgdG9vbHRpcCAqL1xuICAgIEBJbnB1dCgpIGlzT3BlbjogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqIEN1c3RvbWl6ZSBob3cgdGhlIHRvb2x0aXAgc2hvdWxkIGJlIHBvc2l0aW9uZWQgcmVsYXRpdmUgdG8gdGhlIGVsZW1lbnQgKi9cbiAgICBASW5wdXQoKSBwbGFjZW1lbnQ6IEFuY2hvclBsYWNlbWVudCA9ICd0b3AnO1xuXG4gICAgLyoqIFNwZWNpZnkgd2hpY2ggZXZlbnRzIHNob3VsZCBzaG93IHRoZSB0b29sdGlwICovXG4gICAgQElucHV0KCkgc2hvd1RyaWdnZXJzOiBzdHJpbmdbXSA9IFsnbW91c2VlbnRlcicsICdmb2N1cyddO1xuXG4gICAgLyoqIFNwZWNpZnkgd2hpY2ggZXZlbnRzIHNob3VsZCBoaWRlIHRoZSB0b29sdGlwICovXG4gICAgQElucHV0KCkgaGlkZVRyaWdnZXJzOiBzdHJpbmdbXSA9IFsnbW91c2VsZWF2ZScsICdibHVyJ107XG5cbiAgICAvKiogRW1pdHMgYW4gZXZlbnQgd2hlbiB0aGUgdG9vbHRpcCBpcyBzaG93biAqL1xuICAgIEBPdXRwdXQoKSBzaG93biA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcblxuICAgIC8qKiBFbWl0cyBhIGV2ZW50IHdoZW4gdGhlIHRvb2x0aXAgaXMgaGlkZGVuICovXG4gICAgQE91dHB1dCgpIGhpZGRlbiA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcblxuICAgIC8qKiBBbGxvdyB0d28gd2F5IGJpbmRpbmcgdG8gdHJhY2sgdGhlIHZpc2liaWxpdHkgb2YgdGhlIHRvb2x0aXAgKi9cbiAgICBAT3V0cHV0KCkgaXNPcGVuQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG4gICAgLyoqIEtlZXAgdHJhY2sgb2YgdGhlIHRvb2x0aXAgdmlzaWJpbGl0eSAqL1xuICAgIGlzVmlzaWJsZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqIEEgcmVmZXJlbmNlIHRvIHRoZSBDREsgcG9ydGFsIGNvbnRhaW5pbmcgdGhlIG92ZXJsYXkgKi9cbiAgICBwcm90ZWN0ZWQgX3BvcnRhbDogQ29tcG9uZW50UG9ydGFsPFRvb2x0aXBDb21wb25lbnQ+O1xuXG4gICAgLyoqIEEgcmVmZXJlbmNlIHRvIHRoZSBvdmVybGF5IHRoZSB0b29sdGlwIHdpbGwgYmUgaW5zZXJ0ZWQgaW50byAqL1xuICAgIHByb3RlY3RlZCBfb3ZlcmxheVJlZjogT3ZlcmxheVJlZjtcblxuICAgIC8qKiBBIHJlZmVyZW5jZSB0byB0aGUgaW5zdGFuY2Ugb2YgdGhlIHRvb2x0aXAgY29tcG9uZW50IHdoZW4gY3JlYXRlZCAqL1xuICAgIHByb3RlY3RlZCBfaW5zdGFuY2U6IFRvb2x0aXBDb21wb25lbnQ7XG5cbiAgICAvKiogVGhpcyB3aWxsIGVtaXQgd2hlbiB0aGUgZGlyZWN0aXZlIGlzIGRlc3Ryb3llZCBhbGxvd2luZyB1cyB0byB1bnN1YnNjcmliZSBhbGwgc3Vic2NyaXB0aW9ucyBhdXRvbWF0aWNhbGx5ICovXG4gICAgcHJvdGVjdGVkIF9vbkRlc3Ryb3kgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gICAgLyoqIFN0b3JlIHRoZSB0aW1lb3V0IGludGVydmFsIGZvciBjYW5jZWxhdGlvbiAqL1xuICAgIHByaXZhdGUgX3Nob3dUaW1lb3V0SWQ6IG51bWJlcjtcblxuICAgIC8qKiBJbnRlcm5hbGx5IHN0b3JlIHRoZSB0eXBlIG9mIHRoaXMgY29tcG9uZW50IC0gdXN1YWwgZm9yIGRpc3RpbmN0aW9ucyB3aGVuIGV4dGVuZGluZyB0aGlzIGNsYXNzICovXG4gICAgcHJvdGVjdGVkIF90eXBlOiBzdHJpbmcgPSAndG9vbHRpcCc7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJvdGVjdGVkIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgICAgICBwcm90ZWN0ZWQgX3ZpZXdDb250YWluZXJSZWY6IFZpZXdDb250YWluZXJSZWYsXG4gICAgICAgIHByb3RlY3RlZCBfb3ZlcmxheTogT3ZlcmxheSxcbiAgICAgICAgcHJvdGVjdGVkIF9zY3JvbGxEaXNwYXRjaGVyOiBTY3JvbGxEaXNwYXRjaGVyLFxuICAgICAgICBwcml2YXRlIF9jaGFuZ2VEZXRlY3RvclJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgICAgIHByaXZhdGUgX3JlbmRlcmVyOiBSZW5kZXJlcjIsXG4gICAgICAgIHByaXZhdGUgX3Rvb2x0aXBTZXJ2aWNlOiBUb29sdGlwU2VydmljZVxuICAgICkgeyB9XG5cbiAgICAvKiogU2V0IHVwIHRoZSB0cmlnZ2VycyBhbmQgYmluZCB0byB0aGUgc2hvdy9oaWRlIGV2ZW50cyB0byBrZWVwIHZpc2liaWxpdHkgaW4gc3luYyAqL1xuICAgIG5nT25Jbml0KCk6IHZvaWQge1xuXG4gICAgICAgIC8vIHNldCB1cCBzaG93IGFuZCBoaWRlIGV2ZW50IHRyaWdnZXJzXG4gICAgICAgIGZyb21FdmVudCh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdjbGljaycpLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZSh0aGlzLm9uQ2xpY2suYmluZCh0aGlzKSk7XG4gICAgICAgIGZyb21FdmVudCh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdtb3VzZWVudGVyJykucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSkuc3Vic2NyaWJlKHRoaXMub25Nb3VzZUVudGVyLmJpbmQodGhpcykpO1xuICAgICAgICBmcm9tRXZlbnQodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnbW91c2VsZWF2ZScpLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZSh0aGlzLm9uTW91c2VMZWF2ZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgZnJvbUV2ZW50KHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2ZvY3VzJykucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSkuc3Vic2NyaWJlKHRoaXMub25Gb2N1cy5iaW5kKHRoaXMpKTtcbiAgICAgICAgZnJvbUV2ZW50KHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2JsdXInKS5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUodGhpcy5vbkJsdXIuYmluZCh0aGlzKSk7XG5cbiAgICAgICAgLy8gd2hlbiBhbnkgb3RoZXIgdG9vbHRpcHMgb3BlbiBoaWRlIHRoaXMgb25lXG4gICAgICAgIHRoaXMuX3Rvb2x0aXBTZXJ2aWNlLnNob3duJC5waXBlKFxuICAgICAgICAgICAgZmlsdGVyKCgpID0+IHRoaXMuX3R5cGUgPT09ICd0b29sdGlwJyksXG4gICAgICAgICAgICBmaWx0ZXIodG9vbHRpcCA9PiB0b29sdGlwICE9PSB0aGlzLl9pbnN0YW5jZSksXG4gICAgICAgICAgICB0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KVxuICAgICAgICApLnN1YnNjcmliZSh0aGlzLmhpZGUuYmluZCh0aGlzKSk7XG5cbiAgICAgICAgLy8gaWYgdGhlIHRvb2x0aXAgc2hvdWxkIGJlIGluaXRpYWxseSB2aXNpYmxlIHRoZW4gb3BlbiBpdFxuICAgICAgICBpZiAodGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2UgbmVlZCB0byBzZW5kIGlucHV0IGNoYW5nZXMgdG8gdGhlIHRvb2x0aXAgY29tcG9uZW50XG4gICAgICogV2UgY2FuJ3QgdXNlIHNldHRlcnMgYXMgdGhleSBtYXkgdHJpZ2dlciBiZWZvcmUgdG9vbHRpcCBpbml0aWFsaXNlZCBhbmQgY2FuJ3QgcmVzZW5kIG9uY2UgaW5pdGlhbGlzZWRcbiAgICAgKiovXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xuXG4gICAgICAgIC8vIHdlIGNhbiBpZ25vcmUgdGhlIGZpcnN0IGNoYW5nZSBhcyBpdCdzIGhhbmRsZWQgaW4gbmdPbkluaXRcbiAgICAgICAgaWYgKGNoYW5nZXMuaXNPcGVuICYmICFjaGFuZ2VzLmlzT3Blbi5maXJzdENoYW5nZSAmJiBjaGFuZ2VzLmlzT3Blbi5jdXJyZW50VmFsdWUgIT09IHRoaXMuaXNWaXNpYmxlKSB7XG4gICAgICAgICAgICBjaGFuZ2VzLmlzT3Blbi5jdXJyZW50VmFsdWUgPyB0aGlzLnNob3coKSA6IHRoaXMuaGlkZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZGVzdHJveSB0aGUgb3ZlcmxheSByZWYgc28gYSBuZXcgY29ycmVjdGx5IHBvc2l0aW9uZWQgaW5zdGFuY2Ugd2lsbCBiZSBjcmVhdGVkIG5leHQgdGltZVxuICAgICAgICBpZiAoY2hhbmdlcy5wbGFjZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveU92ZXJsYXkoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9pbnN0YW5jZSAmJiBjaGFuZ2VzLnBsYWNlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5faW5zdGFuY2Uuc2V0UGxhY2VtZW50KGNoYW5nZXMucGxhY2VtZW50LmN1cnJlbnRWYWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5faW5zdGFuY2UgJiYgY2hhbmdlcy5jb250ZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZS5zZXRDb250ZW50KGNoYW5nZXMuY29udGVudC5jdXJyZW50VmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2luc3RhbmNlICYmIGNoYW5nZXMuY3VzdG9tQ2xhc3MpIHtcbiAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlLnNldENsYXNzKGNoYW5nZXMuY3VzdG9tQ2xhc3MuY3VycmVudFZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9pbnN0YW5jZSAmJiBjaGFuZ2VzLmNvbnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlLnNldENvbnRleHQoY2hhbmdlcy5jb250ZXh0LmN1cnJlbnRWYWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5faW5zdGFuY2UgJiYgY2hhbmdlcy5yb2xlKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZS5zZXRDb250ZXh0KGNoYW5nZXMucm9sZS5jdXJyZW50VmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEVuc3VyZSB3ZSBjbGVhbiB1cCBhZnRlciBvdXJzZWx2ZXMgKi9cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcblxuICAgICAgICAvLyBlbnN1cmUgd2UgY2xvc2UgdGhlIHRvb2x0aXAgd2hlbiB0aGUgaG9zdCBpcyBkZXN0cm95ZWRcbiAgICAgICAgaWYgKHRoaXMuX292ZXJsYXlSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlSZWYuZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5faW5zdGFuY2UgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZW1pdCB0aGlzIGV2ZW50IHRvIGF1dG9tYXRpY2FsbHkgdW5zdWJzY3JpYmUgZnJvbSBhbGwgc3Vic2NyaXB0aW9uc1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kubmV4dCgpO1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kuY29tcGxldGUoKTtcbiAgICB9XG5cbiAgICAvKiogTWFrZSB0aGUgdG9vbHRpcCBvcGVuICovXG4gICAgc2hvdygpOiB2b2lkIHtcblxuICAgICAgICAvLyBpZiB0aGUgdG9vbHRpcCBpcyBkaXNhYmxlZCB0aGVuIGRvIG5vdGhpbmdcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQgfHwgdGhpcy5pc1Zpc2libGUgfHwgdGhpcy5fc2hvd1RpbWVvdXRJZCB8fCAhdGhpcy5jb250ZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkZWxheSB0aGUgc2hvdyBieSB0aGUgZGVsYXkgYW1vdW50XG4gICAgICAgIHRoaXMuX3Nob3dUaW1lb3V0SWQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG5cbiAgICAgICAgICAgIC8vIGNyZWF0ZSB0aGUgdG9vbHRpcCBhbmQgZ2V0IHRoZSBvdmVybGF5IHJlZlxuICAgICAgICAgICAgY29uc3Qgb3ZlcmxheVJlZiA9IHRoaXMuY3JlYXRlT3ZlcmxheSgpO1xuXG4gICAgICAgICAgICAvLyBjcmVhdGUgdGhlIHBvcnRhbCB0byBjcmVhdGUgdGhlIHRvb2x0aXAgY29tcG9uZW50XG4gICAgICAgICAgICB0aGlzLl9wb3J0YWwgPSB0aGlzLmNyZWF0ZVBvcnRhbCgpO1xuICAgICAgICAgICAgdGhpcy5faW5zdGFuY2UgPSB0aGlzLmNyZWF0ZUluc3RhbmNlKG92ZXJsYXlSZWYpO1xuXG4gICAgICAgICAgICAvLyB3YXRjaCBmb3IgYW55IGNoYW5nZXMgdG8gdGhlIGNvbnRlbnRcbiAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlLnJlcG9zaXRpb24kLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZSh0aGlzLnJlcG9zaXRpb24uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgICAgIC8vIHN0b3JlIHRoZSB2aXNpYmxlIHN0YXRlXG4gICAgICAgICAgICB0aGlzLmlzVmlzaWJsZSA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIGVuc3VyZSB0aGUgb3ZlcmxheSBoYXMgdGhlIGNvcnJlY3QgaW5pdGlhbCBwb3NpdGlvblxuICAgICAgICAgICAgdGhpcy5yZXBvc2l0aW9uKCk7XG5cbiAgICAgICAgICAgIC8vIGVtaXQgdGhlIHNob3cgZXZlbnRzXG4gICAgICAgICAgICB0aGlzLnNob3duLmVtaXQoKTtcbiAgICAgICAgICAgIHRoaXMuaXNPcGVuQ2hhbmdlLm5leHQodHJ1ZSk7XG5cbiAgICAgICAgICAgIC8vIGNsZWFyIHRoZSBpbnRlcnZhbCBpZFxuICAgICAgICAgICAgdGhpcy5fc2hvd1RpbWVvdXRJZCA9IG51bGw7XG5cbiAgICAgICAgICAgIC8vIGVtaXQgdGhlIHNob3cgZXZlbnQgdG8gY2xvc2UgYW55IG90aGVyIHRvb2x0aXBzXG4gICAgICAgICAgICB0aGlzLl90b29sdGlwU2VydmljZS5zaG93biQubmV4dCh0aGlzLl9pbnN0YW5jZSk7XG5cbiAgICAgICAgICAgIC8vIGVuc3VyZSBjaGFuZ2UgZGV0ZWN0aW9uIGlzIHJ1blxuICAgICAgICAgICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICB9LCB0aGlzLmRlbGF5KTtcblxuICAgIH1cblxuICAgIC8qKiBJZiBhIHRvb2x0aXAgZXhpc3RzIGFuZCBpcyB2aXNpYmxlLCBoaWRlIGl0ICovXG4gICAgaGlkZSgpIHtcblxuICAgICAgICAvLyBpZiB3ZSBhcmUgd2FpdGluZyB0byBzaG93IGEgdG9vbHRpcCB0aGVuIGNhbmNlbCB0aGUgcGVuZGluZyB0aW1lb3V0XG4gICAgICAgIGlmICh0aGlzLl9zaG93VGltZW91dElkKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fc2hvd1RpbWVvdXRJZCk7XG4gICAgICAgICAgICB0aGlzLl9zaG93VGltZW91dElkID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9vdmVybGF5UmVmICYmIHRoaXMuX292ZXJsYXlSZWYuaGFzQXR0YWNoZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5fb3ZlcmxheVJlZi5kZXRhY2goKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0QXJpYURlc2NyaWJlZEJ5KG51bGwpO1xuICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IG51bGw7XG5cbiAgICAgICAgLy8gc3RvcmUgdGhlIHZpc2libGUgc3RhdGVcbiAgICAgICAgdGhpcy5pc1Zpc2libGUgPSBmYWxzZTtcblxuICAgICAgICAvLyBlbWl0IHRoZSBoaWRlIGV2ZW50c1xuICAgICAgICB0aGlzLmhpZGRlbi5lbWl0KCk7XG4gICAgICAgIHRoaXMuaXNPcGVuQ2hhbmdlLm5leHQoZmFsc2UpO1xuXG4gICAgICAgIC8vIGVuc3VyZSBjaGFuZ2UgZGV0ZWN0aW9uIGlzIHJ1blxuICAgICAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgfVxuXG4gICAgLyoqIFRvZ2dsZSB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgdG9vbHRpcCAqL1xuICAgIHRvZ2dsZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5pc1Zpc2libGUgPyB0aGlzLmhpZGUoKSA6IHRoaXMuc2hvdygpO1xuICAgIH1cblxuICAgIC8qKiBSZWNhbGN1bGF0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIHBvcG92ZXIgKi9cbiAgICByZXBvc2l0aW9uKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5pc1Zpc2libGUgJiYgdGhpcy5fb3ZlcmxheVJlZikge1xuICAgICAgICAgICAgdGhpcy5fb3ZlcmxheVJlZi51cGRhdGVQb3NpdGlvbigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIENyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tIHRoZSBvdmVybGF5IHJlZiAtIGFsbG93cyBvdmVycmlkaW5nIGFuZCBhZGRpdGlvbmFsIGxvZ2ljIGhlcmUgKi9cbiAgICBwcm90ZWN0ZWQgY3JlYXRlSW5zdGFuY2Uob3ZlcmxheVJlZjogT3ZlcmxheVJlZik6IFRvb2x0aXBDb21wb25lbnQge1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IG92ZXJsYXlSZWYuYXR0YWNoKHRoaXMuX3BvcnRhbCkuaW5zdGFuY2UgYXMgVG9vbHRpcENvbXBvbmVudDtcblxuICAgICAgICAvLyBzdXBwbHkgdGhlIHRvb2x0aXAgd2l0aCB0aGUgY29ycmVjdCBwcm9wZXJ0aWVzXG4gICAgICAgIGluc3RhbmNlLnNldENvbnRlbnQodGhpcy5jb250ZW50KTtcbiAgICAgICAgaW5zdGFuY2Uuc2V0UGxhY2VtZW50KHRoaXMucGxhY2VtZW50KTtcbiAgICAgICAgaW5zdGFuY2Uuc2V0Q2xhc3ModGhpcy5jdXN0b21DbGFzcyk7XG4gICAgICAgIGluc3RhbmNlLnNldENvbnRleHQodGhpcy5jb250ZXh0KTtcbiAgICAgICAgaW5zdGFuY2Uuc2V0Um9sZSh0aGlzLnJvbGUpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgYXJpYS1kZXNjcmliZWRieSBhdHRyaWJ1dGVcbiAgICAgICAgdGhpcy5zZXRBcmlhRGVzY3JpYmVkQnkoaW5zdGFuY2UuaWQpO1xuXG4gICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9XG5cbiAgICAvKiogQ3JlYXRlIHRoZSBjb21wb25lbnQgcG9ydGFsIC0gYWxsb3dzIG92ZXJyaWRpbmcgdG8gYWxsb3cgb3RoZXIgcG9ydGFscyBlZy4gcG9wb3ZlcnMgKi9cbiAgICBwcm90ZWN0ZWQgY3JlYXRlUG9ydGFsKCk6IENvbXBvbmVudFBvcnRhbDxhbnk+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvcnRhbCB8fCBuZXcgQ29tcG9uZW50UG9ydGFsKFRvb2x0aXBDb21wb25lbnQsIHRoaXMuX3ZpZXdDb250YWluZXJSZWYpO1xuICAgIH1cblxuICAgIC8qKiBDcmVhdGUgdGhlIG92ZXJsYXkgYW5kIHNldCB1cCB0aGUgc2Nyb2xsIGhhbmRsaW5nIGJlaGF2aW9yICovXG4gICAgcHJpdmF0ZSBjcmVhdGVPdmVybGF5KCk6IE92ZXJsYXlSZWYge1xuXG4gICAgICAgIC8vIGlmIHRoZSB0b29sdGlwIGhhcyBhbHJlYWR5IGJlZW4gY3JlYXRlZCB0aGVuIGp1c3QgcmV0dXJuIHRoZSBleGlzdGluZyBpbnN0YW5jZVxuICAgICAgICBpZiAodGhpcy5fb3ZlcmxheVJlZikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX292ZXJsYXlSZWY7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25maWd1cmUgdGhlIHRvb2x0aXBcbiAgICAgICAgY29uc3Qgc3RyYXRlZ3kgPSB0aGlzLl9vdmVybGF5LnBvc2l0aW9uKClcbiAgICAgICAgICAgIC5jb25uZWN0ZWRUbyh0aGlzLl9lbGVtZW50UmVmLCB0aGlzLmdldE9yaWdpbigpLCB0aGlzLmdldE92ZXJsYXlQb3NpdGlvbigpKTtcblxuICAgICAgICAvLyBjb3JyZWN0bHkgaGFuZGxlIHNjcm9sbGluZ1xuICAgICAgICBjb25zdCBzY3JvbGxhYmxlQW5jZXN0b3JzID0gdGhpcy5fc2Nyb2xsRGlzcGF0Y2hlclxuICAgICAgICAgICAgLmdldEFuY2VzdG9yU2Nyb2xsQ29udGFpbmVycyh0aGlzLl9lbGVtZW50UmVmKTtcblxuICAgICAgICBzdHJhdGVneS53aXRoU2Nyb2xsYWJsZUNvbnRhaW5lcnMoc2Nyb2xsYWJsZUFuY2VzdG9ycyk7XG5cbiAgICAgICAgdGhpcy5fb3ZlcmxheVJlZiA9IHRoaXMuX292ZXJsYXkuY3JlYXRlKHtcbiAgICAgICAgICAgIHBvc2l0aW9uU3RyYXRlZ3k6IHN0cmF0ZWd5LFxuICAgICAgICAgICAgcGFuZWxDbGFzczogJ3V4LW92ZXJsYXktcGFuZScsXG4gICAgICAgICAgICBzY3JvbGxTdHJhdGVneTogdGhpcy5fb3ZlcmxheS5zY3JvbGxTdHJhdGVnaWVzLnJlcG9zaXRpb24oeyBzY3JvbGxUaHJvdHRsZTogMCB9KSxcbiAgICAgICAgICAgIGhhc0JhY2tkcm9wOiBmYWxzZVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fb3ZlcmxheVJlZjtcbiAgICB9XG5cbiAgICAvKiogUmVjcmVhdGUgdGhlIG92ZXJsYXkgcmVmIHVzaW5nIHRoZSB1cGRhdGVkIG9yaWdpbiBhbmQgb3ZlcmxheSBwb3NpdGlvbnMgKi9cbiAgICBwcml2YXRlIGRlc3Ryb3lPdmVybGF5KCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGRlc3Ryb3kgdGhlIGV4aXN0aW5nIG92ZXJsYXlcbiAgICAgICAgaWYgKHRoaXMuX292ZXJsYXlSZWYgJiYgdGhpcy5fb3ZlcmxheVJlZi5oYXNBdHRhY2hlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5UmVmLmRldGFjaCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX292ZXJsYXlSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlSZWYuZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5fb3ZlcmxheVJlZiA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmlzVmlzaWJsZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKiBHZXQgdGhlIG9yaWdpbiBwb3NpdGlvbiBiYXNlZCBvbiB0aGUgc3BlY2lmaWVkIHRvb2x0aXAgcGxhY2VtZW50ICovXG4gICAgcHJpdmF0ZSBnZXRPcmlnaW4oKTogT3JpZ2luQ29ubmVjdGlvblBvc2l0aW9uIHtcblxuICAgICAgICAvLyBlbnN1cmUgcGxhY2VtZW50IGlzIGRlZmluZWRcbiAgICAgICAgdGhpcy5wbGFjZW1lbnQgPSB0aGlzLnBsYWNlbWVudCB8fCAndG9wJztcblxuICAgICAgICBpZiAodGhpcy5wbGFjZW1lbnQgPT0gJ3RvcCcgfHwgdGhpcy5wbGFjZW1lbnQgPT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG9yaWdpblg6ICdjZW50ZXInLCBvcmlnaW5ZOiB0aGlzLnBsYWNlbWVudCB9O1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMucGxhY2VtZW50ID09ICdsZWZ0Jykge1xuICAgICAgICAgICAgcmV0dXJuIHsgb3JpZ2luWDogJ3N0YXJ0Jywgb3JpZ2luWTogJ2NlbnRlcicgfTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnBsYWNlbWVudCA9PSAncmlnaHQnKSB7XG4gICAgICAgICAgICByZXR1cm4geyBvcmlnaW5YOiAnZW5kJywgb3JpZ2luWTogJ2NlbnRlcicgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBDYWxjdWxhdGUgdGhlIG92ZXJsYXkgcG9zaXRpb24gYmFzZWQgb24gdGhlIHNwZWNpZmllZCB0b29sdGlwIHBsYWNlbWVudCAqL1xuICAgIHByaXZhdGUgZ2V0T3ZlcmxheVBvc2l0aW9uKCk6IE92ZXJsYXlDb25uZWN0aW9uUG9zaXRpb24ge1xuXG4gICAgICAgIC8vIGVuc3VyZSBwbGFjZW1lbnQgaXMgZGVmaW5lZFxuICAgICAgICB0aGlzLnBsYWNlbWVudCA9IHRoaXMucGxhY2VtZW50IHx8ICd0b3AnO1xuXG4gICAgICAgIGlmICh0aGlzLnBsYWNlbWVudCA9PSAndG9wJykge1xuICAgICAgICAgICAgcmV0dXJuIHsgb3ZlcmxheVg6ICdjZW50ZXInLCBvdmVybGF5WTogJ2JvdHRvbScgfTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnBsYWNlbWVudCA9PSAnYm90dG9tJykge1xuICAgICAgICAgICAgcmV0dXJuIHsgb3ZlcmxheVg6ICdjZW50ZXInLCBvdmVybGF5WTogJ3RvcCcgfTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnBsYWNlbWVudCA9PSAnbGVmdCcpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG92ZXJsYXlYOiAnZW5kJywgb3ZlcmxheVk6ICdjZW50ZXInIH07XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5wbGFjZW1lbnQgPT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgcmV0dXJuIHsgb3ZlcmxheVg6ICdzdGFydCcsIG92ZXJsYXlZOiAnY2VudGVyJyB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2ltcGxlIHV0aWxpdHkgbWV0aG9kIC0gYmVjYXVzZSBJRSBkb2Vzbid0IHN1cHBvcnQgYXJyYXkuaW5jbHVkZXNcbiAgICAgKiBBbmQgaXQgaXNuJ3QgaW5jbHVkZWQgaW4gdGhlIGNvcmUtanMvZXM2IHBvbHlmaWxscyB3aGljaCBhcmUgdGhlXG4gICAgICogb25seSBvbmVzIHJlcXVpcmVkIGJ5IEFuZ3VsYXIgYW5kIGd1YXJhbnRlZWQgdG8gYmUgdGhlcmVcbiAgICAgKiovXG4gICAgcHJvdGVjdGVkIGluY2x1ZGVzPFQ+KGFycmF5OiBBcnJheTxUPiwgdmFsdWU6IFQpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJyYXkpICYmICEhYXJyYXkuZmluZChpdGVtID0+IGl0ZW0gPT09IHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKiogSGFuZGxlIHRoZSBjbGljayBldmVudCAtIHNob3cgb3IgaGlkZSBhY2NvcmRpbmdseSAqL1xuICAgIHByb3RlY3RlZCBvbkNsaWNrKGV2ZW50OiBNb3VzZUV2ZW50KTogdm9pZCB7XG5cbiAgICAgICAgLy8gaWYgaXRzIG5vdCB2aXNpYmxlIGFuZCBjbGljayBpcyBhIHNob3cgdHJpZ2dlciBvcGVuIGl0XG4gICAgICAgIGlmICghdGhpcy5pc1Zpc2libGUgJiYgdGhpcy5pbmNsdWRlcyh0aGlzLnNob3dUcmlnZ2VycywgJ2NsaWNrJykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNob3coKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIGl0cyB2aXNpYmxlIGFuZCBjbGljayBpcyBhIGhpZGUgdHJpZ2dlciBjbG9zZSBpdFxuICAgICAgICBpZiAodGhpcy5pc1Zpc2libGUgJiYgdGhpcy5pbmNsdWRlcyh0aGlzLmhpZGVUcmlnZ2VycywgJ2NsaWNrJykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhpZGUoKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLyoqIEhhbmRsZSB0aGUgbW91c2UgZW50ZXIgZXZlbnQgLSBzaG93IG9yIGhpZGUgYWNjb3JkaW5nbHkgKi9cbiAgICBwcm90ZWN0ZWQgb25Nb3VzZUVudGVyKGV2ZW50OiBNb3VzZUV2ZW50KTogdm9pZCB7XG5cbiAgICAgICAgLy8gdGhpcyBpcyBhbiBzaG93IG9ubHkgdHJpZ2dlciAtIGlmIGFscmVhZHkgb3BlbiBvciBpdCBpc24ndCBhIHRyaWdnZXIgZG8gbm90aGluZ1xuICAgICAgICBpZiAodGhpcy5pc1Zpc2libGUgfHwgIXRoaXMuaW5jbHVkZXModGhpcy5zaG93VHJpZ2dlcnMsICdtb3VzZWVudGVyJykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG90aGVyd2lzZSBvcGVuIHRoZSB0b29sdGlwXG4gICAgICAgIHRoaXMuc2hvdygpO1xuICAgIH1cblxuICAgIC8qKiBIYW5kbGUgdGhlIG1vdXNlIGxlYXZlIGV2ZW50IC0gc2hvdyBvciBoaWRlIGFjY29yZGluZ2x5ICovXG4gICAgcHJvdGVjdGVkIG9uTW91c2VMZWF2ZShldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xuXG4gICAgICAgIC8vIHRoaXMgaXMgYW4gaGlkZSBvbmx5IHRyaWdnZXIgLSBpZiBub3Qgb3BlbiBvciBpdCBpc24ndCBhIHRyaWdnZXIgZG8gbm90aGluZ1xuICAgICAgICBpZiAoIXRoaXMuaXNWaXNpYmxlIHx8ICF0aGlzLmluY2x1ZGVzKHRoaXMuaGlkZVRyaWdnZXJzLCAnbW91c2VsZWF2ZScpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvdGhlcndpc2UgY2xvc2UgdGhlIHRvb2x0aXBcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgfVxuXG4gICAgLyoqIEhhbmRsZSB0aGUgZm9jdXMgZXZlbnQgLSBzaG93IG9yIGhpZGUgYWNjb3JkaW5nbHkgKi9cbiAgICBwcm90ZWN0ZWQgb25Gb2N1cyhldmVudDogRXZlbnQpOiB2b2lkIHtcblxuICAgICAgICAvLyB0aGlzIGlzIGFuIHNob3cgb25seSB0cmlnZ2VyIC0gaWYgYWxyZWFkeSBvcGVuIG9yIGl0IGlzbid0IGEgdHJpZ2dlciBkbyBub3RoaW5nXG4gICAgICAgIGlmICh0aGlzLmlzVmlzaWJsZSB8fCAhdGhpcy5pbmNsdWRlcyh0aGlzLnNob3dUcmlnZ2VycywgJ2ZvY3VzJykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG90aGVyd2lzZSBvcGVuIHRoZSB0b29sdGlwXG4gICAgICAgIHRoaXMuc2hvdygpO1xuICAgIH1cblxuICAgIC8qKiBIYW5kbGUgdGhlIGJsdXIgZXZlbnQgLSBzaG93IG9yIGhpZGUgYWNjb3JkaW5nbHkgKi9cbiAgICBwcm90ZWN0ZWQgb25CbHVyKGV2ZW50OiBFdmVudCk6IHZvaWQge1xuXG4gICAgICAgIC8vIHRoaXMgaXMgYW4gaGlkZSBvbmx5IHRyaWdnZXIgLSBpZiBub3Qgb3BlbiBvciBpdCBpc24ndCBhIHRyaWdnZXIgZG8gbm90aGluZ1xuICAgICAgICBpZiAoIXRoaXMuaXNWaXNpYmxlIHx8ICF0aGlzLmluY2x1ZGVzKHRoaXMuaGlkZVRyaWdnZXJzLCAnYmx1cicpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvdGhlcndpc2UgY2xvc2UgdGhlIHRvb2x0aXBcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgfVxuXG4gICAgLyoqIERldGVybWluZSBpZiB0aGUgdHJpZ2dlciBlbGVtZW50IGlzIGZvY3VzZWQgKi9cbiAgICBwcml2YXRlIGlzRm9jdXNlZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgICB9XG5cbiAgICAvKiogUHJvZ3JhbW1hdGljYWxseSB1cGRhdGUgdGhlIGFyaWEtZGVzY3JpYmVkYnkgcHJvcGVydHkgKi9cbiAgICBwcm90ZWN0ZWQgc2V0QXJpYURlc2NyaWJlZEJ5KGlkOiBzdHJpbmcgfCBudWxsKTogdm9pZCB7XG4gICAgICAgIGlmIChpZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIucmVtb3ZlQXR0cmlidXRlKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2FyaWEtZGVzY3JpYmVkYnknKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEF0dHJpYnV0ZSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdhcmlhLWRlc2NyaWJlZGJ5JywgaWQpO1xuICAgICAgICB9XG4gICAgfVxuXG59XG5cbmV4cG9ydCB0eXBlIEFuY2hvclBsYWNlbWVudCA9ICd0b3AnIHwgJ3JpZ2h0JyB8ICdib3R0b20nIHwgJ2xlZnQnOyIsImltcG9ydCB7IE92ZXJsYXlNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jZGsvb3ZlcmxheSc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFRvb2x0aXBDb21wb25lbnQgfSBmcm9tICcuL3Rvb2x0aXAuY29tcG9uZW50JztcbmltcG9ydCB7IFRvb2x0aXBEaXJlY3RpdmUgfSBmcm9tICcuL3Rvb2x0aXAuZGlyZWN0aXZlJztcbmltcG9ydCB7IE9ic2VydmVyc01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9vYnNlcnZlcnMnO1xuaW1wb3J0IHsgVG9vbHRpcFNlcnZpY2UgfSBmcm9tICcuL3Rvb2x0aXAuc2VydmljZSc7XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtcbiAgICBDb21tb25Nb2R1bGUsXG4gICAgT3ZlcmxheU1vZHVsZSxcbiAgICBPYnNlcnZlcnNNb2R1bGVcbiAgXSxcbiAgZXhwb3J0czogW1Rvb2x0aXBEaXJlY3RpdmVdLFxuICBkZWNsYXJhdGlvbnM6IFtUb29sdGlwQ29tcG9uZW50LCBUb29sdGlwRGlyZWN0aXZlXSxcbiAgcHJvdmlkZXJzOiBbVG9vbHRpcFNlcnZpY2VdLFxuICBlbnRyeUNvbXBvbmVudHM6IFtUb29sdGlwQ29tcG9uZW50XVxufSlcbmV4cG9ydCBjbGFzcyBUb29sdGlwTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgRGlyZWN0aXZlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3V4UmVvcmRlcmFibGVIYW5kbGVdJ1xufSlcbmV4cG9ydCBjbGFzcyBSZW9yZGVyYWJsZUhhbmRsZURpcmVjdGl2ZSB7IH1cbiIsImltcG9ydCB7IERpcmVjdGl2ZSwgSW5wdXQsIEVsZW1lbnRSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbdXhSZW9yZGVyYWJsZU1vZGVsXSdcbn0pXG5leHBvcnQgY2xhc3MgUmVvcmRlcmFibGVNb2RlbERpcmVjdGl2ZSB7XG5cbiAgICAvLyBhbGxvdyB0aGUgdXNlciB0byBzcGVjaWZ5IGEgbW9kZWwgZm9yIHRoZSBpdGVtIC0gYWxsb3dzIHVzZSB3aXRoIG5nRm9yXG4gICAgQElucHV0KCkgdXhSZW9yZGVyYWJsZU1vZGVsOiBhbnk7XG5cbiAgICAvLyB0aGlzIGNhbiBiZSB1c2VkIHRvIGlkZW50aWZ5IHdoaWNoIGluc3RhbmNlIG9mIHRoZSBkaXJlY3RpdmUgcmVsYXRlcyB0byB3aGljaCBlbGVtZW50XG4gICAgY29uc3RydWN0b3IocHVibGljIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYpIHsgfVxufVxuIiwiLy8gV09SS0FST1VORDogQW5ndWxhciBDbGkgNiBoYXMgcmVtb3ZlZCB0aGUgZ2xvYmFscyBwYXRjaCwgZHJhZ3VsYXIgcmVxdWlyZXMgdGhpcyB0byB3ZSBjYW4gcGF0Y2ggaXQgaGVyZVxuKDxhbnk+d2luZG93KS5nbG9iYWwgPSAoPGFueT53aW5kb3cpLmdsb2JhbCB8fCB7fTtcblxuLy8gV09SS0FST1VORDogbmctcGFja2FnciBpc3N1ZSAtIGh0dHBzOi8vZ2l0aHViLmNvbS9kaGVyZ2VzL25nLXBhY2thZ3IvaXNzdWVzLzE2M1xuaW1wb3J0ICogYXMgZHJhZ3VsYU5hbWVzcGFjZSBmcm9tICdkcmFndWxhJztcbmltcG9ydCB7IERyYWtlIH0gZnJvbSAnZHJhZ3VsYSc7XG5cbmV4cG9ydCBjb25zdCBkcmFndWxhOiAoY29udGFpbmVycz86IGFueSwgb3B0aW9ucz86IGFueSkgPT4gRHJha2UgPSAoZHJhZ3VsYU5hbWVzcGFjZSBhcyBhbnkpLmRlZmF1bHQgfHwgZHJhZ3VsYU5hbWVzcGFjZTsiLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBFdmVudEVtaXR0ZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IERyYWtlLCBEcmFndWxhT3B0aW9ucyB9IGZyb20gJ2RyYWd1bGEnO1xuaW1wb3J0IHsgZHJhZ3VsYSB9IGZyb20gJy4vZHJhZ3VsYSc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBSZW9yZGVyYWJsZVNlcnZpY2Uge1xuXG4gICAgcHJpdmF0ZSBfZ3JvdXBzOiB7IFtrOiBzdHJpbmddOiBSZW9yZGVyYWJsZUdyb3VwIH0gPSB7fTtcbiAgICBwcml2YXRlIF91bmlxdWVHcm91cElkID0gMDtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSB1bmlxdWUgc3RyaW5nIHdoaWNoIGNhbiBiZSB1c2VkIGFzIGEgZ3JvdXAgbmFtZSBpZiBvbmUgd2FzIG5vdCBjb25maWd1cmVkLlxuICAgICAqL1xuICAgIGdldFVuaXF1ZUdyb3VwTmFtZSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gJ191eFJlb3JkZXJhYmxlXycgKyB0aGlzLl91bmlxdWVHcm91cElkKys7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyB0aGUgY29udGFpbmVyIHRvIHRoZSBuYW1lZCBncm91cC5cbiAgICAgKi9cbiAgICByZWdpc3Rlcihncm91cE5hbWU6IHN0cmluZywgY29udGFpbmVyOiBSZW9yZGVyYWJsZUNvbnRhaW5lcik6IFJlb3JkZXJhYmxlR3JvdXAge1xuXG4gICAgICAgIGlmICghdGhpcy5fZ3JvdXBzW2dyb3VwTmFtZV0pIHtcbiAgICAgICAgICAgIHRoaXMuX2dyb3Vwc1tncm91cE5hbWVdID0gbmV3IFJlb3JkZXJhYmxlR3JvdXAoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2dyb3Vwc1tncm91cE5hbWVdLnJlZ2lzdGVyKGNvbnRhaW5lcik7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2dyb3Vwc1tncm91cE5hbWVdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGNvbnRhaW5lciBmcm9tIHRoZSBuYW1lZCBncm91cC4gSWYgaXQgd2FzIHRoZSBsYXN0IGNvbnRhaW5lciBpbiB0aGUgZ3JvdXAsIGRlc3Ryb3lzIHRoZSBncm91cC5cbiAgICAgKi9cbiAgICB1bnJlZ2lzdGVyKGdyb3VwTmFtZTogc3RyaW5nLCBjb250YWluZXI6IFJlb3JkZXJhYmxlQ29udGFpbmVyKTogdm9pZCB7XG5cbiAgICAgICAgY29uc3QgZ3JvdXAgPSB0aGlzLl9ncm91cHNbZ3JvdXBOYW1lXTtcblxuICAgICAgICBpZiAoZ3JvdXApIHtcbiAgICAgICAgICAgIGdyb3VwLnVucmVnaXN0ZXIoY29udGFpbmVyKTtcblxuICAgICAgICAgICAgaWYgKGdyb3VwLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgIGdyb3VwLmRlc3Ryb3koKTtcblxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ncm91cHNbZ3JvdXBOYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIGRyYWd1bGEgaW5zdGFuY2Ugd2l0aCB0aGUgY3VycmVudCBjb25maWcgYW5kIGF0dGFjaGVzIHRoZSBldmVudHMsIGlmIG5vdCBhbHJlYWR5IGNyZWF0ZWQuXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZShncm91cE5hbWU6IHN0cmluZyk6IFJlb3JkZXJhYmxlR3JvdXAge1xuXG4gICAgICAgIGNvbnN0IGdyb3VwID0gdGhpcy5fZ3JvdXBzW2dyb3VwTmFtZV07XG5cbiAgICAgICAgaWYgKGdyb3VwKSB7XG4gICAgICAgICAgICBncm91cC5pbml0aWFsaXplKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZ3JvdXAgb2JqZWN0IGZvciB0aGUgZ2l2ZW4gbmFtZS5cbiAgICAgKi9cbiAgICBnZXRHcm91cChncm91cDogc3RyaW5nKTogUmVvcmRlcmFibGVHcm91cCB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ncm91cHNbZ3JvdXBdO1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZW9yZGVyYWJsZUNvbnRhaW5lciB7XG4gICAgZWxlbWVudDogRWxlbWVudDtcbiAgICBnZXRNb2RlbEZyb21FbGVtZW50OiAoZWxlbWVudDogRWxlbWVudCkgPT4gYW55O1xuICAgIGNhbk1vdmU6IChlbGVtZW50OiBFbGVtZW50LCBjb250YWluZXI6IEVsZW1lbnQsIGhhbmRsZTogRWxlbWVudCkgPT4gYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZW9yZGVyYWJsZURyYWdFdmVudCB7XG4gICAgbW9kZWw6IGFueTtcbiAgICBlbGVtZW50OiBFbGVtZW50O1xuICAgIHNvdXJjZTogRWxlbWVudDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZW9yZGVyYWJsZURyYWdFbmRFdmVudCB7XG4gICAgbW9kZWw6IGFueTtcbiAgICBlbGVtZW50OiBFbGVtZW50O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlb3JkZXJhYmxlRHJvcEV2ZW50IHtcbiAgICBtb2RlbDogYW55O1xuICAgIGVsZW1lbnQ6IEVsZW1lbnQ7XG4gICAgdGFyZ2V0OiBFbGVtZW50O1xuICAgIHNvdXJjZTogRWxlbWVudDtcbiAgICBzaWJsaW5nOiBFbGVtZW50O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlb3JkZXJhYmxlQ2FuY2VsRXZlbnQge1xuICAgIG1vZGVsOiBhbnk7XG4gICAgZWxlbWVudDogRWxlbWVudDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZW9yZGVyYWJsZUNsb25lZEV2ZW50IHtcbiAgICBjbG9uZTogRWxlbWVudDtcbiAgICBlbGVtZW50OiBFbGVtZW50O1xuICAgIHR5cGU6IHN0cmluZztcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgY29sbGVjdGlvbiBvZiBkcmFnLWFuZC1kcm9wIGNvbnRhaW5lcnMgKHV4UmVvcmRlcmFibGUpIHRoYXQgaXRlbXMgY2FuIGJlIGRyYWdnZWQgYmV0d2Vlbi5cbiAqL1xuZXhwb3J0IGNsYXNzIFJlb3JkZXJhYmxlR3JvdXAge1xuXG4gICAgZHJhZyA9IG5ldyBFdmVudEVtaXR0ZXI8UmVvcmRlcmFibGVEcmFnRXZlbnQ+KCk7XG4gICAgZHJhZ0VuZCA9IG5ldyBFdmVudEVtaXR0ZXI8UmVvcmRlcmFibGVEcmFnRW5kRXZlbnQ+KCk7XG4gICAgZHJvcCA9IG5ldyBFdmVudEVtaXR0ZXI8UmVvcmRlcmFibGVEcm9wRXZlbnQ+KCk7XG4gICAgY2FuY2VsID0gbmV3IEV2ZW50RW1pdHRlcjxSZW9yZGVyYWJsZUNhbmNlbEV2ZW50PigpO1xuICAgIGNsb25lZCA9IG5ldyBFdmVudEVtaXR0ZXI8UmVvcmRlcmFibGVDbG9uZWRFdmVudD4oKTtcblxuICAgIHByaXZhdGUgX2luc3RhbmNlOiBEcmFrZTtcbiAgICBwcml2YXRlIF9jb250YWluZXJzOiBSZW9yZGVyYWJsZUNvbnRhaW5lcltdID0gW107XG5cbiAgICBwcml2YXRlIF9jb25maWc6IERyYWd1bGFPcHRpb25zID0ge1xuICAgICAgICBtb3ZlczogdGhpcy5jYW5Nb3ZlLmJpbmQodGhpcylcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZXJlIGFyZSBubyBjb250YWluZXJzIHJlZ2lzdGVyZWQgd2l0aCB0aGUgZ3JvdXAuXG4gICAgICovXG4gICAgaXNFbXB0eSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lcnMubGVuZ3RoID09PSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1vZGVsIG9iamVjdCAodXhSZW9yZGVyYWJsZU1vZGVsKSBmb3IgYW4gZWxlbWVudHMgaW4gb25lIG9mIHRoZSBjb250YWluZXJzIGluIHRoZSBncm91cC5cbiAgICAgKi9cbiAgICBnZXRNb2RlbEZvckVsZW1lbnQoZWxlbWVudDogRWxlbWVudCk6IGFueSB7XG4gICAgICAgIGZvciAoY29uc3QgY29udGFpbmVyIG9mIHRoaXMuX2NvbnRhaW5lcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IG1vZGVsID0gY29udGFpbmVyLmdldE1vZGVsRnJvbUVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgICAgICBpZiAobW9kZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSBjb250YWluZXIgdG8gdGhlIGdyb3VwLlxuICAgICAqL1xuICAgIHJlZ2lzdGVyKGNvbnRhaW5lcjogUmVvcmRlcmFibGVDb250YWluZXIpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fY29udGFpbmVycy5wdXNoKGNvbnRhaW5lcik7XG5cbiAgICAgICAgaWYgKHRoaXMuX2luc3RhbmNlKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZS5jb250YWluZXJzID0gdGhpcy5fY29udGFpbmVycy5tYXAoKGMpID0+IGMuZWxlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX2NvbmZpZy5taXJyb3JDb250YWluZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbmZpZy5taXJyb3JDb250YWluZXIgPSBjb250YWluZXIuZWxlbWVudDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGNvbnRhaW5lciBmcm9tIHRoZSBncm91cC5cbiAgICAgKi9cbiAgICB1bnJlZ2lzdGVyKGNvbnRhaW5lcjogUmVvcmRlcmFibGVDb250YWluZXIpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9jb250YWluZXJzLmluZGV4T2YoY29udGFpbmVyKTtcbiAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlLmNvbnRhaW5lcnMgPSB0aGlzLl9jb250YWluZXJzLm1hcCgoYykgPT4gYy5lbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIGRyYWd1bGEgaW5zdGFuY2Ugd2l0aCB0aGUgY3VycmVudCBjb25maWcgYW5kIGF0dGFjaGVzIHRoZSBldmVudHMsIGlmIG5vdCBhbHJlYWR5IGNyZWF0ZWQuXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZSgpOiB2b2lkIHtcblxuICAgICAgICBpZiAodGhpcy5faW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2luc3RhbmNlID0gZHJhZ3VsYSh0aGlzLl9jb250YWluZXJzLm1hcCgoYykgPT4gYy5lbGVtZW50KSwgdGhpcy5fY29uZmlnKTtcblxuICAgICAgICB0aGlzLl9pbnN0YW5jZS5vbignZHJhZycsIChlbGVtZW50OiBFbGVtZW50LCBzb3VyY2U6IEVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZHJhZy5lbWl0KHtcbiAgICAgICAgICAgICAgICBtb2RlbDogdGhpcy5nZXRNb2RlbEZvckVsZW1lbnQoZWxlbWVudCksXG4gICAgICAgICAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9pbnN0YW5jZS5vbignZHJhZ2VuZCcsIChlbGVtZW50OiBFbGVtZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRyYWdFbmQuZW1pdCh7XG4gICAgICAgICAgICAgICAgbW9kZWw6IHRoaXMuZ2V0TW9kZWxGb3JFbGVtZW50KGVsZW1lbnQpLFxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5faW5zdGFuY2Uub24oJ2Ryb3AnLCAoZWxlbWVudDogRWxlbWVudCwgdGFyZ2V0OiBFbGVtZW50LCBzb3VyY2U6IEVsZW1lbnQsIHNpYmxpbmc6IEVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZHJvcC5lbWl0KHtcbiAgICAgICAgICAgICAgICBtb2RlbDogdGhpcy5nZXRNb2RlbEZvckVsZW1lbnQoZWxlbWVudCksXG4gICAgICAgICAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICAgICAgICBzaWJsaW5nOiBzaWJsaW5nXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2luc3RhbmNlLm9uKCdjYW5jZWwnLCAoZWxlbWVudDogRWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jYW5jZWwuZW1pdCh7XG4gICAgICAgICAgICAgICAgbW9kZWw6IHRoaXMuZ2V0TW9kZWxGb3JFbGVtZW50KGVsZW1lbnQpLFxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5faW5zdGFuY2Uub24oJ2Nsb25lZCcsIChjbG9uZTogRWxlbWVudCwgZWxlbWVudDogRWxlbWVudCwgdHlwZTogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNsb25lZC5lbWl0KHtcbiAgICAgICAgICAgICAgICBjbG9uZTogY2xvbmUsXG4gICAgICAgICAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgdGhlIGRyYWd1bGEgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuX2luc3RhbmNlKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZS5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgY29udGFpbmVyIGZvciB0aGUgY29udGFpbmVyRWxlbWVudCBhbmQgcmV0dXJucyB0aGUgcmVzdWx0cyBvZiBjYW5Nb3ZlLlxuICAgICAqL1xuICAgIHByaXZhdGUgY2FuTW92ZShlbGVtZW50OiBFbGVtZW50LCBjb250YWluZXJFbGVtZW50OiBFbGVtZW50LCBoYW5kbGU6IEVsZW1lbnQpOiBib29sZWFuIHtcbiAgICAgICAgZm9yIChsZXQgY29udGFpbmVyIG9mIHRoaXMuX2NvbnRhaW5lcnMpIHtcbiAgICAgICAgICAgIGlmIChjb250YWluZXIuZWxlbWVudC5pc1NhbWVOb2RlKGNvbnRhaW5lckVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5lci5jYW5Nb3ZlKGVsZW1lbnQsIGNvbnRhaW5lckVsZW1lbnQsIGhhbmRsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQgeyBBZnRlclZpZXdJbml0LCBDb250ZW50Q2hpbGRyZW4sIERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBIb3N0QmluZGluZywgSW5wdXQsIE9uRGVzdHJveSwgT25Jbml0LCBPdXRwdXQsIFF1ZXJ5TGlzdCwgUmVuZGVyZXIyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBSZW9yZGVyYWJsZUhhbmRsZURpcmVjdGl2ZSB9IGZyb20gJy4vcmVvcmRlcmFibGUtaGFuZGxlLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBSZW9yZGVyYWJsZU1vZGVsRGlyZWN0aXZlIH0gZnJvbSAnLi9yZW9yZGVyYWJsZS1tb2RlbC5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgUmVvcmRlcmFibGVDYW5jZWxFdmVudCwgUmVvcmRlcmFibGVDbG9uZWRFdmVudCwgUmVvcmRlcmFibGVDb250YWluZXIsIFJlb3JkZXJhYmxlRHJhZ0VuZEV2ZW50LCBSZW9yZGVyYWJsZURyYWdFdmVudCwgUmVvcmRlcmFibGVEcm9wRXZlbnQsIFJlb3JkZXJhYmxlU2VydmljZSB9IGZyb20gJy4vcmVvcmRlcmFibGUuc2VydmljZSc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3V4UmVvcmRlcmFibGVdJ1xufSlcbmV4cG9ydCBjbGFzcyBSZW9yZGVyYWJsZURpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCwgQWZ0ZXJWaWV3SW5pdCwgT25EZXN0cm95IHtcblxuICAgIEBJbnB1dCgpIHJlb3JkZXJhYmxlTW9kZWw6IEFycmF5PGFueT47XG4gICAgQElucHV0KCkgcmVvcmRlcmFibGVHcm91cDogc3RyaW5nO1xuICAgIEBJbnB1dCgpIHJlb3JkZXJpbmdEaXNhYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIEBPdXRwdXQoKSByZW9yZGVyYWJsZU1vZGVsQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxBcnJheTxhbnk+PigpO1xuICAgIEBPdXRwdXQoKSByZW9yZGVyU3RhcnQgPSBuZXcgRXZlbnRFbWl0dGVyPFJlb3JkZXJFdmVudD4oKTtcbiAgICBAT3V0cHV0KCkgcmVvcmRlckNhbmNlbCA9IG5ldyBFdmVudEVtaXR0ZXI8UmVvcmRlckV2ZW50PigpO1xuICAgIEBPdXRwdXQoKSByZW9yZGVyRW5kID0gbmV3IEV2ZW50RW1pdHRlcjxSZW9yZGVyRXZlbnQ+KCk7XG5cbiAgICBAQ29udGVudENoaWxkcmVuKFJlb3JkZXJhYmxlSGFuZGxlRGlyZWN0aXZlLCB7IHJlYWQ6IEVsZW1lbnRSZWYsIGRlc2NlbmRhbnRzOiB0cnVlIH0pIGhhbmRsZXM6IFF1ZXJ5TGlzdDxFbGVtZW50UmVmPjtcbiAgICBAQ29udGVudENoaWxkcmVuKFJlb3JkZXJhYmxlTW9kZWxEaXJlY3RpdmUpIG1vZGVsczogUXVlcnlMaXN0PFJlb3JkZXJhYmxlTW9kZWxEaXJlY3RpdmU+O1xuXG4gICAgcHJpdmF0ZSBfY29udGFpbmVyOiBSZW9yZGVyYWJsZUNvbnRhaW5lcjtcblxuICAgIEBIb3N0QmluZGluZygnY2xhc3MudXgtcmVvcmRlcmFibGUtY29udGFpbmVyLW1vdmluZycpIGRyYWdnaW5nID0gZmFsc2U7XG5cbiAgICBwcml2YXRlIF9zdWJzY3JpcHRpb25zID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYsXG4gICAgICAgIHByaXZhdGUgX3JlbmRlcmVyOiBSZW5kZXJlcjIsXG4gICAgICAgIHByaXZhdGUgX3NlcnZpY2U6IFJlb3JkZXJhYmxlU2VydmljZVxuICAgICkgeyB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXNlIGRyYWd1bGEgYW5kIGJpbmQgdG8gYWxsIHRoZSByZXF1aXJlZCBldmVudHNcbiAgICAgKi9cbiAgICBuZ09uSW5pdCgpOiB2b2lkIHtcblxuICAgICAgICAvLyBJZiBubyBncm91cCBuYW1lIHRoZW4gZ2VuZXJhdGUgYSB1bmlxdWUgb25lIGZvciB0aGlzIGluc3RhbmNlIG9ubHlcbiAgICAgICAgaWYgKCF0aGlzLnJlb3JkZXJhYmxlR3JvdXApIHtcbiAgICAgICAgICAgIHRoaXMucmVvcmRlcmFibGVHcm91cCA9IHRoaXMuX3NlcnZpY2UuZ2V0VW5pcXVlR3JvdXBOYW1lKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jb250YWluZXIgPSB7XG4gICAgICAgICAgICBlbGVtZW50OiB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsXG4gICAgICAgICAgICBnZXRNb2RlbEZyb21FbGVtZW50OiB0aGlzLmdldE1vZGVsRnJvbUVsZW1lbnQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGNhbk1vdmU6IHRoaXMuY2FuTW92ZS5iaW5kKHRoaXMpXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gUmVnaXN0ZXIgZm9yIGRyYWcgZXZlbnRzIG9uIHRoaXMgZWxlbWVudFxuICAgICAgICBjb25zdCBncm91cCA9IHRoaXMuX3NlcnZpY2UucmVnaXN0ZXIodGhpcy5yZW9yZGVyYWJsZUdyb3VwLCB0aGlzLl9jb250YWluZXIpO1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zLmFkZChncm91cC5kcmFnLnN1YnNjcmliZSh0aGlzLm9uRHJhZy5iaW5kKHRoaXMpKSk7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMuYWRkKGdyb3VwLmRyYWdFbmQuc3Vic2NyaWJlKHRoaXMub25EcmFnRW5kLmJpbmQodGhpcykpKTtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9ucy5hZGQoZ3JvdXAuZHJvcC5zdWJzY3JpYmUodGhpcy5vbkRyb3AuYmluZCh0aGlzKSkpO1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zLmFkZChncm91cC5jYW5jZWwuc3Vic2NyaWJlKChldmVudDogUmVvcmRlcmFibGVDYW5jZWxFdmVudCkgPT4gdGhpcy5yZW9yZGVyQ2FuY2VsLmVtaXQoeyBlbGVtZW50OiBldmVudC5lbGVtZW50LCBtb2RlbDogZXZlbnQubW9kZWwgfSkpKTtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9ucy5hZGQoZ3JvdXAuY2xvbmVkLnN1YnNjcmliZSh0aGlzLm9uQ2xvbmUuYmluZCh0aGlzKSkpO1xuICAgIH1cblxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fc2VydmljZS5pbml0aWFsaXplKHRoaXMucmVvcmRlcmFibGVHcm91cCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2UgbmVlZCB0byBkZXN0cm95IHRoZSBkcmFndWxhIGluc3RhbmNlIG9uIGNvbXBvbmVudCBkZXN0cm95XG4gICAgICovXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3NlcnZpY2UudW5yZWdpc3Rlcih0aGlzLnJlb3JkZXJhYmxlR3JvdXAsIHRoaXMuX2NvbnRhaW5lcik7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMudW5zdWJzY3JpYmUoKTtcbiAgICB9XG5cbiAgICBvbkRyYWcoZXZlbnQ6IFJlb3JkZXJhYmxlRHJhZ0V2ZW50KTogdm9pZCB7XG5cbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5yZW9yZGVyU3RhcnQuZW1pdCh7IGVsZW1lbnQ6IGV2ZW50LmVsZW1lbnQsIG1vZGVsOiBldmVudC5tb2RlbCB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIGZpcmVkIHdoZW4gaXRlbXMgZ2V0IHJlb3JkZXJlZCAtIHdlIG5lZWQgdG8gZW1pdCB0aGUgbmV3IG9yZGVyIG9mIHRoZSBtb2RlbHNcbiAgICAgKi9cbiAgICBvbkRyb3AoZXZlbnQ6IFJlb3JkZXJhYmxlRHJvcEV2ZW50KTogdm9pZCB7XG5cbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gcHJvdmlkZWQgbW9kdWxlIHdlIGNhbiBza2lwIHRoaXNcbiAgICAgICAgaWYgKCF0aGlzLnJlb3JkZXJhYmxlTW9kZWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGV2ZW50LnNvdXJjZS5pc1NhbWVOb2RlKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCkpIHtcblxuICAgICAgICAgICAgLy8gcmVtb3ZlIHRoaXMgbW9kZWwgZnJvbSB0aGUgbGlzdCBvZiBtb2RlbHNcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5yZW9yZGVyYWJsZU1vZGVsLmluZGV4T2YoZXZlbnQubW9kZWwpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlb3JkZXJhYmxlTW9kZWwuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldmVudC50YXJnZXQuaXNTYW1lTm9kZSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpKSB7XG5cbiAgICAgICAgICAgIC8vIGdldCB0aGUgcG9zaXRpb24gb2Ygc2libGluZyBlbGVtZW50XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGV2ZW50LnNpYmxpbmcgJiYgIWV2ZW50LnNpYmxpbmcuY2xhc3NMaXN0LmNvbnRhaW5zKCdndS1taXJyb3InKSA/XG4gICAgICAgICAgICAgICAgdGhpcy5yZW9yZGVyYWJsZU1vZGVsLmluZGV4T2YodGhpcy5nZXRNb2RlbEZyb21FbGVtZW50KGV2ZW50LnNpYmxpbmcpKSA6XG4gICAgICAgICAgICAgICAgdGhpcy5yZW9yZGVyYWJsZU1vZGVsLmxlbmd0aDtcblxuICAgICAgICAgICAgLy8gaW5zZXJ0IHRoZSBtb2RlbCBhdCBpdHMgbmV3IGxvY2F0aW9uXG4gICAgICAgICAgICB0aGlzLnJlb3JkZXJhYmxlTW9kZWwuc3BsaWNlKGluZGV4LCAwLCBldmVudC5tb2RlbCk7XG4gICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVtaXQgZXZlbnQgaWYgYW55IGNoYW5nZXMgd2VyZSBtYWRlXG4gICAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLnJlb3JkZXJhYmxlTW9kZWxDaGFuZ2UuZW1pdCh0aGlzLnJlb3JkZXJhYmxlTW9kZWwpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBtb2RlbCBhc3NjaWF0ZWQgd2l0aCBhIHBhcnRpY3VsYXIgZWxlbWVudCBpbiB0aGUgbGlzdC5cbiAgICAgKiBUaGlzIHNob3VsZCBlbnN1cmUgdGhhdCB0aGUgaXRlbXMgaGF2ZSB0aGUgZHJhZ2dhYmxlIG1vZGVsIGRpcmVjdGl2ZSBhcHBsaWVkXG4gICAgICovXG4gICAgZ2V0TW9kZWxGcm9tRWxlbWVudChlbGVtZW50OiBFbGVtZW50KTogYW55IHtcblxuICAgICAgICBjb25zdCBtb2RlbCA9IHRoaXMubW9kZWxzLmZpbmQoX21vZGVsID0+IF9tb2RlbC5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQgPT09IGVsZW1lbnQpO1xuXG4gICAgICAgIGlmICghbW9kZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1vZGVsLnV4UmVvcmRlcmFibGVNb2RlbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHdlIGZpbmlzaCBkcmFnZ2luZyByZW1vdmUgdGhlIHV0aWxsaXR5IGNsYXNzIGZyb20gdGhlIGVsZW1lbnQgYmVpbmcgbW92ZWRcbiAgICAgKi9cbiAgICBvbkRyYWdFbmQoZXZlbnQ6IFJlb3JkZXJhYmxlRHJhZ0VuZEV2ZW50KTogdm9pZCB7XG5cbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuXG4gICAgICAgIGlmICh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuY29udGFpbnMoZXZlbnQuZWxlbWVudCkpIHtcblxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIucmVtb3ZlQ2xhc3MoZXZlbnQuZWxlbWVudCwgJ3V4LXJlb3JkZXJhYmxlLW1vdmluZycpO1xuXG4gICAgICAgICAgICB0aGlzLnJlb3JkZXJFbmQuZW1pdCh7XG4gICAgICAgICAgICAgICAgZWxlbWVudDogZXZlbnQuZWxlbWVudCxcbiAgICAgICAgICAgICAgICBtb2RlbDogZXZlbnQubW9kZWxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2Ugd2FudCB0byBlbnN1cmUgdGhhdCB0aGUgY2xvbmVkIGVsZW1lbnQgaXMgaWRlbnRpY2FsXG4gICAgICogdG8gdGhlIG9yaWdpbmFsLCByZWdhcmRsZXNzIG9mIGl0J3MgbG9jYXRpb24gaW4gdGhlIERPTSB0cmVlXG4gICAgICovXG4gICAgb25DbG9uZShldmVudDogUmVvcmRlcmFibGVDbG9uZWRFdmVudCk6IHZvaWQge1xuXG4gICAgICAgIGlmICh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuY29udGFpbnMoZXZlbnQuZWxlbWVudCkpIHtcblxuICAgICAgICAgICAgdGhpcy5zZXRUYWJsZUNlbGxXaWR0aHMoZXZlbnQuZWxlbWVudCwgZXZlbnQuY2xvbmUpO1xuICAgICAgICAgICAgdGhpcy5jYXB0dXJlQ2FudmFzZXMoZXZlbnQuZWxlbWVudCwgZXZlbnQuY2xvbmUpO1xuXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5hZGRDbGFzcyhldmVudC5lbGVtZW50LCAndXgtcmVvcmRlcmFibGUtbW92aW5nJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZiBlbGVtZW50cyBjb250YWluIGhhbmRsZXMgdGhlbiBvbmx5IGRyYWcgd2hlbiB0aGUgaGFuZGxlIGlzIGRyYWdnZWRcbiAgICAgKiBvdGhlcndpc2UgZHJhZyB3aGVuZXZlciBhbiBpbW1lZGlhdGUgY2hpbGQgaXMgc3BlY2lmaWVkXG4gICAgICovXG4gICAgY2FuTW92ZShlbGVtZW50OiBFbGVtZW50LCBjb250YWluZXI6IEVsZW1lbnQsIGhhbmRsZTogRWxlbWVudCk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAodGhpcy5yZW9yZGVyaW5nRGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVzLmxlbmd0aCA9PT0gMCA/IHRydWUgOiAhIXRoaXMuaGFuZGxlcy5maW5kKF9oYW5kbGUgPT4gX2hhbmRsZS5uYXRpdmVFbGVtZW50ID09PSBoYW5kbGUpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc2V0VGFibGVDZWxsV2lkdGhzKHNvdXJjZTogRWxlbWVudCwgdGFyZ2V0OiBFbGVtZW50KTogdm9pZCB7XG5cbiAgICAgICAgLy8gaWYgaXQgaXMgbm90IGEgdGFibGUgcm93IHRoZW4gc2tpcCB0aGlzXG4gICAgICAgIGlmIChzb3VyY2UudGFnTmFtZSAhPT0gJ1RSJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmluZCBhbnkgaW1tZWRpYXRlIHRkIGNoaWxkcmVuIGFuZCBmaXggdGhlaXIgd2lkdGhcbiAgICAgICAgY29uc3Qgc291cmNlQ2VsbHMgPSBBcnJheS5mcm9tKHNvdXJjZS5jaGlsZHJlbikgYXMgSFRNTFRhYmxlQ2VsbEVsZW1lbnRbXTtcbiAgICAgICAgY29uc3QgdGFyZ2V0Q2VsbHMgPSBBcnJheS5mcm9tKHRhcmdldC5jaGlsZHJlbikgYXMgSFRNTFRhYmxlQ2VsbEVsZW1lbnRbXTtcblxuICAgICAgICAvLyBmaXggdGhlIHdpZHRoIG9mIHRoZXNlIGNlbGxzXG4gICAgICAgIHNvdXJjZUNlbGxzLmZvckVhY2goKGNlbGwsIGlkeCkgPT4gdGFyZ2V0Q2VsbHNbaWR4XS5zdHlsZS5taW5XaWR0aCA9IGdldENvbXB1dGVkU3R5bGUoY2VsbCkuZ2V0UHJvcGVydHlWYWx1ZSgnd2lkdGgnKSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjYXB0dXJlQ2FudmFzZXMoc291cmNlOiBFbGVtZW50LCB0YXJnZXQ6IEVsZW1lbnQpOiB2b2lkIHtcblxuICAgICAgICAvLyBmaW5kIGFsbCBjaGlsZCBjYW52YXMgZWxlbWVudHNcbiAgICAgICAgY29uc3Qgc291cmNlQ2FudmFzZXMgPSBBcnJheS5mcm9tKHNvdXJjZS5xdWVyeVNlbGVjdG9yQWxsKCdjYW52YXMnKSk7XG4gICAgICAgIGNvbnN0IHRhcmdldENhbnZhc2VzID0gQXJyYXkuZnJvbSh0YXJnZXQucXVlcnlTZWxlY3RvckFsbCgnY2FudmFzJykpO1xuXG4gICAgICAgIC8vIHJlcGxpY2F0ZSB0aGUgY2FudmFzIGNvbnRlbnRcbiAgICAgICAgdGFyZ2V0Q2FudmFzZXMubWFwKGNhbnZhcyA9PiBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSlcbiAgICAgICAgICAgIC5mb3JFYWNoKChjb250ZXh0LCBpZHgpID0+IGNvbnRleHQuZHJhd0ltYWdlKHNvdXJjZUNhbnZhc2VzW2lkeF0sIDAsIDApKTtcblxuICAgIH1cblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlb3JkZXJFdmVudCB7XG4gICAgZWxlbWVudDogRWxlbWVudDtcbiAgICBtb2RlbDogYW55O1xufVxuIiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBSZW9yZGVyYWJsZURpcmVjdGl2ZSB9IGZyb20gJy4vcmVvcmRlcmFibGUuZGlyZWN0aXZlJztcbmltcG9ydCB7IFJlb3JkZXJhYmxlSGFuZGxlRGlyZWN0aXZlIH0gZnJvbSAnLi9yZW9yZGVyYWJsZS1oYW5kbGUuZGlyZWN0aXZlJztcbmltcG9ydCB7IFJlb3JkZXJhYmxlTW9kZWxEaXJlY3RpdmUgfSBmcm9tICcuL3Jlb3JkZXJhYmxlLW1vZGVsLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBSZW9yZGVyYWJsZVNlcnZpY2UgfSBmcm9tICcuL3Jlb3JkZXJhYmxlLnNlcnZpY2UnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlXG4gICAgXSxcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgUmVvcmRlcmFibGVEaXJlY3RpdmUsXG4gICAgICAgIFJlb3JkZXJhYmxlSGFuZGxlRGlyZWN0aXZlLFxuICAgICAgICBSZW9yZGVyYWJsZU1vZGVsRGlyZWN0aXZlXG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIFJlb3JkZXJhYmxlRGlyZWN0aXZlLFxuICAgICAgICBSZW9yZGVyYWJsZUhhbmRsZURpcmVjdGl2ZSxcbiAgICAgICAgUmVvcmRlcmFibGVNb2RlbERpcmVjdGl2ZVxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIFJlb3JkZXJhYmxlU2VydmljZVxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgUmVvcmRlcmFibGVNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVHlwZWFoZWFkTW9kdWxlIH0gZnJvbSAnbmd4LWJvb3RzdHJhcC90eXBlYWhlYWQnO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IEZhY2V0Q29udGFpbmVyQ29tcG9uZW50IH0gZnJvbSAnLi9mYWNldC1jb250YWluZXIuY29tcG9uZW50JztcbmltcG9ydCB7IEZhY2V0QmFzZUNvbXBvbmVudCB9IGZyb20gJy4vYmFzZS9mYWNldC1iYXNlL2ZhY2V0LWJhc2UuY29tcG9uZW50JztcbmltcG9ydCB7IEZhY2V0SGVhZGVyQ29tcG9uZW50IH0gZnJvbSAnLi9iYXNlL2ZhY2V0LWhlYWRlci9mYWNldC1oZWFkZXIuY29tcG9uZW50JztcbmltcG9ydCB7IEZhY2V0Q2hlY2tMaXN0Q29tcG9uZW50IH0gZnJvbSAnLi9mYWNldC1jaGVjay1saXN0L2ZhY2V0LWNoZWNrLWxpc3QuY29tcG9uZW50JztcbmltcG9ydCB7IEZhY2V0VHlwZWFoZWFkTGlzdENvbXBvbmVudCwgRmFjZXRUeXBlYWhlYWRIaWdobGlnaHQgfSBmcm9tICcuL2ZhY2V0LXR5cGVhaGVhZC1saXN0L2ZhY2V0LXR5cGVhaGVhZC1saXN0LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBGb3Jtc01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IENoZWNrYm94TW9kdWxlIH0gZnJvbSAnLi4vY2hlY2tib3gvaW5kZXgnO1xuaW1wb3J0IHsgVG9vbHRpcE1vZHVsZSB9IGZyb20gJy4uL3Rvb2x0aXAvaW5kZXgnO1xuaW1wb3J0IHsgUmVvcmRlcmFibGVNb2R1bGUgfSBmcm9tICcuLy4uLy4uL2RpcmVjdGl2ZXMvcmVvcmRlcmFibGUvcmVvcmRlcmFibGUubW9kdWxlJztcblxuY29uc3QgREVDTEFSQVRJT05TID0gW1xuICAgIEZhY2V0Q29udGFpbmVyQ29tcG9uZW50LFxuICAgIEZhY2V0SGVhZGVyQ29tcG9uZW50LFxuICAgIEZhY2V0QmFzZUNvbXBvbmVudCxcbiAgICBGYWNldENoZWNrTGlzdENvbXBvbmVudCxcbiAgICBGYWNldFR5cGVhaGVhZExpc3RDb21wb25lbnQsXG4gICAgRmFjZXRUeXBlYWhlYWRIaWdobGlnaHRcbl07XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlLFxuICAgICAgICBDaGVja2JveE1vZHVsZSxcbiAgICAgICAgVG9vbHRpcE1vZHVsZSxcbiAgICAgICAgUmVvcmRlcmFibGVNb2R1bGUsXG4gICAgICAgIFR5cGVhaGVhZE1vZHVsZS5mb3JSb290KClcbiAgICBdLFxuICAgIGV4cG9ydHM6IERFQ0xBUkFUSU9OUyxcbiAgICBkZWNsYXJhdGlvbnM6IERFQ0xBUkFUSU9OU1xufSlcbmV4cG9ydCBjbGFzcyBGYWNldHNNb2R1bGUgeyB9XG4iLCJleHBvcnQgY2xhc3MgRmFjZXQge1xuICAgIFxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwdWJsaWMgdGl0bGU6IHN0cmluZyxcbiAgICAgICAgcHVibGljIGRhdGE6IGFueSA9IHt9LFxuICAgICAgICBwdWJsaWMgY291bnQ/OiBudW1iZXIsXG4gICAgICAgIHB1YmxpYyBkaXNhYmxlZDogYm9vbGVhbiA9IGZhbHNlLFxuICAgICAgICBwdWJsaWMgaWQ/OiBzdHJpbmcgfCBudW1iZXJcbiAgICApIHsgfVxufSIsImltcG9ydCB7IENvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT3V0cHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtZmlsdGVyLWNvbnRhaW5lcicsXG4gICAgdGVtcGxhdGU6IGA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG5cbjwhLS0gQWRkIGEgQ2xlYXIgQnV0dG9uIC0tPlxuPGRpdiBjbGFzcz1cImZpbHRlci1zZWxlY3RlZC1jbGVhci1idXR0b25cIiAqbmdJZj1cImZpbHRlcnMubGVuZ3RoID4gMFwiIFt1eFRvb2x0aXBdPVwiY2xlYXJUb29sdGlwIHx8ICdDbGVhciBBbGwnXCIgKGNsaWNrKT1cInJlbW92ZUFsbCgpXCI+XG5cbiAgICA8c3ZnIGNsYXNzPVwiZmlsdGVyLXNlbGVjdGVkLWNsZWFyLWdyYXBoaWNcIiB3aWR0aD1cIjE5XCIgaGVpZ2h0PVwiMTJcIiB2aWV3Qm94PVwiMCAwIDE5IDEyXCIgc2hhcGUtcmVuZGVyaW5nPVwiZ2VvbWV0cmljUHJlY2lzaW9uXCI+XG4gICAgICAgIDxyZWN0IGNsYXNzPVwibGlnaHQtZ3JleVwiIHg9XCIwXCIgeT1cIjJcIiB3aWR0aD1cIjdcIiBoZWlnaHQ9XCIyXCI+PC9yZWN0PlxuICAgICAgICA8cmVjdCBjbGFzcz1cImRhcmstZ3JleVwiIHg9XCIwXCIgeT1cIjVcIiB3aWR0aD1cIjlcIiBoZWlnaHQ9XCIyXCI+PC9yZWN0PlxuICAgICAgICA8cmVjdCBjbGFzcz1cImxpZ2h0LWdyZXlcIiB4PVwiMFwiIHk9XCI4XCIgd2lkdGg9XCI3XCIgaGVpZ2h0PVwiMlwiPjwvcmVjdD5cbiAgICAgICAgPHBhdGggY2xhc3M9XCJkYXJrLWdyZXlcIiBkPVwiTTksMSBoMSBsOSw5IHYxIGgtMSBsLTksLTkgdi0xIFpcIj48L3BhdGg+XG4gICAgICAgIDxwYXRoIGNsYXNzPVwiZGFyay1ncmV5XCIgZD1cIk05LDExIHYtMSBsOSwtOSBoMSB2MSBsLTksOSBoLTEgWlwiPjwvcGF0aD5cbiAgICA8L3N2Zz5cblxuPC9kaXY+YFxufSlcbmV4cG9ydCBjbGFzcyBGaWx0ZXJDb250YWluZXJDb21wb25lbnQge1xuXG4gICAgQElucHV0KCkgZmlsdGVyczogRmlsdGVyW10gPSBbXTtcbiAgICBASW5wdXQoKSBjbGVhclRvb2x0aXA6IHN0cmluZztcbiAgICBAT3V0cHV0KCkgZmlsdGVyc0NoYW5nZTogRXZlbnRFbWl0dGVyPEZpbHRlcltdPiA9IG5ldyBFdmVudEVtaXR0ZXI8RmlsdGVyW10+KCk7XG4gICAgQE91dHB1dCgpIGV2ZW50czogRXZlbnRFbWl0dGVyPEZpbHRlckV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8RmlsdGVyRXZlbnQ+KCk7XG5cblxuICAgIGFkZEZpbHRlcihmaWx0ZXI6IEZpbHRlcik6IHZvaWQge1xuICAgICAgICB0aGlzLmZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICAgICAgICB0aGlzLmV2ZW50cy5uZXh0KG5ldyBGaWx0ZXJBZGRFdmVudChmaWx0ZXIpKTtcbiAgICAgICAgdGhpcy5maWx0ZXJzQ2hhbmdlLmVtaXQodGhpcy5maWx0ZXJzKTtcbiAgICB9XG5cbiAgICByZW1vdmVGaWx0ZXIoZmlsdGVyOiBGaWx0ZXIpOiB2b2lkIHtcbiAgICAgICAgbGV0IGlkeCA9IHRoaXMuZmlsdGVycy5maW5kSW5kZXgoZmlsdGVycyA9PiBmaWx0ZXJzID09PSBmaWx0ZXIpO1xuXG4gICAgICAgIGlmIChpZHggIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmZpbHRlcnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5uZXh0KG5ldyBGaWx0ZXJSZW1vdmVFdmVudChmaWx0ZXIpKTtcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyc0NoYW5nZS5lbWl0KHRoaXMuZmlsdGVycyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZW1vdmVBbGwoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZXZlbnRzLm5leHQobmV3IEZpbHRlclJlbW92ZUFsbEV2ZW50KCkpO1xuICAgIH1cblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZpbHRlciB7XG4gICAgZ3JvdXA6IHN0cmluZztcbiAgICB0aXRsZTogc3RyaW5nO1xuICAgIG5hbWU6IHN0cmluZztcbiAgICBpbml0aWFsPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNsYXNzIEZpbHRlckFkZEV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZmlsdGVyOiBGaWx0ZXIpIHt9XG59XG5cbmV4cG9ydCBjbGFzcyBGaWx0ZXJSZW1vdmVFdmVudCB7XG4gICAgY29uc3RydWN0b3IocHVibGljIGZpbHRlcjogRmlsdGVyKSB7fVxufVxuXG5leHBvcnQgY2xhc3MgRmlsdGVyUmVtb3ZlQWxsRXZlbnQge1xufVxuXG5leHBvcnQgdHlwZSBGaWx0ZXJFdmVudCA9IEZpbHRlckFkZEV2ZW50IHwgRmlsdGVyUmVtb3ZlRXZlbnQgfCBGaWx0ZXJSZW1vdmVBbGxFdmVudDsiLCJcbmltcG9ydCB7IERpcmVjdGl2ZSwgSG9zdCwgSW5wdXQsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgZmlsdGVyIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcy9TdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgRmlsdGVyLCBGaWx0ZXJDb250YWluZXJDb21wb25lbnQsIEZpbHRlclJlbW92ZUFsbEV2ZW50IH0gZnJvbSAnLi4vZmlsdGVyLWNvbnRhaW5lci5jb21wb25lbnQnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ3V4LWZpbHRlci1iYXNlJ1xufSlcbmV4cG9ydCBjbGFzcyBGaWx0ZXJCYXNlQ29tcG9uZW50IGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICAgIEBJbnB1dCgpIGZpbHRlcnM6IEZpbHRlcltdO1xuXG4gICAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgICBjb25zdHJ1Y3RvcihASG9zdCgpIHByaXZhdGUgZmlsdGVyc0NvbnRhaW5lcjogRmlsdGVyQ29udGFpbmVyQ29tcG9uZW50KSB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IGZpbHRlcnNDb250YWluZXIuZXZlbnRzLnBpcGUoZmlsdGVyKGV2ZW50ID0+IGV2ZW50IGluc3RhbmNlb2YgRmlsdGVyUmVtb3ZlQWxsRXZlbnQpKS5zdWJzY3JpYmUodGhpcy5yZW1vdmVGaWx0ZXIuYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cblxuICAgIGFkZEZpbHRlcihfZmlsdGVyOiBGaWx0ZXIpOiB2b2lkIHtcbiAgICAgICAgaWYgKCFfZmlsdGVyLmluaXRpYWwpIHtcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyc0NvbnRhaW5lci5hZGRGaWx0ZXIoX2ZpbHRlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZW1vdmVGaWx0ZXIoX2ZpbHRlcjogRmlsdGVyKTogdm9pZCB7XG4gICAgICAgIGlmICghX2ZpbHRlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5maWx0ZXJzQ29udGFpbmVyLnJlbW92ZUZpbHRlcihfZmlsdGVyKTtcbiAgICB9XG5cbn0iLCJpbXBvcnQgeyBDb21wb25lbnQsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGaWx0ZXJCYXNlQ29tcG9uZW50IH0gZnJvbSAnLi4vZmlsdGVyLWJhc2UvZmlsdGVyLWJhc2UuY29tcG9uZW50JztcbmltcG9ydCB7IEZpbHRlciB9IGZyb20gJy4uL2ZpbHRlci1jb250YWluZXIuY29tcG9uZW50JztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1maWx0ZXItZHJvcGRvd24nLFxuICAgIHRlbXBsYXRlOiBgPGRpdiBjbGFzcz1cImJ0bi1ncm91cFwiIGRyb3Bkb3duPlxuICAgIDxidXR0b24gZHJvcGRvd25Ub2dnbGUgdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiZmlsdGVyLWRyb3Bkb3duIGJ0biBkcm9wZG93bi10b2dnbGVcIiBbY2xhc3MuYWN0aXZlXT1cInNlbGVjdGVkICE9PSBpbml0aWFsXCI+e3sgc2VsZWN0ZWQ/LnRpdGxlIH19IFxuICAgICAgICA8c3BhbiBjbGFzcz1cImhwZS1pY29uIGhwZS1kb3duXCI+PC9zcGFuPlxuICAgIDwvYnV0dG9uPlxuICAgIDx1bCAqZHJvcGRvd25NZW51IGNsYXNzPVwiZHJvcGRvd24tbWVudVwiIHJvbGU9XCJtZW51XCI+XG4gICAgICAgIDxsaSBjbGFzcz1cImRyb3Bkb3duLWxpc3QtaXRlbVwiICpuZ0Zvcj1cImxldCBmaWx0ZXIgb2YgZmlsdGVyc1wiIHJvbGU9XCJtZW51aXRlbVwiPlxuICAgICAgICAgICAgPGEgY2xhc3M9XCJkcm9wZG93bi1pdGVtXCIgKGNsaWNrKT1cInNlbGVjdEZpbHRlcihmaWx0ZXIpXCI+XG4gICAgICAgICAgICAgICAgPGkgY2xhc3M9XCJocGUtaWNvblwiIFtjbGFzcy5ocGUtY2hlY2ttYXJrXT1cImZpbHRlciA9PT0gc2VsZWN0ZWRcIj48L2k+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJmaWx0ZXItZHJvcGRvd24tdGl0bGVcIj57eyBmaWx0ZXIubmFtZSB9fTwvc3Bhbj5cbiAgICAgICAgICAgIDwvYT5cbiAgICAgICAgPC9saT5cbiAgICA8L3VsPlxuPC9kaXY+YCxcbn0pXG5leHBvcnQgY2xhc3MgRmlsdGVyRHJvcGRvd25Db21wb25lbnQgZXh0ZW5kcyBGaWx0ZXJCYXNlQ29tcG9uZW50IHtcblxuICAgIEBJbnB1dCgpIGluaXRpYWw6IEZpbHRlcjtcblxuICAgIHNlbGVjdGVkOiBGaWx0ZXI7XG5cbiAgICByZW1vdmVGaWx0ZXIoKTogdm9pZCB7XG4gICAgICAgIHN1cGVyLnJlbW92ZUZpbHRlcih0aGlzLnNlbGVjdGVkKTtcbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9IHRoaXMuaW5pdGlhbDtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9IHRoaXMuaW5pdGlhbDtcbiAgICB9XG5cbiAgICBzZWxlY3RGaWx0ZXIoZmlsdGVyOiBGaWx0ZXIpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVGaWx0ZXIoKTtcbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9IGZpbHRlcjtcbiAgICAgICAgdGhpcy5hZGRGaWx0ZXIodGhpcy5zZWxlY3RlZCk7XG4gICAgfVxuXG59IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgVmlld0NoaWxkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBCc0Ryb3Bkb3duRGlyZWN0aXZlIH0gZnJvbSAnbmd4LWJvb3RzdHJhcC9kcm9wZG93bic7XG5pbXBvcnQgeyBUeXBlYWhlYWRNYXRjaCB9IGZyb20gJ25neC1ib290c3RyYXAvdHlwZWFoZWFkJztcbmltcG9ydCB7IEZpbHRlckJhc2VDb21wb25lbnQgfSBmcm9tICcuLi9maWx0ZXItYmFzZS9maWx0ZXItYmFzZS5jb21wb25lbnQnO1xuaW1wb3J0IHsgRmlsdGVyIH0gZnJvbSAnLi4vZmlsdGVyLWNvbnRhaW5lci5jb21wb25lbnQnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LWZpbHRlci1keW5hbWljJyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJidG4tZ3JvdXAgdXgtZHluYW1pYy1maWx0ZXJcIiBkcm9wZG93biAjZHluYW1pY0Ryb3Bkb3duPVwiYnMtZHJvcGRvd25cIj5cbiAgICA8YnV0dG9uIChjbGljayk9XCJkeW5hbWljRHJvcGRvd24uc2hvdygpXCIgdHlwZT1cImJ1dHRvblwiIFtjbGFzcy5hY3RpdmVdPVwic2VsZWN0ZWQgIT09IGluaXRpYWxcIiBjbGFzcz1cImZpbHRlci1kcm9wZG93biBidG4gZHJvcGRvd24tdG9nZ2xlXCI+e3sgc2VsZWN0ZWQ/LnRpdGxlIH19IFxuICAgICAgICA8c3BhbiBjbGFzcz1cImhwZS1pY29uIGhwZS1kb3duXCI+PC9zcGFuPlxuICAgIDwvYnV0dG9uPlxuICAgIDx1bCAqZHJvcGRvd25NZW51IGNsYXNzPVwiZHJvcGRvd24tbWVudVwiIHJvbGU9XCJtZW51XCI+XG5cbiAgICAgICAgPGxpIGNsYXNzPVwiZHJvcGRvd24tbGlzdC1pdGVtXCIgKm5nSWY9XCJzaG93VHlwZWFoZWFkXCIgcm9sZT1cIm1lbnVpdGVtXCI+XG4gICAgICAgICAgICA8YSBjbGFzcz1cImRyb3Bkb3duLWl0ZW1cIiAoY2xpY2spPVwicmVtb3ZlRmlsdGVyKCk7IGR5bmFtaWNEcm9wZG93bi5oaWRlKCk7XCI+XG4gICAgICAgICAgICAgICAgPGkgY2xhc3M9XCJocGUtaWNvblwiIFtjbGFzcy5ocGUtY2hlY2ttYXJrXT1cImluaXRpYWwgPT09IHNlbGVjdGVkXCI+PC9pPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZmlsdGVyLWRyb3Bkb3duLXRpdGxlXCI+e3sgaW5pdGlhbC5uYW1lIH19PC9zcGFuPlxuICAgICAgICAgICAgPC9hPlxuICAgICAgICA8L2xpPlxuXG4gICAgICAgIDxsaSBjbGFzcz1cImRyb3Bkb3duLWxpc3QtaXRlbVwiICpuZ0lmPVwic2VsZWN0ZWQgIT09IGluaXRpYWwgJiYgc2hvd1R5cGVhaGVhZFwiIHJvbGU9XCJtZW51aXRlbVwiPlxuICAgICAgICAgICAgPGEgY2xhc3M9XCJkcm9wZG93bi1pdGVtXCI+XG4gICAgICAgICAgICAgICAgPGkgY2xhc3M9XCJocGUtaWNvbiBocGUtY2hlY2ttYXJrXCI+PC9pPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZmlsdGVyLWRyb3Bkb3duLXRpdGxlXCI+e3sgc2VsZWN0ZWQubmFtZSB9fTwvc3Bhbj5cbiAgICAgICAgICAgIDwvYT5cbiAgICAgICAgPC9saT5cblxuICAgICAgICA8aHI+XG5cbiAgICAgICAgPGxpICpuZ0lmPVwic2hvd1R5cGVhaGVhZFwiIGNsYXNzPVwidHlwZWFoZWFkLWJveFwiPlxuICAgICAgICAgICAgPGlucHV0IFsobmdNb2RlbCldPVwic2VhcmNoUXVlcnlcIiBbdHlwZWFoZWFkXT1cInR5cGVhaGVhZEl0ZW1zXCIgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiBcbiAgICAgICAgICAgICh0eXBlYWhlYWRPblNlbGVjdCk9XCJzZWxlY3RPcHRpb24oJGV2ZW50KVwiIFxuICAgICAgICAgICAgW3BsYWNlaG9sZGVyXT1cIm9wdGlvbnM/LnBsYWNlaG9sZGVyIHx8IGRlZmF1bHRPcHRpb25zLnBsYWNlaG9sZGVyXCJcbiAgICAgICAgICAgIFt0eXBlYWhlYWRNaW5MZW5ndGhdPVwib3B0aW9ucz8ubWluQ2hhcmFjdGVycyB8fCBkZWZhdWx0T3B0aW9ucy5taW5DaGFyYWN0ZXJzXCJcbiAgICAgICAgICAgIFt0eXBlYWhlYWRPcHRpb25zTGltaXRdPVwib3B0aW9ucz8ubWF4UmVzdWx0c1wiPlxuICAgICAgICA8L2xpPlxuXG4gICAgICAgIDxzcGFuICpuZ0lmPVwiIXNob3dUeXBlYWhlYWRcIj5cbiAgICAgICAgICAgIDxsaSBjbGFzcz1cImRyb3Bkb3duLWxpc3QtaXRlbVwiICpuZ0Zvcj1cImxldCBmaWx0ZXIgb2YgZmlsdGVyc1wiIHJvbGU9XCJtZW51aXRlbVwiPlxuICAgICAgICAgICAgICAgIDxhIGNsYXNzPVwiZHJvcGRvd24taXRlbVwiIChjbGljayk9XCJzZWxlY3RGaWx0ZXIoZmlsdGVyKVwiPlxuICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cImhwZS1pY29uXCIgW2NsYXNzLmhwZS1jaGVja21hcmtdPVwiZmlsdGVyID09PSBzZWxlY3RlZFwiPjwvaT5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJmaWx0ZXItZHJvcGRvd24tdGl0bGVcIj57eyBmaWx0ZXIubmFtZSB9fTwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICA8L2xpPlxuICAgICAgICA8L3NwYW4+XG5cbiAgICA8L3VsPlxuPC9kaXY+YCxcbiAgICBob3N0OiB7XG4gICAgICAgICcoZG9jdW1lbnQ6Y2xpY2spJzogJ2NsaWNrT2ZmKCRldmVudCknLFxuICAgIH1cbn0pXG5leHBvcnQgY2xhc3MgRmlsdGVyRHluYW1pY0NvbXBvbmVudCBleHRlbmRzIEZpbHRlckJhc2VDb21wb25lbnQge1xuXG4gICAgQElucHV0KCkgZmlsdGVyczogRmlsdGVyW107XG4gICAgQElucHV0KCkgaW5pdGlhbDogRmlsdGVyO1xuICAgIEBJbnB1dCgpIG9wdGlvbnM6IEZpbHRlckR5bmFtaWNMaXN0Q29uZmlnO1xuXG4gICAgQFZpZXdDaGlsZChCc0Ryb3Bkb3duRGlyZWN0aXZlKSBkcm9wZG93bjogQnNEcm9wZG93bkRpcmVjdGl2ZTtcblxuICAgIGRlZmF1bHRPcHRpb25zOiBGaWx0ZXJEeW5hbWljTGlzdENvbmZpZyA9IHtcbiAgICAgICAgcGxhY2Vob2xkZXI6ICcnLFxuICAgICAgICBtaW5DaGFyYWN0ZXJzOiAzXG4gICAgfTtcbiAgICBzZWFyY2hRdWVyeTogc3RyaW5nO1xuICAgIHNlbGVjdGVkOiBGaWx0ZXI7XG4gICAgc2hvd1R5cGVhaGVhZDogYm9vbGVhbiA9IHRydWU7XG4gICAgdHlwZWFoZWFkSXRlbXM6IHN0cmluZ1tdID0gW107XG5cbiAgICBnZXRJdGVtcygpOiBzdHJpbmdbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRlcnMuZmlsdGVyKGl0ZW0gPT4gaXRlbSAhPT0gdGhpcy5pbml0aWFsKS5tYXAoaXRlbSA9PiBpdGVtLm5hbWUpO1xuICAgIH1cblxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkID0gdGhpcy5pbml0aWFsO1xuICAgICAgICB0aGlzLnR5cGVhaGVhZEl0ZW1zID0gdGhpcy5nZXRJdGVtcygpO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLm1heEluZGl2aWR1YWxJdGVtcyAmJiB0aGlzLm9wdGlvbnMubWF4SW5kaXZpZHVhbEl0ZW1zICsgMSA+PSB0aGlzLmZpbHRlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnNob3dUeXBlYWhlYWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNlbGVjdE9wdGlvbih0eXBlYWhlYWRPcHRpb246IFR5cGVhaGVhZE1hdGNoKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRmlsdGVyKCk7XG4gICAgICAgIGxldCBpZHggPSB0aGlzLmZpbHRlcnMuZmluZEluZGV4KGZpbHRlciA9PiBmaWx0ZXIubmFtZSA9PT0gdHlwZWFoZWFkT3B0aW9uLnZhbHVlKTtcbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9IHRoaXMuZmlsdGVyc1tpZHhdO1xuICAgICAgICB0aGlzLmFkZEZpbHRlcih0aGlzLnNlbGVjdGVkKTtcbiAgICAgICAgdGhpcy5zZWFyY2hRdWVyeSA9ICcnO1xuICAgICAgICB0aGlzLmRyb3Bkb3duLmhpZGUoKTtcbiAgICB9XG5cbiAgICBjbGlja09mZihldmVudDogTW91c2VFdmVudCkge1xuXG4gICAgICAgIGxldCB0YXJnZXQgPSBldmVudC50YXJnZXQgYXMgSFRNTEVsZW1lbnQ7XG4gICAgICAgIGxldCBoaWRlRHJvcGRvd24gPSB0cnVlO1xuXG4gICAgICAgIHdoaWxlICh0YXJnZXQgJiYgdGFyZ2V0Lm5vZGVOYW1lICE9PSAnQk9EWScpIHtcbiAgICAgICAgICAgIGlmICh0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCd1eC1keW5hbWljLWZpbHRlcicpKSB7XG4gICAgICAgICAgICAgICAgaGlkZURyb3Bkb3duID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhpZGVEcm9wZG93bikge1xuICAgICAgICAgICAgdGhpcy5zZWFyY2hRdWVyeSA9ICcnO1xuICAgICAgICAgICAgdGhpcy5kcm9wZG93bi5oaWRlKCk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHJlbW92ZUZpbHRlcigpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWQgIT09IHRoaXMuaW5pdGlhbCkge1xuICAgICAgICAgICAgc3VwZXIucmVtb3ZlRmlsdGVyKHRoaXMuc2VsZWN0ZWQpO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZCA9IHRoaXMuaW5pdGlhbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlYXJjaFF1ZXJ5ID0gJyc7XG4gICAgfVxuXG4gICAgc2VsZWN0RmlsdGVyKGZpbHRlcjogRmlsdGVyKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRmlsdGVyKCk7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWQgPSBmaWx0ZXI7XG4gICAgICAgIHRoaXMuYWRkRmlsdGVyKHRoaXMuc2VsZWN0ZWQpO1xuICAgIH1cblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZpbHRlckR5bmFtaWNMaXN0Q29uZmlnIHtcbiAgICBwbGFjZWhvbGRlcj86IHN0cmluZztcbiAgICBtaW5DaGFyYWN0ZXJzPzogbnVtYmVyO1xuICAgIG1heFJlc3VsdHM/OiBudW1iZXI7XG4gICAgbWF4SW5kaXZpZHVhbEl0ZW1zPzogbnVtYmVyO1xufSIsImltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRm9ybXNNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBCc0Ryb3Bkb3duTW9kdWxlIH0gZnJvbSAnbmd4LWJvb3RzdHJhcC9kcm9wZG93bic7XG5pbXBvcnQgeyBUeXBlYWhlYWRNb2R1bGUgfSBmcm9tICduZ3gtYm9vdHN0cmFwL3R5cGVhaGVhZCc7XG5pbXBvcnQgeyBUb29sdGlwTW9kdWxlIH0gZnJvbSAnLi4vdG9vbHRpcC9pbmRleCc7XG5pbXBvcnQgeyBGaWx0ZXJCYXNlQ29tcG9uZW50IH0gZnJvbSAnLi9maWx0ZXItYmFzZS9maWx0ZXItYmFzZS5jb21wb25lbnQnO1xuaW1wb3J0IHsgRmlsdGVyQ29udGFpbmVyQ29tcG9uZW50IH0gZnJvbSAnLi9maWx0ZXItY29udGFpbmVyLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBGaWx0ZXJEcm9wZG93bkNvbXBvbmVudCB9IGZyb20gJy4vZmlsdGVyLWRyb3Bkb3duL2ZpbHRlci1kcm9wZG93bi5jb21wb25lbnQnO1xuaW1wb3J0IHsgRmlsdGVyRHluYW1pY0NvbXBvbmVudCB9IGZyb20gJy4vZmlsdGVyLWR5bmFtaWMvZmlsdGVyLWR5bmFtaWMuY29tcG9uZW50JztcblxuY29uc3QgREVDTEFSQVRJT05TID0gW1xuICAgIEZpbHRlckJhc2VDb21wb25lbnQsXG4gICAgRmlsdGVyQ29udGFpbmVyQ29tcG9uZW50LFxuICAgIEZpbHRlckRyb3Bkb3duQ29tcG9uZW50LFxuICAgIEZpbHRlckR5bmFtaWNDb21wb25lbnRcbl07XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW1xuICAgICAgICBCc0Ryb3Bkb3duTW9kdWxlLmZvclJvb3QoKSxcbiAgICAgICAgVHlwZWFoZWFkTW9kdWxlLmZvclJvb3QoKSxcbiAgICAgICAgVG9vbHRpcE1vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGUsXG4gICAgICAgIENvbW1vbk1vZHVsZVxuICAgIF0sXG4gICAgZXhwb3J0czogREVDTEFSQVRJT05TLFxuICAgIGRlY2xhcmF0aW9uczogREVDTEFSQVRJT05TXG59KVxuZXhwb3J0IGNsYXNzIEZpbHRlck1vZHVsZSB7IH1cbiIsImltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIERpcmVjdGl2ZSwgSG9zdExpc3RlbmVyLCBPdXRwdXQsIEV2ZW50RW1pdHRlciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LWZsaXBwYWJsZS1jYXJkJyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJ1eC1mbGlwcGVyXCIgW2NsYXNzLnV4LWZsaXAtY2FyZF09XCJmbGlwcGVkXCIgW3N0eWxlLndpZHRoLnB4XT1cIndpZHRoXCIgW3N0eWxlLmhlaWdodC5weF09XCJoZWlnaHRcIj5cblxuICAgIDxkaXYgY2xhc3M9XCJ1eC1mbGlwcGFibGUtY2FyZC1mcm9udFwiIFtzdHlsZS53aWR0aC5weF09XCJ3aWR0aFwiIFtzdHlsZS5oZWlnaHQucHhdPVwiaGVpZ2h0XCI+XG4gICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cInV4LWZsaXBwYWJsZS1jYXJkLWZyb250XCI+PC9uZy1jb250ZW50PlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cInV4LWZsaXBwYWJsZS1jYXJkLWJhY2tcIiBbc3R5bGUud2lkdGgucHhdPVwid2lkdGhcIiBbc3R5bGUuaGVpZ2h0LnB4XT1cImhlaWdodFwiPlxuICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJ1eC1mbGlwcGFibGUtY2FyZC1iYWNrXCI+PC9uZy1jb250ZW50PlxuICAgIDwvZGl2PlxuPC9kaXY+YCxcbiAgICBob3N0OiB7XG4gICAgICAgICdbY2xhc3MuaG9yaXpvbnRhbF0nOiAnZGlyZWN0aW9uID09PSBcImhvcml6b250YWxcIicsXG4gICAgICAgICdbY2xhc3MudmVydGljYWxdJzogJ2RpcmVjdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiJ1xuICAgIH0sXG4gICAgZXhwb3J0QXM6ICd1eC1mbGlwcGFibGUtY2FyZCdcbn0pXG5leHBvcnQgY2xhc3MgRmxpcHBhYmxlQ2FyZENvbXBvbmVudCB7XG5cbiAgICBASW5wdXQoKSBkaXJlY3Rpb246ICdob3Jpem9udGFsJyB8ICd2ZXJ0aWNhbCcgPSAnaG9yaXpvbnRhbCc7XG4gICAgQElucHV0KCkgdHJpZ2dlcjogJ2NsaWNrJyB8ICdob3ZlcicgfCAnbWFudWFsJyA9ICdob3Zlcic7XG4gICAgQElucHV0KCkgd2lkdGg6IG51bWJlciA9IDI4MDtcbiAgICBASW5wdXQoKSBoZWlnaHQ6IG51bWJlciA9IDIwMDtcbiAgICBASW5wdXQoKSBmbGlwcGVkOiBib29sZWFuID0gZmFsc2U7XG4gICAgQE91dHB1dCgpIGZsaXBwZWRDaGFuZ2U6IEV2ZW50RW1pdHRlcjxib29sZWFuPiA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oKTtcblxuICAgIHNldEZsaXBwZWQoc3RhdGU6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5mbGlwcGVkID0gc3RhdGU7XG4gICAgICAgIHRoaXMuZmxpcHBlZENoYW5nZS5lbWl0KHRoaXMuZmxpcHBlZCk7XG4gICAgfVxuXG4gICAgdG9nZ2xlRmxpcHBlZCgpIHtcbiAgICAgICAgdGhpcy5zZXRGbGlwcGVkKCF0aGlzLmZsaXBwZWQpO1xuICAgIH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ2NsaWNrJykgY2xpY2tUcmlnZ2VyKCkge1xuXG4gICAgICAgIC8vIGFkZCBvciByZW1vdmUgdGhlIGNsYXNzIGRlcGVuZGluZyBvbiB3aGV0aGVyIG9yIG5vdCB0aGUgY2FyZCBoYXMgYmVlbiBmbGlwcGVkXG4gICAgICAgIGlmICh0aGlzLnRyaWdnZXIgPT09ICdjbGljaycpIHtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlRmxpcHBlZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcignbW91c2VlbnRlcicpIGhvdmVyRW50ZXIoKSB7XG4gICAgICAgIC8vIGlmIHRoZSB0cmlnZ2VyIGlzIGhvdmVyIHRoZW4gYmVnaW4gdG8gZmxpcFxuICAgICAgICBpZiAodGhpcy50cmlnZ2VyID09PSAnaG92ZXInKSB7XG4gICAgICAgICAgICB0aGlzLnNldEZsaXBwZWQodHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBASG9zdExpc3RlbmVyKCdtb3VzZWxlYXZlJykgaG92ZXJFeGl0KCkge1xuICAgICAgICBpZiAodGhpcy50cmlnZ2VyID09PSAnaG92ZXInKSB7XG4gICAgICAgICAgICB0aGlzLnNldEZsaXBwZWQoZmFsc2UpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAndXgtZmxpcHBhYmxlLWNhcmQtZnJvbnQnXG59KVxuZXhwb3J0IGNsYXNzIEZsaXBwYWJsZUNhcmRGcm9udERpcmVjdGl2ZSB7IH1cblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICd1eC1mbGlwcGFibGUtY2FyZC1iYWNrJ1xufSlcbmV4cG9ydCBjbGFzcyBGbGlwcGFibGVDYXJkQmFja0RpcmVjdGl2ZSB7IH1cbiIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IEZsaXBwYWJsZUNhcmRDb21wb25lbnQsIEZsaXBwYWJsZUNhcmRCYWNrRGlyZWN0aXZlLCBGbGlwcGFibGVDYXJkRnJvbnREaXJlY3RpdmUgfSBmcm9tICcuL2ZsaXBwYWJsZS1jYXJkLmNvbXBvbmVudCc7XG5cbkBOZ01vZHVsZSh7XG4gICAgZXhwb3J0czogW0ZsaXBwYWJsZUNhcmRDb21wb25lbnQsIEZsaXBwYWJsZUNhcmRCYWNrRGlyZWN0aXZlLCBGbGlwcGFibGVDYXJkRnJvbnREaXJlY3RpdmVdLFxuICAgIGRlY2xhcmF0aW9uczogW0ZsaXBwYWJsZUNhcmRDb21wb25lbnQsIEZsaXBwYWJsZUNhcmRCYWNrRGlyZWN0aXZlLCBGbGlwcGFibGVDYXJkRnJvbnREaXJlY3RpdmVdXG59KVxuZXhwb3J0IGNsYXNzIEZsaXBwYWJsZUNhcmRNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QgfSBmcm9tICdyeGpzL0JlaGF2aW9yU3ViamVjdCc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBGbG9hdGluZ0FjdGlvbkJ1dHRvbnNTZXJ2aWNlIHtcblxuICAgIG9wZW4kID0gbmV3IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPihmYWxzZSk7XG5cbiAgICBvcGVuKCk6IHZvaWQge1xuICAgICAgICB0aGlzLm9wZW4kLm5leHQodHJ1ZSk7XG4gICAgfVxuXG4gICAgdG9nZ2xlKCk6IHZvaWQge1xuICAgICAgICB0aGlzLm9wZW4kLm5leHQoIXRoaXMub3BlbiQuZ2V0VmFsdWUoKSk7XG4gICAgfVxuXG4gICAgY2xvc2UoKTogdm9pZCB7XG4gICAgICAgIHRoaXMub3BlbiQubmV4dChmYWxzZSk7XG4gICAgfVxufSIsImltcG9ydCB7IGFuaW1hdGUsIHF1ZXJ5LCBzdGFnZ2VyLCBzdHlsZSwgdHJhbnNpdGlvbiwgdHJpZ2dlciB9IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xuaW1wb3J0IHsgQWZ0ZXJWaWV3SW5pdCwgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENvbXBvbmVudCwgQ29udGVudENoaWxkcmVuLCBFbGVtZW50UmVmLCBIb3N0TGlzdGVuZXIsIElucHV0LCBPbkRlc3Ryb3ksIFF1ZXJ5TGlzdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVG9vbHRpcERpcmVjdGl2ZSB9IGZyb20gJ25neC1ib290c3RyYXAvdG9vbHRpcCc7XG5pbXBvcnQgeyBmaWx0ZXIgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBGbG9hdGluZ0FjdGlvbkJ1dHRvbnNTZXJ2aWNlIH0gZnJvbSAnLi9mbG9hdGluZy1hY3Rpb24tYnV0dG9ucy5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1mbG9hdGluZy1hY3Rpb24tYnV0dG9ucycsXG4gICAgdGVtcGxhdGU6IGA8bmctY29udGVudCBzZWxlY3Q9XCJbZmFiLXByaW1hcnldXCI+PC9uZy1jb250ZW50PlxuXG48ZGl2IGNsYXNzPVwiZmxvYXRpbmctYWN0aW9uLWJ1dHRvbi1saXN0XCIgW0BmYWJBbmltYXRpb25dPVwiZmFiLm9wZW4kIHwgYXN5bmNcIiBbbmdDbGFzc109XCJkaXJlY3Rpb25cIiAqbmdJZj1cImZhYi5vcGVuJCB8IGFzeW5jXCI+XG4gICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuPC9kaXY+YCxcbiAgICBwcm92aWRlcnM6IFtGbG9hdGluZ0FjdGlvbkJ1dHRvbnNTZXJ2aWNlXSxcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICBwcmVzZXJ2ZVdoaXRlc3BhY2VzOiBmYWxzZSxcbiAgICBhbmltYXRpb25zOiBbXG4gICAgICAgIHRyaWdnZXIoJ2ZhYkFuaW1hdGlvbicsIFtcbiAgICAgICAgICAgIHRyYW5zaXRpb24oJ3ZvaWQgPT4gdHJ1ZScsIFtcbiAgICAgICAgICAgICAgICBxdWVyeSgndXgtZmxvYXRpbmctYWN0aW9uLWJ1dHRvbicsIHN0eWxlKHsgb3BhY2l0eTogMCB9KSksXG4gICAgICAgICAgICAgICAgcXVlcnkoJ3V4LWZsb2F0aW5nLWFjdGlvbi1idXR0b24nLCBzdGFnZ2VyKDUwLCBhbmltYXRlKDI1MCwgc3R5bGUoeyBvcGFjaXR5OiAxIH0pKSkpXG4gICAgICAgICAgICBdKSxcbiAgICAgICAgICAgIHRyYW5zaXRpb24oJ3RydWUgPT4gdm9pZCcsIFtcbiAgICAgICAgICAgICAgICBxdWVyeSgndXgtZmxvYXRpbmctYWN0aW9uLWJ1dHRvbicsIHN0YWdnZXIoLTUwLCBhbmltYXRlKDI1MCwgc3R5bGUoeyBvcGFjaXR5OiAwIH0pKSkpXG4gICAgICAgICAgICBdKVxuICAgICAgICBdKVxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgRmxvYXRpbmdBY3Rpb25CdXR0b25zQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCwgT25EZXN0cm95IHtcblxuICAgIEBJbnB1dCgpIGRpcmVjdGlvbjogRmxvYXRpbmdBY3Rpb25CdXR0b25EaXJlY3Rpb24gPSAndG9wJztcbiAgICBAQ29udGVudENoaWxkcmVuKFRvb2x0aXBEaXJlY3RpdmUpIHRvb2x0aXBzOiBRdWVyeUxpc3Q8VG9vbHRpcERpcmVjdGl2ZT47XG5cbiAgICBwcml2YXRlIF9zdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBmYWI6IEZsb2F0aW5nQWN0aW9uQnV0dG9uc1NlcnZpY2UsIHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYpIHsgfVxuXG4gICAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24gPSB0aGlzLmZhYi5vcGVuJC5waXBlKGZpbHRlcihvcGVuID0+IG9wZW4gPT09IGZhbHNlKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy50b29sdGlwcy5mb3JFYWNoKHRvb2x0aXAgPT4gdG9vbHRpcC5oaWRlKCkpKTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBEZXRlY3QgYW55IGNsaWNrcyB0byB0cmlnZ2VyIGNsb3NlIG9mIHRoZSBtZW51XG4gICAgICovXG4gICAgQEhvc3RMaXN0ZW5lcignZG9jdW1lbnQ6Y2xpY2snLCBbJyRldmVudC50YXJnZXQnXSkgY2xvc2UodGFyZ2V0OiBIVE1MRWxlbWVudCk6IHZvaWQge1xuICAgICAgICBpZiAoIXRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAgICAgICB0aGlzLmZhYi5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgdHlwZSBGbG9hdGluZ0FjdGlvbkJ1dHRvbkRpcmVjdGlvbiA9ICd0b3AnIHwgJ3JpZ2h0JyB8ICdib3R0b20nIHwgJ2xlZnQnOyIsImltcG9ydCB7IEF0dHJpYnV0ZSwgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENvbXBvbmVudCwgSG9zdEJpbmRpbmcsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGbG9hdGluZ0FjdGlvbkJ1dHRvbnNTZXJ2aWNlIH0gZnJvbSAnLi9mbG9hdGluZy1hY3Rpb24tYnV0dG9ucy5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1mbG9hdGluZy1hY3Rpb24tYnV0dG9uJyxcbiAgICB0ZW1wbGF0ZTogYDxidXR0b24gY2xhc3M9XCJidG4gZmxvYXRpbmctYWN0aW9uLWJ1dHRvblwiIFxuICAgICAgICBbY2xhc3MuYnV0dG9uLXByaW1hcnldPVwicHJpbWFyeVwiIFxuICAgICAgICBbY2xhc3MuYnV0dG9uLXNlY29uZGFyeV09XCIhcHJpbWFyeVwiIFxuICAgICAgICAoY2xpY2spPVwicHJpbWFyeSA/IGZhYi50b2dnbGUoKSA6IGZhYi5jbG9zZSgpXCI+XG5cbiAgICA8c3BhbiBjbGFzcz1cImhwZS1pY29uIGZsb2F0aW5nLWFjdGlvbi1idXR0b24taWNvblwiICpuZ0lmPVwiaWNvblwiIFtuZ0NsYXNzXT1cImljb25cIj48L3NwYW4+XG4gICAgPG5nLWNvbnRlbnQgKm5nSWY9XCIhaWNvblwiPjwvbmctY29udGVudD5cblxuPC9idXR0b24+YCxcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICBwcmVzZXJ2ZVdoaXRlc3BhY2VzOiBmYWxzZVxufSlcbmV4cG9ydCBjbGFzcyBGbG9hdGluZ0FjdGlvbkJ1dHRvbkNvbXBvbmVudCB7XG5cbiAgICBASW5wdXQoKSBpY29uOiBzdHJpbmc7XG4gICAgQEhvc3RCaW5kaW5nKCkgdGFiaW5kZXggPSAxO1xuXG4gICAgcHJpbWFyeTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgY29uc3RydWN0b3IoQEF0dHJpYnV0ZSgnZmFiLXByaW1hcnknKSBwcmltYXJ5OiBzdHJpbmcsIHB1YmxpYyBmYWI6IEZsb2F0aW5nQWN0aW9uQnV0dG9uc1NlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5wcmltYXJ5ID0gcHJpbWFyeSAhPT0gbnVsbDtcbiAgICB9XG59IiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5cbmltcG9ydCB7IEZsb2F0aW5nQWN0aW9uQnV0dG9uc0NvbXBvbmVudCB9IGZyb20gJy4vZmxvYXRpbmctYWN0aW9uLWJ1dHRvbnMuY29tcG9uZW50JztcbmltcG9ydCB7IEZsb2F0aW5nQWN0aW9uQnV0dG9uQ29tcG9uZW50IH0gZnJvbSAnLi9mbG9hdGluZy1hY3Rpb24tYnV0dG9uLmNvbXBvbmVudCc7XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGVcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgRmxvYXRpbmdBY3Rpb25CdXR0b25zQ29tcG9uZW50LFxuICAgICAgICBGbG9hdGluZ0FjdGlvbkJ1dHRvbkNvbXBvbmVudFxuICAgIF0sXG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIEZsb2F0aW5nQWN0aW9uQnV0dG9uc0NvbXBvbmVudCxcbiAgICAgICAgRmxvYXRpbmdBY3Rpb25CdXR0b25Db21wb25lbnRcbiAgICBdXG59KVxuZXhwb3J0IGNsYXNzIEZsb2F0aW5nQWN0aW9uQnV0dG9uc01vZHVsZSB7IH1cbiIsImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzL09ic2VydmFibGUnO1xuaW1wb3J0IHsgT2JzZXJ2ZXIgfSBmcm9tICdyeGpzL09ic2VydmVyJztcbmltcG9ydCB7IG9mIH0gZnJvbSAncnhqcy9vYnNlcnZhYmxlL29mJztcbmltcG9ydCB7IGZpcnN0IH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgSGllcmFyY2h5QmFyU2VydmljZSB7XG5cbiAgICBub2RlcyQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PEhpZXJhcmNoeUJhck5vZGVbXT4oW10pO1xuXG4gICAgcHJpdmF0ZSBfcm9vdDogSGllcmFyY2h5QmFyTm9kZTtcbiAgICBwcml2YXRlIF9ub2RlczogSGllcmFyY2h5QmFyTm9kZVtdID0gW107XG5cbiAgICAvKipcbiAgICAgKiBTdG9yZSB0aGUgcm9vdCBub2RlIG9mIHRoZSBoaWVyYXJjaHkgdHJlZVxuICAgICAqL1xuICAgIHNldFJvb3ROb2RlKHJvb3Q6IEhpZXJhcmNoeUJhck5vZGUpIHtcblxuICAgICAgICAvLyBzdG9yZSB0aGUgcm9vdCBub2RlXG4gICAgICAgIHRoaXMuX3Jvb3QgPSByb290O1xuXG4gICAgICAgIC8vIGNyZWF0ZSBhIGZsYXQgc3RydWN0dXJlIG9mIG5vZGVzXG4gICAgICAgIHRoaXMuX25vZGVzID0gdGhpcy5nZXROb2RlTGlzdChyb290KTtcblxuICAgICAgICAvLyBmbGF0dGVuIHRoZSBhcnJheSAtIGJhc2VkIG9uIHRoZSBzZWxlY3RlZCBub2RlXG4gICAgICAgIHRoaXMubm9kZXMkLm5leHQodGhpcy5nZXRTZWxlY3RlZENoaWxkcmVuKHJvb3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3QgYSBub2RlLiBUaGlzIGNhdXNlcyBhbGwgbm9kZXMgdG8gYmVcbiAgICAgKiBkZXNlbGVjdGVkIGFuZCB0aGUgcGF0aCB0byB0aGUgc2VsZWN0ZWQgbm9kZVxuICAgICAqIHRvIGJlIHNlbGVjdGVkXG4gICAgICovXG4gICAgc2VsZWN0Tm9kZShub2RlOiBIaWVyYXJjaHlCYXJOb2RlKTogdm9pZCB7XG5cbiAgICAgICAgLy8gZGVzZWxlY3QgYWxsIG5vZGVzXG4gICAgICAgIHRoaXMuZGVzZWxlY3RBbGwoKTtcblxuICAgICAgICAvLyBlbnN1cmUgdGhlIGN1cnJlbnQgbm9kZSBpcyBzZWxlY3RlZCBhbmQgaXRzIHBhcmVudHNcbiAgICAgICAgdGhpcy5zZWxlY3Qobm9kZSk7XG5cbiAgICAgICAgLy8gZW1pdCBhIG5ldyBub2RlIGxpc3QgdG8gdHJpZ2dlciBjaGFuZ2UgZGV0ZWN0aW9uXG4gICAgICAgIHRoaXMubm9kZXMkLm5leHQodGhpcy5nZXRTZWxlY3RlZENoaWxkcmVuKHRoaXMuX3Jvb3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGdldHRpbmcgY2hpbGRyZW4gd2l0aCBzdXBwb3J0IGZvciBib3RoIGFycmF5cyBhbmQgb2JzZXJ2YWJsZXNcbiAgICAgKi9cbiAgICBnZXRDaGlsZHJlbihub2RlOiBIaWVyYXJjaHlCYXJOb2RlKTogT2JzZXJ2YWJsZTxIaWVyYXJjaHlCYXJOb2RlQ2hpbGRyZW4+IHtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShub2RlLmNoaWxkcmVuKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9mKHsgbG9hZGluZzogZmFsc2UsIGNoaWxkcmVuOiBub2RlLmNoaWxkcmVuIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY2hpbGRyZW4kOiBPYnNlcnZhYmxlPEhpZXJhcmNoeUJhck5vZGVbXT4gPSBub2RlLmNoaWxkcmVuO1xuXG4gICAgICAgIC8vIGlmIGl0IGlzIGFuIG9ic2VydmFibGUgdGhlbiBoYW5kbGUgbG9hZGluZ1xuICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZS5jcmVhdGUoKG9ic2VydmVyOiBPYnNlcnZlcjxIaWVyYXJjaHlCYXJOb2RlQ2hpbGRyZW4+KSA9PiB7XG4gICAgICAgICAgICAvLyBlbWl0IGluaXRpYWwgdmFsdWVcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQoeyBsb2FkaW5nOiB0cnVlLCBjaGlsZHJlbjogW10gfSk7XG5cbiAgICAgICAgICAgIC8vIG5vdyB3YWl0IHVudGlsIHRoZSBjaGlsZHJlbiBvYnNlcnZhYmxlIGNvbXBsZXRlc1xuICAgICAgICAgICAgY2hpbGRyZW4kLnBpcGUoZmlyc3QoKSkuc3Vic2NyaWJlKGNoaWxkcmVuID0+IHtcblxuICAgICAgICAgICAgICAgIC8vIHJlcGxhY2UgdGhlIG9ic2VydmFibGUgd2l0aCBhbiBhcnJheSBmb3IgZnV0dXJlIGxvYWRpbmdcbiAgICAgICAgICAgICAgICBub2RlLmNoaWxkcmVuID0gY2hpbGRyZW47XG5cbiAgICAgICAgICAgICAgICAvLyByZWJ1aWxkIHRoZSBub2RlIHRyZWVcbiAgICAgICAgICAgICAgICB0aGlzLnNldFJvb3ROb2RlKHRoaXMuX3Jvb3QpO1xuXG4gICAgICAgICAgICAgICAgLy8gZW1pdCB0aGUgbGF0ZXN0IHZhbHVlXG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCh7IGxvYWRpbmc6IGZhbHNlLCBjaGlsZHJlbjogY2hpbGRyZW4gfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBjbG9zZSB0aGUgb2JzZXJ2YWJsZSBzdHJlYW1cbiAgICAgICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRyYXZlcnNlcyBhbGwgdGhlIHBhcmVudHMgdG8gZW5zdXJlIHRoZXkgYXJlIHNlbGVjdGVkXG4gICAgICovXG4gICAgcHJpdmF0ZSBzZWxlY3Qobm9kZTogSGllcmFyY2h5QmFyTm9kZSk6IHZvaWQge1xuICAgICAgICBub2RlLnNlbGVjdGVkID0gdHJ1ZTtcblxuICAgICAgICBpZiAobm9kZS5wYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0KG5vZGUucGFyZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlc2VsZWN0cyBhbGwgbm9kZXNcbiAgICAgKi9cbiAgICBwcml2YXRlIGRlc2VsZWN0QWxsKCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9ub2Rlcy5mb3JFYWNoKG5vZGUgPT4gbm9kZS5zZWxlY3RlZCA9IGZhbHNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGFsbCB0aGUgbm9kZXMgaW4gdGhlIHRyZWUgYXMgYSBmbGF0IGFycmF5LlxuICAgICAqIEl0IGFsc28gc3RvcmVzIHRoZSBwYXJlbnQgbm9kZSBpbiBhIHBhcmVudCBwcm9wZXJ0eVxuICAgICAqIG9uIHRoZSBub2RlIGZvciBlYXN5IHRyYXZlcnNhbCBpbiBib3RoIGRpcmVjdGlvbnNcbiAgICAgKi9cbiAgICBwcml2YXRlIGdldE5vZGVMaXN0KG5vZGU6IEhpZXJhcmNoeUJhck5vZGUpOiBIaWVyYXJjaHlCYXJOb2RlW10ge1xuXG4gICAgICAgIC8vIGlmIHRoZXJlIGFyZSBubyBjaGlsZHJlbiB0aGVuIHJldHVybiBvbmx5IGl0c2VsZlxuICAgICAgICBpZiAoIW5vZGUuY2hpbGRyZW4gfHwgbm9kZS5jaGlsZHJlbiBpbnN0YW5jZW9mIE9ic2VydmFibGUgfHwgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbbm9kZV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzdG9yZSB0aGUgcGFyZW50IHByb3BlcnR5XG4gICAgICAgIG5vZGUuY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiBjaGlsZC5wYXJlbnQgPSBub2RlKTtcblxuICAgICAgICAvLyBnZXQgYWxsIGRlc2NlbmRhbnRzIG9mIHRoaXMgbm9kZVxuICAgICAgICBjb25zdCBkZXNjZW5kYW50cyA9IG5vZGUuY2hpbGRyZW4ucmVkdWNlPEhpZXJhcmNoeUJhck5vZGVbXT4oKG5vZGVzLCBjdXJyZW50KSA9PiBbLi4ubm9kZXMsIC4uLnRoaXMuZ2V0Tm9kZUxpc3QoY3VycmVudCldLCBbXSk7XG5cbiAgICAgICAgcmV0dXJuIFtub2RlLCAuLi5kZXNjZW5kYW50c107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhbGwgc2VsZWN0ZWQgbm9kZXMgZnJvbSB0aGUgcGFyZW50IG5vZGUuXG4gICAgICovXG4gICAgcHJpdmF0ZSBnZXRTZWxlY3RlZENoaWxkcmVuKG5vZGU6IEhpZXJhcmNoeUJhck5vZGUpOiBIaWVyYXJjaHlCYXJOb2RlW10ge1xuXG4gICAgICAgIGlmIChub2RlLmNoaWxkcmVuIGluc3RhbmNlb2YgT2JzZXJ2YWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIFtub2RlXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdldCB0aGUgY2hpbGRyZW4gLSBhbmQgYWNjb3VudCBmb3Igd2hlbiB0aGVyZSBpcyBub25lXG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbiB8fCBbXTtcblxuICAgICAgICAvLyBjaGVjayBpZiBhbnkgY2hpbGQgaXMgc2VsZWN0ZWRcbiAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbi5maW5kKF9jaGlsZCA9PiBfY2hpbGQuc2VsZWN0ZWQpO1xuXG4gICAgICAgIC8vIHJldHVybiB0aGUgcmVtYWluaW5nIGNoYWluIG9mIHNlbGVjdGVkIGl0ZW1zXG4gICAgICAgIHJldHVybiBjaGlsZCA/IFtub2RlLCAuLi50aGlzLmdldFNlbGVjdGVkQ2hpbGRyZW4oY2hpbGQpXSA6IFtub2RlXTtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSGllcmFyY2h5QmFyTm9kZSB7XG4gICAgaWNvbj86IHN0cmluZztcbiAgICB0aXRsZTogc3RyaW5nO1xuICAgIHNlbGVjdGVkPzogYm9vbGVhbjtcbiAgICBwYXJlbnQ/OiBIaWVyYXJjaHlCYXJOb2RlO1xuICAgIGNoaWxkcmVuPzogSGllcmFyY2h5QmFyTm9kZVtdIHwgT2JzZXJ2YWJsZTxIaWVyYXJjaHlCYXJOb2RlW10+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEhpZXJhcmNoeUJhck5vZGVDaGlsZHJlbiB7XG4gICAgbG9hZGluZzogYm9vbGVhbjtcbiAgICBjaGlsZHJlbjogSGllcmFyY2h5QmFyTm9kZVtdO1xufSIsImltcG9ydCB7IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDb21wb25lbnQsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE9uRGVzdHJveSwgT3V0cHV0LCBRdWVyeUxpc3QsIFRlbXBsYXRlUmVmLCBWaWV3Q2hpbGQsIFZpZXdDaGlsZHJlbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcy9CZWhhdmlvclN1YmplY3QnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcy9TdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgZGVib3VuY2VUaW1lIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgSGllcmFyY2h5QmFyTm9kZSwgSGllcmFyY2h5QmFyU2VydmljZSB9IGZyb20gJy4vaGllcmFyY2h5LWJhci5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1oaWVyYXJjaHktYmFyJyxcbiAgICB0ZW1wbGF0ZTogYDwhLS0gQWxsb3cgY29udGVudCB0byBiZSBwbGFjZWQgb24gdGhlIGxlZnQgb2YgdGhlIGl0ZW1zIC0tPlxuPGFzaWRlIGNsYXNzPVwiaGllcmFyY2h5LWJhci1hZGRvbnNcIj5cbiAgICA8bmctY29udGVudCBzZWxlY3Q9XCJbdXhIaWVyYXJjaHlCYXJMZWZ0QWRkb25dXCI+PC9uZy1jb250ZW50PlxuPC9hc2lkZT5cblxuPG1haW4gI25vZGVsaXN0IGNsYXNzPVwiaGllcmFyY2h5LWJhci1ub2Rlc1wiICh1eFJlc2l6ZSk9XCJzY3JvbGxJbnRvVmlldygpXCI+XG5cbiAgICA8ZGl2ICpuZ0lmPVwib3ZlcmZsb3ckIHwgYXN5bmNcIlxuICAgICAgICAgI3BvcG92ZXI9XCJ1eC1wb3BvdmVyXCJcbiAgICAgICAgIGNsYXNzPVwiaGllcmFyY2h5LWJhci1vdmVyZmxvdy1pbmRpY2F0b3JcIlxuICAgICAgICAgW3N0eWxlLmxlZnQucHhdPVwibm9kZWxpc3Quc2Nyb2xsTGVmdFwiXG4gICAgICAgICBbdXhQb3BvdmVyXT1cIm92ZXJmbG93XCJcbiAgICAgICAgIFtwb3BvdmVyQ29udGV4dF09XCJ7IHBvcG92ZXI6IHBvcG92ZXIgfVwiXG4gICAgICAgICBwbGFjZW1lbnQ9XCJib3R0b21cIlxuICAgICAgICAgcG9wb3ZlckNsYXNzPVwiaGllcmFyY2h5LWJhci1wb3BvdmVyXCI+XG4gICAgICAgIC4gLiAuXG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2ICNub2RlRWxlbWVudCBjbGFzcz1cImhpZXJhcmNoeS1iYXItbm9kZVwiXG4gICAgICAgICAqbmdGb3I9XCJsZXQgbm9kZSBvZiBoaWVyYXJjaHlCYXIubm9kZXMkIHwgYXN5bmNcIj5cblxuICAgICAgICA8YnV0dG9uIGNsYXNzPVwiaGllcmFyY2h5LWJhci1ub2RlLWNvbnRlbnRcIlxuICAgICAgICAgICAgICAgIFthdHRyLmFyaWEtbGFiZWxdPVwibm9kZS50aXRsZVwiXG4gICAgICAgICAgICAgICAgKGNsaWNrKT1cImhpZXJhcmNoeUJhci5zZWxlY3ROb2RlKG5vZGUpXCI+XG5cbiAgICAgICAgICAgIDwhLS0gU2hvdyBhbiBpY29uIGlmIHNwZWNpZmVkIC0tPlxuICAgICAgICAgICAgPGltZyBjbGFzcz1cImhpZXJhcmNoeS1iYXItbm9kZS1pY29uXCIgKm5nSWY9XCJub2RlLmljb25cIiBbc3JjXT1cIm5vZGUuaWNvblwiIGFsdD1cIkhpZXJhcmNoeSBCYXIgSWNvblwiPlxuXG4gICAgICAgICAgICA8IS0tIFNob3cgdGhlIG5hbWUgb2YgdGhlIGN1cnJlbnQgbm9kZSAtLT5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaGllcmFyY2h5LWJhci1ub2RlLXRpdGxlXCI+e3sgbm9kZS50aXRsZSB9fTwvc3Bhbj5cblxuICAgICAgICA8L2J1dHRvbj5cblxuICAgICAgICA8IS0tIFNob3cgYSBkcm9wZG93biBhcnJvdyBpZiB0aGVyZSBhcmUgY2hpbGRyZW4gLS0+XG4gICAgICAgIDxidXR0b24gKm5nSWY9XCJub2RlLmNoaWxkcmVuXCJcbiAgICAgICAgICAgICAgI3BvcG92ZXI9XCJ1eC1wb3BvdmVyXCJcbiAgICAgICAgICAgICAgYXJpYS1sYWJlbD1cIlNob3cgY2hpbGRyZW5cIlxuICAgICAgICAgICAgICByb2xlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgY2xhc3M9XCJoaWVyYXJjaHktYmFyLW5vZGUtYXJyb3cgaHBlLWljb24gaHBlLW5leHRcIlxuICAgICAgICAgICAgICBbdXhQb3BvdmVyXT1cImNvbnRlbnRcIlxuICAgICAgICAgICAgICBbcG9wb3ZlckNvbnRleHRdPVwieyBub2RlOiBub2RlLCBwb3BvdmVyOiBwb3BvdmVyIH1cIlxuICAgICAgICAgICAgICBwbGFjZW1lbnQ9XCJib3R0b21cIlxuICAgICAgICAgICAgICBwb3BvdmVyQ2xhc3M9XCJoaWVyYXJjaHktYmFyLXBvcG92ZXJcIlxuICAgICAgICAgICAgICB0YWJpbmRleD1cIjBcIj5cbiAgICAgICAgPC9idXR0b24+XG5cbiAgICA8L2Rpdj5cblxuPC9tYWluPlxuXG48IS0tIEFsbG93IGNvbnRlbnQgdG8gYmUgcGxhY2VkIG9uIHRoZSByaWdodCBvZiB0aGUgaXRlbXMgLS0+XG48YXNpZGUgY2xhc3M9XCJoaWVyYXJjaHktYmFyLWFkZG9uc1wiPlxuICAgIDxuZy1jb250ZW50IHNlbGVjdD1cIlt1eEhpZXJhcmNoeUJhclJpZ2h0QWRkb25dXCI+PC9uZy1jb250ZW50PlxuPC9hc2lkZT5cblxuPCEtLSBUZW1wbGF0ZSBmb3IgdGhlIHBvcG92ZXIgbGlzdCAtLT5cbjxuZy10ZW1wbGF0ZSAjY29udGVudCBsZXQtbm9kZT1cIm5vZGVcIiBsZXQtcG9wb3Zlcj1cInBvcG92ZXJcIj5cblxuICAgIDwhLS0gTG9hZGluZyBJbmRpY2F0b3IgLS0+XG4gICAgPHVsIGNsYXNzPVwiaGllcmFyY2h5LWJhci1ub2RlLWxpc3RcIiAqbmdJZj1cIihoaWVyYXJjaHlCYXIuZ2V0Q2hpbGRyZW4obm9kZSkgfCBhc3luYykubG9hZGluZ1wiPlxuXG4gICAgICAgIDxsaSBjbGFzcz1cImhpZXJhcmNoeS1iYXItbm9kZS1saXN0LWl0ZW1cIj5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXIgW25nVGVtcGxhdGVPdXRsZXRdPVwibG9hZGluZ0luZGljYXRvciB8fCBkZWZhdWx0TG9hZGluZ0luZGljYXRvclwiPjwvbmctY29udGFpbmVyPlxuICAgICAgICA8L2xpPlxuICAgIDwvdWw+XG5cbiAgICA8IS0tIExpc3Qgb2YgY2hpbGRyZW4gLS0+XG4gICAgPHVsIGNsYXNzPVwiaGllcmFyY2h5LWJhci1ub2RlLWxpc3RcIiAqbmdJZj1cIiEoaGllcmFyY2h5QmFyLmdldENoaWxkcmVuKG5vZGUpIHwgYXN5bmMpLmxvYWRpbmdcIj5cblxuICAgICAgICA8bGkgKm5nRm9yPVwibGV0IGNoaWxkIG9mIChoaWVyYXJjaHlCYXIuZ2V0Q2hpbGRyZW4obm9kZSkgfCBhc3luYykuY2hpbGRyZW47IGxldCBmaXJzdCA9IGZpcnN0XCJcbiAgICAgICAgICAgIGNsYXNzPVwiaGllcmFyY2h5LWJhci1ub2RlLWxpc3QtaXRlbVwiXG4gICAgICAgICAgICBbZm9jdXNJZl09XCJmaXJzdFwiXG4gICAgICAgICAgICB0YWJpbmRleD1cIjBcIlxuICAgICAgICAgICAgKGtleWRvd24uZW50ZXIpPVwiaGllcmFyY2h5QmFyLnNlbGVjdE5vZGUoY2hpbGQpOyBwb3BvdmVyLmhpZGUoKVwiXG4gICAgICAgICAgICAoY2xpY2spPVwiaGllcmFyY2h5QmFyLnNlbGVjdE5vZGUoY2hpbGQpOyBwb3BvdmVyLmhpZGUoKVwiPlxuXG4gICAgICAgICAgICA8IS0tIFNob3cgYW4gaWNvbiBpZiBzcGVjaWZlZCAtLT5cbiAgICAgICAgICAgIDxpbWcgY2xhc3M9XCJoaWVyYXJjaHktYmFyLW5vZGUtaWNvblwiICpuZ0lmPVwiY2hpbGQuaWNvblwiIFtzcmNdPVwiY2hpbGQuaWNvblwiIGFsdD1cIkhpZXJhcmNoeSBCYXIgSWNvblwiPlxuXG4gICAgICAgICAgICA8IS0tIFNob3cgdGhlIG5hbWUgb2YgdGhlIGN1cnJlbnQgbm9kZSAtLT5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiaGllcmFyY2h5LWJhci1ub2RlLXRpdGxlXCI+e3sgY2hpbGQudGl0bGUgfX08L3NwYW4+XG5cbiAgICAgICAgPC9saT5cblxuICAgIDwvdWw+XG48L25nLXRlbXBsYXRlPlxuXG48IS0tIFRlbXBsYXRlIGZvciB0aGUgb3ZlcmZsb3cgcG9wb3ZlciBsaXN0IC0tPlxuPG5nLXRlbXBsYXRlICNvdmVyZmxvdyBsZXQtcG9wb3Zlcj1cInBvcG92ZXJcIj5cblxuICAgIDx1bCBjbGFzcz1cImhpZXJhcmNoeS1iYXItbm9kZS1saXN0XCI+XG5cbiAgICAgICAgPGxpICpuZ0Zvcj1cImxldCBjaGlsZCBvZiBvdmVyZmxvd05vZGVzJCB8IGFzeW5jOyBsZXQgZmlyc3QgPSBmaXJzdFwiXG4gICAgICAgICAgICBjbGFzcz1cImhpZXJhcmNoeS1iYXItbm9kZS1saXN0LWl0ZW1cIlxuICAgICAgICAgICAgdGFiaW5kZXg9XCIwXCJcbiAgICAgICAgICAgIFtmb2N1c0lmXT1cImZpcnN0XCJcbiAgICAgICAgICAgIChjbGljayk9XCJoaWVyYXJjaHlCYXIuc2VsZWN0Tm9kZShjaGlsZCk7IHBvcG92ZXIuaGlkZSgpXCJcbiAgICAgICAgICAgIChrZXlkb3duLmVudGVyKT1cImhpZXJhcmNoeUJhci5zZWxlY3ROb2RlKGNoaWxkKTsgcG9wb3Zlci5oaWRlKClcIj5cblxuICAgICAgICAgICAgPCEtLSBTaG93IGFuIGljb24gaWYgc3BlY2lmZWQgLS0+XG4gICAgICAgICAgICA8aW1nIGNsYXNzPVwiaGllcmFyY2h5LWJhci1ub2RlLWljb25cIiAqbmdJZj1cImNoaWxkLmljb25cIiBbc3JjXT1cImNoaWxkLmljb25cIiBhbHQ9XCJIaWVyYXJjaHkgQmFyIEljb25cIj5cblxuICAgICAgICAgICAgPCEtLSBTaG93IHRoZSBuYW1lIG9mIHRoZSBjdXJyZW50IG5vZGUgLS0+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImhpZXJhcmNoeS1iYXItbm9kZS10aXRsZVwiPnt7IGNoaWxkLnRpdGxlIH19PC9zcGFuPlxuXG4gICAgICAgIDwvbGk+XG5cbiAgICA8L3VsPlxuPC9uZy10ZW1wbGF0ZT5cblxuPCEtLSBMb2FkaW5nIEluZGljYXRvciBUZW1wbGF0ZSAtLT5cbjxuZy10ZW1wbGF0ZSAjZGVmYXVsdExvYWRpbmdJbmRpY2F0b3I+XG4gICAgPGRpdiBjbGFzcz1cImhpZXJhcmNoeS1iYXItbm9kZS1pY29uXCIgYWx0PVwiSGllcmFyY2h5IEJhciBMb2FkaW5nIEluZGljYXRvclwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwic3Bpbm5lciBzcGlubmVyLWFjY2VudCBzcGlubmVyLWJvdW5jZS1taWRkbGVcIj48L2Rpdj5cbiAgICA8L2Rpdj5cblxuICAgIDwhLS0gU2hvdyB0aGUgbmFtZSBvZiB0aGUgY3VycmVudCBub2RlIC0tPlxuICAgIDxzcGFuIGNsYXNzPVwiaGllcmFyY2h5LWJhci1ub2RlLXRpdGxlXCI+TG9hZGluZy4uLjwvc3Bhbj5cbjwvbmctdGVtcGxhdGU+YCxcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICB2aWV3UHJvdmlkZXJzOiBbSGllcmFyY2h5QmFyU2VydmljZV1cbn0pXG5leHBvcnQgY2xhc3MgSGllcmFyY2h5QmFyQ29tcG9uZW50IGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICAgIEBJbnB1dCgpIHNldCByb290KG5vZGU6IEhpZXJhcmNoeUJhck5vZGUpIHtcbiAgICAgICAgdGhpcy5oaWVyYXJjaHlCYXIuc2V0Um9vdE5vZGUobm9kZSk7XG4gICAgfVxuXG4gICAgQElucHV0KCkgc2V0IHNlbGVjdGVkKG5vZGU6IEhpZXJhcmNoeUJhck5vZGUpIHtcbiAgICAgICAgdGhpcy5oaWVyYXJjaHlCYXIuc2VsZWN0Tm9kZShub2RlKTtcbiAgICB9XG5cbiAgICBASW5wdXQoKSBsb2FkaW5nSW5kaWNhdG9yOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgQE91dHB1dCgpIHNlbGVjdGVkQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxIaWVyYXJjaHlCYXJOb2RlPigpO1xuICAgIEBWaWV3Q2hpbGQoJ25vZGVsaXN0Jykgbm9kZWxpc3Q6IEVsZW1lbnRSZWY7XG4gICAgQFZpZXdDaGlsZHJlbignbm9kZUVsZW1lbnQnKSBub2RlczogUXVlcnlMaXN0PEVsZW1lbnRSZWY+O1xuXG4gICAgb3ZlcmZsb3ckID0gbmV3IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPihmYWxzZSk7XG4gICAgb3ZlcmZsb3dOb2RlcyQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PEhpZXJhcmNoeUJhck5vZGVbXT4oW10pO1xuXG4gICAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGhpZXJhcmNoeUJhcjogSGllcmFyY2h5QmFyU2VydmljZSkge1xuXG4gICAgICAgIC8vIHN1YnNjcmliZSB0byBjaGFuZ2VzIGluIHRoZSBzZWxlY3RlZCBub2RlXG4gICAgICAgIGNvbnN0IHNlbGVjdGVkID0gaGllcmFyY2h5QmFyLm5vZGVzJC5zdWJzY3JpYmUobm9kZXMgPT4gdGhpcy5zZWxlY3RlZENoYW5nZS5lbWl0KG5vZGVzLmxlbmd0aCA9PT0gMCA/IG51bGwgOiBub2Rlc1tub2Rlcy5sZW5ndGggLSAxXSkpO1xuICAgICAgICBjb25zdCBjaGFuZ2VkID0gaGllcmFyY2h5QmFyLm5vZGVzJC5waXBlKGRlYm91bmNlVGltZSgwKSkuc3Vic2NyaWJlKCgpID0+IHRoaXMuc2Nyb2xsSW50b1ZpZXcoKSk7XG5cbiAgICAgICAgLy8gc3RvcmUgc3Vic2NyaXB0aW9uc1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24uYWRkKHNlbGVjdGVkKTtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLmFkZChjaGFuZ2VkKTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0aGVyZSBpcyBvdmVyZmxvdyBlbnN1cmUgdGhhdCB0aGUgcmlnaHRtb3N0XG4gICAgICogbm9kZSByZW1haW5zIGluIHZpZXcgYXQgYWxsIHRpbWVzLiBUaGUgbm9kZXMgbm8gbG9uZ2VyXG4gICAgICogdmlzaWJsZSBiZSBiZSBkaXNwbGF5ZWQgaW4gYSBwb3BvdmVyIGF2YWlsYWJsZSBvbiB0aGVcbiAgICAgKiBvdmVyZmxvdyBpbmRpY2F0b3JcbiAgICAgKi9cbiAgICBzY3JvbGxJbnRvVmlldygpOiB2b2lkIHtcblxuICAgICAgICBpZiAoIXRoaXMubm9kZWxpc3QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdldCB0aGUgbmF0aXZlIGVsZW1lbnRcbiAgICAgICAgY29uc3QgeyBuYXRpdmVFbGVtZW50IH0gPSB0aGlzLm5vZGVsaXN0O1xuXG4gICAgICAgIC8vIGVtaXQgd2hldGhlciBvciBub3QgdGhlcmUgaXMgb3ZlcmZsb3dcbiAgICAgICAgdGhpcy5vdmVyZmxvdyQubmV4dChuYXRpdmVFbGVtZW50LnNjcm9sbFdpZHRoID4gbmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aCk7XG5cbiAgICAgICAgLy8gaWYgdGhlIGhpZXJhcmNoeSBiYXIgY29udGVudHMgZG8gbm90IG92ZXJmbG93IHRoZW4gZG8gbm90aGluZ1xuICAgICAgICBpZiAobmF0aXZlRWxlbWVudC5zY3JvbGxXaWR0aCA+IG5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGgpIHtcblxuICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIHRoZSBhbW91bnQgb2Ygb3ZlcmZsb3dcbiAgICAgICAgICAgIGNvbnN0IG92ZXJmbG93QW1vdW50ID0gbmF0aXZlRWxlbWVudC5zY3JvbGxXaWR0aCAtIG5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGg7XG5cbiAgICAgICAgICAgIC8vIGRldGVybWluZSB3aGljaCBub2RlcyBhcmUgbm90IGZ1bGx5IHZpc2libGVcbiAgICAgICAgICAgIHRoaXMub3ZlcmZsb3dOb2RlcyQubmV4dChcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLmZpbHRlcihub2RlID0+IG5vZGUubmF0aXZlRWxlbWVudC5vZmZzZXRMZWZ0IDwgb3ZlcmZsb3dBbW91bnQpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKG5vZGUsIGluZGV4KSA9PiB0aGlzLmhpZXJhcmNoeUJhci5ub2RlcyQudmFsdWVbaW5kZXhdKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gbW92ZSB0aGUgc2Nyb2xsIHBvc2l0aW9uIHRvIGFsd2F5cyBzaG93IHRoZSBsYXN0IGl0bWVcbiAgICAgICAgICAgIHRoaXMubm9kZWxpc3QubmF0aXZlRWxlbWVudC5zY3JvbGxMZWZ0ID0gb3ZlcmZsb3dBbW91bnQ7XG4gICAgICAgIH1cbiAgICB9XG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBPdXRwdXQsIEV2ZW50RW1pdHRlciwgRWxlbWVudFJlZiwgSG9zdExpc3RlbmVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBEaXJlY3RpdmUoeyBcbiAgICBzZWxlY3RvcjogJ1t1eENsaWNrT3V0c2lkZV0nXG59KVxuZXhwb3J0IGNsYXNzIENsaWNrT3V0c2lkZURpcmVjdGl2ZSB7XG5cbiAgICBAT3V0cHV0KCkgdXhDbGlja091dHNpZGUgPSBuZXcgRXZlbnRFbWl0dGVyPE1vdXNlRXZlbnQ+KCk7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmKSB7IH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ2RvY3VtZW50OmNsaWNrJywgWyckZXZlbnQnXSlcbiAgICBjbGljayhldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50ICE9PSBldmVudC50YXJnZXQgJiYgIXRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5jb250YWlucyhldmVudC50YXJnZXQpKSB7XG4gICAgICAgICAgICB0aGlzLnV4Q2xpY2tPdXRzaWRlLmVtaXQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxufSIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDbGlja091dHNpZGVEaXJlY3RpdmUgfSBmcm9tICcuL2NsaWNrLW91dHNpZGUuZGlyZWN0aXZlJztcblxuXG5ATmdNb2R1bGUoe1xuICAgIGV4cG9ydHM6IFtDbGlja091dHNpZGVEaXJlY3RpdmVdLFxuICAgIGRlY2xhcmF0aW9uczogW0NsaWNrT3V0c2lkZURpcmVjdGl2ZV1cbn0pXG5leHBvcnQgY2xhc3MgQ2xpY2tPdXRzaWRlTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XG5pbXBvcnQgeyBUb29sdGlwQ29tcG9uZW50IH0gZnJvbSAnLi4vdG9vbHRpcC9pbmRleCc7XG5cbmxldCB1bmlxdWVQb3BvdmVySWQgPSAwO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICd1eC1wb3BvdmVyJyxcbiAgdGVtcGxhdGU6IGA8ZGl2IGNsYXNzPVwicG9wb3ZlciBzaG93XCIgW25nQ2xhc3NdPVwiW3BsYWNlbWVudCwgY3VzdG9tQ2xhc3NdXCIgW2lkXT1cImlkXCIgW2F0dHIucm9sZV09XCJyb2xlXCIgKHV4Q2xpY2tPdXRzaWRlKT1cImNsaWNrT3V0c2lkZSQubmV4dCgkZXZlbnQpXCI+XG4gICAgPGRpdiBjbGFzcz1cImFycm93XCI+PC9kaXY+XG4gICAgPGgzIGNsYXNzPVwicG9wb3Zlci10aXRsZVwiICpuZ0lmPVwidGl0bGVcIj57eyB0aXRsZSB9fTwvaDM+XG4gICAgPGRpdiBjbGFzcz1cInBvcG92ZXItY29udGVudFwiIChjZGtPYnNlcnZlQ29udGVudCk9XCJyZXBvc2l0aW9uKClcIj5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cIiFpc1RlbXBsYXRlUmVmXCI+e3sgY29udGVudCB9fTwvbmctY29udGFpbmVyPlxuICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiaXNUZW1wbGF0ZVJlZlwiIFtuZ1RlbXBsYXRlT3V0bGV0XT1cImNvbnRlbnRcIiBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVwiY29udGV4dFwiPjwvbmctY29udGFpbmVyPlxuICAgIDwvZGl2PlxuPC9kaXY+YCxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgUG9wb3ZlckNvbXBvbmVudCBleHRlbmRzIFRvb2x0aXBDb21wb25lbnQge1xuXG4gIC8qKiBEZWZpbmUgYSB1bmlxdWUgaWQgZm9yIGVhY2ggcG9wb3ZlciAqL1xuICBpZDogc3RyaW5nID0gYHV4LXBvcG92ZXItJHsrK3VuaXF1ZVBvcG92ZXJJZH1gO1xuXG4gIC8qKiBJZiBzcGVjaWZpZWQgYWxsb3dzIHRoZSBwb3BvdmVyIHRvIHNob3cgYSB0aXRsZSAqL1xuICB0aXRsZTogc3RyaW5nO1xuXG4gIC8qKiBUaGlzIHdpbGwgZW1pdCBhbiBldmVudCBhbnkgdGltZSB0aGUgdXNlciBjbGlja3Mgb3V0c2lkZSB0aGUgcG9wb3ZlciAqL1xuICBjbGlja091dHNpZGUkID0gbmV3IFN1YmplY3Q8TW91c2VFdmVudD4oKTtcblxuICAvKiogVGhpcyB3aWxsIHVwZGF0ZSB0aGUgdGl0bGUgb2YgdGhlIHBvcG92ZXIgYW5kIHRyaWdnZXIgY2hhbmdlIGRldGVjdGlvbiAqL1xuICBzZXRUaXRsZSh0aXRsZTogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy50aXRsZSA9IHRpdGxlO1xuICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICB9XG59IiwiaW1wb3J0IHsgRVNDQVBFIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2tleWNvZGVzJztcbmltcG9ydCB7IE92ZXJsYXlSZWYgfSBmcm9tICdAYW5ndWxhci9jZGsvb3ZlcmxheSc7XG5pbXBvcnQgeyBDb21wb25lbnRQb3J0YWwgfSBmcm9tICdAYW5ndWxhci9jZGsvcG9ydGFsJztcbmltcG9ydCB7IERpcmVjdGl2ZSwgSG9zdEJpbmRpbmcsIElucHV0LCBPbkNoYW5nZXMsIE9uSW5pdCwgU2ltcGxlQ2hhbmdlcywgVGVtcGxhdGVSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGZyb21FdmVudCB9IGZyb20gJ3J4anMvb2JzZXJ2YWJsZS9mcm9tRXZlbnQnO1xuaW1wb3J0IHsgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgVG9vbHRpcERpcmVjdGl2ZSB9IGZyb20gJy4uL3Rvb2x0aXAvaW5kZXgnO1xuaW1wb3J0IHsgUG9wb3ZlckNvbXBvbmVudCB9IGZyb20gJy4vcG9wb3Zlci5jb21wb25lbnQnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1t1eFBvcG92ZXJdJyxcbiAgICBleHBvcnRBczogJ3V4LXBvcG92ZXInXG59KVxuZXhwb3J0IGNsYXNzIFBvcG92ZXJEaXJlY3RpdmUgZXh0ZW5kcyBUb29sdGlwRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBPbkNoYW5nZXMge1xuXG4gICAgLyoqIENvbnRhaW5zIHRoZSBjb250ZW50IG9mIHRoZSBwb3BvdmVyIG9yIGEgVGVtcGxhdGVSZWYgZm9yIG1vcmUgZGV0YWlsZWQgY29udGVudCAqL1xuICAgIEBJbnB1dCgndXhQb3BvdmVyJykgY29udGVudDogc3RyaW5nIHwgVGVtcGxhdGVSZWY8YW55PjtcblxuICAgIC8qKiBPcHRpb25hbGx5IGRpc3BsYXkgYSB0aXRsZSBpbiB0aGUgcG9wb3ZlciAqL1xuICAgIEBJbnB1dCgncG9wb3ZlclRpdGxlJykgdGl0bGU6IHN0cmluZztcblxuICAgIC8qKiBBbGxvdyB0aGUgcG9wb3ZlciB0byBiZSBjb25kaXRpb25hbGx5IGRpc2FibGVkICovXG4gICAgQElucHV0KCdwb3BvdmVyRGlzYWJsZWQnKSBkaXNhYmxlZDogYm9vbGVhbjtcblxuICAgIC8qKiBBbGwgdGhlIHVzZXIgdG8gYWRkIGEgY3VzdG9tIGNsYXNzIHRvIHRoZSBwb3BvdmVyICovXG4gICAgQElucHV0KCdwb3BvdmVyQ2xhc3MnKSBjdXN0b21DbGFzczogc3RyaW5nID0gJyc7XG5cbiAgICAvKiogQWxsIHRoZSB1c2VyIHRvIGFkZCBhIHJvbGUgdG8gdGhlIHBvcG92ZXIgLSBkZWZhdWx0IGlzIHRvb2x0aXAgKi9cbiAgICBASW5wdXQoJ3BvcG92ZXJSb2xlJykgcm9sZTogc3RyaW5nID0gJ3Rvb2x0aXAnO1xuXG4gICAgLyoqIFByb3ZpZGUgdGhlIFRlbXBsYXRlUmVmIGEgY29udGV4dCBvYmplY3QgKi9cbiAgICBASW5wdXQoJ3BvcG92ZXJDb250ZXh0JykgY29udGV4dDogYW55ID0ge307XG5cbiAgICAvKiogRGVsYXkgdGhlIHNob3dpbmcgb2YgdGhlIHBvcG92ZXIgYnkgYSBudW1iZXIgb2YgbWlsaXNlY29uZHMgKi9cbiAgICBASW5wdXQoJ3BvcG92ZXJEZWxheScpIGRlbGF5OiBudW1iZXIgPSAwO1xuXG4gICAgLyoqIFNwZWNpZnkgd2hpY2ggZXZlbnRzIHNob3VsZCBzaG93IHRoZSBwb3BvdmVyICovXG4gICAgQElucHV0KCkgc2hvd1RyaWdnZXJzOiBzdHJpbmdbXSA9IFsnY2xpY2snXTtcblxuICAgIC8qKiBTcGVjaWZ5IHdoaWNoIGV2ZW50cyBzaG91bGQgaGlkZSB0aGUgcG9wb3ZlciAqL1xuICAgIEBJbnB1dCgpIGhpZGVUcmlnZ2Vyczogc3RyaW5nW10gPSBbJ2NsaWNrJywgJ2NsaWNrb3V0c2lkZScsICdlc2NhcGUnXTtcblxuICAgIC8qKiBLZWVwIHRyYWNrIG9mIHRoZSB0b29sdGlwIHZpc2liaWxpdHkgYW5kIHVwZGF0ZSBhcmlhLWV4cGFuZGVkIGF0dHJpYnV0ZSAqL1xuICAgIEBIb3N0QmluZGluZygnYXR0ci5hcmlhLWV4cGFuZGVkJykgaXNWaXNpYmxlOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKiogQSByZWZlcmVuY2UgdG8gdGhlIENESyBwb3J0YWwgY29udGFpbmluZyB0aGUgb3ZlcmxheSAqL1xuICAgIHByb3RlY3RlZCBfcG9ydGFsOiBDb21wb25lbnRQb3J0YWw8UG9wb3ZlckNvbXBvbmVudD47XG5cbiAgICAvKiogQSByZWZlcmVuY2UgdG8gdGhlIGluc3RhbmNlIG9mIHRoZSBwb3BvdmVyIGNvbXBvbmVudCB3aGVuIGNyZWF0ZWQgKi9cbiAgICBwcm90ZWN0ZWQgX2luc3RhbmNlOiBQb3BvdmVyQ29tcG9uZW50O1xuXG4gICAgLyoqIERldGVybWluZSB3aGV0aGVyIG9yIG5vdCBhbiBhcmlhLWRlc2NyaWJlZGJ5IHByb3BlcnR5IG9yaWdpbmFsbHkgZXhpc3RlZCBvbiB0aGUgZWxlbWVudCAqL1xuICAgIHByaXZhdGUgX2FyaWFEZXNjcmliZWRCeTogYm9vbGVhbjtcblxuICAgIC8qKiBJbnRlcm5hbGx5IHN0b3JlIHRoZSB0eXBlIG9mIHRoaXMgY29tcG9uZW50IC0gdXN1YWwgZm9yIGRpc3RpbmN0aW9ucyB3aGVuIGV4dGVuZGluZyB0aGUgdG9vbHRpcCBjbGFzcyAqL1xuICAgIHByb3RlY3RlZCBfdHlwZTogc3RyaW5nID0gJ3BvcG92ZXInO1xuXG4gICAgLyoqIFNldCB1cCB0aGUgdHJpZ2dlcnMgYW5kIGJpbmQgdG8gdGhlIHNob3cvaGlkZSBldmVudHMgdG8ga2VlcCB2aXNpYmlsaXR5IGluIHN5bmMgKi9cbiAgICBuZ09uSW5pdCgpOiB2b2lkIHtcblxuICAgICAgICAvLyBzZXQgdXAgdGhlIGV2ZW50IHRyaWdnZXJzXG4gICAgICAgIGZyb21FdmVudChkb2N1bWVudCwgJ2tleWRvd24nKS5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUodGhpcy5vbktleURvd24uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgaXMgYW4gYXJpYS1kZXNjcmliZWQgYnkgYXR0cmlidXRlXG4gICAgICAgIHRoaXMuX2FyaWFEZXNjcmliZWRCeSA9IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2FyaWEtZGVzY3JpYmVkYnknKTtcblxuICAgICAgICAvLyBzZXQgdXAgdGhlIGRlZmF1bHQgZXZlbnQgdHJpZ2dlcnNcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXZSBuZWVkIHRvIHNlbmQgaW5wdXQgY2hhbmdlcyB0byB0aGUgcG9wb3ZlciBjb21wb25lbnRcbiAgICAgKiBXZSBjYW4ndCB1c2Ugc2V0dGVycyBhcyB0aGV5IG1heSB0cmlnZ2VyIGJlZm9yZSBwb3BvdmVyIGluaXRpYWxpc2VkIGFuZCBjYW4ndCByZXNlbmQgb25jZSBpbml0aWFsaXNlZFxuICAgICAqKi9cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG4gICAgICAgIHN1cGVyLm5nT25DaGFuZ2VzKGNoYW5nZXMpO1xuXG4gICAgICAgIGlmICh0aGlzLl9pbnN0YW5jZSAmJiBjaGFuZ2VzLnRpdGxlKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZS5zZXRUaXRsZShjaGFuZ2VzLnRpdGxlLmN1cnJlbnRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgY3JlYXRlSW5zdGFuY2Uob3ZlcmxheVJlZjogT3ZlcmxheVJlZik6IFBvcG92ZXJDb21wb25lbnQge1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IG92ZXJsYXlSZWYuYXR0YWNoKHRoaXMuX3BvcnRhbCkuaW5zdGFuY2UgYXMgUG9wb3ZlckNvbXBvbmVudDtcblxuICAgICAgICAvLyBzdXBwbHkgdGhlIHRvb2x0aXAgd2l0aCB0aGUgY29ycmVjdCBwcm9wZXJ0aWVzXG4gICAgICAgIGluc3RhbmNlLnNldFRpdGxlKHRoaXMudGl0bGUpO1xuICAgICAgICBpbnN0YW5jZS5zZXRDb250ZW50KHRoaXMuY29udGVudCk7XG4gICAgICAgIGluc3RhbmNlLnNldFBsYWNlbWVudCh0aGlzLnBsYWNlbWVudCk7XG4gICAgICAgIGluc3RhbmNlLnNldENsYXNzKHRoaXMuY3VzdG9tQ2xhc3MpO1xuICAgICAgICBpbnN0YW5jZS5zZXRDb250ZXh0KHRoaXMuY29udGV4dCk7XG4gICAgICAgIGluc3RhbmNlLnNldFJvbGUodGhpcy5yb2xlKTtcblxuICAgICAgICAvLyBVcGRhdGUgdGhlIGFyaWEtZGVzY3JpYmVkYnkgYXR0cmlidXRlXG4gICAgICAgIHRoaXMuc2V0QXJpYURlc2NyaWJlZEJ5KGluc3RhbmNlLmlkKTtcblxuICAgICAgICAvLyBzdWJzY3JpYmUgdG8gdGhlIG91dHNpZGUgY2xpY2sgZXZlbnRcbiAgICAgICAgaW5zdGFuY2UuY2xpY2tPdXRzaWRlJC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUodGhpcy5vbkNsaWNrT3V0c2lkZS5iaW5kKHRoaXMpKTtcblxuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGNyZWF0ZVBvcnRhbCgpOiBDb21wb25lbnRQb3J0YWw8UG9wb3ZlckNvbXBvbmVudD4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9ydGFsIHx8IG5ldyBDb21wb25lbnRQb3J0YWwoUG9wb3ZlckNvbXBvbmVudCwgdGhpcy5fdmlld0NvbnRhaW5lclJlZik7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBvbktleURvd24oZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcblxuICAgICAgICAvLyBpZiB2aXNpYmxlIGFuZCB0aGUgZXNjYXBlIGtleSBpcyBwcmVzc2VkIGFuZCBpdCBpcyBvbmUgb2YgdGhlIGhpZGUgdHJpZ2dlcnNcbiAgICAgICAgaWYgKHRoaXMuaXNWaXNpYmxlICYmIGV2ZW50LmtleUNvZGUgPT09IEVTQ0FQRSAmJiB0aGlzLmluY2x1ZGVzKHRoaXMuaGlkZVRyaWdnZXJzLCAnZXNjYXBlJykpIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBvbkNsaWNrT3V0c2lkZSgpOiB2b2lkIHtcbiAgICAgICAgLy8gaWYgdmlzaWJsZSBhbmQgaXQgaXMgb25lIG9mIHRoZSBoaWRlIHRyaWdnZXJzXG4gICAgICAgIGlmICh0aGlzLmlzVmlzaWJsZSAmJiB0aGlzLmluY2x1ZGVzKHRoaXMuaGlkZVRyaWdnZXJzLCAnY2xpY2tvdXRzaWRlJykpIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIFByb2dyYW1tYXRpY2FsbHkgdXBkYXRlIHRoZSBhcmlhLWRlc2NyaWJlZGJ5IHByb3BlcnR5ICovXG4gICAgcHJvdGVjdGVkIHNldEFyaWFEZXNjcmliZWRCeShpZDogc3RyaW5nIHwgbnVsbCk6IHZvaWQge1xuXG4gICAgICAgIC8vIHdlIG9ubHkgd2FudCB0byBzZXQgdGhlIGFyaWEtZGVzY3JpYmVkYnkgYXR0ciB3aGVuIHRoZSBjb250ZW50IGlzIGEgc3RyaW5nIGFuZCB0aGVyZSB3YXMgbm8gdXNlciBkZWZpbmVkIGF0dHJpYnV0ZSBhbHJlYWR5XG4gICAgICAgIGlmICh0aGlzLl9hcmlhRGVzY3JpYmVkQnkgPT09IGZhbHNlICYmIHR5cGVvZiB0aGlzLmNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBzdXBlci5zZXRBcmlhRGVzY3JpYmVkQnkoaWQpO1xuICAgICAgICB9XG4gICAgfVxuXG59IiwiaW1wb3J0IHsgT2JzZXJ2ZXJzTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL29ic2VydmVycyc7XG5pbXBvcnQgeyBPdmVybGF5TW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL292ZXJsYXknO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDbGlja091dHNpZGVNb2R1bGUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL2NsaWNrLW91dHNpZGUvaW5kZXgnO1xuaW1wb3J0IHsgVG9vbHRpcE1vZHVsZSB9IGZyb20gJy4uL3Rvb2x0aXAvaW5kZXgnO1xuaW1wb3J0IHsgUG9wb3ZlckNvbXBvbmVudCB9IGZyb20gJy4vcG9wb3Zlci5jb21wb25lbnQnO1xuaW1wb3J0IHsgUG9wb3ZlckRpcmVjdGl2ZSB9IGZyb20gJy4vcG9wb3Zlci5kaXJlY3RpdmUnO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbXG4gICAgQ29tbW9uTW9kdWxlLFxuICAgIE92ZXJsYXlNb2R1bGUsXG4gICAgT2JzZXJ2ZXJzTW9kdWxlLFxuICAgIENsaWNrT3V0c2lkZU1vZHVsZSxcbiAgICBUb29sdGlwTW9kdWxlXG4gIF0sXG4gIGV4cG9ydHM6IFtQb3BvdmVyRGlyZWN0aXZlXSxcbiAgZGVjbGFyYXRpb25zOiBbUG9wb3ZlckNvbXBvbmVudCwgUG9wb3ZlckRpcmVjdGl2ZV0sXG4gIGVudHJ5Q29tcG9uZW50czogW1BvcG92ZXJDb21wb25lbnRdXG59KVxuZXhwb3J0IGNsYXNzIFBvcG92ZXJNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZvY3VzSWZNb2R1bGUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL2ZvY3VzLWlmL2luZGV4JztcbmltcG9ydCB7IFJlc2l6ZU1vZHVsZSB9IGZyb20gJy4uLy4uL2RpcmVjdGl2ZXMvcmVzaXplL2luZGV4JztcbmltcG9ydCB7IEhpZXJhcmNoeUJhckNvbXBvbmVudCB9IGZyb20gJy4vaGllcmFyY2h5LWJhci5jb21wb25lbnQnO1xuaW1wb3J0IHsgUG9wb3Zlck1vZHVsZSB9IGZyb20gJy4uL3BvcG92ZXIvaW5kZXgnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBSZXNpemVNb2R1bGUsXG4gICAgICAgIEZvY3VzSWZNb2R1bGUsXG4gICAgICAgIFBvcG92ZXJNb2R1bGVcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtIaWVyYXJjaHlCYXJDb21wb25lbnRdLFxuICAgIGRlY2xhcmF0aW9uczogW0hpZXJhcmNoeUJhckNvbXBvbmVudF0sXG59KVxuZXhwb3J0IGNsYXNzIEhpZXJhcmNoeUJhck1vZHVsZSB7IH1cbiIsImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFNpZGVQYW5lbFNlcnZpY2Uge1xuXG4gICAgb3BlbiQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+KGZhbHNlKTtcblxuICAgIG9wZW4oKSB7XG4gICAgICAgIHRoaXMub3BlbiQubmV4dCh0cnVlKTtcbiAgICB9XG5cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgdGhpcy5vcGVuJC5uZXh0KGZhbHNlKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBPbkluaXQsIElucHV0LCBPdXRwdXQsIEV2ZW50RW1pdHRlciwgT25EZXN0cm95LCBIb3N0QmluZGluZywgSG9zdExpc3RlbmVyLCBFbGVtZW50UmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBTaWRlUGFuZWxTZXJ2aWNlIH0gZnJvbSAnLi9zaWRlLXBhbmVsLnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LXNpZGUtcGFuZWwnLFxuICAgIGV4cG9ydEFzOiAndXgtc2lkZS1wYW5lbCcsXG4gICAgdGVtcGxhdGU6IGA8ZGl2ICpuZ0lmPVwibW9kYWwgJiYgb3BlblwiIGNsYXNzPVwibW9kYWwtYmFja2Ryb3BcIlxuICAgIFtzdHlsZS5wb3NpdGlvbl09XCJwb3NpdGlvblwiXG4gICAgW3N0eWxlLnRvcF09XCJjc3NUb3BcIj48L2Rpdj5cblxuPGRpdiBjbGFzcz1cInV4LXNpZGUtcGFuZWwtaG9zdFwiXG4gICAgW2NsYXNzLm1vZGFsLXBhbmVsXT1cIm1vZGFsXCJcbiAgICBbc3R5bGUucG9zaXRpb25dPVwicG9zaXRpb25cIlxuICAgIFtzdHlsZS53aWR0aF09XCJob3N0V2lkdGhcIlxuICAgIFtzdHlsZS50b3BdPVwiY3NzVG9wXCI+XG4gICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuPC9kaXY+XG5gLFxuICAgIHByb3ZpZGVyczogW1NpZGVQYW5lbFNlcnZpY2VdLFxuICAgIGhvc3Q6IHtcbiAgICAgICAgJ2NsYXNzJzogJ3V4LXNpZGUtcGFuZWwnXG4gICAgfVxufSlcbmV4cG9ydCBjbGFzcyBTaWRlUGFuZWxDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG5cbiAgICBASW5wdXQoKVxuICAgIEBIb3N0QmluZGluZygnY2xhc3Mub3BlbicpXG4gICAgZ2V0IG9wZW4oKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlcnZpY2Uub3BlbiQudmFsdWU7XG4gICAgfVxuXG4gICAgc2V0IG9wZW4odmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5zZXJ2aWNlLm9wZW4kLm5leHQodmFsdWUpO1xuICAgIH1cblxuICAgIEBJbnB1dCgpXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5pbmxpbmUnKVxuICAgIGlubGluZSA9IGZhbHNlO1xuXG4gICAgQElucHV0KClcbiAgICBhdHRhY2hUbzogJ3dpbmRvdycgfCAnY29udGFpbmVyJyA9ICd3aW5kb3cnO1xuXG4gICAgQElucHV0KClcbiAgICB3aWR0aDogc3RyaW5nIHwgbnVtYmVyID0gJzUwJSc7XG5cbiAgICBASW5wdXQoKVxuICAgIHRvcDogc3RyaW5nIHwgbnVtYmVyID0gJzAnO1xuXG4gICAgQElucHV0KClcbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIuYXJpYS1tb2RhbCcpXG4gICAgbW9kYWwgPSBmYWxzZTtcblxuICAgIEBJbnB1dCgpXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5hbmltYXRlJylcbiAgICBhbmltYXRlID0gZmFsc2U7XG5cbiAgICBASW5wdXQoKVxuICAgIGNsb3NlT25FeHRlcm5hbENsaWNrID0gZmFsc2U7XG5cbiAgICBAT3V0cHV0KClcbiAgICBvcGVuQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG4gICAgZ2V0IHBvc2l0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5pbmxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnc3RhdGljJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hdHRhY2hUbyA9PT0gJ2NvbnRhaW5lcicpIHtcbiAgICAgICAgICAgIHJldHVybiAnYWJzb2x1dGUnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnZml4ZWQnO1xuICAgIH1cblxuICAgIGdldCBjc3NXaWR0aCgpOiBzdHJpbmcge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMud2lkdGggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53aWR0aCA9PT0gMCA/ICcwJyA6IHRoaXMud2lkdGggKyAncHgnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLndpZHRoO1xuICAgIH1cblxuICAgIGdldCBjc3NUb3AoKTogc3RyaW5nIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnRvcCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvcCA9PT0gMCA/ICcwJyA6IHRoaXMudG9wICsgJ3B4JztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50b3A7XG4gICAgfVxuXG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS53aWR0aCcpXG4gICAgZ2V0IGNvbXBvbmVudFdpZHRoKCk6IHN0cmluZyB7XG4gICAgICAgIGlmICh0aGlzLmlubGluZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3BlbiA/IHRoaXMuY3NzV2lkdGggOiAnMCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZ2V0IGhvc3RXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5saW5lID8gJzEwMCUnIDogdGhpcy5jc3NXaWR0aDtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9zdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcm90ZWN0ZWQgc2VydmljZTogU2lkZVBhbmVsU2VydmljZSxcbiAgICAgICAgcHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZlxuICAgICkgeyB9XG5cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gdGhpcy5zZXJ2aWNlLm9wZW4kLnN1YnNjcmliZSgobmV4dCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5vcGVuQ2hhbmdlLmVtaXQobmV4dCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG5cbiAgICBvcGVuUGFuZWwoKSB7XG4gICAgICAgIHRoaXMuc2VydmljZS5vcGVuKCk7XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcignZG9jdW1lbnQ6a2V5dXAuZXNjYXBlJylcbiAgICBjbG9zZVBhbmVsKCkge1xuICAgICAgICB0aGlzLnNlcnZpY2UuY2xvc2UoKTtcbiAgICB9XG5cbiAgICBASG9zdExpc3RlbmVyKCdkb2N1bWVudDpjbGljaycsIFsnJGV2ZW50J10pXG4gICAgY2xpY2tIYW5kbGVyKGV2ZW50OiBNb3VzZUV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5vcGVuIHx8ICF0aGlzLmNsb3NlT25FeHRlcm5hbENsaWNrKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQgYXMgSFRNTEVsZW1lbnQ7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuY29udGFpbnModGFyZ2V0KSB8fFxuICAgICAgICAgICAgKHRhcmdldCAmJiB0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdtb2RhbC1iYWNrZHJvcCcpKSkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZVBhbmVsKCk7XG4gICAgICAgIH1cbiAgICB9XG59IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBEaXJlY3RpdmUsIElucHV0LCBPdXRwdXQsIEV2ZW50RW1pdHRlciwgQ29udGVudENoaWxkLCBFbGVtZW50UmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBTaWRlUGFuZWxDb21wb25lbnQgfSBmcm9tICcuLi9zaWRlLXBhbmVsL3NpZGUtcGFuZWwuY29tcG9uZW50JztcbmltcG9ydCB7IFNpZGVQYW5lbFNlcnZpY2UgfSBmcm9tICcuLi9zaWRlLXBhbmVsL3NpZGUtcGFuZWwuc2VydmljZSc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3V4SXRlbURpc3BsYXlQYW5lbENvbnRlbnRdJ1xufSlcbmV4cG9ydCBjbGFzcyBJdGVtRGlzcGxheVBhbmVsQ29udGVudERpcmVjdGl2ZSB7IH1cblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbdXhJdGVtRGlzcGxheVBhbmVsRm9vdGVyXSdcbn0pXG5leHBvcnQgY2xhc3MgSXRlbURpc3BsYXlQYW5lbEZvb3RlckRpcmVjdGl2ZSB7IH1cblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1pdGVtLWRpc3BsYXktcGFuZWwnLFxuICAgIHRlbXBsYXRlOiBgPGRpdiBjbGFzcz1cInV4LXNpZGUtcGFuZWwtaG9zdCB1eC1pdGVtLWRpc3BsYXktcGFuZWxcIlxuICAgIFtjbGFzcy5ib3gtc2hhZG93XT1cImJveFNoYWRvd1wiXG4gICAgW3N0eWxlLnBvc2l0aW9uXT1cInBvc2l0aW9uXCJcbiAgICBbc3R5bGUud2lkdGhdPVwiaG9zdFdpZHRoXCJcbiAgICBbc3R5bGUudG9wXT1cImNzc1RvcFwiPlxuXG4gICAgPGRpdiBjbGFzcz1cInV4LXNpZGUtcGFuZWwtaGVhZGVyXCIgW2NsYXNzLml0ZW0tZGlzcGxheS1wYW5lbC1zaGFkb3ddPVwic2hhZG93XCI+XG4gICAgICAgIDxoMz57eyBoZWFkZXIgfX08L2gzPlxuICAgICAgICA8YnV0dG9uICpuZ0lmPVwiY2xvc2VWaXNpYmxlXCIgdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1sZyBidG4tbGluayBidG4taWNvbiBidXR0b24tc2Vjb25kYXJ5XCIgKGNsaWNrKT1cInZpc2libGUgPSBmYWxzZVwiPlxuICAgICAgICAgICAgPGkgY2xhc3M9XCJocGUtaWNvbiBocGUtY2xvc2VcIj48L2k+XG4gICAgICAgIDwvYnV0dG9uPlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cInV4LXNpZGUtcGFuZWwtY29udGVudFwiPlxuICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJbdXhJdGVtRGlzcGxheVBhbmVsQ29udGVudF1cIj48L25nLWNvbnRlbnQ+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwidXgtc2lkZS1wYW5lbC1mb290ZXJcIiAqbmdJZj1cImZvb3RlclwiPlxuICAgICAgICA8bmctY29udGVudCBzZWxlY3Q9XCJbdXhJdGVtRGlzcGxheVBhbmVsRm9vdGVyXVwiPjwvbmctY29udGVudD5cbiAgICA8L2Rpdj5cblxuPC9kaXY+XG5gLFxuICAgIHByb3ZpZGVyczogW1NpZGVQYW5lbFNlcnZpY2VdLFxuICAgIGhvc3Q6IHtcbiAgICAgICAgJ2NsYXNzJzogJ3V4LXNpZGUtcGFuZWwgdXgtaXRlbS1kaXNwbGF5LXBhbmVsJ1xuICAgIH1cbn0pXG5leHBvcnQgY2xhc3MgSXRlbURpc3BsYXlQYW5lbENvbXBvbmVudCBleHRlbmRzIFNpZGVQYW5lbENvbXBvbmVudCB7XG5cbiAgICBASW5wdXQoKSBoZWFkZXI6IHN0cmluZztcblxuICAgIEBJbnB1dCgpIGJveFNoYWRvdzogYm9vbGVhbiA9IHRydWU7XG5cbiAgICBASW5wdXQoKSBjbG9zZVZpc2libGU6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgZ2V0IHByZXZlbnRDbG9zZSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmNsb3NlT25FeHRlcm5hbENsaWNrO1xuICAgIH1cblxuICAgIEBJbnB1dCgpXG4gICAgc2V0IHByZXZlbnRDbG9zZSh2YWx1ZTogYm9vbGVhbikge1xuICAgICAgICB0aGlzLmNsb3NlT25FeHRlcm5hbENsaWNrID0gIXZhbHVlO1xuICAgIH1cblxuICAgIEBJbnB1dCgpIHNoYWRvdzogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgQENvbnRlbnRDaGlsZChJdGVtRGlzcGxheVBhbmVsRm9vdGVyRGlyZWN0aXZlKSBmb290ZXI6IEl0ZW1EaXNwbGF5UGFuZWxGb290ZXJEaXJlY3RpdmU7XG5cbiAgICBAT3V0cHV0KCkgdmlzaWJsZUNoYW5nZTogRXZlbnRFbWl0dGVyPGJvb2xlYW4+ID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKiBUaXRsZSB1c2VkIGZvciBhZGRpbmcgdG9vbHRpcHMgYW5kIHNob3VsZG4ndCBiZSB1c2VkIGFzIGFuIGlucHV0XG4gICAgICogaW5zdGVhZCBoZWFkZXIgd2lsbCBiZSB1c2VkLiBUaGlzIGlzIGhlcmUgdG8gc3VwcG9ydCBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IG9ubHlcbiAgICAgKiB0aGlzIHByb3BlcnR5IHNob3VsZCBub3QgYmUgdXNlZC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNldCB0aXRsZSh2YWx1ZTogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuaGVhZGVyID0gdmFsdWU7XG4gICAgfVxuXG4gICAgZ2V0IHRpdGxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oZWFkZXI7XG4gICAgfVxuXG4gICAgQElucHV0KClcbiAgICBzZXQgdmlzaWJsZSh2aXNpYmxlOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMub3BlbiA9IHZpc2libGU7XG4gICAgfVxuXG4gICAgZ2V0IHZpc2libGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wZW47XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfaXRlbURpc3BsYXlQYW5lbFN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gICAgY29uc3RydWN0b3Ioc2VydmljZTogU2lkZVBhbmVsU2VydmljZSwgZWxlbWVudFJlZjogRWxlbWVudFJlZikge1xuICAgICAgICBzdXBlcihzZXJ2aWNlLCBlbGVtZW50UmVmKTtcblxuICAgICAgICB0aGlzLmFuaW1hdGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jbG9zZU9uRXh0ZXJuYWxDbGljayA9IHRydWU7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMuX2l0ZW1EaXNwbGF5UGFuZWxTdWJzY3JpcHRpb24gPSB0aGlzLnNlcnZpY2Uub3BlbiQuc3Vic2NyaWJlKChuZXh0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnZpc2libGVDaGFuZ2UuZW1pdChuZXh0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX2l0ZW1EaXNwbGF5UGFuZWxTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBJdGVtRGlzcGxheVBhbmVsQ29tcG9uZW50LCBJdGVtRGlzcGxheVBhbmVsQ29udGVudERpcmVjdGl2ZSwgSXRlbURpc3BsYXlQYW5lbEZvb3RlckRpcmVjdGl2ZSB9IGZyb20gJy4vaXRlbS1kaXNwbGF5LXBhbmVsLmNvbXBvbmVudCc7XG5cbmNvbnN0IERFQ0xBUkFUSU9OUyA9IFtcbiAgICBJdGVtRGlzcGxheVBhbmVsQ29tcG9uZW50LFxuICAgIEl0ZW1EaXNwbGF5UGFuZWxDb250ZW50RGlyZWN0aXZlLFxuICAgIEl0ZW1EaXNwbGF5UGFuZWxGb290ZXJEaXJlY3RpdmVcbl07XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGVcbiAgICBdLFxuICAgIGV4cG9ydHM6IERFQ0xBUkFUSU9OUyxcbiAgICBkZWNsYXJhdGlvbnM6IERFQ0xBUkFUSU9OU1xufSlcbmV4cG9ydCBjbGFzcyBJdGVtRGlzcGxheVBhbmVsTW9kdWxlIHt9IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgRXZlbnRFbWl0dGVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtd2l6YXJkLXN0ZXAnLFxuICAgIHRlbXBsYXRlOiBgPG5nLWNvbnRhaW5lciAqbmdJZj1cImFjdGl2ZVwiPlxuICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbjwvbmctY29udGFpbmVyPmBcbn0pXG5leHBvcnQgY2xhc3MgV2l6YXJkU3RlcENvbXBvbmVudCB7XG4gICAgXG4gICAgQElucHV0KCkgaGVhZGVyOiBzdHJpbmc7XG4gICAgQElucHV0KCkgdmFsaWQ6IGJvb2xlYW4gPSB0cnVlO1xuICAgIEBJbnB1dCgpIHZpc2l0ZWRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XG5cbiAgICBwcml2YXRlIF9hY3RpdmU6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBwcml2YXRlIF92aXNpdGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBASW5wdXQoKSBcbiAgICBnZXQgdmlzaXRlZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2l0ZWQ7XG4gICAgfVxuXG4gICAgc2V0IHZpc2l0ZWQodmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5fdmlzaXRlZCA9IHZhbHVlO1xuICAgICAgICB0aGlzLnZpc2l0ZWRDaGFuZ2UubmV4dCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgc2V0IGFjdGl2ZSh2YWx1ZTogYm9vbGVhbikge1xuICAgICAgICBcbiAgICAgICAgLy8gc3RvcmUgdGhlIGFjdGl2ZSBzdGF0ZSBvZiB0aGUgc3RlcFxuICAgICAgICB0aGlzLl9hY3RpdmUgPSB2YWx1ZTtcblxuICAgICAgICAvLyBpZiB0aGUgdmFsdWUgaXMgdHJ1ZSB0aGVuIHRoZSBzdGVwIHNob3VsZCBhbHNvIGJlIG1hcmtlZCBhcyB2aXNpdGVkXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy52aXNpdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBhY3RpdmUoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hY3RpdmU7XG4gICAgfVxuXG59IiwiaW1wb3J0IHsgQWZ0ZXJWaWV3SW5pdCwgQ29tcG9uZW50LCBDb250ZW50Q2hpbGRyZW4sIEV2ZW50RW1pdHRlciwgSW5wdXQsIE91dHB1dCwgUXVlcnlMaXN0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBXaXphcmRTdGVwQ29tcG9uZW50IH0gZnJvbSAnLi93aXphcmQtc3RlcC5jb21wb25lbnQnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LXdpemFyZCcsXG4gICAgdGVtcGxhdGU6IGA8ZGl2IGNsYXNzPVwid2l6YXJkLWJvZHlcIj5cblxuICAgIDxkaXYgY2xhc3M9XCJ3aXphcmQtc3RlcHNcIj5cblxuICAgICAgICA8ZGl2IGNsYXNzPVwid2l6YXJkLXN0ZXBcIiBbY2xhc3MuYWN0aXZlXT1cInN0cC5hY3RpdmVcIiBbY2xhc3MudmlzaXRlZF09XCJzdHAudmlzaXRlZFwiIFtjbGFzcy5pbnZhbGlkXT1cInN0cC5hY3RpdmUgJiYgIXN0cC52YWxpZCAmJiBpbnZhbGlkSW5kaWNhdG9yXCIgKGNsaWNrKT1cImdvdG9TdGVwKHN0cClcIiAqbmdGb3I9XCJsZXQgc3RwIG9mIHN0ZXBzXCI+XG4gICAgICAgICAgICB7eyBzdHAuaGVhZGVyIH19XG4gICAgICAgIDwvZGl2PlxuXG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwid2l6YXJkLWNvbnRlbnRcIj5cbiAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgIDwvZGl2PlxuXG48L2Rpdj5cblxuPGRpdiBjbGFzcz1cIndpemFyZC1mb290ZXJcIj5cbiAgICA8YnV0dG9uICN0aXA9XCJ1eC10b29sdGlwXCIgY2xhc3M9XCJidG4gYnV0dG9uLXNlY29uZGFyeVwiICpuZ0lmPVwicHJldmlvdXNWaXNpYmxlXCIgW3V4VG9vbHRpcF09XCJwcmV2aW91c1Rvb2x0aXBcIiBbZGlzYWJsZWRdPVwicHJldmlvdXNEaXNhYmxlZCB8fCBzdGVwID09PSAwXCJcbiAgICAgICAgKGNsaWNrKT1cInByZXZpb3VzKCk7IHRpcC5oaWRlKClcIj57eyBwcmV2aW91c1RleHQgfX08L2J1dHRvbj5cblxuICAgIDxidXR0b24gI3RpcD1cInV4LXRvb2x0aXBcIiBjbGFzcz1cImJ0biBidXR0b24tcHJpbWFyeVwiICpuZ0lmPVwibmV4dFZpc2libGUgJiYgIWlzTGFzdFN0ZXAoKVwiIFt1eFRvb2x0aXBdPVwibmV4dFRvb2x0aXBcIiBbZGlzYWJsZWRdPVwibmV4dERpc2FibGVkXCJcbiAgICAgICAgKGNsaWNrKT1cIm5leHQoKTsgdGlwLmhpZGUoKVwiPnt7IG5leHRUZXh0IH19PC9idXR0b24+XG5cbiAgICA8YnV0dG9uICN0aXA9XCJ1eC10b29sdGlwXCIgY2xhc3M9XCJidG4gYnV0dG9uLXByaW1hcnlcIiAqbmdJZj1cImZpbmlzaFZpc2libGUgJiYgaXNMYXN0U3RlcCgpIHx8IGZpbmlzaEFsd2F5c1Zpc2libGVcIiBbdXhUb29sdGlwXT1cImZpbmlzaFRvb2x0aXBcIlxuICAgICAgICBbZGlzYWJsZWRdPVwiZmluaXNoRGlzYWJsZWRcIiAoY2xpY2spPVwiZmluaXNoKCk7IHRpcC5oaWRlKClcIj57eyBmaW5pc2hUZXh0IH19PC9idXR0b24+XG5cbiAgICA8YnV0dG9uICN0aXA9XCJ1eC10b29sdGlwXCIgY2xhc3M9XCJidG4gYnV0dG9uLXNlY29uZGFyeVwiICpuZ0lmPVwiY2FuY2VsVmlzaWJsZSAmJiAhaXNMYXN0U3RlcCgpIHx8IGNhbmNlbEFsd2F5c1Zpc2libGVcIiBbdXhUb29sdGlwXT1cImNhbmNlbFRvb2x0aXBcIlxuICAgICAgICBbZGlzYWJsZWRdPVwiY2FuY2VsRGlzYWJsZWRcIiAoY2xpY2spPVwiY2FuY2VsKCk7IHRpcC5oaWRlKClcIj57eyBjYW5jZWxUZXh0IH19PC9idXR0b24+XG48L2Rpdj5gLFxuICAgIGhvc3Q6IHtcbiAgICAgICAgJ1tjbGFzc10nOiAnb3JpZW50YXRpb24nXG4gICAgfVxufSlcbmV4cG9ydCBjbGFzcyBXaXphcmRDb21wb25lbnQgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0IHtcblxuICAgIHByaXZhdGUgX3N0ZXA6IG51bWJlciA9IDA7XG5cbiAgICBAQ29udGVudENoaWxkcmVuKFdpemFyZFN0ZXBDb21wb25lbnQpIHN0ZXBzID0gbmV3IFF1ZXJ5TGlzdDxXaXphcmRTdGVwQ29tcG9uZW50PigpO1xuXG4gICAgQElucHV0KCkgb3JpZW50YXRpb246ICdob3Jpem9udGFsJyB8ICd2ZXJ0aWNhbCcgPSAnaG9yaXpvbnRhbCc7XG5cbiAgICBASW5wdXQoKSBuZXh0VGV4dDogc3RyaW5nID0gJ05leHQnO1xuICAgIEBJbnB1dCgpIHByZXZpb3VzVGV4dDogc3RyaW5nID0gJ1ByZXZpb3VzJztcbiAgICBASW5wdXQoKSBjYW5jZWxUZXh0OiBzdHJpbmcgPSAnQ2FuY2VsJztcbiAgICBASW5wdXQoKSBmaW5pc2hUZXh0OiBzdHJpbmcgPSAnRmluaXNoJztcblxuICAgIEBJbnB1dCgpIG5leHRUb29sdGlwOiBzdHJpbmcgPSAnR28gdG8gdGhlIG5leHQgc3RlcCc7XG4gICAgQElucHV0KCkgcHJldmlvdXNUb29sdGlwOiBzdHJpbmcgPSAnR28gdG8gdGhlIHByZXZpb3VzIHN0ZXAnO1xuICAgIEBJbnB1dCgpIGNhbmNlbFRvb2x0aXA6IHN0cmluZyA9ICdDYW5jZWwgdGhlIHdpemFyZCc7XG4gICAgQElucHV0KCkgZmluaXNoVG9vbHRpcDogc3RyaW5nID0gJ0ZpbmlzaCB0aGUgd2l6YXJkJztcblxuICAgIEBJbnB1dCgpIG5leHREaXNhYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIEBJbnB1dCgpIHByZXZpb3VzRGlzYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBASW5wdXQoKSBjYW5jZWxEaXNhYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIEBJbnB1dCgpIGZpbmlzaERpc2FibGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBASW5wdXQoKSBuZXh0VmlzaWJsZTogYm9vbGVhbiA9IHRydWU7XG4gICAgQElucHV0KCkgcHJldmlvdXNWaXNpYmxlOiBib29sZWFuID0gdHJ1ZTtcbiAgICBASW5wdXQoKSBjYW5jZWxWaXNpYmxlOiBib29sZWFuID0gdHJ1ZTtcbiAgICBASW5wdXQoKSBmaW5pc2hWaXNpYmxlOiBib29sZWFuID0gdHJ1ZTtcbiAgICBASW5wdXQoKSBjYW5jZWxBbHdheXNWaXNpYmxlOiBib29sZWFuID0gZmFsc2U7XG4gICAgQElucHV0KCkgZmluaXNoQWx3YXlzVmlzaWJsZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgQE91dHB1dCgpIG9uTmV4dCA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyPigpO1xuICAgIEBPdXRwdXQoKSBvblByZXZpb3VzID0gbmV3IEV2ZW50RW1pdHRlcjxudW1iZXI+KCk7XG4gICAgQE91dHB1dCgpIG9uQ2FuY2VsID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuICAgIEBPdXRwdXQoKSBvbkZpbmlzaGluZyA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcbiAgICBAT3V0cHV0KCkgb25GaW5pc2ggPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG4gICAgQE91dHB1dCgpIHN0ZXBDaGFuZ2luZyA9IG5ldyBFdmVudEVtaXR0ZXI8U3RlcENoYW5naW5nRXZlbnQ+KCk7XG4gICAgQE91dHB1dCgpIHN0ZXBDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPG51bWJlcj4oKTtcblxuICAgIGludmFsaWRJbmRpY2F0b3I6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIEBJbnB1dCgpXG4gICAgZ2V0IHN0ZXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGVwO1xuICAgIH1cbiAgICBzZXQgc3RlcCh2YWx1ZTogbnVtYmVyKSB7XG5cbiAgICAgICAgLy8gb25seSBhY2NlcHQgbnVtYmVycyBhcyB2YWxpZCBvcHRpb25zXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG5cbiAgICAgICAgICAgIC8vIHN0b3JlIHRoZSBhY3RpdmUgc3RlcFxuICAgICAgICAgICAgdGhpcy5fc3RlcCA9IHZhbHVlO1xuXG4gICAgICAgICAgICAvLyB1cGRhdGUgd2hpY2ggc3RlcHMgc2hvdWxkIGJlIGFjdGl2ZVxuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcblxuICAgICAgICAgICAgLy8gZW1pdCB0aGUgY2hhbmdlIGV2ZW50XG4gICAgICAgICAgICB0aGlzLnN0ZXBDaGFuZ2UubmV4dCh0aGlzLnN0ZXApO1xuXG4gICAgICAgICAgICAvLyByZXNldCB0aGUgaW52YWxpZCBzdGF0ZVxuICAgICAgICAgICAgdGhpcy5pbnZhbGlkSW5kaWNhdG9yID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gaW5pdGlhbGx5IHNldCB0aGUgY29ycmVjdCB2aXNpYmlsaXR5IG9mIHRoZSBzdGVwc1xuICAgICAgICBzZXRUaW1lb3V0KHRoaXMudXBkYXRlLmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5hdmlnYXRlIHRvIHRoZSBuZXh0IHN0ZXBcbiAgICAgKi9cbiAgICBuZXh0KCk6IHZvaWQge1xuXG4gICAgICAgIHRoaXMuc3RlcENoYW5naW5nLm5leHQobmV3IFN0ZXBDaGFuZ2luZ0V2ZW50KHRoaXMuc3RlcCwgdGhpcy5zdGVwICsgMSkpO1xuXG4gICAgICAgIC8vIGNoZWNrIGlmIGN1cnJlbnQgc3RlcCBpcyBpbnZhbGlkXG4gICAgICAgIGlmICghdGhpcy5nZXRDdXJyZW50U3RlcCgpLnZhbGlkKSB7XG4gICAgICAgICAgICB0aGlzLmludmFsaWRJbmRpY2F0b3IgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgd2UgYXJlIGN1cnJlbnRseSBvbiB0aGUgbGFzdCBzdGVwXG4gICAgICAgIGlmICgodGhpcy5zdGVwICsgMSkgPCB0aGlzLnN0ZXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5zdGVwKys7XG5cbiAgICAgICAgICAgIC8vIGVtaXQgdGhlIGN1cnJlbnQgc3RlcFxuICAgICAgICAgICAgdGhpcy5vbk5leHQubmV4dCh0aGlzLnN0ZXApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTmF2aWdhdGUgdG8gdGhlIHByZXZpb3VzIHN0ZXBcbiAgICAgKi9cbiAgICBwcmV2aW91cygpOiB2b2lkIHtcblxuICAgICAgICB0aGlzLnN0ZXBDaGFuZ2luZy5uZXh0KG5ldyBTdGVwQ2hhbmdpbmdFdmVudCh0aGlzLnN0ZXAsIHRoaXMuc3RlcCAtIDEpKTtcblxuICAgICAgICAvLyBjaGVjayBpZiB3ZSBhcmUgY3VycmVudGx5IG9uIHRoZSBsYXN0IHN0ZXBcbiAgICAgICAgaWYgKHRoaXMuc3RlcCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuc3RlcC0tO1xuXG4gICAgICAgICAgICAvLyBlbWl0IHRoZSBjdXJyZW50IHN0ZXBcbiAgICAgICAgICAgIHRoaXMub25QcmV2aW91cy5uZXh0KHRoaXMuc3RlcCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGFjdGlvbnMgd2hlbiB0aGUgZmluaXNoIGJ1dHRvbiBpcyBjbGlja2VkXG4gICAgICovXG4gICAgZmluaXNoKCk6IFByb21pc2U8dm9pZD4ge1xuXG4gICAgICAgIC8vIGZpcmVzIHdoZW4gdGhlIGZpbmlzaCBidXR0b24gaXMgY2xpY2tlZCBhbHdheXNcbiAgICAgICAgdGhpcy5vbkZpbmlzaGluZy5uZXh0KCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgaXMgcmVxdWlyZWQgYmVjYXVzZSB3ZSBuZWVkIHRvIGVuc3VyZSBjaGFuZ2UgZGV0ZWN0aW9uIGhhcyBydW5cbiAgICAgICAgICogdG8gZGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IHdlIGhhdmUgdGhlIGxhdGVzdCB2YWx1ZSBmb3IgdGhlICd2YWxpZCcgaW5wdXRcbiAgICAgICAgICogb24gdGhlIGN1cnJlbnQgc3RlcC4gVW5mb3J0dW5hdGVseSB3ZSBjYW4ndCB1c2UgQ2hhbmdlRGV0ZWN0b3JSZWYgYXMgd2UgYXJlIGxvb2tpbmcgdG8gcnVuXG4gICAgICAgICAqIG9uIGNvbnRlbnQgY2hpbGRyZW4sIGFuZCB3ZSBjYW50IHVzZSBBcHBsaWNhdGlvblJlZi50aWNrKCkgYXMgdGhpcyBkb2VzIG5vdCB3b3JrIGluIGEgaHlicmlkIGFwcCwgZWcuIG91ciBkb2NzXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2U8dm9pZD4ocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcblxuICAgICAgICAgICAgICAgIC8vIG9ubHkgZmlyZXMgd2hlbiB0aGUgZmluaXNoIGJ1dHRvbiBpcyBjbGlja2VkIGFuZCB0aGUgc3RlcCBpcyB2YWxpZFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmdldEN1cnJlbnRTdGVwKCkudmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkZpbmlzaC5uZXh0KCk7ICAgICAgICBcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBhY3Rpb25zIHdoZW4gdGhlIGNhbmNlbCBidXR0b24gaXMgY2xpY2tlZFxuICAgICAqL1xuICAgIGNhbmNlbCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5vbkNhbmNlbC5uZXh0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBhY3RpdmUgc3RhdGUgb2YgZWFjaCBzdGVwXG4gICAgICovXG4gICAgdXBkYXRlKCk6IHZvaWQge1xuICAgICAgICAvLyB1cGRhdGUgd2hpY2ggc3RlcHMgc2hvdWxkIGJlIGFjdGl2ZVxuICAgICAgICB0aGlzLnN0ZXBzLmZvckVhY2goKHN0ZXAsIGlkeCkgPT4gc3RlcC5hY3RpdmUgPSBpZHggPT09IHRoaXMuc3RlcCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSnVtcCB0byBhIHNwZWNpZmljIHN0ZXAgb25seSBpZiB0aGUgc3RlcCBoYXMgcHJldmlvdXNseSBiZWVuIHZpc2l0ZWRcbiAgICAgKi9cbiAgICBnb3RvU3RlcChzdGVwOiBXaXphcmRTdGVwQ29tcG9uZW50KTogdm9pZCB7XG4gICAgICAgIGlmIChzdGVwLnZpc2l0ZWQpIHtcblxuICAgICAgICAgICAgY29uc3Qgc3RlcEluZGV4ID0gdGhpcy5zdGVwcy50b0FycmF5KCkuZmluZEluZGV4KHN0cCA9PiBzdHAgPT09IHN0ZXApO1xuXG4gICAgICAgICAgICB0aGlzLnN0ZXBDaGFuZ2luZy5uZXh0KG5ldyBTdGVwQ2hhbmdpbmdFdmVudCh0aGlzLnN0ZXAsIHN0ZXBJbmRleCkpO1xuXG4gICAgICAgICAgICB0aGlzLnN0ZXAgPSBzdGVwSW5kZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgaWYgdGhlIGN1cnJlbnQgc3RlcCBpcyB0aGUgbGFzdCBzdGVwXG4gICAgICovXG4gICAgaXNMYXN0U3RlcCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RlcCA9PT0gKHRoaXMuc3RlcHMubGVuZ3RoIC0gMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzZXQgdGhlIHdpemFyZCAtIGdvZXMgdG8gZmlyc3Qgc3RlcCBhbmQgcmVzZXRzIHZpc2l0ZWQgc3RhdGVcbiAgICAgKi9cbiAgICByZXNldCgpOiB2b2lkIHtcblxuICAgICAgICAvLyBtYXJrIGFsbCBzdGVwcyBhcyBub3QgdmlzaXRlZFxuICAgICAgICB0aGlzLnN0ZXBzLmZvckVhY2goc3RlcCA9PiBzdGVwLnZpc2l0ZWQgPSBmYWxzZSk7XG5cbiAgICAgICAgLy8gZ28gdG8gdGhlIGZpcnN0IHN0ZXBcbiAgICAgICAgdGhpcy5zdGVwID0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHN0ZXAgYXQgdGhlIGN1cnJlbnQgaW5kZXhcbiAgICAgKi9cbiAgICBnZXRDdXJyZW50U3RlcCgpOiBXaXphcmRTdGVwQ29tcG9uZW50IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RlcEF0SW5kZXgodGhpcy5zdGVwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBzdGVwIGF0IGEgc3BlY2lmaWMgaW5kZXhcbiAgICAgKi9cbiAgICBnZXRTdGVwQXRJbmRleChpbmRleDogbnVtYmVyKTogV2l6YXJkU3RlcENvbXBvbmVudCB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0ZXBzLnRvQXJyYXkoKVtpbmRleF07XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgU3RlcENoYW5naW5nRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBmcm9tOiBudW1iZXIsIHB1YmxpYyB0bzogbnVtYmVyKSB7IH1cbn0iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IFdpemFyZENvbXBvbmVudCB9IGZyb20gJy4vd2l6YXJkLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBXaXphcmRTdGVwQ29tcG9uZW50IH0gZnJvbSAnLi93aXphcmQtc3RlcC5jb21wb25lbnQnO1xuaW1wb3J0IHsgVG9vbHRpcE1vZHVsZSB9IGZyb20gJy4uL3Rvb2x0aXAvaW5kZXgnO1xuXG5jb25zdCBERUNMQVJBVElPTlMgPSBbXG4gICAgV2l6YXJkQ29tcG9uZW50LFxuICAgIFdpemFyZFN0ZXBDb21wb25lbnRcbl07XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIFRvb2x0aXBNb2R1bGVcbiAgICBdLFxuICAgIGV4cG9ydHM6IERFQ0xBUkFUSU9OUyxcbiAgICBkZWNsYXJhdGlvbnM6IERFQ0xBUkFUSU9OU1xufSlcbmV4cG9ydCBjbGFzcyBXaXphcmRNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcbmltcG9ydCB7IE1hcnF1ZWVXaXphcmRTdGVwQ29tcG9uZW50IH0gZnJvbSAnLi9tYXJxdWVlLXdpemFyZC1zdGVwLmNvbXBvbmVudCc7XG5cbi8qKlxuICogVGhpcyBzZXJ2aWNlIGlzIHJlcXVpcmVkIHRvIHByb3ZpZGUgYSBmb3JtIG9mIGNvbW11bmljYXRpb25cbiAqIGJldHdlZW4gdGhlIG1hcnF1ZWUgd2l6YXJkIHN0ZXBzIGFuZCB0aGUgY29udGFpbmluZyBtYXJxdWVlIHdpemFyZC5cbiAqIFdlIGNhbm5vdCBpbmplY3QgdGhlIEhvc3QgZHVlIHRvIHRoZSBzdGVwcyBiZWluZyBjb250ZW50IGNoaWxkcmVuIFxuICogcmF0aGVyIHRoYW4gdmlldyBjaGlsZHJlbi5cbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIE1hcnF1ZWVXaXphcmRTZXJ2aWNlIHtcbiAgICB2YWxpZCQgPSBuZXcgU3ViamVjdDxNYXJxdWVlV2l6YXJkVmFsaWRFdmVudD4oKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNYXJxdWVlV2l6YXJkVmFsaWRFdmVudCB7XG4gICAgc3RlcDogTWFycXVlZVdpemFyZFN0ZXBDb21wb25lbnQ7XG4gICAgdmFsaWQ6IGJvb2xlYW47XG59IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgT3V0cHV0LCBFdmVudEVtaXR0ZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFdpemFyZFN0ZXBDb21wb25lbnQgfSBmcm9tICcuLi93aXphcmQvaW5kZXgnO1xuaW1wb3J0IHsgTWFycXVlZVdpemFyZFNlcnZpY2UgfSBmcm9tICcuL21hcnF1ZWUtd2l6YXJkLnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LW1hcnF1ZWUtd2l6YXJkLXN0ZXAnLFxuICAgIHRlbXBsYXRlOiBgPG5nLWNvbnRhaW5lciAqbmdJZj1cImFjdGl2ZVwiPlxuICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbjwvbmctY29udGFpbmVyPmBcbn0pXG5leHBvcnQgY2xhc3MgTWFycXVlZVdpemFyZFN0ZXBDb21wb25lbnQgZXh0ZW5kcyBXaXphcmRTdGVwQ29tcG9uZW50IHtcblxuICAgIEBJbnB1dCgpIGljb246IHN0cmluZztcbiAgICBASW5wdXQoKSBjb21wbGV0ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBAT3V0cHV0KCkgY29tcGxldGVkQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuICAgIFxuICAgIGdldCB2YWxpZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbGlkO1xuICAgIH1cblxuICAgIHNldCB2YWxpZCh2YWxpZDogYm9vbGVhbikge1xuICAgICAgICB0aGlzLl92YWxpZCA9IHZhbGlkO1xuXG4gICAgICAgIGlmICh0aGlzLl9tYXJxdWVlV2l6YXJkU2VydmljZSkge1xuICAgICAgICAgICAgdGhpcy5fbWFycXVlZVdpemFyZFNlcnZpY2UudmFsaWQkLm5leHQoeyBzdGVwOiB0aGlzLCB2YWxpZDogdmFsaWQgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIF92YWxpZDogYm9vbGVhbiA9IHRydWU7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9tYXJxdWVlV2l6YXJkU2VydmljZTogTWFycXVlZVdpemFyZFNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIGNvbXBsZXRlZCBzdGF0ZSBhbmQgZW1pdCB0aGUgbGF0ZXN0IHZhbHVlXG4gICAgICogQHBhcmFtIGNvbXBsZXRlZCB3aGV0aGVyIG9yIG5vdCB0aGUgc3RlcCBpcyBjb21wbGV0ZWRcbiAgICAgKi9cbiAgICBzZXRDb21wbGV0ZWQoY29tcGxldGVkOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIHRoaXMuY29tcGxldGVkID0gY29tcGxldGVkO1xuICAgICAgICB0aGlzLmNvbXBsZXRlZENoYW5nZS5lbWl0KGNvbXBsZXRlZCk7XG4gICAgfVxufSIsImltcG9ydCB7IENvbXBvbmVudCwgQ29udGVudENoaWxkcmVuLCBJbnB1dCwgUXVlcnlMaXN0LCBUZW1wbGF0ZVJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgZmlsdGVyIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgV2l6YXJkQ29tcG9uZW50IH0gZnJvbSAnLi4vd2l6YXJkL2luZGV4JztcbmltcG9ydCB7IE1hcnF1ZWVXaXphcmRTdGVwQ29tcG9uZW50IH0gZnJvbSAnLi9tYXJxdWVlLXdpemFyZC1zdGVwLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBNYXJxdWVlV2l6YXJkU2VydmljZSwgTWFycXVlZVdpemFyZFZhbGlkRXZlbnQgfSBmcm9tICcuL21hcnF1ZWUtd2l6YXJkLnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LW1hcnF1ZWUtd2l6YXJkJyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJtYXJxdWVlLXdpemFyZC1zaWRlLXBhbmVsXCI+XG5cbiAgICA8ZGl2IGNsYXNzPVwibWFycXVlZS13aXphcmQtZGVzY3JpcHRpb24tY29udGFpbmVyXCIgKm5nSWY9XCJkZXNjcmlwdGlvblwiPlxuICAgICAgICA8IS0tIElmIGEgdGVtcGxhdGUgd2FzIHByb3ZpZGVkIGRpc3BsYXkgaXQgLS0+XG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJpc1RlbXBsYXRlXCIgW25nVGVtcGxhdGVPdXRsZXRdPVwiZGVzY3JpcHRpb25cIj48L25nLWNvbnRhaW5lcj5cblxuICAgICAgICA8IS0tIE90aGVyd2lzZSB3aW1wbHkgZGlzcGxheSB0aGUgc3RyaW5nIC0tPlxuICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiIWlzVGVtcGxhdGVcIj5cbiAgICAgICAgICAgIDxwPnt7IGRlc2NyaXB0aW9uIH19PC9wPlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICA8L2Rpdj5cblxuICAgIDx1bCBjbGFzcz1cIm1hcnF1ZWUtd2l6YXJkLXN0ZXBzXCI+XG5cbiAgICAgICAgPGxpIGNsYXNzPVwibWFycXVlZS13aXphcmQtc3RlcFwiICpuZ0Zvcj1cImxldCBzdGVwIG9mIHN0ZXBzXCIgKGNsaWNrKT1cImdvdG9TdGVwKHN0ZXApXCIgW2NsYXNzLmFjdGl2ZV09XCJzdGVwLmFjdGl2ZVwiIFtjbGFzcy52aXNpdGVkXT1cInN0ZXAudmlzaXRlZFwiIFtjbGFzcy5pbnZhbGlkXT1cIiFzdGVwLnZhbGlkXCI+XG4gICAgICAgICAgICA8aSBjbGFzcz1cIm1hcnF1ZWUtd2l6YXJkLXN0ZXAtaWNvblwiIFtuZ0NsYXNzXT1cInN0ZXAuaWNvblwiPjwvaT5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwibWFycXVlZS13aXphcmQtc3RlcC10aXRsZVwiPnt7IHN0ZXAuaGVhZGVyIH19PC9zcGFuPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJtYXJxdWVlLXdpemFyZC1zdGVwLXN0YXR1cyBocGUtaWNvbiBocGUtY2hlY2ttYXJrXCIgKm5nSWY9XCJzdGVwLmNvbXBsZXRlZFwiPjwvc3Bhbj5cbiAgICAgICAgPC9saT5cblxuICAgIDwvdWw+XG48L2Rpdj5cblxuPGRpdiBjbGFzcz1cIm1hcnF1ZWUtd2l6YXJkLWNvbnRlbnQtcGFuZWxcIj5cbiAgICA8ZGl2IGNsYXNzPVwibWFycXVlZS13aXphcmQtY29udGVudFwiPlxuICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwibW9kYWwtZm9vdGVyXCI+XG5cbiAgICAgICAgPGJ1dHRvbiAjdGlwPVwidXgtdG9vbHRpcFwiIGNsYXNzPVwiYnRuIGJ1dHRvbi1zZWNvbmRhcnlcIiAqbmdJZj1cInByZXZpb3VzVmlzaWJsZVwiIFt1eFRvb2x0aXBdPVwicHJldmlvdXNUb29sdGlwXCIgY29udGFpbmVyPVwiYm9keVwiXG4gICAgICAgICAgICBbZGlzYWJsZWRdPVwicHJldmlvdXNEaXNhYmxlZCB8fCBzdGVwID09PSAwXCIgKGNsaWNrKT1cInByZXZpb3VzKCk7IHRpcC5oaWRlKClcIj57eyBwcmV2aW91c1RleHQgfX08L2J1dHRvbj5cblxuICAgICAgICA8YnV0dG9uICN0aXA9XCJ1eC10b29sdGlwXCIgY2xhc3M9XCJidG4gYnV0dG9uLXByaW1hcnlcIiAqbmdJZj1cIm5leHRWaXNpYmxlICYmICFpc0xhc3RTdGVwKClcIiBbdXhUb29sdGlwXT1cIm5leHRUb29sdGlwXCIgY29udGFpbmVyPVwiYm9keVwiXG4gICAgICAgICAgICBbZGlzYWJsZWRdPVwibmV4dERpc2FibGVkXCIgKGNsaWNrKT1cIm5leHQoKTsgdGlwLmhpZGUoKVwiPnt7IG5leHRUZXh0IH19PC9idXR0b24+XG5cbiAgICAgICAgPGJ1dHRvbiAjdGlwPVwidXgtdG9vbHRpcFwiIGNsYXNzPVwiYnRuIGJ1dHRvbi1wcmltYXJ5XCIgKm5nSWY9XCJmaW5pc2hWaXNpYmxlICYmIGlzTGFzdFN0ZXAoKSB8fCBmaW5pc2hBbHdheXNWaXNpYmxlXCIgW3V4VG9vbHRpcF09XCJmaW5pc2hUb29sdGlwXCJcbiAgICAgICAgICAgIGNvbnRhaW5lcj1cImJvZHlcIiBbZGlzYWJsZWRdPVwiZmluaXNoRGlzYWJsZWRcIiAoY2xpY2spPVwiZmluaXNoKCk7IHRpcC5oaWRlKClcIj57eyBmaW5pc2hUZXh0IH19PC9idXR0b24+XG5cbiAgICAgICAgPGJ1dHRvbiAjdGlwPVwidXgtdG9vbHRpcFwiIGNsYXNzPVwiYnRuIGJ1dHRvbi1zZWNvbmRhcnlcIiAqbmdJZj1cImNhbmNlbFZpc2libGUgJiYgIWlzTGFzdFN0ZXAoKSB8fCBjYW5jZWxBbHdheXNWaXNpYmxlXCIgW3V4VG9vbHRpcF09XCJjYW5jZWxUb29sdGlwXCJcbiAgICAgICAgICAgIGNvbnRhaW5lcj1cImJvZHlcIiBbZGlzYWJsZWRdPVwiY2FuY2VsRGlzYWJsZWRcIiAoY2xpY2spPVwiY2FuY2VsKCk7IHRpcC5oaWRlKClcIj57eyBjYW5jZWxUZXh0IH19PC9idXR0b24+XG4gICAgPC9kaXY+XG48L2Rpdj5gLFxuICAgIHByb3ZpZGVyczogWyBNYXJxdWVlV2l6YXJkU2VydmljZSBdXG59KVxuZXhwb3J0IGNsYXNzIE1hcnF1ZWVXaXphcmRDb21wb25lbnQgZXh0ZW5kcyBXaXphcmRDb21wb25lbnQge1xuXG4gICAgQElucHV0KCkgZGVzY3JpcHRpb246IHN0cmluZyB8IFRlbXBsYXRlUmVmPGFueT47XG4gICAgQENvbnRlbnRDaGlsZHJlbihNYXJxdWVlV2l6YXJkU3RlcENvbXBvbmVudCkgc3RlcHMgPSBuZXcgUXVlcnlMaXN0PE1hcnF1ZWVXaXphcmRTdGVwQ29tcG9uZW50PigpO1xuXG4gICAgZ2V0IGlzVGVtcGxhdGUoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlc2NyaXB0aW9uICYmIHRoaXMuZGVzY3JpcHRpb24gaW5zdGFuY2VvZiBUZW1wbGF0ZVJlZjtcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3RvcihtYXJxdWVlV2l6YXJkU2VydmljZTogTWFycXVlZVdpemFyZFNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICBtYXJxdWVlV2l6YXJkU2VydmljZS52YWxpZCQucGlwZShcbiAgICAgICAgICAgIGZpbHRlcigoZXZlbnQ6IE1hcnF1ZWVXaXphcmRWYWxpZEV2ZW50KSA9PiAhZXZlbnQudmFsaWQpXG4gICAgICAgICkuc3Vic2NyaWJlKHRoaXMudmFsaWRDaGFuZ2UuYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSWYgdGhlIGN1cnJlbnQgc3RlcCBpcyB2YWxpZCwgbWFyayBpdCBhc1xuICAgICAqIGNvbXBsZXRlIGFuZCBnbyB0byB0aGUgbmV4dCBzdGVwXG4gICAgICovXG4gICAgbmV4dCgpOiB2b2lkIHtcblxuICAgICAgICAvLyBnZXQgdGhlIGN1cnJlbnQgc3RlcFxuICAgICAgICBjb25zdCBzdGVwID0gdGhpcy5nZXRDdXJyZW50U3RlcCgpIGFzIE1hcnF1ZWVXaXphcmRTdGVwQ29tcG9uZW50O1xuXG4gICAgICAgIGlmIChzdGVwLnZhbGlkKSB7XG4gICAgICAgICAgICBzdXBlci5uZXh0KCk7XG5cbiAgICAgICAgICAgIC8vIG1hcmsgdGhpcyBzdGVwIGFzIGNvbXBsZXRlZFxuICAgICAgICAgICAgc3RlcC5zZXRDb21wbGV0ZWQodHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbWl0IHRoZSBvbkZpbmlzaGluZyBldmVudCBhbmQgaWYgdmFsaWQgdGhlIG9uRmluaXNoIGV2ZW50LlxuICAgICAqIEFsc28gbWFyayB0aGUgZmluYWwgc3RlcCBhcyBjb21wbGV0ZWQgaWYgaXQgaXMgdmFsaWRcbiAgICAgKi9cbiAgICBmaW5pc2goKTogUHJvbWlzZTx2b2lkPiB7XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBjdXJyZW50IHN0ZXBcbiAgICAgICAgY29uc3Qgc3RlcCA9IHRoaXMuZ2V0Q3VycmVudFN0ZXAoKSBhcyBNYXJxdWVlV2l6YXJkU3RlcENvbXBvbmVudDtcblxuICAgICAgICAvLyBjYWxsIHRoZSBvcmlnaW5hbCBmaW5pc2ggZnVuY3Rpb25cbiAgICAgICAgcmV0dXJuIHN1cGVyLmZpbmlzaCgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgLy8gaWYgdGhlIHN0ZXAgaXMgdmFsaWQgaW5kaWNhdGUgdGhhdCBpdCBpcyBub3cgY29tcGxldGVcbiAgICAgICAgICAgIGlmIChzdGVwLnZhbGlkKSB7XG4gICAgICAgICAgICAgICAgc3RlcC5zZXRDb21wbGV0ZWQodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIGEgc3RlcCBpbiB0aGUgd2l6YXJkIGJlY29tZXMgaW52YWxpZCwgYWxsIHN0ZXBzIHNlcXVlbnRpYWxseSBhZnRlclxuICAgICAqIGl0LCBzaG91bGQgYmVjb21lIHVudmlzaXRlZCBhbmQgaW5jb21wbGV0ZVxuICAgICAqL1xuICAgIHZhbGlkQ2hhbmdlKHN0YXRlOiBNYXJxdWVlV2l6YXJkVmFsaWRFdmVudCk6IHZvaWQge1xuXG4gICAgICAgIGNvbnN0IHN0ZXBzID0gdGhpcy5zdGVwcy50b0FycmF5KCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSBzdGVwcy5maW5kSW5kZXgoc3RlcCA9PiBzdGVwID09PSBzdGF0ZS5zdGVwKTtcbiAgICAgICAgY29uc3QgYWZmZWN0ZWQgPSBzdGVwcy5zbGljZShjdXJyZW50KTtcblxuICAgICAgICBhZmZlY3RlZC5mb3JFYWNoKHN0ZXAgPT4ge1xuXG4gICAgICAgICAgICAvLyB0aGUgc3RlcCBzaG91bGQgbm8gbG9uZ2VyIGJlIGNvbXBsZXRlZFxuICAgICAgICAgICAgc3RlcC5jb21wbGV0ZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgLy8gaWYgdGhlIHN0ZXAgaXMgbm90IHRoZSBjdXJyZW50IHN0ZXAgdGhlbiBhbHNvIG1hcmsgaXQgYXMgdW52aXNpdGVkXG4gICAgICAgICAgICBpZiAoc3RlcCAhPT0gc3RhdGUuc3RlcCkge1xuICAgICAgICAgICAgICAgIHN0ZXAudmlzaXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgIH1cbn0iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcblxuaW1wb3J0IHsgV2l6YXJkTW9kdWxlIH0gZnJvbSAnLi4vd2l6YXJkL2luZGV4JztcbmltcG9ydCB7IE1hcnF1ZWVXaXphcmRDb21wb25lbnQgfSBmcm9tICcuL21hcnF1ZWUtd2l6YXJkLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBNYXJxdWVlV2l6YXJkU3RlcENvbXBvbmVudCB9IGZyb20gJy4vbWFycXVlZS13aXphcmQtc3RlcC5jb21wb25lbnQnO1xuaW1wb3J0IHsgVG9vbHRpcE1vZHVsZSB9IGZyb20gJy4uL3Rvb2x0aXAvaW5kZXgnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBXaXphcmRNb2R1bGUsXG4gICAgICAgIFRvb2x0aXBNb2R1bGVcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgTWFycXVlZVdpemFyZENvbXBvbmVudCxcbiAgICAgICAgTWFycXVlZVdpemFyZFN0ZXBDb21wb25lbnRcbiAgICBdLFxuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBNYXJxdWVlV2l6YXJkQ29tcG9uZW50LFxuICAgICAgICBNYXJxdWVlV2l6YXJkU3RlcENvbXBvbmVudFxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgTWFycXVlZVdpemFyZE1vZHVsZSB7IH1cbiIsImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEh0dHAsIFJlc3BvbnNlQ29udGVudFR5cGUgfSBmcm9tICdAYW5ndWxhci9odHRwJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzL09ic2VydmFibGUnO1xuaW1wb3J0IHsgb2YgfSBmcm9tICdyeGpzL29ic2VydmFibGUvb2YnO1xuaW1wb3J0IHsgT2JzZXJ2ZXIgfSBmcm9tICdyeGpzL09ic2VydmVyJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEF1ZGlvU2VydmljZSB7XG5cbiAgICBwcml2YXRlIF9hdWRpb0J1ZmZlcjogQXVkaW9CdWZmZXI7XG4gICAgcHJpdmF0ZSBfYXVkaW9CdWZmZXJTb3VyY2U6IEF1ZGlvQnVmZmVyU291cmNlTm9kZTtcbiAgICBwcml2YXRlIF9hdWRpb0NvbnRleHQ6IEF1ZGlvQ29udGV4dDtcbiAgICBwcml2YXRlIF9nYWluTm9kZTogR2Fpbk5vZGU7XG4gICAgcHJpdmF0ZSBfYW5hbHlzZXJOb2RlOiBBbmFseXNlck5vZGU7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9odHRwOiBIdHRwKSB7IH1cblxuICAgIGdldEF1ZGlvRmlsZU1ldGFkYXRhKG1lZGlhRWxlbWVudDogSFRNTE1lZGlhRWxlbWVudCk6IE9ic2VydmFibGU8QXVkaW9NZXRhZGF0YT4ge1xuICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZS5jcmVhdGUoKG9ic2VydmVyOiBPYnNlcnZlcjxBdWRpb01ldGFkYXRhPikgPT4ge1xuICAgICAgICAgICAgdGhpcy5faHR0cC5yZXF1ZXN0KG1lZGlhRWxlbWVudC5zcmMsIHsgcmVzcG9uc2VUeXBlOiBSZXNwb25zZUNvbnRlbnRUeXBlLkJsb2IgfSkuc3Vic2NyaWJlKHJlc3BvbnNlID0+IHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVuYW1lID0gbWVkaWFFbGVtZW50LnNyYy5zdWJzdHJpbmcobWVkaWFFbGVtZW50LnNyYy5sYXN0SW5kZXhPZignLycpICsgMSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZXh0ZW5zaW9uID0gbWVkaWFFbGVtZW50LnNyYy5zdWJzdHJpbmcobWVkaWFFbGVtZW50LnNyYy5sYXN0SW5kZXhPZignLicpICsgMSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBibG9iID0gcmVzcG9uc2UuYmxvYigpO1xuICAgICAgICAgICAgICAgIGxldCBkZXNjcmlwdGlvbjtcblxuICAgICAgICAgICAgICAgIHN3aXRjaCAoZXh0ZW5zaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21wMyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbiA9ICdNUEVHIGF1ZGlvIGxheWVyIDMgZmlsZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICd3bWEnOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb24gPSAnV2luZG93cyBtZWRpYSBhdWRpbyBmaWxlJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3dhdic6XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbiA9ICdXQVZFIGF1ZGlvIGZpbGUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnb2dnJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uID0gJ09nZyBWb3JiaXMgZmlsZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdhYWMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb24gPSAnQWR2YW5jZWQgYXVkaW8gY29kaW5nIGZpbGUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWlkaSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbiA9ICdNdXNpY2FsIGluc3RydW1lbnQgZGlnaXRhbCBpbnRlcmZhY2UgZmlsZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb24gPSAnQXVkaW8gZmlsZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KHtcbiAgICAgICAgICAgICAgICAgICAgZmlsZW5hbWU6IGZpbGVuYW1lLFxuICAgICAgICAgICAgICAgICAgICBleHRlbnNpb246IGV4dGVuc2lvbixcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgICAgICBzaXplOiBibG9iLnNpemVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBnZXRXYXZlZm9ybUZyb21VcmwodXJsOiBzdHJpbmcpOiBPYnNlcnZhYmxlPEZsb2F0MzJBcnJheVtdPiB7XG5cbiAgICAgICAgLy8gaWYgYXVkaW8gY29udGV4dCBpcyBub3Qgc3VwcG9ydCByZXR1cm4gYSBzdHJlYW0gb2YgZW1wdHkgZGF0YVxuICAgICAgICBpZiAoISg8YW55PndpbmRvdykuQXVkaW9Db250ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gb2Y8RmxvYXQzMkFycmF5W10+KFtuZXcgRmxvYXQzMkFycmF5KDApXSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9hdWRpb0NvbnRleHQgPSBuZXcgQXVkaW9Db250ZXh0KCk7XG4gICAgICAgIHRoaXMuY3JlYXRlVm9sdW1lTm9kZSgpO1xuICAgICAgICB0aGlzLmNyZWF0ZUFuYWx5c2VyTm9kZSgpO1xuXG4gICAgICAgIHJldHVybiBPYnNlcnZhYmxlLmNyZWF0ZSgob2JzZXJ2ZXI6IE9ic2VydmVyPEZsb2F0MzJBcnJheVtdPikgPT4ge1xuXG4gICAgICAgICAgICAvLyBsb2FkIHRoZSBtZWRpYSBmcm9tIHRoZSBVUkwgcHJvdmlkZWRcbiAgICAgICAgICAgIHRoaXMuX2h0dHAucmVxdWVzdCh1cmwsIHsgcmVzcG9uc2VUeXBlOiBSZXNwb25zZUNvbnRlbnRUeXBlLkFycmF5QnVmZmVyIH0pLnN1YnNjcmliZShyZXNwb25zZSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRBdWRpb0J1ZmZlcihyZXNwb25zZS5hcnJheUJ1ZmZlcigpKS5zdWJzY3JpYmUoYXVkaW9CdWZmZXIgPT4ge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSB0aGUgYnVmZmVyIHNvdXJjZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUJ1ZmZlclNvdXJjZShhdWRpb0J1ZmZlcik7XG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IGRhdGFQb2ludHM6IEZsb2F0MzJBcnJheVtdID0gW107XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5uZWxzID0gdGhpcy5fYXVkaW9CdWZmZXIubnVtYmVyT2ZDaGFubmVscztcblxuICAgICAgICAgICAgICAgICAgICAvLyBleHRyYWN0IHRoZSBkYXRhIGZyb20gZWFjaCBjaGFubmVsXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGNoYW5uZWxJZHggPSAwOyBjaGFubmVsSWR4IDwgY2hhbm5lbHM7IGNoYW5uZWxJZHgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVBvaW50c1tjaGFubmVsSWR4XSA9IHRoaXMuX2F1ZGlvQnVmZmVyLmdldENoYW5uZWxEYXRhKGNoYW5uZWxJZHgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dChkYXRhUG9pbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBjbGVhbnVwIGFmdGVyIG91cnNlbHZlc1xuICAgICAgICAgICAgICAgICAgICBkYXRhUG9pbnRzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9LCAoZXJyb3IpID0+IG9ic2VydmVyLmVycm9yKGVycm9yKSk7XG4gICAgICAgICAgICB9LCAoZXJyb3IpID0+IG9ic2VydmVyLmVycm9yKGVycm9yKSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGdldFdhdmVmb3JtUG9pbnRzKGNoYW5uZWxzOiBGbG9hdDMyQXJyYXlbXSA9IFtdLCBza2lwOiBudW1iZXIgPSAxMDAwKTogV2F2ZWZvcm1Qb2ludFtdIHtcblxuICAgICAgICBjb25zdCB3YXZlZm9ybTogV2F2ZWZvcm1Qb2ludFtdID0gW107XG4gICAgICAgIGNvbnN0IGR1cmF0aW9uID0gY2hhbm5lbHMubGVuZ3RoID4gMCA/IGNoYW5uZWxzWzBdLmxlbmd0aCA6IDA7XG5cbiAgICAgICAgLy8gY29udmVydCBlYWNoIGNoYW5uZWwgZGF0YSB0byBhIHNlcmllcyBvZiB3YXZlZm9ybSBwb2ludHNcbiAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgZHVyYXRpb247IGlkeCArPSBza2lwKSB7XG5cbiAgICAgICAgICAgIC8vIGdldCBhbGwgdGhlIGNoYW5uZWwgZGF0YSBmb3IgYSBzcGVjaWZpYyBwb2ludFxuICAgICAgICAgICAgY29uc3QgcG9pbnRzID0gY2hhbm5lbHMubWFwKGNoYW5uZWwgPT4gY2hhbm5lbFtpZHhdKTtcblxuICAgICAgICAgICAgLy8gZmluZCB0aGUgbWluaW11bSBwb2ludCBhbmQgbWF4aW11bSBwb2ludHMgYXQgZWFjaCBwb3NpdGlvbiBhY3Jvc3MgYWxsIGNoYW5uZWxzXG4gICAgICAgICAgICB3YXZlZm9ybS5wdXNoKHtcbiAgICAgICAgICAgICAgICBtaW46IHBvaW50cy5yZWR1Y2UoKHByZXZpb3VzLCBjdXJyZW50KSA9PiBjdXJyZW50IDwgcHJldmlvdXMgPyBjdXJyZW50IDogcHJldmlvdXMpLFxuICAgICAgICAgICAgICAgIG1heDogcG9pbnRzLnJlZHVjZSgocHJldmlvdXMsIGN1cnJlbnQpID0+IGN1cnJlbnQgPiBwcmV2aW91cyA/IGN1cnJlbnQgOiBwcmV2aW91cylcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHdhdmVmb3JtO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0QXVkaW9CdWZmZXIoYXJyYXlCdWZmZXI6IEFycmF5QnVmZmVyKTogT2JzZXJ2YWJsZTxBdWRpb0J1ZmZlcj4ge1xuICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZS5jcmVhdGUoKG9ic2VydmVyOiBPYnNlcnZlcjxBdWRpb0J1ZmZlcj4pID0+IHtcbiAgICAgICAgICAgIHRoaXMuZ2V0T2ZmbGluZUF1ZGlvQ29udGV4dCgpLmRlY29kZUF1ZGlvRGF0YShhcnJheUJ1ZmZlciwgKGF1ZGlvQnVmZmVyOiBBdWRpb0J1ZmZlcikgPT4ge1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLm5leHQoYXVkaW9CdWZmZXIpO1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICB9LCAoZXJyb3IpID0+IG9ic2VydmVyLmVycm9yKGVycm9yKSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0T2ZmbGluZUF1ZGlvQ29udGV4dCgpOiBPZmZsaW5lQXVkaW9Db250ZXh0IHtcbiAgICAgICAgcmV0dXJuIG5ldyBPZmZsaW5lQXVkaW9Db250ZXh0KDEsIDIsIHRoaXMuX2F1ZGlvQ29udGV4dC5zYW1wbGVSYXRlIHx8IDQ0MTAwKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGNyZWF0ZUJ1ZmZlclNvdXJjZShhdWRpb0J1ZmZlcjogQXVkaW9CdWZmZXIpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0U291cmNlKCk7XG5cbiAgICAgICAgdGhpcy5fYXVkaW9CdWZmZXIgPSBhdWRpb0J1ZmZlcjtcbiAgICAgICAgdGhpcy5fYXVkaW9CdWZmZXJTb3VyY2UgPSB0aGlzLl9hdWRpb0NvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XG4gICAgICAgIHRoaXMuX2F1ZGlvQnVmZmVyU291cmNlLmJ1ZmZlciA9IHRoaXMuX2F1ZGlvQnVmZmVyO1xuICAgICAgICB0aGlzLl9hdWRpb0J1ZmZlclNvdXJjZS5jb25uZWN0KHRoaXMuX2FuYWx5c2VyTm9kZSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmVhdGVWb2x1bWVOb2RlKCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9nYWluTm9kZSA9IHRoaXMuX2F1ZGlvQ29udGV4dC5jcmVhdGVHYWluKCk7XG4gICAgICAgIHRoaXMuX2dhaW5Ob2RlLmNvbm5lY3QodGhpcy5fYXVkaW9Db250ZXh0LmRlc3RpbmF0aW9uKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGNyZWF0ZUFuYWx5c2VyTm9kZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fYW5hbHlzZXJOb2RlID0gdGhpcy5fYXVkaW9Db250ZXh0LmNyZWF0ZUFuYWx5c2VyKCk7XG4gICAgICAgIHRoaXMuX2FuYWx5c2VyTm9kZS5jb25uZWN0KHRoaXMuX2dhaW5Ob2RlKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGRpc2Nvbm5lY3RTb3VyY2UoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLl9hdWRpb0J1ZmZlclNvdXJjZSkge1xuICAgICAgICAgICAgdGhpcy5fYXVkaW9CdWZmZXJTb3VyY2UuZGlzY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFdhdmVmb3JtUG9pbnQge1xuICAgIG1pbjogbnVtYmVyO1xuICAgIG1heDogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEF1ZGlvTWV0YWRhdGEge1xuICAgIGZpbGVuYW1lOiBzdHJpbmc7XG4gICAgZXh0ZW5zaW9uOiBzdHJpbmc7XG4gICAgZGVzY3JpcHRpb246IHN0cmluZztcbiAgICBzaXplOiBudW1iZXI7XG59IiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEh0dHBNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9odHRwJztcbmltcG9ydCB7IEF1ZGlvU2VydmljZSB9IGZyb20gJy4vYXVkaW8uc2VydmljZSc7XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogWyBIdHRwTW9kdWxlIF0sXG4gICAgcHJvdmlkZXJzOiBbQXVkaW9TZXJ2aWNlXVxufSlcbmV4cG9ydCBjbGFzcyBBdWRpb1NlcnZpY2VNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcy9PYnNlcnZhYmxlJztcbmltcG9ydCB7IGNvbmNhdCB9IGZyb20gJ3J4anMvb2JzZXJ2YWJsZS9jb25jYXQnO1xuaW1wb3J0IHsgZnJvbUV2ZW50IH0gZnJvbSAncnhqcy9vYnNlcnZhYmxlL2Zyb21FdmVudCc7XG5pbXBvcnQgeyBPYnNlcnZlciB9IGZyb20gJ3J4anMvT2JzZXJ2ZXInO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgRnJhbWVFeHRyYWN0aW9uU2VydmljZSB7XG5cbiAgICBwcml2YXRlIGNyZWF0ZVZpZGVvUGxheWVyKHNvdXJjZTogc3RyaW5nKTogSFRNTFZpZGVvRWxlbWVudCB7XG4gICAgICAgIGxldCB2aWRlb1BsYXllciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XG4gICAgICAgIHZpZGVvUGxheWVyLnByZWxvYWQgPSAnYXV0byc7XG4gICAgICAgIHZpZGVvUGxheWVyLnNyYyA9IHNvdXJjZTtcbiAgICAgICAgcmV0dXJuIHZpZGVvUGxheWVyO1xuICAgIH1cblxuICAgIHByaXZhdGUgY3JlYXRlQ2FudmFzKHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKTogSFRNTENhbnZhc0VsZW1lbnQge1xuICAgICAgICBsZXQgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICByZXR1cm4gY2FudmFzO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ29Ub0ZyYW1lKHZpZGVvUGxheWVyOiBIVE1MVmlkZW9FbGVtZW50LCB0aW1lOiBudW1iZXIpOiBPYnNlcnZhYmxlPG51bWJlcj4ge1xuICAgICAgICB2aWRlb1BsYXllci5jdXJyZW50VGltZSA9IHRpbWU7XG4gICAgICAgIHJldHVybiBmcm9tRXZlbnQodmlkZW9QbGF5ZXIsIHRpbWUgPT09IDAgPyAnbG9hZGVkZGF0YScgOiAnc2Vla2VkJyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRUaHVtYm5haWwodmlkZW9QbGF5ZXI6IEhUTUxWaWRlb0VsZW1lbnQsIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsIHRpbWU6IG51bWJlciwgd2lkdGg6IG51bWJlciA9IDE2MCwgaGVpZ2h0OiBudW1iZXIgPSA5MCk6IE9ic2VydmFibGU8RXh0cmFjdGVkRnJhbWU+IHtcblxuICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZS5jcmVhdGUoKG9ic2VydmVyOiBPYnNlcnZlcjxFeHRyYWN0ZWRGcmFtZT4pID0+IHtcblxuICAgICAgICAgICAgLy8gZ28gdG8gc3BlY2lmaWVkIGZyYW1lXG4gICAgICAgICAgICBsZXQgc3Vic2NyaXB0aW9uID0gdGhpcy5nb1RvRnJhbWUodmlkZW9QbGF5ZXIsIHRpbWUpLnN1YnNjcmliZSgoZXZlbnQ6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBpbWFnZSBmcm9tIGN1cnJlbnQgZnJhbWVcbiAgICAgICAgICAgICAgICBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5kcmF3SW1hZ2UodmlkZW9QbGF5ZXIsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLm5leHQoeyBpbWFnZTogY2FudmFzLnRvRGF0YVVSTCgpLCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0LCB0aW1lOiB0aW1lIH0pO1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZ2V0RnJhbWVUaHVtYm5haWwoc291cmNlOiBzdHJpbmcsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyLCB0aW1lOiBudW1iZXIpOiBPYnNlcnZhYmxlPEV4dHJhY3RlZEZyYW1lPiB7XG5cbiAgICAgICAgLy8gY3JlYXRlIHJlcXVpcmVkIGVsZW1lbnRzXG4gICAgICAgIGxldCB2aWRlb1BsYXllciA9IHRoaXMuY3JlYXRlVmlkZW9QbGF5ZXIoc291cmNlKTtcbiAgICAgICAgbGV0IGNhbnZhcyA9IHRoaXMuY3JlYXRlQ2FudmFzKHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAgIGxldCBmcmFtZVN1YnNjcmlwdGlvbiA9IHRoaXMuZ2V0VGh1bWJuYWlsKHZpZGVvUGxheWVyLCBjYW52YXMsIHRpbWUsIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAgIC8vIGVuc3VyZSB3ZSByZWxlYXNlIG1lbW9yeSBhZnRlciB3ZSBhcmUgZmluaXNoZWRcbiAgICAgICAgZnJhbWVTdWJzY3JpcHRpb24uc3Vic2NyaWJlKG51bGwsIG51bGwsICgpID0+IHtcbiAgICAgICAgICAgIHZpZGVvUGxheWVyID0gbnVsbDtcbiAgICAgICAgICAgIGNhbnZhcyA9IG51bGw7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBmcmFtZVN1YnNjcmlwdGlvbjtcbiAgICB9XG5cbiAgICBnZXRGcmFtZVRodW1ibmFpbHMoc291cmNlOiBzdHJpbmcsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyLCBzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlciwgc2tpcDogbnVtYmVyID0gNSk6IE9ic2VydmFibGU8RXh0cmFjdGVkRnJhbWU+IHtcblxuICAgICAgICAvLyBjcmVhdGUgcmVxdWlyZWQgZWxlbWVudHNcbiAgICAgICAgbGV0IHZpZGVvUGxheWVyID0gdGhpcy5jcmVhdGVWaWRlb1BsYXllcihzb3VyY2UpO1xuICAgICAgICBsZXQgY2FudmFzID0gdGhpcy5jcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCk7XG5cbiAgICAgICAgcmV0dXJuIE9ic2VydmFibGUuY3JlYXRlKChvYnNlcnZlcjogT2JzZXJ2ZXI8RXh0cmFjdGVkRnJhbWU+KSA9PiB7XG5cbiAgICAgICAgICAgIGZyb21FdmVudCh2aWRlb1BsYXllciwgJ2xvYWRlZG1ldGFkYXRhJykuc3Vic2NyaWJlKCgpID0+IHtcblxuICAgICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgZnJhbWVzIHJlcXVpcmVkXG4gICAgICAgICAgICAgICAgbGV0IGZyYW1lcyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaWR4ID0gc3RhcnQ7IGlkeCA8IGVuZDsgaWR4ICs9IHNraXApIHtcbiAgICAgICAgICAgICAgICAgICAgZnJhbWVzLnB1c2godGhpcy5nZXRUaHVtYm5haWwodmlkZW9QbGF5ZXIsIGNhbnZhcywgaWR4LCB3aWR0aCwgaGVpZ2h0KSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uY2F0KC4uLmZyYW1lcykuc3Vic2NyaWJlKChmcmFtZTogRXh0cmFjdGVkRnJhbWUpID0+IG9ic2VydmVyLm5leHQoZnJhbWUpLCBudWxsLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZpZGVvUGxheWVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0pO1xuICAgIH1cblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEV4dHJhY3RlZEZyYW1lIHtcbiAgICBpbWFnZTogc3RyaW5nO1xuICAgIHdpZHRoOiBudW1iZXI7XG4gICAgaGVpZ2h0OiBudW1iZXI7XG4gICAgdGltZTogbnVtYmVyO1xufSIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IEZyYW1lRXh0cmFjdGlvblNlcnZpY2UgfSBmcm9tICcuL2ZyYW1lLWV4dHJhY3Rpb24uc2VydmljZSc7XG5cbkBOZ01vZHVsZSh7XG4gICAgcHJvdmlkZXJzOiBbRnJhbWVFeHRyYWN0aW9uU2VydmljZV0sXG59KVxuZXhwb3J0IGNsYXNzIEZyYW1lRXh0cmFjdGlvbk1vZHVsZSB7IH1cbiIsImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzL09ic2VydmFibGUnO1xuaW1wb3J0IHsgZnJvbSB9IGZyb20gJ3J4anMvb2JzZXJ2YWJsZS9mcm9tJztcbmltcG9ydCB7IE9ic2VydmVyIH0gZnJvbSAncnhqcy9PYnNlcnZlcic7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcbmltcG9ydCB7IEV4dHJhY3RlZEZyYW1lLCBGcmFtZUV4dHJhY3Rpb25TZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvZnJhbWUtZXh0cmFjdGlvbi9pbmRleCc7XG5pbXBvcnQgeyBNZWRpYVBsYXllclR5cGUgfSBmcm9tICcuL21lZGlhLXBsYXllci5jb21wb25lbnQnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgTWVkaWFQbGF5ZXJTZXJ2aWNlIHtcblxuICAgIHNvdXJjZTogc3RyaW5nO1xuICAgIHR5cGU6IE1lZGlhUGxheWVyVHlwZSA9ICd2aWRlbyc7XG4gICAgbG9hZGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKlxuICAgICAgICBDcmVhdGUgb2JzZXJ2YWJsZXMgZm9yIG1lZGlhIHBsYXllciBldmVudHNcbiAgICAqL1xuICAgIHBsYXlpbmc6IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPiA9IG5ldyBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4oZmFsc2UpO1xuICAgIGluaXRFdmVudDogQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+ID0gbmV3IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPihmYWxzZSk7XG4gICAgYWJvcnRFdmVudDogU3ViamVjdDx2b2lkPiA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG4gICAgY2FuUGxheUV2ZW50OiBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4gPSBuZXcgQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+KGZhbHNlKTtcbiAgICBjYW5QbGF5VGhyb3VnaEV2ZW50OiBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4gPSBuZXcgQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+KGZhbHNlKTtcbiAgICBkdXJhdGlvbkNoYW5nZUV2ZW50OiBTdWJqZWN0PG51bWJlcj4gPSBuZXcgU3ViamVjdDxudW1iZXI+KCk7XG4gICAgZW5kZWRFdmVudDogU3ViamVjdDx2b2lkPiA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG4gICAgZXJyb3JFdmVudDogU3ViamVjdDxhbnk+ID0gbmV3IFN1YmplY3Q8YW55PigpO1xuICAgIGxvYWRlZERhdGFFdmVudDogU3ViamVjdDxhbnk+ID0gbmV3IFN1YmplY3Q8YW55PigpO1xuICAgIGxvYWRlZE1ldGFkYXRhRXZlbnQ6IFN1YmplY3Q8YW55PiA9IG5ldyBTdWJqZWN0PGFueT4oKTtcbiAgICBsb2FkU3RhcnRFdmVudDogU3ViamVjdDx2b2lkPiA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG4gICAgcGF1c2VFdmVudDogU3ViamVjdDx2b2lkPiA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG4gICAgcGxheUV2ZW50OiBTdWJqZWN0PHZvaWQ+ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcbiAgICBwbGF5aW5nRXZlbnQ6IFN1YmplY3Q8Ym9vbGVhbj4gPSBuZXcgU3ViamVjdDxib29sZWFuPigpO1xuICAgIHJhdGVDaGFuZ2VFdmVudDogU3ViamVjdDxudW1iZXI+ID0gbmV3IFN1YmplY3Q8bnVtYmVyPigpO1xuICAgIHNlZWtlZEV2ZW50OiBTdWJqZWN0PG51bWJlcj4gPSBuZXcgU3ViamVjdDxudW1iZXI+KCk7XG4gICAgc2Vla2luZ0V2ZW50OiBTdWJqZWN0PG51bWJlcj4gPSBuZXcgU3ViamVjdDxudW1iZXI+KCk7XG4gICAgc3RhbGxlZEV2ZW50OiBTdWJqZWN0PHZvaWQ+ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcbiAgICBzdXNwZW5kRXZlbnQ6IFN1YmplY3Q8dm9pZD4gPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuICAgIHRpbWVVcGRhdGVFdmVudDogU3ViamVjdDxudW1iZXI+ID0gbmV3IFN1YmplY3Q8bnVtYmVyPigpO1xuICAgIHZvbHVtZUNoYW5nZUV2ZW50OiBTdWJqZWN0PG51bWJlcj4gPSBuZXcgU3ViamVjdDxudW1iZXI+KCk7XG4gICAgd2FpdGluZ0V2ZW50OiBTdWJqZWN0PHZvaWQ+ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcbiAgICBtZWRpYUNsaWNrRXZlbnQ6IFN1YmplY3Q8TW91c2VFdmVudD4gPSBuZXcgU3ViamVjdDxNb3VzZUV2ZW50PigpO1xuICAgIGZ1bGxzY3JlZW5FdmVudDogQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+ID0gbmV3IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPihmYWxzZSk7XG4gICAgcXVpZXRNb2RlRXZlbnQ6IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPiA9IG5ldyBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4oZmFsc2UpO1xuICAgIHByb2dyZXNzRXZlbnQ6IE9ic2VydmFibGU8VGltZVJhbmdlcz4gPSBPYnNlcnZhYmxlLmNyZWF0ZSgob2JzZXJ2ZXI6IE9ic2VydmVyPFRpbWVSYW5nZXM+KSA9PiB7XG5cbiAgICAgICAgLy8gcmVwZWF0IHVudGlsIHRoZSB3aG9sZSB2aWRlbyBoYXMgZnVsbHkgbG9hZGVkXG4gICAgICAgIGxldCBpbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcblxuICAgICAgICAgICAgbGV0IGJ1ZmZlcmVkID0gdGhpcy5fbWVkaWFQbGF5ZXIuYnVmZmVyZWQgYXMgVGltZVJhbmdlcztcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQoYnVmZmVyZWQpO1xuXG4gICAgICAgICAgICBpZiAoYnVmZmVyZWQubGVuZ3RoID09PSAxICYmIGJ1ZmZlcmVkLnN0YXJ0KDApID09PSAwICYmIGJ1ZmZlcmVkLmVuZCgwKSA9PT0gdGhpcy5kdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDEwMDApO1xuICAgIH0pO1xuXG4gICAgcHJpdmF0ZSBfbWVkaWFQbGF5ZXI6IEhUTUxNZWRpYUVsZW1lbnQ7XG4gICAgcHJpdmF0ZSBfaG9zdEVsZW1lbnQ6IEhUTUxFbGVtZW50O1xuICAgIHByaXZhdGUgX2Z1bGxzY3JlZW46IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBwcml2YXRlIF9xdWlldE1vZGU6IGJvb2xlYW47XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9mcmFtZUV4dHJhY3Rpb25TZXJ2aWNlOiBGcmFtZUV4dHJhY3Rpb25TZXJ2aWNlKSB7fVxuXG4gICAgLypcbiAgICAgICAgQ3JlYXRlIGFsbCB0aGUgZ2V0dGVycyBhbmQgc2V0dGVycyB0aGUgY2FuIGJlIHVzZWQgYnkgbWVkaWEgcGxheWVyIGV4dGVuc2lvbnNcbiAgICAqL1xuICAgIGdldCBtZWRpYVBsYXllcigpOiBIVE1MTWVkaWFFbGVtZW50IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhUGxheWVyO1xuICAgIH1cblxuICAgIGdldCBxdWlldE1vZGUoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9xdWlldE1vZGU7XG4gICAgfVxuXG4gICAgc2V0IHF1aWV0TW9kZSh2YWx1ZTogYm9vbGVhbikge1xuXG4gICAgICAgIC8vIHF1aWV0IG1vZGUgY2Fubm90IGJlIGVuYWJsZWQgb24gYXVkaW8gcGxheWVyXG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9xdWlldE1vZGUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5xdWlldE1vZGVFdmVudC5uZXh0KHZhbHVlKTtcbiAgICB9XG5cbiAgICBnZXQgbWVkaWFQbGF5ZXJXaWR0aCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVkaWFQbGF5ZXIgPyB0aGlzLl9tZWRpYVBsYXllci5vZmZzZXRXaWR0aCA6IDA7XG4gICAgfVxuXG4gICAgZ2V0IG1lZGlhUGxheWVySGVpZ2h0KCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZWRpYVBsYXllciA/IHRoaXMuX21lZGlhUGxheWVyLm9mZnNldEhlaWdodCA6IDA7XG4gICAgfVxuXG4gICAgZ2V0IGF1ZGlvVHJhY2tzKCk6IEF1ZGlvVHJhY2tMaXN0IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhUGxheWVyID8gdGhpcy5fbWVkaWFQbGF5ZXIuYXVkaW9UcmFja3MgOiBudWxsO1xuICAgIH1cblxuICAgIGdldCBhdXRvcGxheSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhUGxheWVyID8gdGhpcy5fbWVkaWFQbGF5ZXIuYXV0b3BsYXkgOiBmYWxzZTtcbiAgICB9XG4gICAgc2V0IGF1dG9wbGF5KHZhbHVlOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuX21lZGlhUGxheWVyLmF1dG9wbGF5ID0gdmFsdWU7XG4gICAgfVxuXG4gICAgZ2V0IGJ1ZmZlcmVkKCk6IFRpbWVSYW5nZXMge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVkaWFQbGF5ZXIgPyB0aGlzLl9tZWRpYVBsYXllci5idWZmZXJlZCA6IG5ldyBUaW1lUmFuZ2VzKCk7XG4gICAgfVxuXG4gICAgZ2V0IGNyb3NzT3JpZ2luKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZWRpYVBsYXllciA/IHRoaXMuX21lZGlhUGxheWVyLmNyb3NzT3JpZ2luIDogbnVsbDtcbiAgICB9XG4gICAgc2V0IGNyb3NzT3JpZ2luKHZhbHVlOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5fbWVkaWFQbGF5ZXIuY3Jvc3NPcmlnaW4gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBnZXQgY3VycmVudFNyYygpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVkaWFQbGF5ZXIgPyB0aGlzLl9tZWRpYVBsYXllci5jdXJyZW50U3JjIDogbnVsbDtcbiAgICB9XG5cbiAgICBnZXQgY3VycmVudFRpbWUoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhUGxheWVyID8gdGhpcy5fbWVkaWFQbGF5ZXIuY3VycmVudFRpbWUgOiAwO1xuICAgIH1cbiAgICBzZXQgY3VycmVudFRpbWUodmFsdWU6IG51bWJlcikge1xuICAgICAgICB0aGlzLl9tZWRpYVBsYXllci5jdXJyZW50VGltZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIGdldCBkZWZhdWx0TXV0ZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZWRpYVBsYXllciA/IHRoaXMuX21lZGlhUGxheWVyLmRlZmF1bHRNdXRlZCA6IGZhbHNlO1xuICAgIH1cbiAgICBzZXQgZGVmYXVsdE11dGVkKHZhbHVlOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuX21lZGlhUGxheWVyLmRlZmF1bHRNdXRlZCA9IHZhbHVlO1xuICAgIH1cblxuICAgIGdldCBkZWZhdWx0UGxheWJhY2tSYXRlKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZWRpYVBsYXllciA/IHRoaXMuX21lZGlhUGxheWVyLmRlZmF1bHRQbGF5YmFja1JhdGUgOiAxO1xuICAgIH1cbiAgICBzZXQgZGVmYXVsdFBsYXliYWNrUmF0ZSh2YWx1ZTogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX21lZGlhUGxheWVyLmRlZmF1bHRQbGF5YmFja1JhdGUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBnZXQgZHVyYXRpb24oKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhUGxheWVyID8gdGhpcy5fbWVkaWFQbGF5ZXIuZHVyYXRpb24gOiAwO1xuICAgIH1cblxuICAgIGdldCBlbmRlZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhUGxheWVyID8gdGhpcy5fbWVkaWFQbGF5ZXIuZW5kZWQgOiBmYWxzZTtcbiAgICB9XG5cbiAgICBnZXQgbG9vcCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhUGxheWVyID8gdGhpcy5fbWVkaWFQbGF5ZXIubG9vcCA6IGZhbHNlO1xuICAgIH1cbiAgICBzZXQgbG9vcCh2YWx1ZTogYm9vbGVhbikge1xuICAgICAgICB0aGlzLl9tZWRpYVBsYXllci5sb29wID0gdmFsdWU7XG4gICAgfVxuXG4gICAgZ2V0IG11dGVkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVkaWFQbGF5ZXIgPyB0aGlzLl9tZWRpYVBsYXllci5tdXRlZCA6IGZhbHNlO1xuICAgIH1cbiAgICBzZXQgbXV0ZWQodmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5fbWVkaWFQbGF5ZXIubXV0ZWQgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBnZXQgbmV0d29ya1N0YXRlKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZWRpYVBsYXllci5uZXR3b3JrU3RhdGU7XG4gICAgfVxuXG4gICAgZ2V0IHBhdXNlZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhUGxheWVyID8gdGhpcy5fbWVkaWFQbGF5ZXIucGF1c2VkIDogdHJ1ZTtcbiAgICB9XG5cbiAgICBnZXQgcGxheWJhY2tSYXRlKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZWRpYVBsYXllciA/IHRoaXMuX21lZGlhUGxheWVyLnBsYXliYWNrUmF0ZSA6IDE7XG4gICAgfVxuICAgIHNldCBwbGF5YmFja1JhdGUodmFsdWU6IG51bWJlcikge1xuICAgICAgICB0aGlzLl9tZWRpYVBsYXllci5wbGF5YmFja1JhdGUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBnZXQgcGxheWVkKCk6IFRpbWVSYW5nZXMge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVkaWFQbGF5ZXIgPyB0aGlzLl9tZWRpYVBsYXllci5wbGF5ZWQgOiBuZXcgVGltZVJhbmdlcygpO1xuICAgIH1cblxuICAgIGdldCBwcmVsb2FkKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZWRpYVBsYXllciA/IHRoaXMuX21lZGlhUGxheWVyLnByZWxvYWQgOiAnYXV0byc7XG4gICAgfVxuICAgIHNldCBwcmVsb2FkKHZhbHVlOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5fbWVkaWFQbGF5ZXIucHJlbG9hZCA9IHZhbHVlO1xuICAgIH1cblxuICAgIGdldCByZWFkeVN0YXRlKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZWRpYVBsYXllciA/IHRoaXMuX21lZGlhUGxheWVyLnJlYWR5U3RhdGUgOiAwO1xuICAgIH1cblxuICAgIGdldCBzZWVrYWJsZSgpOiBUaW1lUmFuZ2VzIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhUGxheWVyID8gdGhpcy5fbWVkaWFQbGF5ZXIuc2Vla2FibGUgOiBuZXcgVGltZVJhbmdlcygpO1xuICAgIH1cblxuICAgIGdldCBzZWVraW5nKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVkaWFQbGF5ZXIgPyB0aGlzLl9tZWRpYVBsYXllci5zZWVraW5nIDogZmFsc2U7XG4gICAgfVxuXG4gICAgZ2V0IHNyYygpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVkaWFQbGF5ZXIgPyB0aGlzLl9tZWRpYVBsYXllci5zcmMgOiAnJztcbiAgICB9XG4gICAgc2V0IHNyYyh2YWx1ZTogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuX21lZGlhUGxheWVyLnNyYyA9IHZhbHVlO1xuICAgIH1cblxuICAgIGdldCB0ZXh0VHJhY2tzKCk6IFRleHRUcmFja0xpc3Qge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVkaWFQbGF5ZXIgPyB0aGlzLl9tZWRpYVBsYXllci50ZXh0VHJhY2tzIDogbmV3IFRleHRUcmFja0xpc3QoKTtcbiAgICB9XG5cbiAgICBnZXQgdmlkZW9UcmFja3MoKTogVmlkZW9UcmFja0xpc3Qge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVkaWFQbGF5ZXIgPyB0aGlzLl9tZWRpYVBsYXllci52aWRlb1RyYWNrcyA6IG5ldyBWaWRlb1RyYWNrTGlzdCgpO1xuICAgIH1cblxuICAgIGdldCB2b2x1bWUoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhUGxheWVyID8gdGhpcy5fbWVkaWFQbGF5ZXIudm9sdW1lIDogMTtcbiAgICB9XG4gICAgc2V0IHZvbHVtZSh2YWx1ZTogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX21lZGlhUGxheWVyLnZvbHVtZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIGdldCBmdWxsc2NyZWVuKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVkaWFQbGF5ZXIgPyB0aGlzLl9mdWxsc2NyZWVuIDogZmFsc2U7XG4gICAgfVxuICAgIHNldCBmdWxsc2NyZWVuKHZhbHVlOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuX2Z1bGxzY3JlZW4gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5mdWxsc2NyZWVuRXZlbnQubmV4dCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgc2V0TWVkaWFQbGF5ZXIoaG9zdEVsZW1lbnQ6IEhUTUxFbGVtZW50LCBtZWRpYVBsYXllcjogSFRNTE1lZGlhRWxlbWVudCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9ob3N0RWxlbWVudCA9IGhvc3RFbGVtZW50O1xuICAgICAgICB0aGlzLl9tZWRpYVBsYXllciA9IG1lZGlhUGxheWVyO1xuXG4gICAgICAgIHRoaXMuaW5pdEV2ZW50Lm5leHQodHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVG9nZ2xlIHBsYXlpbmcgc3RhdGVcbiAgICAgKi9cbiAgICB0b2dnbGVQbGF5KCk6IHZvaWQge1xuXG4gICAgICAgIC8vIHByZXZlbnQgYW55IGFjdGlvbiBpcyBub3QgbG9hZGVkXG4gICAgICAgIGlmICh0aGlzLmxvYWRlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnBhdXNlZCkge1xuICAgICAgICAgICAgdGhpcy5wbGF5KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdGFydHMgcGxheWluZyB0aGUgYXVkaW8vdmlkZW9cbiAgICAgKi9cbiAgICBwbGF5KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9tZWRpYVBsYXllci5wbGF5KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGF1c2VzIHRoZSBjdXJyZW50bHkgcGxheWluZyBhdWRpby92aWRlb1xuICAgICAqL1xuICAgIHBhdXNlKCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9tZWRpYVBsYXllci5wYXVzZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlLWxvYWRzIHRoZSBhdWRpby92aWRlbyBlbGVtZW50XG4gICAgICovXG4gICAgbG9hZCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fbWVkaWFQbGF5ZXIubG9hZCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgYnJvd3NlciBjYW4gcGxheSB0aGUgc3BlY2lmaWVkIGF1ZGlvL3ZpZGVvIHR5cGVcbiAgICAgKi9cbiAgICBjYW5QbGF5VHlwZSh0eXBlOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVkaWFQbGF5ZXIuY2FuUGxheVR5cGUodHlwZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIG5ldyB0ZXh0IHRyYWNrIHRvIHRoZSBhdWRpby92aWRlb1xuICAgICAqL1xuICAgIGFkZFRleHRUcmFjayhraW5kOiBzdHJpbmcsIGxhYmVsOiBzdHJpbmcsIGxhbmd1YWdlOiBzdHJpbmcpOiBUZXh0VHJhY2sge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVkaWFQbGF5ZXIuYWRkVGV4dFRyYWNrKGtpbmQsIGxhYmVsLCBsYW5ndWFnZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXR0ZW1wdCB0byBkaXNwbGF5IG1lZGlhIGluIGZ1bGxzY3JlZW4gbW9kZVxuICAgICAqL1xuICAgIHJlcXVlc3RGdWxsc2NyZWVuKCk6IHZvaWQge1xuXG4gICAgICAgIGlmICh0aGlzLl9ob3N0RWxlbWVudC5yZXF1ZXN0RnVsbHNjcmVlbikge1xuICAgICAgICAgICAgdGhpcy5faG9zdEVsZW1lbnQucmVxdWVzdEZ1bGxzY3JlZW4oKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ob3N0RWxlbWVudC53ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbikge1xuICAgICAgICAgICAgdGhpcy5faG9zdEVsZW1lbnQud2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4oKTtcbiAgICAgICAgfSBlbHNlIGlmICgoPGFueT50aGlzLl9ob3N0RWxlbWVudCkubXNSZXF1ZXN0RnVsbHNjcmVlbikge1xuICAgICAgICAgICAgKDxhbnk+dGhpcy5faG9zdEVsZW1lbnQpLm1zUmVxdWVzdEZ1bGxzY3JlZW4oKTtcbiAgICAgICAgfSBlbHNlIGlmICgoPGFueT50aGlzLl9ob3N0RWxlbWVudCkubW96UmVxdWVzdEZ1bGxTY3JlZW4pIHtcbiAgICAgICAgICAgICg8YW55PnRoaXMuX2hvc3RFbGVtZW50KS5tb3pSZXF1ZXN0RnVsbFNjcmVlbigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhpdCBmdWxsIHNjcmVlbiBtb2RlXG4gICAgICovXG4gICAgZXhpdEZ1bGxzY3JlZW4oKTogdm9pZCB7XG5cbiAgICAgICAgaWYgKCg8YW55PnRoaXMuX2hvc3RFbGVtZW50KS5leGl0RnVsbHNjcmVlbikge1xuICAgICAgICAgICAgZG9jdW1lbnQuZXhpdEZ1bGxzY3JlZW4oKTtcbiAgICAgICAgfSBlbHNlIGlmIChkb2N1bWVudC53ZWJraXRFeGl0RnVsbHNjcmVlbikge1xuICAgICAgICAgICAgZG9jdW1lbnQud2Via2l0RXhpdEZ1bGxzY3JlZW4oKTtcbiAgICAgICAgfSBlbHNlIGlmICgoPGFueT5kb2N1bWVudCkubXNFeGl0RnVsbHNjcmVlbikge1xuICAgICAgICAgICAgKDxhbnk+ZG9jdW1lbnQpLm1zRXhpdEZ1bGxzY3JlZW4oKTtcbiAgICAgICAgfSBlbHNlIGlmICgoPGFueT5kb2N1bWVudCkubW96Q2FuY2VsRnVsbFNjcmVlbikge1xuICAgICAgICAgICAgKDxhbnk+ZG9jdW1lbnQpLm1vekNhbmNlbEZ1bGxTY3JlZW4oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bGxzY3JlZW5DaGFuZ2UoZXZlbnQ6IEV2ZW50KSB7XG4gICAgICAgIHRoaXMuZnVsbHNjcmVlbiA9ICg8YW55PmRvY3VtZW50KS5mdWxsc2NyZWVuIHx8IGRvY3VtZW50LndlYmtpdElzRnVsbFNjcmVlbiB8fCAoPGFueT5kb2N1bWVudCkubW96RnVsbFNjcmVlbiB8fCAoPGFueT5kb2N1bWVudCkubXNGdWxsc2NyZWVuRWxlbWVudCAhPT0gbnVsbCAmJiAoPGFueT5kb2N1bWVudCkubXNGdWxsc2NyZWVuRWxlbWVudCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmZ1bGxzY3JlZW5FdmVudC5uZXh0KHRoaXMuZnVsbHNjcmVlbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVG9nZ2xlIEZ1bGxzY3JlZW4gU3RhdGVcbiAgICAgKi9cbiAgICB0b2dnbGVGdWxsc2NyZWVuKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5mdWxsc2NyZWVuKSB7XG4gICAgICAgICAgICB0aGlzLmV4aXRGdWxsc2NyZWVuKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RGdWxsc2NyZWVuKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0IHRoZSBmcmFtZXMgZnJvbSB0aGUgdmlkZW9cbiAgICAgKi9cbiAgICBnZXRGcmFtZXMod2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIsIHNraXA6IG51bWJlcik6IE9ic2VydmFibGU8RXh0cmFjdGVkRnJhbWU+IHtcblxuICAgICAgICBpZiAodGhpcy50eXBlID09PSAndmlkZW8nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZnJhbWVFeHRyYWN0aW9uU2VydmljZS5nZXRGcmFtZVRodW1ibmFpbHModGhpcy5zb3VyY2UsIHdpZHRoLCBoZWlnaHQsIDAsIHRoaXMuZHVyYXRpb24sIDEwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmcm9tKFtdKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgQWZ0ZXJWaWV3SW5pdCwgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBJbnB1dCwgT25EZXN0cm95LCBWaWV3Q2hpbGQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzL09ic2VydmFibGUnO1xuaW1wb3J0IHsgZnJvbUV2ZW50IH0gZnJvbSAncnhqcy9vYnNlcnZhYmxlL2Zyb21FdmVudCc7XG5pbXBvcnQgeyBvZiB9IGZyb20gJ3J4anMvb2JzZXJ2YWJsZS9vZic7XG5pbXBvcnQgeyBkZWJvdW5jZVRpbWUsIHN3aXRjaE1hcCwgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XG5pbXBvcnQgeyBBdWRpb01ldGFkYXRhLCBBdWRpb1NlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9hdWRpby9pbmRleCc7XG5pbXBvcnQgeyBNZWRpYVBsYXllclNlcnZpY2UgfSBmcm9tICcuL21lZGlhLXBsYXllci5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1tZWRpYS1wbGF5ZXInLFxuICAgIHRlbXBsYXRlOiBgPGRpdiBjbGFzcz1cInZpZGVvLXBsYXllci1jb250YWluZXJcIiAqbmdJZj1cInR5cGUgPT09ICd2aWRlbydcIj5cblxuICAgIDx2aWRlbyBjbGFzcz1cInZpZGVvLXBsYXllclwiXG4gICAgICAgICNwbGF5ZXJcbiAgICAgICAgW3NyY109XCJzb3VyY2VcIlxuICAgICAgICAoYWJvcnQpPVwibWVkaWFQbGF5ZXJTZXJ2aWNlLmFib3J0RXZlbnQubmV4dCgpXCJcbiAgICAgICAgKGNhbnBsYXkpPVwibWVkaWFQbGF5ZXJTZXJ2aWNlLmNhblBsYXlFdmVudC5uZXh0KHRydWUpXCJcbiAgICAgICAgKGNhbnBsYXl0aHJvdWdoKT1cIm1lZGlhUGxheWVyU2VydmljZS5jYW5QbGF5VGhyb3VnaEV2ZW50Lm5leHQodHJ1ZSlcIlxuICAgICAgICAoZHVyYXRpb25jaGFuZ2UpPVwibWVkaWFQbGF5ZXJTZXJ2aWNlLmR1cmF0aW9uQ2hhbmdlRXZlbnQubmV4dChwbGF5ZXIuZHVyYXRpb24pXCJcbiAgICAgICAgKGVuZGVkKT1cIm1lZGlhUGxheWVyU2VydmljZS5lbmRlZEV2ZW50Lm5leHQoKVwiXG4gICAgICAgIChlcnJvcik9XCJtZWRpYVBsYXllclNlcnZpY2UuZXJyb3JFdmVudC5uZXh0KCRldmVudClcIlxuICAgICAgICAobG9hZGVkZGF0YSk9XCJtZWRpYVBsYXllclNlcnZpY2UubG9hZGVkRGF0YUV2ZW50Lm5leHQoJGV2ZW50KVwiXG4gICAgICAgIChsb2FkZWRtZXRhZGF0YSk9XCJtZWRpYVBsYXllclNlcnZpY2UubG9hZGVkTWV0YWRhdGFFdmVudC5uZXh0KCRldmVudClcIlxuICAgICAgICAobG9hZHN0YXJ0KT1cIm1lZGlhUGxheWVyU2VydmljZS5sb2FkU3RhcnRFdmVudC5uZXh0KClcIlxuICAgICAgICAocGF1c2UpPVwibWVkaWFQbGF5ZXJTZXJ2aWNlLnBhdXNlRXZlbnQubmV4dCgpXCJcbiAgICAgICAgKHBsYXkpPVwibWVkaWFQbGF5ZXJTZXJ2aWNlLnBsYXlFdmVudC5uZXh0KClcIlxuICAgICAgICAocGxheWluZyk9XCJtZWRpYVBsYXllclNlcnZpY2UucGxheWluZ0V2ZW50Lm5leHQoIXBsYXllci5wYXVzZWQpXCJcbiAgICAgICAgKHJhdGVjaGFuZ2UpPVwibWVkaWFQbGF5ZXJTZXJ2aWNlLnJhdGVDaGFuZ2VFdmVudC5uZXh0KHBsYXllci5wbGF5YmFja1JhdGUpXCJcbiAgICAgICAgKHNlZWtlZCk9XCJtZWRpYVBsYXllclNlcnZpY2Uuc2Vla2VkRXZlbnQubmV4dChwbGF5ZXIuY3VycmVudFRpbWUpXCJcbiAgICAgICAgKHNlZWtpbmcpPVwibWVkaWFQbGF5ZXJTZXJ2aWNlLnNlZWtpbmdFdmVudC5uZXh0KHBsYXllci5jdXJyZW50VGltZSlcIlxuICAgICAgICAoc3RhbGxlZCk9XCJtZWRpYVBsYXllclNlcnZpY2Uuc3RhbGxlZEV2ZW50Lm5leHQoKVwiXG4gICAgICAgIChzdXNwZW5kKT1cIm1lZGlhUGxheWVyU2VydmljZS5zdXNwZW5kRXZlbnQubmV4dCgpXCJcbiAgICAgICAgKHRpbWV1cGRhdGUpPVwibWVkaWFQbGF5ZXJTZXJ2aWNlLnRpbWVVcGRhdGVFdmVudC5uZXh0KHBsYXllci5jdXJyZW50VGltZSlcIlxuICAgICAgICAodm9sdW1lY2hhbmdlKT1cIm1lZGlhUGxheWVyU2VydmljZS52b2x1bWVDaGFuZ2VFdmVudC5uZXh0KHBsYXllci52b2x1bWUpXCJcbiAgICAgICAgKHdhaXRpbmcpPVwibWVkaWFQbGF5ZXJTZXJ2aWNlLndhaXRpbmdFdmVudC5uZXh0KClcIlxuICAgICAgICAoY2xpY2spPVwibWVkaWFQbGF5ZXJTZXJ2aWNlLm1lZGlhQ2xpY2tFdmVudC5uZXh0KCRldmVudClcIj5cbiAgICA8L3ZpZGVvPlxuXG4gICAgPGRpdiBjbGFzcz1cInZpZGVvLW92ZXJsYXlcIiBbY2xhc3MucGxheWluZ109XCJtZWRpYVBsYXllclNlcnZpY2UucGxheWluZyB8IGFzeW5jXCI+XG4gICAgICAgIDxzdmcgY2xhc3M9XCJwbGF5LWdyYXBoaWNcIiB4PVwiMHB4XCIgeT1cIjBweFwiIHZpZXdCb3g9XCIwIDAgNjQgNjRcIj5cbiAgICAgICAgICAgIDxjaXJjbGUgY2xhc3M9XCJwbGF5LWNpcmNsZVwiIGN4PVwiMzIuMlwiIGN5PVwiMzEuOFwiIHI9XCIzMS44XCIgLz5cbiAgICAgICAgICAgIDxwb2x5Z29uIGNsYXNzPVwicGxheS10cmlhbmdsZVwiIHBvaW50cz1cIjIzLDE0LjEgMjMsNTAuOCA0OC4zLDMyLjVcIiAvPlxuICAgICAgICA8L3N2Zz5cbiAgICA8L2Rpdj5cblxuPC9kaXY+XG5cblxuPGRpdiBjbGFzcz1cImF1ZGlvLXBsYXllclwiICpuZ0lmPVwidHlwZSA9PT0gJ2F1ZGlvJ1wiPlxuXG4gICAgPHN2ZyB3aWR0aD1cIjI0cHhcIiBoZWlnaHQ9XCIyNHB4XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPlxuICAgICAgICA8ZyBzdHJva2U9XCJub25lXCIgc3Ryb2tlLXdpZHRoPVwiMVwiIGZpbGw9XCJub25lXCIgZmlsbC1ydWxlPVwiZXZlbm9kZFwiPlxuICAgICAgICAgICAgPGcgdHJhbnNmb3JtPVwidHJhbnNsYXRlKC05OC4wMDAwMDAsIC00NTguMDAwMDAwKVwiPlxuICAgICAgICAgICAgICAgIDxnIHRyYW5zZm9ybT1cInRyYW5zbGF0ZSg5OC4wMDAwMDAsIDQ1OC4wMDAwMDApXCI+XG4gICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9XCJNNC41LDAuNSBMMTguMDQzNTMwOCwwLjUgTDIzLjUsNi4yMjI1MTUwMiBMMjMuNSwyMy41IEw0LjUsMjMuNSBMNC41LDAuNSBaXCIgZmlsbD1cIiNDQ0VBRTJcIj48L3BhdGg+XG4gICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9XCJNNC41LDggTDQuNSwwLjUgTDE4LDAuNSBMMjMuNSw2IEwyMy41LDIzLjUgTDE4LDIzLjVcIiBzdHJva2U9XCIjNjA3OThEXCIgZmlsbD1cIiNDQ0VBRTJcIj48L3BhdGg+XG4gICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9XCJNNCwxMy41IEwwLjUsMTMuNSBMMC41LDE4LjUgTDQsMTguNSBMOS41LDIyLjUgTDkuNSw5LjUgTDQsMTMuNSBaXCIgc3Ryb2tlPVwiIzYwNzk4RFwiIGZpbGw9XCIjODVEMkJFXCI+PC9wYXRoPlxuICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPVwiTTExLjUsMTIuNTEzNzkzOSBDMTMuNzU3NjIyNSwxMi41MTM3OTM5IDE0LjUsMTQuMzcwOTIzNiAxNC41LDE2IEMxNC41LDE3LjY4NDkyMzYgMTMuNzA4OTE1MiwxOS41NDIwNTMyIDExLjUsMTkuNTQyMDUzMlwiXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJva2U9XCIjNjA3OThEXCI+PC9wYXRoPlxuICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPVwiTTExLjUsOSBDMTUuODAzNzY0Myw5LjA0MTY4NzAxIDE4LjUsMTEuNjYwNDgwNSAxOC41LDE2IEMxOC41LDIwLjMzOTUxOTUgMTUuODgwNDMwMiwyMy4wMDc5OTU2IDExLjUsMjNcIiBzdHJva2U9XCIjNjA3OThEXCI+PC9wYXRoPlxuICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPVwiTTE3LjUyMTkxMTYsMC43NjE0MTM1NzQgTDE3LjUyMTkxMTYsNiBMMjMsNlwiIHN0cm9rZT1cIiM2MDc5OERcIiBmaWxsPVwiIzg1RDJCRVwiPjwvcGF0aD5cbiAgICAgICAgICAgICAgICA8L2c+XG4gICAgICAgICAgICA8L2c+XG4gICAgICAgIDwvZz5cbiAgICA8L3N2Zz5cblxuICAgIDxwIGNsYXNzPVwiYXVkaW8tZmlsZS1uYW1lXCI+e3sgKGF1ZGlvTWV0YWRhdGEgfCBhc3luYyk/LmZpbGVuYW1lIH19PC9wPlxuICAgIDxwIGNsYXNzPVwiYXVkaW8tZmlsZS1mb3JtYXRcIj57eyAoYXVkaW9NZXRhZGF0YSB8IGFzeW5jKT8uZGVzY3JpcHRpb24gfX08L3A+XG4gICAgPHAgY2xhc3M9XCJhdWRpby1maWxlLXNpemVcIj57eyAoYXVkaW9NZXRhZGF0YSB8IGFzeW5jKT8uc2l6ZSB8IGZpbGVTaXplIH19PC9wPlxuXG4gICAgPGF1ZGlvICNwbGF5ZXJcbiAgICAgICAgW3NyY109XCJzb3VyY2VcIlxuICAgICAgICAoYWJvcnQpPVwibWVkaWFQbGF5ZXJTZXJ2aWNlLmFib3J0RXZlbnQubmV4dCgpXCJcbiAgICAgICAgKGNhbnBsYXkpPVwibWVkaWFQbGF5ZXJTZXJ2aWNlLmNhblBsYXlFdmVudC5uZXh0KHRydWUpXCJcbiAgICAgICAgKGNhbnBsYXl0aHJvdWdoKT1cIm1lZGlhUGxheWVyU2VydmljZS5jYW5QbGF5VGhyb3VnaEV2ZW50Lm5leHQodHJ1ZSlcIlxuICAgICAgICAoZHVyYXRpb25jaGFuZ2UpPVwibWVkaWFQbGF5ZXJTZXJ2aWNlLmR1cmF0aW9uQ2hhbmdlRXZlbnQubmV4dChwbGF5ZXIuZHVyYXRpb24pXCJcbiAgICAgICAgKGVuZGVkKT1cIm1lZGlhUGxheWVyU2VydmljZS5lbmRlZEV2ZW50Lm5leHQoKVwiXG4gICAgICAgIChlcnJvcik9XCJtZWRpYVBsYXllclNlcnZpY2UuZXJyb3JFdmVudC5uZXh0KCRldmVudClcIlxuICAgICAgICAobG9hZGVkZGF0YSk9XCJtZWRpYVBsYXllclNlcnZpY2UubG9hZGVkRGF0YUV2ZW50Lm5leHQoJGV2ZW50KVwiXG4gICAgICAgIChsb2FkZWRtZXRhZGF0YSk9XCJtZWRpYVBsYXllclNlcnZpY2UubG9hZGVkTWV0YWRhdGFFdmVudC5uZXh0KCRldmVudClcIlxuICAgICAgICAobG9hZHN0YXJ0KT1cIm1lZGlhUGxheWVyU2VydmljZS5sb2FkU3RhcnRFdmVudC5uZXh0KClcIlxuICAgICAgICAocGF1c2UpPVwibWVkaWFQbGF5ZXJTZXJ2aWNlLnBhdXNlRXZlbnQubmV4dCgpXCJcbiAgICAgICAgKHBsYXkpPVwibWVkaWFQbGF5ZXJTZXJ2aWNlLnBsYXlFdmVudC5uZXh0KClcIlxuICAgICAgICAocGxheWluZyk9XCJtZWRpYVBsYXllclNlcnZpY2UucGxheWluZ0V2ZW50Lm5leHQoIXBsYXllci5wYXVzZWQpXCJcbiAgICAgICAgKHJhdGVjaGFuZ2UpPVwibWVkaWFQbGF5ZXJTZXJ2aWNlLnJhdGVDaGFuZ2VFdmVudC5uZXh0KHBsYXllci5wbGF5YmFja1JhdGUpXCJcbiAgICAgICAgKHNlZWtlZCk9XCJtZWRpYVBsYXllclNlcnZpY2Uuc2Vla2VkRXZlbnQubmV4dChwbGF5ZXIuY3VycmVudFRpbWUpXCJcbiAgICAgICAgKHNlZWtpbmcpPVwibWVkaWFQbGF5ZXJTZXJ2aWNlLnNlZWtpbmdFdmVudC5uZXh0KHBsYXllci5jdXJyZW50VGltZSlcIlxuICAgICAgICAoc3RhbGxlZCk9XCJtZWRpYVBsYXllclNlcnZpY2Uuc3RhbGxlZEV2ZW50Lm5leHQoKVwiXG4gICAgICAgIChzdXNwZW5kKT1cIm1lZGlhUGxheWVyU2VydmljZS5zdXNwZW5kRXZlbnQubmV4dCgpXCJcbiAgICAgICAgKHRpbWV1cGRhdGUpPVwibWVkaWFQbGF5ZXJTZXJ2aWNlLnRpbWVVcGRhdGVFdmVudC5uZXh0KHBsYXllci5jdXJyZW50VGltZSlcIlxuICAgICAgICAodm9sdW1lY2hhbmdlKT1cIm1lZGlhUGxheWVyU2VydmljZS52b2x1bWVDaGFuZ2VFdmVudC5uZXh0KHBsYXllci52b2x1bWUpXCJcbiAgICAgICAgKHdhaXRpbmcpPVwibWVkaWFQbGF5ZXJTZXJ2aWNlLndhaXRpbmdFdmVudC5uZXh0KClcIlxuICAgICAgICAoY2xpY2spPVwibWVkaWFQbGF5ZXJTZXJ2aWNlLm1lZGlhQ2xpY2tFdmVudC5uZXh0KCRldmVudClcIj5cbiAgICA8L2F1ZGlvPlxuPC9kaXY+XG5cbjxkaXYgY2xhc3M9XCJjb250cm9sLWJhclwiPlxuICAgIDx1eC1tZWRpYS1wbGF5ZXItdGltZWxpbmU+PC91eC1tZWRpYS1wbGF5ZXItdGltZWxpbmU+XG4gICAgPHV4LW1lZGlhLXBsYXllci1jb250cm9scz48L3V4LW1lZGlhLXBsYXllci1jb250cm9scz5cbjwvZGl2PmAsXG4gICAgcHJvdmlkZXJzOiBbTWVkaWFQbGF5ZXJTZXJ2aWNlXSxcbiAgICBob3N0OiB7XG4gICAgICAgICd0YWJpbmRleCc6ICcwJyxcbiAgICAgICAgJyhrZXlkb3duLlNwYWNlKSc6ICdtZWRpYVBsYXllclNlcnZpY2UudG9nZ2xlUGxheSgpJyxcbiAgICAgICAgJ1tjbGFzcy5zdGFuZGFyZF0nOiAnIW1lZGlhUGxheWVyU2VydmljZS5mdWxsc2NyZWVuJyxcbiAgICAgICAgJ1tjbGFzcy5mdWxsc2NyZWVuXSc6ICdtZWRpYVBsYXllclNlcnZpY2UuZnVsbHNjcmVlbicsXG4gICAgICAgICdbY2xhc3MucXVpZXRdJzogJ3F1aWV0TW9kZSAmJiB0eXBlID09PSBcInZpZGVvXCIgfHwgbWVkaWFQbGF5ZXJTZXJ2aWNlLmZ1bGxzY3JlZW4nLFxuICAgICAgICAnW2NsYXNzLmhvdmVyXSc6ICdob3ZlcmluZycsXG4gICAgICAgICdbY2xhc3MudmlkZW9dJzogJ3R5cGUgPT09IFwidmlkZW9cIicsXG4gICAgICAgICdbY2xhc3MuYXVkaW9dJzogJ3R5cGUgPT09IFwiYXVkaW9cIicsXG4gICAgICAgICcobW91c2VlbnRlciknOiAnaG92ZXJpbmcgPSB0cnVlJyxcbiAgICAgICAgJyhtb3VzZWxlYXZlKSc6ICdob3ZlcmluZyA9IGZhbHNlJyxcbiAgICAgICAgJyhkb2N1bWVudDp3ZWJraXRmdWxsc2NyZWVuY2hhbmdlKSc6ICdtZWRpYVBsYXllclNlcnZpY2UuZnVsbHNjcmVlbkNoYW5nZSgkZXZlbnQpJyxcbiAgICAgICAgJyhkb2N1bWVudDptb3pmdWxsc2NyZWVuY2hhbmdlKSc6ICdtZWRpYVBsYXllclNlcnZpY2UuZnVsbHNjcmVlbkNoYW5nZSgkZXZlbnQpJyxcbiAgICAgICAgJyhkb2N1bWVudDpNU0Z1bGxzY3JlZW5DaGFuZ2UpJzogJ21lZGlhUGxheWVyU2VydmljZS5mdWxsc2NyZWVuQ2hhbmdlKCRldmVudCknXG4gICAgfVxufSlcbmV4cG9ydCBjbGFzcyBNZWRpYVBsYXllckNvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQsIE9uRGVzdHJveSB7XG5cbiAgICBAVmlld0NoaWxkKCdwbGF5ZXInKSBwcml2YXRlIF9wbGF5ZXJSZWY6IEVsZW1lbnRSZWY7XG5cbiAgICBob3ZlcmluZzogYm9vbGVhbiA9IGZhbHNlO1xuICAgIGF1ZGlvTWV0YWRhdGE6IE9ic2VydmFibGU8QXVkaW9NZXRhZGF0YT47XG5cbiAgICBnZXQgc291cmNlKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lZGlhUGxheWVyU2VydmljZS5zb3VyY2U7XG4gICAgfVxuXG4gICAgQElucHV0KClcbiAgICBzZXQgc291cmNlKHZhbHVlOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5tZWRpYVBsYXllclNlcnZpY2Uuc291cmNlID0gdmFsdWU7XG4gICAgfVxuXG4gICAgZ2V0IHR5cGUoKTogTWVkaWFQbGF5ZXJUeXBlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLnR5cGU7XG4gICAgfVxuXG4gICAgQElucHV0KClcbiAgICBzZXQgdHlwZSh2YWx1ZTogTWVkaWFQbGF5ZXJUeXBlKSB7XG4gICAgICAgIHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLnR5cGUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBnZXQgcXVpZXRNb2RlKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5tZWRpYVBsYXllclNlcnZpY2UucXVpZXRNb2RlO1xuICAgIH1cblxuICAgIEBJbnB1dCgpXG4gICAgc2V0IHF1aWV0TW9kZSh2YWx1ZTogYm9vbGVhbikge1xuICAgICAgICB0aGlzLm1lZGlhUGxheWVyU2VydmljZS5xdWlldE1vZGUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9vbkRlc3Ryb3kgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIG1lZGlhUGxheWVyU2VydmljZTogTWVkaWFQbGF5ZXJTZXJ2aWNlLCBwcml2YXRlIF9hdWRpb1NlcnZpY2U6IEF1ZGlvU2VydmljZSwgcHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZikge1xuXG4gICAgICAgIC8vIHNob3cgY29udHJvbHMgd2hlbiBob3ZlcmluZyBhbmQgaW4gcXVpZXQgbW9kZVxuICAgICAgICBmcm9tRXZlbnQodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnbW91c2Vtb3ZlJykucGlwZShcbiAgICAgICAgICAgIHN3aXRjaE1hcCgoZXZlbnQ6IE1vdXNlRXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmhvdmVyaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2YoZXZlbnQpO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBkZWJvdW5jZVRpbWUoMjAwMCksXG4gICAgICAgICAgICB0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KVxuICAgICAgICApLnN1YnNjcmliZSgoKSA9PiB0aGlzLmhvdmVyaW5nID0gZmFsc2UpO1xuICAgIH1cblxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5tZWRpYVBsYXllclNlcnZpY2Uuc2V0TWVkaWFQbGF5ZXIodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCB0aGlzLl9wbGF5ZXJSZWYubmF0aXZlRWxlbWVudCk7XG5cbiAgICAgICAgdGhpcy5hdWRpb01ldGFkYXRhID0gdGhpcy5fYXVkaW9TZXJ2aWNlLmdldEF1ZGlvRmlsZU1ldGFkYXRhKHRoaXMuX3BsYXllclJlZi5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgdGhpcy5tZWRpYVBsYXllclNlcnZpY2UucGxheWluZ0V2ZW50LnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZSgoKSA9PiB0aGlzLm1lZGlhUGxheWVyU2VydmljZS5wbGF5aW5nLm5leHQodHJ1ZSkpO1xuICAgICAgICB0aGlzLm1lZGlhUGxheWVyU2VydmljZS5wYXVzZUV2ZW50LnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZSgoKSA9PiB0aGlzLm1lZGlhUGxheWVyU2VydmljZS5wbGF5aW5nLm5leHQoZmFsc2UpKTtcbiAgICAgICAgdGhpcy5tZWRpYVBsYXllclNlcnZpY2UubWVkaWFDbGlja0V2ZW50LnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZSgoKSA9PiB0aGlzLm1lZGlhUGxheWVyU2VydmljZS50b2dnbGVQbGF5KCkpO1xuICAgICAgICB0aGlzLm1lZGlhUGxheWVyU2VydmljZS5sb2FkZWRNZXRhZGF0YUV2ZW50LnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZSgoKSA9PiB0aGlzLm1lZGlhUGxheWVyU2VydmljZS5sb2FkZWQgPSB0cnVlKTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fb25EZXN0cm95Lm5leHQoKTtcbiAgICAgICAgdGhpcy5fb25EZXN0cm95LmNvbXBsZXRlKCk7XG4gICAgfVxufVxuXG5leHBvcnQgdHlwZSBNZWRpYVBsYXllclR5cGUgPSAndmlkZW8nIHwgJ2F1ZGlvJztcblxuZXhwb3J0IGludGVyZmFjZSBNZWRpYVBsYXllckJ1ZmZlciB7XG4gICAgc3RhcnQ6IG51bWJlcjtcbiAgICBlbmQ6IG51bWJlcjtcbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE1lZGlhUGxheWVyU2VydmljZSB9IGZyb20gJy4uL21lZGlhLXBsYXllci5zZXJ2aWNlJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbbWVkaWFQbGF5ZXJCYXNlRXh0ZW5zaW9uXSdcbn0pXG5leHBvcnQgY2xhc3MgTWVkaWFQbGF5ZXJCYXNlRXh0ZW5zaW9uRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgbWVkaWFQbGF5ZXJTZXJ2aWNlOiBNZWRpYVBsYXllclNlcnZpY2UpIHsgfVxufSIsImltcG9ydCB7IEFmdGVyVmlld0luaXQsIENvbXBvbmVudCwgRWxlbWVudFJlZiwgT25EZXN0cm95LCBPbkluaXQsIFZpZXdDaGlsZCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgZnJvbUV2ZW50IH0gZnJvbSAncnhqcy9vYnNlcnZhYmxlL2Zyb21FdmVudCc7XG5pbXBvcnQgeyBzd2l0Y2hNYXAsIHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzL1N1YmplY3QnO1xuaW1wb3J0IHsgTWVkaWFQbGF5ZXJCYXNlRXh0ZW5zaW9uRGlyZWN0aXZlIH0gZnJvbSAnLi4vYmFzZS1leHRlbnNpb24uZGlyZWN0aXZlJztcblxuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LW1lZGlhLXBsYXllci10aW1lbGluZScsXG4gICAgdGVtcGxhdGU6IGA8cCBjbGFzcz1cImN1cnJlbnQtdGltZVwiPnt7IGN1cnJlbnQgfCBkdXJhdGlvbiB9fTwvcD5cblxuPGRpdiAjdGltZWxpbmUgY2xhc3M9XCJ0aW1lbGluZS1iYXJcIiAobW91c2VlbnRlcik9XCJzY3J1Yi52aXNpYmxlID0gdHJ1ZTsgcG9wLnNob3coKVwiIChtb3VzZWxlYXZlKT1cInNjcnViLnZpc2libGUgPSBmYWxzZTsgcG9wLmhpZGUoKVwiXG4gICAgKG1vdXNlbW92ZSk9XCJ1cGRhdGVTY3J1YigkZXZlbnQpXCIgKG1vdXNldXApPVwidXBkYXRlU2NydWIoJGV2ZW50KVwiIChtb3VzZWRvd24pPVwibW91c2VEb3duID0gdHJ1ZTsgJGV2ZW50LnByZXZlbnREZWZhdWx0KClcIj5cblxuICAgIDxkaXYgY2xhc3M9XCJidWZmZXJlZC1iYXJcIiAqbmdGb3I9XCJsZXQgYnVmZmVyIG9mIGJ1ZmZlcmVkXCIgW3N0eWxlLmxlZnQuJV09XCJidWZmZXIuc3RhcnRcIiBbc3R5bGUud2lkdGguJV09XCJidWZmZXIuZW5kIC0gYnVmZmVyLnN0YXJ0XCI+PC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwibWVkaWEtcHJvZ3Jlc3MtYmFyXCIgW3N0eWxlLndpZHRoLiVdPVwicG9zaXRpb25cIj5cbiAgICAgICAgPGRpdiAjcHJvZ3Jlc3NUaHVtYiBjbGFzcz1cIm1lZGlhLXByb2dyZXNzLWJhci10aHVtYlwiIChtb3VzZWVudGVyKT1cInNjcnViLnZpc2libGUgPSBmYWxzZTsgcG9wLmhpZGUoKTsgJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXCJcbiAgICAgICAgICAgIChtb3VzZWxlYXZlKT1cInNjcnViLnZpc2libGUgPSB0cnVlOyBwb3Auc2hvdygpOyAkZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcIj48L2Rpdj5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJzY3J1Yi1oYW5kbGVcIlxuICAgICAgICAgW2NsYXNzLnNjcnViLWhhbmRsZS1oaWRkZW5dPVwiIXNjcnViLnZpc2libGVcIlxuICAgICAgICAgW3N0eWxlLmxlZnQucHhdPVwic2NydWIucG9zaXRpb25cIlxuICAgICAgICAgW3V4VG9vbHRpcF09XCJwb3BUZW1wbGF0ZVwiXG4gICAgICAgICBwbGFjZW1lbnQ9XCJ0b3BcIlxuICAgICAgICAgW3Nob3dUcmlnZ2Vyc109XCJbXVwiXG4gICAgICAgICBbaGlkZVRyaWdnZXJzXT1cIltdXCJcbiAgICAgICAgICNwb3A9XCJ1eC10b29sdGlwXCJcbiAgICAgICAgIFt0b29sdGlwRGVsYXldPVwiMTAwXCJcbiAgICAgICAgIFt0b29sdGlwRGlzYWJsZWRdPVwiZHVyYXRpb24gPT09IDBcIj48L2Rpdj5cbjwvZGl2PlxuXG48cCBjbGFzcz1cImR1cmF0aW9uLXRpbWVcIj57eyBkdXJhdGlvbiB8IGR1cmF0aW9uIH19PC9wPlxuXG48bmctdGVtcGxhdGUgI3BvcFRlbXBsYXRlPlxuICAgIDxzcGFuPnt7IHNjcnViLnRpbWUgfCBkdXJhdGlvbiB9fTwvc3Bhbj5cbjwvbmctdGVtcGxhdGU+YCxcbiAgICBob3N0OiB7XG4gICAgICAgICcoZG9jdW1lbnQ6bW91c2V1cCknOiAnbW91c2VEb3duID0gZmFsc2UnLFxuICAgICAgICAnW2NsYXNzLnF1aWV0XSc6ICdxdWlldE1vZGUgfHwgZnVsbHNjcmVlbidcbiAgICB9XG59KVxuZXhwb3J0IGNsYXNzIE1lZGlhUGxheWVyVGltZWxpbmVFeHRlbnNpb25Db21wb25lbnQgZXh0ZW5kcyBNZWRpYVBsYXllckJhc2VFeHRlbnNpb25EaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIEFmdGVyVmlld0luaXQsIE9uRGVzdHJveSB7XG5cbiAgICBAVmlld0NoaWxkKCdwcm9ncmVzc1RodW1iJykgdGh1bWI6IEVsZW1lbnRSZWY7XG4gICAgQFZpZXdDaGlsZCgndGltZWxpbmUnKSB0aW1lbGluZVJlZjogRWxlbWVudFJlZjtcblxuICAgIGN1cnJlbnQ6IG51bWJlciA9IDA7XG4gICAgcG9zaXRpb246IG51bWJlciA9IDA7XG4gICAgZHVyYXRpb246IG51bWJlciA9IDA7XG4gICAgYnVmZmVyZWQ6IE1lZGlhUGxheWVyQnVmZmVyZWRbXSA9IFtdO1xuICAgIG1vdXNlRG93bjogYm9vbGVhbiA9IGZhbHNlO1xuICAgIHF1aWV0TW9kZTogYm9vbGVhbiA9IGZhbHNlO1xuICAgIGZ1bGxzY3JlZW46IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBzY3J1YiA9IHsgdmlzaWJsZTogZmFsc2UsIHBvc2l0aW9uOiAwLCB0aW1lOiAwIH07XG5cbiAgICBwcml2YXRlIF9vbkRlc3Ryb3kgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gICAgbmdPbkluaXQoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gd2F0Y2ggZm9yIGNoYW5nZXMgdG8gdGhlIGN1cnJlbnQgdGltZVxuICAgICAgICB0aGlzLm1lZGlhUGxheWVyU2VydmljZS5kdXJhdGlvbkNoYW5nZUV2ZW50LnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZShkdXJhdGlvbiA9PiB0aGlzLmR1cmF0aW9uID0gZHVyYXRpb24pO1xuICAgICAgICB0aGlzLm1lZGlhUGxheWVyU2VydmljZS5xdWlldE1vZGVFdmVudC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUocXVpZXRNb2RlID0+IHRoaXMucXVpZXRNb2RlID0gcXVpZXRNb2RlKTtcbiAgICAgICAgdGhpcy5tZWRpYVBsYXllclNlcnZpY2UuZnVsbHNjcmVlbkV2ZW50LnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZShmdWxsc2NyZWVuID0+IHtcbiAgICAgICAgICAgIHRoaXMuZnVsbHNjcmVlbiA9IGZ1bGxzY3JlZW47XG4gICAgICAgICAgICB0aGlzLnNjcnViLnBvc2l0aW9uID0gMDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5tZWRpYVBsYXllclNlcnZpY2UudGltZVVwZGF0ZUV2ZW50LnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZShjdXJyZW50ID0+IHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudCA9IGN1cnJlbnQ7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gKHRoaXMuY3VycmVudCAvIHRoaXMuZHVyYXRpb24pICogMTAwO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLm1lZGlhUGxheWVyU2VydmljZS5wcm9ncmVzc0V2ZW50LnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZSgoYnVmZmVyZWQ6IFRpbWVSYW5nZXMpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyZWQgPSBbXTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgYnVmZmVyZWQubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyZWQucHVzaCh7IHN0YXJ0OiAoYnVmZmVyZWQuc3RhcnQoaWR4KSAvIHRoaXMuZHVyYXRpb24pICogMTAwLCBlbmQ6IChidWZmZXJlZC5lbmQoaWR4KSAvIHRoaXMuZHVyYXRpb24pICogMTAwIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IG1vdXNlZG93biQgPSBmcm9tRXZlbnQodGhpcy50aHVtYi5uYXRpdmVFbGVtZW50LCAnbW91c2Vkb3duJyk7XG4gICAgICAgIGNvbnN0IG1vdXNlbW92ZSQgPSBmcm9tRXZlbnQoZG9jdW1lbnQsICdtb3VzZW1vdmUnKTtcbiAgICAgICAgY29uc3QgbW91c2V1cCQgPSBmcm9tRXZlbnQoZG9jdW1lbnQsICdtb3VzZXVwJyk7XG5cbiAgICAgICAgbW91c2Vkb3duJC5waXBlKFxuICAgICAgICAgICAgc3dpdGNoTWFwKCgpID0+IG1vdXNlbW92ZSQucGlwZSh0YWtlVW50aWwobW91c2V1cCQpKSksXG4gICAgICAgICAgICB0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KVxuICAgICAgICApLnN1YnNjcmliZSgoKSA9PiB0aGlzLnNjcnViLnZpc2libGUgPSBmYWxzZSk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX29uRGVzdHJveS5uZXh0KCk7XG4gICAgICAgIHRoaXMuX29uRGVzdHJveS5jb21wbGV0ZSgpO1xuICAgIH1cblxuICAgIHVwZGF0ZVNjcnViKGV2ZW50PzogTW91c2VFdmVudCk6IHZvaWQge1xuXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldCBhcyBIVE1MRWxlbWVudDtcblxuICAgICAgICBpZiAodGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnbWVkaWEtcHJvZ3Jlc3MtYmFyLXRodW1iJykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRpbWVsaW5lID0gdGhpcy50aW1lbGluZVJlZi5uYXRpdmVFbGVtZW50IGFzIEhUTUxEaXZFbGVtZW50O1xuICAgICAgICBjb25zdCBib3VuZHMgPSB0aW1lbGluZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICB0aGlzLnNjcnViLnBvc2l0aW9uID0gZXZlbnQub2Zmc2V0WDtcbiAgICAgICAgdGhpcy5zY3J1Yi50aW1lID0gKGV2ZW50Lm9mZnNldFggLyBib3VuZHMud2lkdGgpICogdGhpcy5tZWRpYVBsYXllclNlcnZpY2UuZHVyYXRpb247XG5cbiAgICAgICAgaWYgKHRoaXMubW91c2VEb3duKSB7XG4gICAgICAgICAgICB0aGlzLm1lZGlhUGxheWVyU2VydmljZS5wYXVzZSgpO1xuICAgICAgICAgICAgdGhpcy5tZWRpYVBsYXllclNlcnZpY2UuY3VycmVudFRpbWUgPSB0aGlzLnNjcnViLnRpbWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWVkaWFQbGF5ZXJCdWZmZXJlZCB7XG4gICAgc3RhcnQ6IG51bWJlcjtcbiAgICBlbmQ6IG51bWJlcjtcbn1cbiIsImltcG9ydCB7IENvbXBvbmVudCwgRWxlbWVudFJlZiwgSG9zdExpc3RlbmVyLCBPbkRlc3Ryb3ksIE9uSW5pdCwgVmlld0NoaWxkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBmcm9tRXZlbnQgfSBmcm9tICdyeGpzL29ic2VydmFibGUvZnJvbUV2ZW50JztcbmltcG9ydCB7IHRpbWVyIH0gZnJvbSAncnhqcy9vYnNlcnZhYmxlL3RpbWVyJztcbmltcG9ydCB7IGRlYm91bmNlVGltZSwgZmlsdGVyLCBzd2l0Y2hNYXAsIHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzL1N1YmplY3QnO1xuaW1wb3J0IHsgTWVkaWFQbGF5ZXJCYXNlRXh0ZW5zaW9uRGlyZWN0aXZlIH0gZnJvbSAnLi4vYmFzZS1leHRlbnNpb24uZGlyZWN0aXZlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1tZWRpYS1wbGF5ZXItY29udHJvbHMnLFxuICAgIHRlbXBsYXRlOiBgPGRpdiBjbGFzcz1cInZvbHVtZS1jb250YWluZXJcIj5cblxuICAgIDxkaXYgY2xhc3M9XCJ2b2x1bWUtc2xpZGVyLWNvbnRhaW5lclwiICN2b2x1bWVDb250YWluZXIgW2NsYXNzLmFjdGl2ZV09XCJ2b2x1bWVBY3RpdmVcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInZvbHVtZS1zbGlkZXItaWNvblwiICN2b2x1bWVJY29uPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJocGUtaWNvblwiIFtjbGFzcy5ocGUtdm9sdW1lLW11dGVdPVwidm9sdW1lID09PSAwXCIgW2NsYXNzLmhwZS12b2x1bWUtbG93XT1cInZvbHVtZSA+IDAgJiYgdm9sdW1lIDw9IDcwXCIgW2NsYXNzLmhwZS12b2x1bWVdPVwidm9sdW1lID4gNzBcIiBbdXhUb29sdGlwXT1cIm11dGVUb29sdGlwXCIgKGNsaWNrKT1cInRvZ2dsZU11dGUoKVwiPjwvc3Bhbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIFxuICAgICAgICA8ZGl2IGNsYXNzPVwidm9sdW1lLXNsaWRlci1ub2RlXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwidm9sdW1lLXNsaWRlclwiICN2b2x1bWVTbGlkZXI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInZvbHVtZS10cmFjay1sb3dlclwiIFtzdHlsZS53aWR0aC4lXT1cInZvbHVtZVwiPjwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ2b2x1bWUtc2xpZGVyLXRodW1iXCIgKG1vdXNlZG93bik9XCJkcmFnU3RhcnQoJGV2ZW50KVwiIFtzdHlsZS5sZWZ0LiVdPVwidm9sdW1lXCIgdGFiaW5kZXg9XCIwXCIgKGtleWRvd24uQXJyb3dSaWdodCk9XCJ2b2x1bWUgPSB2b2x1bWUgKyAxMFwiIChrZXlkb3duLkFycm93TGVmdCk9XCJ2b2x1bWUgPSB2b2x1bWUgLSAxMFwiPjwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuPC9kaXY+XG5cbjxkaXYgY2xhc3M9XCJzcGFjZXJcIj48L2Rpdj5cblxuPHN2ZyB2aWV3Qm94PVwiMCAwIDUxLjUgNjRcIiB3aWR0aD1cIjE0XCIgaGVpZ2h0PVwiMTdcIiBjbGFzcz1cImNvbnRyb2wtYnV0dG9uXCIgKGNsaWNrKT1cImdvVG9TdGFydCgpXCI+XG4gICAgPHJlY3QgeD1cIjBcIiB5PVwiMFwiIHdpZHRoPVwiNy41XCIgaGVpZ2h0PVwiNjRcIiAvPlxuICAgIDxwb2x5Z29uIHBvaW50cz1cIjUxLjUsNjQgNTEuNSwwIDcuNCwzMiBcIiAvPlxuPC9zdmc+XG5cbjxzdmcgdmlld0JveD1cIjAgMCA0NSA2NFwiIHdpZHRoPVwiMjBcIiBoZWlnaHQ9XCIyOVwiIGNsYXNzPVwiY29udHJvbC1idXR0b25cIiAqbmdJZj1cIiFwbGF5aW5nXCIgKGNsaWNrKT1cInRvZ2dsZVBsYXkoKVwiPlxuICAgIDxwb2x5Z29uIHBvaW50cz1cIjAuNCwwIDAuNCw2NCA0NC42LDMyXCIgLz5cbjwvc3ZnPlxuXG48c3ZnIHZpZXdCb3g9XCIwIDAgNDMgNTYuOVwiIGNsYXNzPVwiY29udHJvbC1idXR0b25cIiB3aWR0aD1cIjIwXCIgaGVpZ2h0PVwiMjlcIiAqbmdJZj1cInBsYXlpbmdcIiAoY2xpY2spPVwidG9nZ2xlUGxheSgpXCI+XG4gICAgPHJlY3QgeT1cIjAuMVwiIHdpZHRoPVwiMTUuN1wiIGhlaWdodD1cIjU2LjlcIiAvPlxuICAgIDxyZWN0IHg9XCIyNy4zXCIgeT1cIjAuMVwiIHdpZHRoPVwiMTUuN1wiIGhlaWdodD1cIjU2LjlcIiAvPlxuPC9zdmc+XG5cbjxzdmcgdmlld0JveD1cIjAgMCA1MS41IDY0XCIgd2lkdGg9XCIxNFwiIGhlaWdodD1cIjE3XCIgY2xhc3M9XCJjb250cm9sLWJ1dHRvblwiIChjbGljayk9XCJnb1RvRW5kKClcIj5cbiAgICA8cmVjdCB4PVwiNDQuMVwiIHk9XCIwXCIgd2lkdGg9XCI3LjVcIiBoZWlnaHQ9XCI2NFwiIC8+XG4gICAgPHBvbHlnb24gcG9pbnRzPVwiMCw2NCAwLDAgNDQuMSwzMiBcIiAvPlxuPC9zdmc+XG5cbjxkaXYgY2xhc3M9XCJzcGFjZXJcIj48L2Rpdj5cblxuPHNwYW4gY2xhc3M9XCJocGUtaWNvblwiICpuZ0lmPVwibWVkaWFQbGF5ZXJTZXJ2aWNlLnR5cGUgIT09ICdhdWRpbydcIiBbY2xhc3MuaHBlLWV4cGFuZF09XCIhbWVkaWFQbGF5ZXJTZXJ2aWNlLmZ1bGxzY3JlZW5cIiBbY2xhc3MuaHBlLWNvbnRyYWN0XT1cIm1lZGlhUGxheWVyU2VydmljZS5mdWxsc2NyZWVuXCJcbiAgICAoY2xpY2spPVwic2V0RnVsbHNjcmVlbigpXCI+PC9zcGFuPlxuXG48bmctdGVtcGxhdGUgI211dGVUb29sdGlwPnt7IHZvbHVtZSA9PT0gMCA/ICdVbm11dGUnIDogJ011dGUnIH19PC9uZy10ZW1wbGF0ZT5gLFxuICAgIGhvc3Q6IHtcbiAgICAgICAgJ1tjbGFzcy5xdWlldF0nOiAncXVpZXRNb2RlIHx8IGZ1bGxzY3JlZW4nXG4gICAgfVxufSlcbmV4cG9ydCBjbGFzcyBNZWRpYVBsYXllckNvbnRyb2xzRXh0ZW5zaW9uQ29tcG9uZW50IGV4dGVuZHMgTWVkaWFQbGF5ZXJCYXNlRXh0ZW5zaW9uRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuXG4gICAgcGxheWluZzogYm9vbGVhbjtcbiAgICBxdWlldE1vZGU6IGJvb2xlYW47XG4gICAgZnVsbHNjcmVlbjogYm9vbGVhbiA9IGZhbHNlO1xuICAgIHZvbHVtZUFjdGl2ZTogYm9vbGVhbiA9IGZhbHNlO1xuICAgIHZvbHVtZURyYWdnaW5nOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBAVmlld0NoaWxkKCd2b2x1bWVJY29uJykgdm9sdW1lSWNvbjogRWxlbWVudFJlZjtcbiAgICBAVmlld0NoaWxkKCd2b2x1bWVTbGlkZXInKSB2b2x1bWVTbGlkZXI6IEVsZW1lbnRSZWY7XG4gICAgQFZpZXdDaGlsZCgndm9sdW1lQ29udGFpbmVyJykgdm9sdW1lQ29udGFpbmVyOiBFbGVtZW50UmVmO1xuXG4gICAgcHJpdmF0ZSBfdm9sdW1lOiBudW1iZXIgPSA1MDtcbiAgICBwcml2YXRlIF9wcmV2aW91c1ZvbHVtZSA9IDUwO1xuICAgIHByaXZhdGUgX29uRGVzdHJveSA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgICBnZXQgdm9sdW1lKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl92b2x1bWU7XG4gICAgfVxuXG4gICAgc2V0IHZvbHVtZSh2YWx1ZTogbnVtYmVyKSB7XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSAwICYmIHRoaXMuX3ZvbHVtZSAhPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNWb2x1bWUgPSB0aGlzLl92b2x1bWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl92b2x1bWUgPSBNYXRoLm1pbihNYXRoLm1heCh2YWx1ZSwgMCksIDEwMCk7XG4gICAgICAgIHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLnZvbHVtZSA9IHRoaXMuX3ZvbHVtZSAvIDEwMDtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5tZWRpYVBsYXllclNlcnZpY2UucGxheUV2ZW50LnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZShfID0+IHRoaXMucGxheWluZyA9IHRydWUpO1xuICAgICAgICB0aGlzLm1lZGlhUGxheWVyU2VydmljZS5wYXVzZUV2ZW50LnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZShfID0+IHRoaXMucGxheWluZyA9IGZhbHNlKTtcbiAgICAgICAgdGhpcy5tZWRpYVBsYXllclNlcnZpY2UucXVpZXRNb2RlRXZlbnQucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSkuc3Vic2NyaWJlKHF1aWV0TW9kZSA9PiB0aGlzLnF1aWV0TW9kZSA9IHF1aWV0TW9kZSk7XG4gICAgICAgIHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLnZvbHVtZUNoYW5nZUV2ZW50LnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZSh2b2x1bWUgPT4gdGhpcy52b2x1bWUgPSB2b2x1bWUgKiAxMDApO1xuICAgICAgICB0aGlzLm1lZGlhUGxheWVyU2VydmljZS5pbml0RXZlbnQucGlwZShkZWJvdW5jZVRpbWUoMSksIGZpbHRlcihpbml0ID0+IGluaXQgPT09IHRydWUpLCB0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSkuc3Vic2NyaWJlKCgpID0+IHRoaXMudm9sdW1lID0gdGhpcy5tZWRpYVBsYXllclNlcnZpY2Uudm9sdW1lICogMTAwKTtcbiAgICAgICAgdGhpcy5tZWRpYVBsYXllclNlcnZpY2UuZnVsbHNjcmVlbkV2ZW50LnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZShmdWxsc2NyZWVuID0+IHRoaXMuZnVsbHNjcmVlbiA9IGZ1bGxzY3JlZW4pO1xuXG4gICAgICAgIGNvbnN0IG1vdXNlZW50ZXIkID0gZnJvbUV2ZW50KHRoaXMudm9sdW1lSWNvbi5uYXRpdmVFbGVtZW50LCAnbW91c2VlbnRlcicpO1xuICAgICAgICBjb25zdCBtb3VzZWVudGVyQ29udGFpbmVyJCA9IGZyb21FdmVudCh0aGlzLnZvbHVtZUNvbnRhaW5lci5uYXRpdmVFbGVtZW50LCAnbW91c2VlbnRlcicpO1xuICAgICAgICBjb25zdCBtb3VzZWxlYXZlQ29udGFpbmVyJCA9IGZyb21FdmVudCh0aGlzLnZvbHVtZUNvbnRhaW5lci5uYXRpdmVFbGVtZW50LCAnbW91c2VsZWF2ZScpO1xuXG4gICAgICAgIG1vdXNlZW50ZXIkLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZSgoKSA9PiB0aGlzLnZvbHVtZUFjdGl2ZSA9IHRydWUpO1xuICAgICAgICBtb3VzZWxlYXZlQ29udGFpbmVyJC5waXBlKFxuICAgICAgICAgICAgc3dpdGNoTWFwKCgpID0+IHRpbWVyKDE1MDApLnBpcGUodGFrZVVudGlsKG1vdXNlZW50ZXJDb250YWluZXIkKSkpLFxuICAgICAgICAgICAgdGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSlcbiAgICAgICAgKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy52b2x1bWVBY3RpdmUgPSBmYWxzZSk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX29uRGVzdHJveS5uZXh0KCk7XG4gICAgICAgIHRoaXMuX29uRGVzdHJveS5jb21wbGV0ZSgpO1xuICAgIH1cblxuICAgIHRvZ2dsZU11dGUoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLnZvbHVtZSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy52b2x1bWUgPSB0aGlzLl9wcmV2aW91c1ZvbHVtZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudm9sdW1lID0gMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRvZ2dsZVBsYXkoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLnBsYXlpbmcpIHtcbiAgICAgICAgICAgIHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLnBhdXNlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1lZGlhUGxheWVyU2VydmljZS5wbGF5KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRGdWxsc2NyZWVuKCk6IHZvaWQge1xuICAgICAgICB0aGlzLm1lZGlhUGxheWVyU2VydmljZS50b2dnbGVGdWxsc2NyZWVuKCk7XG4gICAgfVxuXG4gICAgZ29Ub1N0YXJ0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLm1lZGlhUGxheWVyU2VydmljZS5jdXJyZW50VGltZSA9IDA7XG4gICAgfVxuXG4gICAgZ29Ub0VuZCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5tZWRpYVBsYXllclNlcnZpY2UuY3VycmVudFRpbWUgPSB0aGlzLm1lZGlhUGxheWVyU2VydmljZS5kdXJhdGlvbjtcbiAgICB9XG5cbiAgICBkcmFnU3RhcnQoZXZlbnQ6IE1vdXNlRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy52b2x1bWVEcmFnZ2luZyA9IHRydWU7XG5cbiAgICAgICAgY29uc3QgdGh1bWIgPSBldmVudC50YXJnZXQgYXMgSFRNTERpdkVsZW1lbnQ7XG4gICAgICAgIHRodW1iLmZvY3VzKCk7XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcignZG9jdW1lbnQ6bW91c2Vtb3ZlJywgWyckZXZlbnQnXSlcbiAgICBkcmFnTW92ZShldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xuICAgICAgICBpZiAoIXRoaXMudm9sdW1lRHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgY29uc3Qgc2xpZGVyID0gdGhpcy52b2x1bWVTbGlkZXIubmF0aXZlRWxlbWVudCBhcyBIVE1MRGl2RWxlbWVudDtcbiAgICAgICAgY29uc3QgYm91bmRzID0gc2xpZGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgIGNvbnN0IHggPSBNYXRoLm1pbihib3VuZHMud2lkdGgsIE1hdGgubWF4KDAsIGV2ZW50LnBhZ2VYIC0gYm91bmRzLmxlZnQpKTtcblxuICAgICAgICAvLyBjb252ZXJ0IHRvIGEgcGVyY2VudGFnZVxuICAgICAgICB0aGlzLnZvbHVtZSA9ICh4IC8gYm91bmRzLndpZHRoKSAqIDEwMDtcbiAgICB9XG5cbiAgICBASG9zdExpc3RlbmVyKCdkb2N1bWVudDptb3VzZXVwJylcbiAgICBkcmFnRW5kKCk6IHZvaWQge1xuICAgICAgICB0aGlzLnZvbHVtZURyYWdnaW5nID0gZmFsc2U7XG4gICAgfVxuXG59IiwiaW1wb3J0IHsgUGlwZSwgUGlwZVRyYW5zZm9ybSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5AUGlwZSh7XG4gICAgbmFtZTogJ2R1cmF0aW9uJ1xufSlcbmV4cG9ydCBjbGFzcyBEdXJhdGlvblBpcGUgaW1wbGVtZW50cyBQaXBlVHJhbnNmb3JtIHtcbiAgICBcbiAgICB0cmFuc2Zvcm0oc2Vjb25kczogbnVtYmVyKTogYW55IHtcblxuICAgICAgICBsZXQgbWludXRlcyA9IE1hdGguZmxvb3Ioc2Vjb25kcyAvIDYwKTtcbiAgICAgICAgbGV0IGhvdXJzID0gTWF0aC5mbG9vcihtaW51dGVzIC8gNjApO1xuICAgICAgICBsZXQgZGF5cyA9IE1hdGguZmxvb3IoaG91cnMgLyAyNCk7XG5cbiAgICAgICAgaG91cnMgPSBob3VycyAtIChkYXlzICogMjQpO1xuICAgICAgICBtaW51dGVzID0gbWludXRlcyAtIChkYXlzICogMjQgKiA2MCkgLSAoaG91cnMgKiA2MCk7XG4gICAgICAgIHNlY29uZHMgPSBNYXRoLmZsb29yKHNlY29uZHMgLSAoZGF5cyAqIDI0ICogNjAgKiA2MCkgLSAoaG91cnMgKiA2MCAqIDYwKSAtIChtaW51dGVzICogNjApKTtcblxuICAgICAgICBpZiAoaG91cnMgPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7dGhpcy5wYWQoaG91cnMpfToke3RoaXMucGFkKG1pbnV0ZXMpfToke3RoaXMucGFkKHNlY29uZHMpfWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7dGhpcy5wYWQobWludXRlcyl9OiR7dGhpcy5wYWQoc2Vjb25kcyl9YDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHBhZCh2YWx1ZTogbnVtYmVyKTogc3RyaW5nIHtcbiAgICAgICAgaWYgKHZhbHVlIDwgMTApIHtcbiAgICAgICAgICAgIHJldHVybiBgMCR7dmFsdWV9YDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBEdXJhdGlvblBpcGUgfSBmcm9tICcuL2R1cmF0aW9uLnBpcGUnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGV4cG9ydHM6IFtEdXJhdGlvblBpcGVdLFxuICAgIGRlY2xhcmF0aW9uczogW0R1cmF0aW9uUGlwZV1cbn0pXG5leHBvcnQgY2xhc3MgRHVyYXRpb25QaXBlTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgUGlwZSwgUGlwZVRyYW5zZm9ybSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5AUGlwZSh7XG4gICAgbmFtZTogJ2ZpbGVTaXplJ1xufSlcbmV4cG9ydCBjbGFzcyBGaWxlU2l6ZVBpcGUgaW1wbGVtZW50cyBQaXBlVHJhbnNmb3JtIHtcblxuICAgIHRyYW5zZm9ybSh2YWx1ZTogbnVtYmVyKTogYW55IHtcblxuICAgICAgICAvLyBhbGxvdyBmb3IgYXN5bmMgdmFsdWVzXG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgbGV0IHVuaXRzID0gWydCJywgJ0tCJywgJ01CJywgJ0dCJywgJ1RCJ107XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSB3aGljaCB1bml0IGJyYWNrZXQgdGhlIHZhbHVlcyBzaG91bGQgYmUgYSBwYXJ0IG9mXG4gICAgICAgIGxldCBpZHggPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGgubG9nKDEwMjQpKTtcbiAgICAgICAgbGV0IGZvcm1hdHRlZFZhbHVlID0gdmFsdWUgLyBNYXRoLnBvdygxMDI0LCBpZHgpO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGAke2Zvcm1hdHRlZFZhbHVlLnRvRml4ZWQoMil9ICR7dW5pdHNbaWR4XX1gO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBGaWxlU2l6ZVBpcGUgfSBmcm9tICcuL2ZpbGUtc2l6ZS5waXBlJztcblxuQE5nTW9kdWxlKHtcbiAgICBleHBvcnRzOiBbRmlsZVNpemVQaXBlXSxcbiAgICBkZWNsYXJhdGlvbnM6IFtGaWxlU2l6ZVBpcGVdXG59KVxuZXhwb3J0IGNsYXNzIEZpbGVTaXplUGlwZU1vZHVsZSB7IH1cbiIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuXG5pbXBvcnQgeyBNZWRpYVBsYXllckNvbXBvbmVudCB9IGZyb20gJy4vbWVkaWEtcGxheWVyLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBNZWRpYVBsYXllclRpbWVsaW5lRXh0ZW5zaW9uQ29tcG9uZW50IH0gZnJvbSAnLi9leHRlbnNpb25zL3RpbWVsaW5lL3RpbWVsaW5lLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBNZWRpYVBsYXllckJhc2VFeHRlbnNpb25EaXJlY3RpdmUgfSBmcm9tICcuL2V4dGVuc2lvbnMvYmFzZS1leHRlbnNpb24uZGlyZWN0aXZlJztcbmltcG9ydCB7IE1lZGlhUGxheWVyQ29udHJvbHNFeHRlbnNpb25Db21wb25lbnQgfSBmcm9tICcuL2V4dGVuc2lvbnMvY29udHJvbHMvY29udHJvbHMuY29tcG9uZW50JztcbmltcG9ydCB7IEZyYW1lRXh0cmFjdGlvbk1vZHVsZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2ZyYW1lLWV4dHJhY3Rpb24vZnJhbWUtZXh0cmFjdGlvbi5tb2R1bGUnO1xuaW1wb3J0IHsgQXVkaW9TZXJ2aWNlTW9kdWxlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvYXVkaW8vaW5kZXgnO1xuaW1wb3J0IHsgRHVyYXRpb25QaXBlTW9kdWxlIH0gZnJvbSAnLi4vLi4vcGlwZXMvZHVyYXRpb24vaW5kZXgnO1xuaW1wb3J0IHsgRmlsZVNpemVQaXBlTW9kdWxlIH0gZnJvbSAnLi4vLi4vcGlwZXMvZmlsZS1zaXplL2luZGV4JztcbmltcG9ydCB7IE1lZGlhUGxheWVyU2VydmljZSB9IGZyb20gJy4vbWVkaWEtcGxheWVyLnNlcnZpY2UnO1xuaW1wb3J0IHsgVG9vbHRpcE1vZHVsZSB9IGZyb20gJy4uL3Rvb2x0aXAvaW5kZXgnO1xuXG5jb25zdCBERUNMQVJBVElPTlMgPSBbXG4gICAgTWVkaWFQbGF5ZXJDb21wb25lbnQsXG4gICAgTWVkaWFQbGF5ZXJUaW1lbGluZUV4dGVuc2lvbkNvbXBvbmVudCxcbiAgICBNZWRpYVBsYXllckJhc2VFeHRlbnNpb25EaXJlY3RpdmUsXG4gICAgTWVkaWFQbGF5ZXJDb250cm9sc0V4dGVuc2lvbkNvbXBvbmVudFxuXTtcblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgRnJhbWVFeHRyYWN0aW9uTW9kdWxlLFxuICAgICAgICBUb29sdGlwTW9kdWxlLFxuICAgICAgICBBdWRpb1NlcnZpY2VNb2R1bGUsXG4gICAgICAgIER1cmF0aW9uUGlwZU1vZHVsZSxcbiAgICAgICAgRmlsZVNpemVQaXBlTW9kdWxlXG4gICAgXSxcbiAgICBleHBvcnRzOiBERUNMQVJBVElPTlMsXG4gICAgZGVjbGFyYXRpb25zOiBERUNMQVJBVElPTlMsXG4gICAgcHJvdmlkZXJzOiBbTWVkaWFQbGF5ZXJTZXJ2aWNlXVxufSlcbmV4cG9ydCBjbGFzcyBNZWRpYVBsYXllck1vZHVsZSB7IH1cbiIsImltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1uYXZpZ2F0aW9uJyxcbiAgICB0ZW1wbGF0ZTogYDxuYXYgY2xhc3M9XCJ0cmVlXCIgcm9sZT1cIm5hdmlnYXRpb25cIj5cbiAgICA8b2wgY2xhc3M9XCJuYXZcIj5cbiAgICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgIDwvb2w+XG48L25hdj5cbmBcbn0pXG5leHBvcnQgY2xhc3MgTmF2aWdhdGlvbkNvbXBvbmVudCB7XG5cbn0iLCJpbXBvcnQgeyBBZnRlckNvbnRlbnRJbml0LCBBZnRlclZpZXdJbml0LCBDb21wb25lbnQsIENvbnRlbnRDaGlsZHJlbiwgRWxlbWVudFJlZiwgSG9zdEJpbmRpbmcsIElucHV0LCBPbkRlc3Ryb3ksIE9wdGlvbmFsLCBRdWVyeUxpc3QsIFJlbmRlcmVyMiwgU2tpcFNlbGYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEFjdGl2YXRlZFJvdXRlLCBOYXZpZ2F0aW9uRW5kLCBSb3V0ZXIsIFVybFRyZWUgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuaW1wb3J0IHsgZmlsdGVyIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcy9TdWJzY3JpcHRpb24nO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ1t1eC1uYXZpZ2F0aW9uLWl0ZW1dJyxcbiAgICB0ZW1wbGF0ZTogYDxhICpuZ0lmPVwibGlua1wiIFtjbGFzcy5oYXMtYXJyb3ddPVwiY2hpbGRyZW4ubGVuZ3RoID4gMFwiIFtjbGFzcy5uby1hcnJvd109XCJpbmRlbnRXaXRob3V0QXJyb3dcIiBbcm91dGVyTGlua109XCJsaW5rXCI+XG4gICAgPHNwYW4+e3toZWFkZXJ9fTwvc3Bhbj5cbjwvYT5cbjxhICpuZ0lmPVwiIWxpbmtcIiAoY2xpY2spPVwiZXhwYW5kZWQgPSAhZXhwYW5kZWRcIiBbY2xhc3MuaGFzLWFycm93XT1cImNoaWxkcmVuLmxlbmd0aCA+IDBcIiBbY2xhc3Mubm8tYXJyb3ddPVwiaW5kZW50V2l0aG91dEFycm93XCI+XG4gICAgPHNwYW4+e3toZWFkZXJ9fTwvc3Bhbj5cbjwvYT5cbjxuZy1jb250ZW50PjwvbmctY29udGVudD5cbmAsXG59KVxuZXhwb3J0IGNsYXNzIE5hdmlnYXRpb25JdGVtQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCwgQWZ0ZXJDb250ZW50SW5pdCwgT25EZXN0cm95IHtcblxuICAgIEBJbnB1dCgpIGhlYWRlcjogc3RyaW5nO1xuICAgIEBJbnB1dCgpIGljb246IHN0cmluZztcbiAgICBASW5wdXQoKSBsaW5rOiBzdHJpbmc7XG4gICAgQElucHV0KCkgQEhvc3RCaW5kaW5nKCdjbGFzcy5zZWxlY3RlZCcpIGV4cGFuZGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmFjdGl2ZScpXG4gICAgZ2V0IGFjdGl2ZSgpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKHRoaXMubGluaykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JvdXRlci5pc0FjdGl2ZSh0aGlzLmxpbmssIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbGV2ZWw6IG51bWJlciA9IDE7XG4gICAgaW5kZW50V2l0aG91dEFycm93OiBib29sZWFuID0gdHJ1ZTtcblxuICAgIHByaXZhdGUgX25hdmlnYXRpb25FbmQ6IFN1YnNjcmlwdGlvbjtcbiAgICBwcml2YXRlIF9jaGlsZHJlbkNoYW5nZXM6IFN1YnNjcmlwdGlvbjtcblxuICAgIEBDb250ZW50Q2hpbGRyZW4oTmF2aWdhdGlvbkl0ZW1Db21wb25lbnQsIHsgZGVzY2VuZGFudHM6IHRydWUgfSlcbiAgICBwcml2YXRlIF9jaGlsZHJlbjogUXVlcnlMaXN0PE5hdmlnYXRpb25JdGVtQ29tcG9uZW50PjtcblxuICAgIGdldCBjaGlsZHJlbigpOiBOYXZpZ2F0aW9uSXRlbUNvbXBvbmVudFtdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuLmZpbHRlcihpdGVtID0+IGl0ZW0gIT09IHRoaXMpO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgICAgICBwcml2YXRlIF9yZW5kZXJlcjogUmVuZGVyZXIyLFxuICAgICAgICBAT3B0aW9uYWwoKSBAU2tpcFNlbGYoKSBwcml2YXRlIF9wYXJlbnQ6IE5hdmlnYXRpb25JdGVtQ29tcG9uZW50LFxuICAgICAgICBwcml2YXRlIF9yb3V0ZXI6IFJvdXRlcixcbiAgICAgICAgcHJpdmF0ZSBfYWN0aXZhdGVkUm91dGU6IEFjdGl2YXRlZFJvdXRlXG4gICAgKSB7XG4gICAgICAgIHRoaXMubGV2ZWwgPSBfcGFyZW50ID8gX3BhcmVudC5sZXZlbCArIDEgOiAxO1xuXG4gICAgICAgIHRoaXMuX25hdmlnYXRpb25FbmQgPSBfcm91dGVyLmV2ZW50cy5waXBlKGZpbHRlcihldmVudCA9PiBldmVudCBpbnN0YW5jZW9mIE5hdmlnYXRpb25FbmQpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLmV4cGFuZGVkID0gdGhpcy5oYXNBY3RpdmVMaW5rKHRoaXMubGluaykpO1xuICAgIH1cblxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkIHtcbiAgICAgICAgLy8gQWRkIGNsYXNzZXMgdG8gcGFyZW50IGZvciBzdHlsaW5nXG4gICAgICAgIGNvbnN0IHBhcmVudExpc3RFbGVtZW50ID0gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgICAgIGlmIChwYXJlbnRMaXN0RWxlbWVudCkge1xuICAgICAgICAgICAgY29uc3QgbGV2ZWxDbGFzczogc3RyaW5nID0gdGhpcy5nZXRMZXZlbENsYXNzKCk7XG4gICAgICAgICAgICBpZiAobGV2ZWxDbGFzcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuYWRkQ2xhc3MocGFyZW50TGlzdEVsZW1lbnQsICduYXYnKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5hZGRDbGFzcyhwYXJlbnRMaXN0RWxlbWVudCwgbGV2ZWxDbGFzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZCB7XG4gICAgICAgIC8vIFNldCAnaW5kZW50V2l0aG91dEFycm93J1xuICAgICAgICB0aGlzLnNldEluZGVudFdpdGhvdXRBcnJvdygpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSAnaW5kZW50V2l0aG91dEFycm93JyBpbiByZXNwb25zZSB0byBjaGFuZ2VzIHRvIGNoaWxkcmVuXG4gICAgICAgIHRoaXMuX2NoaWxkcmVuQ2hhbmdlcyA9IHRoaXMuX2NoaWxkcmVuLmNoYW5nZXMuc3Vic2NyaWJlKCgpID0+IHRoaXMuc2V0SW5kZW50V2l0aG91dEFycm93KCkpO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9uYXZpZ2F0aW9uRW5kLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuX2NoaWxkcmVuQ2hhbmdlcy51bnN1YnNjcmliZSgpO1xuICAgIH1cblxuICAgIHByaXZhdGUgaGFzQWN0aXZlTGluayhsaW5rOiBzdHJpbmcgfCBVcmxUcmVlKTogYm9vbGVhbiB7XG5cbiAgICAgICAgY29uc3QgdHJlZSA9IHRoaXMuX3JvdXRlci5jcmVhdGVVcmxUcmVlKFtsaW5rXSwge1xuICAgICAgICAgICAgcmVsYXRpdmVUbzogdGhpcy5fYWN0aXZhdGVkUm91dGUsXG4gICAgICAgICAgICBxdWVyeVBhcmFtczogdGhpcy5fYWN0aXZhdGVkUm91dGUuc25hcHNob3QucXVlcnlQYXJhbXMsXG4gICAgICAgICAgICBmcmFnbWVudDogdGhpcy5fYWN0aXZhdGVkUm91dGUuc25hcHNob3QuZnJhZ21lbnRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGxpbmsgJiYgdGhpcy5fcm91dGVyLmlzQWN0aXZlKHRyZWUsIHRydWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoaXMgY29tcG9uZW50IGhhcyBjaGlsZHJlbiwgY2hlY2sgaWYgYW55IG9mIHRoZW0sIG9yIHRoZWlyIGRlc2NlbmRhbnRzLCBhcmUgYWN0aXZlLlxuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5zb21lKChpdGVtKSA9PiBpdGVtLmhhc0FjdGl2ZUxpbmsoaXRlbS5saW5rKSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRMZXZlbENsYXNzKCk6IHN0cmluZyB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5sZXZlbCkge1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiAnbmF2LXNlY29uZC1sZXZlbCc7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgcmV0dXJuICduYXYtdGhpcmQtbGV2ZWwnO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIHJldHVybiAnbmF2LWZvdXJ0aC1sZXZlbCc7XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgcmV0dXJuICduYXYtZmlmdGgtbGV2ZWwnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIHByaXZhdGUgc2V0SW5kZW50V2l0aG91dEFycm93KCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIGVsZW1lbnQgaGFzIGNoaWxkcmVuIGl0IHdpbGwgYmUgaW5kZW50ZWQgYW5kIHdpbGwgaGF2ZSBhbiBhcnJvd1xuICAgICAgICAgICAgdGhpcy5pbmRlbnRXaXRob3V0QXJyb3cgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9wYXJlbnQpIHtcbiAgICAgICAgICAgLy8gSWYgdGhpcyBlbGVtZW50IGhhcyBhIHBhcmVudCwgaW5kZW50IGl0IGlmIGFueSBvZiBpdHMgc2libGluZ3MgaGF2ZSBjaGlsZHJlblxuICAgICAgICAgICAgdGhpcy5pbmRlbnRXaXRob3V0QXJyb3cgPSAhdGhpcy5fcGFyZW50LmNoaWxkcmVuLmV2ZXJ5KChpdGVtKSA9PiBpdGVtLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUb3AtbGV2ZWwgZWxlbWVudHMgc2hvdWxkIGJlIGluZGVudGVkXG4gICAgICAgICAgICB0aGlzLmluZGVudFdpdGhvdXRBcnJvdyA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IFJvdXRlck1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7XG5pbXBvcnQgeyBOYXZpZ2F0aW9uQ29tcG9uZW50IH0gZnJvbSAnLi9uYXZpZ2F0aW9uLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBOYXZpZ2F0aW9uSXRlbUNvbXBvbmVudCB9IGZyb20gJy4vbmF2aWdhdGlvbi1pdGVtL25hdmlnYXRpb24taXRlbS5jb21wb25lbnQnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBSb3V0ZXJNb2R1bGVcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgTmF2aWdhdGlvbkNvbXBvbmVudCxcbiAgICAgICAgTmF2aWdhdGlvbkl0ZW1Db21wb25lbnRcbiAgICBdLFxuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBOYXZpZ2F0aW9uQ29tcG9uZW50LFxuICAgICAgICBOYXZpZ2F0aW9uSXRlbUNvbXBvbmVudFxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgTmF2aWdhdGlvbk1vZHVsZSB7IH1cbiIsImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbG9yQ2xhc3NTZXQsIENvbG9yVmFsdWVTZXQgfSBmcm9tICcuL2NvbG9yLnNlcnZpY2UnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgQ29sb3JTZXJ2aWNlIHtcblxuICAgIHByaXZhdGUgX2h0bWw6IHN0cmluZztcbiAgICBwcml2YXRlIF9lbGVtZW50OiBIVE1MRWxlbWVudDtcbiAgICBwcml2YXRlIF9jb2xvcnM6IFRoZW1lQ29sb3JzO1xuICAgIHByaXZhdGUgX2NvbG9yU2V0OiBhbnkgPSBjb2xvclNldHMua2VwcGVsO1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jb2xvclNldC5jb2xvckNsYXNzU2V0KSB7XG4gICAgICAgICAgICB0aGlzLnNldENvbG9ycygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIHRoaXMuX2NvbG9yU2V0LmNvbG9yVmFsdWVTZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb2xvcnNba2V5XSA9IHRoaXMuZ2V0Q29sb3JWYWx1ZUJ5SGV4KHRoaXMuX2NvbG9yU2V0LmNvbG9yVmFsdWVTZXRba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHNldENvbG9ycygpIHtcblxuICAgICAgICB0aGlzLl9odG1sID0gJyc7XG5cbiAgICAgICAgZm9yIChsZXQga2V5IGluIHRoaXMuX2NvbG9yU2V0LmNvbG9yQ2xhc3NTZXQpIHtcbiAgICAgICAgICAgIHRoaXMuX2h0bWwgKz0gJzxkaXYgY2xhc3M9XCInICsgdGhpcy5fY29sb3JTZXQuY29sb3JDbGFzc1NldFtrZXldICsgJy1jb2xvclwiPjwvZGl2Pic7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9lbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NOYW1lID0gJ2NvbG9yLWNoYXJ0JztcbiAgICAgICAgdGhpcy5fZWxlbWVudC5pbm5lckhUTUwgPSB0aGlzLl9odG1sO1xuXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5fZWxlbWVudCk7XG5cbiAgICAgICAgdGhpcy5fY29sb3JzID0ge307XG5cbiAgICAgICAgZm9yIChsZXQga2V5IGluIHRoaXMuX2NvbG9yU2V0LmNvbG9yQ2xhc3NTZXQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbG9yc1trZXldID0gdGhpcy5nZXRDb2xvclZhbHVlKHRoaXMuX2NvbG9yU2V0LmNvbG9yQ2xhc3NTZXRba2V5XSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5fZWxlbWVudCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRDb2xvclZhbHVlQnlIZXgoY29sb3I6IHN0cmluZyk6IFRoZW1lQ29sb3Ige1xuICAgICAgICBjb25zdCBoZXggPSBjb2xvci5yZXBsYWNlKCcjJywgJycpO1xuXG4gICAgICAgIGNvbnN0IHIgPSBwYXJzZUludChoZXguc3Vic3RyaW5nKDAsIDIpLCAxNikudG9TdHJpbmcoKTtcbiAgICAgICAgY29uc3QgZyA9IHBhcnNlSW50KGhleC5zdWJzdHJpbmcoMiwgNCksIDE2KS50b1N0cmluZygpO1xuICAgICAgICBjb25zdCBiID0gcGFyc2VJbnQoaGV4LnN1YnN0cmluZyg0LCA2KSwgMTYpLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBUaGVtZUNvbG9yKHIsIGcsIGIsICcxJyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRDb2xvclZhbHVlKGNvbG9yOiBDb2xvcklkZW50aWZpZXIpOiBUaGVtZUNvbG9yIHtcblxuICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLl9lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy4nICsgdGhpcy5fY29sb3JTZXQuY29sb3JDbGFzc1NldFtjb2xvcl0gKyAnLWNvbG9yJyk7XG5cbiAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2xvcicpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY29sb3JWYWx1ZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRhcmdldCkuYmFja2dyb3VuZENvbG9yO1xuXG4gICAgICAgIGNvbnN0IHJnYmEgPSBjb2xvclZhbHVlLm1hdGNoKC9ecmdiYT9cXCgoXFxkKyksXFxzKihcXGQrKSxcXHMqKFxcZCspKD86LFxccyooXFxkKyg/OlxcLlxcZCspPykpP1xcKSQvKTtcblxuICAgICAgICByZXR1cm4gbmV3IFRoZW1lQ29sb3IocmdiYVsxXSwgcmdiYVsyXSwgcmdiYVszXSwgcmdiYVs0XSk7XG4gICAgfVxuXG4gICAgZ2V0Q29sb3IoY29sb3I6IENvbG9ySWRlbnRpZmllcik6IFRoZW1lQ29sb3Ige1xuICAgICAgICBjb25zdCB0aGVtZUNvbG9yID0gdGhpcy5fY29sb3JzW3RoaXMucmVzb2x2ZUNvbG9yTmFtZShjb2xvcildO1xuICAgICAgICBpZiAoIXRoZW1lQ29sb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29sb3Igbm90IGZvdW5kOiAnICsgY29sb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBUaGVtZUNvbG9yKHRoZW1lQ29sb3IuZ2V0UmVkKCksIHRoZW1lQ29sb3IuZ2V0R3JlZW4oKSwgdGhlbWVDb2xvci5nZXRCbHVlKCksIHRoZW1lQ29sb3IuZ2V0QWxwaGEoKSk7XG4gICAgfVxuXG4gICAgZ2V0Q29sb3JTZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2xvclNldDtcbiAgICB9XG5cbiAgICBzZXRDb2xvclNldChjb2xvclNldDogQ29sb3JTZXQpIHtcbiAgICAgICAgdGhpcy5fY29sb3JTZXQgPSBjb2xvclNldDtcbiAgICAgICAgdGhpcy5fY29sb3JzID0ge307XG5cbiAgICAgICAgaWYgKHRoaXMuX2NvbG9yU2V0LmNvbG9yQ2xhc3NTZXQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q29sb3JzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gdGhpcy5fY29sb3JTZXQuY29sb3JWYWx1ZVNldCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbG9yc1trZXldID0gdGhpcy5nZXRDb2xvclZhbHVlQnlIZXgodGhpcy5fY29sb3JTZXQuY29sb3JWYWx1ZVNldFtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlc29sdmUodmFsdWU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvbG9yTmFtZSA9IHRoaXMucmVzb2x2ZUNvbG9yTmFtZSh2YWx1ZSk7XG5cbiAgICAgICAgZm9yIChsZXQgY29sb3IgaW4gdGhpcy5fY29sb3JzKSB7XG4gICAgICAgICAgICBpZiAoY29sb3JOYW1lID09PSBjb2xvci50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29sb3IoY29sb3JOYW1lKS50b1JnYmEoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXNvbHZlQ29sb3JOYW1lKHZhbHVlOiBzdHJpbmcgPSAnJyk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKC9cXHMrL2csICctJykudG9Mb3dlckNhc2UoKTtcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBUaGVtZUNvbG9yIHtcblxuICAgIHByaXZhdGUgX3I6IHN0cmluZztcbiAgICBwcml2YXRlIF9nOiBzdHJpbmc7XG4gICAgcHJpdmF0ZSBfYjogc3RyaW5nO1xuICAgIHByaXZhdGUgX2E6IHN0cmluZztcblxuICAgIGNvbnN0cnVjdG9yKHI6IHN0cmluZywgZzogc3RyaW5nLCBiOiBzdHJpbmcsIGE6IHN0cmluZykge1xuICAgICAgICB0aGlzLl9yID0gcjtcbiAgICAgICAgdGhpcy5fZyA9IGc7XG4gICAgICAgIHRoaXMuX2IgPSBiO1xuICAgICAgICB0aGlzLl9hID0gYSA9PT0gdW5kZWZpbmVkID8gJzEnIDogYTtcbiAgICB9XG5cbiAgICBzdGF0aWMgcGFyc2UodmFsdWU6IHN0cmluZyk6IFRoZW1lQ29sb3Ige1xuICAgICAgICBsZXQgciwgZywgYiwgYSA9ICcxJztcblxuICAgICAgICBjb25zdCByZ2JhUGF0dGVybiA9IC9ecmdiYT9cXCgoXFxkKyksXFxzKihcXGQrKSxcXHMqKFxcZCspKD86LFxccyooXFxkKyg/OlxcLlxcZCspPykpP1xcKSQvO1xuICAgICAgICBjb25zdCBzaG9ydEhleFBhdHRlcm4gPSAvXiM/KFthLWZcXGRdKShbYS1mXFxkXSkoW2EtZlxcZF0pJC9pO1xuICAgICAgICBjb25zdCBsb25nSGV4UGF0dGVybiA9IC9eIz8oW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkkLztcblxuICAgICAgICBjb25zdCByZ2JhTWF0Y2ggPSB2YWx1ZS5tYXRjaChyZ2JhUGF0dGVybik7XG4gICAgICAgIGNvbnN0IHNob3J0SGV4TWF0Y2ggPSB2YWx1ZS5tYXRjaChzaG9ydEhleFBhdHRlcm4pO1xuICAgICAgICBjb25zdCBsb25nSGV4TWF0Y2ggPSB2YWx1ZS5tYXRjaChsb25nSGV4UGF0dGVybik7XG5cbiAgICAgICAgaWYgKHJnYmFNYXRjaCkge1xuICAgICAgICAgICAgciA9IHJnYmFNYXRjaFsxXTtcbiAgICAgICAgICAgIGcgPSByZ2JhTWF0Y2hbMl07XG4gICAgICAgICAgICBiID0gcmdiYU1hdGNoWzNdO1xuICAgICAgICAgICAgYSA9IHJnYmFNYXRjaFs0XSA/IHJnYmFNYXRjaFs0XSA6ICcxJztcbiAgICAgICAgfSBlbHNlIGlmIChsb25nSGV4TWF0Y2gpIHtcbiAgICAgICAgICAgIHIgPSBwYXJzZUludChsb25nSGV4TWF0Y2hbMV0sIDE2KS50b1N0cmluZygpO1xuICAgICAgICAgICAgZyA9IHBhcnNlSW50KGxvbmdIZXhNYXRjaFsyXSwgMTYpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBiID0gcGFyc2VJbnQobG9uZ0hleE1hdGNoWzNdLCAxNikudG9TdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIGlmIChzaG9ydEhleE1hdGNoKSB7XG4gICAgICAgICAgICByID0gcGFyc2VJbnQoc2hvcnRIZXhNYXRjaFsxXSArIHNob3J0SGV4TWF0Y2hbMV0sIDE2KS50b1N0cmluZygpO1xuICAgICAgICAgICAgZyA9IHBhcnNlSW50KHNob3J0SGV4TWF0Y2hbMl0gKyBzaG9ydEhleE1hdGNoWzJdLCAxNikudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGIgPSBwYXJzZUludChzaG9ydEhleE1hdGNoWzNdICsgc2hvcnRIZXhNYXRjaFszXSwgMTYpLnRvU3RyaW5nKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBwYXJzZSBjb2xvciAtICR7dmFsdWV9IGlzIG5vdCBhIHZhbGlkIGNvbG9yLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVGhlbWVDb2xvcihyLCBnLCBiLCBhKTtcbiAgICB9XG5cbiAgICB0b0hleCgpIHtcbiAgICAgICAgbGV0IHJlZCA9IHBhcnNlSW50KHRoaXMuX3IpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgbGV0IGdyZWVuID0gcGFyc2VJbnQodGhpcy5fZykudG9TdHJpbmcoMTYpO1xuICAgICAgICBsZXQgYmx1ZSA9IHBhcnNlSW50KHRoaXMuX2IpLnRvU3RyaW5nKDE2KTtcblxuICAgICAgICBpZiAocmVkLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHJlZCA9ICcwJyArIHJlZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JlZW4ubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgZ3JlZW4gPSAnMCcgKyBncmVlbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmx1ZS5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICBibHVlID0gJzAnICsgYmx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAnIycgKyByZWQgKyBncmVlbiArIGJsdWU7XG4gICAgfVxuXG4gICAgdG9SZ2IoKSB7XG4gICAgICAgIHJldHVybiAncmdiKCcgKyB0aGlzLl9yICsgJywgJyArIHRoaXMuX2cgKyAnLCAnICsgdGhpcy5fYiArICcpJztcbiAgICB9XG5cbiAgICB0b1JnYmEoKSB7XG4gICAgICAgIHJldHVybiAncmdiYSgnICsgdGhpcy5fciArICcsICcgKyB0aGlzLl9nICsgJywgJyArIHRoaXMuX2IgKyAnLCAnICsgdGhpcy5fYSArICcpJztcbiAgICB9XG5cbiAgICBnZXRSZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yO1xuICAgIH1cblxuICAgIGdldEdyZWVuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZztcbiAgICB9XG5cbiAgICBnZXRCbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYjtcbiAgICB9XG5cbiAgICBnZXRBbHBoYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2E7XG4gICAgfVxuXG4gICAgc2V0UmVkKHJlZDogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuX3IgPSByZWQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNldEdyZWVuKGdyZWVuOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5fZyA9IGdyZWVuO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzZXRCbHVlKGJsdWU6IHN0cmluZykge1xuICAgICAgICB0aGlzLl9iID0gYmx1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc2V0QWxwaGEoYWxwaGE6IHN0cmluZyB8IG51bWJlcikge1xuICAgICAgICB0aGlzLl9hID0gYWxwaGEudG9TdHJpbmcoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuXG5leHBvcnQgY29uc3QgY29sb3JTZXRzID0ge1xuICAgIGtlcHBlbDoge1xuICAgICAgICBjb2xvckNsYXNzU2V0OiB7XG4gICAgICAgICAgICAncHJpbWFyeSc6ICdwcmltYXJ5JyxcbiAgICAgICAgICAgICdhY2NlbnQnOiAnYWNjZW50JyxcbiAgICAgICAgICAgICdzZWNvbmRhcnknOiAnc2Vjb25kYXJ5JyxcbiAgICAgICAgICAgICdhbHRlcm5hdGUxJzogJ2FsdGVybmF0ZTEnLFxuICAgICAgICAgICAgJ2FsdGVybmF0ZTInOiAnYWx0ZXJuYXRlMicsXG4gICAgICAgICAgICAnYWx0ZXJuYXRlMyc6ICdhbHRlcm5hdGUzJyxcbiAgICAgICAgICAgICd2aWJyYW50MSc6ICd2aWJyYW50MScsXG4gICAgICAgICAgICAndmlicmFudDInOiAndmlicmFudDInLFxuICAgICAgICAgICAgJ2dyZXkxJzogJ2dyZXkxJyxcbiAgICAgICAgICAgICdncmV5Mic6ICdncmV5MicsXG4gICAgICAgICAgICAnZ3JleTMnOiAnZ3JleTMnLFxuICAgICAgICAgICAgJ2dyZXk0JzogJ2dyZXk0JyxcbiAgICAgICAgICAgICdncmV5NSc6ICdncmV5NScsXG4gICAgICAgICAgICAnZ3JleTYnOiAnZ3JleTYnLFxuICAgICAgICAgICAgJ2dyZXk3JzogJ2dyZXk3JyxcbiAgICAgICAgICAgICdncmV5OCc6ICdncmV5OCcsXG4gICAgICAgICAgICAnY2hhcnQxJzogJ2NoYXJ0MScsXG4gICAgICAgICAgICAnY2hhcnQyJzogJ2NoYXJ0MicsXG4gICAgICAgICAgICAnY2hhcnQzJzogJ2NoYXJ0MycsXG4gICAgICAgICAgICAnY2hhcnQ0JzogJ2NoYXJ0NCcsXG4gICAgICAgICAgICAnY2hhcnQ1JzogJ2NoYXJ0NScsXG4gICAgICAgICAgICAnY2hhcnQ2JzogJ2NoYXJ0NicsXG4gICAgICAgICAgICAnb2snOiAnb2snLFxuICAgICAgICAgICAgJ3dhcm5pbmcnOiAnd2FybmluZycsXG4gICAgICAgICAgICAnY3JpdGljYWwnOiAnY3JpdGljYWwnLFxuICAgICAgICAgICAgJ3BhcnRpdGlvbjEnOiAncGFydGl0aW9uMScsXG4gICAgICAgICAgICAncGFydGl0aW9uOSc6ICdwYXJ0aXRpb245JyxcbiAgICAgICAgICAgICdwYXJ0aXRpb24xMCc6ICdwYXJ0aXRpb24xMCcsXG4gICAgICAgICAgICAncGFydGl0aW9uMTEnOiAncGFydGl0aW9uMTEnLFxuICAgICAgICAgICAgJ3BhcnRpdGlvbjEyJzogJ3BhcnRpdGlvbjEyJyxcbiAgICAgICAgICAgICdwYXJ0aXRpb24xMyc6ICdwYXJ0aXRpb24xMycsXG4gICAgICAgICAgICAncGFydGl0aW9uMTQnOiAncGFydGl0aW9uMTQnLFxuICAgICAgICAgICAgJ3NvY2lhbC1jaGFydC1ub2RlJzogJ3NvY2lhbC1jaGFydC1ub2RlJyxcbiAgICAgICAgICAgICdzb2NpYWwtY2hhcnQtZWRnZSc6ICdzb2NpYWwtY2hhcnQtZWRnZSdcbiAgICAgICAgfVxuICAgIH0sXG4gICAgbWljcm9Gb2N1czoge1xuICAgICAgICAnY29sb3JWYWx1ZVNldCc6IHtcbiAgICAgICAgICAgICdjZXJ1bGVhbic6ICcjMTY2OGMxJyxcbiAgICAgICAgICAgICdhcXVhJzogJyMyOWNlZmYnLFxuICAgICAgICAgICAgJ2FxdWFtYXJpbmUnOiAnIzJmZDZjMycsXG4gICAgICAgICAgICAnZnVjaHNpYSc6ICcjYzYxNzlkJyxcbiAgICAgICAgICAgICdpbmRpZ28nOiAnIzc0MjVhZCcsXG4gICAgICAgICAgICAnZGFyay1ibHVlJzogJyMyMzFjYTUnLFxuICAgICAgICAgICAgJ3doaXRlJzogJyNmZmZmZmYnLFxuICAgICAgICAgICAgJ3NsaWdodGx5LWdyYXknOiAnI2Y1ZjdmOCcsXG4gICAgICAgICAgICAnYnJpZ2h0LWdyYXknOiAnI2YxZjJmMycsXG4gICAgICAgICAgICAnZ3JheSc6ICcjZGNkZWRmJyxcbiAgICAgICAgICAgICdzaWx2ZXInOiAnI2JkYmVjMCcsXG4gICAgICAgICAgICAnZGltLWdyYXknOiAnIzY1NjY2OCcsXG4gICAgICAgICAgICAnZGFyay1ncmF5JzogJyMzMjM0MzUnLFxuICAgICAgICAgICAgJ2JsYWNrJzogJyMwMDAwMDAnLFxuICAgICAgICAgICAgJ2NyaW1zb24tbmVnYXRpdmUnOiAnI2U1MDA0YycsXG4gICAgICAgICAgICAnYXByaWNvdCc6ICcjZjQ4YjM0JyxcbiAgICAgICAgICAgICd5ZWxsb3cnOiAnI2ZjZGIxZicsXG4gICAgICAgICAgICAnZ3JlZW4tcG9zaXRpdmUnOiAnIzFhYWM2MCcsXG4gICAgICAgICAgICAndWx0cmFtYXJpbmUnOiAnIzM5MzljNicsXG4gICAgICAgICAgICAnc2t5Ymx1ZSc6ICcjMDBhYmYzJyxcbiAgICAgICAgICAgICdwYWxlLWFxdWEnOiAnIzQzZTRmZicsXG4gICAgICAgICAgICAncGFsZS1ncmVlbic6ICcjMWZmYmJhJyxcbiAgICAgICAgICAgICdsaW1lJzogJyM3NWRhNGQnLFxuICAgICAgICAgICAgJ29yYW5nZSc6ICcjZmZjZTAwJyxcbiAgICAgICAgICAgICdtYWdlbnRhJzogJyNlYjIzYzInLFxuICAgICAgICAgICAgJ3BhbGUtcHVycGxlJzogJyNiYTQ3ZTInLFxuICAgICAgICAgICAgJ2RhcmstdWx0cmFtYXJpbmUnOiAnIzI3MTc4MicsXG4gICAgICAgICAgICAnc3RlZWxibHVlJzogJyMwMTQyNzInLFxuICAgICAgICAgICAgJ2FyY3RpYy1ibHVlJzogJyMwYjhlYWMnLFxuICAgICAgICAgICAgJ2VtZXJhbGQnOiAnIzAwYTk4OScsXG4gICAgICAgICAgICAnb2xpdmUnOiAnIzViYmEzNicsXG4gICAgICAgICAgICAnZ29sZGVucm9kJzogJyNmZmIwMDAnLFxuICAgICAgICAgICAgJ3B1cnBsZSc6ICcjOWIxZTgzJyxcbiAgICAgICAgICAgICdwYWxlLWVnZ3BsYW50JzogJyM1MjE2YWMnLFxuICAgICAgICAgICAgJ3JlZCc6ICcjZmY0NTRmJyxcbiAgICAgICAgICAgICdwYWxlLWFtYmVyJzogJyNmZmIyNGQnLFxuICAgICAgICAgICAgJ3BhbGUtbGVtb24nOiAnI2ZkZTE1OScsXG4gICAgICAgICAgICAncGFsZS1lbWVyYWxkJzogJyMzM2MxODAnLFxuICAgICAgICAgICAgJ3BsdW0nOiAnI2IyMTY0NicsXG4gICAgICAgICAgICAnY29wcGVyJzogJyNlNTc4MjgnLFxuICAgICAgICAgICAgJ2FtYmVyJzogJyNmZmMwMDInLFxuICAgICAgICAgICAgJ2xlYWYtZ3JlZW4nOiAnIzExOGM0ZicsXG4gICAgICAgICAgICAnZm9yZXN0LWdyZWVuJzogJyMwMDY0NWEnLFxuICAgICAgICAgICAgJ3ByaW1hcnknOiAnIzAwNzNlNycsXG4gICAgICAgICAgICAnYWNjZW50JzogJyM3NDI1YWQnLFxuICAgICAgICAgICAgJ3NlY29uZGFyeSc6ICcjZmZmZmZmJyxcbiAgICAgICAgICAgICdhbHRlcm5hdGUxJzogJyMyOWNlZmYnLFxuICAgICAgICAgICAgJ2FsdGVybmF0ZTInOiAnIzJmZDZjMycsXG4gICAgICAgICAgICAnYWx0ZXJuYXRlMyc6ICcjYzYxNzlkJyxcbiAgICAgICAgICAgICd2aWJyYW50MSc6ICcjNDNlNGZmJyxcbiAgICAgICAgICAgICd2aWJyYW50Mic6ICcjZmZjZTAwJyxcbiAgICAgICAgICAgICdncmV5MSc6ICcjMDAwMDAwJyxcbiAgICAgICAgICAgICdncmV5Mic6ICcjMzIzNDM1JyxcbiAgICAgICAgICAgICdncmV5Myc6ICcjNjU2NjY4JyxcbiAgICAgICAgICAgICdncmV5NCc6ICcjYmRiZWMwJyxcbiAgICAgICAgICAgICdncmV5NSc6ICcjZGNkZWRmJyxcbiAgICAgICAgICAgICdncmV5Nic6ICcjZjFmMmYzJyxcbiAgICAgICAgICAgICdncmV5Nyc6ICcjZjVmN2Y4JyxcbiAgICAgICAgICAgICdncmV5OCc6ICcjZmZmZmZmJyxcbiAgICAgICAgICAgICdjaGFydDEnOiAnIzM5MzljNicsXG4gICAgICAgICAgICAnY2hhcnQyJzogJyMwMGFiZjMnLFxuICAgICAgICAgICAgJ2NoYXJ0Myc6ICcjNzVkYTRkJyxcbiAgICAgICAgICAgICdjaGFydDQnOiAnI2ZmY2UwMCcsXG4gICAgICAgICAgICAnY2hhcnQ1JzogJyNlYjIzYzInLFxuICAgICAgICAgICAgJ2NoYXJ0Nic6ICcjYmE0N2UyJyxcbiAgICAgICAgICAgICdvayc6ICcjMWFhYzYwJyxcbiAgICAgICAgICAgICd3YXJuaW5nJzogJyNmNDhiMzQnLFxuICAgICAgICAgICAgJ2NyaXRpY2FsJzogJ2U1MDA0YycsXG4gICAgICAgICAgICAncGFydGl0aW9uMSc6ICcjNzQyNWFkJyxcbiAgICAgICAgICAgICdwYXJ0aXRpb245JzogJyM1MjE2YWMnLFxuICAgICAgICAgICAgJ3BhcnRpdGlvbjEwJzogJyM1YmJhMzYnLFxuICAgICAgICAgICAgJ3BhcnRpdGlvbjExJzogJyMwMTQyNzInLFxuICAgICAgICAgICAgJ3BhcnRpdGlvbjEyJzogJyNmZmIwMDAnLFxuICAgICAgICAgICAgJ3BhcnRpdGlvbjEzJzogJyNiZGJlYzAnLFxuICAgICAgICAgICAgJ3BhcnRpdGlvbjE0JzogJyMyNzE3ODInLFxuICAgICAgICAgICAgJ3NvY2lhbC1jaGFydC1ub2RlJzogJyNmZjAwZmYnLFxuICAgICAgICAgICAgJ3NvY2lhbC1jaGFydC1lZGdlJzogJyNmZjAwZmYnXG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIFRoZW1lQ29sb3JzIHtcbiAgICBbbmFtZTogc3RyaW5nXTogVGhlbWVDb2xvcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb2xvclNldCB7XG4gICAgY29sb3JDbGFzc1NldD86IENvbG9yQ2xhc3NTZXQ7XG4gICAgY29sb3JWYWx1ZVNldD86IENvbG9yVmFsdWVTZXQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29sb3JDbGFzc1NldCB7XG4gICAgW25hbWU6IHN0cmluZ106IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb2xvclZhbHVlU2V0IHtcbiAgICBbbmFtZTogc3RyaW5nXTogc3RyaW5nO1xufVxuXG5leHBvcnQgdHlwZSBDb2xvcklkZW50aWZpZXIgPSBzdHJpbmc7XG4iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29sb3JTZXJ2aWNlIH0gZnJvbSAnLi9jb2xvci5zZXJ2aWNlJztcblxuQE5nTW9kdWxlKHtcbiAgICBwcm92aWRlcnM6IFtDb2xvclNlcnZpY2VdLFxufSlcbmV4cG9ydCBjbGFzcyBDb2xvclNlcnZpY2VNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBUZW1wbGF0ZVJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcy9CZWhhdmlvclN1YmplY3QnO1xuaW1wb3J0IHsgQ29sb3JTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvY29sb3IvaW5kZXgnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgTm90aWZpY2F0aW9uU2VydmljZSB7XG5cbiAgICAvLyBwcm92aWRlIGRlZmF1bHQgb3B0aW9uc1xuICAgIG9wdGlvbnM6IE5vdGlmaWNhdGlvbk9wdGlvbnMgPSB7XG4gICAgICAgIGR1cmF0aW9uOiA0LFxuICAgICAgICBoZWlnaHQ6IDEwMCxcbiAgICAgICAgc3BhY2luZzogMTAsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhpcy5fY29sb3JTZXJ2aWNlLmdldENvbG9yKCdhY2NlbnQnKS50b0hleCgpLFxuICAgICAgICBpY29uQ29sb3I6IHRoaXMuX2NvbG9yU2VydmljZS5nZXRDb2xvcignYWNjZW50JykudG9IZXgoKVxuICAgIH07XG5cbiAgICBkaXJlY3Rpb246IE5vdGlmaWNhdGlvbkxpc3REaXJlY3Rpb24gPSAnYWJvdmUnO1xuXG4gICAgbm90aWZpY2F0aW9ucyQ6IEJlaGF2aW9yU3ViamVjdDxOb3RpZmljYXRpb25SZWZbXT4gPSBuZXcgQmVoYXZpb3JTdWJqZWN0PE5vdGlmaWNhdGlvblJlZltdPihbXSk7ICAgIFxuXG4gICAgc2hvdyh0ZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8YW55Piwgb3B0aW9uczogTm90aWZpY2F0aW9uT3B0aW9ucyA9IHRoaXMub3B0aW9ucywgZGF0YTogeyBba2V5OiBzdHJpbmddOiBhbnkgfSA9IHt9KTogTm90aWZpY2F0aW9uUmVmIHtcblxuICAgICAgICBvcHRpb25zID0geyAuLi50aGlzLm9wdGlvbnMsIC4uLm9wdGlvbnMgfTtcblxuICAgICAgICBjb25zdCBub3RpZmljYXRpb25SZWY6IE5vdGlmaWNhdGlvblJlZiA9IHtcbiAgICAgICAgICAgIHRlbXBsYXRlUmVmOiB0ZW1wbGF0ZVJlZixcbiAgICAgICAgICAgIGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxuICAgICAgICAgICAgZGF0ZTogbmV3IERhdGUoKSxcbiAgICAgICAgICAgIHZpc2libGU6IHRydWUsXG4gICAgICAgICAgICBoZWlnaHQ6IG9wdGlvbnMuaGVpZ2h0LFxuICAgICAgICAgICAgc3BhY2luZzogb3B0aW9ucy5zcGFjaW5nLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBvcHRpb25zLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgIGljb25Db2xvcjogb3B0aW9ucy5pY29uQ29sb3IsXG4gICAgICAgICAgICBkYXRhOiBkYXRhXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3Qgbm90aWZpY2F0aW9ucyA9IHRoaXMubm90aWZpY2F0aW9ucyQuZ2V0VmFsdWUoKTtcblxuICAgICAgICBpZiAodGhpcy5kaXJlY3Rpb24gPT09ICdhYm92ZScpIHtcbiAgICAgICAgICAgIG5vdGlmaWNhdGlvbnMudW5zaGlmdChub3RpZmljYXRpb25SZWYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm90aWZpY2F0aW9ucy5wdXNoKG5vdGlmaWNhdGlvblJlZik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm5vdGlmaWNhdGlvbnMkLm5leHQobm90aWZpY2F0aW9ucyk7XG5cbiAgICAgICAgLy8gcmVtb3ZlIG5vdGlmaWNhdGlvbiBhZnRlciBkZWxheVxuICAgICAgICBpZiAob3B0aW9ucy5kdXJhdGlvbiAhPT0gMCkge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLmRpc21pc3Mobm90aWZpY2F0aW9uUmVmKSwgb3B0aW9ucy5kdXJhdGlvbiAqIDEwMDApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5vdGlmaWNhdGlvblJlZjtcbiAgICB9XG5cbiAgICBnZXRIaXN0b3J5KCk6IE5vdGlmaWNhdGlvblJlZltdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm90aWZpY2F0aW9ucyQuZ2V0VmFsdWUoKTtcbiAgICB9XG5cbiAgICBkaXNtaXNzKG5vdGlmaWNhdGlvblJlZjogTm90aWZpY2F0aW9uUmVmKTogdm9pZCB7XG4gICAgICAgIG5vdGlmaWNhdGlvblJlZi52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMubm90aWZpY2F0aW9ucyQubmV4dCh0aGlzLm5vdGlmaWNhdGlvbnMkLmdldFZhbHVlKCkpO1xuICAgIH1cbiAgICBcbiAgICBkaXNtaXNzQWxsKCk6IHZvaWQge1xuICAgICAgICB0aGlzLm5vdGlmaWNhdGlvbnMkLmdldFZhbHVlKCkuZm9yRWFjaChub3RpZmljYXRpb25SZWYgPT4gbm90aWZpY2F0aW9uUmVmLnZpc2libGUgPSBmYWxzZSk7XG4gICAgICAgIHRoaXMubm90aWZpY2F0aW9ucyQubmV4dCh0aGlzLm5vdGlmaWNhdGlvbnMkLmdldFZhbHVlKCkpOyAgICAgICAgXG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfY29sb3JTZXJ2aWNlOiBDb2xvclNlcnZpY2UpIHtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTm90aWZpY2F0aW9uUmVmIHtcbiAgICB0ZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8YW55PjtcbiAgICBkdXJhdGlvbjogbnVtYmVyO1xuICAgIGRhdGU6IERhdGU7XG4gICAgdmlzaWJsZT86IGJvb2xlYW47XG4gICAgaGVpZ2h0PzogbnVtYmVyO1xuICAgIHNwYWNpbmc/OiBudW1iZXI7XG4gICAgYmFja2dyb3VuZENvbG9yPzogc3RyaW5nO1xuICAgIGljb25Db2xvcj86IHN0cmluZztcbiAgICBkYXRhOiB7IFtrZXk6IHN0cmluZ106IGFueSB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE5vdGlmaWNhdGlvbk9wdGlvbnMge1xuICAgIGR1cmF0aW9uPzogbnVtYmVyO1xuICAgIGhlaWdodD86IG51bWJlcjtcbiAgICBzcGFjaW5nPzogbnVtYmVyO1xuICAgIGJhY2tncm91bmRDb2xvcj86IHN0cmluZztcbiAgICBpY29uQ29sb3I/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCB0eXBlIE5vdGlmaWNhdGlvbkxpc3REaXJlY3Rpb24gPSAnYWJvdmUnIHwgJ2JlbG93JzsiLCJpbXBvcnQgeyBDb21wb25lbnQsIEhvc3RCaW5kaW5nLCBJbnB1dCwgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE5vdGlmaWNhdGlvblNlcnZpY2UsIE5vdGlmaWNhdGlvblJlZiwgTm90aWZpY2F0aW9uTGlzdERpcmVjdGlvbiB9IGZyb20gJy4vbm90aWZpY2F0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgdHJpZ2dlciwgc3RhdGUsIHN0eWxlLCBhbmltYXRlLCB0cmFuc2l0aW9uIH0gZnJvbSAnQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XG5pbXBvcnQgeyBtYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycy9tYXAnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMvT2JzZXJ2YWJsZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtbm90aWZpY2F0aW9uLWxpc3QnLFxuICAgIHRlbXBsYXRlOiBgPGRpdiBjbGFzcz1cIm5vdGlmaWNhdGlvblwiICpuZ0Zvcj1cImxldCBub3RpZmljYXRpb25SZWYgb2Ygbm90aWZpY2F0aW9ucyQgfCBhc3luYzsgbGV0IGlkeCA9IGluZGV4XCJcbiAgICBbc3R5bGUudG9wLnB4XT1cIihub3RpZmljYXRpb25SZWYuaGVpZ2h0ICsgbm90aWZpY2F0aW9uUmVmLnNwYWNpbmcpICogaWR4XCJcbiAgICBbc3R5bGUuaGVpZ2h0LnB4XT1cIm5vdGlmaWNhdGlvblJlZi5oZWlnaHRcIlxuICAgIFtzdHlsZS5iYWNrZ3JvdW5kLWNvbG9yXT1cIm5vdGlmaWNhdGlvblJlZi5iYWNrZ3JvdW5kQ29sb3JcIlxuICAgIFtAbm90aWZpY2F0aW9uU3RhdGVdPlxuICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJub3RpZmljYXRpb25SZWYudGVtcGxhdGVSZWY7IGNvbnRleHQ6IHsgJGltcGxpY2l0OiBub3RpZmljYXRpb25SZWYsIGRhdGE6IG5vdGlmaWNhdGlvblJlZi5kYXRhIH1cIj48L25nLWNvbnRhaW5lcj5cbjwvZGl2PlxuYCxcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICBhbmltYXRpb25zOiBbXG4gICAgICAgIHRyaWdnZXIoJ25vdGlmaWNhdGlvblN0YXRlJywgW1xuICAgICAgICAgICAgc3RhdGUoJ2luJywgc3R5bGUoeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGVZKDApJywgb3BhY2l0eTogMC45IH0pKSxcbiAgICAgICAgICAgIHRyYW5zaXRpb24oJzplbnRlcicsIFtcbiAgICAgICAgICAgICAgICBzdHlsZSh7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVkoLTUwcHgpJywgb3BhY2l0eTogMCB9KSxcbiAgICAgICAgICAgICAgICBhbmltYXRlKDUwMClcbiAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgdHJhbnNpdGlvbignOmxlYXZlJywgW1xuICAgICAgICAgICAgICAgIGFuaW1hdGUoNTAwLCBzdHlsZSh7IHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVkoNTBweCknLCBvcGFjaXR5OiAwIH0pKVxuICAgICAgICAgICAgXSlcbiAgICAgICAgXSlcbiAgICBdXG59KVxuZXhwb3J0IGNsYXNzIE5vdGlmaWNhdGlvbkxpc3RDb21wb25lbnQge1xuICAgIFxuICAgIEBJbnB1dCgpIFxuICAgIHNldCBkaXJlY3Rpb24oZGlyZWN0aW9uOiBOb3RpZmljYXRpb25MaXN0RGlyZWN0aW9uKSB7XG4gICAgICAgIHRoaXMuX25vdGlmaWNhdGlvblNlcnZpY2UuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgIH1cblxuICAgIEBJbnB1dCgpIEBIb3N0QmluZGluZygnY2xhc3MnKSBwb3NpdGlvbjogTm90aWZpY2F0aW9uTGlzdFBvc3Rpb24gPSAndG9wLXJpZ2h0JztcblxuICAgIG5vdGlmaWNhdGlvbnMkOiBPYnNlcnZhYmxlPE5vdGlmaWNhdGlvblJlZltdPiA9IHRoaXMuX25vdGlmaWNhdGlvblNlcnZpY2Uubm90aWZpY2F0aW9ucyQucGlwZShcbiAgICAgICAgbWFwKChub3RpZmljYXRpb25SZWZzOiBOb3RpZmljYXRpb25SZWZbXSkgPT4gbm90aWZpY2F0aW9uUmVmcy5maWx0ZXIobm90aWZpY2F0aW9uUmVmID0+IG5vdGlmaWNhdGlvblJlZi52aXNpYmxlKSxcbiAgICApKTtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX25vdGlmaWNhdGlvblNlcnZpY2U6IE5vdGlmaWNhdGlvblNlcnZpY2UpIHtcblxuICAgIH1cbn1cblxuZXhwb3J0IHR5cGUgTm90aWZpY2F0aW9uTGlzdFBvc3Rpb24gPSAndG9wLWxlZnQnIHwgJ3RvcC1yaWdodCcgfCAnYm90dG9tLWxlZnQnIHwgJ2JvdHRvbS1yaWdodCc7IiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcclxuaW1wb3J0IHsgTm90aWZpY2F0aW9uTGlzdENvbXBvbmVudCB9IGZyb20gJy4vbm90aWZpY2F0aW9uLWxpc3QuY29tcG9uZW50JztcclxuaW1wb3J0IHsgTm90aWZpY2F0aW9uU2VydmljZSB9IGZyb20gJy4vbm90aWZpY2F0aW9uLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBDb2xvclNlcnZpY2VNb2R1bGUgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9jb2xvci9pbmRleCc7XHJcblxyXG5ATmdNb2R1bGUoe1xyXG4gICAgaW1wb3J0czogW1xyXG4gICAgICAgIENvbW1vbk1vZHVsZSxcclxuICAgICAgICBDb2xvclNlcnZpY2VNb2R1bGVcclxuICAgIF0sXHJcbiAgICBleHBvcnRzOiBbXHJcbiAgICAgICAgTm90aWZpY2F0aW9uTGlzdENvbXBvbmVudFxyXG4gICAgXSxcclxuICAgIGRlY2xhcmF0aW9uczogW1xyXG4gICAgICAgIE5vdGlmaWNhdGlvbkxpc3RDb21wb25lbnRcclxuICAgIF0sXHJcbiAgICBwcm92aWRlcnM6IFtcclxuICAgICAgICBOb3RpZmljYXRpb25TZXJ2aWNlXHJcbiAgICBdXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBOb3RpZmljYXRpb25Nb2R1bGUgeyB9XHJcbiIsImltcG9ydCB7IENvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBmb3J3YXJkUmVmLCBJbnB1dCwgT3V0cHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb250cm9sVmFsdWVBY2Nlc3NvciwgTkdfVkFMVUVfQUNDRVNTT1IgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmV4cG9ydCBjb25zdCBOVU1CRVJfUElDS0VSX1ZBTFVFX0FDQ0VTU09SOiBhbnkgPSB7XG4gICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTnVtYmVyUGlja2VyQ29tcG9uZW50KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1udW1iZXItcGlja2VyJyxcbiAgICB0ZW1wbGF0ZTogYDxpbnB1dCB0eXBlPVwibnVtYmVyXCJcbiAgICAgICByb2xlPVwic3BpbmJ1dHRvblwiXG4gICAgICAgY2xhc3M9XCJmb3JtLWNvbnRyb2wgbnVtYmVyLXBpY2tlci1pbnB1dFwiXG4gICAgICAgWyhuZ01vZGVsKV09XCJ2YWx1ZVwiXG4gICAgICAgW21pbl09XCJtaW5cIlxuICAgICAgIFttYXhdPVwibWF4XCJcbiAgICAgICAoa2V5ZG93bi5BcnJvd0Rvd24pPVwiZGVjcmVtZW50KCRldmVudClcIlxuICAgICAgIChrZXlkb3duLkFycm93VXApPVwiaW5jcmVtZW50KCRldmVudClcIlxuICAgICAgICh3aGVlbCk9XCJvblNjcm9sbCgkZXZlbnQpXCJcbiAgICAgICBzdGVwPVwiYW55XCJcbiAgICAgICBbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuICAgICAgIFthdHRyLmFyaWEtdmFsdWVtaW5dPVwibWluXCJcbiAgICAgICBbYXR0ci5hcmlhLXZhbHVlbm93XT1cInZhbHVlXCJcbiAgICAgICBbYXR0ci5hcmlhLXZhbHVlbWF4XT1cIm1heFwiPlxuXG48ZGl2IGNsYXNzPVwibnVtYmVyLXBpY2tlci1jb250cm9sc1wiPlxuXG4gICAgPGRpdiBjbGFzcz1cIm51bWJlci1waWNrZXItY29udHJvbC11cFwiXG4gICAgICAgICAoY2xpY2spPVwiaW5jcmVtZW50KCRldmVudClcIlxuICAgICAgICAgW2NsYXNzLmRpc2FibGVkXT1cImRpc2FibGVkIHx8IHZhbHVlID49IG1heFwiPlxuXG4gICAgICAgIDxzcGFuIGNsYXNzPVwiaHBlLWljb24gaHBlLXVwXCI+PC9zcGFuPlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cIm51bWJlci1waWNrZXItY29udHJvbC1kb3duXCJcbiAgICAgICAgIChjbGljayk9XCJkZWNyZW1lbnQoJGV2ZW50KVwiXG4gICAgICAgICBbY2xhc3MuZGlzYWJsZWRdPVwiZGlzYWJsZWQgfHwgdmFsdWUgPD0gbWluXCI+XG5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJocGUtaWNvbiBocGUtZG93blwiPjwvc3Bhbj5cbiAgICA8L2Rpdj5cblxuPC9kaXY+YCxcbiAgICBwcm92aWRlcnM6IFtOVU1CRVJfUElDS0VSX1ZBTFVFX0FDQ0VTU09SXSxcbiAgICBob3N0OiB7XG4gICAgICAgICdbY2xhc3MuaGFzLWVycm9yXSc6ICchaXNWYWxpZCgpJ1xuICAgIH1cbn0pXG5leHBvcnQgY2xhc3MgTnVtYmVyUGlja2VyQ29tcG9uZW50IGltcGxlbWVudHMgQ29udHJvbFZhbHVlQWNjZXNzb3Ige1xuXG4gICAgcHJpdmF0ZSBfbWluOiBudW1iZXIgPSAtSW5maW5pdHk7XG4gICAgcHJpdmF0ZSBfbWF4OiBudW1iZXIgPSBJbmZpbml0eTtcbiAgICBwcml2YXRlIF9zdGVwOiBudW1iZXIgPSAxO1xuICAgIHByaXZhdGUgX2Rpc2FibGVkOiBib29sZWFuID0gZmFsc2U7XG4gICAgcHJpdmF0ZSBfdmFsdWU6IG51bWJlciA9IDA7XG4gICAgcHJpdmF0ZSBfcHJvcGFnYXRlQ2hhbmdlID0gKF86IGFueSkgPT4geyB9O1xuXG4gICAgQElucHV0KCkgdmFsaWQ6IGJvb2xlYW4gPSB0cnVlO1xuICAgIEBPdXRwdXQoKSB2YWx1ZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyPigpO1xuXG4gICAgQElucHV0KCd2YWx1ZScpXG4gICAgZ2V0IHZhbHVlKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICB9XG4gICAgc2V0IHZhbHVlKHZhbHVlOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy52YWx1ZUNoYW5nZS5lbWl0KHZhbHVlKTtcbiAgICAgICAgdGhpcy5fcHJvcGFnYXRlQ2hhbmdlKHZhbHVlKTtcbiAgICB9XG5cbiAgICBASW5wdXQoKVxuICAgIGdldCBtaW4oKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21pbjtcbiAgICB9XG4gICAgc2V0IG1pbih2YWx1ZSkge1xuICAgICAgICB0aGlzLl9taW4gPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gcGFyc2VGbG9hdCh2YWx1ZSkgOiB2YWx1ZTtcbiAgICB9XG5cbiAgICBASW5wdXQoKVxuICAgIGdldCBtYXgoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21heDtcbiAgICB9XG4gICAgc2V0IG1heCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9tYXggPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gcGFyc2VGbG9hdCh2YWx1ZSkgOiB2YWx1ZTtcbiAgICB9XG5cbiAgICBASW5wdXQoKVxuICAgIGdldCBzdGVwKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGVwO1xuICAgIH1cbiAgICBzZXQgc3RlcCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9zdGVwID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHBhcnNlRmxvYXQodmFsdWUpIDogdmFsdWU7XG4gICAgfVxuXG4gICAgQElucHV0KClcbiAgICBnZXQgZGlzYWJsZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaXNhYmxlZDtcbiAgICB9XG4gICAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2Rpc2FibGVkID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSAndHJ1ZScgfHwgdmFsdWUgPT09ICdkaXNhYmxlZCcpIHx8IHZhbHVlID09PSB0cnVlO1xuICAgIH1cblxuICAgIGluY3JlbWVudChldmVudDogTW91c2VFdmVudCB8IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBNYXRoLm1heChNYXRoLm1pbih0aGlzLnZhbHVlICsgdGhpcy5zdGVwLCB0aGlzLm1heCksIHRoaXMubWluKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRlY3JlbWVudChldmVudDogTW91c2VFdmVudCB8IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBNYXRoLm1pbihNYXRoLm1heCh0aGlzLnZhbHVlIC0gdGhpcy5zdGVwLCB0aGlzLm1pbiksIHRoaXMubWF4KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlzVmFsaWQoKTogYm9vbGVhbiB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlIDwgdGhpcy5taW4gfHwgdGhpcy52YWx1ZSA+IHRoaXMubWF4KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy52YWxpZDtcbiAgICB9XG5cbiAgICBvblNjcm9sbChldmVudDogV2hlZWxFdmVudCk6IHZvaWQge1xuXG4gICAgICAgIGxldCBzY3JvbGxWYWx1ZSA9IGV2ZW50LmRlbHRhWSB8fCBldmVudC53aGVlbERlbHRhO1xuXG4gICAgICAgIGlmIChzY3JvbGxWYWx1ZSA8IDApIHtcbiAgICAgICAgICAgIHRoaXMuaW5jcmVtZW50KGV2ZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGVjcmVtZW50KGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHdyaXRlVmFsdWUodmFsdWU6IGFueSk6IHZvaWQge1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm46IGFueSk6IHZvaWQge1xuICAgICAgICB0aGlzLl9wcm9wYWdhdGVDaGFuZ2UgPSBmbjtcbiAgICB9XG5cbiAgICByZWdpc3Rlck9uVG91Y2hlZChmbjogYW55KTogdm9pZCB7IH1cblxuICAgIHNldERpc2FibGVkU3RhdGUoaXNEaXNhYmxlZDogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gaXNEaXNhYmxlZDtcbiAgICB9XG5cbn0iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRm9ybXNNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuXG5pbXBvcnQgeyBOdW1iZXJQaWNrZXJDb21wb25lbnQgfSBmcm9tICcuL251bWJlci1waWNrZXIuY29tcG9uZW50JztcblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGVcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtOdW1iZXJQaWNrZXJDb21wb25lbnRdLFxuICAgIGRlY2xhcmF0aW9uczogW051bWJlclBpY2tlckNvbXBvbmVudF1cbn0pXG5leHBvcnQgY2xhc3MgTnVtYmVyUGlja2VyTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcy9CZWhhdmlvclN1YmplY3QnO1xuaW1wb3J0IHsgTWVudU5hdmlnYXRpb25JdGVtRGlyZWN0aXZlIH0gZnJvbSAnLi9tZW51LW5hdmlnYXRpb24taXRlbS5kaXJlY3RpdmUnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgTWVudU5hdmlnYXRpb25TZXJ2aWNlIHtcblxuICAgIGFjdGl2ZSQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PE1lbnVOYXZpZ2F0aW9uSXRlbURpcmVjdGl2ZT4obnVsbCk7XG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIE9uRGVzdHJveSwgT3V0cHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBNZW51TmF2aWdhdGlvblNlcnZpY2UgfSBmcm9tICcuL21lbnUtbmF2aWdhdGlvbi5zZXJ2aWNlJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbdXhNZW51TmF2aWdhdGlvbkl0ZW1dJ1xufSlcbmV4cG9ydCBjbGFzcyBNZW51TmF2aWdhdGlvbkl0ZW1EaXJlY3RpdmUgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuXG4gICAgQE91dHB1dCgpIGFjdGl2YXRlZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIHByaXZhdGUgX3N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gICAgY29uc3RydWN0b3Ioc2VydmljZTogTWVudU5hdmlnYXRpb25TZXJ2aWNlLCBwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmKSB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IHNlcnZpY2UuYWN0aXZlJC5zdWJzY3JpYmUoKG5leHQpID0+IHtcbiAgICAgICAgICAgIGlmIChuZXh0ID09PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRBY3RpdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cblxuICAgIHNldEFjdGl2ZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgIHRoaXMuYWN0aXZhdGVkLmVtaXQoKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIEhvc3RMaXN0ZW5lciwgSW5wdXQsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1t1eE1lbnVOYXZpZ2F0aW9uVG9nZ2xlXScsXG4gICAgZXhwb3J0QXM6ICd1eE1lbnVOYXZpZ2F0aW9uVG9nZ2xlJ1xufSlcbmV4cG9ydCBjbGFzcyBNZW51TmF2aWdhdGlvblRvZ2dsZURpcmVjdGl2ZSB7XG5cbiAgICBASW5wdXQoKVxuICAgIGdldCBtZW51T3BlbigpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lbnVPcGVuO1xuICAgIH1cblxuICAgIHNldCBtZW51T3Blbih2YWx1ZTogYm9vbGVhbikge1xuICAgICAgICB0aGlzLl9tZW51T3BlbiA9IHZhbHVlO1xuICAgICAgICB0aGlzLm1lbnVPcGVuQ2hhbmdlLmVtaXQodmFsdWUpO1xuICAgIH1cblxuICAgIEBJbnB1dCgpXG4gICAgbWVudVBvc2l0aW9uOiAndG9wJyB8ICdyaWdodCcgfCAnYm90dG9tJyB8ICdsZWZ0JyA9ICdib3R0b20nO1xuXG4gICAgQE91dHB1dCgpXG4gICAgbWVudU9wZW5DaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XG5cbiAgICBrZXlFbnRlciA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcblxuICAgIHByaXZhdGUgX21lbnVPcGVuOiBib29sZWFuO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZikgeyB9XG5cbiAgICBmb2N1cygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcigna2V5ZG93bicsIFsnJGV2ZW50J10pXG4gICAga2V5ZG93bkhhbmRsZXIoZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcblxuICAgICAgICBpZiAodGhpcy5pc0tleU1hdGNoKGV2ZW50LmtleSkpIHtcblxuICAgICAgICAgICAgLy8gT3BlbiB0aGUgbWVudVxuICAgICAgICAgICAgdGhpcy5tZW51T3BlbiA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIEFsbG93IHRoZSBtZW51IHRvIGluaXQsIHRoZW4gc2VuZCB0aGUgZXZlbnQgdG8gZ2l2ZSBpdCBmb2N1c1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5rZXlFbnRlci5lbWl0KCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpc0tleU1hdGNoKGtleTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgICBjYXNlICdFbnRlcic6XG4gICAgICAgICAgICBjYXNlICcgJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAgICAgY2FzZSAnQXJyb3dVcCc6XG4gICAgICAgICAgICBjYXNlICdVcCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVudVBvc2l0aW9uID09PSAndG9wJztcblxuICAgICAgICAgICAgY2FzZSAnQXJyb3dEb3duJzpcbiAgICAgICAgICAgIGNhc2UgJ0Rvd24nOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1lbnVQb3NpdGlvbiA9PT0gJ2JvdHRvbSc7XG5cbiAgICAgICAgICAgIGNhc2UgJ0Fycm93TGVmdCc6XG4gICAgICAgICAgICBjYXNlICdMZWZ0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tZW51UG9zaXRpb24gPT09ICdsZWZ0JztcblxuICAgICAgICAgICAgY2FzZSAnQXJyb3dSaWdodCc6XG4gICAgICAgICAgICBjYXNlICdSaWdodCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVudVBvc2l0aW9uID09PSAncmlnaHQnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBBZnRlckNvbnRlbnRJbml0LCBDb250ZW50Q2hpbGRyZW4sIERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBIb3N0TGlzdGVuZXIsIEluamVjdCwgSW5wdXQsIE9uRGVzdHJveSwgT25Jbml0LCBPdXRwdXQsIFF1ZXJ5TGlzdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRE9DVU1FTlQgfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IE1lbnVOYXZpZ2F0aW9uSXRlbURpcmVjdGl2ZSB9IGZyb20gJy4vbWVudS1uYXZpZ2F0aW9uLWl0ZW0uZGlyZWN0aXZlJztcbmltcG9ydCB7IE1lbnVOYXZpZ2F0aW9uVG9nZ2xlRGlyZWN0aXZlIH0gZnJvbSAnLi9tZW51LW5hdmlnYXRpb24tdG9nZ2xlLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBNZW51TmF2aWdhdGlvblNlcnZpY2UgfSBmcm9tICcuL21lbnUtbmF2aWdhdGlvbi5zZXJ2aWNlJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbdXhNZW51TmF2aWdhdGlvbl0nLFxuICAgIGV4cG9ydEFzOiAndXhNZW51TmF2aWdhdGlvbicsXG4gICAgcHJvdmlkZXJzOiBbTWVudU5hdmlnYXRpb25TZXJ2aWNlXVxufSlcbmV4cG9ydCBjbGFzcyBNZW51TmF2aWdhdGlvbkRpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCwgQWZ0ZXJDb250ZW50SW5pdCwgT25EZXN0cm95IHtcblxuICAgIEBJbnB1dCgpXG4gICAgdG9nZ2xlQnV0dG9uOiBNZW51TmF2aWdhdGlvblRvZ2dsZURpcmVjdGl2ZTtcblxuICAgIEBJbnB1dCgpXG4gICAgdG9nZ2xlQnV0dG9uUG9zaXRpb246ICd0b3AnIHwgJ3JpZ2h0JyB8ICdib3R0b20nIHwgJ2xlZnQnID0gJ3RvcCc7XG5cbiAgICBAT3V0cHV0KClcbiAgICBuYXZpZ2F0ZWRPdXQgPSBuZXcgRXZlbnRFbWl0dGVyPEtleWJvYXJkRXZlbnQ+KCk7XG5cbiAgICBAQ29udGVudENoaWxkcmVuKE1lbnVOYXZpZ2F0aW9uSXRlbURpcmVjdGl2ZSwgeyBkZXNjZW5kYW50czogdHJ1ZSB9KVxuICAgIGl0ZW1zOiBRdWVyeUxpc3Q8TWVudU5hdmlnYXRpb25JdGVtRGlyZWN0aXZlPjtcblxuICAgIGdldCBhY3RpdmVJbmRleCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5faXRlbXNPcmRlcmVkLmluZGV4T2YodGhpcy5fc2VydmljZS5hY3RpdmUkLnZhbHVlKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9pdGVtc09yZGVyZWQ6IE1lbnVOYXZpZ2F0aW9uSXRlbURpcmVjdGl2ZVtdO1xuXG4gICAgcHJpdmF0ZSBfZG9jdW1lbnQ6IGFueTtcblxuICAgIHByaXZhdGUgX3N1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24oKTtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIF9zZXJ2aWNlOiBNZW51TmF2aWdhdGlvblNlcnZpY2UsXG4gICAgICAgIHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYsXG4gICAgICAgIEBJbmplY3QoRE9DVU1FTlQpIGRvY3VtZW50OiBhbnlcbiAgICApIHtcbiAgICAgICAgdGhpcy5fZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMudG9nZ2xlQnV0dG9uKSB7XG4gICAgICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24uYWRkKFxuICAgICAgICAgICAgICAgIHRoaXMudG9nZ2xlQnV0dG9uLmtleUVudGVyLnN1YnNjcmliZSh0aGlzLmZvY3VzRmlyc3QuYmluZCh0aGlzKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZCB7XG5cbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLmFkZChcbiAgICAgICAgICAgIHRoaXMuaXRlbXMuY2hhbmdlcy5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2l0ZW1zT3JkZXJlZCA9IHRoaXMuaXRlbXMudG9BcnJheSgpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLl9pdGVtc09yZGVyZWQgPSB0aGlzLml0ZW1zLnRvQXJyYXkoKTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuXG4gICAgZm9jdXNGaXJzdCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5tb3ZlRmlyc3QoKTtcbiAgICB9XG5cbiAgICBASG9zdExpc3RlbmVyKCdkb2N1bWVudDprZXlkb3duJywgWyckZXZlbnQnXSlcbiAgICBrZXlkb3duSGFuZGxlcihldmVudDogS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xuXG4gICAgICAgIC8vIE9ubHkgaGFuZGxlIGV2ZW50cyB3aGVuIGZvY3VzIGluIHdpdGhpbiB0aGUgbGlzdCBvZiBtZW51IGl0ZW1zXG4gICAgICAgIGlmICghdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmNvbnRhaW5zKHRoaXMuX2RvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgaGFuZGxlZCA9IGZhbHNlO1xuXG4gICAgICAgIHN3aXRjaCAoZXZlbnQua2V5KSB7XG5cbiAgICAgICAgICAgIGNhc2UgJ0Fycm93VXAnOlxuICAgICAgICAgICAgY2FzZSAnVXAnOlxuICAgICAgICAgICAgICAgIHRoaXMubW92ZVByZXZpb3VzKGV2ZW50KTtcbiAgICAgICAgICAgICAgICBoYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnQXJyb3dEb3duJzpcbiAgICAgICAgICAgIGNhc2UgJ0Rvd24nOlxuICAgICAgICAgICAgICAgIHRoaXMubW92ZU5leHQoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGhhbmRsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdBcnJvd0xlZnQnOlxuICAgICAgICAgICAgY2FzZSAnTGVmdCc6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudG9nZ2xlQnV0dG9uUG9zaXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdmVUb1RvZ2dsZUJ1dHRvbihldmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnQXJyb3dSaWdodCc6XG4gICAgICAgICAgICBjYXNlICdSaWdodCc6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudG9nZ2xlQnV0dG9uUG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb3ZlVG9Ub2dnbGVCdXR0b24oZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ0hvbWUnOlxuICAgICAgICAgICAgICAgIHRoaXMubW92ZUZpcnN0KCk7XG4gICAgICAgICAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ0VuZCc6XG4gICAgICAgICAgICAgICAgdGhpcy5tb3ZlTGFzdCgpO1xuICAgICAgICAgICAgICAgIGhhbmRsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdFc2NhcGUnOlxuICAgICAgICAgICAgICAgIHRoaXMubmF2aWdhdGVkT3V0LmVtaXQoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGhhbmRsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhbmRsZWQpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgbW92ZU5leHQoZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcblxuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIHRoZXJlJ3Mgbm8gYWN0aXZlIG1lbnUgaXRlbSByZWdpc3RlcmVkXG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZUluZGV4IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gdGhpcy5hY3RpdmVJbmRleCArIDE7XG4gICAgICAgIGlmIChuZXh0SW5kZXggPCB0aGlzLl9pdGVtc09yZGVyZWQubGVuZ3RoKSB7XG5cbiAgICAgICAgICAgIC8vIEFjdGl2YXRlIHRoZSBuZXh0IG1lbnUgaXRlbVxuICAgICAgICAgICAgLy8gKHV4TWVudU5hdmlnYXRpb25JdGVtIHN1YnNjcmliZXMgdG8gdGhpcyBhbmQgYXBwbGllcyBmb2N1cyBpZiBpdCBtYXRjaGVzKVxuICAgICAgICAgICAgdGhpcy5fc2VydmljZS5hY3RpdmUkLm5leHQodGhpcy5faXRlbXNPcmRlcmVkW25leHRJbmRleF0pO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGZvY3VzIHdlbnQgb3V0IG9mIGJvdW5kcyBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBvcmlnaW4gdG9nZ2xlIGJ1dHRvblxuICAgICAgICAgICAgaWYgKHRoaXMudG9nZ2xlQnV0dG9uUG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb3ZlVG9Ub2dnbGVCdXR0b24oZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBtb3ZlUHJldmlvdXMoZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcblxuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIHRoZXJlJ3Mgbm8gYWN0aXZlIG1lbnUgaXRlbSByZWdpc3RlcmVkXG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZUluZGV4IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gdGhpcy5hY3RpdmVJbmRleCAtIDE7XG4gICAgICAgIGlmIChuZXh0SW5kZXggPj0gMCkge1xuXG4gICAgICAgICAgICAvLyBBY3RpdmF0ZSB0aGUgcHJldmlvdXMgbWVudSBpdGVtXG4gICAgICAgICAgICAvLyAodXhNZW51TmF2aWdhdGlvbkl0ZW0gc3Vic2NyaWJlcyB0byB0aGlzIGFuZCBhcHBsaWVzIGZvY3VzIGlmIGl0IG1hdGNoZXMpXG4gICAgICAgICAgICB0aGlzLl9zZXJ2aWNlLmFjdGl2ZSQubmV4dCh0aGlzLl9pdGVtc09yZGVyZWRbbmV4dEluZGV4XSk7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgZm9jdXMgd2VudCBvdXQgb2YgYm91bmRzIGluIHRoZSBkaXJlY3Rpb24gb2YgdGhlIG9yaWdpbiB0b2dnbGUgYnV0dG9uXG4gICAgICAgICAgICBpZiAodGhpcy50b2dnbGVCdXR0b25Qb3NpdGlvbiA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVUb1RvZ2dsZUJ1dHRvbihldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIG1vdmVGaXJzdCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuX2l0ZW1zT3JkZXJlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXJ2aWNlLmFjdGl2ZSQubmV4dCh0aGlzLl9pdGVtc09yZGVyZWRbMF0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBtb3ZlTGFzdCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuX2l0ZW1zT3JkZXJlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXJ2aWNlLmFjdGl2ZSQubmV4dCh0aGlzLl9pdGVtc09yZGVyZWRbdGhpcy5faXRlbXNPcmRlcmVkLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgbW92ZVRvVG9nZ2xlQnV0dG9uKGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLnRvZ2dsZUJ1dHRvbikge1xuICAgICAgICAgICAgdGhpcy50b2dnbGVCdXR0b24uZm9jdXMoKTtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlQnV0dG9uLm1lbnVPcGVuID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm5hdmlnYXRlZE91dC5lbWl0KGV2ZW50KTtcbiAgICB9XG59IiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgTWVudU5hdmlnYXRpb25EaXJlY3RpdmUgfSBmcm9tICcuL21lbnUtbmF2aWdhdGlvbi5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgTWVudU5hdmlnYXRpb25JdGVtRGlyZWN0aXZlIH0gZnJvbSAnLi9tZW51LW5hdmlnYXRpb24taXRlbS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgTWVudU5hdmlnYXRpb25Ub2dnbGVEaXJlY3RpdmUgfSBmcm9tICcuL21lbnUtbmF2aWdhdGlvbi10b2dnbGUuZGlyZWN0aXZlJztcblxuY29uc3QgRVhQT1JUUyA9IFtcbiAgICBNZW51TmF2aWdhdGlvbkRpcmVjdGl2ZSxcbiAgICBNZW51TmF2aWdhdGlvbkl0ZW1EaXJlY3RpdmUsXG4gICAgTWVudU5hdmlnYXRpb25Ub2dnbGVEaXJlY3RpdmVcbl07XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW10sXG4gICAgZXhwb3J0czogRVhQT1JUUyxcbiAgICBkZWNsYXJhdGlvbnM6IEVYUE9SVFMsXG59KVxuZXhwb3J0IGNsYXNzIE1lbnVOYXZpZ2F0aW9uTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgRGlyZWN0aXZlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBEaXJlY3RpdmUoeyBcbiAgICBzZWxlY3RvcjogJ1t1eFBhZ2VIZWFkZXJDdXN0b21NZW51XScgXG59KVxuZXhwb3J0IGNsYXNzIFBhZ2VIZWFkZXJDdXN0b21NZW51RGlyZWN0aXZlIHsgfSIsImltcG9ydCB7IEluamVjdGFibGUsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcy9CZWhhdmlvclN1YmplY3QnO1xuaW1wb3J0IHsgbWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcy9TdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgUGFnZUhlYWRlckljb25NZW51IH0gZnJvbSAnLi9pbnRlcmZhY2VzJztcbmltcG9ydCB7IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uRHJvcGRvd25JdGVtLCBQYWdlSGVhZGVyTmF2aWdhdGlvbkl0ZW0gfSBmcm9tICcuL25hdmlnYXRpb24vbmF2aWdhdGlvbi5jb21wb25lbnQnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgUGFnZUhlYWRlclNlcnZpY2UgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuXG4gICAgaXRlbXMkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxQYWdlSGVhZGVyTmF2aWdhdGlvbkl0ZW1bXT4oW10pO1xuICAgIHNlbGVjdGVkJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8UGFnZUhlYWRlck5hdmlnYXRpb25JdGVtPihudWxsKTtcbiAgICBzZWxlY3RlZFJvb3QkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxQYWdlSGVhZGVyTmF2aWdhdGlvbkl0ZW0+KG51bGwpO1xuICAgIHNlY29uZGFyeSQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+KGZhbHNlKTtcbiAgICBhY3RpdmVJY29uTWVudSQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PFBhZ2VIZWFkZXJJY29uTWVudT4obnVsbCk7XG4gICAgc2Vjb25kYXJ5TmF2aWdhdGlvbkF1dG9zZWxlY3QgPSBmYWxzZTtcblxuICAgIHByaXZhdGUgX3N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IHRoaXMuc2VsZWN0ZWQkLnBpcGUobWFwKHNlbGVjdGVkID0+IHRoaXMuZ2V0Um9vdChzZWxlY3RlZCkpKS5zdWJzY3JpYmUocm9vdCA9PiB0aGlzLnNlbGVjdGVkUm9vdCQubmV4dChyb290KSk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cblxuICAgIHNlbGVjdChpdGVtOiBQYWdlSGVhZGVyTmF2aWdhdGlvbkl0ZW0pOiB2b2lkIHtcblxuICAgICAgICBpZiAodGhpcy5zZWNvbmRhcnlOYXZpZ2F0aW9uQXV0b3NlbGVjdCAmJiBpdGVtICYmIGl0ZW0uY2hpbGRyZW4gJiYgaXRlbS5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG5cbiAgICAgICAgICAgIC8vIFNlbGVjdCB0aGUgZmlyc3QgY2hpbGQgaW4gc2Vjb25kYXJ5TmF2aWdhdGlvbkF1dG9zZWxlY3QgbW9kZVxuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZCQubmV4dChpdGVtLmNoaWxkcmVuWzBdKTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAvLyBpZiB3ZSBhcmUgaW4gc2Vjb25kYXJ5IG5hdmlnYXRpb24gbW9kZSBhbmQgd2UgY2xpY2sgYSBwYXJlbnQgLSBkb250IGRlc2VsZWN0IHRoZSBjaGlsZFxuICAgICAgICAgICAgaWYgKHRoaXMuc2Vjb25kYXJ5JC5nZXRWYWx1ZSgpID09PSB0cnVlICYmIHRoaXMuaXNQYXJlbnRPZih0aGlzLnNlbGVjdGVkJC5nZXRWYWx1ZSgpLCBpdGVtKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHNlbGVjdCB0aGUgZ2l2ZW4gaXRlbVxuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZCQubmV4dChpdGVtKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRlc2VsZWN0KGl0ZW06IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uSXRlbSB8IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uRHJvcGRvd25JdGVtKTogdm9pZCB7XG5cbiAgICAgICAgLy8gZGVzZWxlY3QgdGhlIGN1cnJlbnQgaXRlbVxuICAgICAgICBpdGVtLnNlbGVjdGVkID0gZmFsc2U7XG5cbiAgICAgICAgLy8gaXRlcmF0ZSBhbnkgY2hpbGRyZW4gYW5kIGRlc2VsZWN0IHRoZW1cbiAgICAgICAgaWYgKGl0ZW0uY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGl0ZW0uY2hpbGRyZW4uZm9yRWFjaChfaXRlbSA9PiB0aGlzLmRlc2VsZWN0KF9pdGVtKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZXNlbGVjdEFsbCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5pdGVtcyQuZ2V0VmFsdWUoKS5mb3JFYWNoKGl0ZW0gPT4gdGhpcy5kZXNlbGVjdChpdGVtKSk7XG4gICAgfVxuXG4gICAgdXBkYXRlSXRlbShpdGVtOiBQYWdlSGVhZGVyTmF2aWdhdGlvbkl0ZW0sIHNlbGVjdGVkOiBQYWdlSGVhZGVyTmF2aWdhdGlvbkl0ZW0pOiB2b2lkIHtcblxuICAgICAgICAvLyBJdGVtIGlzIHNlbGVjdGVkIGlmIGl0IGlzIHRoZSBzZWxlY3RlZCBpdGVtLCBvciBvbmUgb2YgdGhlIHNlbGVjdGVkIGl0ZW0ncyBhbmNlc3RvcnMuXG4gICAgICAgIGl0ZW0uc2VsZWN0ZWQgPSAoaXRlbSA9PT0gc2VsZWN0ZWQpIHx8IHRoaXMuaXNQYXJlbnRPZihzZWxlY3RlZCwgaXRlbSk7XG5cbiAgICAgICAgaWYgKGl0ZW0gPT09IHNlbGVjdGVkKSB7XG4gICAgICAgICAgICAvLyBjYWxsIHRoZSBzZWxlY3QgZnVuY3Rpb24gaWYgcHJlc2VudFxuICAgICAgICAgICAgaWYgKGl0ZW0uc2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgaXRlbS5zZWxlY3QuY2FsbChpdGVtLCBpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldEl0ZW1zKGl0ZW1zOiBQYWdlSGVhZGVyTmF2aWdhdGlvbkl0ZW1bXSA9IFtdKTogdm9pZCB7XG4gICAgICAgIC8vIGlkZW50aWZ5IGFsbCBwYXJlbnQgZWxlbWVudHNcbiAgICAgICAgaXRlbXMuZm9yRWFjaChpdGVtID0+IHRoaXMuc2V0UGFyZW50KGl0ZW0pKTtcblxuICAgICAgICB0aGlzLml0ZW1zJC5uZXh0KGl0ZW1zKTtcblxuICAgICAgICAvLyBTZXQgdXAgdGhlIGluaXRhbGx5IHNlbGVjdGVkIGl0ZW1cbiAgICAgICAgY29uc3QgaW5pdGlhbFNlbGVjdGVkSXRlbSA9IGl0ZW1zLmZpbmQoaXRlbSA9PiBpdGVtLnNlbGVjdGVkID09PSB0cnVlKTtcbiAgICAgICAgdGhpcy5zZWxlY3QoaW5pdGlhbFNlbGVjdGVkSXRlbSk7XG4gICAgfVxuXG4gICAgc2V0U2Vjb25kYXJ5TmF2aWdhdGlvbihlbmFibGVkOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIHRoaXMuc2Vjb25kYXJ5JC5uZXh0KGVuYWJsZWQpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0Um9vdChpdGVtOiBQYWdlSGVhZGVyTmF2aWdhdGlvbik6IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0gJiYgaXRlbS5wYXJlbnQgPyB0aGlzLmdldFJvb3QoaXRlbS5wYXJlbnQpIDogaXRlbTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHNldFBhcmVudChpdGVtOiBQYWdlSGVhZGVyTmF2aWdhdGlvbiwgcGFyZW50PzogUGFnZUhlYWRlck5hdmlnYXRpb24gfCBudWxsKTogdm9pZCB7XG4gICAgICAgIC8vIHNldCB0aGUgcGFyZW50IGZpZWxkXG4gICAgICAgIGl0ZW0ucGFyZW50ID0gcGFyZW50O1xuXG4gICAgICAgIC8vIGNhbGwgdGhpcyBmdW5jdGlvbiByZWN1cnNpdmVseSBvbiBhbGwgY2hpbGRyZW5cbiAgICAgICAgaWYgKGl0ZW0uY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGl0ZW0uY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB0aGlzLnNldFBhcmVudChjaGlsZCwgaXRlbSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpc1BhcmVudE9mKG5vZGU6IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uLCBwYXJlbnQ6IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uKTogYm9vbGVhbiB7XG5cbiAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG5vIHBhcmVudHMgcmV0dXJuIGZhbHNlXG4gICAgICAgIGlmICghbm9kZSB8fCAhbm9kZS5wYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoZSBwYXJlbnQgaXMgdGhlIG1hdGNoIHdlIGFyZSBsb29raW5nIGZvciByZXR1cm4gdHJ1ZVxuICAgICAgICBpZiAobm9kZS5wYXJlbnQgPT09IHBhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aGVyZSBhcmUgcG90ZW50aWFsbHkgZ3JhbmRwYXJlbnRzIHRoZW4gY2hlY2sgdGhlbSB0b29cbiAgICAgICAgcmV0dXJuIHRoaXMuaXNQYXJlbnRPZihub2RlLnBhcmVudCwgcGFyZW50KTtcbiAgICB9XG59XG5cbmV4cG9ydCB0eXBlIFBhZ2VIZWFkZXJOYXZpZ2F0aW9uID0gUGFnZUhlYWRlck5hdmlnYXRpb25JdGVtIHwgUGFnZUhlYWRlck5hdmlnYXRpb25Ecm9wZG93bkl0ZW07IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgT25EZXN0cm95LCBWaWV3Q2hpbGQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IE1lbnVOYXZpZ2F0aW9uVG9nZ2xlRGlyZWN0aXZlIH0gZnJvbSAnLi4vLi4vLi4vZGlyZWN0aXZlcy9tZW51LW5hdmlnYXRpb24vbWVudS1uYXZpZ2F0aW9uLXRvZ2dsZS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgUGFnZUhlYWRlckljb25NZW51LCBQYWdlSGVhZGVySWNvbk1lbnVEcm9wZG93bkl0ZW0gfSBmcm9tICcuLi9pbnRlcmZhY2VzJztcbmltcG9ydCB7IFBhZ2VIZWFkZXJTZXJ2aWNlIH0gZnJvbSAnLi4vcGFnZS1oZWFkZXIuc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtcGFnZS1oZWFkZXItaWNvbi1tZW51JyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJwYWdlLWhlYWRlci1pY29uLW1lbnVcIlxuICAgIGRyb3Bkb3duXG4gICAgcGxhY2VtZW50PVwiYm90dG9tIHJpZ2h0XCJcbiAgICBbKGlzT3BlbildPVwiaXNPcGVuXCI+XG5cbiAgICA8YSByb2xlPVwiYnV0dG9uXCJcbiAgICAgICAgY2xhc3M9XCJwYWdlLWhlYWRlci1pY29uLW1lbnUtYnV0dG9uXCJcbiAgICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XCJtZW51LmxhYmVsXCJcbiAgICAgICAgYXJpYS1oYXNwb3B1cD1cInRydWVcIlxuICAgICAgICB0YWJpbmRleD1cIjBcIlxuICAgICAgICAoY2xpY2spPVwic2VsZWN0KG1lbnUpXCJcbiAgICAgICAgZHJvcGRvd25Ub2dnbGVcbiAgICAgICAgdXhNZW51TmF2aWdhdGlvblRvZ2dsZVxuICAgICAgICAjbWVudU5hdmlnYXRpb25Ub2dnbGU9XCJ1eE1lbnVOYXZpZ2F0aW9uVG9nZ2xlXCJcbiAgICAgICAgWyhtZW51T3BlbildPVwiaXNPcGVuXCI+XG5cbiAgICAgICAgPGkgY2xhc3M9XCJocGUtaWNvblwiIFtuZ0NsYXNzXT1cIm1lbnUuaWNvblwiPjwvaT5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJsYWJlbCBsYWJlbC1wcmltYXJ5XCIgKm5nSWY9XCJtZW51Py5iYWRnZVwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPnt7IG1lbnUuYmFkZ2UgfX08L3NwYW4+XG5cbiAgICA8L2E+XG5cbiAgICA8dWwgKmRyb3Bkb3duTWVudVxuICAgICAgICBjbGFzcz1cImRyb3Bkb3duLW1lbnVcIlxuICAgICAgICByb2xlPVwibWVudVwiXG4gICAgICAgIHV4TWVudU5hdmlnYXRpb25cbiAgICAgICAgW3RvZ2dsZUJ1dHRvbl09XCJtZW51TmF2aWdhdGlvblRvZ2dsZVwiPlxuXG4gICAgICAgIDxsaSAqbmdGb3I9XCJsZXQgZHJvcGRvd24gb2YgbWVudT8uZHJvcGRvd25cIlxuICAgICAgICAgICAgcm9sZT1cIm5vbmVcIlxuICAgICAgICAgICAgW2NsYXNzLmRyb3Bkb3duLWhlYWRlcl09XCJkcm9wZG93bi5oZWFkZXJcIlxuICAgICAgICAgICAgW2NsYXNzLmRyb3Bkb3duLWRpdmlkZXJdPVwiZHJvcGRvd24uZGl2aWRlclwiPlxuXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImZvbnQtYm9sZFwiICpuZ0lmPVwiZHJvcGRvd24uaGVhZGVyXCI+e3sgZHJvcGRvd24udGl0bGUgfX08L3NwYW4+XG5cbiAgICAgICAgICAgIDxhICpuZ0lmPVwiIWRyb3Bkb3duLmhlYWRlclwiXG4gICAgICAgICAgICAgICAgcm9sZT1cIm1lbnVpdGVtXCJcbiAgICAgICAgICAgICAgICBjbGFzcz1cImRyb3Bkb3duLWl0ZW1cIlxuICAgICAgICAgICAgICAgIHRhYmluZGV4PVwiLTFcIlxuICAgICAgICAgICAgICAgIChjbGljayk9XCJzZWxlY3QoZHJvcGRvd24pXCJcbiAgICAgICAgICAgICAgICAoa2V5ZG93bik9XCJrZXlkb3duSGFuZGxlcihkcm9wZG93biwgJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgdXhNZW51TmF2aWdhdGlvbkl0ZW0+XG5cblxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZHJvcGRvd24taXRlbS10aXRsZVwiPlxuICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cImhwZS1pY29uIGhwZS1md1wiIFtuZ0NsYXNzXT1cImRyb3Bkb3duLmljb25cIj48L2k+XG4gICAgICAgICAgICAgICAgICAgIHt7IGRyb3Bkb3duLnRpdGxlIH19XG4gICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgIDxzcGFuICpuZ0lmPVwiZHJvcGRvd24uc3VidGl0bGVcIiBjbGFzcz1cImRyb3Bkb3duLWl0ZW0tc3VidGl0bGVcIj57eyBkcm9wZG93bi5zdWJ0aXRsZSB9fTwvc3Bhbj5cblxuICAgICAgICAgICAgPC9hPlxuICAgICAgICA8L2xpPlxuXG4gICAgPC91bD5cbjwvZGl2PmBcbn0pXG5leHBvcnQgY2xhc3MgUGFnZUhlYWRlckljb25NZW51Q29tcG9uZW50IGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICAgIEBJbnB1dCgpIG1lbnU6IFBhZ2VIZWFkZXJJY29uTWVudTtcblxuICAgIGdldCBpc09wZW4oKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc09wZW47XG4gICAgfVxuXG4gICAgc2V0IGlzT3Blbih2YWx1ZTogYm9vbGVhbikge1xuICAgICAgICB0aGlzLl9pc09wZW4gPSB2YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXJ2aWNlLmFjdGl2ZUljb25NZW51JC5uZXh0KHRoaXMubWVudSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBAVmlld0NoaWxkKCdtZW51TmF2aWdhdGlvblRvZ2dsZScpIG1lbnVOYXZpZ2F0aW9uVG9nZ2xlOiBNZW51TmF2aWdhdGlvblRvZ2dsZURpcmVjdGl2ZTtcblxuICAgIHByaXZhdGUgX2lzT3BlbjogYm9vbGVhbjtcbiAgICBwcml2YXRlIF9zdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX3NlcnZpY2U6IFBhZ2VIZWFkZXJTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IF9zZXJ2aWNlLmFjdGl2ZUljb25NZW51JC5zdWJzY3JpYmUoKG5leHQpID0+IHtcbiAgICAgICAgICAgIC8vIENsb3NlIGFsbCBidXQgdGhlIG1vc3QgcmVjZW50bHkgb3BlbmVkIG1lbnVcbiAgICAgICAgICAgIGlmIChuZXh0ICE9PSB0aGlzLm1lbnUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc09wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cblxuICAgIHNlbGVjdChpdGVtOiBQYWdlSGVhZGVySWNvbk1lbnUgfCBQYWdlSGVhZGVySWNvbk1lbnVEcm9wZG93bkl0ZW0pIHtcbiAgICAgICAgaWYgKGl0ZW0uc2VsZWN0KSB7XG4gICAgICAgICAgICBpdGVtLnNlbGVjdC5jYWxsKGl0ZW0sIGl0ZW0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAga2V5ZG93bkhhbmRsZXIoaXRlbTogUGFnZUhlYWRlckljb25NZW51IHwgUGFnZUhlYWRlckljb25NZW51RHJvcGRvd25JdGVtLCBldmVudDogS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xuXG4gICAgICAgIHN3aXRjaCAoZXZlbnQua2V5KSB7XG4gICAgICAgICAgICBjYXNlICdFbnRlcic6XG4gICAgICAgICAgICBjYXNlICcgJzpcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdChpdGVtKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlzT3BlbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMubWVudU5hdmlnYXRpb25Ub2dnbGUuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufSIsImltcG9ydCB7IENvbXBvbmVudCwgRWxlbWVudFJlZiwgSW5wdXQsIE9uRGVzdHJveSwgVmlld0NoaWxkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IGRlYm91bmNlVGltZSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFBhZ2VIZWFkZXJTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vcGFnZS1oZWFkZXIuc2VydmljZSc7XG5pbXBvcnQgeyBQYWdlSGVhZGVyTmF2aWdhdGlvbkRyb3Bkb3duSXRlbSB9IGZyb20gJy4uL25hdmlnYXRpb24uY29tcG9uZW50JztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1wYWdlLWhlYWRlci1ob3Jpem9udGFsLW5hdmlnYXRpb24tZHJvcGRvd24taXRlbScsXG4gICAgZXhwb3J0QXM6ICd1eC1wYWdlLWhlYWRlci1ob3Jpem9udGFsLW5hdmlnYXRpb24tZHJvcGRvd24taXRlbScsXG4gICAgdGVtcGxhdGU6IGA8ZGl2ICpuZ0lmPVwiaXRlbS5jaGlsZHJlbiAmJiBpdGVtLmNoaWxkcmVuLmxlbmd0aCA+IDBcIlxuICAgIGRyb3Bkb3duXG4gICAgI3N1Yk1lbnU9XCJicy1kcm9wZG93blwiXG4gICAgW2lzT3Blbl09XCJkcm9wZG93bk9wZW5cIlxuICAgIGNvbnRhaW5lcj1cImJvZHlcIlxuICAgIHBsYWNlbWVudD1cInJpZ2h0XCJcbiAgICAobW91c2VlbnRlcik9XCJob3ZlclN0YXJ0KClcIlxuICAgIChtb3VzZWxlYXZlKT1cImhvdmVyTGVhdmUoKVwiPlxuXG4gICAgPGEgcm9sZT1cIm1lbnVpdGVtXCJcbiAgICAgICAgY2xhc3M9XCJkcm9wZG93bi1pdGVtXCJcbiAgICAgICAgW2NsYXNzLnNlbGVjdGVkXT1cIml0ZW0uc2VsZWN0ZWRcIlxuICAgICAgICBhcmlhLWhhc3BvcHVwPVwidHJ1ZVwiXG4gICAgICAgIFthdHRyLmFyaWEtZXhwYW5kZWRdPVwiZHJvcGRvd25PcGVuXCJcbiAgICAgICAgW2F0dHIuYXJpYS1zZWxlY3RlZF09XCJpdGVtLnNlbGVjdGVkXCJcbiAgICAgICAgdGFiaW5kZXg9XCItMVwiXG4gICAgICAgICNidXR0b25cbiAgICAgICAgZHJvcGRvd25Ub2dnbGVcbiAgICAgICAgdXhNZW51TmF2aWdhdGlvblRvZ2dsZVxuICAgICAgICAjbWVudU5hdmlnYXRpb25Ub2dnbGU9XCJ1eE1lbnVOYXZpZ2F0aW9uVG9nZ2xlXCJcbiAgICAgICAgWyhtZW51T3BlbildPVwiZHJvcGRvd25PcGVuXCJcbiAgICAgICAgbWVudVBvc2l0aW9uPVwicmlnaHRcIj5cblxuICAgICAgICA8c3BhbiBjbGFzcz1cImRyb3Bkb3duLWl0ZW0tdGl0bGVcIj57eyBpdGVtLnRpdGxlIH19PC9zcGFuPlxuICAgICAgICA8c3BhbiBjbGFzcz1cImRyb3Bkb3duLWl0ZW0taWNvbiBocGUtaWNvbiBocGUtbmV4dFwiPjwvc3Bhbj5cblxuICAgIDwvYT5cblxuICAgIDx1bCAqZHJvcGRvd25NZW51XG4gICAgICAgIHJvbGU9XCJtZW51XCJcbiAgICAgICAgY2xhc3M9XCJkcm9wZG93bi1tZW51IGhvcml6b250YWwtbmF2aWdhdGlvbi1kcm9wZG93bi1zdWJtZW51XCJcbiAgICAgICAgKG1vdXNlZW50ZXIpPVwiaG92ZXJTdGFydCgpXCJcbiAgICAgICAgKG1vdXNlbGVhdmUpPVwiaG92ZXJMZWF2ZSgpXCJcbiAgICAgICAgdXhNZW51TmF2aWdhdGlvblxuICAgICAgICAjbWVudU5hdmlnYXRpb249XCJ1eE1lbnVOYXZpZ2F0aW9uXCJcbiAgICAgICAgW3RvZ2dsZUJ1dHRvbl09XCJtZW51TmF2aWdhdGlvblRvZ2dsZVwiXG4gICAgICAgIHRvZ2dsZUJ1dHRvblBvc2l0aW9uPVwibGVmdFwiPlxuXG4gICAgICAgIDxsaSAqbmdGb3I9XCJsZXQgc3ViSXRlbSBvZiBpdGVtLmNoaWxkcmVuXCIgcm9sZT1cIm5vbmVcIj5cblxuICAgICAgICAgICAgPGEgcm9sZT1cIm1lbnVpdGVtXCJcbiAgICAgICAgICAgICAgICBjbGFzcz1cImRyb3Bkb3duLWl0ZW1cIlxuICAgICAgICAgICAgICAgIFtjbGFzcy5zZWxlY3RlZF09XCJzdWJJdGVtLnNlbGVjdGVkXCJcbiAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLXNlbGVjdGVkXT1cInN1Ykl0ZW0uc2VsZWN0ZWRcIlxuICAgICAgICAgICAgICAgIHRhYmluZGV4PVwiLTFcIlxuICAgICAgICAgICAgICAgIChjbGljayk9XCJzZWxlY3Qoc3ViSXRlbSlcIlxuICAgICAgICAgICAgICAgIChrZXlkb3duKT1cImtleWRvd25IYW5kbGVyKCRldmVudCwgc3ViSXRlbSlcIlxuICAgICAgICAgICAgICAgIHV4TWVudU5hdmlnYXRpb25JdGVtPlxuXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJkcm9wZG93bi1pdGVtLXRpdGxlXCI+e3sgc3ViSXRlbS50aXRsZSB9fTwvc3Bhbj5cblxuICAgICAgICAgICAgPC9hPlxuXG4gICAgICAgIDwvbGk+XG4gICAgPC91bD5cblxuPC9kaXY+XG5cbjxkaXYgKm5nSWY9XCIhaXRlbS5jaGlsZHJlbiB8fCBpdGVtLmNoaWxkcmVuLmxlbmd0aCA9PT0gMFwiXG4gICAgKG1vdXNlZW50ZXIpPVwiaG92ZXJTdGFydCgpXCJcbiAgICAobW91c2VsZWF2ZSk9XCJob3ZlckxlYXZlKClcIj5cblxuICAgIDxhIHJvbGU9XCJtZW51aXRlbVwiXG4gICAgICAgICNidXR0b25cbiAgICAgICAgY2xhc3M9XCJkcm9wZG93bi1pdGVtXCJcbiAgICAgICAgW2NsYXNzLnNlbGVjdGVkXT1cIml0ZW0uc2VsZWN0ZWRcIlxuICAgICAgICBbYXR0ci5hcmlhLXNlbGVjdGVkXT1cIml0ZW0uc2VsZWN0ZWRcIlxuICAgICAgICB0YWJpbmRleD1cIi0xXCJcbiAgICAgICAgKGNsaWNrKT1cInNlbGVjdChpdGVtKVwiXG4gICAgICAgIChrZXlkb3duKT1cImtleWRvd25IYW5kbGVyKCRldmVudCwgaXRlbSlcIj5cblxuICAgICAgICA8c3BhbiBjbGFzcz1cImRyb3Bkb3duLWl0ZW0tdGl0bGVcIj57eyBpdGVtLnRpdGxlIH19PC9zcGFuPlxuXG4gICAgPC9hPlxuXG48L2Rpdj5gXG59KVxuZXhwb3J0IGNsYXNzIFBhZ2VIZWFkZXJOYXZpZ2F0aW9uRHJvcGRvd25JdGVtQ29tcG9uZW50IGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICAgIEBJbnB1dCgpIGl0ZW06IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uRHJvcGRvd25JdGVtO1xuXG4gICAgQFZpZXdDaGlsZCgnYnV0dG9uJylcbiAgICBidXR0b246IEVsZW1lbnRSZWY7XG5cbiAgICBkcm9wZG93bk9wZW46IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIHByaXZhdGUgX3N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuICAgIHByaXZhdGUgX2hvdmVyJDogU3ViamVjdDxib29sZWFuPiA9IG5ldyBTdWJqZWN0PGJvb2xlYW4+KCk7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9wYWdlSGVhZGVyU2VydmljZTogUGFnZUhlYWRlclNlcnZpY2UpIHtcblxuICAgICAgICAvLyBzdWJzY3JpYmUgdG8gc3RyZWFtIHdpdGggYSBkZWJvdW5jZSAoYSBzbWFsbCBkZWJvdW5jZSBpcyBhbGwgdGhhdCBpcyByZXF1aXJlZClcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gdGhpcy5faG92ZXIkLnBpcGUoZGVib3VuY2VUaW1lKDEpKS5zdWJzY3JpYmUodmlzaWJsZSA9PiB0aGlzLmRyb3Bkb3duT3BlbiA9IHZpc2libGUpO1xuXG4gICAgICAgIC8vIENsb3NlIHN1Ym1lbnVzIHdoZW4gc2VsZWN0ZWQgaXRlbSBjaGFuZ2VzXG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi5hZGQoXG4gICAgICAgICAgICBfcGFnZUhlYWRlclNlcnZpY2Uuc2VsZWN0ZWQkLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcm9wZG93bk9wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cblxuICAgIHNlbGVjdChpdGVtOiBQYWdlSGVhZGVyTmF2aWdhdGlvbkRyb3Bkb3duSXRlbSkge1xuXG4gICAgICAgIC8vIGNsaWNraW5nIG9uIGFuIGl0ZW0gd2l0aCBjaGlsZHJlbiB0aGVuIHJldHVyblxuICAgICAgICBpZiAoaXRlbS5jaGlsZHJlbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZW1pdCB0aGUgc2VsZWN0ZWQgaXRlbSBpbiBhbiBldmVudFxuICAgICAgICB0aGlzLl9wYWdlSGVhZGVyU2VydmljZS5zZWxlY3QoaXRlbSk7XG4gICAgfVxuXG4gICAgZm9jdXMoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuYnV0dG9uLm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICB9XG5cbiAgICBob3ZlclN0YXJ0KCkge1xuICAgICAgICB0aGlzLl9ob3ZlciQubmV4dCh0cnVlKTtcbiAgICB9XG5cbiAgICBob3ZlckxlYXZlKCkge1xuICAgICAgICB0aGlzLl9ob3ZlciQubmV4dChmYWxzZSk7XG4gICAgfVxuXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHRoaXMuZHJvcGRvd25PcGVuID0gZmFsc2U7XG4gICAgfVxuXG4gICAga2V5ZG93bkhhbmRsZXIoZXZlbnQ6IEtleWJvYXJkRXZlbnQsIGl0ZW06IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uRHJvcGRvd25JdGVtKTogdm9pZCB7XG5cbiAgICAgICAgc3dpdGNoIChldmVudC5rZXkpIHtcbiAgICAgICAgICAgIGNhc2UgJ0VudGVyJzpcbiAgICAgICAgICAgIGNhc2UgJyAnOlxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0KGl0ZW0pO1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBJbnB1dCwgT25EZXN0cm95LCBPbkluaXQsIFF1ZXJ5TGlzdCwgVmlld0NoaWxkLCBWaWV3Q2hpbGRyZW4gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJzRHJvcGRvd25EaXJlY3RpdmUgfSBmcm9tICduZ3gtYm9vdHN0cmFwL2Ryb3Bkb3duJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IE1lbnVOYXZpZ2F0aW9uVG9nZ2xlRGlyZWN0aXZlIH0gZnJvbSAnLi4vLi4vLi4vLi4vZGlyZWN0aXZlcy9tZW51LW5hdmlnYXRpb24vbWVudS1uYXZpZ2F0aW9uLXRvZ2dsZS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgUGFnZUhlYWRlclNlcnZpY2UgfSBmcm9tICcuLi8uLi9wYWdlLWhlYWRlci5zZXJ2aWNlJztcbmltcG9ydCB7IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uRHJvcGRvd25JdGVtQ29tcG9uZW50IH0gZnJvbSAnLi4vbmF2aWdhdGlvbi1kcm9wZG93bi1pdGVtL25hdmlnYXRpb24tZHJvcGRvd24taXRlbS5jb21wb25lbnQnO1xuaW1wb3J0IHsgUGFnZUhlYWRlck5hdmlnYXRpb25JdGVtIH0gZnJvbSAnLi4vbmF2aWdhdGlvbi5jb21wb25lbnQnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LXBhZ2UtaGVhZGVyLWhvcml6b250YWwtbmF2aWdhdGlvbi1pdGVtJyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgKm5nSWY9XCJpdGVtLmNoaWxkcmVuICYmIGl0ZW0uY2hpbGRyZW4ubGVuZ3RoID4gMCAmJiAhKHNlY29uZGFyeSQgfCBhc3luYylcIlxuICAgIGRyb3Bkb3duXG4gICAgI21lbnU9XCJicy1kcm9wZG93blwiXG4gICAgWyhpc09wZW4pXT1cImlzT3BlblwiXG4gICAgY29udGFpbmVyPVwiYm9keVwiXG4gICAgcGxhY2VtZW50PVwiYm90dG9tIGxlZnRcIj5cblxuICAgIDxidXR0b24gcm9sZT1cIm1lbnVpdGVtXCJcbiAgICAgICAgY2xhc3M9XCJob3Jpem9udGFsLW5hdmlnYXRpb24tYnV0dG9uXCJcbiAgICAgICAgW2NsYXNzLnNlbGVjdGVkXT1cIml0ZW0uc2VsZWN0ZWRcIlxuICAgICAgICBbY2xhc3Mub3Blbl09XCJpc09wZW5cIlxuICAgICAgICBhcmlhLWhhc3BvcHVwPVwidHJ1ZVwiXG4gICAgICAgIFthdHRyLmFyaWEtZXhwYW5kZWRdPVwiaXNPcGVuXCJcbiAgICAgICAgW2F0dHIuYXJpYS1zZWxlY3RlZF09XCJpdGVtLnNlbGVjdGVkXCJcbiAgICAgICAgZHJvcGRvd25Ub2dnbGVcbiAgICAgICAgdXhNZW51TmF2aWdhdGlvblRvZ2dsZVxuICAgICAgICAjYnV0dG9uPVwidXhNZW51TmF2aWdhdGlvblRvZ2dsZVwiXG4gICAgICAgIFsobWVudU9wZW4pXT1cImlzT3BlblwiPlxuXG4gICAgICAgIDxzcGFuIGNsYXNzPVwiaHBlLWljb24gbmF2aWdhdGlvbi1pdGVtLWljb25cIiAqbmdJZj1cIml0ZW0uaWNvblwiIFtuZ0NsYXNzXT1cIml0ZW0/Lmljb25cIj48L3NwYW4+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwibmF2aWdhdGlvbi1pdGVtLWxhYmVsXCI+e3sgaXRlbT8udGl0bGUgfX08L3NwYW4+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwiaHBlLWljb24gaHBlLWRvd25cIj48L3NwYW4+XG5cbiAgICA8L2J1dHRvbj5cblxuICAgIDxkaXYgKmRyb3Bkb3duTWVudVxuICAgICAgICByb2xlPVwibWVudVwiXG4gICAgICAgIGNsYXNzPVwiZHJvcGRvd24tbWVudSBob3Jpem9udGFsLW5hdmlnYXRpb24tZHJvcGRvd24tbWVudVwiXG4gICAgICAgIHV4TWVudU5hdmlnYXRpb25cbiAgICAgICAgW3RvZ2dsZUJ1dHRvbl09XCJidXR0b25cIlxuICAgICAgICB0b2dnbGVCdXR0b25Qb3NpdGlvbj1cInRvcFwiPlxuXG4gICAgICAgIDxkaXYgKm5nRm9yPVwibGV0IGl0ZW0gb2YgaXRlbT8uY2hpbGRyZW5cIiB1eE1lbnVOYXZpZ2F0aW9uSXRlbSAoYWN0aXZhdGVkKT1cImRyb3Bkb3duSXRlbS5mb2N1cygpXCI+XG4gICAgICAgICAgICA8dXgtcGFnZS1oZWFkZXItaG9yaXpvbnRhbC1uYXZpZ2F0aW9uLWRyb3Bkb3duLWl0ZW1cbiAgICAgICAgICAgICAgICAjZHJvcGRvd25JdGVtPVwidXgtcGFnZS1oZWFkZXItaG9yaXpvbnRhbC1uYXZpZ2F0aW9uLWRyb3Bkb3duLWl0ZW1cIlxuICAgICAgICAgICAgICAgIFtpdGVtXT1cIml0ZW1cIj5cbiAgICAgICAgICAgIDwvdXgtcGFnZS1oZWFkZXItaG9yaXpvbnRhbC1uYXZpZ2F0aW9uLWRyb3Bkb3duLWl0ZW0+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgPC9kaXY+XG5cbjwvZGl2PlxuXG48YnV0dG9uICpuZ0lmPVwiIWl0ZW0uY2hpbGRyZW4gfHwgaXRlbS5jaGlsZHJlbi5sZW5ndGggPT09IDAgfHwgKHNlY29uZGFyeSQgfCBhc3luYylcIlxuICAgIHJvbGU9XCJtZW51aXRlbVwiXG4gICAgY2xhc3M9XCJob3Jpem9udGFsLW5hdmlnYXRpb24tYnV0dG9uXCJcbiAgICBbY2xhc3Muc2VsZWN0ZWRdPVwiaXRlbS5zZWxlY3RlZFwiXG4gICAgW2F0dHIuYXJpYS1zZWxlY3RlZF09XCJpdGVtLnNlbGVjdGVkXCJcbiAgICAoY2xpY2spPVwic2VsZWN0KClcIj5cblxuICAgIDxzcGFuIGNsYXNzPVwiaHBlLWljb24gbmF2aWdhdGlvbi1pdGVtLWljb25cIiAqbmdJZj1cIml0ZW0uaWNvblwiIFtuZ0NsYXNzXT1cIml0ZW0/Lmljb25cIj48L3NwYW4+XG4gICAgPHNwYW4gY2xhc3M9XCJuYXZpZ2F0aW9uLWl0ZW0tbGFiZWxcIj57eyBpdGVtPy50aXRsZSB9fTwvc3Bhbj5cblxuPC9idXR0b24+YFxufSlcbmV4cG9ydCBjbGFzcyBQYWdlSGVhZGVyTmF2aWdhdGlvbkl0ZW1Db21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG5cbiAgICBAVmlld0NoaWxkKCdidXR0b24nKSBidXR0b246IE1lbnVOYXZpZ2F0aW9uVG9nZ2xlRGlyZWN0aXZlO1xuICAgIEBWaWV3Q2hpbGQoJ21lbnUnKSBtZW51OiBCc0Ryb3Bkb3duRGlyZWN0aXZlO1xuICAgIEBWaWV3Q2hpbGRyZW4oUGFnZUhlYWRlck5hdmlnYXRpb25Ecm9wZG93bkl0ZW1Db21wb25lbnQpIGRyb3Bkb3duczogUXVlcnlMaXN0PFBhZ2VIZWFkZXJOYXZpZ2F0aW9uRHJvcGRvd25JdGVtQ29tcG9uZW50PjtcblxuICAgIEBJbnB1dCgpIGl0ZW06IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uSXRlbTtcblxuICAgIHNlY29uZGFyeSQ6IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPiA9IHRoaXMuX3BhZ2VIZWFkZXJTZXJ2aWNlLnNlY29uZGFyeSQ7XG5cbiAgICBpc09wZW46IGJvb2xlYW47XG5cbiAgICBwcml2YXRlIF9zdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwdWJsaWMgZWxlbWVudFJlZjogRWxlbWVudFJlZixcbiAgICAgICAgcHJpdmF0ZSBfcGFnZUhlYWRlclNlcnZpY2U6IFBhZ2VIZWFkZXJTZXJ2aWNlXG4gICAgKSB7IH1cblxuICAgIG5nT25Jbml0KCkge1xuXG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IHRoaXMuX3BhZ2VIZWFkZXJTZXJ2aWNlLnNlbGVjdGVkJC5zdWJzY3JpYmUobmV4dCA9PiB7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSBzZWxlY3RlZCBzdGF0ZSBmb3IgdGhpcyBpdGVtXG4gICAgICAgICAgICB0aGlzLl9wYWdlSGVhZGVyU2VydmljZS51cGRhdGVJdGVtKHRoaXMuaXRlbSwgbmV4dCk7XG5cbiAgICAgICAgICAgIGlmIChuZXh0ICYmIHRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc09wZW4gPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIC8vIElmIG1lbnUgd2FzIGNsb3NlZCwga2VlcCBmb2N1cyBvbiB0aGUgdG9nZ2xlIGJ1dHRvblxuICAgICAgICAgICAgICAgIHRoaXMuYnV0dG9uLmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh0aGlzLm1lbnUpIHtcbiAgICAgICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi5hZGQoXG4gICAgICAgICAgICAgICAgdGhpcy5tZW51Lm9uSGlkZGVuLnN1YnNjcmliZSgoKSA9PiB0aGlzLmRyb3Bkb3ducy5mb3JFYWNoKGRyb3Bkb3duID0+IGRyb3Bkb3duLmNsb3NlKCkpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG5cbiAgICBzZWxlY3QoKSB7XG5cbiAgICAgICAgLy8gaWYgdGhlIGl0ZW0gaGFzIGNoaWxkcmVuIHRoZW4gZG8gbm90aGluZyBhdCB0aGlzIHN0YWdlXG4gICAgICAgIGlmICh0aGlzLml0ZW0uY2hpbGRyZW4gJiYgdGhpcy5fcGFnZUhlYWRlclNlcnZpY2Uuc2Vjb25kYXJ5JC5nZXRWYWx1ZSgpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gb3RoZXJ3aXNlIHNlbGVjdCB0aGUgY3VycmVudCBpdGVtXG4gICAgICAgIHRoaXMuX3BhZ2VIZWFkZXJTZXJ2aWNlLnNlbGVjdCh0aGlzLml0ZW0pO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIElucHV0LCBPbkRlc3Ryb3ksIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBkZWxheSwgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcclxuaW1wb3J0IHsgUGFnZUhlYWRlclNlcnZpY2UgfSBmcm9tICcuLi8uLi9wYWdlLWhlYWRlci5zZXJ2aWNlJztcclxuaW1wb3J0IHsgUGFnZUhlYWRlck5hdmlnYXRpb25JdGVtIH0gZnJvbSAnLi4vbmF2aWdhdGlvbi5jb21wb25lbnQnO1xyXG5cclxuQERpcmVjdGl2ZSh7XHJcbiAgICBzZWxlY3RvcjogJ1t1eFBhZ2VIZWFkZXJOYXZpZ2F0aW9uU2Vjb25kYXJ5SXRlbV0nXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBQYWdlSGVhZGVyTmF2aWdhdGlvblNlY29uZGFyeUl0ZW1EaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XHJcblxyXG4gICAgQElucHV0KCd1eFBhZ2VIZWFkZXJOYXZpZ2F0aW9uU2Vjb25kYXJ5SXRlbScpXHJcbiAgICBpdGVtOiBQYWdlSGVhZGVyTmF2aWdhdGlvbkl0ZW07XHJcblxyXG4gICAgcHJpdmF0ZSBfb25EZXN0cm95ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9wYWdlSGVhZGVyU2VydmljZTogUGFnZUhlYWRlclNlcnZpY2UpIHsgfVxyXG5cclxuICAgIG5nT25Jbml0KCkge1xyXG5cclxuICAgICAgICB0aGlzLl9wYWdlSGVhZGVyU2VydmljZS5zZWxlY3RlZCQucGlwZShkZWxheSgwKSwgdGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZShuZXh0ID0+IHtcclxuXHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBzZWxlY3RlZCBzdGF0ZSBmb3IgdGhpcyBpdGVtXHJcbiAgICAgICAgICAgIHRoaXMuX3BhZ2VIZWFkZXJTZXJ2aWNlLnVwZGF0ZUl0ZW0odGhpcy5pdGVtLCBuZXh0KTtcclxuXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fb25EZXN0cm95Lm5leHQoKTtcclxuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kuY29tcGxldGUoKTtcclxuICAgIH1cclxufSIsImltcG9ydCB7IEFmdGVyVmlld0luaXQsIENvbXBvbmVudCwgRWxlbWVudFJlZiwgT25EZXN0cm95LCBRdWVyeUxpc3QsIFZpZXdDaGlsZHJlbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcy9CZWhhdmlvclN1YmplY3QnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcy9TdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgZGlzdGluY3RVbnRpbENoYW5nZWQgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBSZXNpemVTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vLi4vZGlyZWN0aXZlcy9yZXNpemUvaW5kZXgnO1xuaW1wb3J0IHsgUGFnZUhlYWRlck5hdmlnYXRpb24sIFBhZ2VIZWFkZXJTZXJ2aWNlIH0gZnJvbSAnLi4vcGFnZS1oZWFkZXIuc2VydmljZSc7XG5pbXBvcnQgeyBQYWdlSGVhZGVyTmF2aWdhdGlvbkl0ZW1Db21wb25lbnQgfSBmcm9tICcuL25hdmlnYXRpb24taXRlbS9uYXZpZ2F0aW9uLWl0ZW0uY29tcG9uZW50JztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1wYWdlLWhlYWRlci1ob3Jpem9udGFsLW5hdmlnYXRpb24nLFxuICAgIHRlbXBsYXRlOiBgPHV4LXBhZ2UtaGVhZGVyLWhvcml6b250YWwtbmF2aWdhdGlvbi1pdGVtXG4gICAgKm5nRm9yPVwibGV0IGl0ZW0gb2YgaXRlbXMkIHwgYXN5bmNcIlxuICAgIFtpdGVtXT1cIml0ZW1cIj5cbjwvdXgtcGFnZS1oZWFkZXItaG9yaXpvbnRhbC1uYXZpZ2F0aW9uLWl0ZW0+XG5cbjxkaXYgY2xhc3M9XCJzZWxlY3RlZC1pbmRpY2F0b3JcIlxuICAgIFtzdHlsZS5vcGFjaXR5XT1cImluZGljYXRvclZpc2libGUgPyAxIDogMFwiXG4gICAgW3N0eWxlLm1hcmdpbi1sZWZ0LnB4XT1cImluZGljYXRvclhcIlxuICAgIFtzdHlsZS53aWR0aC5weF09XCJpbmRpY2F0b3JXaWR0aFwiPlxuPC9kaXY+YCxcbiAgICBob3N0OiB7XG4gICAgICAgICdyb2xlJzogJ21lbnViYXInXG4gICAgfVxufSlcbmV4cG9ydCBjbGFzcyBQYWdlSGVhZGVyTmF2aWdhdGlvbkNvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQsIE9uRGVzdHJveSB7XG5cbiAgICBAVmlld0NoaWxkcmVuKFBhZ2VIZWFkZXJOYXZpZ2F0aW9uSXRlbUNvbXBvbmVudCkgbWVudUl0ZW1zOiBRdWVyeUxpc3Q8UGFnZUhlYWRlck5hdmlnYXRpb25JdGVtQ29tcG9uZW50PjtcblxuICAgIGl0ZW1zJDogQmVoYXZpb3JTdWJqZWN0PFBhZ2VIZWFkZXJOYXZpZ2F0aW9uSXRlbVtdPiA9IHRoaXMuX3BhZ2VIZWFkZXJTZXJ2aWNlLml0ZW1zJDtcbiAgICBpbmRpY2F0b3JWaXNpYmxlOiBib29sZWFuID0gZmFsc2U7XG4gICAgaW5kaWNhdG9yWDogbnVtYmVyID0gMDtcbiAgICBpbmRpY2F0b3JXaWR0aDogbnVtYmVyID0gMDtcblxuICAgIHByaXZhdGUgX3N1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24oKTtcblxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIHJlc2l6ZVNlcnZpY2U6IFJlc2l6ZVNlcnZpY2UsIHByaXZhdGUgX3BhZ2VIZWFkZXJTZXJ2aWNlOiBQYWdlSGVhZGVyU2VydmljZSkge1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24uYWRkKHJlc2l6ZVNlcnZpY2UuYWRkUmVzaXplTGlzdGVuZXIoZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50KS5zdWJzY3JpYmUodGhpcy51cGRhdGVTZWxlY3RlZEluZGljYXRvci5iaW5kKHRoaXMpKSk7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi5hZGQoX3BhZ2VIZWFkZXJTZXJ2aWNlLnNlbGVjdGVkJC5waXBlKGRpc3RpbmN0VW50aWxDaGFuZ2VkKCkpLnN1YnNjcmliZSh0aGlzLnVwZGF0ZVNlbGVjdGVkSW5kaWNhdG9yLmJpbmQodGhpcykpKTtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLmFkZChfcGFnZUhlYWRlclNlcnZpY2Uuc2Vjb25kYXJ5JC5waXBlKGRpc3RpbmN0VW50aWxDaGFuZ2VkKCkpLnN1YnNjcmliZSh0aGlzLnVwZGF0ZVNlbGVjdGVkSW5kaWNhdG9yLmJpbmQodGhpcykpKTtcbiAgICB9XG5cbiAgICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMudXBkYXRlU2VsZWN0ZWRJbmRpY2F0b3IoKTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuXG4gICAgdXBkYXRlU2VsZWN0ZWRJbmRpY2F0b3IoKTogdm9pZCB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgLy8gZmluZCB0aGUgc2VsZWN0ZWQgaXRlbVxuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWQgPSB0aGlzLm1lbnVJdGVtcy5maW5kKGl0ZW0gPT4gaXRlbS5pdGVtLnNlbGVjdGVkKTtcblxuICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IHRvIHNob3cgdGhlIGluZGljYXRvclxuICAgICAgICAgICAgdGhpcy5pbmRpY2F0b3JWaXNpYmxlID0gISFzZWxlY3RlZDtcblxuICAgICAgICAgICAgLy8gc2V0IHRoZSB3aWR0aCBvZiB0aGUgaW5kaWNhdG9yIHRvIG1hdGNoIHRoZSB3aWR0aCBvZiB0aGUgbmF2aWdhdGlvbiBpdGVtXG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHlsZXMgPSBnZXRDb21wdXRlZFN0eWxlKHNlbGVjdGVkLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmluZGljYXRvclggPSBzZWxlY3RlZC5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQub2Zmc2V0TGVmdDtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGljYXRvcldpZHRoID0gcGFyc2VJbnQoc3R5bGVzLmdldFByb3BlcnR5VmFsdWUoJ3dpZHRoJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBQYWdlSGVhZGVyTmF2aWdhdGlvbkl0ZW0ge1xuICAgIGljb24/OiBzdHJpbmc7XG4gICAgdGl0bGU6IHN0cmluZztcbiAgICBzZWxlY3RlZD86IGJvb2xlYW47XG4gICAgc2VsZWN0PzogKGl0ZW06IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uSXRlbSkgPT4gdm9pZDtcbiAgICBjaGlsZHJlbj86IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uRHJvcGRvd25JdGVtW107XG4gICAgcGFyZW50PzogUGFnZUhlYWRlck5hdmlnYXRpb247XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGFnZUhlYWRlck5hdmlnYXRpb25Ecm9wZG93bkl0ZW0ge1xuICAgIHRpdGxlOiBzdHJpbmc7XG4gICAgc2VsZWN0ZWQ/OiBib29sZWFuO1xuICAgIHNlbGVjdD86IChpdGVtOiBQYWdlSGVhZGVyTmF2aWdhdGlvbkRyb3Bkb3duSXRlbSkgPT4gdm9pZDtcbiAgICBjaGlsZHJlbj86IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uRHJvcGRvd25JdGVtW107XG4gICAgcGFyZW50PzogUGFnZUhlYWRlck5hdmlnYXRpb247XG59XG5cbi8vIFRoaXMgaXMgYW4gYWxpYXMgZm9yIE1GIHVzZSBhcyBcIkRyb3Bkb3duSXRlbVwiIGRvZXNuJ3QgbWFrZSBzZW5zZSBpbiBjb250ZXh0IHdpdGggaG93IGl0IGlzIHVzZWRcbmV4cG9ydCBpbnRlcmZhY2UgUGFnZUhlYWRlclNlY29uZGFyeU5hdmlnYXRpb25JdGVtIGV4dGVuZHMgUGFnZUhlYWRlck5hdmlnYXRpb25Ecm9wZG93bkl0ZW0geyB9IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBDb250ZW50Q2hpbGRyZW4sIEV2ZW50RW1pdHRlciwgSW5wdXQsIE91dHB1dCwgUXVlcnlMaXN0LCBUZW1wbGF0ZVJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcy9CZWhhdmlvclN1YmplY3QnO1xuaW1wb3J0IHsgQ29sb3JTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvY29sb3IvaW5kZXgnO1xuaW1wb3J0IHsgQnJlYWRjcnVtYiB9IGZyb20gJy4uL2JyZWFkY3J1bWJzL2luZGV4JztcbmltcG9ydCB7IFBhZ2VIZWFkZXJDdXN0b21NZW51RGlyZWN0aXZlIH0gZnJvbSAnLi9jdXN0b20tbWVudS9jdXN0b20tbWVudS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgUGFnZUhlYWRlckljb25NZW51IH0gZnJvbSAnLi9pbnRlcmZhY2VzJztcbmltcG9ydCB7IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uSXRlbSB9IGZyb20gJy4vbmF2aWdhdGlvbi9uYXZpZ2F0aW9uLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBQYWdlSGVhZGVyTmF2aWdhdGlvbiwgUGFnZUhlYWRlclNlcnZpY2UgfSBmcm9tICcuL3BhZ2UtaGVhZGVyLnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LXBhZ2UtaGVhZGVyJyxcbiAgICBleHBvcnRBczogJ3V4LXBhZ2UtaGVhZGVyJyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJ1eC1wYWdlLWhlYWRlclwiIFtjbGFzcy5wYWdlLWhlYWRlci1jb25kZW5zZWRdPVwiY29uZGVuc2VkXCIgcm9sZT1cImJhbm5lclwiPlxuXG4gICAgPCEtLSBEaXNwbGF5IFVwcGVyIFNlY3Rpb24gd2hlbiBub3QgY29uZGVuc2VkIC0tPlxuICAgIDxkaXYgY2xhc3M9XCJwYWdlLWhlYWRlci1hY3Rpb25zXCIgKm5nSWY9XCIhY29uZGVuc2VkXCI+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cInBhZ2UtaGVhZGVyLWxvZ28tY29udGFpbmVyXCIgcm9sZT1cInByZXNlbnRhdGlvblwiIFtoaWRkZW5dPVwiIWxvZ29cIj5cbiAgICAgICAgICAgIDxpbWcgW2F0dHIuc3JjXT1cImxvZ29cIiBjbGFzcz1cInBhZ2UtaGVhZGVyLWxvZ29cIj5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cInBhZ2UtaGVhZGVyLW5hdmlnYXRpb25cIiBbbmdDbGFzc109XCJhbGlnbm1lbnRcIiByb2xlPVwibmF2aWdhdGlvblwiIGFyaWEtbGFiZWw9XCJQcmltYXJ5IE5hdmlnYXRpb25cIj5cblxuICAgICAgICAgICAgPCEtLSBUaGUgVG9wIE5hdmlnYXRpb24gT3B0aW9ucyAtLT5cbiAgICAgICAgICAgIDx1eC1wYWdlLWhlYWRlci1ob3Jpem9udGFsLW5hdmlnYXRpb24+PC91eC1wYWdlLWhlYWRlci1ob3Jpem9udGFsLW5hdmlnYXRpb24+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDxkaXYgY2xhc3M9XCJwYWdlLWhlYWRlci1pY29uLW1lbnVzXCIgcm9sZT1cInRvb2xiYXJcIj5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nRm9yPVwibGV0IG1lbnUgb2YgY3VzdG9tTWVudXNcIiBbbmdUZW1wbGF0ZU91dGxldF09XCJtZW51XCI+PC9uZy1jb250YWluZXI+XG5cbiAgICAgICAgICAgIDx1eC1wYWdlLWhlYWRlci1pY29uLW1lbnUgKm5nRm9yPVwibGV0IG1lbnUgb2YgaWNvbk1lbnVzXCIgW21lbnVdPVwibWVudVwiPjwvdXgtcGFnZS1oZWFkZXItaWNvbi1tZW51PlxuICAgICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cblxuICAgIDwhLS0gRGlzcGxheSBMb3dlciBTZWN0aW9uIFdoZW4gTm90IENvbmRlbnNlZCAtLT5cbiAgICA8ZGl2IGNsYXNzPVwicGFnZS1oZWFkZXItZGV0YWlsc1wiICpuZ0lmPVwiIWNvbmRlbnNlZFwiPlxuXG4gICAgICAgIDxkaXYgY2xhc3M9XCJwYWdlLWhlYWRlci1zdGF0ZS1jb250YWluZXJcIiByb2xlPVwibmF2aWdhdGlvblwiPlxuXG4gICAgICAgICAgICA8YnV0dG9uICpuZ0lmPVwiYmFja1Zpc2libGUgPT09IHRydWVcIiBjbGFzcz1cInBhZ2UtaGVhZGVyLWJhY2stYnV0dG9uXCIgKGNsaWNrKT1cImdvQmFjaygpXCIgYXJpYS1sYWJlbD1cIkdvIEJhY2tcIj5cbiAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImhwZS1pY29uIGhwZS1wcmV2aW91cyB0ZXh0LXByaW1hcnlcIj48L3NwYW4+XG4gICAgICAgICAgICA8L2J1dHRvbj5cblxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInBhZ2UtaGVhZGVyLXRpdGxlLWNvbnRhaW5lclwiPlxuXG4gICAgICAgICAgICAgICAgPHV4LWJyZWFkY3J1bWJzIFtjcnVtYnNdPVwiY3J1bWJzXCI+PC91eC1icmVhZGNydW1icz5cblxuICAgICAgICAgICAgICAgIDxoMSBjbGFzcz1cInBhZ2UtaGVhZGVyLXRpdGxlXCIgW3N0eWxlLmJhY2tncm91bmRDb2xvcl09XCJmYW1pbHlCYWNrZ3JvdW5kXCIgW3N0eWxlLmNvbG9yXT1cImZhbWlseUZvcmVncm91bmRcIj57eyBoZWFkZXIgfX08L2gxPlxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPC9kaXY+XG5cbiAgICA8L2Rpdj5cblxuICAgIDwhLS0gRGlzcGxheSBUaGlzIFNlY3Rpb24gT3B0aW1pemVkIGZvciBDb25kZW5zZWQgTW9kZSAtLT5cbiAgICA8ZGl2IGNsYXNzPVwicGFnZS1oZWFkZXItY29uZGVuc2VkLWNvbnRlbnRcIiAqbmdJZj1cImNvbmRlbnNlZFwiPlxuXG4gICAgICAgIDxkaXYgY2xhc3M9XCJwYWdlLWhlYWRlci1icmVhZGNydW1ic1wiIHJvbGU9XCJuYXZpZ2F0aW9uXCI+XG4gICAgICAgICAgICA8dXgtYnJlYWRjcnVtYnMgW2NydW1ic109XCJjcnVtYnNcIj48L3V4LWJyZWFkY3J1bWJzPlxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8ZGl2IGNsYXNzPVwicGFnZS1oZWFkZXItbmF2aWdhdGlvblwiIFtuZ0NsYXNzXT1cImFsaWdubWVudFwiIHJvbGU9XCJuYXZpZ2F0aW9uXCIgYXJpYS1sYWJlbD1cIlByaW1hcnkgTmF2aWdhdGlvblwiPlxuXG4gICAgICAgICAgICA8IS0tIFRoZSBUb3AgTmF2aWdhdGlvbiBPcHRpb25zIC0tPlxuICAgICAgICAgICAgPHV4LXBhZ2UtaGVhZGVyLWhvcml6b250YWwtbmF2aWdhdGlvbj48L3V4LXBhZ2UtaGVhZGVyLWhvcml6b250YWwtbmF2aWdhdGlvbj5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cInBhZ2UtaGVhZGVyLWljb24tbWVudXNcIiByb2xlPVwidG9vbGJhclwiPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdGb3I9XCJsZXQgbWVudSBvZiBjdXN0b21NZW51c1wiIFtuZ1RlbXBsYXRlT3V0bGV0XT1cIm1lbnVcIj48L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgIDx1eC1wYWdlLWhlYWRlci1pY29uLW1lbnUgKm5nRm9yPVwibGV0IG1lbnUgb2YgaWNvbk1lbnVzXCIgW21lbnVdPVwibWVudVwiPjwvdXgtcGFnZS1oZWFkZXItaWNvbi1tZW51PlxuICAgICAgICA8L2Rpdj5cblxuICAgIDwvZGl2PlxuXG48L2Rpdj5cblxuPGRpdiBjbGFzcz1cInBhZ2UtaGVhZGVyLXNlY29uZGFyeVwiIFtuZ0NsYXNzXT1cInNlY29uZGFyeU5hdmlnYXRpb25BbGlnbm1lbnRcIiByb2xlPVwibmF2aWdhdGlvblwiICpuZ0lmPVwic2Vjb25kYXJ5TmF2aWdhdGlvbiAmJiAoc2VsZWN0ZWRSb290JCB8IGFzeW5jKVwiPlxuICAgIDx1bCBjbGFzcz1cIm5hdiBuYXYtdGFic1wiIHJvbGU9XCJ0YWJsaXN0XCIgYXJpYS1sYWJlbD1cIlNlY29uZGFyeSBOYXZpZ2F0aW9uXCIgKm5nSWY9XCIoc2VsZWN0ZWRSb290JCB8IGFzeW5jKT8uY2hpbGRyZW47IGxldCBjaGlsZHJlblwiPlxuICAgICAgICA8bGkgKm5nRm9yPVwibGV0IGNoaWxkIG9mIGNoaWxkcmVuXCJcbiAgICAgICAgICAgIFtjbGFzcy5hY3RpdmVdPVwiY2hpbGQuc2VsZWN0ZWRcIlxuICAgICAgICAgICAgcm9sZT1cIm5vbmVcIlxuICAgICAgICAgICAgW3V4UGFnZUhlYWRlck5hdmlnYXRpb25TZWNvbmRhcnlJdGVtXT1cImNoaWxkXCI+XG5cbiAgICAgICAgICAgIDxhIHJvbGU9XCJ0YWJcIlxuICAgICAgICAgICAgICAgIFthdHRyLmFyaWEtc2VsZWN0ZWRdPVwiY2hpbGQuc2VsZWN0ZWRcIlxuICAgICAgICAgICAgICAgIHRhYmluZGV4PVwiMFwiXG4gICAgICAgICAgICAgICAgKGNsaWNrKT1cInNlbGVjdChjaGlsZClcIlxuICAgICAgICAgICAgICAgIChrZXlkb3duLmVudGVyKT1cInNlbGVjdChjaGlsZClcIj57eyBjaGlsZC50aXRsZSB9fTwvYT5cblxuICAgICAgICA8L2xpPlxuICAgIDwvdWw+XG48L2Rpdj5gLFxuICAgIHByb3ZpZGVyczogWyBQYWdlSGVhZGVyU2VydmljZSBdXG59KVxuZXhwb3J0IGNsYXNzIFBhZ2VIZWFkZXJDb21wb25lbnQge1xuXG4gICAgQElucHV0KCkgbG9nbzogc3RyaW5nO1xuICAgIEBJbnB1dCgpIGhlYWRlcjogc3RyaW5nO1xuICAgIEBJbnB1dCgpIGFsaWdubWVudDogJ2xlZnQnIHwgJ3JpZ2h0JyB8ICdjZW50ZXInID0gJ2NlbnRlcic7XG4gICAgQElucHV0KCkgY29uZGVuc2VkOiBib29sZWFuID0gZmFsc2U7XG4gICAgQElucHV0KCkgaWNvbk1lbnVzOiBQYWdlSGVhZGVySWNvbk1lbnVbXTtcbiAgICBASW5wdXQoKSBiYWNrVmlzaWJsZTogYm9vbGVhbiA9IHRydWU7XG4gICAgQElucHV0KCkgc2Vjb25kYXJ5TmF2aWdhdGlvbkFsaWdubWVudDogc3RyaW5nID0gJ2NlbnRlcic7XG5cbiAgICBASW5wdXQoKSBzZXQgc2Vjb25kYXJ5TmF2aWdhdGlvbkF1dG9zZWxlY3QodmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5fcGFnZUhlYWRlclNlcnZpY2Uuc2Vjb25kYXJ5TmF2aWdhdGlvbkF1dG9zZWxlY3QgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBnZXQgc2Vjb25kYXJ5TmF2aWdhdGlvbkF1dG9zZWxlY3QoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYWdlSGVhZGVyU2VydmljZS5zZWNvbmRhcnlOYXZpZ2F0aW9uQXV0b3NlbGVjdDtcbiAgICB9XG5cbiAgICBASW5wdXQoKSBzZXQgaXRlbXMoaXRlbXM6IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uSXRlbVtdKSB7XG4gICAgICAgIHRoaXMuX3BhZ2VIZWFkZXJTZXJ2aWNlLnNldEl0ZW1zKGl0ZW1zKTtcbiAgICB9XG5cbiAgICBASW5wdXQoKSBzZXQgc2Vjb25kYXJ5TmF2aWdhdGlvbihlbmFibGVkOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuX3BhZ2VIZWFkZXJTZXJ2aWNlLnNldFNlY29uZGFyeU5hdmlnYXRpb24oZW5hYmxlZCk7XG4gICAgfVxuXG4gICAgZ2V0IHNlY29uZGFyeU5hdmlnYXRpb24oKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYWdlSGVhZGVyU2VydmljZS5zZWNvbmRhcnkkLmdldFZhbHVlKCk7XG4gICAgfVxuXG4gICAgQElucHV0KCkgc2V0IGNydW1icyhjcnVtYnM6IEJyZWFkY3J1bWJbXSkge1xuICAgICAgICB0aGlzLl9jcnVtYnMgPSBjcnVtYnM7XG4gICAgfVxuXG4gICAgZ2V0IGNydW1icygpOiBCcmVhZGNydW1iW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25kZW5zZWQgPyBbLi4udGhpcy5fY3J1bWJzLCB7IHRpdGxlOiB0aGlzLmhlYWRlciB9XSA6IHRoaXMuX2NydW1icztcbiAgICB9XG5cbiAgICBASW5wdXQoKVxuICAgIHNldCBmYW1pbHlCYWNrZ3JvdW5kKGNvbG9yOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5fZmFtaWx5QmFja2dyb3VuZCA9IHRoaXMuX2NvbG9yU2VydmljZS5yZXNvbHZlKGNvbG9yKTtcbiAgICB9XG5cbiAgICBnZXQgZmFtaWx5QmFja2dyb3VuZCgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmFtaWx5QmFja2dyb3VuZDtcbiAgICB9XG5cbiAgICBASW5wdXQoKVxuICAgIHNldCBmYW1pbHlGb3JlZ3JvdW5kKGNvbG9yOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5fZmFtaWx5Rm9yZWdyb3VuZCA9IHRoaXMuX2NvbG9yU2VydmljZS5yZXNvbHZlKGNvbG9yKTtcbiAgICB9XG5cbiAgICBnZXQgZmFtaWx5Rm9yZWdyb3VuZCgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmFtaWx5Rm9yZWdyb3VuZDtcbiAgICB9XG5cbiAgICBAT3V0cHV0KCkgYmFja0NsaWNrID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgQENvbnRlbnRDaGlsZHJlbihQYWdlSGVhZGVyQ3VzdG9tTWVudURpcmVjdGl2ZSwgeyByZWFkOiBUZW1wbGF0ZVJlZiB9KSBjdXN0b21NZW51czogUXVlcnlMaXN0PFRlbXBsYXRlUmVmPGFueT4+O1xuXG4gICAgc2VsZWN0ZWQkOiBCZWhhdmlvclN1YmplY3Q8UGFnZUhlYWRlck5hdmlnYXRpb25JdGVtPiA9IHRoaXMuX3BhZ2VIZWFkZXJTZXJ2aWNlLnNlbGVjdGVkJDtcbiAgICBzZWxlY3RlZFJvb3QkOiBCZWhhdmlvclN1YmplY3Q8UGFnZUhlYWRlck5hdmlnYXRpb25JdGVtPiA9IHRoaXMuX3BhZ2VIZWFkZXJTZXJ2aWNlLnNlbGVjdGVkUm9vdCQ7XG5cbiAgICBwcml2YXRlIF9jcnVtYnM6IEJyZWFkY3J1bWJbXSA9IFtdO1xuICAgIHByaXZhdGUgX2ZhbWlseUJhY2tncm91bmQ6IHN0cmluZztcbiAgICBwcml2YXRlIF9mYW1pbHlGb3JlZ3JvdW5kOiBzdHJpbmc7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9jb2xvclNlcnZpY2U6IENvbG9yU2VydmljZSwgcHJpdmF0ZSBfcGFnZUhlYWRlclNlcnZpY2U6IFBhZ2VIZWFkZXJTZXJ2aWNlKSB7IH1cblxuICAgIGdvQmFjaygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5iYWNrQ2xpY2suZW1pdCgpO1xuICAgIH1cblxuICAgIHNlbGVjdChpdGVtOiBQYWdlSGVhZGVyTmF2aWdhdGlvbik6IHZvaWQge1xuICAgICAgICB0aGlzLl9wYWdlSGVhZGVyU2VydmljZS5zZWxlY3QoaXRlbSk7XG4gICAgfVxufSIsImltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQnNEcm9wZG93bk1vZHVsZSB9IGZyb20gJ25neC1ib290c3RyYXAvZHJvcGRvd24nO1xuaW1wb3J0IHsgTWVudU5hdmlnYXRpb25Nb2R1bGUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL21lbnUtbmF2aWdhdGlvbi9pbmRleCc7XG5pbXBvcnQgeyBSZXNpemVNb2R1bGUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL3Jlc2l6ZS9pbmRleCc7XG5pbXBvcnQgeyBDb2xvclNlcnZpY2VNb2R1bGUgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9jb2xvci9pbmRleCc7XG5pbXBvcnQgeyBCcmVhZGNydW1ic01vZHVsZSB9IGZyb20gJy4uL2JyZWFkY3J1bWJzL2luZGV4JztcbmltcG9ydCB7IFBhZ2VIZWFkZXJDdXN0b21NZW51RGlyZWN0aXZlIH0gZnJvbSAnLi9jdXN0b20tbWVudS9jdXN0b20tbWVudS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgUGFnZUhlYWRlckljb25NZW51Q29tcG9uZW50IH0gZnJvbSAnLi9pY29uLW1lbnUvaWNvbi1tZW51LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBQYWdlSGVhZGVyTmF2aWdhdGlvbkRyb3Bkb3duSXRlbUNvbXBvbmVudCB9IGZyb20gJy4vbmF2aWdhdGlvbi9uYXZpZ2F0aW9uLWRyb3Bkb3duLWl0ZW0vbmF2aWdhdGlvbi1kcm9wZG93bi1pdGVtLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBQYWdlSGVhZGVyTmF2aWdhdGlvbkl0ZW1Db21wb25lbnQgfSBmcm9tICcuL25hdmlnYXRpb24vbmF2aWdhdGlvbi1pdGVtL25hdmlnYXRpb24taXRlbS5jb21wb25lbnQnO1xuaW1wb3J0IHsgUGFnZUhlYWRlck5hdmlnYXRpb25TZWNvbmRhcnlJdGVtRGlyZWN0aXZlIH0gZnJvbSAnLi9uYXZpZ2F0aW9uL25hdmlnYXRpb24tc2Vjb25kYXJ5LWl0ZW0vbmF2aWdhdGlvbi1zZWNvbmRhcnktaXRlbS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgUGFnZUhlYWRlck5hdmlnYXRpb25Db21wb25lbnQgfSBmcm9tICcuL25hdmlnYXRpb24vbmF2aWdhdGlvbi5jb21wb25lbnQnO1xuaW1wb3J0IHsgUGFnZUhlYWRlckNvbXBvbmVudCB9IGZyb20gJy4vcGFnZS1oZWFkZXIuY29tcG9uZW50JztcblxuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBCcmVhZGNydW1ic01vZHVsZSxcbiAgICAgICAgQ29sb3JTZXJ2aWNlTW9kdWxlLFxuICAgICAgICBSZXNpemVNb2R1bGUsXG4gICAgICAgIE1lbnVOYXZpZ2F0aW9uTW9kdWxlLFxuICAgICAgICBCc0Ryb3Bkb3duTW9kdWxlLmZvclJvb3QoKVxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBQYWdlSGVhZGVyQ29tcG9uZW50LFxuICAgICAgICBQYWdlSGVhZGVyQ3VzdG9tTWVudURpcmVjdGl2ZVxuICAgIF0sXG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIFBhZ2VIZWFkZXJDb21wb25lbnQsXG4gICAgICAgIFBhZ2VIZWFkZXJJY29uTWVudUNvbXBvbmVudCxcbiAgICAgICAgUGFnZUhlYWRlckN1c3RvbU1lbnVEaXJlY3RpdmUsXG4gICAgICAgIFBhZ2VIZWFkZXJOYXZpZ2F0aW9uQ29tcG9uZW50LFxuICAgICAgICBQYWdlSGVhZGVyTmF2aWdhdGlvbkl0ZW1Db21wb25lbnQsXG4gICAgICAgIFBhZ2VIZWFkZXJOYXZpZ2F0aW9uRHJvcGRvd25JdGVtQ29tcG9uZW50LFxuICAgICAgICBQYWdlSGVhZGVyTmF2aWdhdGlvblNlY29uZGFyeUl0ZW1EaXJlY3RpdmVcbiAgICBdXG59KVxuZXhwb3J0IGNsYXNzIFBhZ2VIZWFkZXJNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBDb21wb25lbnQsIElucHV0LCBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LXByb2dyZXNzLWJhcicsXG4gICAgdGVtcGxhdGU6IGA8ZGl2ICpuZ0lmPVwiIWluZGV0ZXJtaW5hdGVcIiBjbGFzcz1cInByb2dyZXNzYmFyLXRyYWNrXCIgW3N0eWxlLndpZHRoLiVdPVwiKHZhbHVlIC8gbWF4KSAqIDEwMFwiIFtzdHlsZS5iYWNrZ3JvdW5kQ29sb3JdPVwiYmFyQ29sb3JcIj5cbiAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG48L2Rpdj5cbjxkaXYgKm5nSWY9XCJpbmRldGVybWluYXRlXCIgY2xhc3M9XCJwcm9ncmVzc2Jhci10cmFjayBpbmRldGVybWluYXRlXCIgW3N0eWxlLmJhY2tncm91bmRDb2xvcl09XCJiYXJDb2xvclwiPlxuICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbjwvZGl2PmAsXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgUHJvZ3Jlc3NCYXJDb21wb25lbnQge1xuICAgIEBJbnB1dCgpIHZhbHVlOiBudW1iZXIgPSAwO1xuICAgIEBJbnB1dCgpIG1heDogbnVtYmVyID0gMTAwO1xuICAgIEBJbnB1dCgpIGluZGV0ZXJtaW5hdGU6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBASW5wdXQoKSB0cmFja0NvbG9yOiBzdHJpbmc7XG4gICAgQElucHV0KCkgYmFyQ29sb3I6IHN0cmluZztcbn1cbiIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuXG5pbXBvcnQgeyBQcm9ncmVzc0JhckNvbXBvbmVudCB9IGZyb20gJy4vcHJvZ3Jlc3MtYmFyLmNvbXBvbmVudCc7XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGVcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtQcm9ncmVzc0JhckNvbXBvbmVudF0sXG4gICAgZGVjbGFyYXRpb25zOiBbUHJvZ3Jlc3NCYXJDb21wb25lbnRdXG59KVxuZXhwb3J0IGNsYXNzIFByb2dyZXNzQmFyTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIElucHV0LCBPdXRwdXQsIGZvcndhcmRSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBOR19WQUxVRV9BQ0NFU1NPUiB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuZXhwb3J0IGNvbnN0IFJBRElPQlVUVE9OX1ZBTFVFX0FDQ0VTU09SOiBhbnkgPSB7XG4gICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gUmFkaW9CdXR0b25Db21wb25lbnQpLFxuICAgIG11bHRpOiB0cnVlXG59O1xuXG5sZXQgdW5pcXVlUmFkaW9JZCA9IDA7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtcmFkaW8tYnV0dG9uJyxcbiAgICB0ZW1wbGF0ZTogYDxsYWJlbCBbYXR0ci5mb3JdPVwiaW5wdXRJZFwiIGNsYXNzPVwidXgtcmFkaW8tYnV0dG9uXCJcbiAgICAgICBbY2xhc3MudXgtcmFkaW8tYnV0dG9uLWNoZWNrZWRdPVwidmFsdWUgPT09IG9wdGlvblwiXG4gICAgICAgW2NsYXNzLnV4LXJhZGlvLWJ1dHRvbi1zaW1wbGlmaWVkXT1cInNpbXBsaWZpZWRcIlxuICAgICAgIFtjbGFzcy51eC1yYWRpby1idXR0b24tZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuICAgICAgIFtjbGFzcy51eC1yYWRpby1idXR0b24tZm9jdXNlZF09XCJmb2N1c2VkXCI+XG5cbiAgICA8ZGl2IGNsYXNzPVwidXgtcmFkaW8tYnV0dG9uLWNvbnRhaW5lclwiPlxuICAgICAgICA8aW5wdXQgY2xhc3M9XCJ1eC1yYWRpby1idXR0b24taW5wdXRcIlxuICAgICAgICAgICAgdHlwZT1cInJhZGlvXCJcbiAgICAgICAgICAgIFtpZF09XCJpbnB1dElkXCJcbiAgICAgICAgICAgIFtjaGVja2VkXT1cInZhbHVlID09PSBvcHRpb25cIlxuICAgICAgICAgICAgW2Rpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICAgICAgIFt0YWJpbmRleF09XCJ0YWJpbmRleCB8fCB2YWx1ZSA9PT0gb3B0aW9uID8gMCA6IC0xXCJcbiAgICAgICAgICAgIFthdHRyLm5hbWVdPVwibmFtZVwiXG4gICAgICAgICAgICBbcmVxdWlyZWRdPVwicmVxdWlyZWRcIlxuICAgICAgICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XCJhcmlhTGFiZWxcIlxuICAgICAgICAgICAgW2F0dHIuYXJpYS1sYWJlbGxlZGJ5XT1cImFyaWFMYWJlbGxlZGJ5XCJcbiAgICAgICAgICAgIFthdHRyLmFyaWEtZGVzY3JpYmVkYnldPVwiYXJpYURlc2NyaWJlZGJ5XCJcbiAgICAgICAgICAgIFthdHRyLmFyaWEtY2hlY2tlZF09XCJ2YWx1ZSA9PT0gb3B0aW9uXCJcbiAgICAgICAgICAgIChmb2N1cyk9XCJmb2N1c2VkID0gdHJ1ZVwiXG4gICAgICAgICAgICAoYmx1cik9XCJmb2N1c2VkID0gZmFsc2VcIlxuICAgICAgICAgICAgKGNoYW5nZSk9XCJ0b2dnbGUoKVwiXG4gICAgICAgICAgICAoY2xpY2spPVwiJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXCI+XG4gICAgPC9kaXY+XG5cbiAgICA8c3BhbiBjbGFzcz1cInV4LXJhZGlvLWJ1dHRvbi1sYWJlbFwiPlxuICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgPC9zcGFuPlxuXG48L2xhYmVsPmAsXG4gICAgcHJvdmlkZXJzOiBbUkFESU9CVVRUT05fVkFMVUVfQUNDRVNTT1JdXG59KVxuZXhwb3J0IGNsYXNzIFJhZGlvQnV0dG9uQ29tcG9uZW50IGltcGxlbWVudHMgQ29udHJvbFZhbHVlQWNjZXNzb3Ige1xuXG4gICAgcHJpdmF0ZSBfcmFkaW9CdXR0b25JZDogc3RyaW5nID0gYHV4LXJhZGlvLWJ1dHRvbi0keysrdW5pcXVlUmFkaW9JZH1gO1xuXG4gICAgQElucHV0KCkgaWQ6IHN0cmluZyA9IHRoaXMuX3JhZGlvQnV0dG9uSWQ7XG4gICAgQElucHV0KCkgbmFtZTogc3RyaW5nIHwgbnVsbDtcbiAgICBASW5wdXQoKSByZXF1aXJlZDogYm9vbGVhbjtcbiAgICBASW5wdXQoKSB0YWJpbmRleDogbnVtYmVyID0gMDtcbiAgICBASW5wdXQoKSBjbGlja2FibGU6IGJvb2xlYW4gPSB0cnVlO1xuICAgIEBJbnB1dCgpIGRpc2FibGVkOiBib29sZWFuID0gZmFsc2U7XG4gICAgQElucHV0KCkgc2ltcGxpZmllZDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIEBJbnB1dCgpIG9wdGlvbjogYW55O1xuICAgIEBJbnB1dCgnYXJpYS1sYWJlbCcpIGFyaWFMYWJlbDogc3RyaW5nID0gJyc7XG4gICAgQElucHV0KCdhcmlhLWxhYmVsbGVkYnknKSBhcmlhTGFiZWxsZWRieTogc3RyaW5nID0gbnVsbDtcbiAgICBASW5wdXQoJ2FyaWEtZGVzY3JpYmVkYnknKSBhcmlhRGVzY3JpYmVkYnk6IHN0cmluZyA9IG51bGw7XG5cbiAgICBAT3V0cHV0KCkgdmFsdWVDaGFuZ2U6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgICBASW5wdXQoKVxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgIH1cblxuICAgIHNldCB2YWx1ZSh2YWx1ZTogYm9vbGVhbikge1xuICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuXG4gICAgICAgIC8vIGludm9rZSBjaGFuZ2UgZXZlbnRcbiAgICAgICAgdGhpcy52YWx1ZUNoYW5nZS5lbWl0KHRoaXMuX3ZhbHVlKTtcblxuICAgICAgICAvLyBjYWxsIGNhbGxiYWNrXG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjayh0aGlzLl92YWx1ZSk7XG4gICAgICAgIHRoaXMub25Ub3VjaGVkQ2FsbGJhY2soKTsgICAgICAgIFxuICAgIH1cblxuICAgIGdldCBpbnB1dElkKCk6IHN0cmluZyB7IFxuICAgICAgICByZXR1cm4gYCR7dGhpcy5pZCB8fCB0aGlzLl9yYWRpb0J1dHRvbklkfS1pbnB1dGA7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfdmFsdWU6IGFueSA9IGZhbHNlO1xuXG4gICAgZm9jdXNlZDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIG9uVG91Y2hlZENhbGxiYWNrOiAoKSA9PiB2b2lkID0gKCkgPT4geyB9O1xuICAgIG9uQ2hhbmdlQ2FsbGJhY2s6IChfOiBhbnkpID0+IHZvaWQgPSAoKSA9PiB7IH07XG5cbiAgICB0b2dnbGUoKTogdm9pZCB7XG5cbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQgfHwgIXRoaXMuY2xpY2thYmxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0b2dnbGUgdGhlIGNoZWNrZWQgc3RhdGVcbiAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMub3B0aW9uO1xuXG4gICAgICAgIC8vIGNhbGwgY2FsbGJhY2tcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKHRoaXMudmFsdWUpO1xuICAgIH1cblxuICAgIC8vIEZ1bmN0aW9ucyByZXF1aXJlZCB0byB1cGRhdGUgbmctbW9kZWxcbiAgICB3cml0ZVZhbHVlKHZhbHVlOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZWdpc3Rlck9uQ2hhbmdlKGZuOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrID0gZm47XG4gICAgfVxuXG4gICAgcmVnaXN0ZXJPblRvdWNoZWQoZm46IGFueSk6IHZvaWQge1xuICAgICAgICB0aGlzLm9uVG91Y2hlZENhbGxiYWNrID0gZm47XG4gICAgfVxuXG4gICAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0Zvcm1zTW9kdWxlfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmltcG9ydCB7IFJhZGlvQnV0dG9uQ29tcG9uZW50IH0gZnJvbSAnLi9yYWRpb2J1dHRvbi5jb21wb25lbnQnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtGb3Jtc01vZHVsZV0sXG4gICAgZXhwb3J0czogW1JhZGlvQnV0dG9uQ29tcG9uZW50XSxcbiAgICBkZWNsYXJhdGlvbnM6IFtSYWRpb0J1dHRvbkNvbXBvbmVudF1cbn0pXG5leHBvcnQgY2xhc3MgUmFkaW9CdXR0b25Nb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QgfSBmcm9tICdyeGpzL0JlaGF2aW9yU3ViamVjdCc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcbmltcG9ydCB7IFNlYXJjaEJ1aWxkZXJDb21wb25lbnREZWZpbml0aW9uIH0gZnJvbSAnLi9pbnRlcmZhY2VzL2NvbXBvbmVudC1kZWZpbml0aW9uLmludGVyZmFjZSc7XG5pbXBvcnQgeyBTZWFyY2hCdWlsZGVyUXVlcnkgfSBmcm9tICcuL2ludGVyZmFjZXMvcXVlcnkuaW50ZXJmYWNlJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFNlYXJjaEJ1aWxkZXJTZXJ2aWNlIHtcblxuICBxdWVyeTogU2VhcmNoQnVpbGRlclF1ZXJ5ID0ge307XG4gIHF1ZXJ5Q2hhbmdlOiBTdWJqZWN0PFNlYXJjaEJ1aWxkZXJRdWVyeT4gPSBuZXcgU3ViamVjdDxTZWFyY2hCdWlsZGVyUXVlcnk+KCk7XG4gIHZhbGlkYXRpb25DaGFuZ2U6IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPiA9IG5ldyBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4odHJ1ZSk7XG5cbiAgcHJpdmF0ZSBfY29tcG9uZW50SWQ6IG51bWJlciA9IDA7XG4gIHByaXZhdGUgX2NvbXBvbmVudHM6IFNlYXJjaEJ1aWxkZXJDb21wb25lbnREZWZpbml0aW9uW10gPSBbXTtcbiAgcHJpdmF0ZSBfdmFsaWRhdGlvbjogeyBba2V5OiBudW1iZXJdOiBib29sZWFuIH0gPSB7fTtcblxuICAvKipcbiAgICogQWRkIGEgY29tcG9uZW50IHRvIHRoZSBpbnRlcm5hbCBsaXN0IG9mIGNvbXBvbmVudHNcbiAgICovXG4gIHJlZ2lzdGVyQ29tcG9uZW50KGNvbXBvbmVudDogU2VhcmNoQnVpbGRlckNvbXBvbmVudERlZmluaXRpb24pOiB2b2lkIHtcblxuICAgIC8vIGVuc3VyZSB0aGVyZSBhcmUgbm8gY29tcG9uZW50cyB3aXRoIGEgbWF0Y2hpbmcgbmFtZVxuICAgIGlmICh0aGlzLl9jb21wb25lbnRzLmZpbmQoY21wID0+IGNtcC5uYW1lID09PSBjb21wb25lbnQubmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgU2VhcmNoIGJ1aWxkZXIgY29tcG9uZW50cyBtdXN0IGhhdmUgYSB1bmlxdWUgbmFtZS4gVGhlIG5hbWUgJHtjb21wb25lbnQubmFtZX0gaGFzIGFscmVhZHkgYmVlbiB1c2VkLmApO1xuICAgIH1cblxuICAgIC8vIGlmIHVuaXF1ZSB0aGVuIGFkZCB0aGUgY29tcG9uZW50IHRvIHRoZSBsaXN0XG4gICAgdGhpcy5fY29tcG9uZW50cy5wdXNoKGNvbXBvbmVudCk7XG4gIH1cblxuICAvKipcbiAgICogQnVsayByZWdpc3RyYXRpb24gb2YgY29tcG9uZW50c1xuICAgKiAoSnVzdCBhIGhlbHBlciBtZXRob2QpXG4gICAqL1xuICByZWdpc3RlckNvbXBvbmVudHMoY29tcG9uZW50czogU2VhcmNoQnVpbGRlckNvbXBvbmVudERlZmluaXRpb25bXSk6IHZvaWQge1xuICAgIGNvbXBvbmVudHMuZm9yRWFjaChjb21wb25lbnQgPT4gdGhpcy5yZWdpc3RlckNvbXBvbmVudChjb21wb25lbnQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSByZWdpc3RlcmVkIGNvbXBvbmVudCBjbGFzc1xuICAgKi9cbiAgZ2V0Q29tcG9uZW50KG5hbWU6IHN0cmluZyk6IGFueSB7XG5cbiAgICAvLyBmaW5kIHRoZSBjb21wb25lbnRcbiAgICBjb25zdCBjb21wb25lbnQgPSB0aGlzLl9jb21wb25lbnRzLmZpbmQoY21wID0+IGNtcC5uYW1lID09PSBuYW1lKTtcblxuICAgIC8vIGlmIHRoZXJlIGlzIG5vIG1hdGNoIHRocm93IGFuIGV4Y2VwdGlvblxuICAgIGlmICghY29tcG9uZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHNlYXJjaCBidWlsZCBjb21wb25lbnQgd2l0aCB0aGUgbmFtZSAke25hbWV9IGV4aXN0c2ApO1xuICAgIH1cblxuICAgIC8vIGVuc3VyZSBjb25maWcgaXMgZGVmaW5lZCAtIGF0IGxlYXN0IHRvIGFuIGVtcHR5IG9iamVjdFxuICAgIGNvbXBvbmVudC5jb25maWcgPSBjb21wb25lbnQuY29uZmlnIHx8IHt9O1xuXG4gICAgcmV0dXJuIGNvbXBvbmVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGludGVybmFsIHNlYXJjaCBxdWVyeSBzdGF0ZVxuICAgKiBub3RlIHRoYXQgdGhlIHF1ZXJ5IHdpbGwgYmUgaW1tdXRhYmxlXG4gICAqL1xuICBzZXRRdWVyeShxdWVyeTogU2VhcmNoQnVpbGRlclF1ZXJ5KTogdm9pZCB7XG4gICAgdGhpcy5xdWVyeSA9IE9iamVjdC5hc3NpZ24oe30sIHF1ZXJ5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGN1cnJlbnQgcXVlcnkgc3RhdGVcbiAgICovXG4gIGdldFF1ZXJ5KCk6IFNlYXJjaEJ1aWxkZXJRdWVyeSB7XG4gICAgcmV0dXJuIHRoaXMucXVlcnk7XG4gIH1cblxuICAvKipcbiAgICogVHJpZ2dlciB0aGUgb2JzZXJ2YWJsZSB0byBpbmRpY2F0ZSB0aGUgcXVlcnkgaGFzIGJlZW4gdXBkYXRlZFxuICAgKi9cbiAgcXVlcnlIYXNDaGFuZ2VkKCk6IHZvaWQge1xuICAgIHRoaXMucXVlcnlDaGFuZ2UubmV4dCh0aGlzLnF1ZXJ5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9yZSB0aGUgdmFsaWRhdGlvbiBzdGF0ZSBvZiB0aGUgcXVlcnlcbiAgICovXG4gIHNldFZhbGlkKGlkOiBudW1iZXIsIHZhbGlkOiBib29sZWFuKTogdm9pZCB7XG5cbiAgICAvLyBzdG9yZSB0aGUgc3RhdGUgZm9yIHRoaXMgc3BlY2lmaWMgY29tcG9uZW50XG4gICAgdGhpcy5fdmFsaWRhdGlvbltpZF0gPSB2YWxpZDtcblxuICAgIC8vIGV2YWx1YXRlIHRoZSBlbnRpcmUgdmFsaWRhdGlvbiBzdGF0ZVxuICAgIHRoaXMudmFsaWRhdGlvbkNoYW5nZS5uZXh0KCFPYmplY3Qua2V5cyh0aGlzLl92YWxpZGF0aW9uKS5zb21lKGtleSA9PiAhdGhpcy5fdmFsaWRhdGlvbltrZXldKSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB1bmlxdWUgaWQgZm9yIGVhY2ggY29tcG9uZW50XG4gICAqL1xuICBnZW5lcmF0ZUNvbXBvbmVudElkKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbXBvbmVudElkKys7XG4gIH1cbn1cbiIsImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFNlYXJjaEJ1aWxkZXJHcm91cFF1ZXJ5IH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9ncm91cC1xdWVyeS5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgU2VhcmNoQnVpbGRlclNlcnZpY2UgfSBmcm9tICcuLi9zZWFyY2gtYnVpbGRlci5zZXJ2aWNlJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFNlYXJjaEJ1aWxkZXJHcm91cFNlcnZpY2Uge1xuXG4gIHByaXZhdGUgX2lkOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfc2VhcmNoQnVpbGRlclNlcnZpY2U6IFNlYXJjaEJ1aWxkZXJTZXJ2aWNlKSB7IH1cblxuICAvKipcbiAgICogSW5pdGlhbGlzZSB0aGUgZ3JvdXAgYnkgZGVmaW5pbmcgYW4gaWRcbiAgICovXG4gIGluaXQoaWQ6IHN0cmluZyk6IHZvaWQge1xuICAgIC8vIHN0b3JlIHRoZSBuYW1lIG9mIHRoZSBncm91cFxuICAgIHRoaXMuX2lkID0gaWQ7XG5cbiAgICAvLyBjcmVhdGUgdGhlIGVudHJ5IGluIHRoZSBxdWVyeSBvYmplY3QgaWYgaXQgZG9lc24ndCBleGlzdFxuICAgIGlmICghdGhpcy5fc2VhcmNoQnVpbGRlclNlcnZpY2UucXVlcnlbdGhpcy5faWRdKSB7XG5cbiAgICAgIC8vIGNyZWF0ZSB0aGUgc2VjdGlvblxuICAgICAgdGhpcy5fc2VhcmNoQnVpbGRlclNlcnZpY2UucXVlcnlbdGhpcy5faWRdID0gW107XG5cbiAgICAgIC8vIGVtaXQgdGhlIGNoYW5nZXMgYWZ0ZXIgdGhlIGluaXRpYWwgc2V0dXBcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5fc2VhcmNoQnVpbGRlclNlcnZpY2UucXVlcnlIYXNDaGFuZ2VkKCkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBmaWVsZCBmcm9tIHRoZSBzZWFyY2ggYnVpbGRlciBxdWVyeVxuICAgKi9cbiAgcmVtb3ZlKGZpZWxkOiBTZWFyY2hCdWlsZGVyR3JvdXBRdWVyeSk6IHZvaWQge1xuICAgIC8vIGdldCB0aGUgcXVlcnkgZm9yIHRoaXMgZ3JvdXBcbiAgICBjb25zdCBxdWVyeSA9IHRoaXMuZ2V0UXVlcnkoKTtcblxuICAgIC8vIHJlbW92ZSB0aGUgZmllbGQgZnJvbSB0aGUgYXJyYXlcbiAgICBxdWVyeS5zcGxpY2UocXVlcnkuaW5kZXhPZihmaWVsZCksIDEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcXVlcnkgZm9yIHRoaXMgc3BlY2lmaWMgc2VhcmNoIGdyb3VwXG4gICAqL1xuICBnZXRRdWVyeSgpOiBTZWFyY2hCdWlsZGVyR3JvdXBRdWVyeVtdIHtcbiAgICByZXR1cm4gdGhpcy5fc2VhcmNoQnVpbGRlclNlcnZpY2UucXVlcnlbdGhpcy5faWRdID8gdGhpcy5fc2VhcmNoQnVpbGRlclNlcnZpY2UucXVlcnlbdGhpcy5faWRdIDogW107XG4gIH1cbn1cbiIsImltcG9ydCB7IENvbXBvbmVudCwgT25Jbml0LCBJbnB1dCwgT3V0cHV0LCBFdmVudEVtaXR0ZXIsIFRlbXBsYXRlUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTZWFyY2hCdWlsZGVyR3JvdXBTZXJ2aWNlIH0gZnJvbSAnLi9zZWFyY2gtYnVpbGRlci1ncm91cC5zZXJ2aWNlJztcbmltcG9ydCB7IFNlYXJjaEJ1aWxkZXJTZXJ2aWNlIH0gZnJvbSAnLi4vc2VhcmNoLWJ1aWxkZXIuc2VydmljZSc7XG5pbXBvcnQgeyBTZWFyY2hCdWlsZGVyR3JvdXBRdWVyeSB9IGZyb20gJy4uL2ludGVyZmFjZXMvZ3JvdXAtcXVlcnkuaW50ZXJmYWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAndXgtc2VhcmNoLWJ1aWxkZXItZ3JvdXAnLFxuICB0ZW1wbGF0ZTogYDxoNCBjbGFzcz1cInNlYXJjaC1ncm91cC10aXRsZVwiPnt7IGhlYWRlciB9fTwvaDQ+XG5cbjxtYWluIGNsYXNzPVwic2VhcmNoLWdyb3VwLWNvbnRlbnRcIj5cblxuICA8c2VjdGlvbiBjbGFzcz1cInNlYXJjaC1ncm91cC1vcGVyYXRvciBzZWFyY2gtZ3JvdXAtb3BlcmF0b3Ite3sgb3BlcmF0b3IgfX1cIiBbY2xhc3MuaGlkZGVuLW9wZXJhdG9yXT1cInNlYXJjaEJ1aWxkZXJHcm91cFNlcnZpY2UuZ2V0UXVlcnkoKS5sZW5ndGggPCAyXCI+e3sgb3BlcmF0b3IgfX08L3NlY3Rpb24+XG5cbiAgPHNlY3Rpb24gY2xhc3M9XCJzZWFyY2gtZ3JvdXAtaXRlbXNcIj5cblxuICAgIDxkaXYgY2xhc3M9XCJzZWFyY2gtZ3JvdXAtaXRlbS1jb250YWluZXJcIiAqbmdGb3I9XCJsZXQgZmllbGQgb2Ygc2VhcmNoQnVpbGRlckdyb3VwU2VydmljZS5nZXRRdWVyeSgpXCI+XG5cbiAgICAgIDxkaXYgY2xhc3M9XCJzZWFyY2gtZ3JvdXAtaXRlbVwiPlxuICAgICAgICA8bmctY29udGFpbmVyICp1eFNlYXJjaEJ1aWxkZXJPdXRsZXQ9XCJmaWVsZC50eXBlOyBjb250ZXh0OiBmaWVsZFwiPjwvbmctY29udGFpbmVyPlxuICAgICAgPC9kaXY+XG5cbiAgICAgIDxkaXYgY2xhc3M9XCJzZWFyY2gtZ3JvdXAtaXRlbS1yZW1vdmVcIiAoY2xpY2spPVwicmVtb3ZlRmllbGQoZmllbGQpXCI+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwiaHBlLWljb24gaHBlLWNsb3NlXCI+PC9zcGFuPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG5cbiAgICA8IS0tIFBsYWNlaG9sZGVyIEl0ZW0gLS0+XG4gICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cInNob3dQbGFjZWhvbGRlclwiPlxuXG4gICAgICA8IS0tIFRoZSBEZWZhdWx0IFBsYWNlaG9sZGVyIC0tPlxuICAgICAgPGRpdiBjbGFzcz1cInNlYXJjaC1ncm91cC1pdGVtLWNvbnRhaW5lciBwbGFjZWhvbGRlci1pdGVtXCIgKm5nSWY9XCIhcGxhY2Vob2xkZXJcIj5cbiAgICAgICAgXG4gICAgICAgIDxkaXYgY2xhc3M9XCJzZWFyY2gtZ3JvdXAtaXRlbVwiPlxuICAgICAgICAgIDxsYWJlbCBjbGFzcz1cImZvcm0tbGFiZWxcIj5OZXcgZmllbGQ8L2xhYmVsPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIj48L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gIFxuICAgICAgPC9kaXY+XG5cbiAgICAgIDwhLS0gQWxsb3cgYSBjdXN0b20gcGxhY2Vob2xkZXIgLS0+XG4gICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cInBsYWNlaG9sZGVyXCI+PC9uZy1jb250YWluZXI+XG5cbiAgICA8L25nLWNvbnRhaW5lcj5cblxuICA8L3NlY3Rpb24+XG5cbiAgPHNlY3Rpb24gY2xhc3M9XCJzZWFyY2gtYnVpbGRlci1ncm91cC1hZGQtZmllbGRcIiAoY2xpY2spPVwiYWRkLmVtaXQoJGV2ZW50KVwiPlxuXG4gICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLWljb24gYnRuLWNpcmN1bGFyIGJ1dHRvbi1hY2NlbnRcIiBhcmlhLWxhYmVsPVwiQWRkIEZpZWxkXCI+XG4gICAgICA8c3BhbiBjbGFzcz1cImhwZS1pY29uIGhwZS1hZGRcIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L3NwYW4+XG4gICAgPC9idXR0b24+XG5cbiAgICA8c3BhbiBjbGFzcz1cInNlYXJjaC1idWlsZGVyLWdyb3VwLWFkZC1maWVsZC1sYWJlbFwiPnt7IGFkZFRleHQgfX08L3NwYW4+XG5cbiAgPC9zZWN0aW9uPlxuXG48L21haW4+XG5cbjxociBjbGFzcz1cInNlYXJjaC1idWlsZGVyLWdyb3VwLWRpdmlkZXJcIj5cbmAsXG4gIHByb3ZpZGVyczogW1NlYXJjaEJ1aWxkZXJHcm91cFNlcnZpY2VdXG59KVxuZXhwb3J0IGNsYXNzIFNlYXJjaEJ1aWxkZXJHcm91cENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG5cbiAgQElucHV0KCkgaWQ6IHN0cmluZztcbiAgQElucHV0KCkgaGVhZGVyOiBzdHJpbmc7XG4gIEBJbnB1dCgpIG9wZXJhdG9yOiBTZWFyY2hCdWlsZGVyR3JvdXBPcGVyYXRvciA9ICdhbmQnO1xuICBASW5wdXQoKSBhZGRUZXh0OiBzdHJpbmcgPSAnQWRkIGEgZmllbGQnO1xuICBASW5wdXQoKSBwbGFjZWhvbGRlcjogVGVtcGxhdGVSZWY8YW55PjtcbiAgQElucHV0KCkgc2hvd1BsYWNlaG9sZGVyOiBib29sZWFuID0gZmFsc2U7XG5cbiAgQE91dHB1dCgpIGFkZDogRXZlbnRFbWl0dGVyPE1vdXNlRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxNb3VzZUV2ZW50PigpO1xuICBAT3V0cHV0KCkgcmVtb3ZlOiBFdmVudEVtaXR0ZXI8U2VhcmNoQnVpbGRlckdyb3VwUXVlcnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxTZWFyY2hCdWlsZGVyR3JvdXBRdWVyeT4oKTtcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgc2VhcmNoQnVpbGRlckdyb3VwU2VydmljZTogU2VhcmNoQnVpbGRlckdyb3VwU2VydmljZSwgcHJpdmF0ZSBfc2VhcmNoQnVpbGRlclNlcnZpY2U6IFNlYXJjaEJ1aWxkZXJTZXJ2aWNlKSB7IH1cblxuICBuZ09uSW5pdCgpOiB2b2lkIHtcblxuICAgIC8vIGVuc3VyZSB3ZSBoYXZlIGEgbmFtZSBvdGhlcndpc2UgdGhyb3cgYW4gZXJyb3JcbiAgICBpZiAoIXRoaXMuaWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2VhcmNoIGJ1aWxkZXIgZ3JvdXAgbXVzdCBoYXZlIGEgbmFtZSBhdHRyaWJ1dGUuJyk7XG4gICAgfVxuXG4gICAgLy8gb3RoZXJ3aXNlIHJlZ2lzdGVyIHRoZSBncm91cFxuICAgIHRoaXMuc2VhcmNoQnVpbGRlckdyb3VwU2VydmljZS5pbml0KHRoaXMuaWQpO1xuICB9XG5cbiAgcmVtb3ZlRmllbGQoZmllbGQ6IFNlYXJjaEJ1aWxkZXJHcm91cFF1ZXJ5KTogdm9pZCB7XG4gICAgdGhpcy5zZWFyY2hCdWlsZGVyR3JvdXBTZXJ2aWNlLnJlbW92ZShmaWVsZCk7XG4gICAgdGhpcy5yZW1vdmUuZW1pdChmaWVsZCk7XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgU2VhcmNoQnVpbGRlckdyb3VwT3BlcmF0b3IgPSAnYW5kJyB8ICdvcicgfCAnbm90JztcbiIsImltcG9ydCB7IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlciwgQ29tcG9uZW50UmVmLCBEaXJlY3RpdmUsIElucHV0LCBPbkluaXQsIFZpZXdDb250YWluZXJSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFNlYXJjaEJ1aWxkZXJTZXJ2aWNlIH0gZnJvbSAnLi4vc2VhcmNoLWJ1aWxkZXIuc2VydmljZSc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3V4U2VhcmNoQnVpbGRlck91dGxldF0nXG59KVxuZXhwb3J0IGNsYXNzIFNlYXJjaEJ1aWxkZXJPdXRsZXREaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQge1xuXG4gICAgQElucHV0KCkgdXhTZWFyY2hCdWlsZGVyT3V0bGV0OiBzdHJpbmc7XG4gICAgQElucHV0KCkgdXhTZWFyY2hCdWlsZGVyT3V0bGV0Q29udGV4dDogYW55O1xuXG4gICAgcHJpdmF0ZSBfY29tcG9uZW50UmVmOiBDb21wb25lbnRSZWY8YW55PjtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIF92aWV3Q29udGFpbmVyUmVmOiBWaWV3Q29udGFpbmVyUmVmLFxuICAgICAgICBwcml2YXRlIF9jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXI6IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcixcbiAgICAgICAgcHJpdmF0ZSBfc2VhcmNoQnVpbGRlclNlcnZpY2U6IFNlYXJjaEJ1aWxkZXJTZXJ2aWNlXG4gICAgKSB7IH1cblxuICAgIG5nT25Jbml0KCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGdldCB0aGUgY2xhc3MgZnJvbSB0aGUgdHlwZVxuICAgICAgICBjb25zdCBjb21wb25lbnREZWZpbml0aW9uID0gdGhpcy5fc2VhcmNoQnVpbGRlclNlcnZpY2UuZ2V0Q29tcG9uZW50KHRoaXMudXhTZWFyY2hCdWlsZGVyT3V0bGV0KTtcblxuICAgICAgICAvLyBjcmVhdGUgdGhlIGNvbXBvbmVudCBmYWN0b3J5XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudEZhY3RvcnkgPSB0aGlzLl9jb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIucmVzb2x2ZUNvbXBvbmVudEZhY3RvcnkoY29tcG9uZW50RGVmaW5pdGlvbi5jb21wb25lbnQpO1xuXG4gICAgICAgIC8vIGNyZWF0ZSB0aGUgY29tcG9uZW50IGluc3RhbmNlXG4gICAgICAgIHRoaXMuX2NvbXBvbmVudFJlZiA9IHRoaXMuX3ZpZXdDb250YWluZXJSZWYuY3JlYXRlQ29tcG9uZW50KGNvbXBvbmVudEZhY3RvcnkpO1xuXG4gICAgICAgIC8vIGNvbWJpbmUgdGhlIHByZWRlZmluZWQgY29uZmlnIHdpdGggYW55IGR5bm1haWMgY29uZmlnXG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IE9iamVjdC5hc3NpZ24oe30sIGNvbXBvbmVudERlZmluaXRpb24uY29uZmlnLCB0aGlzLnV4U2VhcmNoQnVpbGRlck91dGxldENvbnRleHQuY29uZmlnIHx8IHt9KTtcblxuICAgICAgICAvLyBzZXQgdGhlIGNvbnRleHQgYW5kIGNvbmZpZyBwcm9wZXJ0eSBvbiB0aGUgY29tcG9uZW50IGluc3RhbmNlXG4gICAgICAgIHRoaXMuX2NvbXBvbmVudFJlZi5pbnN0YW5jZS5jb250ZXh0ID0gdGhpcy51eFNlYXJjaEJ1aWxkZXJPdXRsZXRDb250ZXh0O1xuICAgICAgICB0aGlzLl9jb21wb25lbnRSZWYuaW5zdGFuY2UuY29uZmlnID0gY29uZmlnO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IENvbXBvbmVudCwgT25EZXN0cm95IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTZWFyY2hCdWlsZGVyQ29tcG9uZW50Q29udGV4dCB9IGZyb20gJy4uL2ludGVyZmFjZXMvY29tcG9uZW50LWNvbnRleHQuaW50ZXJmYWNlJztcbmltcG9ydCB7IFNlYXJjaEJ1aWxkZXJHcm91cFNlcnZpY2UgfSBmcm9tICcuLi9zZWFyY2gtYnVpbGRlci1ncm91cC9zZWFyY2gtYnVpbGRlci1ncm91cC5zZXJ2aWNlJztcbmltcG9ydCB7IFNlYXJjaEJ1aWxkZXJTZXJ2aWNlIH0gZnJvbSAnLi4vc2VhcmNoLWJ1aWxkZXIuc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtYmFzZS1zZWFyY2gnLFxuICAgIHRlbXBsYXRlOiAnJ1xufSlcbmV4cG9ydCBjbGFzcyBCYXNlU2VhcmNoQ29tcG9uZW50IGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICAgIHR5cGU6IHN0cmluZztcbiAgICBjb25maWc6IGFueTtcbiAgICBjb250ZXh0OiBTZWFyY2hCdWlsZGVyQ29tcG9uZW50Q29udGV4dDtcblxuICAgIHByaXZhdGUgX2lkOiBudW1iZXIgPSB0aGlzLl9zZWFyY2hCdWlsZGVyU2VydmljZS5nZW5lcmF0ZUNvbXBvbmVudElkKCk7XG4gICAgcHJpdmF0ZSBfdmFsaWQ6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBjb21wb25lbnRcbiAgICAgKi9cbiAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQudmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBjb21wb25lbnRcbiAgICAgKi9cbiAgICBzZXQgdmFsdWUodmFsdWU6IGFueSkge1xuICAgICAgICB0aGlzLmNvbnRleHQudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5fc2VhcmNoQnVpbGRlclNlcnZpY2UucXVlcnlIYXNDaGFuZ2VkKCk7XG5cbiAgICAgICAgLy8gaWYgdmFsdWUgaGFzIGJlZW4gc2V0IHBlcmZvcm0gdmFsaWRhdGlvblxuICAgICAgICB0aGlzLnZhbGlkYXRlKCk7XG4gICAgfVxuXG4gICAgZ2V0IHZhbGlkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsaWQ7XG4gICAgfVxuXG4gICAgc2V0IHZhbGlkKHZhbGlkOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuX3ZhbGlkID0gdmFsaWQ7XG4gICAgICAgIHRoaXMuX3NlYXJjaEJ1aWxkZXJTZXJ2aWNlLnNldFZhbGlkKHRoaXMuX2lkLCB2YWxpZCk7XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgX3NlYXJjaEJ1aWxkZXJTZXJ2aWNlOiBTZWFyY2hCdWlsZGVyU2VydmljZSxcbiAgICAgICAgcHJpdmF0ZSBfc2VhcmNoQnVpbGRlckdyb3VwU2VydmljZTogU2VhcmNoQnVpbGRlckdyb3VwU2VydmljZVxuICAgICkgeyB9XG5cbiAgICAvKipcbiAgICAgKiBNYWtlIHN1cmUgd2UgY2xlYW4gdXAgYWZ0ZXIgb3Vyc2VsdmVzXG4gICAgICovXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMudmFsaWQgPSB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gYW55IHJlcXVpcmVkIHZhbGlkYXRpb24gb24gdGhlIHZhbHVlXG4gICAgICovXG4gICAgdmFsaWRhdGUoKTogdm9pZCB7XG4gICAgICAgIC8vIGlmIGEgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb24gaGFzIGJlZW4gcHJvdmlkZWQgdGhlbiB1c2UgaXRcbiAgICAgICAgdGhpcy52YWxpZCA9IHRoaXMuY29uZmlnLnZhbGlkYXRpb24gPyB0aGlzLmNvbmZpZy52YWxpZGF0aW9uKHRoaXMsIHRoaXMudmFsdWUpIDogdHJ1ZTtcbiAgICB9XG5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBCYXNlU2VhcmNoQ29tcG9uZW50Q29uZmlnIHtcbiAgICBsYWJlbD86IHN0cmluZztcbiAgICBwbGFjZWhvbGRlcj86IHN0cmluZztcbiAgICB2YWxpZGF0aW9uPzogKHZhbHVlOiBhbnkpID0+IGJvb2xlYW47XG59IiwiaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBCYXNlU2VhcmNoQ29tcG9uZW50LCBCYXNlU2VhcmNoQ29tcG9uZW50Q29uZmlnIH0gZnJvbSAnLi4vYmFzZS1zZWFyY2guY29tcG9uZW50JztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAndXgtc2VhcmNoLXRleHQnLFxuICB0ZW1wbGF0ZTogYDxsYWJlbCBjbGFzcz1cImZvcm0tbGFiZWxcIiAqbmdJZj1cImxhYmVsXCI+e3sgbGFiZWwgfX08L2xhYmVsPlxuPGlucHV0IFtwbGFjZWhvbGRlcl09XCJwbGFjZWhvbGRlclwiIFsobmdNb2RlbCldPVwidmFsdWVcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiPmBcbn0pXG5leHBvcnQgY2xhc3MgU2VhcmNoVGV4dENvbXBvbmVudCBleHRlbmRzIEJhc2VTZWFyY2hDb21wb25lbnQge1xuXG4gIHR5cGU6IHN0cmluZyA9ICd0ZXh0JztcblxuICBnZXQgbGFiZWwoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcubGFiZWw7XG4gIH1cblxuICBnZXQgcGxhY2Vob2xkZXIoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcucGxhY2Vob2xkZXIgfHwgJ0VudGVyIHRleHQnO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VhcmNoVGV4dENvbmZpZyBleHRlbmRzIEJhc2VTZWFyY2hDb21wb25lbnRDb25maWcgeyB9IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBPbkluaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJhc2VTZWFyY2hDb21wb25lbnQsIEJhc2VTZWFyY2hDb21wb25lbnRDb25maWcgfSBmcm9tICcuLi9iYXNlLXNlYXJjaC5jb21wb25lbnQnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICd1eC1zZWFyY2gtZGF0ZScsXG4gIHRlbXBsYXRlOiBgPGxhYmVsIGNsYXNzPVwiZm9ybS1sYWJlbFwiICpuZ0lmPVwibGFiZWxcIj57eyBsYWJlbCB9fTwvbGFiZWw+XG5cbjxkaXYgY2xhc3M9XCJpbnB1dC1ncm91cCBkYXRlIG0tbmlsXCI+XG4gICAgPHNwYW4gY2xhc3M9XCJpbnB1dC1ncm91cC1hZGRvblwiIHRhYmluZGV4PVwiMVwiIChjbGljayk9XCJwb3BvdmVyLnNob3coKVwiPlxuICAgICAgICA8aSBjbGFzcz1cImhwZS1pY29uIGhwZS1jYWxlbmRhclwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvaT5cbiAgICA8L3NwYW4+XG4gICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgI3BvcG92ZXI9XCJ1eC1wb3BvdmVyXCIgW25nTW9kZWxdPVwidmFsdWUgfCBkYXRlOidkZCBNTU1NIHl5eXknXCIgW3V4UG9wb3Zlcl09XCJwb3BvdmVyVGVtcGxhdGVcIlxuICAgICAgICBwbGFjZW1lbnQ9XCJib3R0b21cIiBwb3BvdmVyQ2xhc3M9XCJkYXRlLXRpbWUtcGlja2VyLXBvcG92ZXJcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiIGFyaWEtbGFiZWw9XCJTZWxlY3RlZCBkYXRlXCIgW3BsYWNlaG9sZGVyXT1cInBsYWNlaG9sZGVyXCI+XG48L2Rpdj5cblxuPG5nLXRlbXBsYXRlICNwb3BvdmVyVGVtcGxhdGU+XG4gICAgPHV4LWRhdGUtdGltZS1waWNrZXIgWyhkYXRlKV09XCJ2YWx1ZVwiIFtzaG93VGltZV09XCJmYWxzZVwiPjwvdXgtZGF0ZS10aW1lLXBpY2tlcj5cbjwvbmctdGVtcGxhdGU+YFxufSlcbmV4cG9ydCBjbGFzcyBTZWFyY2hEYXRlQ29tcG9uZW50IGV4dGVuZHMgQmFzZVNlYXJjaENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG5cbiAgdHlwZTogc3RyaW5nID0gJ2RhdGUnO1xuXG4gIGdldCBsYWJlbCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy5sYWJlbDtcbiAgfVxuXG4gIGdldCBwbGFjZWhvbGRlcigpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy5wbGFjZWhvbGRlciB8fCAnRW50ZXIgZGF0ZSc7XG4gIH1cblxuICBuZ09uSW5pdCgpOiB2b2lkIHtcblxuICAgIC8vIGJ5IGRlZmF1bHQgc2V0IHRvIHRoZSBjdXJyZW50IGRhdGUgaWYgbm90IHNwZWNpZmllZFxuICAgIGlmICghdGhpcy52YWx1ZSkge1xuICAgICAgdGhpcy52YWx1ZSA9IG5ldyBEYXRlKCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VhcmNoRGF0ZUNvbmZpZyBleHRlbmRzIEJhc2VTZWFyY2hDb21wb25lbnRDb25maWcgeyB9IiwiaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBCYXNlU2VhcmNoQ29tcG9uZW50IH0gZnJvbSAnLi4vYmFzZS1zZWFyY2guY29tcG9uZW50JztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1zZWFyY2gtZGF0ZS1yYW5nZScsXG4gICAgdGVtcGxhdGU6IGA8bGFiZWwgY2xhc3M9XCJmb3JtLWxhYmVsXCIgKm5nSWY9XCJsYWJlbFwiPnt7IGxhYmVsIH19PC9sYWJlbD5cblxuPGRpdiBjbGFzcz1cInJvd1wiPlxuICAgIDxkaXYgY2xhc3M9XCJjb2wtc20tMTJcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0taW5saW5lXCIgW2NsYXNzLmhhcy1lcnJvcl09XCIhdmFsaWRcIj5cblxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXAgcC1yLW1kXCI+XG4gICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPVwiZm9ybS1sYWJlbCBtLXIteHNcIj57eyBmcm9tTGFiZWwgfX08L2xhYmVsPlxuXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImlucHV0LWdyb3VwIGRhdGUgbS1uaWxcIj5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpbnB1dC1ncm91cC1hZGRvbiBwLXIteHNcIiB0YWJpbmRleD1cIjFcIiAoY2xpY2spPVwiZnJvbVBvcG92ZXIuc2hvdygpXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cImhwZS1pY29uIGhwZS1jYWxlbmRhclwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvaT5cbiAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiAjZnJvbVBvcG92ZXI9XCJ1eC1wb3BvdmVyXCIgW25nTW9kZWxdPVwiZnJvbSB8IGRhdGU6J2RkIE1NTU0geXl5eSdcIiBbdXhQb3BvdmVyXT1cImZyb21Qb3BvdmVyVGVtcGxhdGVcIiBwbGFjZW1lbnQ9XCJib3R0b21cIlxuICAgICAgICAgICAgICAgICAgICAgICAgcG9wb3ZlckNsYXNzPVwiZGF0ZS10aW1lLXBpY2tlci1wb3BvdmVyXCIgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiBhcmlhLWxhYmVsPVwiU2VsZWN0ZWQgZGF0ZVwiIFtwbGFjZWhvbGRlcl09XCJmcm9tUGxhY2Vob2xkZXJcIj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cCBwLXIteHNcIj5cbiAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9XCJmb3JtLWxhYmVsIG0tci14c1wiPnt7IHRvTGFiZWwgfX08L2xhYmVsPlxuXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImlucHV0LWdyb3VwIGRhdGUgbS1uaWxcIj5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpbnB1dC1ncm91cC1hZGRvblwiIHRhYmluZGV4PVwiMVwiIChjbGljayk9XCJ0b1BvcG92ZXIuc2hvdygpXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8aSBjbGFzcz1cImhwZS1pY29uIGhwZS1jYWxlbmRhclwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvaT5cbiAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiAjdG9Qb3BvdmVyPVwidXgtcG9wb3ZlclwiIFtuZ01vZGVsXT1cInRvIHwgZGF0ZTonZGQgTU1NTSB5eXl5J1wiIFt1eFBvcG92ZXJdPVwidG9Qb3BvdmVyVGVtcGxhdGVcIiBwbGFjZW1lbnQ9XCJib3R0b21cIlxuICAgICAgICAgICAgICAgICAgICAgICAgcG9wb3ZlckNsYXNzPVwiZGF0ZS10aW1lLXBpY2tlci1wb3BvdmVyXCIgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiBhcmlhLWxhYmVsPVwiU2VsZWN0ZWQgZGF0ZVwiIFtwbGFjZWhvbGRlcl09XCJ0b1BsYWNlaG9sZGVyXCI+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbjwvZGl2PlxuXG48bmctdGVtcGxhdGUgI2Zyb21Qb3BvdmVyVGVtcGxhdGU+XG4gICAgPHV4LWRhdGUtdGltZS1waWNrZXIgWyhkYXRlKV09XCJmcm9tXCIgW3Nob3dUaW1lXT1cImZhbHNlXCI+PC91eC1kYXRlLXRpbWUtcGlja2VyPlxuPC9uZy10ZW1wbGF0ZT5cblxuPG5nLXRlbXBsYXRlICN0b1BvcG92ZXJUZW1wbGF0ZT5cbiAgICA8dXgtZGF0ZS10aW1lLXBpY2tlciBbKGRhdGUpXT1cInRvXCIgW3Nob3dUaW1lXT1cImZhbHNlXCI+PC91eC1kYXRlLXRpbWUtcGlja2VyPlxuPC9uZy10ZW1wbGF0ZT5gXG59KVxuZXhwb3J0IGNsYXNzIFNlYXJjaERhdGVSYW5nZUNvbXBvbmVudCBleHRlbmRzIEJhc2VTZWFyY2hDb21wb25lbnQge1xuXG4gICAgdHlwZTogc3RyaW5nID0gJ2RhdGUtcmFuZ2UnO1xuXG4gICAgZ2V0IGxhYmVsKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5sYWJlbDtcbiAgICB9XG5cbiAgICBnZXQgZnJvbSgpIHtcblxuICAgICAgICAvLyBpZiB2YWx1ZSBkb2VzIG5vdCBleGlzdCB0aGUgc2V0IGl0XG4gICAgICAgIGlmICghdGhpcy52YWx1ZSB8fCAhdGhpcy52YWx1ZS5mcm9tKSB7XG4gICAgICAgICAgICB0aGlzLmZyb20gPSBuZXcgRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZW5zdXJlIHRoYXQgdGhlIGZyb20gdmFsdWUgaXMgYSBkYXRlIG9iamVjdFxuICAgICAgICBpZiAodGhpcy52YWx1ZS5mcm9tIGluc3RhbmNlb2YgRGF0ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUuZnJvbSA9IG5ldyBEYXRlKHRoaXMudmFsdWUuZnJvbSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZS5mcm9tO1xuICAgIH1cblxuICAgIHNldCBmcm9tKGZyb21WYWx1ZTogYW55KSB7XG5cbiAgICAgICAgLy8gY3JlYXRlIG5ldyBvYmplY3QgYmFzZWQgb24gdGhlIGN1cnJlbnQgdmFsdWVcbiAgICAgICAgY29uc3QgdmFsdWUgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnZhbHVlKTtcblxuICAgICAgICAvLyBlbnN1cmUgdGhhdCB0aGUgZnJvbSB2YWx1ZSBpcyBhIGRhdGVcbiAgICAgICAgaWYgKGZyb21WYWx1ZSBpbnN0YW5jZW9mIERhdGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBmcm9tVmFsdWUgPSBuZXcgRGF0ZShmcm9tVmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0IHRoZSBsYXRlc3QgdmFsdWVcbiAgICAgICAgdmFsdWUuZnJvbSA9IGZyb21WYWx1ZTtcblxuICAgICAgICAvLyB1cGRhdGUgdGhlIHZhbHVlIG9iamVjdCB3aGlsZSBlbnN1cmluZyBpbW11dGFiaWxpdHlcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIGdldCB0bygpIHtcblxuICAgICAgICAvLyBpZiB2YWx1ZSBkb2VzIG5vdCBleGlzdCB0aGUgc2V0IGl0XG4gICAgICAgIGlmICghdGhpcy52YWx1ZSB8fCAhdGhpcy52YWx1ZS50bykge1xuICAgICAgICAgICAgdGhpcy50byA9IG5ldyBEYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBlbnN1cmUgdGhhdCB0aGUgdG8gdmFsdWUgaXMgYSBkYXRlIG9iamVjdFxuICAgICAgICBpZiAodGhpcy52YWx1ZS50byBpbnN0YW5jZW9mIERhdGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlLnRvID0gbmV3IERhdGUodGhpcy52YWx1ZS50byk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZS50bztcbiAgICB9XG5cbiAgICBzZXQgdG8odG9WYWx1ZTogYW55KSB7XG5cbiAgICAgICAgLy8gY3JlYXRlIG5ldyBvYmplY3QgYmFzZWQgb24gdGhlIGN1cnJlbnQgdmFsdWVcbiAgICAgICAgY29uc3QgdmFsdWUgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnZhbHVlKTtcblxuICAgICAgICAvLyBlbnN1cmUgdGhhdCB0aGUgdG8gdmFsdWUgaXMgYSBkYXRlXG4gICAgICAgIGlmICh0b1ZhbHVlIGluc3RhbmNlb2YgRGF0ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRvVmFsdWUgPSBuZXcgRGF0ZSh0b1ZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldCB0aGUgbGF0ZXN0IHZhbHVlXG4gICAgICAgIHZhbHVlLnRvID0gdG9WYWx1ZTtcblxuICAgICAgICAvLyB1cGRhdGUgdGhlIHZhbHVlIG9iamVjdCB3aGlsZSBlbnN1cmluZyBpbW11dGFiaWxpdHlcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIGdldCBmcm9tTGFiZWwoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLmZyb21MYWJlbCB8fCAnRnJvbSc7XG4gICAgfVxuXG4gICAgZ2V0IHRvTGFiZWwoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLnRvTGFiZWwgfHwgJ1RvJztcbiAgICB9XG5cbiAgICBnZXQgZnJvbVBsYWNlaG9sZGVyKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5mcm9tUGxhY2Vob2xkZXI7XG4gICAgfVxuXG4gICAgZ2V0IHRvUGxhY2Vob2xkZXIoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlnLnRvUGxhY2Vob2xkZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgdGhlIGRlZmF1bHQgdmFsaWRhdGlvblxuICAgICAqL1xuICAgIHZhbGlkYXRlKCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGlzIGEgY29uZmlnIHZhbGlkYXRpb24gZnVuY3Rpb25cbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLnZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBzdXBlci52YWxpZGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlIGNvcGllcyBvZiB0aGUgZGF0ZXMgc28gd2UgY2FuIG1vZGlmeSB0aW1lIHZhbHVlICh0byBpZ25vcmUgaXQpXG4gICAgICAgIGNvbnN0IGZyb20gPSBuZXcgRGF0ZSh0aGlzLnZhbHVlLmZyb20pO1xuICAgICAgICBjb25zdCB0byA9IG5ldyBEYXRlKHRoaXMudmFsdWUudG8pO1xuXG4gICAgICAgIC8vIHNldCB0aGUgdGltZSB0byB0aGUgc2FtZSBzbyB3ZSBkb250IGNvbXBhcmUgaXRcbiAgICAgICAgZnJvbS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgICAgICAgdG8uc2V0SG91cnMoMCwgMCwgMCwgMCk7XG5cbiAgICAgICAgLy8gdmFsaWQgaWYgdGhlIGZyb20gZGF0ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHRvIGRhdGVcbiAgICAgICAgdGhpcy52YWxpZCA9IGZyb20gPD0gdG87XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNlYXJjaERhdGVSYW5nZUNvbmZpZyB7XG4gICAgbGFiZWw/OiBzdHJpbmc7XG4gICAgZnJvbUxhYmVsPzogc3RyaW5nO1xuICAgIHRvTGFiZWw/OiBzdHJpbmc7XG4gICAgZnJvbVBsYWNlaG9sZGVyPzogc3RyaW5nO1xuICAgIHRvUGxhY2Vob2xkZXI/OiBzdHJpbmc7XG4gICAgdmFsaWRhdGlvbjogKHZhbHVlOiBhbnkpID0+IGJvb2xlYW47XG59IiwiaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBCYXNlU2VhcmNoQ29tcG9uZW50LCBCYXNlU2VhcmNoQ29tcG9uZW50Q29uZmlnIH0gZnJvbSAnLi4vYmFzZS1zZWFyY2guY29tcG9uZW50JztcbmltcG9ydCB7IEluZmluaXRlU2Nyb2xsTG9hZEZ1bmN0aW9uIH0gZnJvbSAnLi4vLi4vLi4vLi4vaW5kZXgnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICd1eC1zZWFyY2gtc2VsZWN0JyxcbiAgdGVtcGxhdGU6IGA8bGFiZWwgY2xhc3M9XCJmb3JtLWxhYmVsXCIgKm5nSWY9XCJsYWJlbFwiPnt7IGxhYmVsIH19PC9sYWJlbD5cblxuPHV4LXNlbGVjdCBbKHZhbHVlKV09XCJ2YWx1ZVwiIFxuICAgICAgICAgICBbb3B0aW9uc109XCJvcHRpb25zXCIgXG4gICAgICAgICAgIFttdWx0aXBsZV09XCJtdWx0aXBsZVwiIFxuICAgICAgICAgICBbcGxhY2Vob2xkZXJdPVwicGxhY2Vob2xkZXJcIiBcbiAgICAgICAgICAgW2Ryb3BEaXJlY3Rpb25dPVwiZHJvcERpcmVjdGlvblwiXG4gICAgICAgICAgIFtwYWdlU2l6ZV09XCJwYWdlU2l6ZVwiXG4gICAgICAgICAgIFthbGxvd051bGxdPVwiYWxsb3dOdWxsXCJcbiAgICAgICAgICAgW2Rpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICAgICAgW21heEhlaWdodF09XCJtYXhIZWlnaHRcIlxuICAgICAgICAgICBba2V5XT1cImNvbmZpZy5rZXlcIlxuICAgICAgICAgICBbZGlzcGxheV09XCJjb25maWcuZGlzcGxheVwiXG4gICAgICAgICAgIFtsb2FkaW5nVGVtcGxhdGVdPVwiY29uZmlnLmxvYWRpbmdUZW1wbGF0ZVwiXG4gICAgICAgICAgIFtvcHRpb25UZW1wbGF0ZV09XCJjb25maWcub3B0aW9uVGVtcGxhdGVcIlxuICAgICAgICAgICBbbm9PcHRpb25zVGVtcGxhdGVdPVwiY29uZmlnLm5vT3B0aW9uc1RlbXBsYXRlXCI+XG48L3V4LXNlbGVjdD5gXG59KVxuZXhwb3J0IGNsYXNzIFNlYXJjaFNlbGVjdENvbXBvbmVudCBleHRlbmRzIEJhc2VTZWFyY2hDb21wb25lbnQge1xuXG4gIHR5cGU6IHN0cmluZyA9ICdzZWxlY3QnO1xuXG4gIC8qKlxuICAgKiBQcm92aWRlIGRlZmF1bHRzIGZvciB1bmRlZmluZWQgcHJvcGVydGllc1xuICAgKi9cbiAgZ2V0IGxhYmVsKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLmxhYmVsO1xuICB9XG5cbiAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLm9wdGlvbnMgfHwgW107XG4gIH1cblxuICBnZXQgbXVsdGlwbGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLm11bHRpcGxlIHx8IGZhbHNlO1xuICB9XG5cbiAgZ2V0IHBsYWNlaG9sZGVyKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLnBsYWNlaG9sZGVyIHx8ICdTZWxlY3QgaXRlbSc7XG4gIH1cblxuICBnZXQgZHJvcERpcmVjdGlvbigpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy5kcm9wRGlyZWN0aW9uIHx8ICdkb3duJztcbiAgfVxuXG4gIGdldCBhbGxvd051bGwoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLmFsbG93TnVsbCB8fCBmYWxzZTtcbiAgfVxuXG4gIGdldCBkaXNhYmxlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcuZGlzYWJsZWQgfHwgZmFsc2U7XG4gIH1cblxuICBnZXQgbWF4SGVpZ2h0KCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLm1heEhlaWdodCB8fCAnMjUwcHgnO1xuICB9XG5cbiAgZ2V0IHBhZ2VTaXplKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLnBhZ2VTaXplIHx8IDIwO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VhcmNoU2VsZWN0Q29uZmlnIGV4dGVuZHMgQmFzZVNlYXJjaENvbXBvbmVudENvbmZpZyB7XG4gIG9wdGlvbnM/OiBhbnlbXSB8IEluZmluaXRlU2Nyb2xsTG9hZEZ1bmN0aW9uO1xuICBtdWx0aXBsZT86IGJvb2xlYW47XG4gIGRyb3BEaXJlY3Rpb24/OiAndXAnIHwgJ2Rvd24nO1xuICBhbGxvd051bGw/OiBib29sZWFuO1xuICBkaXNhYmxlZD86IGJvb2xlYW47XG4gIG1heEhlaWdodD86IHN0cmluZztcbiAgcGFnZVNpemU/OiBudW1iZXI7XG59IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIElucHV0LCBPbkRlc3Ryb3ksIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgZGlzdGluY3RVbnRpbENoYW5nZWQgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBTZWFyY2hCdWlsZGVyQ29tcG9uZW50RGVmaW5pdGlvbiB9IGZyb20gJy4vaW50ZXJmYWNlcy9jb21wb25lbnQtZGVmaW5pdGlvbi5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgU2VhcmNoQnVpbGRlclF1ZXJ5IH0gZnJvbSAnLi9pbnRlcmZhY2VzL3F1ZXJ5LmludGVyZmFjZSc7XG5pbXBvcnQgeyBTZWFyY2hCdWlsZGVyU2VydmljZSB9IGZyb20gJy4vc2VhcmNoLWJ1aWxkZXIuc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ3V4LXNlYXJjaC1idWlsZGVyJyxcbiAgdGVtcGxhdGU6IGA8bmctY29udGVudD48L25nLWNvbnRlbnQ+YCxcbiAgcHJvdmlkZXJzOiBbU2VhcmNoQnVpbGRlclNlcnZpY2VdXG59KVxuZXhwb3J0IGNsYXNzIFNlYXJjaEJ1aWxkZXJDb21wb25lbnQgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuXG4gIEBJbnB1dCgpXG4gIHNldCBjb21wb25lbnRzKGNvbXBvbmVudHM6IFNlYXJjaEJ1aWxkZXJDb21wb25lbnREZWZpbml0aW9uW10pIHtcbiAgICB0aGlzLl9zZWFyY2hCdWlsZGVyU2VydmljZS5yZWdpc3RlckNvbXBvbmVudHMoY29tcG9uZW50cyk7XG4gIH1cblxuICBASW5wdXQoKVxuICBzZXQgcXVlcnkodmFsdWU6IFNlYXJjaEJ1aWxkZXJRdWVyeSkge1xuICAgIHRoaXMuX3NlYXJjaEJ1aWxkZXJTZXJ2aWNlLnNldFF1ZXJ5KHZhbHVlKTtcbiAgfVxuXG4gIGdldCBxdWVyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VhcmNoQnVpbGRlclNlcnZpY2UuZ2V0UXVlcnkoKTtcbiAgfVxuXG4gIEBPdXRwdXQoKSBxdWVyeUNoYW5nZTogRXZlbnRFbWl0dGVyPFNlYXJjaEJ1aWxkZXJRdWVyeT4gPSBuZXcgRXZlbnRFbWl0dGVyPFNlYXJjaEJ1aWxkZXJRdWVyeT4oKTtcbiAgQE91dHB1dCgpIHZhbGlkOiBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4gPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KHRydWUpO1xuXG4gIHByaXZhdGUgX3F1ZXJ5U3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG4gIHByaXZhdGUgX3ZhbGlkU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIHRoZSBkZWZhdWx0IHNlYXJjaCBidWlsZGVyIGNvbXBvbmVudHNcbiAgICovXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX3NlYXJjaEJ1aWxkZXJTZXJ2aWNlOiBTZWFyY2hCdWlsZGVyU2VydmljZSkge1xuXG4gICAgLy8gd2F0Y2ggZm9yIGFueSBxdWVyeSBjaGFuZ2VzXG4gICAgdGhpcy5fcXVlcnlTdWJzY3JpcHRpb24gPSBfc2VhcmNoQnVpbGRlclNlcnZpY2UucXVlcnlDaGFuZ2Uuc3Vic2NyaWJlKHF1ZXJ5ID0+IHRoaXMucXVlcnlDaGFuZ2UuZW1pdChxdWVyeSkpO1xuXG4gICAgLy8gd2F0Y2ggZm9yIGFueSBjaGFuZ2VzIHRvIHRoZSB2YWxpZGF0aW9uXG4gICAgdGhpcy5fdmFsaWRTdWJzY3JpcHRpb24gPSBfc2VhcmNoQnVpbGRlclNlcnZpY2UudmFsaWRhdGlvbkNoYW5nZS5waXBlKGRpc3RpbmN0VW50aWxDaGFuZ2VkKCkpLnN1YnNjcmliZSh2YWxpZCA9PiB0aGlzLnZhbGlkLmVtaXQodmFsaWQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW55IHN1YnNjcmlwdGlvbnMgYW5kIGNsZWFudXBcbiAgICovXG4gIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMuX3F1ZXJ5U3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgdGhpcy5fdmFsaWRTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgfVxuXG59XG4iLCJleHBvcnQgY2xhc3MgVHlwZWFoZWFkT3B0aW9uRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBvcHRpb246IGFueSkge31cbn0iLCJpbXBvcnQgeyBUeXBlYWhlYWRDb21wb25lbnQgfSBmcm9tICcuL2luZGV4JztcbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFR5cGVhaGVhZEtleVNlcnZpY2Uge1xuXG4gICAgY29uc3RydWN0b3IoKSB7IH1cblxuICAgIGhhbmRsZUtleShldmVudDogS2V5Ym9hcmRFdmVudCwgdHlwZWFoZWFkOiBUeXBlYWhlYWRDb21wb25lbnQpIHtcbiAgICAgICAgaWYgKHR5cGVhaGVhZCkge1xuICAgICAgICAgICAgc3dpdGNoIChldmVudC5rZXkpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdBcnJvd1VwJzpcbiAgICAgICAgICAgICAgICBjYXNlICdVcCc6XG4gICAgICAgICAgICAgICAgICAgIGlmICghdHlwZWFoZWFkLm9wZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVhaGVhZC5vcGVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVhaGVhZC5tb3ZlSGlnaGxpZ2h0KC0xKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdBcnJvd0Rvd24nOlxuICAgICAgICAgICAgICAgIGNhc2UgJ0Rvd24nOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIXR5cGVhaGVhZC5vcGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlYWhlYWQub3BlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlYWhlYWQubW92ZUhpZ2hsaWdodCgxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdFc2NhcGUnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ0VzYyc6XG4gICAgICAgICAgICAgICAgICAgIHR5cGVhaGVhZC5vcGVuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSIsImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcy9CZWhhdmlvclN1YmplY3QnO1xyXG5cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgVHlwZWFoZWFkU2VydmljZSB7XHJcblxyXG4gICAgb3BlbiQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+KGZhbHNlKTtcclxuXHJcbiAgICBoaWdobGlnaHRlZEVsZW1lbnQkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxIVE1MRWxlbWVudD4obnVsbCk7XHJcbn0iLCJpbXBvcnQgeyBBZnRlclZpZXdJbml0LCBDaGFuZ2VEZXRlY3RvclJlZiwgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIEhvc3RCaW5kaW5nLCBIb3N0TGlzdGVuZXIsIElucHV0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSwgT3V0cHV0LCBTaW1wbGVDaGFuZ2VzLCBUZW1wbGF0ZVJlZiwgVmlld0NoaWxkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcclxuaW1wb3J0IHsgY29tYmluZUxhdGVzdCB9IGZyb20gJ3J4anMvb2JzZXJ2YWJsZS9jb21iaW5lTGF0ZXN0JztcclxuaW1wb3J0IHsgZGlzdGluY3RVbnRpbENoYW5nZWQgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcclxuaW1wb3J0IHsgSW5maW5pdGVTY3JvbGxMb2FkRnVuY3Rpb24gfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL2luZmluaXRlLXNjcm9sbC9pbmRleCc7XHJcbmltcG9ydCB7IFR5cGVhaGVhZE9wdGlvbkV2ZW50IH0gZnJvbSAnLi90eXBlYWhlYWQtZXZlbnQnO1xyXG5pbXBvcnQgeyBUeXBlYWhlYWRTZXJ2aWNlIH0gZnJvbSAnLi90eXBlYWhlYWQuc2VydmljZSc7XHJcblxyXG5sZXQgdW5pcXVlSWQgPSAwO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgICBzZWxlY3RvcjogJ3V4LXR5cGVhaGVhZCcsXHJcbiAgICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJ1eC10eXBlYWhlYWQtb3B0aW9uc1wiXG4gICAgW3V4SW5maW5pdGVTY3JvbGxdPVwibG9hZE9wdGlvbnNDYWxsYmFja1wiXG4gICAgW2NvbGxlY3Rpb25dPVwidmlzaWJsZU9wdGlvbnMkIHwgYXN5bmNcIlxuICAgIChjb2xsZWN0aW9uQ2hhbmdlKT1cInZpc2libGVPcHRpb25zJC5uZXh0KCRldmVudClcIlxuICAgIFtlbmFibGVkXT1cImlzSW5maW5pdGVTY3JvbGwoKVwiXG4gICAgW2ZpbHRlcl09XCJmaWx0ZXJcIlxuICAgIFtsb2FkT25TY3JvbGxdPVwidHJ1ZVwiXG4gICAgW3BhZ2VTaXplXT1cInBhZ2VTaXplXCJcbiAgICBbc2Nyb2xsRWxlbWVudF09XCJ0eXBlYWhlYWRFbGVtZW50XCJcbiAgICAobG9hZGluZyk9XCJsb2FkaW5nID0gdHJ1ZVwiXG4gICAgKGxvYWRlZCk9XCJsb2FkaW5nID0gZmFsc2VcIj5cblxuICAgIDxvbCAqbmdJZj1cIih2aXNpYmxlT3B0aW9ucyQgfCBhc3luYykubGVuZ3RoID4gMFwiPlxuICAgICAgICA8bGkgKm5nRm9yPVwibGV0IG9wdGlvbiBvZiAodmlzaWJsZU9wdGlvbnMkIHwgYXN5bmMpOyBsZXQgaSA9IGluZGV4XCJcbiAgICAgICAgICAgIFthdHRyLmlkXT1cImlkICsgJy1vcHRpb24tJyArIGlcIlxuICAgICAgICAgICAgW2NsYXNzLmRpc2FibGVkXT1cImlzRGlzYWJsZWQob3B0aW9uKVwiXG4gICAgICAgICAgICBbY2xhc3MuaGlnaGxpZ2h0ZWRdPVwiaGlnaGxpZ2h0ZWRLZXkgPT09IG9wdGlvbi5rZXlcIlxuICAgICAgICAgICAgW2F0dHIuYXJpYS1zZWxlY3RlZF09XCJtdWx0aXNlbGVjdGFibGUgPyBpc0Rpc2FibGVkKG9wdGlvbikgOiBudWxsXCJcbiAgICAgICAgICAgIFt1eFR5cGVhaGVhZEhpZ2hsaWdodF09XCJoaWdobGlnaHRlZEtleSA9PT0gb3B0aW9uLmtleVwiXG4gICAgICAgICAgICBbdXhTY3JvbGxJbnRvVmlld0lmXT1cImhpZ2hsaWdodGVkS2V5ID09PSBvcHRpb24ua2V5XCJcbiAgICAgICAgICAgIFtzY3JvbGxQYXJlbnRdPVwidHlwZWFoZWFkRWxlbWVudC5uYXRpdmVFbGVtZW50XCJcbiAgICAgICAgICAgIChtb3VzZWRvd24pPVwib3B0aW9uTW91c2Vkb3duSGFuZGxlcigkZXZlbnQpXCJcbiAgICAgICAgICAgIChjbGljayk9XCJvcHRpb25DbGlja0hhbmRsZXIoJGV2ZW50LCBvcHRpb24pXCJcbiAgICAgICAgICAgIChtb3VzZW92ZXIpPVwiaGlnaGxpZ2h0KG9wdGlvbilcIj5cblxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciBbbmdUZW1wbGF0ZU91dGxldF09XCJvcHRpb25UZW1wbGF0ZVwiXG4gICAgICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRDb250ZXh0XT1cIntvcHRpb246IG9wdGlvbi52YWx1ZSwgYXBpOiBvcHRpb25BcGl9XCI+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cblxuICAgICAgICA8L2xpPlxuICAgIDwvb2w+XG5cbiAgICA8ZGl2ICp1eEluZmluaXRlU2Nyb2xsTG9hZGluZz5cbiAgICAgICAgPG5nLWNvbnRhaW5lciBbbmdUZW1wbGF0ZU91dGxldF09XCJsb2FkaW5nVGVtcGxhdGVcIj5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgPC9kaXY+XG5cbjwvZGl2PlxuPGRpdiAqbmdJZj1cIih2aXNpYmxlT3B0aW9ucyQgfCBhc3luYykubGVuZ3RoID09PSAwICYmICFsb2FkaW5nXCI+XG4gICAgPG5nLWNvbnRhaW5lciBbbmdUZW1wbGF0ZU91dGxldF09XCJub09wdGlvbnNUZW1wbGF0ZVwiPlxuICAgIDwvbmctY29udGFpbmVyPlxuPC9kaXY+XG5cbjxuZy10ZW1wbGF0ZSAjZGVmYXVsdExvYWRpbmdUZW1wbGF0ZT5cbiAgICA8ZGl2IGNsYXNzPVwidXgtdHlwZWFoZWFkLWxvYWRpbmdcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInNwaW5uZXIgc3Bpbm5lci1hY2NlbnQgc3Bpbm5lci1ib3VuY2UtbWlkZGxlXCI+PC9kaXY+XG4gICAgICAgIDxkaXY+TG9hZGluZy4uLjwvZGl2PlxuICAgIDwvZGl2PlxuPC9uZy10ZW1wbGF0ZT5cblxuPG5nLXRlbXBsYXRlICNkZWZhdWx0T3B0aW9uVGVtcGxhdGUgbGV0LW9wdGlvbj1cIm9wdGlvblwiIGxldC1hcGk9XCJhcGlcIj5cbiAgICA8c3BhbiBjbGFzcz1cInV4LXR5cGVhaGVhZC1vcHRpb25cIiBbaW5uZXJIdG1sXT1cImFwaS5nZXREaXNwbGF5SHRtbChvcHRpb24pXCI+PC9zcGFuPlxuPC9uZy10ZW1wbGF0ZT5cblxuPG5nLXRlbXBsYXRlICNkZWZhdWx0Tm9PcHRpb25zVGVtcGxhdGU+XG4gICAgPHNwYW4gY2xhc3M9XCJ1eC10eXBlYWhlYWQtbm8tb3B0aW9uc1wiPk5vIHJlc3VsdHM8L3NwYW4+XG48L25nLXRlbXBsYXRlPmAsXHJcbiAgICBwcm92aWRlcnM6IFtUeXBlYWhlYWRTZXJ2aWNlXSxcclxuICAgIGhvc3Q6IHtcclxuICAgICAgICAncm9sZSc6ICdsaXN0Ym94JyxcclxuICAgICAgICAnW2NsYXNzLm9wZW5dJzogJ29wZW4nLFxyXG4gICAgICAgICdbY2xhc3MuZHJvcC11cF0nOiAnZHJvcERpcmVjdGlvbiA9PT0gXCJ1cFwiJyxcclxuICAgICAgICAnW3N0eWxlLm1heEhlaWdodF0nOiAnbWF4SGVpZ2h0J1xyXG4gICAgfVxyXG59KVxyXG5leHBvcnQgY2xhc3MgVHlwZWFoZWFkQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCwgT25DaGFuZ2VzLCBPbkRlc3Ryb3kge1xyXG5cclxuICAgIEBJbnB1dCgpIEBIb3N0QmluZGluZygnYXR0ci5pZCcpIGlkOiBzdHJpbmcgPSBgdXgtdHlwZWFoZWFkLSR7Kyt1bmlxdWVJZH1gO1xyXG5cclxuICAgIEBJbnB1dCgpIG9wdGlvbnM6IGFueVtdIHwgSW5maW5pdGVTY3JvbGxMb2FkRnVuY3Rpb247XHJcbiAgICBASW5wdXQoKSBmaWx0ZXI6IHN0cmluZztcclxuXHJcbiAgICBASW5wdXQoJ29wZW4nKVxyXG4gICAgZ2V0IG9wZW4oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlcnZpY2Uub3BlbiQuZ2V0VmFsdWUoKTtcclxuICAgIH1cclxuICAgIHNldCBvcGVuKHZhbHVlOiBib29sZWFuKSB7XHJcbiAgICAgICAgdGhpcy5fc2VydmljZS5vcGVuJC5uZXh0KHZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICBAT3V0cHV0KCkgb3BlbkNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oKTtcclxuXHJcbiAgICBASW5wdXQoKSBkaXNwbGF5OiAob3B0aW9uOiBhbnkpID0+IHN0cmluZyB8IHN0cmluZztcclxuICAgIEBJbnB1dCgpIGtleTogKG9wdGlvbjogYW55KSA9PiBzdHJpbmcgfCBzdHJpbmc7XHJcbiAgICBASW5wdXQoKSBkaXNhYmxlZE9wdGlvbnM6IGFueVtdO1xyXG4gICAgQElucHV0KCkgZHJvcERpcmVjdGlvbjogJ3VwJyB8ICdkb3duJyA9ICdkb3duJztcclxuICAgIEBJbnB1dCgpIG1heEhlaWdodDogc3RyaW5nID0gJzI1MHB4JztcclxuICAgIEBJbnB1dCgpIEBIb3N0QmluZGluZygnYXR0ci5hcmlhLW11bHRpc2VsZWN0YWJsZScpIG11bHRpc2VsZWN0YWJsZTogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgQElucHV0KCkgb3Blbk9uRmlsdGVyQ2hhbmdlOiBib29sZWFuID0gdHJ1ZTtcclxuICAgIEBJbnB1dCgpIHBhZ2VTaXplOiBudW1iZXIgPSAyMDtcclxuICAgIEBJbnB1dCgpIHNlbGVjdEZpcnN0OiBib29sZWFuID0gdHJ1ZTtcclxuXHJcbiAgICBASW5wdXQoKSBsb2FkaW5nVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XHJcbiAgICBASW5wdXQoKSBvcHRpb25UZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcclxuICAgIEBJbnB1dCgpIG5vT3B0aW9uc1RlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xyXG5cclxuICAgIEBPdXRwdXQoKSBvcHRpb25TZWxlY3RlZCA9IG5ldyBFdmVudEVtaXR0ZXI8VHlwZWFoZWFkT3B0aW9uRXZlbnQ+KCk7XHJcblxyXG4gICAgQE91dHB1dCgpIGhpZ2hsaWdodGVkQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XHJcbiAgICBAT3V0cHV0KCkgaGlnaGxpZ2h0ZWRFbGVtZW50Q2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxIVE1MRWxlbWVudD4oKTtcclxuXHJcbiAgICBAVmlld0NoaWxkKCdkZWZhdWx0TG9hZGluZ1RlbXBsYXRlJykgcHJpdmF0ZSBfZGVmYXVsdExvYWRpbmdUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcclxuICAgIEBWaWV3Q2hpbGQoJ2RlZmF1bHRPcHRpb25UZW1wbGF0ZScpIHByaXZhdGUgX2RlZmF1bHRPcHRpb25UZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcclxuICAgIEBWaWV3Q2hpbGQoJ2RlZmF1bHROb09wdGlvbnNUZW1wbGF0ZScpIHByaXZhdGUgX2RlZmF1bHROb09wdGlvbnNUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcclxuXHJcbiAgICBsb2FkT3B0aW9uc0NhbGxiYWNrOiBJbmZpbml0ZVNjcm9sbExvYWRGdW5jdGlvbjtcclxuICAgIHZpc2libGVPcHRpb25zJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8VHlwZWFoZWFkVmlzaWJsZU9wdGlvbltdPihbXSk7XHJcbiAgICBsb2FkaW5nID0gZmFsc2U7XHJcbiAgICBjbGlja2luZyA9IGZhbHNlO1xyXG4gICAgaGlnaGxpZ2h0ZWQkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxUeXBlYWhlYWRWaXNpYmxlT3B0aW9uPihudWxsKTtcclxuICAgIGhpZ2hsaWdodGVkS2V5OiBzdHJpbmcgPSBudWxsO1xyXG5cclxuICAgIGdldCBoaWdobGlnaHRlZCgpOiBhbnkge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5oaWdobGlnaHRlZCQuZ2V0VmFsdWUoKTtcclxuICAgICAgICByZXR1cm4gdmFsdWUgPyB2YWx1ZS52YWx1ZSA6IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfb3BlbjogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbigpO1xyXG5cclxuICAgIG9wdGlvbkFwaTogVHlwZWFoZWFkT3B0aW9uQXBpID0ge1xyXG4gICAgICAgIGdldEtleTogdGhpcy5nZXRLZXkuYmluZCh0aGlzKSxcclxuICAgICAgICBnZXREaXNwbGF5OiB0aGlzLmdldERpc3BsYXkuYmluZCh0aGlzKSxcclxuICAgICAgICBnZXREaXNwbGF5SHRtbDogdGhpcy5nZXREaXNwbGF5SHRtbC5iaW5kKHRoaXMpXHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgICAgIHB1YmxpYyB0eXBlYWhlYWRFbGVtZW50OiBFbGVtZW50UmVmLFxyXG4gICAgICAgIHByaXZhdGUgX2NkUmVmOiBDaGFuZ2VEZXRlY3RvclJlZixcclxuICAgICAgICBwcml2YXRlIF9zZXJ2aWNlOiBUeXBlYWhlYWRTZXJ2aWNlXHJcbiAgICApIHtcclxuXHJcbiAgICAgICAgdGhpcy5sb2FkT3B0aW9uc0NhbGxiYWNrID0gKHBhZ2VOdW06IG51bWJlciwgcGFnZVNpemU6IG51bWJlciwgZmlsdGVyOiBhbnkpID0+IHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJbnZva2UgdGhlIGNhbGxiYWNrIHdoaWNoIG1heSByZXR1cm4gYW4gYXJyYXkgb3IgYSBwcm9taXNlLlxyXG4gICAgICAgICAgICAgICAgY29uc3QgYXJyYXlPclByb21pc2UgPSB0aGlzLm9wdGlvbnMocGFnZU51bSwgcGFnZVNpemUsIGZpbHRlcik7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTWFwIHRoZSByZXN1bHRzIHRvIGFuIGFycmF5IG9mIFR5cGVhaGVhZFZpc2libGVPcHRpb24uXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGFycmF5T3JQcm9taXNlKS50aGVuKG5ld09wdGlvbnMgPT4ge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobmV3T3B0aW9ucykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld09wdGlvbnM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3T3B0aW9ucy5tYXAoKG9wdGlvbjogYW55KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiB0aGlzLmdldEtleShvcHRpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24uYWRkKFxyXG4gICAgICAgICAgICB0aGlzLl9zZXJ2aWNlLm9wZW4kLnBpcGUoZGlzdGluY3RVbnRpbENoYW5nZWQoKSkuc3Vic2NyaWJlKChuZXh0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wZW5DaGFuZ2UuZW1pdChuZXh0KTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAobmV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5pdE9wdGlvbnMoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24uYWRkKFxyXG4gICAgICAgICAgICB0aGlzLmhpZ2hsaWdodGVkJC5zdWJzY3JpYmUoKG5leHQpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWRLZXkgPSBuZXh0ID8gbmV4dC5rZXkgOiBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRlZENoYW5nZS5lbWl0KG5leHQgPyBuZXh0LnZhbHVlIDogbnVsbCk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLmFkZChcclxuICAgICAgICAgICAgY29tYmluZUxhdGVzdCh0aGlzLl9zZXJ2aWNlLm9wZW4kLCB0aGlzLl9zZXJ2aWNlLmhpZ2hsaWdodGVkRWxlbWVudCQsIHRoaXMudmlzaWJsZU9wdGlvbnMkKVxyXG4gICAgICAgICAgICAgICAgLnN1YnNjcmliZSgoW29wZW4sIGhpZ2hsaWdodGVkRWxlbWVudCwgdmlzaWJsZU9wdGlvbnNdKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRlZEVsZW1lbnRDaGFuZ2UuZW1pdChvcGVuICYmIHZpc2libGVPcHRpb25zLmxlbmd0aCA+IDAgPyBoaWdobGlnaHRlZEVsZW1lbnQgOiBudWxsKTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBuZ0FmdGVyVmlld0luaXQoKSB7XHJcbiAgICAgICAgLy8gQXR0YWNoIGRlZmF1bHQgbG9hZGluZyB0ZW1wbGF0ZVxyXG4gICAgICAgIGlmICghdGhpcy5sb2FkaW5nVGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2FkaW5nVGVtcGxhdGUgPSB0aGlzLl9kZWZhdWx0TG9hZGluZ1RlbXBsYXRlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQXR0YWNoIGRlZmF1bHQgb3B0aW9uIHRlbXBsYXRlXHJcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvblRlbXBsYXRlKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3B0aW9uVGVtcGxhdGUgPSB0aGlzLl9kZWZhdWx0T3B0aW9uVGVtcGxhdGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBBdHRhY2ggZGVmYXVsdCBcIm5vIHJlc3VsdHNcIiB0ZW1wbGF0ZVxyXG4gICAgICAgIGlmICghdGhpcy5ub09wdGlvbnNUZW1wbGF0ZSkge1xyXG4gICAgICAgICAgICB0aGlzLm5vT3B0aW9uc1RlbXBsYXRlID0gdGhpcy5fZGVmYXVsdE5vT3B0aW9uc1RlbXBsYXRlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5fY2RSZWYuZGV0ZWN0Q2hhbmdlcygpO1xyXG4gICAgfVxyXG5cclxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcclxuICAgICAgICAvLyBPcGVuIHRoZSBkcm9wZG93biBpZiB0aGUgZmlsdGVyIHZhbHVlIHVwZGF0ZXNcclxuICAgICAgICBpZiAoY2hhbmdlcy5maWx0ZXIpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMub3Blbk9uRmlsdGVyQ2hhbmdlICYmIGNoYW5nZXMuZmlsdGVyLmN1cnJlbnRWYWx1ZSAmJiBjaGFuZ2VzLmZpbHRlci5jdXJyZW50VmFsdWUubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmUtZmlsdGVyIHZpc2libGVPcHRpb25zXHJcbiAgICAgICAgdGhpcy51cGRhdGVPcHRpb25zKCk7XHJcbiAgICB9XHJcblxyXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgQEhvc3RMaXN0ZW5lcignbW91c2Vkb3duJylcclxuICAgIG1vdXNlZG93bkhhbmRsZXIoKSB7XHJcbiAgICAgICAgdGhpcy5jbGlja2luZyA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgQEhvc3RMaXN0ZW5lcignbW91c2V1cCcpXHJcbiAgICBtb3VzZXVwSGFuZGxlcigpIHtcclxuICAgICAgICB0aGlzLmNsaWNraW5nID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgb3B0aW9uTW91c2Vkb3duSGFuZGxlcihldmVudDogTW91c2VFdmVudCkge1xyXG4gICAgICAgIC8vIFdvcmthcm91bmQgdG8gcHJldmVudCBmb2N1cyBjaGFuZ2luZyB3aGVuIGFuIG9wdGlvbiBpcyBjbGlja2VkXHJcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgIH1cclxuXHJcbiAgICBvcHRpb25DbGlja0hhbmRsZXIoZXZlbnQ6IE1vdXNlRXZlbnQsIG9wdGlvbjogVHlwZWFoZWFkVmlzaWJsZU9wdGlvbikge1xyXG4gICAgICAgIHRoaXMuc2VsZWN0KG9wdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB1bmlxdWUga2V5IHZhbHVlIG9mIHRoZSBnaXZlbiBvcHRpb24uXHJcbiAgICAgKi9cclxuICAgIGdldEtleShvcHRpb246IGFueSk6IHN0cmluZyB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmtleSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5rZXkob3B0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmtleSA9PT0gJ3N0cmluZycgJiYgb3B0aW9uICYmIG9wdGlvbi5oYXNPd25Qcm9wZXJ0eSh0aGlzLmtleSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbls8c3RyaW5nPnRoaXMua2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGlzcGxheShvcHRpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZGlzcGxheSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gb3B0aW9uLlxyXG4gICAgICovXHJcbiAgICBnZXREaXNwbGF5KG9wdGlvbjogYW55KTogc3RyaW5nIHtcclxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuZGlzcGxheSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kaXNwbGF5KG9wdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5kaXNwbGF5ID09PSAnc3RyaW5nJyAmJiBvcHRpb24gJiYgb3B0aW9uLmhhc093blByb3BlcnR5KHRoaXMuZGlzcGxheSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbls8c3RyaW5nPnRoaXMuZGlzcGxheV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvcHRpb247XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBkaXNwbGF5IHZhbHVlIG9mIHRoZSBnaXZlbiBvcHRpb24gd2l0aCBIVE1MIG1hcmt1cCBhZGRlZCB0byBoaWdobGlnaHQgdGhlIHBhcnQgd2hpY2ggbWF0Y2hlcyB0aGUgY3VycmVudCBmaWx0ZXIgdmFsdWUuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9uXHJcbiAgICAgKi9cclxuICAgIGdldERpc3BsYXlIdG1sKG9wdGlvbjogYW55KSB7XHJcbiAgICAgICAgY29uc3QgZGlzcGxheVRleHQgPSB0aGlzLmdldERpc3BsYXkob3B0aW9uKS5yZXBsYWNlKC8mL2csICcmYW1wOycpLnJlcGxhY2UoLzwvZywgJyZsdDsnKS5yZXBsYWNlKC8+L2csICcmZ3Q7Jyk7XHJcbiAgICAgICAgbGV0IGRpc3BsYXlIdG1sID0gZGlzcGxheVRleHQ7XHJcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHRoaXMuZmlsdGVyLmxlbmd0aDtcclxuICAgICAgICAgICAgY29uc3QgbWF0Y2hJbmRleCA9IGRpc3BsYXlUZXh0LnRvTG93ZXJDYXNlKCkuaW5kZXhPZih0aGlzLmZpbHRlci50b0xvd2VyQ2FzZSgpKTtcclxuICAgICAgICAgICAgaWYgKG1hdGNoSW5kZXggPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGhpZ2hsaWdodCA9IGA8c3BhbiBjbGFzcz1cInV4LWZpbHRlci1tYXRjaFwiPiR7ZGlzcGxheVRleHQuc3Vic3RyKG1hdGNoSW5kZXgsIGxlbmd0aCl9PC9zcGFuPmA7XHJcbiAgICAgICAgICAgICAgICBkaXNwbGF5SHRtbCA9IGRpc3BsYXlUZXh0LnN1YnN0cigwLCBtYXRjaEluZGV4KSArIGhpZ2hsaWdodCArIGRpc3BsYXlUZXh0LnN1YnN0cihtYXRjaEluZGV4ICsgbGVuZ3RoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGlzcGxheUh0bWw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGluZmluaXRlIHNjcm9sbCBjb21wb25lbnQgc2hvdWxkIGxvYWRcclxuICAgICAqL1xyXG4gICAgaXNJbmZpbml0ZVNjcm9sbCgpIHtcclxuICAgICAgICByZXR1cm4gdHlwZW9mIHRoaXMub3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNlbGVjdHMgdGhlIGdpdmVuIG9wdGlvbiwgZW1pdHRpbmcgdGhlIG9wdGlvblNlbGVjdGVkIGV2ZW50IGFuZCBjbG9zaW5nIHRoZSBkcm9wZG93bi5cclxuICAgICAqL1xyXG4gICAgc2VsZWN0KG9wdGlvbjogVHlwZWFoZWFkVmlzaWJsZU9wdGlvbikge1xyXG4gICAgICAgIGlmICghdGhpcy5pc0Rpc2FibGVkKG9wdGlvbikpIHtcclxuICAgICAgICAgICAgdGhpcy5vcHRpb25TZWxlY3RlZC5lbWl0KG5ldyBUeXBlYWhlYWRPcHRpb25FdmVudChvcHRpb24udmFsdWUpKTtcclxuICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRlZCQubmV4dChudWxsKTtcclxuICAgICAgICAgICAgdGhpcy5vcGVuID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBvcHRpb24gaXMgcGFydCBvZiB0aGUgZGlzYWJsZWRPcHRpb25zIGFycmF5LlxyXG4gICAgICovXHJcbiAgICBpc0Rpc2FibGVkKG9wdGlvbjogVHlwZWFoZWFkVmlzaWJsZU9wdGlvbik6IGJvb2xlYW4ge1xyXG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkT3B0aW9ucykge1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmRpc2FibGVkT3B0aW9ucy5maW5kKChzZWxlY3RlZE9wdGlvbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0S2V5KHNlbGVjdGVkT3B0aW9uKSA9PT0gb3B0aW9uLmtleTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgIT09IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBnaXZlbiBvcHRpb24gYXMgdGhlIGN1cnJlbnQgaGlnaGxpZ2h0ZWQgb3B0aW9uLCBhdmFpbGFibGUgaW4gdGhlIGhpZ2hsaWdodGVkT3B0aW9uIHBhcmFtZXRlci5cclxuICAgICAqL1xyXG4gICAgaGlnaGxpZ2h0KG9wdGlvbjogVHlwZWFoZWFkVmlzaWJsZU9wdGlvbikge1xyXG4gICAgICAgIGlmICghdGhpcy5pc0Rpc2FibGVkKG9wdGlvbikpIHtcclxuICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRlZCQubmV4dChvcHRpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEluY3JlbWVudCBvciBkZWNyZW1lbnQgdGhlIGhpZ2hsaWdodGVkIG9wdGlvbiBpbiB0aGUgbGlzdC4gRGlzYWJsZWQgb3B0aW9ucyBhcmUgc2tpcHBlZC5cclxuICAgICAqIEBwYXJhbSBkIFZhbHVlIHRvIGJlIGFkZGVkIHRvIHRoZSBpbmRleCBvZiB0aGUgaGlnaGxpZ2h0ZWQgb3B0aW9uLCBpLmUuIC0xIHRvIG1vdmUgYmFja3dhcmRzLCArMSB0byBtb3ZlIGZvcndhcmRzLlxyXG4gICAgICovXHJcbiAgICBtb3ZlSGlnaGxpZ2h0KGQ6IG51bWJlcik6IGFueSB7XHJcbiAgICAgICAgY29uc3QgdmlzaWJsZU9wdGlvbnMgPSB0aGlzLnZpc2libGVPcHRpb25zJC5nZXRWYWx1ZSgpO1xyXG4gICAgICAgIGNvbnN0IGhpZ2hsaWdodEluZGV4ID0gdGhpcy5pbmRleE9mVmlzaWJsZU9wdGlvbih0aGlzLmhpZ2hsaWdodGVkKTtcclxuICAgICAgICBsZXQgbmV3SW5kZXggPSBoaWdobGlnaHRJbmRleDtcclxuICAgICAgICBsZXQgZGlzYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgIGxldCBpbkJvdW5kcyA9IHRydWU7XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBuZXdJbmRleCA9IG5ld0luZGV4ICsgZDtcclxuICAgICAgICAgICAgaW5Cb3VuZHMgPSAobmV3SW5kZXggPj0gMCAmJiBuZXdJbmRleCA8IHZpc2libGVPcHRpb25zLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIGRpc2FibGVkID0gaW5Cb3VuZHMgJiYgdGhpcy5pc0Rpc2FibGVkKHZpc2libGVPcHRpb25zW25ld0luZGV4XSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdoaWxlIChpbkJvdW5kcyAmJiBkaXNhYmxlZCk7XHJcblxyXG4gICAgICAgIGlmICghZGlzYWJsZWQgJiYgaW5Cb3VuZHMpIHtcclxuICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRlZCQubmV4dCh2aXNpYmxlT3B0aW9uc1tuZXdJbmRleF0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaGlnaGxpZ2h0ZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdXAgdGhlIG9wdGlvbnMgYmVmb3JlIHRoZSBkcm9wZG93biBpcyBkaXNwbGF5ZWQuXHJcbiAgICAgKi9cclxuICAgIGluaXRPcHRpb25zKCkge1xyXG4gICAgICAgIC8vIENsZWFyIHByZXZpb3VzIGhpZ2hsaWdodFxyXG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWQkLm5leHQobnVsbCk7XHJcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0Rmlyc3QpIHtcclxuICAgICAgICAgICAgLy8gVGhpcyB3aWxsIGhpZ2hsaWdodCB0aGUgZmlyc3Qgbm9uLWRpc2FibGVkIG9wdGlvbi5cclxuICAgICAgICAgICAgdGhpcy5tb3ZlSGlnaGxpZ2h0KDEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSB0aGUgdmlzaWJsZU9wdGlvbnMgYXJyYXkgd2l0aCB0aGUgY3VycmVudCBmaWx0ZXIuXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZU9wdGlvbnMoKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGlzZWRJbnB1dCA9ICh0aGlzLmZpbHRlciB8fCAnJykudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgY29uc3QgdmlzaWJsZU9wdGlvbnMgPSB0aGlzLm9wdGlvbnNcclxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKG9wdGlvbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldERpc3BsYXkob3B0aW9uKS50b0xvd2VyQ2FzZSgpLmluZGV4T2Yobm9ybWFsaXNlZElucHV0KSA+PSAwO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5tYXAoKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IHRoaXMuZ2V0S2V5KHZhbHVlKVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy52aXNpYmxlT3B0aW9ucyQubmV4dCh2aXNpYmxlT3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmluaXRPcHRpb25zKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIGluZGV4IG9mIHRoZSBnaXZlbiBvcHRpb24gaW4gdGhlIHZpc2libGVPcHRpb25zIGFycmF5LiBSZXR1cm5zIC0xIGlmIHRoZSBvcHRpb24gaXMgbm90IGN1cnJlbnRseSB2aXNpYmxlLlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGluZGV4T2ZWaXNpYmxlT3B0aW9uKG9wdGlvbjogYW55KTogbnVtYmVyIHtcclxuICAgICAgICBpZiAob3B0aW9uKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbktleSA9IHRoaXMuZ2V0S2V5KG9wdGlvbik7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZpc2libGVPcHRpb25zJC5nZXRWYWx1ZSgpLmZpbmRJbmRleCgoZWwpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbC5rZXkgPT09IG9wdGlvbktleTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgQVBJIGF2YWlsYWJsZSB0byBvcHRpb24gdGVtcGxhdGVzLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBUeXBlYWhlYWRPcHRpb25BcGkge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdW5pcXVlIGtleSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gb3B0aW9uLlxyXG4gICAgICovXHJcbiAgICBnZXRLZXkob3B0aW9uOiBhbnkpOiBzdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBkaXNwbGF5IHZhbHVlIG9mIHRoZSBnaXZlbiBvcHRpb24uXHJcbiAgICAgKi9cclxuICAgIGdldERpc3BsYXkob3B0aW9uOiBhbnkpOiBzdHJpbmc7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBkaXNwbGF5IHZhbHVlIG9mIHRoZSBnaXZlbiBvcHRpb24gd2l0aCBIVE1MIG1hcmt1cCBhZGRlZCB0byBoaWdobGlnaHQgdGhlIHBhcnQgd2hpY2ggbWF0Y2hlcyB0aGUgY3VycmVudCBmaWx0ZXIgdmFsdWUuIE92ZXJyaWRlIHRoZSB1eC1maWx0ZXItbWF0Y2ggY2xhc3MgaW4gQ1NTIHRvIG1vZGlmeSB0aGUgZGVmYXVsdCBhcHBlYXJhbmNlLlxyXG4gICAgICovXHJcbiAgICBnZXREaXNwbGF5SHRtbChvcHRpb246IGFueSk6IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBUeXBlYWhlYWRWaXNpYmxlT3B0aW9uIHtcclxuICAgIHZhbHVlOiBhbnk7XHJcbiAgICBrZXk6IHN0cmluZztcclxufSIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSW5wdXQsIE91dHB1dCwgUmVuZGVyZXIyLCBUZW1wbGF0ZVJlZiwgVmlld0NvbnRhaW5lclJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMvT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbdXhJbmZpbml0ZVNjcm9sbExvYWRCdXR0b25dJ1xufSlcbmV4cG9ydCBjbGFzcyBJbmZpbml0ZVNjcm9sbExvYWRCdXR0b25EaXJlY3RpdmUge1xuXG4gICAgQElucHV0KCd1eEluZmluaXRlU2Nyb2xsTG9hZEJ1dHRvbicpXG4gICAgZ2V0IHZpc2libGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92aXNpYmxlO1xuICAgIH1cbiAgICBzZXQgdmlzaWJsZSh2YWx1ZTogYm9vbGVhbikge1xuICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMuX3Zpc2libGUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZpZXdDb250YWluZXIuY3JlYXRlRW1iZWRkZWRWaWV3KHRoaXMuX3RlbXBsYXRlKTtcblxuICAgICAgICAgICAgICAgIC8vIFRlbXBsYXRlIGNvbnRlbnQgZm9sbG93cyB0aGUgZWxlbWVudFJlZiwgd2hpY2ggaXMgYSBjb21tZW50LlxuICAgICAgICAgICAgICAgIGNvbnN0IGNsaWNrVGFyZ2V0ID0gdGhpcy5nZXROZXh0RWxlbWVudFNpYmxpbmcodGhpcy5fdGVtcGxhdGUuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5saXN0ZW4oY2xpY2tUYXJnZXQsICdjbGljaycsIHRoaXMub25DbGljay5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmlld0NvbnRhaW5lci5jbGVhcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdmlzaWJsZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIEBPdXRwdXQoKSBsb2FkOiBPYnNlcnZhYmxlPEV2ZW50PjtcblxuICAgIHByaXZhdGUgX3Zpc2libGU6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBwcml2YXRlIF9sb2FkID0gbmV3IFN1YmplY3QoKTtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIF9lbGVtZW50OiBFbGVtZW50UmVmLFxuICAgICAgICBwcml2YXRlIF90ZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PixcbiAgICAgICAgcHJpdmF0ZSBfdmlld0NvbnRhaW5lcjogVmlld0NvbnRhaW5lclJlZixcbiAgICAgICAgcHJpdmF0ZSBfcmVuZGVyZXI6IFJlbmRlcmVyMikge1xuXG4gICAgICAgIHRoaXMubG9hZCA9IHRoaXMuX2xvYWQuYXNPYnNlcnZhYmxlKCkgYXMgT2JzZXJ2YWJsZTxFdmVudD47XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBvbkNsaWNrKGV2ZW50OiBNb3VzZUV2ZW50KSB7XG4gICAgICAgIHRoaXMuX2xvYWQubmV4dChldmVudCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXROZXh0RWxlbWVudFNpYmxpbmcoZWxlbWVudDogYW55KTogRWxlbWVudCB7XG4gICAgICAgIHZhciBuZXh0ID0gZWxlbWVudDtcbiAgICAgICAgd2hpbGUgKG5leHQgPSBuZXh0Lm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICBpZiAobmV4dC5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IERpcmVjdGl2ZSwgSW5wdXQsIFRlbXBsYXRlUmVmLCBWaWV3Q29udGFpbmVyUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3V4SW5maW5pdGVTY3JvbGxMb2FkaW5nXSdcbn0pXG5leHBvcnQgY2xhc3MgSW5maW5pdGVTY3JvbGxMb2FkaW5nRGlyZWN0aXZlIHtcblxuICAgIEBJbnB1dCgndXhJbmZpbml0ZVNjcm9sbExvYWRpbmcnKVxuICAgIGdldCB2aXNpYmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaWJsZTtcbiAgICB9XG4gICAgc2V0IHZpc2libGUodmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLl92aXNpYmxlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl92aWV3Q29udGFpbmVyLmNyZWF0ZUVtYmVkZGVkVmlldyh0aGlzLl90ZW1wbGF0ZVJlZik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZpZXdDb250YWluZXIuY2xlYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdGhpcy5fdmlzaWJsZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHByaXZhdGUgX3Zpc2libGU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIF90ZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8YW55PixcbiAgICAgICAgcHJpdmF0ZSBfdmlld0NvbnRhaW5lcjogVmlld0NvbnRhaW5lclJlZikgeyB9XG59XG4iLCJcbmltcG9ydCB7IEFmdGVyQ29udGVudEluaXQsIENvbnRlbnRDaGlsZHJlbiwgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIElucHV0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSwgT25Jbml0LCBPdXRwdXQsIFF1ZXJ5TGlzdCwgU2ltcGxlQ2hhbmdlcyB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcy9CZWhhdmlvclN1YmplY3QnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMvT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBmcm9tIH0gZnJvbSAncnhqcy9vYnNlcnZhYmxlL2Zyb20nO1xuaW1wb3J0IHsgZnJvbUV2ZW50IH0gZnJvbSAncnhqcy9vYnNlcnZhYmxlL2Zyb21FdmVudCc7XG5pbXBvcnQgeyBvZiB9IGZyb20gJ3J4anMvb2JzZXJ2YWJsZS9vZic7XG5pbXBvcnQgeyBhdWRpdFRpbWUsIGNvbWJpbmVMYXRlc3QsIGZpbHRlciBhcyBmaWx0ZXJPcGVyYXRvciwgZmlyc3QsIHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzL1N1YmplY3QnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcy9TdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgSW5maW5pdGVTY3JvbGxMb2FkQnV0dG9uRGlyZWN0aXZlIH0gZnJvbSAnLi9pbmZpbml0ZS1zY3JvbGwtbG9hZC1idXR0b24uZGlyZWN0aXZlJztcbmltcG9ydCB7IEluZmluaXRlU2Nyb2xsTG9hZGluZ0RpcmVjdGl2ZSB9IGZyb20gJy4vaW5maW5pdGUtc2Nyb2xsLWxvYWRpbmcuZGlyZWN0aXZlJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbdXhJbmZpbml0ZVNjcm9sbF0nLFxuICAgIGV4cG9ydEFzOiAndXhJbmZpbml0ZVNjcm9sbCdcbn0pXG5leHBvcnQgY2xhc3MgSW5maW5pdGVTY3JvbGxEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIEFmdGVyQ29udGVudEluaXQsIE9uQ2hhbmdlcywgT25EZXN0cm95IHtcblxuICAgIEBJbnB1dCgndXhJbmZpbml0ZVNjcm9sbCcpIGxvYWQ6IEluZmluaXRlU2Nyb2xsTG9hZEZ1bmN0aW9uO1xuXG4gICAgQElucHV0KCdjb2xsZWN0aW9uJykgX2NvbGxlY3Rpb246IGFueVtdID0gW107XG4gICAgZ2V0IGNvbGxlY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2xsZWN0aW9uO1xuICAgIH1cbiAgICBzZXQgY29sbGVjdGlvbih2YWx1ZTogYW55W10pIHtcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uQ2hhbmdlLmVtaXQodmFsdWUpO1xuICAgICAgICB0aGlzLl9jb2xsZWN0aW9uID0gdmFsdWU7XG4gICAgfVxuXG5cbiAgICBASW5wdXQoKSBzZXQgc2Nyb2xsRWxlbWVudChlbGVtZW50OiBFbGVtZW50UmVmIHwgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5fc2Nyb2xsRWxlbWVudCA9IGVsZW1lbnQgaW5zdGFuY2VvZiBFbGVtZW50UmVmID8gZWxlbWVudCA6IG5ldyBFbGVtZW50UmVmKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIEBJbnB1dCgpIGVuYWJsZWQ6IGJvb2xlYW4gPSB0cnVlO1xuICAgIEBJbnB1dCgpIGZpbHRlcjogYW55O1xuICAgIEBJbnB1dCgpIGxvYWRPbkluaXQ6IGJvb2xlYW4gPSB0cnVlO1xuICAgIEBJbnB1dCgpIGxvYWRPblNjcm9sbDogYm9vbGVhbiA9IHRydWU7XG4gICAgQElucHV0KCkgcGFnZVNpemU6IG51bWJlciA9IDIwO1xuXG4gICAgQE91dHB1dCgpIGNvbGxlY3Rpb25DaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGFueVtdPigpO1xuXG4gICAgQE91dHB1dCgnbG9hZGluZycpXG4gICAgbG9hZGluZ0V2ZW50ID0gbmV3IEV2ZW50RW1pdHRlcjxJbmZpbml0ZVNjcm9sbExvYWRpbmdFdmVudD4oKTtcblxuICAgIEBPdXRwdXQoJ2xvYWRlZCcpXG4gICAgbG9hZGVkRXZlbnQgPSBuZXcgRXZlbnRFbWl0dGVyPEluZmluaXRlU2Nyb2xsTG9hZGVkRXZlbnQ+KCk7XG5cbiAgICBAT3V0cHV0KCdsb2FkRXJyb3InKVxuICAgIGxvYWRFcnJvckV2ZW50ID0gbmV3IEV2ZW50RW1pdHRlcjxJbmZpbml0ZVNjcm9sbExvYWRFcnJvckV2ZW50PigpO1xuXG4gICAgQENvbnRlbnRDaGlsZHJlbihJbmZpbml0ZVNjcm9sbExvYWRCdXR0b25EaXJlY3RpdmUpXG4gICAgcHJpdmF0ZSBfbG9hZEJ1dHRvblF1ZXJ5OiBRdWVyeUxpc3Q8SW5maW5pdGVTY3JvbGxMb2FkQnV0dG9uRGlyZWN0aXZlPjtcblxuICAgIEBDb250ZW50Q2hpbGRyZW4oSW5maW5pdGVTY3JvbGxMb2FkaW5nRGlyZWN0aXZlKVxuICAgIHByaXZhdGUgX2xvYWRpbmdJbmRpY2F0b3JRdWVyeTogUXVlcnlMaXN0PEluZmluaXRlU2Nyb2xsTG9hZGluZ0RpcmVjdGl2ZT47XG5cbiAgICBwcml2YXRlIF9wYWdlczogYW55W11bXTtcbiAgICBwcml2YXRlIF9uZXh0UGFnZU51bSA9IDA7XG4gICAgcHJpdmF0ZSBfZG9tT2JzZXJ2ZXI6IE11dGF0aW9uT2JzZXJ2ZXI7XG4gICAgcHJpdmF0ZSBfc2Nyb2xsRXZlbnRTdWI6IFN1YnNjcmlwdGlvbjtcbiAgICBwcml2YXRlIF91cGRhdGVSZXF1ZXN0cyA9IG5ldyBTdWJqZWN0PEluZmluaXRlU2Nyb2xsUmVxdWVzdD4oKTtcblxuICAgIHByaXZhdGUgX2lzTG9hZGluZyA9IG5ldyBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4oZmFsc2UpO1xuICAgIHByaXZhdGUgX2lzRXhoYXVzdGVkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPihmYWxzZSk7XG4gICAgcHJpdmF0ZSBfbG9hZEJ1dHRvbkVuYWJsZWQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+KGZhbHNlKTtcbiAgICBwcml2YXRlIF9jYW5Mb2FkTWFudWFsbHk6IE9ic2VydmFibGU8Ym9vbGVhbj47XG5cbiAgICBwcml2YXRlIF9zY3JvbGxFbGVtZW50OiBFbGVtZW50UmVmO1xuICAgIHByaXZhdGUgX3N1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbltdID0gW107XG4gICAgcHJpdmF0ZSBfbG9hZEJ1dHRvblN1YnNjcmlwdGlvbnM6IFN1YnNjcmlwdGlvbltdID0gW107XG4gICAgcHJpdmF0ZSBfb25EZXN0cm95ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX2VsZW1lbnQ6IEVsZW1lbnRSZWYpIHtcbiAgICAgICAgdGhpcy5fY2FuTG9hZE1hbnVhbGx5ID0gdGhpcy5faXNMb2FkaW5nLnBpcGUoY29tYmluZUxhdGVzdChcbiAgICAgICAgICAgIHRoaXMuX2lzRXhoYXVzdGVkLFxuICAgICAgICAgICAgdGhpcy5fbG9hZEJ1dHRvbkVuYWJsZWQsXG4gICAgICAgICAgICAoaXNMb2FkaW5nLCBpc0V4aGF1c3RlZCwgbG9hZEJ1dHRvbkVuYWJsZWQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIWlzTG9hZGluZyAmJiAhaXNFeGhhdXN0ZWQgJiYgbG9hZEJ1dHRvbkVuYWJsZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICkpO1xuICAgIH1cblxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICBpZiAoIXRoaXMuX3Njcm9sbEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbEVsZW1lbnQgPSB0aGlzLl9lbGVtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbG9hZEJ1dHRvbkVuYWJsZWQubmV4dCghdGhpcy5sb2FkT25TY3JvbGwpO1xuICAgIH1cblxuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcblxuICAgICAgICAvLyBUaGVyZSBhcmUgdHdvIGtpbmRzIG9mIHVwZGF0ZSByZXF1ZXN0czogY2hlY2sgYW5kIGxvYWQuXG4gICAgICAgIC8vIENoZWNrIHJlcXVlc3RzIGFyZSB0aHJvdHRsZWQgYW5kIHdpbGwgb25seSBjYXVzZSBhbiB1cGRhdGUgaWYgbW9yZSBkYXRhIGlzIHJlcXVpcmVkXG4gICAgICAgIC8vIHRvIGZpbGwgdGhlIHNjcm9sbGluZyB2aWV3LCBhbmQgaXQgaXNuJ3QgYWxyZWFkeSBsb2FkaW5nIHNvbWUuXG4gICAgICAgIC8vIExvYWQgcmVxdWVzdHMgYXJlIG5vdCB0aHJvdHRsZWQgYW5kIGFsd2F5cyByZXF1ZXN0IGEgcGFnZSBvZiBkYXRhLlxuICAgICAgICB0aGlzLl91cGRhdGVSZXF1ZXN0cy5waXBlKGZpbHRlck9wZXJhdG9yKHJlcXVlc3QgPT4gcmVxdWVzdC5jaGVjayksIGF1ZGl0VGltZSgyMDApLCB0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSkuc3Vic2NyaWJlKHRoaXMuZG9SZXF1ZXN0LmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLl91cGRhdGVSZXF1ZXN0cy5waXBlKGZpbHRlck9wZXJhdG9yKHJlcXVlc3QgPT4gIXJlcXVlc3QuY2hlY2spLCB0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSkuc3Vic2NyaWJlKHRoaXMuZG9SZXF1ZXN0LmJpbmQodGhpcykpO1xuXG4gICAgICAgIGlmICh0aGlzLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIC8vIFN1YnNjcmliZSB0byBzY3JvbGwgZXZlbnRzIGFuZCBET00gY2hhbmdlcy5cbiAgICAgICAgICAgIHRoaXMuYXR0YWNoRXZlbnRIYW5kbGVycygpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29ubmVjdCB0aGUgTG9hZCBNb3JlIGJ1dHRvbiB2aXNpYmxlIHN0YXRlLlxuICAgICAgICB0aGlzLl9jYW5Mb2FkTWFudWFsbHkucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSkuc3Vic2NyaWJlKGNhbkxvYWQgPT4ge1xuICAgICAgICAgICAgdGhpcy5fbG9hZEJ1dHRvblF1ZXJ5LmZvckVhY2gobG9hZEJ1dHRvbiA9PiB7XG4gICAgICAgICAgICAgICAgbG9hZEJ1dHRvbi52aXNpYmxlID0gY2FuTG9hZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBDb25uZWN0IHRoZSBsb2FkaW5nIGluZGljYXRvciB2aXNpYmxlIHN0YXRlLlxuICAgICAgICB0aGlzLl9pc0xvYWRpbmcucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSkuc3Vic2NyaWJlKGlzTG9hZGluZyA9PiB7XG4gICAgICAgICAgICB0aGlzLl9sb2FkaW5nSW5kaWNhdG9yUXVlcnkuZm9yRWFjaChsb2FkaW5nID0+IHtcbiAgICAgICAgICAgICAgICBsb2FkaW5nLnZpc2libGUgPSBpc0xvYWRpbmc7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gTGluayB0aGUgTG9hZCBNb3JlIGJ1dHRvbiBjbGljayBldmVudCB0byB0cmlnZ2VyIGFuIHVwZGF0ZS5cbiAgICAgICAgdGhpcy5hdHRhY2hMb2FkQnV0dG9uRXZlbnRzKCk7XG4gICAgICAgIHRoaXMuX2xvYWRCdXR0b25RdWVyeS5jaGFuZ2VzLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmF0dGFjaExvYWRCdXR0b25FdmVudHMoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gSW5pdGlhbCB1cGRhdGUuXG4gICAgICAgIGlmICh0aGlzLmxvYWRPbkluaXQpIHtcbiAgICAgICAgICAgIHRoaXMubG9hZE5leHRQYWdlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XG4gICAgICAgIGxldCBjaGVjayA9IHRydWU7XG5cbiAgICAgICAgaWYgKGNoYW5nZXMuZW5hYmxlZCAmJiBjaGFuZ2VzLmVuYWJsZWQuY3VycmVudFZhbHVlICE9PSBjaGFuZ2VzLmVuYWJsZWQucHJldmlvdXNWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKGNoYW5nZXMuZW5hYmxlZC5jdXJyZW50VmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmF0dGFjaEV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgY2hlY2sgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXRhY2hFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5lbmFibGVkKSB7XG4gICAgICAgICAgICBpZiAoY2hhbmdlcy5maWx0ZXIgJiYgY2hhbmdlcy5maWx0ZXIuY3VycmVudFZhbHVlICE9PSBjaGFuZ2VzLmZpbHRlci5wcmV2aW91c1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgICAgICAgIGNoZWNrID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjaGFuZ2VzLmxvYWRPblNjcm9sbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvYWRCdXR0b25FbmFibGVkLm5leHQoXG4gICAgICAgICAgICAgICAgICAgICFjaGFuZ2VzLmxvYWRPblNjcm9sbC5jdXJyZW50VmFsdWVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY2hhbmdlcy5wYWdlU2l6ZSAmJiBjaGFuZ2VzLnBhZ2VTaXplLmN1cnJlbnRWYWx1ZSAhPT0gY2hhbmdlcy5wYWdlU2l6ZS5wcmV2aW91c1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgICAgICAgIGNoZWNrID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVJlcXVlc3RzLm5leHQoe1xuICAgICAgICAgICAgICAgIGNoZWNrOiBjaGVjayxcbiAgICAgICAgICAgICAgICBwYWdlTnVtYmVyOiB0aGlzLl9uZXh0UGFnZU51bSxcbiAgICAgICAgICAgICAgICBwYWdlU2l6ZTogdGhpcy5wYWdlU2l6ZSxcbiAgICAgICAgICAgICAgICBmaWx0ZXI6IHRoaXMuZmlsdGVyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRldGFjaEV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgdGhpcy5fb25EZXN0cm95Lm5leHQoKTtcbiAgICAgICAgdGhpcy5fb25EZXN0cm95LmNvbXBsZXRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVxdWVzdCBhbiBhZGRpdGlvbmFsIHBhZ2Ugb2YgZGF0YS5cbiAgICAgKi9cbiAgICBsb2FkTmV4dFBhZ2UoKSB7XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl91cGRhdGVSZXF1ZXN0cy5uZXh0KHtcbiAgICAgICAgICAgIGNoZWNrOiBmYWxzZSxcbiAgICAgICAgICAgIHBhZ2VOdW1iZXI6IHRoaXMuX25leHRQYWdlTnVtLFxuICAgICAgICAgICAgcGFnZVNpemU6IHRoaXMucGFnZVNpemUsXG4gICAgICAgICAgICBmaWx0ZXI6IHRoaXMuZmlsdGVyXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcXVlc3QgYSBjaGVjayBmb3Igd2hldGhlciBhbiBhZGRpdGlvbmFsIHBhZ2Ugb2YgZGF0YSBpcyByZXF1aXJlZC4gVGhpcyBpcyB0aHJvdHRsZWQuXG4gICAgICovXG4gICAgY2hlY2soKSB7XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl91cGRhdGVSZXF1ZXN0cy5uZXh0KHtcbiAgICAgICAgICAgIGNoZWNrOiB0cnVlLFxuICAgICAgICAgICAgcGFnZU51bWJlcjogdGhpcy5fbmV4dFBhZ2VOdW0sXG4gICAgICAgICAgICBwYWdlU2l6ZTogdGhpcy5wYWdlU2l6ZSxcbiAgICAgICAgICAgIGZpbHRlcjogdGhpcy5maWx0ZXJcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgdGhlIGNvbGxlY3Rpb24uIEZ1dHVyZSByZXF1ZXN0cyB3aWxsIGxvYWQgZnJvbSBwYWdlIDAuXG4gICAgICovXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXNldCB0aGUgcGFnZSBjb3VudGVyLlxuICAgICAgICB0aGlzLl9uZXh0UGFnZU51bSA9IDA7XG5cbiAgICAgICAgdGhpcy5fcGFnZXMgPSBbXTtcblxuICAgICAgICAvLyBDbGVhciB0aGUgY29sbGVjdGlvbiAod2l0aG91dCBjaGFuZ2luZyB0aGUgcmVmZXJlbmNlKS5cbiAgICAgICAgaWYgKHRoaXMuY29sbGVjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5jb2xsZWN0aW9uLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXNldCB0aGUgZXhoYXVzdGVkIGZsYWcsIGFsbG93aW5nIHRoZSBMb2FkIE1vcmUgYnV0dG9uIHRvIGFwcGVhci5cbiAgICAgICAgdGhpcy5faXNFeGhhdXN0ZWQubmV4dChmYWxzZSk7XG5cbiAgICAgICAgLy8gQ2FuY2VsIGFueSBwZW5kaW5nIHJlcXVlc3RzXG4gICAgICAgIGlmICh0aGlzLl9zdWJzY3JpcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zLmZvckVhY2gocmVxdWVzdCA9PiByZXF1ZXN0LnVuc3Vic2NyaWJlKCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVsb2FkIHRoZSBkYXRhIHdpdGhvdXQgY2xlYXJpbmcgdGhlIHZpZXcuXG4gICAgICovXG4gICAgcmVsb2FkKCkge1xuICAgICAgICB0aGlzLl9wYWdlcy5mb3JFYWNoKChwYWdlLCBpKSA9PiB0aGlzLnJlbG9hZFBhZ2UoaSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbG9hZCB0aGUgZGF0YSBpbiBhIHNwZWNpZmljIHBhZ2Ugd2l0aG91dCBjbGVhcmluZyB0aGUgdmlldy5cbiAgICAgKiBAcGFyYW0gcGFnZU51bSBQYWdlIG51bWJlclxuICAgICAqL1xuICAgIHJlbG9hZFBhZ2UocGFnZU51bTogbnVtYmVyKSB7XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl91cGRhdGVSZXF1ZXN0cy5uZXh0KHtcbiAgICAgICAgICAgIGNoZWNrOiBmYWxzZSxcbiAgICAgICAgICAgIHBhZ2VOdW1iZXI6IHBhZ2VOdW0sXG4gICAgICAgICAgICBwYWdlU2l6ZTogdGhpcy5wYWdlU2l6ZSxcbiAgICAgICAgICAgIGZpbHRlcjogdGhpcy5maWx0ZXIsXG4gICAgICAgICAgICByZWxvYWQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXR0YWNoIHNjcm9sbCBldmVudCBoYW5kbGVyIGFuZCBET00gb2JzZXJ2ZXIuXG4gICAgICovXG4gICAgcHJpdmF0ZSBhdHRhY2hFdmVudEhhbmRsZXJzKCkge1xuXG4gICAgICAgIC8vIGlmIHRoZSBzY3JvbGxFbGVtZW50IGlzIGRvY3VtZW50RWxlbWVudCB3ZSBtdXN0IHdhdGNoIGZvciBhIHNjcm9sbCBldmVudCBvbiB0aGUgZG9jdW1lbnRcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5fc2Nyb2xsRWxlbWVudC5uYXRpdmVFbGVtZW50IGluc3RhbmNlb2YgSFRNTEh0bWxFbGVtZW50ID8gZG9jdW1lbnQgOiB0aGlzLl9zY3JvbGxFbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG5cbiAgICAgICAgLy8gU3Vic2NyaWJlIHRvIHRoZSBzY3JvbGwgZXZlbnQgb24gdGhlIHRhcmdldCBlbGVtZW50LlxuICAgICAgICB0aGlzLl9zY3JvbGxFdmVudFN1YiA9IGZyb21FdmVudCh0YXJnZXQsICdzY3JvbGwnKS5zdWJzY3JpYmUodGhpcy5jaGVjay5iaW5kKHRoaXMpKTtcblxuICAgICAgICAvLyBTdWJzY3JpYmUgdG8gY2hpbGQgRE9NIGNoYW5nZXMuIFRoZSBtYWluIGVmZmVjdCBvZiB0aGlzIGlzIHRvIGNoZWNrIHdoZXRoZXIgZXZlbiBtb3JlIGRhdGEgaXNcbiAgICAgICAgLy8gcmVxdWlyZWQgYWZ0ZXIgdGhlIGluaXRpYWwgbG9hZC5cbiAgICAgICAgdGhpcy5fZG9tT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzLmNoZWNrLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLl9kb21PYnNlcnZlci5vYnNlcnZlKHRoaXMuX3Njcm9sbEVsZW1lbnQubmF0aXZlRWxlbWVudCwge1xuICAgICAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgICAgICAgc3VidHJlZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRhY2ggc2Nyb2xsIGV2ZW50IGhhbmRsZXIgYW5kIERPTSBvYnNlcnZlci5cbiAgICAgKi9cbiAgICBwcml2YXRlIGRldGFjaEV2ZW50SGFuZGxlcnMoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zY3JvbGxFdmVudFN1Yikge1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsRXZlbnRTdWIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbEV2ZW50U3ViID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9kb21PYnNlcnZlcikge1xuICAgICAgICAgICAgdGhpcy5fZG9tT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgdGhpcy5fZG9tT2JzZXJ2ZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFueSBleGlzdGluZyBldmVudCBzdWJzY3JpcHRpb25zIGZvciB0aGUgbG9hZCBidXR0b24gYGxvYWRgIGV2ZW50LCB0aGVuIGF0dGFjaCBzdWJzY3JpcHRpb25zXG4gICAgICogZm9yIGFueSBpbiB0aGUgcXVlcnkuXG4gICAgICovXG4gICAgcHJpdmF0ZSBhdHRhY2hMb2FkQnV0dG9uRXZlbnRzKCkge1xuICAgICAgICB0aGlzLl9sb2FkQnV0dG9uU3Vic2NyaXB0aW9ucy5mb3JFYWNoKHMgPT4gcy51bnN1YnNjcmliZSgpKTtcbiAgICAgICAgdGhpcy5fbG9hZEJ1dHRvblN1YnNjcmlwdGlvbnMgPSB0aGlzLl9sb2FkQnV0dG9uUXVlcnkubWFwKFxuICAgICAgICAgICAgbG9hZEJ1dHRvbiA9PiBsb2FkQnV0dG9uLmxvYWQuc3Vic2NyaWJlKHRoaXMubG9hZE5leHRQYWdlLmJpbmQodGhpcykpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29uZGl0aW9uYWxseSBsb2FkcyBhIHBhZ2UgaW50byB0aGUgY29sbGVjdGlvbiBiYXNlZCBvbiBkaXJlY3RpdmUgc3RhdGUgYW5kIHJlcXVlc3QgcGFyYW1ldGVycy5cbiAgICAgKi9cbiAgICBwcml2YXRlIGRvUmVxdWVzdChyZXF1ZXN0OiBJbmZpbml0ZVNjcm9sbFJlcXVlc3QpIHtcblxuICAgICAgICAvLyBMb2FkIGEgbmV3IHBhZ2UgaWYgdGhlIHNjcm9sbCBwb3NpdGlvbiBpcyBiZXlvbmQgdGhlIHRocmVzaGhvbGQgYW5kIGlmIHRoZSBjbGllbnQgY29kZSBkaWQgbm90XG4gICAgICAgIC8vIGNhbmNlbC5cbiAgICAgICAgaWYgKHRoaXMubmVlZHNEYXRhKHJlcXVlc3QpICYmIHRoaXMuYmVnaW5Mb2FkaW5nKHJlcXVlc3QpKSB7XG5cbiAgICAgICAgICAgIC8vIEludm9rZSB0aGUgY2FsbGJhY2sgbG9hZCBmdW5jdGlvbiwgd2hpY2ggcmV0dXJucyBhIHByb21vc2Ugb3IgcGxhaW4gZGF0YS5cbiAgICAgICAgICAgIGNvbnN0IGxvYWRSZXN1bHQgPSB0aGlzLmxvYWQocmVxdWVzdC5wYWdlTnVtYmVyLCByZXF1ZXN0LnBhZ2VTaXplLCByZXF1ZXN0LmZpbHRlcik7XG5cbiAgICAgICAgICAgIGNvbnN0IG9ic2VydmFibGUgPSBBcnJheS5pc0FycmF5KGxvYWRSZXN1bHQpID8gb2YobG9hZFJlc3VsdCkgOiBmcm9tPGFueVtdPihsb2FkUmVzdWx0KTtcblxuICAgICAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gb2JzZXJ2YWJsZS5waXBlKGZpcnN0KCkpLnN1YnNjcmliZShcbiAgICAgICAgICAgICAgICBpdGVtcyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBwYXJhbWV0ZXJzIGhhdmUgbm90IGNoYW5nZWQgc2luY2UgdGhlIGxvYWQgc3RhcnRlZDtcbiAgICAgICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGRpc2NhcmQgdGhlIHJlc3VsdHMuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LmZpbHRlciA9PT0gdGhpcy5maWx0ZXIgJiYgcmVxdWVzdC5wYWdlU2l6ZSA9PT0gdGhpcy5wYWdlU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW1zICYmIGl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0UGFnZUl0ZW1zKHJlcXVlc3QucGFnZU51bWJlciwgaXRlbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFbWl0IHRoZSBsb2FkZWQgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kTG9hZGluZyhyZXF1ZXN0LCBpdGVtcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlYXNvbiA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVtaXQgdGhlIGxvYWRFcnJvciBldmVudFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZExvYWRpbmdXaXRoRXJyb3IocmVxdWVzdCwgcmVhc29uKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoaXMgcmVxdWVzdCBmcm9tIHRoZSBsaXN0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMgPSB0aGlzLl9zdWJzY3JpcHRpb25zLmZpbHRlcihzID0+IHMgIT09IHN1YnNjcmlwdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gYWRkIHRoZSBzdWJzY3JpcHRpb24gdG8gdGhlIGxpc3Qgb2YgcmVxdWVzdHNcbiAgICAgICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMucHVzaChzdWJzY3JpcHRpb24pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSByZXF1ZXN0IHNob3VsZCBiZSBmdWxmaWxsZWQuXG4gICAgICovXG4gICAgcHJpdmF0ZSBuZWVkc0RhdGEocmVxdWVzdDogSW5maW5pdGVTY3JvbGxSZXF1ZXN0KTogYm9vbGVhbiB7XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBbHdheXMgbG9hZCBmb3IgYSBsb2FkIHJlcXVlc3RcbiAgICAgICAgaWYgKCFyZXF1ZXN0LmNoZWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElnbm9yZSBhIGNoZWNrIHJlcXVlc3Qgd2hlbiB0aGUgZW5kIG9mIGRhdGEgaGFzIGJlZW4gZGV0ZWN0ZWQsIG9yIGlmIGRhdGEgaXMgY3VycmVudGx5IGxvYWRpbmcuXG4gICAgICAgIGlmICh0aGlzLl9pc0V4aGF1c3RlZC5nZXRWYWx1ZSgpIHx8IHRoaXMuX2lzTG9hZGluZy5nZXRWYWx1ZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBMb2FkIGlmIHRoZSByZW1haW5pbmcgc2Nyb2xsIGFyZWEgaXMgPD0gdGhlIGVsZW1lbnQgaGVpZ2h0LlxuICAgICAgICBpZiAodGhpcy5fc2Nyb2xsRWxlbWVudCAmJiB0aGlzLmxvYWRPblNjcm9sbCkge1xuXG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gPEhUTUxFbGVtZW50PnRoaXMuX3Njcm9sbEVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgICAgIGNvbnN0IHJlbWFpbmluZ1Njcm9sbCA9XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zY3JvbGxIZWlnaHQgLVxuICAgICAgICAgICAgICAgIChlbGVtZW50LnNjcm9sbFRvcCArIGVsZW1lbnQuY2xpZW50SGVpZ2h0KTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlbWFpbmluZ1Njcm9sbCA8PSBlbGVtZW50LmNsaWVudEhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHN0YXRlIGZvciB0aGUgYmVnaW5uaW5nIG9mIGEgbG9hZC4gUmV0dXJucyBmYWxzZSBpZiB0aGUgYGxvYWRpbmdgIGV2ZW50IHdhcyBjYW5jZWxsZWQuXG4gICAgICovXG4gICAgcHJpdmF0ZSBiZWdpbkxvYWRpbmcocmVxdWVzdDogSW5maW5pdGVTY3JvbGxSZXF1ZXN0KTogYm9vbGVhbiB7XG5cbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgSW5maW5pdGVTY3JvbGxMb2FkaW5nRXZlbnQoXG4gICAgICAgICAgICByZXF1ZXN0LnBhZ2VOdW1iZXIsXG4gICAgICAgICAgICByZXF1ZXN0LnBhZ2VTaXplLFxuICAgICAgICAgICAgcmVxdWVzdC5maWx0ZXJcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5sb2FkaW5nRXZlbnQuZW1pdChldmVudCk7XG5cbiAgICAgICAgdGhpcy5faXNMb2FkaW5nLm5leHQoIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQoKSk7XG5cbiAgICAgICAgcmV0dXJuICFldmVudC5kZWZhdWx0UHJldmVudGVkKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzZXRQYWdlSXRlbXMocGFnZU51bTogbnVtYmVyLCBpdGVtczogYW55W10pIHtcbiAgICAgICAgdGhpcy5fcGFnZXNbcGFnZU51bV0gPSBpdGVtcztcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uID0gdGhpcy5fcGFnZXMucmVkdWNlKChwcmV2aW91cywgY3VycmVudCkgPT4gcHJldmlvdXMuY29uY2F0KGN1cnJlbnQpLCBbXSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBzdGF0ZSBmcm9tIGEgc3VjY2Vzc2Z1bCBsb2FkLiBSYWlzZXMgdGhlIGBsb2FkZWRgIGV2ZW50LlxuICAgICAqL1xuICAgIHByaXZhdGUgZW5kTG9hZGluZyhyZXF1ZXN0OiBJbmZpbml0ZVNjcm9sbFJlcXVlc3QsIGRhdGE/OiBhbnkpIHtcbiAgICAgICAgdGhpcy5faXNMb2FkaW5nLm5leHQoZmFsc2UpO1xuXG4gICAgICAgIGNvbnN0IGlzRXhoYXVzdGVkID0gISEoZGF0YSAmJiBkYXRhLmxlbmd0aCA8IHRoaXMucGFnZVNpemUpO1xuICAgICAgICB0aGlzLl9pc0V4aGF1c3RlZC5uZXh0KGlzRXhoYXVzdGVkKTtcblxuICAgICAgICB0aGlzLmxvYWRlZEV2ZW50LmVtaXQoXG4gICAgICAgICAgICBuZXcgSW5maW5pdGVTY3JvbGxMb2FkZWRFdmVudChcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnBhZ2VOdW1iZXIsXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5wYWdlU2l6ZSxcbiAgICAgICAgICAgICAgICByZXF1ZXN0LmZpbHRlcixcbiAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgIGlzRXhoYXVzdGVkXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKCFyZXF1ZXN0LnJlbG9hZCkge1xuICAgICAgICAgICAgdGhpcy5fbmV4dFBhZ2VOdW0gKz0gMTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgc3RhdGUgZnJvbSBhIGZhaWxlZCBsb2FkLiBSYWlzZXMgdGhlIGBsb2FkRXJyb3JgIGV2ZW50LlxuICAgICAqL1xuICAgIHByaXZhdGUgZW5kTG9hZGluZ1dpdGhFcnJvcihyZXF1ZXN0OiBJbmZpbml0ZVNjcm9sbFJlcXVlc3QsIGVycm9yOiBhbnkpIHtcbiAgICAgICAgdGhpcy5faXNMb2FkaW5nLm5leHQoZmFsc2UpO1xuXG4gICAgICAgIHRoaXMubG9hZEVycm9yRXZlbnQuZW1pdChcbiAgICAgICAgICAgIG5ldyBJbmZpbml0ZVNjcm9sbExvYWRFcnJvckV2ZW50KFxuICAgICAgICAgICAgICAgIHJlcXVlc3QucGFnZU51bWJlcixcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnBhZ2VTaXplLFxuICAgICAgICAgICAgICAgIHJlcXVlc3QuZmlsdGVyLFxuICAgICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRoZSBpbnRlcm5hbCBkYXRhIGFzc29jaWF0ZWQgd2l0aCBhIGxvYWQvY2hlY2sgcmVxdWVzdC5cbiAqL1xuY2xhc3MgSW5maW5pdGVTY3JvbGxSZXF1ZXN0IHtcbiAgICBjaGVjazogYm9vbGVhbjtcbiAgICBwYWdlTnVtYmVyOiBudW1iZXI7XG4gICAgcGFnZVNpemU6IG51bWJlcjtcbiAgICBmaWx0ZXI6IGFueTtcbiAgICByZWxvYWQ/OiBib29sZWFuO1xufVxuXG5leHBvcnQgdHlwZSBJbmZpbml0ZVNjcm9sbExvYWRGdW5jdGlvbiA9IChcbiAgICBwYWdlTnVtOiBudW1iZXIsXG4gICAgcGFnZVNpemU6IG51bWJlcixcbiAgICBmaWx0ZXI6IGFueVxuKSA9PiBhbnkgfCBQcm9taXNlPGFueT47XG5cbi8qKlxuICogRXZlbnQgcmFpc2VkIGJlZm9yZSB0aGUgYGxvYWRpbmdgIGZ1bmN0aW9uIGlzIGNhbGxlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIEluZmluaXRlU2Nyb2xsTG9hZGluZ0V2ZW50IHtcbiAgICBwcml2YXRlIF9kZWZhdWx0UHJldmVudGVkID0gZmFsc2U7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBpbmRleCBvZiB0aGUgcmVxdWVzdGVkIHBhZ2UsIHN0YXJ0aW5nIGZyb20gMC5cbiAgICAgICAgICovXG4gICAgICAgIHB1YmxpYyBwYWdlTnVtYmVyOiBudW1iZXIsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbnVtYmVyIG9mIGl0ZW1zIHJlcXVlc3RlZC5cbiAgICAgICAgICovXG4gICAgICAgIHB1YmxpYyBwYWdlU2l6ZTogbnVtYmVyLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGZpbHRlciBkZXRhaWxzIGFzIHByb3ZpZGVkIHZpYSB0aGUgYGZpbHRlcmAgYmluZGluZy5cbiAgICAgICAgICovXG4gICAgICAgIHB1YmxpYyBmaWx0ZXI6IGFueVxuICAgICkgeyB9XG5cbiAgICAvKipcbiAgICAgKiBQcmV2ZW50cyB0aGUgZGVmYXVsdCBiZWhhdmlvdXIgb2YgdGhlIGBsb2FkaW5nYCBldmVudCAobG9hZGluZyBmdW5jdGlvbiB3aWxsIG5vdCBiZSBjYWxsZWQpLlxuICAgICAqL1xuICAgIHByZXZlbnREZWZhdWx0KCkge1xuICAgICAgICB0aGlzLl9kZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBkZWZhdWx0UHJldmVudGVkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmYXVsdFByZXZlbnRlZDtcbiAgICB9XG59XG5cbi8qKlxuICogRXZlbnQgcmFpc2VkIHdoZW4gdGhlIGxvYWRpbmcgZnVuY3Rpb24gcmVzdWx0IGhhcyBiZWVuIHJlc29sdmVkIGFuZCBhZGRlZCB0byB0aGUgY29sbGVjdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIEluZmluaXRlU2Nyb2xsTG9hZGVkRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGluZGV4IG9mIHRoZSByZXF1ZXN0ZWQgcGFnZSwgc3RhcnRpbmcgZnJvbSAwLlxuICAgICAgICAgKi9cbiAgICAgICAgcHVibGljIHBhZ2VOdW1iZXI6IG51bWJlcixcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBudW1iZXIgb2YgaXRlbXMgcmVxdWVzdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgcHVibGljIHBhZ2VTaXplOiBudW1iZXIsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZmlsdGVyIGRldGFpbHMgYXMgcHJvdmlkZWQgdmlhIHRoZSBgZmlsdGVyYCBiaW5kaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgcHVibGljIGZpbHRlcjogYW55LFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHJlc3VsdCBvZiB0aGUgcHJvbWlzZSByZXR1cm5lZCBmcm9tIHRoZSBsb2FkaW5nIGZ1bmN0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgcHVibGljIGRhdGE6IGFueSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRydWUgaWYgdGhlIGRhdGEgaXMgY29uc2lkZXJlZCBleGhhdXN0ZWQgKG51bWJlciBvZiBpdGVtcyByZXR1cm5lZCBsZXNzIHRoYW4gYHBhZ2VTaXplYCkuXG4gICAgICAgICAqL1xuICAgICAgICBwdWJsaWMgZXhoYXVzdGVkOiBib29sZWFuXG4gICAgKSB7IH1cbn1cblxuLyoqXG4gKiBFdmVudCByYWlzZWQgaWYgdGhlIGxvYWRpbmcgZnVuY3Rpb24gcmV0dXJucyBhIHJlamVjdGVkIHByb21pc2UuXG4gKi9cbmV4cG9ydCBjbGFzcyBJbmZpbml0ZVNjcm9sbExvYWRFcnJvckV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBpbmRleCBvZiB0aGUgcmVxdWVzdGVkIHBhZ2UsIHN0YXJ0aW5nIGZyb20gMC5cbiAgICAgICAgICovXG4gICAgICAgIHB1YmxpYyBwYWdlTnVtYmVyOiBudW1iZXIsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbnVtYmVyIG9mIGl0ZW1zIHJlcXVlc3RlZC5cbiAgICAgICAgICovXG4gICAgICAgIHB1YmxpYyBwYWdlU2l6ZTogbnVtYmVyLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGZpbHRlciBkZXRhaWxzIGFzIHByb3ZpZGVkIHZpYSB0aGUgYGZpbHRlcmAgYmluZGluZy5cbiAgICAgICAgICovXG4gICAgICAgIHB1YmxpYyBmaWx0ZXI6IGFueSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBvYmplY3QgcHJvdmlkZWQgd2hlbiByZWplY3RpbmcgdGhlIHByb21pc2UuXG4gICAgICAgICAqL1xuICAgICAgICBwdWJsaWMgZXJyb3I6IGFueVxuICAgICkgeyB9XG59XG4iLCJpbXBvcnQgeyBJbmZpbml0ZVNjcm9sbExvYWRCdXR0b25EaXJlY3RpdmUgfSBmcm9tICcuL2luZmluaXRlLXNjcm9sbC1sb2FkLWJ1dHRvbi5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgSW5maW5pdGVTY3JvbGxMb2FkaW5nRGlyZWN0aXZlIH0gZnJvbSAnLi9pbmZpbml0ZS1zY3JvbGwtbG9hZGluZy5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgSW5maW5pdGVTY3JvbGxEaXJlY3RpdmUgfSBmcm9tICcuL2luZmluaXRlLXNjcm9sbC5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIEluZmluaXRlU2Nyb2xsRGlyZWN0aXZlLFxuICAgICAgICBJbmZpbml0ZVNjcm9sbExvYWRCdXR0b25EaXJlY3RpdmUsXG4gICAgICAgIEluZmluaXRlU2Nyb2xsTG9hZGluZ0RpcmVjdGl2ZVxuICAgIF0sXG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIEluZmluaXRlU2Nyb2xsRGlyZWN0aXZlLFxuICAgICAgICBJbmZpbml0ZVNjcm9sbExvYWRCdXR0b25EaXJlY3RpdmUsXG4gICAgICAgIEluZmluaXRlU2Nyb2xsTG9hZGluZ0RpcmVjdGl2ZVxuICAgIF0sXG4gICAgcHJvdmlkZXJzOiBbXSxcbn0pXG5leHBvcnQgY2xhc3MgSW5maW5pdGVTY3JvbGxNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBTY3JvbGxJbnRvVmlld1NlcnZpY2Uge1xuXG4gICAgc2Nyb2xsSW50b1ZpZXcoZWxlbTogSFRNTEVsZW1lbnQsIHNjcm9sbFBhcmVudDogSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0VG9wID0gKGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wICsgc2Nyb2xsUGFyZW50LnNjcm9sbFRvcCkgLSBzY3JvbGxQYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO1xuICAgICAgICBpZiAob2Zmc2V0VG9wIDwgc2Nyb2xsUGFyZW50LnNjcm9sbFRvcCkge1xuICAgICAgICAgICAgc2Nyb2xsUGFyZW50LnNjcm9sbFRvcCA9IG9mZnNldFRvcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldEJvdHRvbSA9IG9mZnNldFRvcCArIGVsZW0ub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgaWYgKG9mZnNldEJvdHRvbSA+IChzY3JvbGxQYXJlbnQuc2Nyb2xsVG9wICsgc2Nyb2xsUGFyZW50LmNsaWVudEhlaWdodCkpIHtcbiAgICAgICAgICAgICAgICBzY3JvbGxQYXJlbnQuc2Nyb2xsVG9wID0gb2Zmc2V0Qm90dG9tIC0gc2Nyb2xsUGFyZW50LmNsaWVudEhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIElucHV0LCBPbkNoYW5nZXMgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFNjcm9sbEludG9WaWV3U2VydmljZSB9IGZyb20gJy4vc2Nyb2xsLWludG8tdmlldy5zZXJ2aWNlJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbdXhTY3JvbGxJbnRvVmlld0lmXScsXG4gICAgcHJvdmlkZXJzOiBbU2Nyb2xsSW50b1ZpZXdTZXJ2aWNlXVxuIH0pXG5leHBvcnQgY2xhc3MgU2Nyb2xsSW50b1ZpZXdJZkRpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uQ2hhbmdlcyB7XG5cbiAgICBASW5wdXQoJ3V4U2Nyb2xsSW50b1ZpZXdJZicpIGNvbmRpdGlvbiA9IGZhbHNlO1xuICAgIEBJbnB1dCgpIHNjcm9sbFBhcmVudDogSFRNTEVsZW1lbnQ7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9lbGVtZW50OiBFbGVtZW50UmVmLCBwcml2YXRlIF9zY3JvbGxJbnRvVmlld1NlcnZpY2U6IFNjcm9sbEludG9WaWV3U2VydmljZSkge31cblxuICAgIG5nT25DaGFuZ2VzKCkge1xuICAgICAgICBpZiAodGhpcy5jb25kaXRpb24pIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5fc2Nyb2xsSW50b1ZpZXdTZXJ2aWNlLnNjcm9sbEludG9WaWV3KHRoaXMuX2VsZW1lbnQubmF0aXZlRWxlbWVudCwgdGhpcy5zY3JvbGxQYXJlbnQpKTtcbiAgICAgICAgfVxuICAgIH1cbn0iLCJpbXBvcnQgeyBBZnRlclZpZXdJbml0LCBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3V4U2Nyb2xsSW50b1ZpZXddJ1xufSlcbmV4cG9ydCBjbGFzcyBTY3JvbGxJbnRvVmlld0RpcmVjdGl2ZSBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQge1xuXG4gICAgLyoqIEFsbG93IGEgY29uZGl0aW9uIGFyb3VuZCB3aGV0aGVyIG9yIG5vdCB0aGlzIHNob3VsZCBzY3JvbGwgaW50byB2aWV3ICovXG4gICAgQElucHV0KCkgdXhTY3JvbGxJbnRvVmlldzogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKiogQWxsb3cgdXNlciB0byBwcm92aWRlIHRoZSBicm93c2VyIHN1cHBvcnRlZCBvcHRpb25zICovXG4gICAgQElucHV0KCkgc2Nyb2xsSW50b1ZpZXdPcHRpb25zOiBTY3JvbGxJbnRvVmlld09wdGlvbnMgfCBib29sZWFuID0gdHJ1ZTtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYpIHsgfVxuXG4gICAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy51eFNjcm9sbEludG9WaWV3KSB7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuc2Nyb2xsSW50b1ZpZXcodGhpcy5zY3JvbGxJbnRvVmlld09wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxufSIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTY3JvbGxJbnRvVmlld0lmRGlyZWN0aXZlIH0gZnJvbSAnLi9zY3JvbGwtaW50by12aWV3LWlmLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBTY3JvbGxJbnRvVmlld0RpcmVjdGl2ZSB9IGZyb20gJy4vc2Nyb2xsLWludG8tdmlldy5kaXJlY3RpdmUnO1xuXG5cbkBOZ01vZHVsZSh7XG4gICAgZXhwb3J0czogW1Njcm9sbEludG9WaWV3SWZEaXJlY3RpdmUsIFNjcm9sbEludG9WaWV3RGlyZWN0aXZlXSxcbiAgICBkZWNsYXJhdGlvbnM6IFtTY3JvbGxJbnRvVmlld0lmRGlyZWN0aXZlLCBTY3JvbGxJbnRvVmlld0RpcmVjdGl2ZV1cbn0pXG5leHBvcnQgY2xhc3MgU2Nyb2xsTW9kdWxlIHsgfSIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgVHlwZWFoZWFkU2VydmljZSB9IGZyb20gJy4vdHlwZWFoZWFkLnNlcnZpY2UnO1xyXG5cclxuQERpcmVjdGl2ZSh7XHJcbiAgICBzZWxlY3RvcjogJ1t1eFR5cGVhaGVhZEhpZ2hsaWdodF0nXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBUeXBlYWhlYWRIaWdobGlnaHREaXJlY3RpdmUge1xyXG5cclxuICAgIEBJbnB1dCgndXhUeXBlYWhlYWRIaWdobGlnaHQnKVxyXG4gICAgc2V0IGhpZ2hsaWdodCh2YWx1ZTogYm9vbGVhbikge1xyXG4gICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9zZXJ2aWNlLmhpZ2hsaWdodGVkRWxlbWVudCQubmV4dCh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9zZXJ2aWNlOiBUeXBlYWhlYWRTZXJ2aWNlLCBwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmKSB7fVxyXG59XHJcbiIsImltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSW5maW5pdGVTY3JvbGxNb2R1bGUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL2luZmluaXRlLXNjcm9sbC9pbmRleCc7XG5pbXBvcnQgeyBTY3JvbGxNb2R1bGUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL3Njcm9sbC9pbmRleCc7XG5pbXBvcnQgeyBUeXBlYWhlYWRIaWdobGlnaHREaXJlY3RpdmUgfSBmcm9tICcuL3R5cGVhaGVhZC1oaWdobGlnaHQuZGlyZWN0aXZlJztcbmltcG9ydCB7IFR5cGVhaGVhZEtleVNlcnZpY2UgfSBmcm9tICcuL3R5cGVhaGVhZC1rZXkuc2VydmljZSc7XG5pbXBvcnQgeyBUeXBlYWhlYWRDb21wb25lbnQgfSBmcm9tICcuL3R5cGVhaGVhZC5jb21wb25lbnQnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBJbmZpbml0ZVNjcm9sbE1vZHVsZSxcbiAgICAgICAgU2Nyb2xsTW9kdWxlXG4gICAgXSxcbiAgICBleHBvcnRzOiBbVHlwZWFoZWFkQ29tcG9uZW50XSxcbiAgICBkZWNsYXJhdGlvbnM6IFtUeXBlYWhlYWRDb21wb25lbnQsIFR5cGVhaGVhZEhpZ2hsaWdodERpcmVjdGl2ZV0sXG4gICAgcHJvdmlkZXJzOiBbVHlwZWFoZWFkS2V5U2VydmljZV0sXG59KVxuZXhwb3J0IGNsYXNzIFR5cGVhaGVhZE1vZHVsZSB7IH1cbiIsImltcG9ydCB7IENvbXBvbmVudCwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBIb3N0QmluZGluZywgSW5qZWN0LCBJbnB1dCwgT25DaGFuZ2VzLCBPbkRlc3Ryb3ksIE9uSW5pdCwgT3V0cHV0LCBTaW1wbGVDaGFuZ2VzLCBTdGF0aWNQcm92aWRlciwgVGVtcGxhdGVSZWYsIFZpZXdDaGlsZCwgZm9yd2FyZFJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBDb250cm9sVmFsdWVBY2Nlc3NvciwgTkdfVkFMVUVfQUNDRVNTT1IgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XHJcbmltcG9ydCB7IERPQ1VNRU5UIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlcic7XHJcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMvT2JzZXJ2YWJsZSc7XHJcbmltcG9ydCB7IGRlYm91bmNlVGltZSwgZmlsdGVyLCBtYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcclxuaW1wb3J0IHsgSW5maW5pdGVTY3JvbGxMb2FkRnVuY3Rpb24gfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL2luZmluaXRlLXNjcm9sbC9pbmRleCc7XHJcbmltcG9ydCB7IFR5cGVhaGVhZENvbXBvbmVudCwgVHlwZWFoZWFkS2V5U2VydmljZSwgVHlwZWFoZWFkT3B0aW9uRXZlbnQgfSBmcm9tICcuLi90eXBlYWhlYWQvaW5kZXgnO1xyXG5cclxubGV0IHVuaXF1ZUlkID0gMDtcclxuXHJcbmV4cG9ydCBjb25zdCBTRUxFQ1RfVkFMVUVfQUNDRVNTT1I6IFN0YXRpY1Byb3ZpZGVyID0ge1xyXG4gICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXHJcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBTZWxlY3RDb21wb25lbnQpLFxyXG4gICAgbXVsdGk6IHRydWVcclxufTtcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gICAgc2VsZWN0b3I6ICd1eC1zZWxlY3QnLFxyXG4gICAgdGVtcGxhdGU6IGA8dXgtdGFnLWlucHV0ICpuZ0lmPVwibXVsdGlwbGVcIlxyXG4gICAgW2lkXT1cImlkICsgJy1pbnB1dCdcIlxyXG4gICAgWyh0YWdzKV09XCJ2YWx1ZVwiXHJcbiAgICBbKGlucHV0KV09XCJpbnB1dFwiXHJcbiAgICBbYWRkT25QYXN0ZV09XCJmYWxzZVwiXHJcbiAgICBbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxyXG4gICAgW2Rpc3BsYXldPVwiZGlzcGxheVwiXHJcbiAgICBbZnJlZUlucHV0XT1cImZhbHNlXCJcclxuICAgIFtwbGFjZWhvbGRlcl09XCJwbGFjZWhvbGRlclwiXHJcbiAgICBbc2hvd1R5cGVhaGVhZE9uQ2xpY2tdPVwidHJ1ZVwiPlxyXG5cclxuICAgIDx1eC10eXBlYWhlYWQgI211bHRpcGxlVHlwZWFoZWFkXHJcbiAgICAgICAgW2lkXT1cImlkICsgJy10eXBlYWhlYWQnXCJcclxuICAgICAgICBbb3B0aW9uc109XCJvcHRpb25zXCJcclxuICAgICAgICBbZmlsdGVyXT1cImZpbHRlciQgfCBhc3luY1wiXHJcbiAgICAgICAgWyhvcGVuKV09XCJkcm9wZG93bk9wZW5cIlxyXG4gICAgICAgIFtkaXNwbGF5XT1cImRpc3BsYXlcIlxyXG4gICAgICAgIFtrZXldPVwia2V5XCJcclxuICAgICAgICBbZGlzYWJsZWRPcHRpb25zXT1cInZhbHVlXCJcclxuICAgICAgICBbZHJvcERpcmVjdGlvbl09XCJkcm9wRGlyZWN0aW9uXCJcclxuICAgICAgICBbbWF4SGVpZ2h0XT1cIm1heEhlaWdodFwiXHJcbiAgICAgICAgW211bHRpc2VsZWN0YWJsZV09XCJ0cnVlXCJcclxuICAgICAgICBbcGFnZVNpemVdPVwicGFnZVNpemVcIlxyXG4gICAgICAgIFtzZWxlY3RGaXJzdF09XCJ0cnVlXCJcclxuICAgICAgICBbbG9hZGluZ1RlbXBsYXRlXT1cImxvYWRpbmdUZW1wbGF0ZVwiXHJcbiAgICAgICAgW29wdGlvblRlbXBsYXRlXT1cIm9wdGlvblRlbXBsYXRlXCJcclxuICAgICAgICBbbm9PcHRpb25zVGVtcGxhdGVdPVwibm9PcHRpb25zVGVtcGxhdGVcIj5cclxuICAgIDwvdXgtdHlwZWFoZWFkPlxyXG5cclxuPC91eC10YWctaW5wdXQ+XHJcblxyXG48ZGl2ICpuZ0lmPVwiIW11bHRpcGxlXCJcclxuICAgIGNsYXNzPVwiaW5uZXItYWRkb24gcmlnaHQtYWRkb25cIlxyXG4gICAgW2NsYXNzLmRpc2FibGVkXT1cImRpc2FibGVkXCJcclxuICAgIHJvbGU9XCJjb21ib2JveFwiXHJcbiAgICBbYXR0ci5hcmlhLWV4cGFuZGVkXT1cImRyb3Bkb3duT3BlblwiXHJcbiAgICBhcmlhLWhhc3BvcHVwPVwibGlzdGJveFwiPlxyXG5cclxuICAgIDxpIGNsYXNzPVwiaHBlLWljb25cIlxyXG4gICAgICAgIFtjbGFzcy5ocGUtZG93bl09XCJkcm9wRGlyZWN0aW9uID09PSAnZG93bidcIlxyXG4gICAgICAgIFtjbGFzcy5ocGUtdXBdPVwiZHJvcERpcmVjdGlvbiA9PT0gJ3VwJ1wiPjwvaT5cclxuXHJcbiAgICA8aW5wdXQgI3NpbmdsZUlucHV0IHR5cGU9XCJ0ZXh0XCIgW2F0dHIuaWRdPVwiaWQgKyAnLWlucHV0J1wiIGNsYXNzPVwiZm9ybS1jb250cm9sXCJcclxuICAgICAgICBbYXR0ci5hcmlhLWFjdGl2ZWRlc2NlbmRhbnRdPVwiaGlnaGxpZ2h0ZWRFbGVtZW50Py5pZFwiXHJcbiAgICAgICAgYXJpYS1hdXRvY29tcGxldGU9XCJsaXN0XCJcclxuICAgICAgICBbYXR0ci5hcmlhLWNvbnRyb2xzXT1cInNpbmdsZVR5cGVhaGVhZC5pZFwiXHJcbiAgICAgICAgYXJpYS1tdWx0aWxpbmU9XCJmYWxzZVwiXHJcbiAgICAgICAgWyhuZ01vZGVsKV09XCJpbnB1dFwiXHJcbiAgICAgICAgW3BsYWNlaG9sZGVyXT1cInBsYWNlaG9sZGVyXCJcclxuICAgICAgICBbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxyXG4gICAgICAgIChjbGljayk9XCJpbnB1dENsaWNrSGFuZGxlcigkZXZlbnQpXCJcclxuICAgICAgICAoYmx1cik9XCJpbnB1dEJsdXJIYW5kbGVyKCRldmVudClcIlxyXG4gICAgICAgIChrZXlkb3duKT1cImlucHV0S2V5SGFuZGxlcigkZXZlbnQpXCI+XHJcblxyXG4gICAgPHV4LXR5cGVhaGVhZCAjc2luZ2xlVHlwZWFoZWFkXHJcbiAgICAgICAgW2lkXT1cImlkICsgJy10eXBlYWhlYWQnXCJcclxuICAgICAgICBbb3B0aW9uc109XCJvcHRpb25zXCJcclxuICAgICAgICBbZmlsdGVyXT1cImZpbHRlciQgfCBhc3luY1wiXHJcbiAgICAgICAgWyhvcGVuKV09XCJkcm9wZG93bk9wZW5cIlxyXG4gICAgICAgIFtkaXNwbGF5XT1cImRpc3BsYXlcIlxyXG4gICAgICAgIFtrZXldPVwia2V5XCJcclxuICAgICAgICBbZHJvcERpcmVjdGlvbl09XCJkcm9wRGlyZWN0aW9uXCJcclxuICAgICAgICBbbWF4SGVpZ2h0XT1cIm1heEhlaWdodFwiXHJcbiAgICAgICAgW211bHRpc2VsZWN0YWJsZV09XCJmYWxzZVwiXHJcbiAgICAgICAgW29wZW5PbkZpbHRlckNoYW5nZV09XCJmYWxzZVwiXHJcbiAgICAgICAgW3BhZ2VTaXplXT1cInBhZ2VTaXplXCJcclxuICAgICAgICBbc2VsZWN0Rmlyc3RdPVwidHJ1ZVwiXHJcbiAgICAgICAgW2xvYWRpbmdUZW1wbGF0ZV09XCJsb2FkaW5nVGVtcGxhdGVcIlxyXG4gICAgICAgIFtvcHRpb25UZW1wbGF0ZV09XCJvcHRpb25UZW1wbGF0ZVwiXHJcbiAgICAgICAgW25vT3B0aW9uc1RlbXBsYXRlXT1cIm5vT3B0aW9uc1RlbXBsYXRlXCJcclxuICAgICAgICAob3B0aW9uU2VsZWN0ZWQpPVwic2luZ2xlT3B0aW9uU2VsZWN0ZWQoJGV2ZW50KVwiXHJcbiAgICAgICAgKGhpZ2hsaWdodGVkRWxlbWVudENoYW5nZSk9XCJoaWdobGlnaHRlZEVsZW1lbnQgPSAkZXZlbnRcIj5cclxuICAgIDwvdXgtdHlwZWFoZWFkPlxyXG5cclxuPC9kaXY+XHJcbmAsXHJcbiAgICBwcm92aWRlcnM6IFtTRUxFQ1RfVkFMVUVfQUNDRVNTT1JdXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBTZWxlY3RDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uQ2hhbmdlcywgT25EZXN0cm95LCBDb250cm9sVmFsdWVBY2Nlc3NvciB7XHJcblxyXG4gICAgQElucHV0KCkgQEhvc3RCaW5kaW5nKCdhdHRyLmlkJykgaWQ6IHN0cmluZyA9IGB1eC1zZWxlY3QtJHsrK3VuaXF1ZUlkfWA7XHJcblxyXG4gICAgQElucHV0KClcclxuICAgIGdldCB2YWx1ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XHJcbiAgICB9XHJcbiAgICBzZXQgdmFsdWUodmFsdWU6IGFueSkge1xyXG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy52YWx1ZUNoYW5nZS5lbWl0KHZhbHVlKTtcclxuICAgICAgICB0aGlzLnByb3BhZ2F0ZUNoYW5nZSh2YWx1ZSk7XHJcblxyXG4gICAgICAgIC8vIGlmIHdlIGFyZSBub3QgYWxsb3cgbXVsdGlwbGUgc2VsZWN0aW9uIHVwZGF0ZSB0aGUgaW5wdXQgdmFsdWUgKHN1cHBvcnRpbmcgbmdNb2RlbClcclxuICAgICAgICBpZiAoIXRoaXMubXVsdGlwbGUgJiYgdmFsdWUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5pbnB1dCA9IHRoaXMuZ2V0RGlzcGxheSh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIEBJbnB1dCgpXHJcbiAgICBnZXQgaW5wdXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lucHV0JC52YWx1ZTtcclxuICAgIH1cclxuICAgIHNldCBpbnB1dCh2YWx1ZTogc3RyaW5nKSB7XHJcbiAgICAgICAgdGhpcy5faW5wdXQkLm5leHQodmFsdWUpO1xyXG4gICAgICAgIHRoaXMuaW5wdXRDaGFuZ2UuZW1pdCh2YWx1ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgQElucHV0KClcclxuICAgIGdldCBkcm9wZG93bk9wZW4oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Ryb3Bkb3duT3BlbjtcclxuICAgIH1cclxuICAgIHNldCBkcm9wZG93bk9wZW4odmFsdWU6IGJvb2xlYW4pIHtcclxuICAgICAgICB0aGlzLl9kcm9wZG93bk9wZW4gPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLmRyb3Bkb3duT3BlbkNoYW5nZS5lbWl0KHZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICBASW5wdXQoKSBvcHRpb25zOiBhbnlbXSB8IEluZmluaXRlU2Nyb2xsTG9hZEZ1bmN0aW9uO1xyXG4gICAgQElucHV0KCkgZGlzcGxheTogKG9wdGlvbjogYW55KSA9PiBzdHJpbmcgfCBzdHJpbmc7XHJcbiAgICBASW5wdXQoKSBrZXk6IChvcHRpb246IGFueSkgPT4gc3RyaW5nIHwgc3RyaW5nO1xyXG4gICAgQElucHV0KCkgYWxsb3dOdWxsOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICBASW5wdXQoKSBkaXNhYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgQElucHV0KCkgZHJvcERpcmVjdGlvbjogJ3VwJyB8ICdkb3duJyA9ICdkb3duJztcclxuICAgIEBJbnB1dCgpIG1heEhlaWdodDogc3RyaW5nID0gJzI1MHB4JztcclxuICAgIEBJbnB1dCgpIG11bHRpcGxlOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICBASW5wdXQoKSBwYWdlU2l6ZTogbnVtYmVyID0gMjA7XHJcbiAgICBASW5wdXQoKSBwbGFjZWhvbGRlcjogc3RyaW5nO1xyXG5cclxuICAgIEBJbnB1dCgpIGxvYWRpbmdUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcclxuICAgIEBJbnB1dCgpIG5vT3B0aW9uc1RlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xyXG4gICAgQElucHV0KCkgb3B0aW9uVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XHJcblxyXG4gICAgQE91dHB1dCgpIHZhbHVlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XHJcbiAgICBAT3V0cHV0KCkgaW5wdXRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPHN0cmluZz4oKTtcclxuICAgIEBPdXRwdXQoKSBkcm9wZG93bk9wZW5DaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XHJcblxyXG4gICAgQFZpZXdDaGlsZCgnc2luZ2xlSW5wdXQnKSBzaW5nbGVJbnB1dDogRWxlbWVudFJlZjtcclxuICAgIEBWaWV3Q2hpbGQoJ211bHRpcGxlVHlwZWFoZWFkJykgbXVsdGlwbGVUeXBlYWhlYWQ6IFR5cGVhaGVhZENvbXBvbmVudDtcclxuICAgIEBWaWV3Q2hpbGQoJ3NpbmdsZVR5cGVhaGVhZCcpIHNpbmdsZVR5cGVhaGVhZDogVHlwZWFoZWFkQ29tcG9uZW50O1xyXG5cclxuICAgIGhpZ2hsaWdodGVkRWxlbWVudDogSFRNTEVsZW1lbnQ7XHJcbiAgICBmaWx0ZXIkOiBPYnNlcnZhYmxlPHN0cmluZz47XHJcbiAgICBwcm9wYWdhdGVDaGFuZ2UgPSAoXzogYW55KSA9PiB7IH07XHJcblxyXG4gICAgcHJpdmF0ZSBfdmFsdWU6IGFueTtcclxuICAgIHByaXZhdGUgX2lucHV0JCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8c3RyaW5nPignJyk7XHJcbiAgICBwcml2YXRlIF9kcm9wZG93bk9wZW46IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIHByaXZhdGUgX3N1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24oKTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgICAgICBwcml2YXRlIF9lbGVtZW50OiBFbGVtZW50UmVmLFxyXG4gICAgICAgIEBJbmplY3QoRE9DVU1FTlQpIHByaXZhdGUgX2RvY3VtZW50OiBhbnksXHJcbiAgICAgICAgcHJpdmF0ZSBfdHlwZWFoZWFkS2V5U2VydmljZTogVHlwZWFoZWFkS2V5U2VydmljZSkgeyB9XHJcblxyXG4gICAgbmdPbkluaXQoKSB7XHJcblxyXG4gICAgICAgIC8vIENoYW5nZXMgdG8gdGhlIGlucHV0IGZpZWxkXHJcbiAgICAgICAgY29uc3Qgb25JbnB1dCA9IHRoaXMuX2lucHV0JC5waXBlKFxyXG4gICAgICAgICAgICBmaWx0ZXIodmFsdWUgPT4gdGhpcy5hbGxvd051bGwpLFxyXG4gICAgICAgICAgICBmaWx0ZXIodmFsdWUgPT4gIXRoaXMubXVsdGlwbGUgJiYgdmFsdWUgIT09IHRoaXMuZ2V0RGlzcGxheSh0aGlzLnZhbHVlKSlcclxuICAgICAgICApLnN1YnNjcmliZSh2YWx1ZSA9PiB0aGlzLnZhbHVlID0gbnVsbCk7XHJcblxyXG4gICAgICAgIC8vIFNldCB1cCBmaWx0ZXIgZnJvbSBpbnB1dFxyXG4gICAgICAgIHRoaXMuZmlsdGVyJCA9IHRoaXMuX2lucHV0JC5waXBlKFxyXG4gICAgICAgICAgICBtYXAoaW5wdXQgPT4gIXRoaXMubXVsdGlwbGUgJiYgaW5wdXQgPT09IHRoaXMuZ2V0RGlzcGxheSh0aGlzLnZhbHVlKSA/ICcnIDogaW5wdXQpLFxyXG4gICAgICAgICAgICBkZWJvdW5jZVRpbWUoMjAwKVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIC8vIE9wZW4gdGhlIGRyb3Bkb3duIHdoZW4gZmlsdGVyIGlzIG5vbmVtcHR5LlxyXG4gICAgICAgIGNvbnN0IG9uRmlsdGVyID0gdGhpcy5maWx0ZXIkLnBpcGUoZmlsdGVyKHZhbHVlID0+IHZhbHVlICYmIHZhbHVlLmxlbmd0aCA+IDApKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5kcm9wZG93bk9wZW4gPSB0cnVlKTtcclxuXHJcbiAgICAgICAgLy8gc3RvcmUgdGhlIHN1YnNjcmlwdGlvbnNcclxuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24uYWRkKG9uSW5wdXQpO1xyXG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi5hZGQob25GaWx0ZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcclxuICAgICAgICBpZiAoY2hhbmdlcy5tdWx0aXBsZSAmJiAhY2hhbmdlcy5tdWx0aXBsZS5maXJzdENoYW5nZSAmJiBjaGFuZ2VzLm11bHRpcGxlLmN1cnJlbnRWYWx1ZSAhPT0gY2hhbmdlcy5tdWx0aXBsZS5wcmV2aW91c1ZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5wdXQgPSAnJztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgd3JpdGVWYWx1ZShvYmo6IGFueSk6IHZvaWQge1xyXG4gICAgICAgIGlmIChvYmogIT09IHVuZGVmaW5lZCAmJiBvYmogIT09IHRoaXMuX3ZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBvYmo7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm46IGFueSk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMucHJvcGFnYXRlQ2hhbmdlID0gZm47XHJcbiAgICB9XHJcblxyXG4gICAgcmVnaXN0ZXJPblRvdWNoZWQoZm46IGFueSk6IHZvaWQgeyB9XHJcblxyXG4gICAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGlzRGlzYWJsZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgaW5wdXRDbGlja0hhbmRsZXIoZXZlbnQ6IE1vdXNlRXZlbnQpIHtcclxuICAgICAgICB0aGlzLnNlbGVjdElucHV0VGV4dCgpO1xyXG4gICAgICAgIHRoaXMuZHJvcGRvd25PcGVuID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpbnB1dEJsdXJIYW5kbGVyKGV2ZW50OiBFdmVudCkge1xyXG5cclxuICAgICAgICAvLyBJZiBhIGNsaWNrIG9uIHRoZSB0eXBlYWhlYWQgaXMgaW4gcHJvZ3Jlc3MsIGp1c3QgcmVmb2N1cyB0aGUgaW5wdXQuXHJcbiAgICAgICAgLy8gVGhpcyB3b3JrcyBhcm91bmQgYW4gaXNzdWUgaW4gSUUgd2hlcmUgY2xpY2tpbmcgYSBzY3JvbGxiYXIgZHJvcHMgZm9jdXMuXHJcbiAgICAgICAgaWYgKHRoaXMuc2luZ2xlVHlwZWFoZWFkICYmIHRoaXMuc2luZ2xlVHlwZWFoZWFkLmNsaWNraW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2luZ2xlSW5wdXQubmF0aXZlRWxlbWVudC5mb2N1cygpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDbG9zZSBkcm9wZG93biBhbmQgcmVzZXQgdGV4dCBpbnB1dCBpZiBmb2N1cyBpcyBsb3N0XHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fZWxlbWVudC5uYXRpdmVFbGVtZW50LmNvbnRhaW5zKHRoaXMuX2RvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRyb3Bkb3duT3BlbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLm11bHRpcGxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dCA9IHRoaXMuZ2V0RGlzcGxheSh0aGlzLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIDIwMCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBLZXkgaGFuZGxlciBmb3Igc2luZ2xlIHNlbGVjdCBvbmx5LiBNdWx0aXBsZSBzZWxlY3Qga2V5IGhhbmRsaW5nIGlzIGluIFRhZ0lucHV0Q29tcG9uZW50LlxyXG4gICAgICovXHJcbiAgICBpbnB1dEtleUhhbmRsZXIoZXZlbnQ6IEtleWJvYXJkRXZlbnQpIHtcclxuXHJcbiAgICAgICAgLy8gU3RhbmRhcmQga2V5cyBmb3IgdHlwZWFoZWFkICh1cC9kb3duL2VzYylcclxuICAgICAgICB0aGlzLl90eXBlYWhlYWRLZXlTZXJ2aWNlLmhhbmRsZUtleShldmVudCwgdGhpcy5zaW5nbGVUeXBlYWhlYWQpO1xyXG5cclxuICAgICAgICBzd2l0Y2ggKGV2ZW50LmtleSkge1xyXG4gICAgICAgICAgICBjYXNlICdFbnRlcic6XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZHJvcGRvd25PcGVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IHRoZSBoaWdobGlnaHRlZCBvcHRpb24gYXMgdGhlIHZhbHVlIGFuZCBjbG9zZVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnNpbmdsZVR5cGVhaGVhZC5oaWdobGlnaHRlZDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyb3Bkb3duT3BlbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgaW5wdXQgZmllbGQuIElmIGRyb3Bkb3duIGlzbid0IG9wZW4gdGhlbiByZXNldCBpdCB0byB0aGUgcHJldmlvdXMgdmFsdWUuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0ID0gdGhpcy5nZXREaXNwbGF5KHRoaXMudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzaW5nbGVPcHRpb25TZWxlY3RlZChldmVudDogVHlwZWFoZWFkT3B0aW9uRXZlbnQpIHtcclxuICAgICAgICBpZiAoZXZlbnQub3B0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBldmVudC5vcHRpb247XHJcbiAgICAgICAgICAgIHRoaXMuZHJvcGRvd25PcGVuID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZGlzcGxheSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gb3B0aW9uLlxyXG4gICAgICovXHJcbiAgICBnZXREaXNwbGF5KG9wdGlvbjogYW55KTogc3RyaW5nIHtcclxuICAgICAgICBpZiAob3B0aW9uID09PSBudWxsIHx8IG9wdGlvbiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmRpc3BsYXkgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGxheShvcHRpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuZGlzcGxheSA9PT0gJ3N0cmluZycgJiYgb3B0aW9uLmhhc093blByb3BlcnR5KHRoaXMuZGlzcGxheSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbls8c3RyaW5nPnRoaXMuZGlzcGxheV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvcHRpb247XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBzZWxlY3RJbnB1dFRleHQoKSB7XHJcbiAgICAgICAgdGhpcy5zaW5nbGVJbnB1dC5uYXRpdmVFbGVtZW50LnNlbGVjdCgpO1xyXG4gICAgfVxyXG59IiwiZXhwb3J0IGNsYXNzIFRhZ0lucHV0RXZlbnQge1xuXG4gICAgcHJpdmF0ZSBfZGVmYXVsdFByZXZlbnRlZCA9IGZhbHNlO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIHRhZzogYW55KSB7fVxuXG4gICAgcHJldmVudERlZmF1bHQoKSB7XG4gICAgICAgIHRoaXMuX2RlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGRlZmF1bHRQcmV2ZW50ZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWZhdWx0UHJldmVudGVkO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBBZnRlckNvbnRlbnRJbml0LCBDb21wb25lbnQsIENvbnRlbnRDaGlsZHJlbiwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBmb3J3YXJkUmVmLCBIb3N0QmluZGluZywgSG9zdExpc3RlbmVyLCBJbmplY3QsIElucHV0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSwgT25Jbml0LCBPdXRwdXQsIFF1ZXJ5TGlzdCwgU2ltcGxlQ2hhbmdlcywgVGVtcGxhdGVSZWYsIFZpZXdDaGlsZCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBDb250cm9sVmFsdWVBY2Nlc3NvciwgTkdfVkFMSURBVE9SUywgTkdfVkFMVUVfQUNDRVNTT1IgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XHJcbmltcG9ydCB7IERPQ1VNRU5UIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlcic7XHJcbmltcG9ydCB7IGRlbGF5IH0gZnJvbSAncnhqcy9vcGVyYXRvcnMvZGVsYXknO1xyXG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XHJcbmltcG9ydCB7IFR5cGVhaGVhZENvbXBvbmVudCwgVHlwZWFoZWFkS2V5U2VydmljZSB9IGZyb20gJy4uL3R5cGVhaGVhZC9pbmRleCc7XHJcbmltcG9ydCB7IFR5cGVhaGVhZE9wdGlvbkV2ZW50IH0gZnJvbSAnLi4vdHlwZWFoZWFkL3R5cGVhaGVhZC1ldmVudCc7XHJcbmltcG9ydCB7IFRhZ0lucHV0RXZlbnQgfSBmcm9tICcuL3RhZy1pbnB1dC1ldmVudCc7XHJcblxyXG5sZXQgdW5pcXVlSWQgPSAwO1xyXG5cclxuY29uc3QgVEFHSU5QVVRfVkFMVUVfQUNDRVNTT1IgPSB7XHJcbiAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcclxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFRhZ0lucHV0Q29tcG9uZW50KSxcclxuICAgIG11bHRpOiB0cnVlXHJcbn07XHJcbmNvbnN0IFRBR0lOUFVUX1ZBTElEQVRPUiA9IHtcclxuICAgIHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsXHJcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBUYWdJbnB1dENvbXBvbmVudCksXHJcbiAgICBtdWx0aTogdHJ1ZVxyXG59O1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgICBzZWxlY3RvcjogJ3V4LXRhZy1pbnB1dCcsXHJcbiAgICB0ZW1wbGF0ZTogYDxvbCBbYXR0ci5yb2xlXT1cInR5cGVhaGVhZCA/ICdjb21ib2JveCcgOiAnbm9uZSdcIiBbYXR0ci5hcmlhLWhhc3BvcHVwXT1cInR5cGVhaGVhZCA/ICdsaXN0Ym94JyA6IG51bGxcIj5cbiAgICA8bGkgKm5nRm9yPVwibGV0IHRhZyBvZiB0YWdzOyBsZXQgaSA9IGluZGV4XCIgY2xhc3M9XCJ1eC10YWdcIlxuICAgICAgICBbY2xhc3MuZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuICAgICAgICBbbmdDbGFzc109XCJ0YWdDbGFzcyh0YWcsIGksIGlzU2VsZWN0ZWQoaSkpXCJcbiAgICAgICAgW2F0dHIudGFiaW5kZXhdPVwiZGlzYWJsZWQgPyBudWxsIDogMFwiXG4gICAgICAgIFtmb2N1c0lmXT1cImlzU2VsZWN0ZWQoaSlcIlxuICAgICAgICAoY2xpY2spPVwidGFnQ2xpY2tIYW5kbGVyKCRldmVudCwgdGFnLCBpKVwiXG4gICAgICAgIChmb2N1cyk9XCJzZWxlY3RUYWdBdChpKVwiPlxuXG4gICAgICAgIDxuZy1jb250YWluZXIgW25nVGVtcGxhdGVPdXRsZXRdPVwidGFnVGVtcGxhdGVcIlxuICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRDb250ZXh0XT1cInt0YWc6IHRhZywgaW5kZXg6IGksIGRpc2FibGVkOiBkaXNhYmxlZCwgYXBpOiB0YWdBcGl9XCI+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuXG4gICAgPC9saT5cbiAgICA8bGkgKm5nSWY9XCJpc0lucHV0VmlzaWJsZSgpXCIgY2xhc3M9XCJ1eC10YWctaW5wdXRcIiByb2xlPVwibm9uZVwiPlxuICAgICAgICA8aW5wdXQgI3RhZ0lucHV0IHR5cGU9XCJ0ZXh0XCIgW2F0dHIuaWRdPVwiaWRcIiBjbGFzcz1cInV4LXRhZy1pbnB1dFwiXG4gICAgICAgICAgICBbKG5nTW9kZWwpXT1cImlucHV0XCJcbiAgICAgICAgICAgIFtjbGFzcy5pbnZhbGlkXT1cIiFpbnB1dFZhbGlkXCJcbiAgICAgICAgICAgIFthdHRyLmFyaWEtYWN0aXZlZGVzY2VuZGFudF09XCJoaWdobGlnaHRlZEVsZW1lbnQ/LmlkXCJcbiAgICAgICAgICAgIFthdHRyLmFyaWEtYXV0b2NvbXBsZXRlXT1cInR5cGVhaGVhZCA/ICdsaXN0JyA6ICdub25lJ1wiXG4gICAgICAgICAgICBbYXR0ci5hcmlhLWNvbnRyb2xzXT1cInR5cGVhaGVhZD8uaWRcIlxuICAgICAgICAgICAgYXJpYS1tdWx0aWxpbmU9XCJmYWxzZVwiXG4gICAgICAgICAgICBbcGxhY2Vob2xkZXJdPVwiZGlzYWJsZWQgPyAnJyA6IChwbGFjZWhvbGRlciB8fCAnJylcIlxuICAgICAgICAgICAgW2Rpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICAgICAgIFtmb2N1c0lmXT1cImlzU2VsZWN0ZWQodGFncy5sZW5ndGgpXCJcbiAgICAgICAgICAgIChjbGljayk9XCJpbnB1dENsaWNrSGFuZGxlcigpXCJcbiAgICAgICAgICAgIChmb2N1cyk9XCJpbnB1dEZvY3VzSGFuZGxlcigpXCJcbiAgICAgICAgICAgIChwYXN0ZSk9XCJpbnB1dFBhc3RlSGFuZGxlcigkZXZlbnQpXCI+XG4gICAgPC9saT5cbjwvb2w+XG5cbjxuZy1jb250ZW50ICN0eXBlYWhlYWQ+PC9uZy1jb250ZW50PlxuXG48bmctdGVtcGxhdGUgI2RlZmF1bHRUYWdUZW1wbGF0ZSBsZXQtdGFnPVwidGFnXCIgbGV0LWluZGV4PVwiaW5kZXhcIiBsZXQtZGlzYWJsZWQ9XCJkaXNhYmxlZFwiIGxldC1hcGk9XCJhcGlcIj5cbiAgICA8c3BhbiBjbGFzcz1cInV4LXRhZy10ZXh0XCI+e3thcGkuZ2V0VGFnRGlzcGxheSh0YWcpfX08L3NwYW4+XG4gICAgPGJ1dHRvbiAqbmdJZj1cImFwaS5jYW5SZW1vdmVUYWdBdChpbmRleClcIlxuICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgY2xhc3M9XCJ1eC10YWctcmVtb3ZlXCJcbiAgICAgICAgYXJpYS1sYWJlbD1cIlJlbW92ZSBJdGVtXCJcbiAgICAgICAgW2Rpc2FibGVkXT1cImRpc2FibGVkXCJcbiAgICAgICAgKGNsaWNrKT1cImFwaS5yZW1vdmVUYWdBdChpbmRleCk7ICRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcIj5cbiAgICAgICAgPHNwYW4gY2xhc3M9XCJocGUtaWNvbiBocGUtY2xvc2VcIj48L3NwYW4+XG4gICAgPC9idXR0b24+XG48L25nLXRlbXBsYXRlPmAsXHJcbiAgICBwcm92aWRlcnM6IFtUQUdJTlBVVF9WQUxVRV9BQ0NFU1NPUiwgVEFHSU5QVVRfVkFMSURBVE9SXSxcclxuICAgIGhvc3Q6IHtcclxuICAgICAgICAnW2NsYXNzLmRpc2FibGVkXSc6ICdkaXNhYmxlZCcsXHJcbiAgICAgICAgJ1tjbGFzcy5mb2N1c10nOiAnaGFzRm9jdXMoKScsXHJcbiAgICAgICAgJ1tjbGFzcy5pbnZhbGlkXSc6ICchdmFsaWQgfHwgIWlucHV0VmFsaWQnXHJcbiAgICB9XHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBUYWdJbnB1dENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgQWZ0ZXJDb250ZW50SW5pdCwgT25DaGFuZ2VzLCBDb250cm9sVmFsdWVBY2Nlc3NvciwgT25EZXN0cm95IHtcclxuXHJcbiAgICBASW5wdXQoKSBASG9zdEJpbmRpbmcoJ2F0dHIuaWQnKSBpZDogc3RyaW5nID0gYHV4LXRhZy1pbnB1dC0keysrdW5pcXVlSWR9YDtcclxuXHJcbiAgICBASW5wdXQoJ3RhZ3MnKVxyXG4gICAgZ2V0IHRhZ3MoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl90YWdzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RhZ3MgPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RhZ3M7XHJcbiAgICB9XHJcbiAgICBzZXQgdGFncyh2YWx1ZTogYW55W10pIHtcclxuICAgICAgICB0aGlzLl90YWdzID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5fb25DaGFuZ2VIYW5kbGVyKHRoaXMuX3RhZ3MpO1xyXG4gICAgICAgIHRoaXMudGFnc0NoYW5nZS5lbWl0KHRoaXMuX3RhZ3MpO1xyXG4gICAgfVxyXG5cclxuICAgIEBPdXRwdXQoKSB0YWdzQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxhbnlbXT4oKTtcclxuXHJcbiAgICBASW5wdXQoJ2lucHV0JylcclxuICAgIGdldCBpbnB1dCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faW5wdXQ7XHJcbiAgICB9XHJcbiAgICBzZXQgaW5wdXQodmFsdWU6IHN0cmluZykge1xyXG4gICAgICAgIHRoaXMuX2lucHV0ID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5pbnB1dENoYW5nZS5lbWl0KHZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICBAT3V0cHV0KCkgaW5wdXRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPHN0cmluZz4oKTtcclxuXHJcbiAgICBASW5wdXQoKSBkaXNwbGF5OiAob3B0aW9uOiBhbnkpID0+IHN0cmluZyB8IHN0cmluZztcclxuICAgIEBJbnB1dCgpIGFkZE9uUGFzdGU6IGJvb2xlYW4gPSB0cnVlO1xyXG4gICAgQElucHV0KCkgZGlzYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIEBJbnB1dCgpIGVuZm9yY2VUYWdMaW1pdHM6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIEBJbnB1dCgpIGZyZWVJbnB1dDogYm9vbGVhbiA9IHRydWU7XHJcbiAgICBASW5wdXQoKSBtYXhUYWdzOiBudW1iZXIgPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgQElucHV0KCkgbWluVGFnczogbnVtYmVyID0gMDtcclxuICAgIEBJbnB1dCgpIHBsYWNlaG9sZGVyOiBzdHJpbmcgPSAnJztcclxuICAgIEBJbnB1dCgpIHNob3dUeXBlYWhlYWRPbkNsaWNrOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICBASW5wdXQoKSB0YWdEZWxpbWl0ZXJzOiBzdHJpbmcgPSAnJztcclxuICAgIEBJbnB1dCgpIHRhZ1BhdHRlcm46IFJlZ0V4cDtcclxuICAgIEBJbnB1dCgpIHRhZ1RlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xyXG4gICAgQElucHV0KCkgdGFnQ2xhc3M6IFRhZ0NsYXNzRnVuY3Rpb24gPSAoKSA9PiB1bmRlZmluZWQ7XHJcbiAgICBASW5wdXQoKSB2YWxpZGF0aW9uRXJyb3JzOiBhbnkgPSB7fTtcclxuICAgIEBJbnB1dCgnY3JlYXRlVGFnJykgY3JlYXRlVGFnSGFuZGxlcjogKHZhbHVlOiBzdHJpbmcpID0+IGFueTtcclxuXHJcbiAgICBAT3V0cHV0KCkgdGFnQWRkaW5nID0gbmV3IEV2ZW50RW1pdHRlcjxUYWdJbnB1dEV2ZW50PigpO1xyXG4gICAgQE91dHB1dCgpIHRhZ0FkZGVkID0gbmV3IEV2ZW50RW1pdHRlcjxUYWdJbnB1dEV2ZW50PigpO1xyXG4gICAgQE91dHB1dCgpIHRhZ0ludmFsaWRhdGVkID0gbmV3IEV2ZW50RW1pdHRlcjxUYWdJbnB1dEV2ZW50PigpO1xyXG4gICAgQE91dHB1dCgpIHRhZ1JlbW92aW5nID0gbmV3IEV2ZW50RW1pdHRlcjxUYWdJbnB1dEV2ZW50PigpO1xyXG4gICAgQE91dHB1dCgpIHRhZ1JlbW92ZWQgPSBuZXcgRXZlbnRFbWl0dGVyPFRhZ0lucHV0RXZlbnQ+KCk7XHJcbiAgICBAT3V0cHV0KCkgdGFnQ2xpY2sgPSBuZXcgRXZlbnRFbWl0dGVyPFRhZ0lucHV0RXZlbnQ+KCk7XHJcblxyXG4gICAgQENvbnRlbnRDaGlsZHJlbihUeXBlYWhlYWRDb21wb25lbnQpIHR5cGVhaGVhZFF1ZXJ5OiBRdWVyeUxpc3Q8VHlwZWFoZWFkQ29tcG9uZW50PjtcclxuXHJcbiAgICBAVmlld0NoaWxkKCd0YWdJbnB1dCcpIHRhZ0lucHV0OiBFbGVtZW50UmVmO1xyXG5cclxuICAgIEBWaWV3Q2hpbGQoJ2RlZmF1bHRUYWdUZW1wbGF0ZScpIHByaXZhdGUgX2RlZmF1bHRUYWdUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcclxuXHJcbiAgICBzZWxlY3RlZEluZGV4OiBudW1iZXIgPSAtMTtcclxuXHJcbiAgICB0YWdBcGk6IFRhZ0FwaSA9IHtcclxuICAgICAgICBnZXRUYWdEaXNwbGF5OiB0aGlzLmdldFRhZ0Rpc3BsYXkuYmluZCh0aGlzKSxcclxuICAgICAgICByZW1vdmVUYWdBdDogdGhpcy5yZW1vdmVUYWdBdC5iaW5kKHRoaXMpLFxyXG4gICAgICAgIGNhblJlbW92ZVRhZ0F0OiB0aGlzLmNhblJlbW92ZVRhZ0F0LmJpbmQodGhpcylcclxuICAgIH07XHJcblxyXG4gICAgdmFsaWQ6IGJvb2xlYW4gPSB0cnVlO1xyXG4gICAgaW5wdXRWYWxpZDogYm9vbGVhbiA9IHRydWU7XHJcblxyXG4gICAgdHlwZWFoZWFkOiBUeXBlYWhlYWRDb21wb25lbnQ7XHJcblxyXG4gICAgaGlnaGxpZ2h0ZWRFbGVtZW50OiBIVE1MRWxlbWVudDtcclxuXHJcbiAgICBwcml2YXRlIF9pbnB1dDogc3RyaW5nID0gJyc7XHJcbiAgICBwcml2YXRlIF90YWdzOiBhbnlbXSA9IFtdO1xyXG4gICAgcHJpdmF0ZSBfb25DaGFuZ2VIYW5kbGVyOiAoXzogYW55KSA9PiB2b2lkID0gKCkgPT4geyB9O1xyXG4gICAgcHJpdmF0ZSBfb25Ub3VjaGVkSGFuZGxlcjogKCkgPT4gdm9pZCA9ICgpID0+IHsgfTtcclxuICAgIHByaXZhdGUgX3R5cGVhaGVhZFN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgICAgIHByaXZhdGUgX2VsZW1lbnQ6IEVsZW1lbnRSZWYsXHJcbiAgICAgICAgQEluamVjdChET0NVTUVOVCkgcHJpdmF0ZSBfZG9jdW1lbnQ6IGFueSxcclxuICAgICAgICBwcml2YXRlIF90eXBlYWhlYWRLZXlTZXJ2aWNlOiBUeXBlYWhlYWRLZXlTZXJ2aWNlKSB7IH1cclxuXHJcbiAgICBuZ09uSW5pdCgpIHtcclxuICAgICAgICBpZiAoIXRoaXMudGFnVGVtcGxhdGUpIHtcclxuICAgICAgICAgICAgdGhpcy50YWdUZW1wbGF0ZSA9IHRoaXMuX2RlZmF1bHRUYWdUZW1wbGF0ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xyXG4gICAgICAgIC8vIFdhdGNoIGZvciBvcHRpb25hbCBjaGlsZCB0eXBlYWhlYWQgY29udHJvbFxyXG4gICAgICAgIHRoaXMuY29ubmVjdFR5cGVhaGVhZCh0aGlzLnR5cGVhaGVhZFF1ZXJ5LmZpcnN0KTtcclxuICAgICAgICB0aGlzLnR5cGVhaGVhZFF1ZXJ5LmNoYW5nZXMuc3Vic2NyaWJlKChxdWVyeSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RUeXBlYWhlYWQocXVlcnkuZmlyc3QpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcclxuICAgICAgICBpZiAoY2hhbmdlcy5kaXNhYmxlZCkge1xyXG4gICAgICAgICAgICBpZiAoY2hhbmdlcy5kaXNhYmxlZC5jdXJyZW50VmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIC8vIENsZWFyIHNlbGVjdGlvbiBhbmQgY2xvc2UgZHJvcGRvd25cclxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHlwZWFoZWFkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50eXBlYWhlYWQub3BlbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBVcGRhdGUgdmFsaWRhdGlvbiBzdGF0dXNcclxuICAgICAgICB0aGlzLnZhbGlkYXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZTogYW55W10pIHtcclxuICAgICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy50YWdzID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm46IGFueSkge1xyXG4gICAgICAgIHRoaXMuX29uQ2hhbmdlSGFuZGxlciA9IGZuO1xyXG4gICAgfVxyXG5cclxuICAgIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiBhbnkpIHtcclxuICAgICAgICB0aGlzLl9vblRvdWNoZWRIYW5kbGVyID0gZm47XHJcbiAgICB9XHJcblxyXG4gICAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkOiBib29sZWFuKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGlzRGlzYWJsZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3R5cGVhaGVhZFN1YnNjcmlwdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLl90eXBlYWhlYWRTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBWYWxpZGF0ZSB0aGUgdmFsdWUgb2YgdGhlIGNvbnRyb2wgKHRhZ3MgcHJvcGVydHkpLlxyXG4gICAgICovXHJcbiAgICB2YWxpZGF0ZSgpIHtcclxuICAgICAgICB0aGlzLnZhbGlkID0gdHJ1ZTtcclxuICAgICAgICBsZXQgdGFnUmFuZ2VFcnJvciA9IG51bGw7XHJcbiAgICAgICAgaWYgKHRoaXMudGFncyAmJiAodGhpcy50YWdzLmxlbmd0aCA8IHRoaXMubWluVGFncyB8fCB0aGlzLnRhZ3MubGVuZ3RoID4gdGhpcy5tYXhUYWdzKSkge1xyXG4gICAgICAgICAgICB0YWdSYW5nZUVycm9yID0ge1xyXG4gICAgICAgICAgICAgICAgZ2l2ZW46IHRoaXMudGFncy5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICBtaW46IHRoaXMubWluVGFncyxcclxuICAgICAgICAgICAgICAgIG1heDogdGhpcy5tYXhUYWdzXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMudmFsaWQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy52YWxpZGF0aW9uRXJyb3JzWyd0YWdSYW5nZUVycm9yJ10gPSB0YWdSYW5nZUVycm9yO1xyXG4gICAgfVxyXG5cclxuICAgIEBIb3N0TGlzdGVuZXIoJ2tleWRvd24nLCBbJyRldmVudCddKVxyXG4gICAga2V5SGFuZGxlcihldmVudDogS2V5Ym9hcmRFdmVudCkge1xyXG5cclxuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkgeyByZXR1cm47IH1cclxuXHJcbiAgICAgICAgLy8gR2V0IHRoZSBpbnB1dCBmaWVsZCBjdXJzb3IgbG9jYXRpb25cclxuICAgICAgICBjb25zdCBpbnB1dEN1cnNvclBvcyA9IHRoaXMudGFnSW5wdXQubmF0aXZlRWxlbWVudC5zZWxlY3Rpb25TdGFydDtcclxuXHJcbiAgICAgICAgLy8gRGV0ZXJtaW5lIGlmIHRoZSBpbnB1dCBmaWVsZCBoYXMgYW55IHRleHQgc2VsZWN0ZWRcclxuICAgICAgICBjb25zdCBoYXNTZWxlY3Rpb24gPSB0aGlzLnRhZ0lucHV0Lm5hdGl2ZUVsZW1lbnQuc2VsZWN0aW9uU3RhcnQgIT09IHRoaXMudGFnSW5wdXQubmF0aXZlRWxlbWVudC5zZWxlY3Rpb25FbmQ7XHJcblxyXG4gICAgICAgIC8vIERldGVybWluZSBpZiBhIHRhZyBoYXMgZm9jdXNcclxuICAgICAgICBjb25zdCB0YWdTZWxlY3RlZCA9IHRoaXMuaXNWYWxpZFRhZ0luZGV4KHRoaXMuc2VsZWN0ZWRJbmRleCk7XHJcblxyXG4gICAgICAgIGNvbnN0IGlucHV0TGVuZ3RoID0gdGhpcy5pbnB1dCA/IHRoaXMuaW5wdXQubGVuZ3RoIDogMDtcclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGUgYXJyb3cga2V5cyBjYW4gbW92ZSB0aGUgc2VsZWN0aW9uLiBPdGhlcndpc2UgdGhlIGlucHV0IGZpZWxkIHRha2VzIHRoZSBldmVudC5cclxuICAgICAgICBjb25zdCBjYW5OYXZpZ2F0ZUxlZnQgPSB0YWdTZWxlY3RlZCB8fCAoaW5wdXRDdXJzb3JQb3MgPD0gMCAmJiAhaGFzU2VsZWN0aW9uKTtcclxuICAgICAgICBjb25zdCBjYW5OYXZpZ2F0ZVJpZ2h0ID0gdGFnU2VsZWN0ZWQgfHwgKGlucHV0Q3Vyc29yUG9zID49IGlucHV0TGVuZ3RoICYmICFoYXNTZWxlY3Rpb24pO1xyXG5cclxuICAgICAgICAvLyBGb3J3YXJkIGtleSBldmVudHMgdG8gdGhlIHR5cGVhaGVhZCBjb21wb25lbnQuXHJcbiAgICAgICAgdGhpcy5fdHlwZWFoZWFkS2V5U2VydmljZS5oYW5kbGVLZXkoZXZlbnQsIHRoaXMudHlwZWFoZWFkKTtcclxuXHJcbiAgICAgICAgc3dpdGNoIChldmVudC5rZXkpIHtcclxuICAgICAgICAgICAgY2FzZSAnRW50ZXInOlxyXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgYSB0eXBlYWhlYWQgb3B0aW9uIGlzIGhpZ2hsaWdodGVkXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50eXBlYWhlYWQgJiYgdGhpcy50eXBlYWhlYWQub3BlbiAmJiB0aGlzLnR5cGVhaGVhZC5oaWdobGlnaHRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgdHlwZWFoZWFkIG9wdGlvbiBhcyBhIHRhZywgY2xlYXIgdGhlIGlucHV0LCBhbmQgY2xvc2UgdGhlIGRyb3Bkb3duXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21taXRUeXBlYWhlYWQodGhpcy50eXBlYWhlYWQuaGlnaGxpZ2h0ZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHlwZWFoZWFkLm9wZW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVmFsaWRhdGUgYW5kIGFkZCB0aGUgaW5wdXQgdGV4dCBhcyBhIHRhZywgaWYgcG9zc2libGVcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbW1pdElucHV0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ0JhY2tzcGFjZSc6XHJcbiAgICAgICAgICAgICAgICBpZiAoY2FuTmF2aWdhdGVMZWZ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iYWNrc3BhY2UoKTtcclxuICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ0RlbGV0ZSc6XHJcbiAgICAgICAgICAgIGNhc2UgJ0RlbCc6XHJcbiAgICAgICAgICAgICAgICBpZiAodGFnU2VsZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVRhZ0F0KHRoaXMuc2VsZWN0ZWRJbmRleCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnQXJyb3dMZWZ0JzpcclxuICAgICAgICAgICAgY2FzZSAnTGVmdCc6XHJcbiAgICAgICAgICAgICAgICBpZiAoY2FuTmF2aWdhdGVMZWZ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb3ZlU2VsZWN0aW9uKC0xKTtcclxuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ0Fycm93UmlnaHQnOlxyXG4gICAgICAgICAgICBjYXNlICdSaWdodCc6XHJcbiAgICAgICAgICAgICAgICBpZiAoY2FuTmF2aWdhdGVSaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW92ZVNlbGVjdGlvbigxKTtcclxuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDaGVjayBmb3Iga2V5cyBpbiB0aGUgdGFnRGVsaW1pdGVyc1xyXG4gICAgICAgIGlmICh0aGlzLnRhZ0RlbGltaXRlcnMgJiYgdGhpcy50YWdEZWxpbWl0ZXJzLmluZGV4T2YodGhpcy5nZXRLZXlDaGFyKGV2ZW50KSkgPj0gMCkge1xyXG4gICAgICAgICAgICAvLyBDb21taXQgcHJldmlvdXMgdGV4dFxyXG4gICAgICAgICAgICB0aGlzLmNvbW1pdElucHV0KCk7XHJcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBASG9zdExpc3RlbmVyKCdmb2N1c291dCcsIFsnJGV2ZW50J10pXHJcbiAgICBmb2N1c091dEhhbmRsZXIoZXZlbnQ6IEZvY3VzRXZlbnQpIHtcclxuXHJcbiAgICAgICAgLy8gSWYgYSBjbGljayBvbiB0aGUgdHlwZWFoZWFkIGlzIGluIHByb2dyZXNzLCBkb24ndCBkbyBhbnl0aGluZy5cclxuICAgICAgICAvLyBUaGlzIHdvcmtzIGFyb3VuZCBhbiBpc3N1ZSBpbiBJRSB3aGVyZSBjbGlja2luZyBhIHNjcm9sbGJhciBkcm9wcyBmb2N1cy5cclxuICAgICAgICBpZiAodGhpcy50eXBlYWhlYWQgJiYgdGhpcy50eXBlYWhlYWQuY2xpY2tpbmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2xvc2UgdGhlIGRyb3Bkb3duIG9uIGJsdXJcclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuY29udGFpbnModGhpcy5fZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHlwZWFoZWFkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50eXBlYWhlYWQub3BlbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgMjAwKTtcclxuICAgIH1cclxuXHJcbiAgICB0YWdDbGlja0hhbmRsZXIoZXZlbnQ6IE1vdXNlRXZlbnQsIHRhZzogYW55LCBpbmRleDogbnVtYmVyKSB7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7IHJldHVybjsgfVxyXG5cclxuICAgICAgICAvLyBTZW5kIHRhZ0NsaWNrIGV2ZW50XHJcbiAgICAgICAgY29uc3QgdGFnQ2xpY2tFdmVudCA9IG5ldyBUYWdJbnB1dEV2ZW50KHRhZyk7XHJcbiAgICAgICAgdGhpcy50YWdDbGljay5lbWl0KHRhZ0NsaWNrRXZlbnQpO1xyXG5cclxuICAgICAgICAvLyBQcmV2ZW50IGZvY3VzIGlmIHByZXZlbnREZWZhdWx0KCkgd2FzIGNhbGxlZFxyXG4gICAgICAgIGlmICh0YWdDbGlja0V2ZW50LmRlZmF1bHRQcmV2ZW50ZWQoKSkge1xyXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTZWxlY3QgdGhlIHRhZyAoZm9yIElFIHRoYXQgZG9lc24ndCBwcm9wYWdhdGUgZm9jdXMpXHJcbiAgICAgICAgdGhpcy5zZWxlY3RUYWdBdChpbmRleCk7XHJcbiAgICB9XHJcblxyXG4gICAgaW5wdXRDbGlja0hhbmRsZXIoKSB7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7IHJldHVybjsgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy50eXBlYWhlYWQgJiYgdGhpcy5zaG93VHlwZWFoZWFkT25DbGljaykge1xyXG4gICAgICAgICAgICB0aGlzLnR5cGVhaGVhZC5vcGVuID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaW5wdXRGb2N1c0hhbmRsZXIoKSB7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7IHJldHVybjsgfVxyXG5cclxuICAgICAgICB0aGlzLnNlbGVjdElucHV0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgaW5wdXRQYXN0ZUhhbmRsZXIoZXZlbnQ6IENsaXBib2FyZEV2ZW50KSB7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7IHJldHVybjsgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5hZGRPblBhc3RlKSB7XHJcbiAgICAgICAgICAgIC8vIEdldCB0ZXh0IGZyb20gdGhlIGNsaXBib2FyZFxyXG4gICAgICAgICAgICBsZXQgaW5wdXQ6IHN0cmluZyA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmIChldmVudC5jbGlwYm9hcmREYXRhKSB7XHJcbiAgICAgICAgICAgICAgICBpbnB1dCA9IGV2ZW50LmNsaXBib2FyZERhdGEuZ2V0RGF0YSgndGV4dC9wbGFpbicpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCg8YW55PndpbmRvdykuY2xpcGJvYXJkRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgLy8gSW50ZXJuZXQgRXhwbG9yZXIgb25seVxyXG4gICAgICAgICAgICAgICAgaW5wdXQgPSAoPGFueT53aW5kb3cpLmNsaXBib2FyZERhdGEuZ2V0RGF0YSgnVGV4dCcpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBDb21taXQgdGhlIGNsaXBib2FyZCB0ZXh0IGRpcmVjdGx5XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbW1pdChpbnB1dCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0SW5wdXQoKTtcclxuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0eXBlYWhlYWRPcHRpb25TZWxlY3RlZEhhbmRsZXIoZXZlbnQ6IFR5cGVhaGVhZE9wdGlvbkV2ZW50KSB7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7IHJldHVybjsgfVxyXG5cclxuICAgICAgICAvLyBXaGVuIHRoZSB0eXBlYWhlYWQgc2VuZHMgdGhlIG9wdGlvblNlbGVjdGVkIGV2ZW50LCBjb21taXQgdGhlIG9iamVjdCBkaXJlY3RseVxyXG4gICAgICAgIHRoaXMuY29tbWl0VHlwZWFoZWFkKGV2ZW50Lm9wdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21taXQgdGhlIGN1cnJlbnQgaW5wdXQgdmFsdWUgYW5kIGNsZWFyIHRoZSBpbnB1dCBmaWVsZCBpZiBzdWNjZXNzZnVsLlxyXG4gICAgICovXHJcbiAgICBjb21taXRJbnB1dCgpIHtcclxuICAgICAgICBpZiAodGhpcy5jb21taXQodGhpcy5pbnB1dCkpIHtcclxuICAgICAgICAgICAgdGhpcy5zZWxlY3RJbnB1dCgpO1xyXG4gICAgICAgICAgICB0aGlzLmlucHV0ID0gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tbWl0IHRoZSBnaXZlbiB0YWcgb2JqZWN0IGFuZCBjbGVhciB0aGUgaW5wdXQgaWYgc3VjY2Vzc2Z1bC5cclxuICAgICAqL1xyXG4gICAgY29tbWl0VHlwZWFoZWFkKHRhZzogYW55KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuYWRkVGFnKHRhZykpIHtcclxuICAgICAgICAgICAgdGhpcy5zZWxlY3RJbnB1dCgpO1xyXG4gICAgICAgICAgICB0aGlzLmlucHV0ID0gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tbWl0IHRoZSBnaXZlbiBzdHJpbmcgdmFsdWUgYXMgb25lIG9yIG1vcmUgdGFncywgaWYgdmFsaWRhdGlvbiBwYXNzZXMuIFJldHVybnMgdHJ1ZSBpZiB0aGUgdGFnKHMpIHdlcmUgY3JlYXRlZC5cclxuICAgICAqL1xyXG4gICAgY29tbWl0KGlucHV0OiBzdHJpbmcpOiBib29sZWFuIHtcclxuICAgICAgICBpZiAoaW5wdXQgJiYgdGhpcy5mcmVlSW5wdXQpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFNwbGl0IHRoZSB0YWdzIGJ5IHRoZSB0YWdEZWxpbWl0ZXJzIGlmIGNvbmZpZ3VyZWRcclxuICAgICAgICAgICAgY29uc3QgbmV3VGFncyA9IHRoaXMuc3BsaXRUYWdJbnB1dChpbnB1dCk7XHJcblxyXG4gICAgICAgICAgICAvLyBDaGVjayB0YWcgdmFsaWRhdGlvbiBmb3IgYWxsIG9mIHRoZSBpbmRpdmlkdWFsIHZhbHVlc1xyXG4gICAgICAgICAgICBsZXQgYWxsVmFsaWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBuZXdUYWcgb2YgbmV3VGFncykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsaWQgPSB0aGlzLnZhbGlkYXRlVGFnKG5ld1RhZyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXZhbGlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWxsVmFsaWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQWRkIHRoZSB0YWdzIGlmIGFsbCBhcmUgdmFsaWRcclxuICAgICAgICAgICAgaWYgKGFsbFZhbGlkKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBuZXdUYWcgb2YgbmV3VGFncykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkVGFnKHRoaXMuY3JlYXRlVGFnKG5ld1RhZykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJZiBubyB0YWcgaXMgc2VsZWN0ZWQsIHNlbGVjdCB0aGUgcmlnaHRtb3N0IHRhZy4gSWYgYSB0YWcgaXMgc2VsZWN0ZWQsIHJlbW92ZSBpdC5cclxuICAgICAqL1xyXG4gICAgYmFja3NwYWNlKCkge1xyXG5cclxuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkgeyByZXR1cm47IH1cclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWRUYWdJbmRleCh0aGlzLnNlbGVjdGVkSW5kZXgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0VGFnQXQodGhpcy50YWdzLmxlbmd0aCAtIDEpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlVGFnQXQodGhpcy5zZWxlY3RlZEluZGV4KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNb3ZlIHRoZSBoaWdobGlnaHRlZCBvcHRpb24gZm9yd2FyZHMgb3IgYmFja3dhcmRzIGluIHRoZSBsaXN0LiBXcmFwcyBhdCB0aGUgbGltaXRzLlxyXG4gICAgICogQHBhcmFtIGQgVmFsdWUgdG8gYmUgYWRkZWQgdG8gdGhlIHNlbGVjdGVkIGluZGV4LCBpLmUuIC0xIHRvIG1vdmUgYmFja3dhcmRzLCArMSB0byBtb3ZlIGZvcndhcmRzLlxyXG4gICAgICovXHJcbiAgICBtb3ZlU2VsZWN0aW9uKGQ6IG51bWJlcikge1xyXG5cclxuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkgeyByZXR1cm47IH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuaXNWYWxpZFNlbGVjdEluZGV4KHRoaXMuc2VsZWN0ZWRJbmRleCkpIHtcclxuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEluZGV4ICs9IGQ7XHJcblxyXG4gICAgICAgICAgICAvLyBEbyB3cmFwcGluZyBvZiBzZWxlY3Rpb24gd2hlbiBvdXQgb2YgYm91bmRzXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGVkSW5kZXggPCAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkSW5kZXggPSB0aGlzLnRhZ3MubGVuZ3RoO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2VsZWN0ZWRJbmRleCA+IHRoaXMudGFncy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgdmFsdWUgdG8gZGlzcGxheSBmb3IgdGhlIGdpdmVuIHRhZy4gVXNlcyBkaXNwbGF5IGZ1bmN0aW9uL3Byb3BlcnR5IG5hbWUgaWYgc2V0LCBvdGhlcndpc2UgYXNzdW1lcyB0aGF0IHRoZSB0YWcgaXMgYSBzaW1wbGUgc3RyaW5nLlxyXG4gICAgICovXHJcbiAgICBnZXRUYWdEaXNwbGF5KHRhZzogYW55KTogc3RyaW5nIHtcclxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuZGlzcGxheSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kaXNwbGF5KHRhZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5kaXNwbGF5ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGFnWzxzdHJpbmc+dGhpcy5kaXNwbGF5XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRhZztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gaW5kZXggaXMgc2VsZWN0ZWQgKHRhZyBpbmRleCBvciBpbnB1dCBmaWVsZCkuXHJcbiAgICAgKi9cclxuICAgIGlzU2VsZWN0ZWQoaW5kZXg6IG51bWJlcik6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiBpbmRleCA9PT0gdGhpcy5zZWxlY3RlZEluZGV4O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2VsZWN0IHRoZSB0YWcgYXQgdGhlIGdpdmVuIGluZGV4LiBEb2VzIG5vdGhpbmcgaWYgZGlzYWJsZWQgaXMgdHJ1ZS5cclxuICAgICAqL1xyXG4gICAgc2VsZWN0VGFnQXQodGFnSW5kZXg6IG51bWJlcikge1xyXG5cclxuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkgeyByZXR1cm47IH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuaXNWYWxpZFRhZ0luZGV4KHRhZ0luZGV4KSkge1xyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkSW5kZXggPSB0YWdJbmRleDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZWxlY3QgdGhlIGlucHV0IGZpZWxkLCBnaXZpbmcgaXQgZm9jdXMuIERvZXMgbm90aGluZyBpZiBkaXNhYmxlZCBpcyB0cnVlLlxyXG4gICAgICovXHJcbiAgICBzZWxlY3RJbnB1dCgpIHtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IHRoaXMudGFncy5sZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmUgdGhlIHRhZyBhdCB0aGUgZ2l2ZW4gaW5kZXguIERvZXMgbm90aGluZyBpZiBkaXNhYmxlZCBpcyB0cnVlIG9yIHRoZSBtaW5UYWdzIHByb3BlcnR5IHByZXZlbnRzIHJlbW92YWwuXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZVRhZ0F0KHRhZ0luZGV4OiBudW1iZXIpIHtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQgfHwgIXRoaXMuY2FuUmVtb3ZlVGFnQXQodGFnSW5kZXgpKSB7IHJldHVybjsgfVxyXG5cclxuICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSB0YWdJbmRleCBpcyBpbiByYW5nZVxyXG4gICAgICAgIGlmICh0aGlzLmlzVmFsaWRUYWdJbmRleCh0YWdJbmRleCkpIHtcclxuICAgICAgICAgICAgY29uc3QgdGFnID0gdGhpcy50YWdzW3RhZ0luZGV4XTtcclxuICAgICAgICAgICAgY29uc3QgdGFnUmVtb3ZpbmdFdmVudCA9IG5ldyBUYWdJbnB1dEV2ZW50KHRhZyk7XHJcbiAgICAgICAgICAgIHRoaXMudGFnUmVtb3ZpbmcuZW1pdCh0YWdSZW1vdmluZ0V2ZW50KTtcclxuICAgICAgICAgICAgaWYgKCF0YWdSZW1vdmluZ0V2ZW50LmRlZmF1bHRQcmV2ZW50ZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gU2VsZWN0IGlucHV0IGZpcnN0IHRvIGF2b2lkIGlzc3VlcyB3aXRoIGRyb3BwaW5nIGZvY3VzXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdElucHV0KCk7XHJcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHRhZ1xyXG4gICAgICAgICAgICAgICAgdGhpcy50YWdzLnNwbGljZSh0YWdJbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICAvLyBTZXQgZm9jdXMgYWdhaW4gc2luY2UgaW5kaWNlcyBoYXZlIGNoYW5nZWRcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0SW5wdXQoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudGFnUmVtb3ZlZC5lbWl0KG5ldyBUYWdJbnB1dEV2ZW50KHRhZykpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy52YWxpZGF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSB0YWcgYXQgdGhlIGdpdmVuIGluZGV4IGNhbiBiZSByZW1vdmVkLlxyXG4gICAgICovXHJcbiAgICBjYW5SZW1vdmVUYWdBdCh0YWdJbmRleDogbnVtYmVyKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGFncy5sZW5ndGggPiB0aGlzLm1pblRhZ3MgfHwgIXRoaXMuZW5mb3JjZVRhZ0xpbWl0cztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgaW5wdXQgZmllbGQgc2hvdWxkIGJlIGF2YWlsYWJsZS5cclxuICAgICAqL1xyXG4gICAgaXNJbnB1dFZpc2libGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGFncy5sZW5ndGggPCB0aGlzLm1heFRhZ3MgfHwgIXRoaXMuZW5mb3JjZVRhZ0xpbWl0cztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBhbnkgcGFydCBvZiB0aGUgY29udHJvbCBoYXMgZm9jdXMuXHJcbiAgICAgKi9cclxuICAgIGhhc0ZvY3VzKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWRTZWxlY3RJbmRleCh0aGlzLnNlbGVjdGVkSW5kZXgpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgY29ubmVjdFR5cGVhaGVhZCh0eXBlYWhlYWQ6IFR5cGVhaGVhZENvbXBvbmVudCkge1xyXG4gICAgICAgIGlmICh0aGlzLl90eXBlYWhlYWRTdWJzY3JpcHRpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5fdHlwZWFoZWFkU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3R5cGVhaGVhZFN1YnNjcmlwdGlvbiA9IG51bGw7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnR5cGVhaGVhZCA9IHR5cGVhaGVhZDtcclxuICAgICAgICBpZiAodGhpcy50eXBlYWhlYWQpIHtcclxuICAgICAgICAgICAgLy8gU2V0IHVwIGV2ZW50IGhhbmRsZXIgZm9yIHNlbGVjdGVkIG9wdGlvbnNcclxuICAgICAgICAgICAgdGhpcy5fdHlwZWFoZWFkU3Vic2NyaXB0aW9uID0gdGhpcy50eXBlYWhlYWQub3B0aW9uU2VsZWN0ZWQuc3Vic2NyaWJlKHRoaXMudHlwZWFoZWFkT3B0aW9uU2VsZWN0ZWRIYW5kbGVyLmJpbmQodGhpcykpO1xyXG5cclxuICAgICAgICAgICAgLy8gU2V0IHVwIGV2ZW50IGhhbmRsZXIgZm9yIHRoZSBoaWdobGlnaHRlZCBlbGVtZW50XHJcbiAgICAgICAgICAgIC8vIEFkZGVkIGEgZGVsYXkgdG8gbW92ZSBpdCBvdXQgb2YgdGhlIGN1cnJlbnQgY2hhbmdlIGRldGVjdGlvbiBjeWNsZVxyXG4gICAgICAgICAgICB0aGlzLl90eXBlYWhlYWRTdWJzY3JpcHRpb24uYWRkKFxyXG4gICAgICAgICAgICAgICAgdGhpcy50eXBlYWhlYWQuaGlnaGxpZ2h0ZWRFbGVtZW50Q2hhbmdlLnBpcGUoZGVsYXkoMCkpLnN1YnNjcmliZSgoZWxlbWVudDogSFRNTEVsZW1lbnQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodGVkRWxlbWVudCA9IGVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFZhbGlkYXRlIHRoZSBnaXZlbiB0YWdWYWx1ZSB3aXRoIHRoZSB0YWdQYXR0ZXJuLCBpZiBzZXQuIFVwZGF0ZSB2YWxpZGF0aW9uRXJyb3JzIG9uIHZhbGlkYXRpb24gZmFpbHVyZS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSB2YWxpZGF0ZVRhZyh0YWdWYWx1ZTogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgICAgICAgbGV0IGlucHV0UGF0dGVybiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5pbnB1dFZhbGlkID0gdHJ1ZTtcclxuICAgICAgICBpZiAodGhpcy50YWdQYXR0ZXJuICYmICF0aGlzLnRhZ1BhdHRlcm4udGVzdCh0YWdWYWx1ZSkpIHtcclxuICAgICAgICAgICAgaW5wdXRQYXR0ZXJuID0ge1xyXG4gICAgICAgICAgICAgICAgZ2l2ZW46IHRhZ1ZhbHVlLFxyXG4gICAgICAgICAgICAgICAgcGF0dGVybjogdGhpcy50YWdQYXR0ZXJuXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuaW5wdXRWYWxpZCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnZhbGlkYXRpb25FcnJvcnNbJ2lucHV0UGF0dGVybiddID0gaW5wdXRQYXR0ZXJuO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmlucHV0VmFsaWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSB0YWcgb2JqZWN0IGZvciB0aGUgZ2l2ZW4gdGFnVmFsdWUuIElmIGNyZWF0ZVRhZ0hhbmRsZXIgaXMgc3BlY2lmaWVkLCB1c2UgaXQ7IG90aGVyd2lzZSBpZiBkaXNwbGF5UHJvcGVydHkgaXMgc3BlY2lmaWVkLCBjcmVhdGUgYW4gb2JqZWN0IHdpdGggdGhlIHRhZ1ZhbHVlIGFzIHRoZSBzaW5nbGUgbmFtZWQgcHJvcGVydHk7IG90aGVyd2lzZSByZXR1cm4gdGhlIHRhZ1ZhbHVlIGl0c2VsZi5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBjcmVhdGVUYWcodGFnVmFsdWU6IHN0cmluZyk6IGFueSB7XHJcbiAgICAgICAgbGV0IHRhZyA9IG51bGw7XHJcbiAgICAgICAgaWYgKHRoaXMuY3JlYXRlVGFnSGFuZGxlciAmJiB0eXBlb2YgdGhpcy5jcmVhdGVUYWdIYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHRhZyA9IHRoaXMuY3JlYXRlVGFnSGFuZGxlcih0YWdWYWx1ZSk7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5kaXNwbGF5ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB0YWcgPSB7fTtcclxuICAgICAgICAgICAgdGFnWzxzdHJpbmc+dGhpcy5kaXNwbGF5XSA9IHRhZ1ZhbHVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRhZyA9IHRhZ1ZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGFnO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgdGFnIG9iamVjdCwgY2FsbGluZyB0aGUgdGFnQWRkaW5nIGFuZCB0YWdBZGRlZCBldmVudHMuIFJldHVybnMgdHJ1ZSBpZiB0aGUgdGFnIHdhcyBhZGRlZCB0byB0aGUgdGFncyBhcnJheS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBhZGRUYWcodGFnOiBhbnkpOiBib29sZWFuIHtcclxuICAgICAgICBpZiAodGFnKSB7XHJcbiAgICAgICAgICAgIC8vIFZlcmlmeSB0aGF0IHRoZSBuZXcgdGFnIGNhbiBiZSBkaXNwbGF5ZWRcclxuICAgICAgICAgICAgY29uc3QgZGlzcGxheVZhbHVlID0gdGhpcy5nZXRUYWdEaXNwbGF5KHRhZyk7XHJcbiAgICAgICAgICAgIGlmIChkaXNwbGF5VmFsdWUgJiYgdHlwZW9mIGRpc3BsYXlWYWx1ZSA9PT0gJ3N0cmluZycgJiYgZGlzcGxheVZhbHVlLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRhZ0FkZGluZ0V2ZW50ID0gbmV3IFRhZ0lucHV0RXZlbnQodGFnKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudGFnQWRkaW5nLmVtaXQodGFnQWRkaW5nRXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0YWdBZGRpbmdFdmVudC5kZWZhdWx0UHJldmVudGVkKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRhZ3MgPSB0aGlzLnRhZ3MgfHwgW107XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YWdzLnB1c2godGFnKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRhZ0FkZGVkLmVtaXQobmV3IFRhZ0lucHV0RXZlbnQodGFnKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWxpZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHRhZ0luZGV4IGlzIGEgdmFsaWQgdGFnIGluZGV4LlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGlzVmFsaWRUYWdJbmRleCh0YWdJbmRleDogbnVtYmVyKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRhZ0luZGV4ID49IDAgJiYgdGFnSW5kZXggPCB0aGlzLnRhZ3MubGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBpbmRleCBpcyBhIHZhbGlkIHNlbGVjdGlvbiBpbmRleCAodGFncyBvciBpbnB1dCBmaWVsZCkuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgaXNWYWxpZFNlbGVjdEluZGV4KGluZGV4OiBudW1iZXIpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gaW5kZXggPj0gMCAmJiBpbmRleCA8PSB0aGlzLnRhZ3MubGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY2hhcmFjdGVyIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGtleSBldmVudCwgbWFpbmx5IGZvciBJRSBjb21wYXRpYmlsaXR5LlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGdldEtleUNoYXIoZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiBzdHJpbmcge1xyXG4gICAgICAgIHN3aXRjaCAoZXZlbnQua2V5KSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ1NwYWNlYmFyJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiAnICc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBldmVudC5rZXk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHN0cmluZ3MgY29ycmVzcG9uZGluZyB0byB0aGUgaW5wdXQgc3RyaW5nIHNwbGl0IGJ5IHRoZSB0YWdEZWxpbWl0ZXJzIGNoYXJhY3RlcnMuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc3BsaXRUYWdJbnB1dChpbnB1dDogc3RyaW5nKTogc3RyaW5nW10ge1xyXG4gICAgICAgIGxldCB0YWdWYWx1ZXMgPSBbaW5wdXRdO1xyXG4gICAgICAgIGlmICh0aGlzLnRhZ0RlbGltaXRlcnMgJiYgdHlwZW9mIHRoaXMudGFnRGVsaW1pdGVycyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgY29uc3QgZXNjYXBlZERlbGltaXRlcnMgPSB0aGlzLnRhZ0RlbGltaXRlcnMucmVwbGFjZSgvWy1cXC9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGRlbGltaXRlclJlZ2V4ID0gbmV3IFJlZ0V4cChgWyR7ZXNjYXBlZERlbGltaXRlcnN9XWAsICdnJyk7XHJcbiAgICAgICAgICAgIHRhZ1ZhbHVlcyA9IGlucHV0LnNwbGl0KGRlbGltaXRlclJlZ2V4KS5maWx0ZXIoKHMpID0+IHMubGVuZ3RoID4gMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0YWdWYWx1ZXM7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgQVBJIGF2YWlsYWJsZSB0byB0YWcgdGVtcGxhdGVzLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBUYWdBcGkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBkaXNwbGF5IHZhbHVlIG9mIHRoZSBnaXZlbiB0YWcsIGFjY29yZGluZyB0byB0aGUgZGlzcGxheVByb3BlcnR5IHByb3BlcnR5LlxyXG4gICAgICovXHJcbiAgICBnZXRUYWdEaXNwbGF5OiAodGFnOiBhbnkpID0+IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgdGhlIHRhZyBhdCB0aGUgZ2l2ZW4gaW5kZXgsIGlmIHBvc3NpYmxlLlxyXG4gICAgICovXHJcbiAgICByZW1vdmVUYWdBdDogKGluZGV4OiBudW1iZXIpID0+IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBcdFJldHVybnMgdHJ1ZSBpZiB0aGUgdGFnIGF0IHRoZSBnaXZlbiBpbmRleCBjYW4gYmUgcmVtb3ZlZC5cclxuICAgICAqL1xyXG4gICAgY2FuUmVtb3ZlVGFnQXQ6IChpbmRleDogbnVtYmVyKSA9PiBib29sZWFuO1xyXG59XHJcblxyXG4vKipcclxuICogVGhlIGZ1bmN0aW9uIHVzZWQgdG8gcmV0dXJuIGN1c3RvbSBjbGFzcyBpbmZvcm1hdGlvbiwgZm9yIHVzZSBpbiBgbmdDbGFzc2AuXHJcbiAqL1xyXG5leHBvcnQgdHlwZSBUYWdDbGFzc0Z1bmN0aW9uID0gKHRhZzogYW55LCBpbmRleDogbnVtYmVyLCBzZWxlY3RlZDogYm9vbGVhbikgPT4gKHN0cmluZyB8IHN0cmluZ1tdIHwgU2V0PHN0cmluZz4pOyIsImltcG9ydCB7IEZvY3VzSWZNb2R1bGUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL2ZvY3VzLWlmL2luZGV4JztcbmltcG9ydCB7IFR5cGVhaGVhZE1vZHVsZSB9IGZyb20gJy4uL3R5cGVhaGVhZC9pbmRleCc7XG5pbXBvcnQgeyBUYWdJbnB1dENvbXBvbmVudCB9IGZyb20gJy4vdGFnLWlucHV0LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZvcm1zTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgRm9jdXNJZk1vZHVsZSxcbiAgICAgICAgVHlwZWFoZWFkTW9kdWxlXG4gICAgXSxcbiAgICBleHBvcnRzOiBbVGFnSW5wdXRDb21wb25lbnRdLFxuICAgIGRlY2xhcmF0aW9uczogW1RhZ0lucHV0Q29tcG9uZW50XSxcbiAgICBwcm92aWRlcnM6IFtdLFxufSlcbmV4cG9ydCBjbGFzcyBUYWdJbnB1dE1vZHVsZSB7IH1cbiIsImltcG9ydCB7IEluZmluaXRlU2Nyb2xsTW9kdWxlIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9pbmZpbml0ZS1zY3JvbGwvaW5kZXgnO1xuaW1wb3J0IHsgVGFnSW5wdXRNb2R1bGUgfSBmcm9tICcuLi90YWctaW5wdXQvaW5kZXgnO1xuaW1wb3J0IHsgVHlwZWFoZWFkTW9kdWxlIH0gZnJvbSAnLi4vdHlwZWFoZWFkL2luZGV4JztcbmltcG9ydCB7IFNlbGVjdENvbXBvbmVudCB9IGZyb20gJy4vc2VsZWN0LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZvcm1zTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgSW5maW5pdGVTY3JvbGxNb2R1bGUsXG4gICAgICAgIFRhZ0lucHV0TW9kdWxlLFxuICAgICAgICBUeXBlYWhlYWRNb2R1bGVcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtTZWxlY3RDb21wb25lbnRdLFxuICAgIGRlY2xhcmF0aW9uczogW1NlbGVjdENvbXBvbmVudF1cbn0pXG5leHBvcnQgY2xhc3MgU2VsZWN0TW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZvcm1zTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IFNlYXJjaEJ1aWxkZXJDb21wb25lbnQgfSBmcm9tICcuL3NlYXJjaC1idWlsZGVyLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBTZWFyY2hCdWlsZGVyR3JvdXBDb21wb25lbnQgfSBmcm9tICcuL3NlYXJjaC1idWlsZGVyLWdyb3VwL3NlYXJjaC1idWlsZGVyLWdyb3VwLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBTZWFyY2hUZXh0Q29tcG9uZW50IH0gZnJvbSAnLi9zZWFyY2gtY29tcG9uZW50cy90ZXh0L3RleHQuY29tcG9uZW50JztcbmltcG9ydCB7IFNlYXJjaERhdGVDb21wb25lbnQgfSBmcm9tICcuL3NlYXJjaC1jb21wb25lbnRzL2RhdGUvZGF0ZS5jb21wb25lbnQnO1xuaW1wb3J0IHsgU2VhcmNoQnVpbGRlck91dGxldERpcmVjdGl2ZSB9IGZyb20gJy4vc2VhcmNoLWJ1aWxkZXItb3V0bGV0L3NlYXJjaC1idWlsZGVyLW91dGxldC5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgQmFzZVNlYXJjaENvbXBvbmVudCB9IGZyb20gJy4vc2VhcmNoLWNvbXBvbmVudHMvYmFzZS1zZWFyY2guY29tcG9uZW50JztcbmltcG9ydCB7IERhdGVUaW1lUGlja2VyTW9kdWxlIH0gZnJvbSAnLi4vZGF0ZS10aW1lLXBpY2tlci9kYXRlLXRpbWUtcGlja2VyLm1vZHVsZSc7XG5pbXBvcnQgeyBTZWFyY2hEYXRlUmFuZ2VDb21wb25lbnQgfSBmcm9tICcuL3NlYXJjaC1jb21wb25lbnRzL2RhdGUtcmFuZ2UvZGF0ZS1yYW5nZS5jb21wb25lbnQnO1xuaW1wb3J0IHsgU2VhcmNoU2VsZWN0Q29tcG9uZW50IH0gZnJvbSAnLi9zZWFyY2gtY29tcG9uZW50cy9zZWxlY3Qvc2VsZWN0LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBTZWxlY3RNb2R1bGUgfSBmcm9tICcuLi9zZWxlY3QvaW5kZXgnO1xuaW1wb3J0IHsgUG9wb3Zlck1vZHVsZSB9IGZyb20gJy4uL3BvcG92ZXIvaW5kZXgnO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbXG4gICAgQ29tbW9uTW9kdWxlLFxuICAgIEZvcm1zTW9kdWxlLFxuICAgIERhdGVUaW1lUGlja2VyTW9kdWxlLFxuICAgIFBvcG92ZXJNb2R1bGUsXG4gICAgU2VsZWN0TW9kdWxlXG4gIF0sXG4gIGV4cG9ydHM6IFtcbiAgICBTZWFyY2hCdWlsZGVyQ29tcG9uZW50LFxuICAgIFNlYXJjaEJ1aWxkZXJHcm91cENvbXBvbmVudCxcbiAgICBCYXNlU2VhcmNoQ29tcG9uZW50XG4gIF0sXG4gIGRlY2xhcmF0aW9uczogW1xuICAgIFNlYXJjaEJ1aWxkZXJDb21wb25lbnQsXG4gICAgU2VhcmNoQnVpbGRlckdyb3VwQ29tcG9uZW50LFxuICAgIFNlYXJjaFRleHRDb21wb25lbnQsXG4gICAgU2VhcmNoRGF0ZUNvbXBvbmVudCxcbiAgICBTZWFyY2hEYXRlUmFuZ2VDb21wb25lbnQsXG4gICAgU2VhcmNoQnVpbGRlck91dGxldERpcmVjdGl2ZSxcbiAgICBTZWFyY2hTZWxlY3RDb21wb25lbnQsXG4gICAgQmFzZVNlYXJjaENvbXBvbmVudFxuICBdLFxuICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICBTZWFyY2hUZXh0Q29tcG9uZW50LFxuICAgIFNlYXJjaERhdGVDb21wb25lbnQsXG4gICAgU2VhcmNoRGF0ZVJhbmdlQ29tcG9uZW50LFxuICAgIFNlYXJjaFNlbGVjdENvbXBvbmVudFxuICBdXG59KVxuZXhwb3J0IGNsYXNzIFNlYXJjaEJ1aWxkZXJNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEhvc3RMaXN0ZW5lciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU2lkZVBhbmVsU2VydmljZSB9IGZyb20gJy4vc2lkZS1wYW5lbC5zZXJ2aWNlJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbdXhTaWRlUGFuZWxDbG9zZV0nXG59KVxuZXhwb3J0IGNsYXNzIFNpZGVQYW5lbENsb3NlRGlyZWN0aXZlIHtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX3NlcnZpY2U6IFNpZGVQYW5lbFNlcnZpY2UpIHsgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcignY2xpY2snKVxuICAgIGNsaWNrSGFuZGxlcigpIHtcbiAgICAgICAgdGhpcy5fc2VydmljZS5jbG9zZSgpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcblxuaW1wb3J0IHsgU2lkZVBhbmVsQ29tcG9uZW50IH0gZnJvbSAnLi9zaWRlLXBhbmVsLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBTaWRlUGFuZWxDbG9zZURpcmVjdGl2ZSB9IGZyb20gJy4vc2lkZS1wYW5lbC1jbG9zZS5kaXJlY3RpdmUnO1xuXG5jb25zdCBFWFBPUlRTID0gW1xuICAgIFNpZGVQYW5lbENvbXBvbmVudCxcbiAgICBTaWRlUGFuZWxDbG9zZURpcmVjdGl2ZVxuXTtcblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZVxuICAgIF0sXG4gICAgZXhwb3J0czogRVhQT1JUUyxcbiAgICBkZWNsYXJhdGlvbnM6IEVYUE9SVFNcbn0pXG5leHBvcnQgY2xhc3MgU2lkZVBhbmVsTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgQWZ0ZXJWaWV3SW5pdCwgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENoYW5nZURldGVjdG9yUmVmLCBDb21wb25lbnQsIERvQ2hlY2ssIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE9uSW5pdCwgT3V0cHV0LCBWaWV3Q2hpbGQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbG9yU2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2NvbG9yL2luZGV4JztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1zbGlkZXInLFxuICAgIHRlbXBsYXRlOiBgPGRpdiBjbGFzcz1cInRyYWNrXCIgI3RyYWNrIFtjbGFzcy5uYXJyb3ddPVwib3B0aW9ucy50cmFjay5oZWlnaHQgPT09IHNsaWRlclNpemUuTmFycm93XCIgW2NsYXNzLndpZGVdPVwib3B0aW9ucy50cmFjay5oZWlnaHQgPT09IHNsaWRlclNpemUuV2lkZVwiIFtjbGFzcy5yYW5nZV09XCJvcHRpb25zLnR5cGUgPT09IHNsaWRlclR5cGUuUmFuZ2VcIj5cblxuICAgIDwhLS0gU2VjdGlvbiBCZW5lYXRoIExvd2VyIFRodW1iIC0tPlxuICAgIDxkaXYgY2xhc3M9XCJ0cmFjay1zZWN0aW9uIHRyYWNrLWxvd2VyXCIgW3N0eWxlLmZsZXgtZ3Jvd109XCJ0cmFja3MubG93ZXIuc2l6ZVwiIFtzdHlsZS5iYWNrZ3JvdW5kXT1cInRyYWNrcy5sb3dlci5jb2xvclwiPjwvZGl2PlxuXG4gICAgPCEtLSBMb3dlciBUaHVtYiBCdXR0b24gLyBMaW5lIC0tPlxuICAgIDxkaXYgY2xhc3M9XCJ0aHVtYiBsb3dlclwiXG4gICAgICAgIHV4RHJhZ1xuICAgICAgICByb2xlPVwic2xpZGVyXCJcbiAgICAgICAgdGFiaW5kZXg9XCIwXCJcbiAgICAgICAgI2xvd2VydGh1bWJcbiAgICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XCJvcHRpb25zLnR5cGUgPT09IHNsaWRlclR5cGUuUmFuZ2UgPyBvcHRpb25zLmhhbmRsZXMuYXJpYS5sb3dlclRodW1iIDogb3B0aW9ucy5oYW5kbGVzLmFyaWEudGh1bWJcIlxuICAgICAgICBbYXR0ci5hcmlhLXZhbHVlbWluXT1cIm9wdGlvbnM/LnRyYWNrPy5taW5cIlxuICAgICAgICBbYXR0ci5hcmlhLXZhbHVlbWF4XT1cIm9wdGlvbnMudHlwZSA9PT0gc2xpZGVyVHlwZS5SYW5nZSA/IGdldFRodW1iVmFsdWUoc2xpZGVyVGh1bWIuVXBwZXIpIDogb3B0aW9ucz8udHJhY2s/Lm1heFwiXG4gICAgICAgIFthdHRyLmFyaWEtdmFsdWVub3ddPVwiZ2V0VGh1bWJWYWx1ZShzbGlkZXJUaHVtYi5Mb3dlcilcIlxuICAgICAgICBbYXR0ci5hcmlhLXZhbHVldGV4dF09XCJnZXRBcmlhVmFsdWVUZXh0KHNsaWRlclRodW1iLkxvd2VyKVwiXG4gICAgICAgIFtzdHlsZS5sZWZ0LiVdPVwidGh1bWJzLmxvd2VyLnBvc2l0aW9uXCJcbiAgICAgICAgW2NsYXNzLmFjdGl2ZV09XCJ0aHVtYnMubG93ZXIuZHJhZ1wiXG4gICAgICAgIFtzdHlsZS56LWluZGV4XT1cInRodW1icy5sb3dlci5vcmRlclwiXG4gICAgICAgIFtjbGFzcy5idXR0b25dPVwib3B0aW9ucy5oYW5kbGVzLnN0eWxlID09PSBzbGlkZXJTdHlsZS5CdXR0b25cIlxuICAgICAgICBbY2xhc3MubGluZV09XCJvcHRpb25zLmhhbmRsZXMuc3R5bGUgPT09IHNsaWRlclN0eWxlLkxpbmVcIlxuICAgICAgICBbY2xhc3MubmFycm93XT1cIm9wdGlvbnMudHJhY2suaGVpZ2h0ID09PSBzbGlkZXJTaXplLk5hcnJvd1wiXG4gICAgICAgIFtjbGFzcy53aWRlXT1cIm9wdGlvbnMudHJhY2suaGVpZ2h0ID09PSBzbGlkZXJTaXplLldpZGVcIlxuICAgICAgICAoZHJhZ3N0YXJ0KT1cInRodW1iRXZlbnQoc2xpZGVyVGh1bWIuTG93ZXIsIHNsaWRlclRodW1iRXZlbnQuRHJhZ1N0YXJ0KTsgbG93ZXJ0aHVtYi5mb2N1cygpXCJcbiAgICAgICAgKGRyYWcpPVwidXBkYXRlVGh1bWJQb3NpdGlvbigkZXZlbnQsIHNsaWRlclRodW1iLkxvd2VyKVwiXG4gICAgICAgIChkcmFnZW5kKT1cInRodW1iRXZlbnQoc2xpZGVyVGh1bWIuTG93ZXIsIHNsaWRlclRodW1iRXZlbnQuRHJhZ0VuZClcIlxuICAgICAgICAobW91c2VlbnRlcik9XCJ0aHVtYkV2ZW50KHNsaWRlclRodW1iLkxvd2VyLCBzbGlkZXJUaHVtYkV2ZW50Lk1vdXNlT3ZlcilcIlxuICAgICAgICAobW91c2VsZWF2ZSk9XCJ0aHVtYkV2ZW50KHNsaWRlclRodW1iLkxvd2VyLCBzbGlkZXJUaHVtYkV2ZW50Lk1vdXNlTGVhdmUpXCJcbiAgICAgICAgKGZvY3VzKT1cInRodW1iRXZlbnQoc2xpZGVyVGh1bWIuTG93ZXIsIHNsaWRlclRodW1iRXZlbnQuTW91c2VPdmVyKVwiXG4gICAgICAgIChibHVyKT1cInRodW1iRXZlbnQoc2xpZGVyVGh1bWIuTG93ZXIsIHNsaWRlclRodW1iRXZlbnQuTW91c2VMZWF2ZSlcIlxuICAgICAgICAoa2V5ZG93bi5BcnJvd0xlZnQpPVwic25hcFRvTmVhcmVzdFRpY2soc2xpZGVyVGh1bWIuTG93ZXIsIHNsaWRlclNuYXAuQWxsLCBmYWxzZSk7ICRldmVudC5wcmV2ZW50RGVmYXVsdCgpXCJcbiAgICAgICAgKGtleWRvd24uQXJyb3dSaWdodCk9XCJzbmFwVG9OZWFyZXN0VGljayhzbGlkZXJUaHVtYi5Mb3dlciwgc2xpZGVyU25hcC5BbGwsIHRydWUpOyAkZXZlbnQucHJldmVudERlZmF1bHQoKVwiXG4gICAgICAgIChrZXlkb3duLkFycm93VXApPVwic25hcFRvTmVhcmVzdFRpY2soc2xpZGVyVGh1bWIuTG93ZXIsIHNsaWRlclNuYXAuQWxsLCBmYWxzZSk7ICRldmVudC5wcmV2ZW50RGVmYXVsdCgpXCJcbiAgICAgICAgKGtleWRvd24uQXJyb3dEb3duKT1cInNuYXBUb05lYXJlc3RUaWNrKHNsaWRlclRodW1iLkxvd2VyLCBzbGlkZXJTbmFwLkFsbCwgdHJ1ZSk7ICRldmVudC5wcmV2ZW50RGVmYXVsdCgpXCJcbiAgICAgICAgKGtleWRvd24uUGFnZURvd24pPVwic25hcFRvTmVhcmVzdFRpY2soc2xpZGVyVGh1bWIuTG93ZXIsIHNsaWRlclNuYXAuTWFqb3IsIGZhbHNlKTsgJGV2ZW50LnByZXZlbnREZWZhdWx0KClcIlxuICAgICAgICAoa2V5ZG93bi5QYWdlVXApPVwic25hcFRvTmVhcmVzdFRpY2soc2xpZGVyVGh1bWIuTG93ZXIsIHNsaWRlclNuYXAuTWFqb3IsIHRydWUpOyAkZXZlbnQucHJldmVudERlZmF1bHQoKVwiXG4gICAgICAgIChrZXlkb3duLkhvbWUpPVwic25hcFRvRW5kKHNsaWRlclRodW1iLkxvd2VyLCBmYWxzZSk7ICRldmVudC5wcmV2ZW50RGVmYXVsdCgpXCJcbiAgICAgICAgKGtleWRvd24uRW5kKT1cInNuYXBUb0VuZChzbGlkZXJUaHVtYi5Mb3dlciwgdHJ1ZSk7ICRldmVudC5wcmV2ZW50RGVmYXVsdCgpXCI+XG5cbiAgICAgICAgPCEtLSBMb3dlciBUaHVtYiBDYWxsb3V0IC0tPlxuICAgICAgICA8ZGl2IGNsYXNzPVwidG9vbHRpcCB0b3AgdG9vbHRpcC1sb3dlclwiICNsb3dlclRvb2x0aXBcbiAgICAgICAgICAgIFtjbGFzcy50b29sdGlwLWR5bmFtaWNdPVwib3B0aW9ucy5oYW5kbGVzLmNhbGxvdXQudHJpZ2dlciA9PT0gc2xpZGVyQ2FsbG91dFRyaWdnZXIuRHluYW1pYyAmJiB0aHVtYnMubG93ZXIuZHJhZyA9PT0gZmFsc2VcIlxuICAgICAgICAgICAgW3N0eWxlLm9wYWNpdHldPVwidG9vbHRpcHMubG93ZXIudmlzaWJsZSA/IDEgOiAwXCJcbiAgICAgICAgICAgIFtzdHlsZS5sZWZ0LnB4XT1cInRvb2x0aXBzLmxvd2VyLnBvc2l0aW9uXCI+XG5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0b29sdGlwLWFycm93XCIgW3N0eWxlLmJvcmRlci10b3AtY29sb3JdPVwib3B0aW9ucy5oYW5kbGVzLmNhbGxvdXQuYmFja2dyb3VuZFwiPjwvZGl2PlxuXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwidG9vbHRpcC1pbm5lclwiXG4gICAgICAgICAgICAgICAgW3N0eWxlLmJhY2tncm91bmQtY29sb3JdPVwib3B0aW9ucy5oYW5kbGVzLmNhbGxvdXQuYmFja2dyb3VuZFwiXG4gICAgICAgICAgICAgICAgW3N0eWxlLmNvbG9yXT1cIm9wdGlvbnMuaGFuZGxlcy5jYWxsb3V0LmNvbG9yXCI+XG4gICAgICAgICAgICAgICAge3sgdG9vbHRpcHMubG93ZXIubGFiZWwgfX1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cblxuICAgIDwvZGl2PlxuXG4gICAgPCEtLSBTZWN0aW9uIG9mIFRyYWNrIEJldHdlZW4gTG93ZXIgYW5kIFVwcGVyIFRodW1icyAtLT5cbiAgICA8ZGl2IGNsYXNzPVwidHJhY2stc2VjdGlvbiB0cmFjay1yYW5nZVwiICpuZ0lmPVwib3B0aW9ucy50eXBlID09PSBzbGlkZXJUeXBlLlJhbmdlXCIgW3N0eWxlLmZsZXgtZ3Jvd109XCJ0cmFja3MubWlkZGxlLnNpemVcIiBbc3R5bGUuYmFja2dyb3VuZF09XCJ0cmFja3MubWlkZGxlLmNvbG9yXCI+XG4gICAgPC9kaXY+XG5cbiAgICA8IS0tIFVwcGVyIFRodW1iIEJ1dHRvbiAvIExpbmUgLS0+XG4gICAgPGRpdiBjbGFzcz1cInRodW1iIHVwcGVyXCJcbiAgICAgICAgdXhEcmFnXG4gICAgICAgIHJvbGU9XCJzbGlkZXJcIlxuICAgICAgICB0YWJpbmRleD1cIjBcIlxuICAgICAgICAjdXBwZXJ0aHVtYlxuICAgICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cIm9wdGlvbnMuaGFuZGxlcy5hcmlhLnVwcGVyVGh1bWJcIlxuICAgICAgICBbYXR0ci5hcmlhLXZhbHVlbWluXT1cImdldFRodW1iVmFsdWUoc2xpZGVyVGh1bWIuTG93ZXIpIHx8IG9wdGlvbnM/LnRyYWNrPy5taW5cIlxuICAgICAgICBbYXR0ci5hcmlhLXZhbHVlbWF4XT1cIm9wdGlvbnM/LnRyYWNrPy5tYXhcIlxuICAgICAgICBbYXR0ci5hcmlhLXZhbHVlbm93XT1cImdldFRodW1iVmFsdWUoc2xpZGVyVGh1bWIuVXBwZXIpXCJcbiAgICAgICAgW2F0dHIuYXJpYS12YWx1ZXRleHRdPVwiZ2V0QXJpYVZhbHVlVGV4dChzbGlkZXJUaHVtYi5VcHBlcilcIlxuICAgICAgICBbaGlkZGVuXT1cIm9wdGlvbnMudHlwZSAhPT0gc2xpZGVyVHlwZS5SYW5nZVwiXG4gICAgICAgIFtjbGFzcy5hY3RpdmVdPVwidGh1bWJzLnVwcGVyLmRyYWdcIlxuICAgICAgICBbc3R5bGUubGVmdC4lXT1cInRodW1icy51cHBlci5wb3NpdGlvblwiXG4gICAgICAgIFtzdHlsZS56LWluZGV4XT1cInRodW1icy51cHBlci5vcmRlclwiXG4gICAgICAgIFtjbGFzcy5idXR0b25dPVwib3B0aW9ucy5oYW5kbGVzLnN0eWxlID09PSBzbGlkZXJTdHlsZS5CdXR0b25cIlxuICAgICAgICBbY2xhc3MubGluZV09XCJvcHRpb25zLmhhbmRsZXMuc3R5bGUgPT09IHNsaWRlclN0eWxlLkxpbmVcIlxuICAgICAgICBbY2xhc3MubmFycm93XT1cIm9wdGlvbnMudHJhY2suaGVpZ2h0ID09PSBzbGlkZXJTaXplLk5hcnJvd1wiXG4gICAgICAgIFtjbGFzcy53aWRlXT1cIm9wdGlvbnMudHJhY2suaGVpZ2h0ID09PSBzbGlkZXJTaXplLldpZGVcIlxuICAgICAgICAoZHJhZ3N0YXJ0KT1cInRodW1iRXZlbnQoc2xpZGVyVGh1bWIuVXBwZXIsIHNsaWRlclRodW1iRXZlbnQuRHJhZ1N0YXJ0KTsgdXBwZXJ0aHVtYi5mb2N1cygpXCJcbiAgICAgICAgKGRyYWcpPVwidXBkYXRlVGh1bWJQb3NpdGlvbigkZXZlbnQsIHNsaWRlclRodW1iLlVwcGVyKVwiXG4gICAgICAgIChkcmFnZW5kKT1cInRodW1iRXZlbnQoc2xpZGVyVGh1bWIuVXBwZXIsIHNsaWRlclRodW1iRXZlbnQuRHJhZ0VuZClcIlxuICAgICAgICAobW91c2VlbnRlcik9XCJ0aHVtYkV2ZW50KHNsaWRlclRodW1iLlVwcGVyLCBzbGlkZXJUaHVtYkV2ZW50Lk1vdXNlT3ZlcilcIlxuICAgICAgICAobW91c2VsZWF2ZSk9XCJ0aHVtYkV2ZW50KHNsaWRlclRodW1iLlVwcGVyLCBzbGlkZXJUaHVtYkV2ZW50Lk1vdXNlTGVhdmUpXCJcbiAgICAgICAgKGZvY3VzKT1cInRodW1iRXZlbnQoc2xpZGVyVGh1bWIuVXBwZXIsIHNsaWRlclRodW1iRXZlbnQuTW91c2VPdmVyKVwiXG4gICAgICAgIChibHVyKT1cInRodW1iRXZlbnQoc2xpZGVyVGh1bWIuVXBwZXIsIHNsaWRlclRodW1iRXZlbnQuTW91c2VMZWF2ZSlcIlxuICAgICAgICAoa2V5ZG93bi5BcnJvd0xlZnQpPVwic25hcFRvTmVhcmVzdFRpY2soc2xpZGVyVGh1bWIuVXBwZXIsIHNsaWRlclNuYXAuQWxsLCBmYWxzZSk7ICRldmVudC5wcmV2ZW50RGVmYXVsdCgpXCJcbiAgICAgICAgKGtleWRvd24uQXJyb3dSaWdodCk9XCJzbmFwVG9OZWFyZXN0VGljayhzbGlkZXJUaHVtYi5VcHBlciwgc2xpZGVyU25hcC5BbGwsIHRydWUpOyAkZXZlbnQucHJldmVudERlZmF1bHQoKVwiXG4gICAgICAgIChrZXlkb3duLkFycm93VXApPVwic25hcFRvTmVhcmVzdFRpY2soc2xpZGVyVGh1bWIuVXBwZXIsIHNsaWRlclNuYXAuQWxsLCBmYWxzZSk7ICRldmVudC5wcmV2ZW50RGVmYXVsdCgpXCJcbiAgICAgICAgKGtleWRvd24uQXJyb3dEb3duKT1cInNuYXBUb05lYXJlc3RUaWNrKHNsaWRlclRodW1iLlVwcGVyLCBzbGlkZXJTbmFwLkFsbCwgdHJ1ZSk7ICRldmVudC5wcmV2ZW50RGVmYXVsdCgpXCJcbiAgICAgICAgKGtleWRvd24uUGFnZURvd24pPVwic25hcFRvTmVhcmVzdFRpY2soc2xpZGVyVGh1bWIuVXBwZXIsIHNsaWRlclNuYXAuTWFqb3IsIGZhbHNlKTsgJGV2ZW50LnByZXZlbnREZWZhdWx0KClcIlxuICAgICAgICAoa2V5ZG93bi5QYWdlVXApPVwic25hcFRvTmVhcmVzdFRpY2soc2xpZGVyVGh1bWIuVXBwZXIsIHNsaWRlclNuYXAuTWFqb3IsIHRydWUpOyAkZXZlbnQucHJldmVudERlZmF1bHQoKVwiXG4gICAgICAgIChrZXlkb3duLkhvbWUpPVwic25hcFRvRW5kKHNsaWRlclRodW1iLlVwcGVyLCBmYWxzZSk7ICRldmVudC5wcmV2ZW50RGVmYXVsdCgpXCJcbiAgICAgICAgKGtleWRvd24uRW5kKT1cInNuYXBUb0VuZChzbGlkZXJUaHVtYi5VcHBlciwgdHJ1ZSk7ICRldmVudC5wcmV2ZW50RGVmYXVsdCgpXCI+XG5cbiAgICAgICAgPCEtLSBVcHBlciBUaHVtYiBDYWxsb3V0IC0tPlxuICAgICAgICA8ZGl2IGNsYXNzPVwidG9vbHRpcCB0b3AgdG9vbHRpcC11cHBlclwiICN1cHBlclRvb2x0aXBcbiAgICAgICAgICAgIFtjbGFzcy50b29sdGlwLWR5bmFtaWNdPVwib3B0aW9ucy5oYW5kbGVzLmNhbGxvdXQudHJpZ2dlciA9PT0gc2xpZGVyQ2FsbG91dFRyaWdnZXIuRHluYW1pYyAmJiB0aHVtYnMudXBwZXIuZHJhZyA9PT0gZmFsc2VcIlxuICAgICAgICAgICAgW3N0eWxlLm9wYWNpdHldPVwidG9vbHRpcHMudXBwZXIudmlzaWJsZSA/IDEgOiAwXCJcbiAgICAgICAgICAgIFtzdHlsZS5sZWZ0LnB4XT1cInRvb2x0aXBzLnVwcGVyLnBvc2l0aW9uXCI+XG5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0b29sdGlwLWFycm93XCIgW3N0eWxlLmJvcmRlci10b3AtY29sb3JdPVwib3B0aW9ucy5oYW5kbGVzLmNhbGxvdXQuYmFja2dyb3VuZFwiPjwvZGl2PlxuXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwidG9vbHRpcC1pbm5lclwiXG4gICAgICAgICAgICAgICAgKm5nSWY9XCJvcHRpb25zLnR5cGUgPT09IHNsaWRlclR5cGUuUmFuZ2VcIlxuICAgICAgICAgICAgICAgIFtzdHlsZS5iYWNrZ3JvdW5kLWNvbG9yXT1cIm9wdGlvbnMuaGFuZGxlcy5jYWxsb3V0LmJhY2tncm91bmRcIlxuICAgICAgICAgICAgICAgIFtzdHlsZS5jb2xvcl09XCJvcHRpb25zLmhhbmRsZXMuY2FsbG91dC5jb2xvclwiPlxuICAgICAgICAgICAgICAgIHt7IHRvb2x0aXBzLnVwcGVyLmxhYmVsIH19XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG5cbiAgICA8IS0tIFNlY3Rpb24gb2YgVHJhY2sgQWJvdmVyIFVwcGVyIFRodW1iIC0tPlxuICAgIDxkaXYgY2xhc3M9XCJ0cmFjay1zZWN0aW9uIHRyYWNrLWhpZ2hlclwiIFtzdHlsZS5mbGV4LWdyb3ddPVwidHJhY2tzLnVwcGVyLnNpemVcIiBbc3R5bGUuYmFja2dyb3VuZF09XCJ0cmFja3MudXBwZXIuY29sb3JcIj48L2Rpdj5cblxuPC9kaXY+XG5cbjwhLS0gQ2hhcnQgVGlja3MgYW5kIFRpY2sgTGFiZWxzIC0tPlxuPGRpdiBjbGFzcz1cInRpY2stY29udGFpbmVyXCJcbiAgICByb2xlPVwicHJlc2VudGF0aW9uXCJcbiAgICAqbmdJZj1cIihvcHRpb25zLnRyYWNrLnRpY2tzLm1ham9yLnNob3cgfHwgb3B0aW9ucy50cmFjay50aWNrcy5taW5vci5zaG93KSAmJiBvcHRpb25zLmhhbmRsZXMuY2FsbG91dC50cmlnZ2VyICE9PSBzbGlkZXJDYWxsb3V0VHJpZ2dlci5EeW5hbWljXCJcbiAgICBbY2xhc3Muc2hvdy1sYWJlbHNdPVwib3B0aW9ucy50cmFjay50aWNrcy5tYWpvci5sYWJlbHMgfHwgb3B0aW9ucy50cmFjay50aWNrcy5taW5vci5sYWJlbHNcIj5cblxuICAgIDxkaXYgY2xhc3M9XCJ0aWNrXCJcbiAgICAgICAgKm5nRm9yPVwibGV0IHRpY2sgb2YgdGlja3NcIlxuICAgICAgICBbY2xhc3MubWFqb3JdPVwidGljay50eXBlID09PSBzbGlkZXJUaWNrVHlwZS5NYWpvclwiXG4gICAgICAgIFtjbGFzcy5taW5vcl09XCJ0aWNrLnR5cGUgPT09IHNsaWRlclRpY2tUeXBlLk1pbm9yXCJcbiAgICAgICAgW3N0eWxlLmxlZnQuJV09XCJ0aWNrLnBvc2l0aW9uXCJcbiAgICAgICAgW2hpZGRlbl09XCIhdGljay5zaG93VGlja3NcIj5cblxuICAgICAgICA8ZGl2IGNsYXNzPVwidGljay1pbmRpY2F0b3JcIj48L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInRpY2stbGFiZWxcIiBhcmlhLWhpZGRlbj1cInRydWVcIiBbaGlkZGVuXT1cIiF0aWNrLnNob3dMYWJlbHNcIj57eyB0aWNrLmxhYmVsIH19PC9kaXY+XG4gICAgPC9kaXY+XG48L2Rpdj5gLFxuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG59KVxuZXhwb3J0IGNsYXNzIFNsaWRlckNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgQWZ0ZXJWaWV3SW5pdCwgRG9DaGVjayB7XG5cbiAgICBASW5wdXQoKSB2YWx1ZTogU2xpZGVyVmFsdWUgfCBudW1iZXIgPSAwO1xuICAgIEBJbnB1dCgpIG9wdGlvbnM6IFNsaWRlck9wdGlvbnM7XG4gICAgQE91dHB1dCgpIHZhbHVlQ2hhbmdlOiBFdmVudEVtaXR0ZXI8U2xpZGVyVmFsdWUgfCBudW1iZXI+ID0gbmV3IEV2ZW50RW1pdHRlcjxTbGlkZXJWYWx1ZSB8IG51bWJlcj4oKTtcblxuICAgIEBWaWV3Q2hpbGQoJ2xvd2VyVG9vbHRpcCcpIGxvd2VyVG9vbHRpcDogRWxlbWVudFJlZjtcbiAgICBAVmlld0NoaWxkKCd1cHBlclRvb2x0aXAnKSB1cHBlclRvb2x0aXA6IEVsZW1lbnRSZWY7XG4gICAgQFZpZXdDaGlsZCgndHJhY2snKSB0cmFjazogRWxlbWVudFJlZjtcblxuICAgIC8vIHN0b3JlIGN1cnJlbnQgdmFsdWVzIGZvciBkZWVwIGNoYW5nZSBkZXRlY3Rpb25cbiAgICBwcml2YXRlIF92YWx1ZTogU2xpZGVyVmFsdWUgfCBudW1iZXI7XG5cbiAgICAvLyBleHBvc2UgZW51bXMgdG8gQW5ndWxhciB2aWV3XG4gICAgc2xpZGVyVHlwZSA9IFNsaWRlclR5cGU7XG4gICAgc2xpZGVyU3R5bGUgPSBTbGlkZXJTdHlsZTtcbiAgICBzbGlkZXJTaXplID0gU2xpZGVyU2l6ZTtcbiAgICBzbGlkZXJTbmFwID0gU2xpZGVyU25hcDtcbiAgICBzbGlkZXJUaHVtYiA9IFNsaWRlclRodW1iO1xuICAgIHNsaWRlclRpY2tUeXBlID0gU2xpZGVyVGlja1R5cGU7XG4gICAgc2xpZGVyVGh1bWJFdmVudCA9IFNsaWRlclRodW1iRXZlbnQ7XG4gICAgc2xpZGVyQ2FsbG91dFRyaWdnZXIgPSBTbGlkZXJDYWxsb3V0VHJpZ2dlcjtcblxuICAgIHRyYWNrcyA9IHtcbiAgICAgICAgbG93ZXI6IHtcbiAgICAgICAgICAgIHNpemU6IDAsXG4gICAgICAgICAgICBjb2xvcjogJydcbiAgICAgICAgfSxcbiAgICAgICAgbWlkZGxlOiB7XG4gICAgICAgICAgICBzaXplOiAwLFxuICAgICAgICAgICAgY29sb3I6ICcnXG4gICAgICAgIH0sXG4gICAgICAgIHVwcGVyOiB7XG4gICAgICAgICAgICBzaXplOiAwLFxuICAgICAgICAgICAgY29sb3I6ICcnXG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdG9vbHRpcHMgPSB7XG4gICAgICAgIGxvd2VyOiB7XG4gICAgICAgICAgICB2aXNpYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiAwLFxuICAgICAgICAgICAgbGFiZWw6ICcnXG4gICAgICAgIH0sXG4gICAgICAgIHVwcGVyOiB7XG4gICAgICAgICAgICB2aXNpYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiAwLFxuICAgICAgICAgICAgbGFiZWw6ICcnXG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGh1bWJzID0ge1xuICAgICAgICBsb3dlcjoge1xuICAgICAgICAgICAgaG92ZXI6IGZhbHNlLFxuICAgICAgICAgICAgZHJhZzogZmFsc2UsXG4gICAgICAgICAgICBwb3NpdGlvbjogMCxcbiAgICAgICAgICAgIG9yZGVyOiAxMDAsXG4gICAgICAgICAgICB2YWx1ZTogbnVsbCBhcyBudW1iZXJcbiAgICAgICAgfSxcbiAgICAgICAgdXBwZXI6IHtcbiAgICAgICAgICAgIGhvdmVyOiBmYWxzZSxcbiAgICAgICAgICAgIGRyYWc6IGZhbHNlLFxuICAgICAgICAgICAgcG9zaXRpb246IDAsXG4gICAgICAgICAgICBvcmRlcjogMTAxLFxuICAgICAgICAgICAgdmFsdWU6IG51bGwgYXMgbnVtYmVyXG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gc3RvcmUgYWxsIHRoZSB0aWNrcyB0byBkaXNwbGF5XG4gICAgdGlja3M6IFNsaWRlclRpY2tbXSA9IFtdO1xuICAgIGRlZmF1bHRPcHRpb25zOiBTbGlkZXJPcHRpb25zO1xuXG4gICAgY29uc3RydWN0b3IoY29sb3JTZXJ2aWNlOiBDb2xvclNlcnZpY2UsIHByaXZhdGUgX2NoYW5nZURldGVjdG9yUmVmOiBDaGFuZ2VEZXRlY3RvclJlZikge1xuXG4gICAgICAgIC8vIHNldHVwIGRlZmF1bHQgb3B0aW9uc1xuICAgICAgICB0aGlzLmRlZmF1bHRPcHRpb25zID0ge1xuICAgICAgICAgICAgdHlwZTogU2xpZGVyVHlwZS5WYWx1ZSxcbiAgICAgICAgICAgIGhhbmRsZXM6IHtcbiAgICAgICAgICAgICAgICBzdHlsZTogU2xpZGVyU3R5bGUuQnV0dG9uLFxuICAgICAgICAgICAgICAgIGNhbGxvdXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcjogU2xpZGVyQ2FsbG91dFRyaWdnZXIuTm9uZSxcbiAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZDogY29sb3JTZXJ2aWNlLmdldENvbG9yKCdncmV5MicpLnRvSGV4KCksXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiAnI2ZmZicsXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlcjogKHZhbHVlOiBudW1iZXIpOiBzdHJpbmcgfCBudW1iZXIgPT4gdmFsdWVcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGtleWJvYXJkOiB7XG4gICAgICAgICAgICAgICAgICAgIG1ham9yOiA1LFxuICAgICAgICAgICAgICAgICAgICBtaW5vcjogMVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYXJpYToge1xuICAgICAgICAgICAgICAgICAgICB0aHVtYjogJ1NsaWRlciB2YWx1ZScsXG4gICAgICAgICAgICAgICAgICAgIGxvd2VyVGh1bWI6ICdTbGlkZXIgbG93ZXIgdmFsdWUnLFxuICAgICAgICAgICAgICAgICAgICB1cHBlclRodW1iOiAnU2xpZGVyIHVwcGVyIHZhbHVlJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cmFjazoge1xuICAgICAgICAgICAgICAgIGhlaWdodDogU2xpZGVyU2l6ZS5XaWRlLFxuICAgICAgICAgICAgICAgIG1pbjogMCxcbiAgICAgICAgICAgICAgICBtYXg6IDEwMCxcbiAgICAgICAgICAgICAgICB0aWNrczoge1xuICAgICAgICAgICAgICAgICAgICBzbmFwOiBTbGlkZXJTbmFwLk5vbmUsXG4gICAgICAgICAgICAgICAgICAgIG1ham9yOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RlcHM6IDEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVyOiAodmFsdWU6IG51bWJlcik6IHN0cmluZyB8IG51bWJlciA9PiB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBtaW5vcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXBzOiA1LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlcjogKHZhbHVlOiBudW1iZXIpOiBzdHJpbmcgfCBudW1iZXIgPT4gdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY29sb3JzOiB7XG4gICAgICAgICAgICAgICAgICAgIGxvd2VyOiBjb2xvclNlcnZpY2UuZ2V0Q29sb3IoJ2dyZXk2JykudG9IZXgoKSxcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IGNvbG9yU2VydmljZS5nZXRDb2xvcignYWNjZW50Jykuc2V0QWxwaGEoMC43NSkudG9SZ2JhKCksXG4gICAgICAgICAgICAgICAgICAgIGhpZ2hlcjogY29sb3JTZXJ2aWNlLmdldENvbG9yKCdncmV5NicpLnRvSGV4KClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKTogdm9pZCB7XG5cbiAgICAgICAgdGhpcy51cGRhdGVPcHRpb25zKCk7XG4gICAgICAgIHRoaXMudXBkYXRlVmFsdWVzKCk7XG5cbiAgICAgICAgdGhpcy5zZXRUaHVtYlN0YXRlKFNsaWRlclRodW1iLkxvd2VyLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICB0aGlzLnNldFRodW1iU3RhdGUoU2xpZGVyVGh1bWIuVXBwZXIsIGZhbHNlLCBmYWxzZSk7XG5cbiAgICAgICAgLy8gZW1pdCB0aGUgaW5pdGlhbCB2YWx1ZVxuICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlLm5leHQodGhpcy5jbG9uZSh0aGlzLnZhbHVlKSk7XG4gICAgfVxuXG4gICAgbmdEb0NoZWNrKCk6IHZvaWQge1xuXG4gICAgICAgIGlmICh0aGlzLmRldGVjdFZhbHVlQ2hhbmdlKHRoaXMudmFsdWUsIHRoaXMuX3ZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZXMoKTtcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gdGhpcy5jbG9uZSh0aGlzLnZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkIHtcbiAgICAgICAgLy8gcGVyc2lzdGVudCB0b29sdGlwcyB3aWxsIG5lZWQgcG9zaXRpb25lZCBjb3JyZWN0bHkgYXQgdGhpcyBzdGFnZVxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVG9vbHRpcFBvc2l0aW9uKFNsaWRlclRodW1iLkxvd2VyKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVG9vbHRpcFBvc2l0aW9uKFNsaWRlclRodW1iLlVwcGVyKTtcblxuICAgICAgICAgICAgLy8gbWFyayBhcyBkaXJ0eVxuICAgICAgICAgICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHNuYXBUb05lYXJlc3RUaWNrKHRodW1iOiBTbGlkZXJUaHVtYiwgc25hcFRhcmdldDogU2xpZGVyU25hcCwgZm9yd2FyZHM6IGJvb2xlYW4pOiB2b2lkIHtcblxuICAgICAgICAvLyBnZXQgdGhlIHZhbHVlIGZvciB0aGUgdGh1bWJcbiAgICAgICAgY29uc3QgeyB2YWx1ZSB9ID0gdGhpcy5nZXRUaHVtYlN0YXRlKHRodW1iKTtcblxuICAgICAgICAvLyBnZXQgdGhlIGNsb3Nlc3QgdGlja3MgLSByZW1vdmUgYW55IHRpY2sgaWYgd2UgYXJlIGN1cnJlbnRseSBvbiBpdFxuICAgICAgICBjb25zdCBjbG9zZXN0ID0gdGhpcy5nZXRUaWNrRGlzdGFuY2VzKHZhbHVlLCB0aHVtYiwgc25hcFRhcmdldClcbiAgICAgICAgICAgIC5maWx0ZXIodGljayA9PiB0aWNrLnZhbHVlICE9PSB2YWx1ZSlcbiAgICAgICAgICAgIC5maW5kKHRpY2sgPT4gZm9yd2FyZHMgPyB0aWNrLnZhbHVlID4gdmFsdWUgOiB0aWNrLnZhbHVlIDwgdmFsdWUpO1xuXG4gICAgICAgIC8vIElmIHdlIGhhdmUgbm8gdGlja3MgdGhlbiBtb3ZlIGJ5IGEgcHJlZGVmaW5lZCBhbW91bnRcbiAgICAgICAgaWYgKGNsb3Nlc3QpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldFRodW1iVmFsdWUodGh1bWIsIHRoaXMudmFsaWRhdGVWYWx1ZSh0aHVtYiwgY2xvc2VzdC52YWx1ZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc3RlcCA9IHNuYXBUYXJnZXQgPT09IFNsaWRlclNuYXAuTWFqb3IgPyB0aGlzLm9wdGlvbnMuaGFuZGxlcy5rZXlib2FyZC5tYWpvciA6IHRoaXMub3B0aW9ucy5oYW5kbGVzLmtleWJvYXJkLm1pbm9yO1xuXG4gICAgICAgIHRoaXMuc2V0VGh1bWJWYWx1ZSh0aHVtYiwgdGhpcy52YWxpZGF0ZVZhbHVlKHRodW1iLCB2YWx1ZSArIChmb3J3YXJkcyA/IHN0ZXAgOiAtc3RlcCkpKTtcblxuICAgIH1cblxuICAgIHNuYXBUb0VuZCh0aHVtYjogU2xpZGVyVGh1bWIsIGZvcndhcmRzOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIHRoaXMuc2V0VGh1bWJWYWx1ZSh0aHVtYiwgdGhpcy52YWxpZGF0ZVZhbHVlKHRodW1iLCBmb3J3YXJkcyA/IHRoaXMub3B0aW9ucy50cmFjay5tYXggOiB0aGlzLm9wdGlvbnMudHJhY2subWluKSk7XG4gICAgfVxuXG4gICAgZ2V0VGh1bWJWYWx1ZSh0aHVtYjogU2xpZGVyVGh1bWIpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRUaHVtYlN0YXRlKHRodW1iKS52YWx1ZTtcbiAgICB9XG5cbiAgICBnZXRGb3JtYXR0ZWRWYWx1ZSh0aHVtYjogU2xpZGVyVGh1bWIpOiBzdHJpbmcgfCBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmhhbmRsZXMuY2FsbG91dC5mb3JtYXR0ZXIodGhpcy5nZXRUaHVtYlN0YXRlKHRodW1iKS52YWx1ZSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRUaHVtYlN0YXRlKHRodW1iOiBTbGlkZXJUaHVtYikge1xuICAgICAgICByZXR1cm4gdGh1bWIgPT09IFNsaWRlclRodW1iLkxvd2VyID8gdGhpcy50aHVtYnMubG93ZXIgOiB0aGlzLnRodW1icy51cHBlcjtcbiAgICB9XG5cbiAgICBwcml2YXRlIHNldFRodW1iU3RhdGUodGh1bWI6IFNsaWRlclRodW1iLCBob3ZlcjogYm9vbGVhbiwgZHJhZzogYm9vbGVhbikge1xuXG4gICAgICAgIGlmICh0aHVtYiA9PT0gU2xpZGVyVGh1bWIuTG93ZXIpIHtcbiAgICAgICAgICAgIHRoaXMudGh1bWJzLmxvd2VyLmhvdmVyID0gaG92ZXI7XG4gICAgICAgICAgICB0aGlzLnRodW1icy5sb3dlci5kcmFnID0gZHJhZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudGh1bWJzLnVwcGVyLmhvdmVyID0gaG92ZXI7XG4gICAgICAgICAgICB0aGlzLnRodW1icy51cHBlci5kcmFnID0gZHJhZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgdG9vbHRpcHNcbiAgICAgICAgdGhpcy51cGRhdGVUb29sdGlwcyh0aHVtYik7XG4gICAgfVxuXG4gICAgdGh1bWJFdmVudCh0aHVtYjogU2xpZGVyVGh1bWIsIGV2ZW50OiBTbGlkZXJUaHVtYkV2ZW50KTogdm9pZCB7XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBjdXJyZW50IHRodW1iIHN0YXRlXG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXRUaHVtYlN0YXRlKHRodW1iKTtcblxuICAgICAgICAvLyB1cGRhdGUgYmFzZWQgdXBvbiBldmVudFxuICAgICAgICBzd2l0Y2ggKGV2ZW50KSB7XG5cbiAgICAgICAgICAgIGNhc2UgU2xpZGVyVGh1bWJFdmVudC5EcmFnU3RhcnQ6XG4gICAgICAgICAgICAgICAgc3RhdGUuZHJhZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgU2xpZGVyVGh1bWJFdmVudC5EcmFnRW5kOlxuICAgICAgICAgICAgICAgIHN0YXRlLmRyYWcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBTbGlkZXJUaHVtYkV2ZW50Lk1vdXNlT3ZlcjpcbiAgICAgICAgICAgICAgICBzdGF0ZS5ob3ZlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgU2xpZGVyVGh1bWJFdmVudC5Nb3VzZUxlYXZlOlxuICAgICAgICAgICAgICAgIHN0YXRlLmhvdmVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgU2xpZGVyVGh1bWJFdmVudC5Ob25lOlxuICAgICAgICAgICAgICAgIHN0YXRlLmRyYWcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5ob3ZlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSB0aHVtYiBzdGF0ZVxuICAgICAgICB0aGlzLnNldFRodW1iU3RhdGUodGh1bWIsIHN0YXRlLmhvdmVyLCBzdGF0ZS5kcmFnKTtcbiAgICB9XG5cbiAgICBnZXRBcmlhVmFsdWVUZXh0KHRodW1iOiBTbGlkZXJUaHVtYik6IHN0cmluZyB8IG51bWJlciB7XG4gICAgICAgIC8vIGdldCB0aGUgY3VycmVudCB0aHVtYiB2YWx1ZVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZ2V0VGh1bWJWYWx1ZSh0aHVtYik7XG5cbiAgICAgICAgLy8gZ2V0IGFsbCB0aGUgdGlja3NcbiAgICAgICAgY29uc3QgdGljayA9IHRoaXMudGlja3MuZmluZChfdGljayA9PiBfdGljay52YWx1ZSA9PT0gdmFsdWUpO1xuXG4gICAgICAgIGlmICh0aWNrICYmIHRpY2subGFiZWwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aWNrLmxhYmVsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gb3RoZXJ3aXNlIHNpbXBseSBkaXNwbGF5IHRoZSBmb3JtYXR0ZWQgdmFsdWVcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Rm9ybWF0dGVkVmFsdWUodGh1bWIpO1xuICAgIH1cblxuICAgIHByaXZhdGUgdXBkYXRlVG9vbHRpcHModGh1bWI6IFNsaWRlclRodW1iKTogdm9pZCB7XG5cbiAgICAgICAgbGV0IHZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldFRodW1iU3RhdGUodGh1bWIpO1xuXG4gICAgICAgIHN3aXRjaCAodGhpcy5vcHRpb25zLmhhbmRsZXMuY2FsbG91dC50cmlnZ2VyKSB7XG5cbiAgICAgICAgICAgIGNhc2UgU2xpZGVyQ2FsbG91dFRyaWdnZXIuUGVyc2lzdGVudDpcbiAgICAgICAgICAgICAgICB2aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBTbGlkZXJDYWxsb3V0VHJpZ2dlci5EcmFnOlxuICAgICAgICAgICAgICAgIHZpc2libGUgPSBzdGF0ZS5kcmFnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFNsaWRlckNhbGxvdXRUcmlnZ2VyLkhvdmVyOlxuICAgICAgICAgICAgICAgIHZpc2libGUgPSBzdGF0ZS5ob3ZlciB8fCBzdGF0ZS5kcmFnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFNsaWRlckNhbGxvdXRUcmlnZ2VyLkR5bmFtaWM6XG4gICAgICAgICAgICAgICAgdmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1cGRhdGUgdGhlIHN0YXRlIGZvciB0aGUgY29ycmVzcG9uZGluZyB0aHVtYlxuICAgICAgICB0aGlzLmdldFRvb2x0aXAodGh1bWIpLnZpc2libGUgPSB2aXNpYmxlO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgdG9vbHRpcCB0ZXh0XG4gICAgICAgIHRoaXMudXBkYXRlVG9vbHRpcFRleHQodGh1bWIpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgdG9vbHRpcCBwb3NpdGlvbnNcbiAgICAgICAgdGhpcy51cGRhdGVUb29sdGlwUG9zaXRpb24odGh1bWIpO1xuICAgIH1cblxuICAgIHByaXZhdGUgdXBkYXRlVG9vbHRpcFRleHQodGh1bWI6IFNsaWRlclRodW1iKSB7XG5cbiAgICAgICAgLy8gZ2V0IHRoZSB0aHVtYiB2YWx1ZVxuICAgICAgICBsZXQgc3RhdGUgPSB0aGlzLmdldFRodW1iU3RhdGUodGh1bWIpO1xuICAgICAgICBsZXQgdG9vbHRpcCA9IHRoaXMuZ2V0VG9vbHRpcCh0aHVtYik7XG5cbiAgICAgICAgLy8gc3RvcmUgdGhlIGZvcm1hdHRlZCBsYWJlbFxuICAgICAgICB0b29sdGlwLmxhYmVsID0gdGhpcy5nZXRGb3JtYXR0ZWRWYWx1ZSh0aHVtYikudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldFRvb2x0aXBFbGVtZW50KHRodW1iOiBTbGlkZXJUaHVtYik6IEVsZW1lbnRSZWYge1xuICAgICAgICByZXR1cm4gdGh1bWIgPT09IFNsaWRlclRodW1iLkxvd2VyID8gdGhpcy5sb3dlclRvb2x0aXAgOiB0aGlzLnVwcGVyVG9vbHRpcDtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldFRvb2x0aXAodGh1bWI6IFNsaWRlclRodW1iKSB7XG4gICAgICAgIHJldHVybiB0aHVtYiA9PT0gU2xpZGVyVGh1bWIuTG93ZXIgPyB0aGlzLnRvb2x0aXBzLmxvd2VyIDogdGhpcy50b29sdGlwcy51cHBlcjtcbiAgICB9XG5cbiAgICBwcml2YXRlIHVwZGF0ZVRvb2x0aXBQb3NpdGlvbih0aHVtYjogU2xpZGVyVGh1bWIpOiB2b2lkIHtcblxuICAgICAgICBjb25zdCB0b29sdGlwID0gdGhpcy5nZXRUb29sdGlwKHRodW1iKTtcblxuICAgICAgICAvLyBpZiB0b29sdGlwIGlzIG5vdCB2aXNpYmxlIHRoZW4gc3RvcCBoZXJlXG4gICAgICAgIGlmICh0b29sdGlwLnZpc2libGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgdG9vbHRpcEVsZW1lbnQgPSB0aGlzLmdldFRvb2x0aXBFbGVtZW50KHRodW1iKTtcblxuICAgICAgICAvLyBnZXQgdGhlIGVsZW1lbnQgd2lkdGhzXG4gICAgICAgIGxldCB0aHVtYldpZHRoOiBudW1iZXI7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5oYW5kbGVzLnN0eWxlID09PSBTbGlkZXJTdHlsZS5CdXR0b24pIHtcbiAgICAgICAgICAgIHRodW1iV2lkdGggPSB0aGlzLm9wdGlvbnMudHJhY2suaGVpZ2h0ID09PSBTbGlkZXJTaXplLk5hcnJvdyA/IDE2IDogMjQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHVtYldpZHRoID0gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCB0b29sdGlwV2lkdGggPSB0b29sdGlwRWxlbWVudC5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgdG9vbHRpcHMgbmV3IHBvc2l0aW9uXG4gICAgICAgIGxldCB0b29sdGlwUG9zaXRpb24gPSBNYXRoLmNlaWwoKHRvb2x0aXBXaWR0aCAtIHRodW1iV2lkdGgpIC8gMik7XG5cbiAgICAgICAgLy8gdXBkYXRlIHRvb2x0aXAgcG9zaXRpb25cbiAgICAgICAgdG9vbHRpcC5wb3NpdGlvbiA9IC10b29sdGlwUG9zaXRpb247XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50eXBlID09PSBTbGlkZXJUeXBlLlJhbmdlICYmIHRoaXMub3B0aW9ucy5oYW5kbGVzLmNhbGxvdXQudHJpZ2dlciA9PT0gU2xpZGVyQ2FsbG91dFRyaWdnZXIuRHluYW1pYykge1xuICAgICAgICAgICAgdGhpcy5wcmV2ZW50VG9vbHRpcE92ZXJsYXAodG9vbHRpcCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHByZXZlbnRUb29sdGlwT3ZlcmxhcCh0b29sdGlwOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgdHJhY2tXaWR0aCA9IHRoaXMudHJhY2submF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aDtcblxuICAgICAgICBjb25zdCBsb3dlciA9ICh0cmFja1dpZHRoIC8gMTAwKSAqIHRoaXMudGh1bWJzLmxvd2VyLnBvc2l0aW9uO1xuICAgICAgICBjb25zdCB1cHBlciA9ICh0cmFja1dpZHRoIC8gMTAwKSAqIHRoaXMudGh1bWJzLnVwcGVyLnBvc2l0aW9uO1xuXG4gICAgICAgIGNvbnN0IGxvd2VyV2lkdGggPSB0aGlzLmxvd2VyVG9vbHRpcC5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoIC8gMjtcbiAgICAgICAgY29uc3QgdXBwZXJXaWR0aCA9IHRoaXMudXBwZXJUb29sdGlwLm5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGggLyAyO1xuXG4gICAgICAgIGNvbnN0IGRpZmYgPSAobG93ZXIgKyBsb3dlcldpZHRoKSAtICh1cHBlciAtIHVwcGVyV2lkdGgpO1xuXG4gICAgICAgIC8vIGlmIHRoZSB0b29sdGlwcyBhcmUgY2xvc2VyIHRoYW4gMTZweCB0aGVuIGFkanVzdCBzbyB0aGUgZG9udCBtb3ZlIGFueSBjbG9zZVxuICAgICAgICBpZiAoZGlmZiA+IDApIHtcbiAgICAgICAgICAgIGlmICh0b29sdGlwID09PSB0aGlzLnRvb2x0aXBzLmxvd2VyICYmIHRoaXMudGh1bWJzLmxvd2VyLmRyYWcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdG9vbHRpcC5wb3NpdGlvbiAtPSAoZGlmZiAvIDIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0b29sdGlwID09PSB0aGlzLnRvb2x0aXBzLnVwcGVyICYmIHRoaXMudGh1bWJzLnVwcGVyLmRyYWcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdG9vbHRpcC5wb3NpdGlvbiArPSAoZGlmZiAvIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjbGFtcCh2YWx1ZTogbnVtYmVyLCBtaW46IG51bWJlciwgbWF4OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgodmFsdWUsIG1pbiksIG1heCk7XG4gICAgfVxuXG4gICAgdXBkYXRlVGh1bWJQb3NpdGlvbihldmVudDogTW91c2VFdmVudCB8IFRvdWNoRXZlbnQsIHRodW1iOiBTbGlkZXJUaHVtYik6IHZvaWQge1xuXG4gICAgICAgIC8vIGdldCBldmVudCBwb3NpdGlvbiAtIGVpdGhlciBtb3VzZSBvciB0b3VjaFxuICAgICAgICBsZXQgZXZlbnRQb3NpdGlvbiA9IGV2ZW50IGluc3RhbmNlb2YgTW91c2VFdmVudCA/IGV2ZW50LmNsaWVudFggOiBldmVudC50b3VjaGVzICYmIGV2ZW50LnRvdWNoZXMubGVuZ3RoID4gMCA/IGV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WCA6IG51bGw7XG5cbiAgICAgICAgLy8gaWYgZXZlbnQgcG9zaXRpb24gaXMgbnVsbCBkbyBub3RoaW5nXG4gICAgICAgIGlmIChldmVudFBvc2l0aW9uID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgbW91c2UgcG9zaXRpb25cbiAgICAgICAgbGV0IG1vdXNlWCA9IHdpbmRvdy5wYWdlWE9mZnNldCArIGV2ZW50UG9zaXRpb247XG5cbiAgICAgICAgLy8gZ2V0IHRyYWNrIHNpemUgYW5kIHBvc2l0aW9uXG4gICAgICAgIGxldCB0cmFja0JvdW5kcyA9IHRoaXMudHJhY2submF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICAvLyByZXN0cmljdCB0aGUgdmFsdWUgd2l0aGluIHRoZSByYW5nZSBzaXplXG4gICAgICAgIGxldCBwb3NpdGlvbiA9IHRoaXMuY2xhbXAobW91c2VYIC0gdHJhY2tCb3VuZHMubGVmdCwgMCwgdHJhY2tCb3VuZHMud2lkdGgpO1xuXG4gICAgICAgIC8vIGdldCBmcmFjdGlvbiByZXByZXNlbnRhdGlvbiBvZiBsb2NhdGlvbiB3aXRoaW4gdGhlIHRyYWNrXG4gICAgICAgIGxldCBmcmFjdGlvbiA9IChwb3NpdGlvbiAvIHRyYWNrQm91bmRzLndpZHRoKTtcblxuICAgICAgICAvLyBjb252ZXJ0IHRvIHZhbHVlIHdpdGhpbiB0aGUgcmFuZ2VcbiAgICAgICAgbGV0IHZhbHVlID0gKCh0aGlzLm9wdGlvbnMudHJhY2subWF4IC0gdGhpcy5vcHRpb25zLnRyYWNrLm1pbikgKiBmcmFjdGlvbikgKyB0aGlzLm9wdGlvbnMudHJhY2subWluO1xuXG4gICAgICAgIC8vIGVuc3VyZSB2YWx1ZSBpcyB2YWxpZFxuICAgICAgICB2YWx1ZSA9IHRoaXMudmFsaWRhdGVWYWx1ZSh0aHVtYiwgdmFsdWUpO1xuXG4gICAgICAgIC8vIHNuYXAgdG8gYSB0aWNrIGlmIHJlcXVpcmVkXG4gICAgICAgIHZhbHVlID0gdGhpcy5zbmFwVG9UaWNrKHZhbHVlLCB0aHVtYik7XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSB2YWx1ZSBhY2NvcmRpbmdseVxuICAgICAgICB0aGlzLnNldFRodW1iVmFsdWUodGh1bWIsIHZhbHVlKTtcblxuICAgICAgICB0aGlzLnVwZGF0ZU9yZGVyKHRodW1iKTtcbiAgICAgICAgdGhpcy51cGRhdGVWYWx1ZXMoKTtcblxuICAgICAgICAvLyB1cGRhdGUgdG9vbHRpcCB0ZXh0ICYgcG9zaXRpb25cbiAgICAgICAgdGhpcy51cGRhdGVUb29sdGlwVGV4dCh0aHVtYik7XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBwb3NpdGlvbiBvZiBhbGwgdmlzaWJsZSB0b29sdGlwc1xuICAgICAgICB0aGlzLnVwZGF0ZVRvb2x0aXBQb3NpdGlvbihTbGlkZXJUaHVtYi5Mb3dlcik7XG4gICAgICAgIHRoaXMudXBkYXRlVG9vbHRpcFBvc2l0aW9uKFNsaWRlclRodW1iLlVwcGVyKTtcblxuICAgICAgICAvLyBtYXJrIGFzIGRpcnR5IGZvciBjaGFuZ2UgZGV0ZWN0aW9uXG4gICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICAgIH1cblxuICAgIHByaXZhdGUgdXBkYXRlT3JkZXIodGh1bWI6IFNsaWRlclRodW1iKTogdm9pZCB7XG5cbiAgICAgICAgbGV0IGxvd2VyID0gdGh1bWIgPT09IFNsaWRlclRodW1iLkxvd2VyID8gMTAxIDogMTAwO1xuICAgICAgICBsZXQgdXBwZXIgPSB0aHVtYiA9PT0gU2xpZGVyVGh1bWIuTG93ZXIgPyAxMDAgOiAxMDE7XG5cbiAgICAgICAgLy8gVGhlIG1vc3QgcmVjZW50bHkgdXNlZCB0aHVtYiBzaG91bGQgYmUgYWJvdmVcbiAgICAgICAgdGhpcy50aHVtYnMubG93ZXIub3JkZXIgPSBsb3dlcjtcbiAgICAgICAgdGhpcy50aHVtYnMudXBwZXIub3JkZXIgPSB1cHBlcjtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldFRpY2tEaXN0YW5jZXModmFsdWU6IG51bWJlciwgdGh1bWI6IFNsaWRlclRodW1iLCBzbmFwVGFyZ2V0OiBTbGlkZXJTbmFwKTogU2xpZGVyVGlja1tdIHtcblxuICAgICAgICAvLyBpZiBzbmFwIHRhcmdldCBpcyBub25lIHRoZW4gcmV0dXJuIG9yaWdpbmFsIHZhbHVlXG4gICAgICAgIGlmIChzbmFwVGFyZ2V0ID09PSBTbGlkZXJTbmFwLk5vbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdldCBmaWx0ZXJlZCB0aWNrc1xuICAgICAgICBsZXQgdGlja3M6IFNsaWRlclRpY2tbXTtcblxuICAgICAgICBzd2l0Y2ggKHNuYXBUYXJnZXQpIHtcblxuICAgICAgICAgICAgY2FzZSBTbGlkZXJTbmFwLk1pbm9yOlxuICAgICAgICAgICAgICAgIHRpY2tzID0gdGhpcy50aWNrcy5maWx0ZXIodGljayA9PiB0aWNrLnR5cGUgPT09IFNsaWRlclRpY2tUeXBlLk1pbm9yKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBTbGlkZXJTbmFwLk1ham9yOlxuICAgICAgICAgICAgICAgIHRpY2tzID0gdGhpcy50aWNrcy5maWx0ZXIodGljayA9PiB0aWNrLnR5cGUgPT09IFNsaWRlclRpY2tUeXBlLk1ham9yKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aWNrcyA9IHRoaXMudGlja3Muc2xpY2UoMCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgdGhlIHRyYWNrIGxpbWl0XG4gICAgICAgIGxldCBsb3dlckxpbWl0ID0gdGhpcy5vcHRpb25zLnRyYWNrLm1pbjtcbiAgICAgICAgbGV0IHVwcGVyTGltaXQgPSB0aGlzLm9wdGlvbnMudHJhY2subWF4O1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudHlwZSA9PT0gU2xpZGVyVHlwZS5SYW5nZSAmJiB0aHVtYiA9PT0gU2xpZGVyVGh1bWIuTG93ZXIpIHtcbiAgICAgICAgICAgIHVwcGVyTGltaXQgPSB0aGlzLnRodW1icy51cHBlci52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudHlwZSA9PT0gU2xpZGVyVHlwZS5SYW5nZSAmJiB0aHVtYiA9PT0gU2xpZGVyVGh1bWIuVXBwZXIpIHtcbiAgICAgICAgICAgIGxvd2VyTGltaXQgPSB0aGlzLnRodW1icy5sb3dlci52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3QgdGljayB0byB0aGUgY3VycmVudCBwb3NpdGlvblxuICAgICAgICBjb25zdCByYW5nZSA9IHRpY2tzLmZpbHRlcih0aWNrID0+IHRpY2sudmFsdWUgPj0gbG93ZXJMaW1pdCAmJiB0aWNrLnZhbHVlIDw9IHVwcGVyTGltaXQpO1xuXG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBjbG9zZSB0aWNrcyBpbiB0aGUgdmFsaWQgcmFuZ2UgdGhlbiBkb250IHNuYXBcbiAgICAgICAgaWYgKHJhbmdlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJhbmdlLnNvcnQoKHRpY2tPbmUsIHRpY2tUd28pID0+IHtcblxuICAgICAgICAgICAgY29uc3QgdGlja09uZURlbHRhID0gTWF0aC5tYXgodGlja09uZS52YWx1ZSwgdmFsdWUpIC0gTWF0aC5taW4odGlja09uZS52YWx1ZSwgdmFsdWUpO1xuICAgICAgICAgICAgY29uc3QgdGlja1R3b0RlbHRhID0gTWF0aC5tYXgodGlja1R3by52YWx1ZSwgdmFsdWUpIC0gTWF0aC5taW4odGlja1R3by52YWx1ZSwgdmFsdWUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gdGlja09uZURlbHRhIC0gdGlja1R3b0RlbHRhO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHNuYXBUb1RpY2sodmFsdWU6IG51bWJlciwgdGh1bWI6IFNsaWRlclRodW1iKTogbnVtYmVyIHtcblxuICAgICAgICBjb25zdCB0aWNrRGlzdGFuY2VzID0gdGhpcy5nZXRUaWNrRGlzdGFuY2VzKHZhbHVlLCB0aHVtYiwgdGhpcy5vcHRpb25zLnRyYWNrLnRpY2tzLnNuYXApO1xuXG4gICAgICAgIC8vIGlmIHRoZXJlIGFyZSBubyB0aWNrcyByZXR1cm4gdGhlIGN1cnJlbnQgdmFsdWVcbiAgICAgICAgaWYgKHRpY2tEaXN0YW5jZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgdGhlIGNsb3Nlc3QgdGlja1xuICAgICAgICByZXR1cm4gdGlja0Rpc3RhbmNlc1swXS52YWx1ZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHZhbGlkYXRlVmFsdWUodGh1bWI6IFNsaWRlclRodW1iLCB2YWx1ZTogbnVtYmVyKTogbnVtYmVyIHtcblxuICAgICAgICAvLyBpZiBzbGlkZXIgaXMgbm90IGEgcmFuZ2UgdmFsdWUgaXMgYWx3YXlzIHZhbGlkIHByb3ZpZGluZyBpdCBpcyB3aXRoaW4gdGhlIGNoYXJ0IG1pbiBhbmQgbWF4IHZhbHVlc1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnR5cGUgPT09IFNsaWRlclR5cGUuVmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heChNYXRoLm1pbih2YWx1ZSwgdGhpcy5vcHRpb25zLnRyYWNrLm1heCksIHRoaXMub3B0aW9ucy50cmFjay5taW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgdmFsdWUgaXMgd2l0aCBjaGFydCByYW5nZXNcbiAgICAgICAgaWYgKHZhbHVlID4gdGhpcy5vcHRpb25zLnRyYWNrLm1heCkge1xuICAgICAgICAgICAgcmV0dXJuIHRodW1iID09PSBTbGlkZXJUaHVtYi5Mb3dlciA/IE1hdGgubWluKHRoaXMub3B0aW9ucy50cmFjay5tYXgsIHRoaXMudGh1bWJzLnVwcGVyLnZhbHVlKSA6IHRoaXMub3B0aW9ucy50cmFjay5tYXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgPCB0aGlzLm9wdGlvbnMudHJhY2subWluKSB7XG4gICAgICAgICAgICByZXR1cm4gdGh1bWIgPT09IFNsaWRlclRodW1iLlVwcGVyID8gTWF0aC5tYXgodGhpcy5vcHRpb25zLnRyYWNrLm1pbiwgdGhpcy50aHVtYnMubG93ZXIudmFsdWUpIDogdGhpcy5vcHRpb25zLnRyYWNrLm1pbjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG90aGVyd2lzZSB3ZSBuZWVkIHRvIGNoZWNrIHRvIG1ha2Ugc3VyZSBsb3dlciB0aHVtYiBjYW5ub3QgZ28gYWJvdmUgaGlnaGVyIGFuZCB2aWNlIHZlcnNhXG4gICAgICAgIGlmICh0aHVtYiA9PT0gU2xpZGVyVGh1bWIuTG93ZXIpIHtcblxuICAgICAgICAgICAgaWYgKHRoaXMudGh1bWJzLnVwcGVyLnZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPD0gdGhpcy50aHVtYnMudXBwZXIudmFsdWUgPyB2YWx1ZSA6IHRoaXMudGh1bWJzLnVwcGVyLnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRodW1iID09PSBTbGlkZXJUaHVtYi5VcHBlcikge1xuXG4gICAgICAgICAgICBpZiAodGhpcy50aHVtYnMubG93ZXIudmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA+PSB0aGlzLnRodW1icy5sb3dlci52YWx1ZSA/IHZhbHVlIDogdGhpcy50aHVtYnMubG93ZXIudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHVwZGF0ZU9wdGlvbnMoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gYWRkIGluIHRoZSBkZWZhdWx0IG9wdGlvbnMgdGhhdCB1c2VyIGhhc24ndCBzcGVjaWZpZWRcbiAgICAgICAgdGhpcy5vcHRpb25zID0gdGhpcy5kZWVwTWVyZ2UodGhpcy5vcHRpb25zIHx8IHt9LCB0aGlzLmRlZmF1bHRPcHRpb25zKTtcblxuICAgICAgICB0aGlzLnVwZGF0ZVRyYWNrQ29sb3JzKCk7XG4gICAgICAgIHRoaXMudXBkYXRlVGlja3MoKTtcbiAgICAgICAgdGhpcy51cGRhdGVWYWx1ZXMoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHVwZGF0ZVZhbHVlcygpOiB2b2lkIHtcblxuICAgICAgICBpZiAodGhpcy52YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMudmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGxvd2VyVmFsdWUgPSB0eXBlb2YgdGhpcy52YWx1ZSA9PT0gJ251bWJlcicgPyB0aGlzLnZhbHVlIDogdGhpcy52YWx1ZS5sb3c7XG4gICAgICAgIGxldCB1cHBlclZhbHVlID0gdHlwZW9mIHRoaXMudmFsdWUgPT09ICdudW1iZXInID8gdGhpcy52YWx1ZSA6IHRoaXMudmFsdWUuaGlnaDtcblxuICAgICAgICAvLyB2YWxpZGF0ZSB2YWx1ZXNcbiAgICAgICAgbG93ZXJWYWx1ZSA9IHRoaXMudmFsaWRhdGVWYWx1ZShTbGlkZXJUaHVtYi5Mb3dlciwgTnVtYmVyKGxvd2VyVmFsdWUudG9GaXhlZCg0KSkpO1xuICAgICAgICB1cHBlclZhbHVlID0gdGhpcy52YWxpZGF0ZVZhbHVlKFNsaWRlclRodW1iLlVwcGVyLCBOdW1iZXIodXBwZXJWYWx1ZS50b0ZpeGVkKDQpKSk7XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBwb3NpdGlvbnMgYXMgcGVyY2VudGFnZXNcbiAgICAgICAgbGV0IGxvd2VyUG9zaXRpb24gPSAoKChsb3dlclZhbHVlIC0gdGhpcy5vcHRpb25zLnRyYWNrLm1pbikgLyAodGhpcy5vcHRpb25zLnRyYWNrLm1heCAtIHRoaXMub3B0aW9ucy50cmFjay5taW4pKSAqIDEwMCk7XG4gICAgICAgIGxldCB1cHBlclBvc2l0aW9uID0gKCgodXBwZXJWYWx1ZSAtIHRoaXMub3B0aW9ucy50cmFjay5taW4pIC8gKHRoaXMub3B0aW9ucy50cmFjay5tYXggLSB0aGlzLm9wdGlvbnMudHJhY2subWluKSkgKiAxMDApO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aHVtYiBwb3NpdGlvbnNcbiAgICAgICAgdGhpcy50aHVtYnMubG93ZXIucG9zaXRpb24gPSBsb3dlclBvc2l0aW9uO1xuICAgICAgICB0aGlzLnRodW1icy51cHBlci5wb3NpdGlvbiA9IHVwcGVyUG9zaXRpb247XG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSB0cmFjayBzaXplc1xuICAgICAgICB0aGlzLnRyYWNrcy5sb3dlci5zaXplID0gbG93ZXJQb3NpdGlvbjtcbiAgICAgICAgdGhpcy50cmFja3MubWlkZGxlLnNpemUgPSB1cHBlclBvc2l0aW9uIC0gbG93ZXJQb3NpdGlvbjtcbiAgICAgICAgdGhpcy50cmFja3MudXBwZXIuc2l6ZSA9IHRoaXMub3B0aW9ucy50eXBlID09PSBTbGlkZXJUeXBlLlZhbHVlID8gMTAwIC0gbG93ZXJQb3NpdGlvbiA6IDEwMCAtIHVwcGVyUG9zaXRpb247XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSB2YWx1ZSBpbnB1dFxuICAgICAgICB0aGlzLnNldFZhbHVlKGxvd2VyVmFsdWUsIHVwcGVyVmFsdWUpO1xuICAgIH1cblxuICAgIHByaXZhdGUgc2V0VmFsdWUobG93OiBudW1iZXIsIGhpZ2g/OiBudW1iZXIpOiB2b2lkIHtcblxuICAgICAgICB0aGlzLnRodW1icy5sb3dlci52YWx1ZSA9IGxvdztcbiAgICAgICAgdGhpcy50aHVtYnMudXBwZXIudmFsdWUgPSBoaWdoO1xuXG4gICAgICAgIGxldCBwcmV2aW91c1ZhbHVlID0gdGhpcy5jbG9uZSh0aGlzLl92YWx1ZSk7XG5cbiAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMub3B0aW9ucy50eXBlID09PSBTbGlkZXJUeXBlLlZhbHVlID8gbG93IDogeyBsb3c6IGxvdywgaGlnaDogaGlnaCB9O1xuXG4gICAgICAgIC8vIGNhbGwgdGhlIGV2ZW50IGVtaXR0ZXIgaWYgY2hhbmdlcyBvY2N1cmVkXG4gICAgICAgIGlmICh0aGlzLmRldGVjdFZhbHVlQ2hhbmdlKHRoaXMudmFsdWUsIHByZXZpb3VzVmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlLmVtaXQodGhpcy5jbG9uZSh0aGlzLnZhbHVlKSk7XG5cbiAgICAgICAgICAgIHRoaXMudXBkYXRlVG9vbHRpcFRleHQoU2xpZGVyVGh1bWIuTG93ZXIpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVUb29sdGlwVGV4dChTbGlkZXJUaHVtYi5VcHBlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlLmVtaXQodGhpcy5jbG9uZSh0aGlzLnZhbHVlKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHNldFRodW1iVmFsdWUodGh1bWI6IFNsaWRlclRodW1iLCB2YWx1ZTogbnVtYmVyKTogdm9pZCB7XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSB0aHVtYiB2YWx1ZVxuICAgICAgICB0aGlzLmdldFRodW1iU3RhdGUodGh1bWIpLnZhbHVlID0gdmFsdWU7XG5cbiAgICAgICAgLy8gZm9yd2FyZCB0aGVzZSBjaGFuZ2VzIHRvIHRoZSB2YWx1ZVxuICAgICAgICB0aGlzLnNldFZhbHVlKHRoaXMudGh1bWJzLmxvd2VyLnZhbHVlLCB0aGlzLnRodW1icy51cHBlci52YWx1ZSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVUaWNrcygpOiB2b2lkIHtcblxuICAgICAgICAvLyBnZXQgdGljayBvcHRpb25zXG4gICAgICAgIGNvbnN0IG1ham9yT3B0aW9ucyA9IHRoaXMub3B0aW9ucy50cmFjay50aWNrcy5tYWpvcjtcbiAgICAgICAgY29uc3QgbWlub3JPcHRpb25zID0gdGhpcy5vcHRpb25zLnRyYWNrLnRpY2tzLm1pbm9yO1xuXG4gICAgICAgIC8vIGNoZWNrIGlmIHdlIHNob3VsZCBzaG93IHRpY2tzXG4gICAgICAgIGlmIChtYWpvck9wdGlvbnMuc2hvdyA9PT0gZmFsc2UgJiYgbWlub3JPcHRpb25zLnNob3cgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLnRpY2tzID0gW107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjcmVhdGUgdGlja3MgZm9yIGJvdGggbWFqb3IgYW5kIG1pbm9yIC0gb25seSBnZXQgdGhlIG9uZXMgdG8gYmUgc2hvd25cbiAgICAgICAgY29uc3QgbWFqb3JUaWNrcyA9IHRoaXMuZ2V0VGlja3MobWFqb3JPcHRpb25zLCBTbGlkZXJUaWNrVHlwZS5NYWpvcikuZmlsdGVyKHRpY2sgPT4gdGljay5zaG93VGlja3MpO1xuICAgICAgICBjb25zdCBtaW5vclRpY2tzID0gdGhpcy5nZXRUaWNrcyhtaW5vck9wdGlvbnMsIFNsaWRlclRpY2tUeXBlLk1pbm9yKS5maWx0ZXIodGljayA9PiB0aWNrLnNob3dUaWNrcyk7XG5cbiAgICAgICAgLy8gcmVtb3ZlIGFueSBtaW5vciB0aWNrcyB0aGF0IGFyZSBvbiBhIG1ham9yIGludGVydmFsXG4gICAgICAgIHRoaXMudGlja3MgPSB0aGlzLnVuaW9uVGlja3MobWFqb3JUaWNrcywgbWlub3JUaWNrcyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVUcmFja0NvbG9ycygpOiB2b2lkIHtcblxuICAgICAgICAvLyBnZXQgY29sb3JzIGZvciBlYWNoIHBhcnQgb2YgdGhlIHRyYWNrXG4gICAgICAgIGNvbnN0IHsgbG93ZXIsIHJhbmdlLCBoaWdoZXIgfSA9IHRoaXMub3B0aW9ucy50cmFjay5jb2xvcnM7XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBjb250cm9sbGVyIHZhbHVlXG4gICAgICAgIHRoaXMudHJhY2tzLmxvd2VyLmNvbG9yID0gdHlwZW9mIGxvd2VyID09PSAnc3RyaW5nJyA/IGxvd2VyIDogYGxpbmVhci1ncmFkaWVudCh0byByaWdodCwgJHtsb3dlci5qb2luKCcsICcpfSlgO1xuICAgICAgICB0aGlzLnRyYWNrcy5taWRkbGUuY29sb3IgPSB0eXBlb2YgcmFuZ2UgPT09ICdzdHJpbmcnID8gcmFuZ2UgOiBgbGluZWFyLWdyYWRpZW50KHRvIHJpZ2h0LCAke3JhbmdlLmpvaW4oJywgJyl9KWA7XG4gICAgICAgIHRoaXMudHJhY2tzLnVwcGVyLmNvbG9yID0gdHlwZW9mIGhpZ2hlciA9PT0gJ3N0cmluZycgPyBoaWdoZXIgOiBgbGluZWFyLWdyYWRpZW50KHRvIHJpZ2h0LCAke2hpZ2hlci5qb2luKCcsICcpfSlgO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0U3RlcHMoc3RlcHM6IG51bWJlciB8IG51bWJlcltdKTogbnVtYmVyW10ge1xuXG4gICAgICAgIC8vIGlmIHRoZXkgYXJlIGFscmVhZHkgYW4gYXJyYXkganVzdCByZXR1cm4gaXRcbiAgICAgICAgaWYgKHN0ZXBzIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGVwcztcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBvdXRwdXQ6IG51bWJlcltdID0gW107XG5cbiAgICAgICAgLy8gb3RoZXJ3aXNlIGNhbGN1bGF0ZSB0aGUgc3RlcHNcbiAgICAgICAgZm9yIChsZXQgaWR4ID0gdGhpcy5vcHRpb25zLnRyYWNrLm1pbjsgaWR4IDw9IHRoaXMub3B0aW9ucy50cmFjay5tYXg7IGlkeCArPSBzdGVwcykge1xuICAgICAgICAgICAgb3V0cHV0LnB1c2goaWR4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRUaWNrcyhvcHRpb25zOiBTbGlkZXJUaWNrT3B0aW9ucywgdHlwZTogU2xpZGVyVGlja1R5cGUpOiBTbGlkZXJUaWNrW10ge1xuXG4gICAgICAgIC8vIGNyZWF0ZSBhbiBhcnJheSB0byBzdG9yZSB0aGUgdGlja3MgYW5kIHN0ZXAgcG9pbnRzXG4gICAgICAgIGxldCBzdGVwcyA9IHRoaXMuZ2V0U3RlcHMob3B0aW9ucy5zdGVwcyk7XG5cbiAgICAgICAgLy8gZ2V0IHNvbWUgY2hhcnQgb3B0aW9uc1xuICAgICAgICBsZXQgbWluID0gdGhpcy5vcHRpb25zLnRyYWNrLm1pbjtcbiAgICAgICAgbGV0IG1heCA9IHRoaXMub3B0aW9ucy50cmFjay5tYXg7XG5cbiAgICAgICAgLy8gY29udmVydCBlYWNoIHN0ZXAgdG8gYSBzbGlkZXIgdGljayBhbmQgcmVtb3ZlIGludmFsaWQgdGlja3NcbiAgICAgICAgcmV0dXJuIHN0ZXBzLm1hcChzdGVwID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2hvd1RpY2tzOiBvcHRpb25zLnNob3csXG4gICAgICAgICAgICAgICAgc2hvd0xhYmVsczogb3B0aW9ucy5sYWJlbHMsXG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogKChzdGVwIC0gbWluKSAvIChtYXggLSBtaW4pKSAqIDEwMCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogc3RlcCxcbiAgICAgICAgICAgICAgICBsYWJlbDogb3B0aW9ucy5mb3JtYXR0ZXIoc3RlcClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pLmZpbHRlcih0aWNrID0+IHRpY2sucG9zaXRpb24gPj0gMCAmJiB0aWNrLnBvc2l0aW9uIDw9IDEwMCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1bmlvblRpY2tzKG1ham9yVGlja3M6IFNsaWRlclRpY2tbXSwgbWlub3JUaWNrczogU2xpZGVyVGlja1tdKTogU2xpZGVyVGlja1tdIHtcblxuICAgICAgICAvLyBnZXQgYWxsIHRpY2tzIGNvbWJpbmVkIHJlbW92aW5nIGFueSBtaW5vciB0aWNrcyB3aXRoIHRoZSBzYW1lIHZhbHVlIGFzIG1ham9yIHRpY2tzXG4gICAgICAgIHJldHVybiBtYWpvclRpY2tzLmNvbmNhdChtaW5vclRpY2tzKVxuICAgICAgICAgICAgLmZpbHRlcigodGljaywgaW5kZXgsIGFycmF5KSA9PiB0aWNrLnR5cGUgPT09IFNsaWRlclRpY2tUeXBlLk1ham9yIHx8ICFhcnJheS5maW5kKHRrID0+IHRrLnR5cGUgPT09IFNsaWRlclRpY2tUeXBlLk1ham9yICYmIHRrLnBvc2l0aW9uID09PSB0aWNrLnBvc2l0aW9uKSlcbiAgICAgICAgICAgIC5zb3J0KCh0MSwgdDIpID0+IHQxLnZhbHVlIC0gdDIudmFsdWUpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZGVlcE1lcmdlPFQ+KGRlc3RpbmF0aW9uOiBULCBzb3VyY2U6IFQpOiBUIHtcblxuICAgICAgICAvLyBsb29wIHRob3VnaCBhbGwgb2YgdGhlIHByb3BlcnRpZXMgaW4gdGhlIHNvdXJjZSBvYmplY3RcbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBzb3VyY2UpIHtcblxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIGRlc3RpbmF0aW9uIG9iamVjdCBoYXMgdGhlIHByb3BlcnR5XG4gICAgICAgICAgICBpZiAoIWRlc3RpbmF0aW9uLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgLy8gY29weSB0aGUgcHJvcGVydHkgYWNyb3NzXG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb25bcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZSBwcm9wZXJ0eSBleGlzdHMgYW5kIGlzIG5vdCBhbiBvYmplY3QgdGhlbiBza2lwXG4gICAgICAgICAgICBpZiAodHlwZW9mIGRlc3RpbmF0aW9uW3Byb3BdICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjaGVjayBpZiBwcm9wZXJ0eSBpcyBhbiBhcnJheVxuICAgICAgICAgICAgaWYgKGRlc3RpbmF0aW9uW3Byb3BdIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgaXQgaXMgYW4gb2JqZWN0IHRoZW4gcGVyZm9ybSBhIHJlY3Vyc2l2ZSBjaGVja1xuICAgICAgICAgICAgZGVzdGluYXRpb25bcHJvcF0gPSB0aGlzLmRlZXBNZXJnZShkZXN0aW5hdGlvbltwcm9wXSwgc291cmNlW3Byb3BdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZXN0aW5hdGlvbjtcbiAgICB9XG5cbiAgICBwcml2YXRlIGRldGVjdFZhbHVlQ2hhbmdlKHZhbHVlMTogbnVtYmVyIHwgU2xpZGVyVmFsdWUsIHZhbHVlMjogbnVtYmVyIHwgU2xpZGVyVmFsdWUpOiBib29sZWFuIHtcblxuICAgICAgICAvLyBjb21wYXJlIHR3byBzbGlkZXIgdmFsdWVzXG4gICAgICAgIGlmICh0aGlzLmlzU2xpZGVyVmFsdWUodmFsdWUxKSAmJiB0aGlzLmlzU2xpZGVyVmFsdWUodmFsdWUyKSkge1xuXG4gICAgICAgICAgICAvLyByZWZlcmVuY2VzIHRvIHRoZSBvYmplY3RzIGluIHRoZSBjb3JyZWN0IHR5cGVzXG4gICAgICAgICAgICBjb25zdCBvYmoxID0gdmFsdWUxIGFzIFNsaWRlclZhbHVlO1xuICAgICAgICAgICAgY29uc3Qgb2JqMiA9IHZhbHVlMiBhcyBTbGlkZXJWYWx1ZTtcblxuICAgICAgICAgICAgcmV0dXJuIG9iajEubG93ICE9PSBvYmoyLmxvdyB8fCBvYmoxLmhpZ2ggIT09IG9iajIuaGlnaDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIG5vdCBhIHNsaWRlciB2YWx1ZSAtIHNob3VsZCBiZSBudW1iZXIgb2YgbnVsbGFibGUgdHlwZSAtIGNvbXBhcmUgbm9ybWFsbHlcbiAgICAgICAgcmV0dXJuIHZhbHVlMSAhPT0gdmFsdWUyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciBvciBub3QgYW4gb2JqZWN0IGNvbmZvcm1zIHRvIHRoZVxuICAgICAqIFNsaWRlclZhbHVlIGludGVyZmFjZS5cbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgb2JqZWN0IHRvIGNoZWNrIC0gdGhpcyBtdXN0IGJlIHR5cGUgYW55XG4gICAgICovXG4gICAgcHJpdmF0ZSBpc1NsaWRlclZhbHVlKHZhbHVlOiBhbnkpOiBib29sZWFuIHtcblxuICAgICAgICAvLyBjaGVjayBpZiBpcyBhbiBvYmplY3RcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5leHQgY2hlY2sgaWYgaXQgY29udGFpbnMgdGhlIG5lY2Vzc2FyeSBwcm9wZXJ0aWVzXG4gICAgICAgIHJldHVybiAnbG93JyBpbiB2YWx1ZSAmJiAnaGlnaCcgaW4gdmFsdWU7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjbG9uZSh2YWx1ZTogbnVtYmVyIHwgU2xpZGVyVmFsdWUpOiBudW1iZXIgfCBTbGlkZXJWYWx1ZSB7XG5cbiAgICAgICAgLy8gaWYgaXQgaXMgbm90IGFuIG9iamVjdCBzaW1wbHkgcmV0dXJuIHRoZSB2YWx1ZVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlIGEgbmV3IG9iamVjdCBmcm9tIHRoZSBleGlzdGluZyBvbmVcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSB7IC4uLnZhbHVlIH07XG5cbiAgICAgICAgLy8gZGVsZXRlIHJlbW92ZSB0aGUgdmFsdWUgZnJvbSB0aGUgb2xkIG9iamVjdFxuICAgICAgICB2YWx1ZSA9IHVuZGVmaW5lZDtcblxuICAgICAgICAvLyByZXR1cm4gdGhlIG5ldyBpbnN0YW5jZSBvZiB0aGUgb2JqZWN0XG4gICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9XG59XG5cbmV4cG9ydCBlbnVtIFNsaWRlclR5cGUge1xuICAgIFZhbHVlLFxuICAgIFJhbmdlXG59XG5cbmV4cG9ydCBlbnVtIFNsaWRlclN0eWxlIHtcbiAgICBCdXR0b24sXG4gICAgTGluZVxufVxuXG5leHBvcnQgZW51bSBTbGlkZXJTaXplIHtcbiAgICBOYXJyb3csXG4gICAgV2lkZVxufVxuXG5leHBvcnQgZW51bSBTbGlkZXJDYWxsb3V0VHJpZ2dlciB7XG4gICAgTm9uZSxcbiAgICBIb3ZlcixcbiAgICBEcmFnLFxuICAgIFBlcnNpc3RlbnQsXG4gICAgRHluYW1pY1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNsaWRlclZhbHVlIHtcbiAgICBsb3c6IG51bWJlcjtcbiAgICBoaWdoOiBudW1iZXI7XG59XG5cbmV4cG9ydCBlbnVtIFNsaWRlclNuYXAge1xuICAgIE5vbmUsXG4gICAgTWlub3IsXG4gICAgTWFqb3IsXG4gICAgQWxsXG59XG5cbmV4cG9ydCBlbnVtIFNsaWRlclRpY2tUeXBlIHtcbiAgICBNaW5vcixcbiAgICBNYWpvclxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNsaWRlck9wdGlvbnMge1xuICAgIHR5cGU/OiBTbGlkZXJUeXBlO1xuICAgIGhhbmRsZXM/OiBTbGlkZXJIYW5kbGVPcHRpb25zO1xuICAgIHRyYWNrPzogU2xpZGVyVHJhY2tPcHRpb25zO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNsaWRlckhhbmRsZU9wdGlvbnMge1xuICAgIHN0eWxlPzogU2xpZGVyU3R5bGU7XG4gICAgY2FsbG91dD86IFNsaWRlckNhbGxvdXQ7XG4gICAga2V5Ym9hcmQ/OiBTbGlkZXJLZXlib2FyZE9wdGlvbnM7XG4gICAgYXJpYT86IFNsaWRlckFyaWFPcHRpb25zO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNsaWRlckFyaWFPcHRpb25zIHtcbiAgICB0aHVtYjogc3RyaW5nO1xuICAgIGxvd2VyVGh1bWI6IHN0cmluZztcbiAgICB1cHBlclRodW1iOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2xpZGVyS2V5Ym9hcmRPcHRpb25zIHtcbiAgICBtYWpvcj86IG51bWJlcjtcbiAgICBtaW5vcj86IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTbGlkZXJUcmFja09wdGlvbnMge1xuICAgIGhlaWdodD86IFNsaWRlclNpemU7XG4gICAgbWluPzogbnVtYmVyO1xuICAgIG1heD86IG51bWJlcjtcbiAgICB0aWNrcz86IFNsaWRlclRpY2tzT3B0aW9ucztcbiAgICBjb2xvcnM/OiBTbGlkZXJUcmFja0NvbG9ycztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTbGlkZXJUaWNrc09wdGlvbnMge1xuICAgIHNuYXA/OiBTbGlkZXJTbmFwO1xuICAgIG1ham9yPzogU2xpZGVyVGlja09wdGlvbnM7XG4gICAgbWlub3I/OiBTbGlkZXJUaWNrT3B0aW9ucztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTbGlkZXJUaWNrT3B0aW9ucyB7XG4gICAgc2hvdz86IGJvb2xlYW47XG4gICAgc3RlcHM/OiBudW1iZXIgfCBudW1iZXJbXTtcbiAgICBsYWJlbHM/OiBib29sZWFuO1xuICAgIGZvcm1hdHRlcj86ICh2YWx1ZTogbnVtYmVyKSA9PiBzdHJpbmcgfCBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2xpZGVyVGljayB7XG4gICAgc2hvd1RpY2tzOiBib29sZWFuO1xuICAgIHNob3dMYWJlbHM6IGJvb2xlYW47XG4gICAgdHlwZTogU2xpZGVyVGlja1R5cGU7XG4gICAgcG9zaXRpb246IG51bWJlcjtcbiAgICB2YWx1ZTogbnVtYmVyO1xuICAgIGxhYmVsOiBzdHJpbmcgfCBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2xpZGVyVHJhY2tDb2xvcnMge1xuICAgIGxvd2VyPzogc3RyaW5nIHwgc3RyaW5nW107XG4gICAgcmFuZ2U/OiBzdHJpbmcgfCBzdHJpbmdbXTtcbiAgICBoaWdoZXI/OiBzdHJpbmcgfCBzdHJpbmdbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTbGlkZXJDYWxsb3V0IHtcbiAgICB0cmlnZ2VyPzogU2xpZGVyQ2FsbG91dFRyaWdnZXI7XG4gICAgYmFja2dyb3VuZD86IHN0cmluZztcbiAgICBjb2xvcj86IHN0cmluZztcbiAgICBmb3JtYXR0ZXI/OiAodmFsdWU6IG51bWJlcikgPT4gc3RyaW5nIHwgbnVtYmVyO1xufVxuXG5leHBvcnQgZW51bSBTbGlkZXJUaHVtYkV2ZW50IHtcbiAgICBOb25lLFxuICAgIE1vdXNlT3ZlcixcbiAgICBNb3VzZUxlYXZlLFxuICAgIERyYWdTdGFydCxcbiAgICBEcmFnRW5kXG59XG5cbmV4cG9ydCBlbnVtIFNsaWRlclRodW1iIHtcbiAgICBMb3dlcixcbiAgICBVcHBlclxufSIsImltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29sb3JTZXJ2aWNlTW9kdWxlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvY29sb3IvaW5kZXgnO1xuXG5pbXBvcnQgeyBTbGlkZXJDb21wb25lbnQgfSBmcm9tICcuL3NsaWRlci5jb21wb25lbnQnO1xuaW1wb3J0IHsgRHJhZ01vZHVsZSB9IGZyb20gJy4uLy4uL2RpcmVjdGl2ZXMvZHJhZy9pbmRleCc7XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIENvbG9yU2VydmljZU1vZHVsZSxcbiAgICAgICAgRHJhZ01vZHVsZVxuICAgIF0sXG4gICAgZXhwb3J0czogW1NsaWRlckNvbXBvbmVudF0sXG4gICAgZGVjbGFyYXRpb25zOiBbU2xpZGVyQ29tcG9uZW50XVxufSlcbmV4cG9ydCBjbGFzcyBTbGlkZXJNb2R1bGUgeyB9IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbG9yU2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2NvbG9yL2luZGV4JztcbmltcG9ydCB7IENvbG9ySWRlbnRpZmllciB9IGZyb20gJy4uLy4uL2luZGV4JztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1zcGFyaycsXG4gICAgdGVtcGxhdGU6IGA8IS0tIElubGluZSBTcGFyayBDaGFydCAtLT5cbjxkaXYgKm5nSWY9XCJpbmxpbmVMYWJlbFwiIGNsYXNzPVwidXgtc3BhcmstaW5saW5lLWxhYmVsLWNvbnRhaW5lclwiPlxuXG4gICAgPGRpdiBjbGFzcz1cInV4LXNwYXJrLWlubGluZS1sYWJlbC1sZWZ0XCIgW2lubmVySHRtbF09XCJpbmxpbmVMYWJlbFwiPjwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cInV4LXNwYXJrLWxpbmVcIj5cblxuICAgICAgICA8ZGl2IGNsYXNzPVwidXgtc3BhcmstdG9wLWNvbnRhaW5lclwiICpuZ0lmPVwidG9wTGVmdExhYmVsIHx8IHRvcFJpZ2h0TGFiZWxcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ1eC1zcGFyay1sYWJlbC10b3AtbGVmdFwiICpuZ0lmPVwidG9wTGVmdExhYmVsXCIgW2lubmVySHRtbF09XCJ0b3BMZWZ0TGFiZWxcIj48L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ1eC1zcGFyay1sYWJlbC10b3AtcmlnaHRcIiAqbmdJZj1cInRvcFJpZ2h0TGFiZWxcIiBbaW5uZXJIdG1sXT1cInRvcFJpZ2h0TGFiZWxcIj48L2Rpdj5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cInV4LXNwYXJrIHV4LWlubGluZSB1eC1zcGFyay10aGVtZS17e3RoZW1lfX1cIiBbc3R5bGUuaGVpZ2h0LnB4XT1cImJhckhlaWdodFwiIFtzdHlsZS5iYWNrZ3JvdW5kQ29sb3JdPVwidHJhY2tDb2xvclwiIFt1eFRvb2x0aXBdPVwidG9vbHRpcFwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInV4LXNwYXJrLWJhclwiICpuZ0Zvcj1cImxldCBsaW5lIG9mIHZhbHVlczsgbGV0IGlkeCA9IGluZGV4O1wiIFtzdHlsZS53aWR0aC4lXT1cImxpbmVcIiBbc3R5bGUuYmFja2dyb3VuZENvbG9yXT1cImJhckNvbG9yW2lkeF1cIj48L2Rpdj5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cInV4LXNwYXJrLWJvdHRvbS1jb250YWluZXJcIiAqbmdJZj1cImJvdHRvbUxlZnRMYWJlbCB8fCBib3R0b21SaWdodExhYmVsXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwidXgtc3BhcmstbGFiZWwtYm90dG9tLWxlZnRcIiAqbmdJZj1cImJvdHRvbUxlZnRMYWJlbFwiIFtpbm5lckh0bWxdPVwiYm90dG9tTGVmdExhYmVsXCI+PC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwidXgtc3BhcmstbGFiZWwtYm90dG9tLXJpZ2h0XCIgKm5nSWY9XCJib3R0b21SaWdodExhYmVsXCIgW2lubmVySHRtbF09XCJib3R0b21SaWdodExhYmVsXCI+PC9kaXY+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgPC9kaXY+XG48L2Rpdj5cblxuPCEtLSBFbmQgSW5saW5lIFNwYXJrIENoYXJ0IC0tPlxuXG5cbjwhLS0gTm9uIElubGluZSBTcGFyayBDaGFydCAtLT5cbjxkaXYgKm5nSWY9XCIhaW5saW5lTGFiZWxcIj5cblxuICAgIDxkaXYgY2xhc3M9XCJ1eC1zcGFyay10b3AtY29udGFpbmVyXCIgKm5nSWY9XCJ0b3BMZWZ0TGFiZWwgfHwgdG9wUmlnaHRMYWJlbFwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwidXgtc3BhcmstbGFiZWwtdG9wLWxlZnRcIiAqbmdJZj1cInRvcExlZnRMYWJlbFwiIFtpbm5lckh0bWxdPVwidG9wTGVmdExhYmVsXCI+PC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJ1eC1zcGFyay1sYWJlbC10b3AtcmlnaHRcIiAqbmdJZj1cInRvcFJpZ2h0TGFiZWxcIiBbaW5uZXJIdG1sXT1cInRvcFJpZ2h0TGFiZWxcIj48L2Rpdj5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJ1eC1zcGFyayB1eC1zcGFyay10aGVtZS17e3RoZW1lfX1cIiBbY2xhc3MudXgtc3BhcmstbXVsdGktdmFsdWVdPVwidmFsdWVzLmxlbmd0aCA+IDFcIiBbc3R5bGUuaGVpZ2h0LnB4XT1cImJhckhlaWdodFwiIFtzdHlsZS5iYWNrZ3JvdW5kQ29sb3JdPVwidHJhY2tDb2xvclwiXG4gICAgICAgIFt1eFRvb2x0aXBdPVwidG9vbHRpcFwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwidXgtc3BhcmstYmFyXCIgKm5nRm9yPVwibGV0IGxpbmUgb2YgdmFsdWU7IGxldCBpZHggPSBpbmRleDtcIiBbc3R5bGUud2lkdGguJV09XCJsaW5lXCIgW3N0eWxlLmJhY2tncm91bmRDb2xvcl09XCJiYXJDb2xvcltpZHhdXCI+PC9kaXY+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwidXgtc3BhcmstYm90dG9tLWNvbnRhaW5lclwiICpuZ0lmPVwiYm90dG9tTGVmdExhYmVsIHx8IGJvdHRvbVJpZ2h0TGFiZWxcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInV4LXNwYXJrLWxhYmVsLWJvdHRvbS1sZWZ0XCIgKm5nSWY9XCJib3R0b21MZWZ0TGFiZWxcIiBbaW5uZXJIdG1sXT1cImJvdHRvbUxlZnRMYWJlbFwiPjwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwidXgtc3BhcmstbGFiZWwtYm90dG9tLXJpZ2h0XCIgKm5nSWY9XCJib3R0b21SaWdodExhYmVsXCIgW2lubmVySHRtbF09XCJib3R0b21SaWdodExhYmVsXCI+PC9kaXY+XG4gICAgPC9kaXY+XG48L2Rpdj5cblxuPCEtLSBFbmQgTm9uIElubGluZSBTcGFyayBDaGFydCAtLT5gLFxuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG59KVxuZXhwb3J0IGNsYXNzIFNwYXJrQ29tcG9uZW50IHtcblxuICAgIHZhbHVlczogbnVtYmVyW10gPSBbXTtcblxuICAgIEBJbnB1dCgpIGJhckhlaWdodDogbnVtYmVyID0gMTA7XG4gICAgQElucHV0KCkgaW5saW5lTGFiZWw6IHN0cmluZztcbiAgICBASW5wdXQoKSB0b3BMZWZ0TGFiZWw6IHN0cmluZztcbiAgICBASW5wdXQoKSB0b3BSaWdodExhYmVsOiBzdHJpbmc7XG4gICAgQElucHV0KCkgYm90dG9tTGVmdExhYmVsOiBzdHJpbmc7XG4gICAgQElucHV0KCkgYm90dG9tUmlnaHRMYWJlbDogc3RyaW5nO1xuICAgIEBJbnB1dCgpIHRvb2x0aXA6IHN0cmluZztcblxuICAgIHByaXZhdGUgX3RyYWNrQ29sb3I6IHN0cmluZztcbiAgICBwcml2YXRlIF90aGVtZTogQ29sb3JJZGVudGlmaWVyID0gJ3ByaW1hcnknOyAgICBcbiAgICBwcml2YXRlIF9iYXJDb2xvcjogc3RyaW5nIHwgc3RyaW5nW10gPSBbXTtcbiAgICBcbiAgICBASW5wdXQoKSBcbiAgICBzZXQgdGhlbWUodmFsdWU6IHN0cmluZykge1xuICAgICAgICB0aGlzLl90aGVtZSA9IHRoaXMuX2NvbG9yU2VydmljZS5yZXNvbHZlQ29sb3JOYW1lKHZhbHVlKTtcbiAgICB9XG5cbiAgICBnZXQgdGhlbWUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RoZW1lO1xuICAgIH1cblxuICAgIEBJbnB1dCgpIFxuICAgIHNldCB0cmFja0NvbG9yKHZhbHVlOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5fdHJhY2tDb2xvciA9IHRoaXMuX2NvbG9yU2VydmljZS5yZXNvbHZlKHZhbHVlKTtcbiAgICB9XG5cbiAgICBnZXQgdHJhY2tDb2xvcigpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJhY2tDb2xvcjtcbiAgICB9XG5cbiAgICBASW5wdXQoKSBcbiAgICBzZXQgYmFyQ29sb3IodmFsdWU6IHN0cmluZyB8IHN0cmluZ1tdKSB7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLl9iYXJDb2xvciA9IHZhbHVlLm1hcChjb2xvciA9PiB0aGlzLl9jb2xvclNlcnZpY2UucmVzb2x2ZShjb2xvcikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fYmFyQ29sb3IgPSBbdGhpcy5fY29sb3JTZXJ2aWNlLnJlc29sdmUodmFsdWUpXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBiYXJDb2xvcigpOiBzdHJpbmcgfCBzdHJpbmdbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9iYXJDb2xvcjtcbiAgICB9XG5cbiAgICBASW5wdXQoKVxuICAgIHNldCB2YWx1ZSh2YWx1ZTogbnVtYmVyIHwgbnVtYmVyW10pIHtcblxuICAgICAgICAvLyBlbnN1cmUgJ3ZhbHVlJyBpcyBhbiBhcnJheSBhdCB0aGlzIHBvaW50XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdO1xuXG4gICAgICAgIC8vIGdldCB0aGUgdG90YWwgdmFsdWUgb2YgYWxsIGxpbmVzXG4gICAgICAgIGNvbnN0IHRvdGFsID0gTWF0aC5tYXgodmFsdWVzLnJlZHVjZSgocHJldmlvdXMsIGN1cnJlbnQpID0+IHByZXZpb3VzICsgY3VycmVudCwgMCksIDEwMCk7XG5cbiAgICAgICAgLy8gZmlndXJlIG91dCB0aGUgcGVyY2VudGFnZXMgZm9yIGVhY2ggc3BhcmsgbGluZVxuICAgICAgICB0aGlzLnZhbHVlcyA9IHZhbHVlcy5tYXAodmFsID0+ICh2YWwgLyB0b3RhbCkgKiAxMDApO1xuICAgIH1cblxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVzO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX2NvbG9yU2VydmljZTogQ29sb3JTZXJ2aWNlKSB7IH1cbn0iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcblxuaW1wb3J0IHsgU3BhcmtDb21wb25lbnQgfSBmcm9tICcuL3NwYXJrLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBDb2xvclNlcnZpY2VNb2R1bGUgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9jb2xvci9pbmRleCc7XG5pbXBvcnQgeyBUb29sdGlwTW9kdWxlIH0gZnJvbSAnLi4vdG9vbHRpcC9pbmRleCc7XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIENvbG9yU2VydmljZU1vZHVsZSxcbiAgICAgICAgVG9vbHRpcE1vZHVsZVxuICAgIF0sXG4gICAgZXhwb3J0czogW1NwYXJrQ29tcG9uZW50XSxcbiAgICBkZWNsYXJhdGlvbnM6IFtTcGFya0NvbXBvbmVudF1cbn0pXG5leHBvcnQgY2xhc3MgU3BhcmtNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QgfSBmcm9tICdyeGpzL0JlaGF2aW9yU3ViamVjdCc7XG5pbXBvcnQgeyBUYWJDb21wb25lbnQgfSBmcm9tICcuL3RhYi90YWIuY29tcG9uZW50JztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFRhYnNldFNlcnZpY2Uge1xuXG4gICAgdGFicyQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PFRhYkNvbXBvbmVudFtdPihbXSk7XG4gICAgYWN0aXZlJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8VGFiQ29tcG9uZW50PihudWxsKTtcbiAgICBmb2N1c2VkJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4oZmFsc2UpO1xuICAgIGhpZ2hsaWdodGVkJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8VGFiQ29tcG9uZW50PihudWxsKTtcblxuICAgIGFkZCh0YWI6IFRhYkNvbXBvbmVudCk6IHZvaWQge1xuICAgICAgICB0aGlzLnRhYnMkLm5leHQoWy4uLnRoaXMudGFicyQudmFsdWUsIHRhYl0pO1xuXG4gICAgICAgIC8vIGNoZWNrIGlmIHRoaXMgaXMgdGhlIG9ubHkgdGFiLiBJZiBzbyBzZWxlY3QgdGhpcyBieSBkZWZhdWx0XG4gICAgICAgIGlmICghdGhpcy5hY3RpdmUkLnZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdCh0YWIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVtb3ZlKHRhYjogVGFiQ29tcG9uZW50KTogdm9pZCB7XG5cbiAgICAgICAgLy8gcmVtb3ZlIHRoZSB0YWJcbiAgICAgICAgdGhpcy50YWJzJC5uZXh0KHRoaXMudGFicyQudmFsdWUuZmlsdGVyKF90YWIgPT4gX3RhYiAhPT0gdGFiKSk7XG4gICAgfVxuXG4gICAgc2VsZWN0KHRhYjogVGFiQ29tcG9uZW50KTogdm9pZCB7XG4gICAgICAgIGlmICghdGFiLmRpc2FibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZSQubmV4dCh0YWIpO1xuICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRlZCQubmV4dCh0YWIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2VsZWN0QXRJbmRleChpbmRleDogbnVtYmVyKTogdm9pZCB7XG5cbiAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG5vIHRhYnMgdGhlbiBkbyBub3RoaW5nXG4gICAgICAgIGlmICh0aGlzLnRhYnMkLnZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlIGluZGV4IGlzIHdpdGhpbiB0aGUgYm91bmRzXG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbGVjdEF0SW5kZXgodGhpcy50YWJzJC52YWx1ZS5sZW5ndGggLSAxKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbmRleCA+PSB0aGlzLnRhYnMkLnZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0QXRJbmRleCgwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMudGFicyQudmFsdWVbaW5kZXhdO1xuXG4gICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0KHRhcmdldCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxlY3ROZXh0VGFiKCk6IHZvaWQge1xuICAgICAgICAvLyBmaW5kIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgaW5kZXhcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLnRhYnMkLnZhbHVlLmluZGV4T2YodGhpcy5hY3RpdmUkLnZhbHVlKTtcblxuICAgICAgICAvLyBjaGVjayB0aGUgdGFicyBhZnRlciB0aGUgYWN0aXZlIG9uZSB0byBzZWUgaWYgdGhlcmUgYXJlIGFueSBzZWxlY3RhYmxlIHRhYnNcbiAgICAgICAgY29uc3QgdGFicyA9IHRoaXMudGFicyQudmFsdWUuc2xpY2UoaW5kZXggKyAxKTtcblxuICAgICAgICAvLyBjaGVjayBpZiBhbnkgb2YgdGhlIHRhYnMgYXJlIG5vdCBkaXNhYmxlZFxuICAgICAgICBmb3IgKGxldCB0YWIgb2YgdGFicykge1xuICAgICAgICAgICAgaWYgKCF0YWIuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3QodGFiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHdlIHJlYWNoIGhlcmUgdGhlbiBubyB0YWIgY291bGQgYmUgc2VsZWN0ZWQgLSBzZWxlY3QgdGhlIGZpcnN0IHRhYlxuICAgICAgICB0aGlzLnNlbGVjdEZpcnN0VGFiKCk7XG4gICAgfVxuXG4gICAgc2VsZWN0UHJldmlvdXNUYWIoKTogdm9pZCB7XG4gICAgICAgIC8vIGZpbmQgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBpbmRleFxuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMudGFicyQudmFsdWUuaW5kZXhPZih0aGlzLmFjdGl2ZSQudmFsdWUpO1xuXG4gICAgICAgIC8vIGNoZWNrIHRoZSB0YWJzIGJlZm9yZSB0aGUgYWN0aXZlIG9uZSB0byBzZWUgaWYgdGhlcmUgYXJlIGFueSBzZWxlY3RhYmxlIHRhYnNcbiAgICAgICAgY29uc3QgdGFicyA9IHRoaXMudGFicyQudmFsdWUuc2xpY2UoMCwgaW5kZXgpO1xuXG4gICAgICAgIC8vIGNoZWNrIGlmIGFueSBvZiB0aGUgdGFicyBhcmUgbm90IGRpc2FibGVkXG4gICAgICAgIGZvciAobGV0IHRhYiBvZiB0YWJzLnJldmVyc2UoKSkge1xuICAgICAgICAgICAgaWYgKCF0YWIuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3QodGFiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHdlIHJlYWNoIGhlcmUgdGhlbiBubyBwcmV2aW91cyB0YWIgY291bGQgYmUgc2VsZWN0ZWQgLSBzZWxlY3QgdGhlIGxhc3QgdGFiXG4gICAgICAgIHRoaXMuc2VsZWN0TGFzdFRhYigpO1xuICAgIH1cblxuICAgIHNlbGVjdEZpcnN0VGFiKCk6IHZvaWQge1xuICAgICAgICAvLyBmaW5kIHRoZSBpbmRleCBvZiB0aGUgZmlyc3Qgbm9uLWRpc2FibGVkIHRhYlxuICAgICAgICBjb25zdCB0YWJJbmRleCA9IHRoaXMudGFicyQudmFsdWUuZmluZEluZGV4KHRhYiA9PiAhdGFiLmRpc2FibGVkKTtcblxuICAgICAgICBpZiAodGFiSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdEF0SW5kZXgodGFiSW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2VsZWN0TGFzdFRhYigpOiB2b2lkIHtcbiAgICAgICAgLy8gZmluZCB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IG5vbi1kaXNhYmxlZCB0YWJcbiAgICAgICAgY29uc3QgdGFiSW5kZXggPSB0aGlzLnRhYnMkLnZhbHVlLnNsaWNlKCkucmV2ZXJzZSgpLmZpbmRJbmRleCh0YWIgPT4gIXRhYi5kaXNhYmxlZCk7XG5cbiAgICAgICAgaWYgKHRhYkluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RBdEluZGV4KCh0aGlzLnRhYnMkLnZhbHVlLmxlbmd0aCAtIDEpIC0gdGFiSW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxufSAiLCJpbXBvcnQgeyBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgQ29tcG9uZW50LCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVGFiQ29tcG9uZW50IH0gZnJvbSAnLi90YWIvdGFiLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBUYWJzZXRTZXJ2aWNlIH0gZnJvbSAnLi90YWJzZXQuc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtdGFic2V0JyxcbiAgICB0ZW1wbGF0ZTogYDwhLS0gTmF2IHRhYnMgLS0+XG48dWwgcm9sZT1cInRhYmxpc3RcIlxuICAgIGNsYXNzPVwibmF2IG5hdi10YWJzXCJcbiAgICBbY2xhc3MubWluaW1hbC10YWJdPVwibWluaW1hbFwiXG4gICAgW2F0dHIuYXJpYS1sYWJlbF09XCJhcmlhTGFiZWxcIlxuICAgIFthdHRyLmFyaWEtb3JpZW50YXRpb25dPVwic3RhY2tlZCA9PT0gJ25vbmUnID8gJ2hvcml6b250YWwnIDogJ3ZlcnRpY2FsJ1wiPlxuXG5cdDxsaSByb2xlPVwicHJlc2VudGF0aW9uXCIgXG4gICAgICAgIGNsYXNzPVwibmF2LWl0ZW1cIlxuICAgICAgICAqbmdGb3I9XCJsZXQgdGFiIG9mIHRhYnNldC50YWJzJCB8IGFzeW5jOyBsZXQgaW5kZXggPSBpbmRleFwiXG4gICAgICAgIFtjbGFzcy5hY3RpdmVdPVwidGFiLmFjdGl2ZSQgfCBhc3luY1wiXG4gICAgICAgIFtjbGFzcy5kaXNhYmxlZF09XCJ0YWIuZGlzYWJsZWRcIlxuICAgICAgICBbbmdDbGFzc109XCJ0YWIuY3VzdG9tQ2xhc3NcIj5cblxuICAgICAgICA8YSBjbGFzcz1cIm5hdi1saW5rXCJcbiAgICAgICAgICAgIFtpZF09XCJ0YWIuaWRcIlxuICAgICAgICAgICAgcm9sZT1cInRhYlwiXG4gICAgICAgICAgICBbdXhUYWJGb2N1c109XCJ0YWJcIlxuICAgICAgICAgICAgW3RhYmluZGV4XT1cIih0YWIuYWN0aXZlJCB8IGFzeW5jKSA/IDAgOiAtMVwiXG4gICAgICAgICAgICBbY2xhc3MuaGlnaGxpZ2h0ZWRdPVwiKHRhYnNldC5mb2N1c2VkJCB8IGFzeW5jKSAmJiAodGFic2V0LmhpZ2hsaWdodGVkJCB8IGFzeW5jKSA9PT0gdGFiXCIgICAgICAgICAgICBcbiAgICAgICAgICAgIChtb3VzZWRvd24pPVwidGFic2V0LnNlbGVjdCh0YWIpXCJcbiAgICAgICAgICAgIChmb2N1cyk9XCJ0YWJzZXQuZm9jdXNlZCQubmV4dCh0cnVlKVwiXG4gICAgICAgICAgICAoYmx1cik9XCJ0YWJzZXQuZm9jdXNlZCQubmV4dChmYWxzZSlcIlxuICAgICAgICAgICAgKG1vdXNlZG93bik9XCJ0YWJzZXQuZm9jdXNlZCQubmV4dCh0cnVlKVwiXG4gICAgICAgICAgICAoa2V5ZG93bi5BcnJvd1VwKT1cInNlbGVjdFByZXZpb3VzVGFiKCRldmVudClcIlxuICAgICAgICAgICAgKGtleWRvd24uQXJyb3dMZWZ0KT1cInNlbGVjdFByZXZpb3VzVGFiKCRldmVudClcIlxuICAgICAgICAgICAgKGtleWRvd24uQXJyb3dSaWdodCk9XCJzZWxlY3ROZXh0VGFiKCRldmVudClcIlxuICAgICAgICAgICAgKGtleWRvd24uQXJyb3dEb3duKT1cInNlbGVjdE5leHRUYWIoJGV2ZW50KVwiXG4gICAgICAgICAgICAoa2V5ZG93bi5Ib21lKT1cInRhYnNldC5zZWxlY3RGaXJzdFRhYigpOyAkZXZlbnQucHJldmVudERlZmF1bHQoKVwiXG4gICAgICAgICAgICAoa2V5ZG93bi5FbmQpPVwidGFic2V0LnNlbGVjdExhc3RUYWIoKTsgJGV2ZW50LnByZXZlbnREZWZhdWx0KClcIlxuICAgICAgICAgICAgW2F0dHIuYXJpYS1jb250cm9sc109XCJ0YWIuaWRcIlxuICAgICAgICAgICAgW2F0dHIuYXJpYS1zZWxlY3RlZF09XCJ0YWIuYWN0aXZlJCB8IGFzeW5jXCJcbiAgICAgICAgICAgIFthdHRyLmFyaWEtZGlzYWJsZWRdPVwidGFiLmRpc2FibGVkXCI+XG5cbiAgICAgICAgICAgIDxzcGFuICpuZ0lmPVwiIXRhYi5oZWFkaW5nUmVmXCI+e3sgdGFiLmhlYWRpbmcgfX08L3NwYW4+XG5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJ0YWIuaGVhZGluZ1JlZlwiIFtuZ1RlbXBsYXRlT3V0bGV0XT1cInRhYi5oZWFkaW5nUmVmXCI+PC9uZy1jb250YWluZXI+XG4gICAgICAgIDwvYT5cblxuXHQ8L2xpPlxuXG48L3VsPlxuXG48IS0tIFRhYiBwYW5lcyAtLT5cbjxkaXYgY2xhc3M9XCJ0YWItY29udGVudFwiPlxuXHQ8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG48L2Rpdj5gLFxuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgIHByb3ZpZGVyczogW1RhYnNldFNlcnZpY2VdLFxuICAgIGhvc3Q6IHtcbiAgICAgICAgJ1tjbGFzcy50YWJzLWxlZnRdJzogJ3N0YWNrZWQgPT09IFwibGVmdFwiJyxcbiAgICAgICAgJ1tjbGFzcy50YWJzLXJpZ2h0XSc6ICdzdGFja2VkID09PSBcInJpZ2h0XCInLFxuICAgIH1cbn0pXG5leHBvcnQgY2xhc3MgVGFic2V0Q29tcG9uZW50IHtcblxuICAgIEBJbnB1dCgpIG1pbmltYWw6IGJvb2xlYW4gPSB0cnVlO1xuICAgIEBJbnB1dCgpIHN0YWNrZWQ6ICdsZWZ0JyB8ICdyaWdodCcgfCAnbm9uZScgPSAnbm9uZSc7XG4gICAgQElucHV0KCdhcmlhLWxhYmVsJykgYXJpYUxhYmVsOiBzdHJpbmc7XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgdGFic2V0OiBUYWJzZXRTZXJ2aWNlKSB7IH1cblxuICAgIC8qKlxuICAgICAqIEFsbG93IG1hbnVhbCB0YWIgc2VsZWN0ZWRcbiAgICAgKi9cbiAgICBzZWxlY3QodGFiOiBUYWJDb21wb25lbnQpOiB2b2lkIHtcbiAgICAgICAgdGhpcy50YWJzZXQuc2VsZWN0KHRhYik7XG4gICAgfVxuXG4gICAgc2VsZWN0UHJldmlvdXNUYWIoZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcblxuICAgICAgICAvLyBkZXRlcm1pbmUgd2hpY2ggYXJyb3cga2V5IGlzIHByZXNzZWRcbiAgICAgICAgY29uc3QgYXJyb3dMZWZ0ID0gZXZlbnQua2V5ID09PSAnQXJyb3dMZWZ0JyB8fCBldmVudC5rZXlDb2RlID09PSAzNztcbiAgICAgICAgY29uc3QgYXJyb3dVcCA9IGV2ZW50LmtleSA9PT0gJ0Fycm93VXAnIHx8IGV2ZW50LmtleUNvZGUgPT09IDM4O1xuXG4gICAgICAgIC8vIG9ubHkgcGVyZm9ybSBhY3Rpb24gaWYgdGhlIGFycm93IGtleSBtYXRjaGVzIHRoZSBvcmllbnRhdGlvblxuICAgICAgICBpZiAoYXJyb3dMZWZ0ICYmIHRoaXMuc3RhY2tlZCAhPT0gJ25vbmUnIHx8IGFycm93VXAgJiYgdGhpcy5zdGFja2VkID09PSAnbm9uZScpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHBlcmZvcm0gc2VsZWN0aW9uXG4gICAgICAgIHRoaXMudGFic2V0LnNlbGVjdFByZXZpb3VzVGFiKCk7XG5cbiAgICAgICAgLy8gcHJldmVudCB0aGUgYnJvd3NlciBmcm9tIHNjcm9sbGluZyB3aGVuIGFycm93IGtleXMgYXJlIHByZXNzZWRcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICBzZWxlY3ROZXh0VGFiKGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZCB7XG5cbiAgICAgICAgLy8gZGV0ZXJtaW5lIHdoaWNoIGFycm93IGtleSBpcyBwcmVzc2VkXG4gICAgICAgIGNvbnN0IGFycm93UmlnaHQgPSBldmVudC5rZXkgPT09ICdBcnJvd1JpZ2h0JyB8fCBldmVudC5rZXlDb2RlID09PSAzOTtcbiAgICAgICAgY29uc3QgYXJyb3dEb3duID0gZXZlbnQua2V5ID09PSAnQXJyb3dEb3duJyB8fCBldmVudC5rZXlDb2RlID09PSA0MDtcblxuICAgICAgICAvLyBvbmx5IHBlcmZvcm0gYWN0aW9uIGlmIHRoZSBhcnJvdyBrZXkgbWF0Y2hlcyB0aGUgb3JpZW50YXRpb25cbiAgICAgICAgaWYgKGFycm93UmlnaHQgJiYgdGhpcy5zdGFja2VkICE9PSAnbm9uZScgfHwgYXJyb3dEb3duICYmIHRoaXMuc3RhY2tlZCA9PT0gJ25vbmUnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwZXJmb3JtIHNlbGVjdGlvblxuICAgICAgICB0aGlzLnRhYnNldC5zZWxlY3ROZXh0VGFiKCk7XG5cbiAgICAgICAgLy8gcHJldmVudCB0aGUgYnJvd3NlciBmcm9tIHNjcm9sbGluZyB3aGVuIGFycm93IGtleXMgYXJlIHByZXNzZWRcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT25EZXN0cm95LCBPdXRwdXQsIFRlbXBsYXRlUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcy9PYnNlcnZhYmxlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IG1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFRhYnNldFNlcnZpY2UgfSBmcm9tICcuLi90YWJzZXQuc2VydmljZSc7XG5cbmxldCB1bmlxdWVUYWJJZCA9IDA7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtdGFiJyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgcm9sZT1cInRhYnBhbmVsXCJcbiAgICAgY2xhc3M9XCJ0YWItcGFuZVwiXG4gICAgIFtjbGFzcy5hY3RpdmVdPVwiYWN0aXZlJCB8IGFzeW5jXCJcbiAgICAgW2lkXT1cImlkICsgJy1wYW5lbCdcIlxuICAgICBbYXR0ci5hcmlhLWxhYmVsbGVkYnldPVwiaWRcIlxuICAgICBbYXR0ci5hcmlhLWhpZGRlbl09XCIhKGFjdGl2ZSQgfCBhc3luYylcIj5cbiAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuPC9kaXY+YCxcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxufSlcbmV4cG9ydCBjbGFzcyBUYWJDb21wb25lbnQgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuXG4gICAgQElucHV0KCkgaWQ6IHN0cmluZyA9IGB1eC10YWItJHsrK3VuaXF1ZVRhYklkfWA7XG4gICAgQElucHV0KCkgZGlzYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBASW5wdXQoKSBoZWFkaW5nOiBzdHJpbmc7XG4gICAgQElucHV0KCkgY3VzdG9tQ2xhc3M6IHN0cmluZztcblxuICAgIEBPdXRwdXQoKSBzZWxlY3QgPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG4gICAgQE91dHB1dCgpIGRlc2VsZWN0ID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuXG4gICAgQElucHV0KCkgc2V0IGFjdGl2ZSh2YWx1ZTogYm9vbGVhbikge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3RhYnNldC5zZWxlY3QodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBoZWFkaW5nUmVmOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICAgIGFjdGl2ZSQ6IE9ic2VydmFibGU8Ym9vbGVhbj4gPSB0aGlzLl90YWJzZXQuYWN0aXZlJC5waXBlKG1hcChhY3RpdmUgPT4gYWN0aXZlID09PSB0aGlzKSk7XG5cbiAgICBwcml2YXRlIF9zdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX3RhYnNldDogVGFic2V0U2VydmljZSkge1xuICAgICAgICBfdGFic2V0LmFkZCh0aGlzKTtcblxuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24gPSB0aGlzLmFjdGl2ZSQuc3Vic2NyaWJlKGFjdGl2ZSA9PiBhY3RpdmUgPyB0aGlzLnNlbGVjdC5lbWl0KCkgOiB0aGlzLmRlc2VsZWN0LmVtaXQoKSk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3RhYnNldC5yZW1vdmUodGhpcyk7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cblxufSIsImltcG9ydCB7IERpcmVjdGl2ZSwgVGVtcGxhdGVSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFRhYkNvbXBvbmVudCB9IGZyb20gJy4vdGFiLmNvbXBvbmVudCc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3V4VGFiSGVhZGluZ10nXG59KVxuZXhwb3J0IGNsYXNzIFRhYkhlYWRpbmdEaXJlY3RpdmUge1xuXG4gICAgY29uc3RydWN0b3IodGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPGFueT4sIHRhYjogVGFiQ29tcG9uZW50KSB7XG4gICAgICAgIHRhYi5oZWFkaW5nUmVmID0gdGVtcGxhdGVSZWY7XG4gICAgfVxuXG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbnB1dCwgT25EZXN0cm95LCBPbkluaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IGZpbHRlciB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFRhYnNldFNlcnZpY2UgfSBmcm9tICcuLi90YWJzZXQuc2VydmljZSc7XG5pbXBvcnQgeyBUYWJDb21wb25lbnQgfSBmcm9tICcuL3RhYi5jb21wb25lbnQnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1t1eFRhYkZvY3VzXSdcbn0pXG5leHBvcnQgY2xhc3MgVGFiRm9jdXNEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG5cbiAgICBASW5wdXQoKSB1eFRhYkZvY3VzOiBUYWJDb21wb25lbnQ7XG5cbiAgICBwcml2YXRlIF9zdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX3RhYnNldDogVGFic2V0U2VydmljZSwgcHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZikgeyB9XG5cbiAgICBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gdGhpcy5fdGFic2V0LmhpZ2hsaWdodGVkJC5waXBlKFxuICAgICAgICAgICAgZmlsdGVyKCgpID0+IHRoaXMuX3RhYnNldC5mb2N1c2VkJC52YWx1ZSA9PT0gdHJ1ZSksXG4gICAgICAgICAgICBmaWx0ZXIoKCkgPT4gdGhpcy5fdGFic2V0LmhpZ2hsaWdodGVkJC52YWx1ZSA9PT0gdGhpcy51eFRhYkZvY3VzKSxcbiAgICAgICAgKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmZvY3VzKCkpO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBUYWJzZXRDb21wb25lbnQgfSBmcm9tICcuL3RhYnNldC5jb21wb25lbnQnO1xuaW1wb3J0IHsgVGFic2V0U2VydmljZSB9IGZyb20gJy4vdGFic2V0LnNlcnZpY2UnO1xuaW1wb3J0IHsgVGFiQ29tcG9uZW50IH0gZnJvbSAnLi90YWIvdGFiLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBUYWJIZWFkaW5nRGlyZWN0aXZlIH0gZnJvbSAnLi90YWIvdGFiLWhlYWRpbmcuZGlyZWN0aXZlJztcbmltcG9ydCB7IFRhYkZvY3VzRGlyZWN0aXZlIH0gZnJvbSAnLi90YWIvdGFiLWZvY3VzLmRpcmVjdGl2ZSc7XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGVcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtUYWJzZXRDb21wb25lbnQsIFRhYkNvbXBvbmVudCwgVGFiSGVhZGluZ0RpcmVjdGl2ZV0sXG4gICAgZGVjbGFyYXRpb25zOiBbVGFic2V0Q29tcG9uZW50LCBUYWJDb21wb25lbnQsIFRhYkhlYWRpbmdEaXJlY3RpdmUsIFRhYkZvY3VzRGlyZWN0aXZlXSxcbn0pXG5leHBvcnQgY2xhc3MgVGFic2V0TW9kdWxlIHsgfSIsImltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgICBzZWxlY3RvcjogJ3V4LXRpbWVsaW5lJyxcclxuICAgIHRlbXBsYXRlOiBgPGRpdiBjbGFzcz1cInRpbWVsaW5lXCI+XHJcbiAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XHJcbjwvZGl2PlxyXG5gXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBUaW1lbGluZUNvbXBvbmVudCB7XHJcbn0iLCJpbXBvcnQgeyBDb21wb25lbnQsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICAgIHNlbGVjdG9yOiAndXgtdGltZWxpbmUtZXZlbnQnLFxyXG4gICAgdGVtcGxhdGU6IGA8ZGl2IGNsYXNzPVwidGltZWxpbmUtYmFkZ2VcIiBbbmdDbGFzc109XCJiYWRnZUNvbG9yXCI+XHJcbiAgICA8c3Bhbj57e2JhZGdlVGl0bGV9fTwvc3Bhbj5cclxuPC9kaXY+XHJcbjxkaXYgY2xhc3M9XCJ0aW1lbGluZS1wYW5lbFwiPlxyXG4gICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxyXG48L2Rpdj5cclxuYFxyXG59KVxyXG5leHBvcnQgY2xhc3MgVGltZWxpbmVFdmVudENvbXBvbmVudCB7XHJcblxyXG4gICAgQElucHV0KCkgYmFkZ2VDb2xvcjogc3RyaW5nO1xyXG4gICAgQElucHV0KCkgYmFkZ2VUaXRsZTogc3RyaW5nO1xyXG59IiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcclxuaW1wb3J0IHsgVGltZWxpbmVDb21wb25lbnQgfSBmcm9tICcuL3RpbWVsaW5lLmNvbXBvbmVudCc7XHJcbmltcG9ydCB7IFRpbWVsaW5lRXZlbnRDb21wb25lbnQgfSBmcm9tICcuL3RpbWVsaW5lLWV2ZW50L3RpbWVsaW5lLWV2ZW50LmNvbXBvbmVudCc7XHJcblxyXG5ATmdNb2R1bGUoe1xyXG4gICAgaW1wb3J0czogW1xyXG4gICAgICAgIENvbW1vbk1vZHVsZVxyXG4gICAgXSxcclxuICAgIGV4cG9ydHM6IFtcclxuICAgICAgICBUaW1lbGluZUNvbXBvbmVudCxcclxuICAgICAgICBUaW1lbGluZUV2ZW50Q29tcG9uZW50XHJcbiAgICBdLFxyXG4gICAgZGVjbGFyYXRpb25zOiBbXHJcbiAgICAgICAgVGltZWxpbmVDb21wb25lbnQsXHJcbiAgICAgICAgVGltZWxpbmVFdmVudENvbXBvbmVudFxyXG4gICAgXVxyXG59KVxyXG5leHBvcnQgY2xhc3MgVGltZWxpbmVNb2R1bGUgeyB9XHJcbiIsImltcG9ydCB7IENvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBmb3J3YXJkUmVmLCBJbnB1dCwgT3V0cHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb250cm9sVmFsdWVBY2Nlc3NvciwgTkdfVkFMVUVfQUNDRVNTT1IgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmNvbnN0IFRPR0dMRVNXSVRDSF9WQUxVRV9BQ0NFU1NPUiA9IHtcbiAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBUb2dnbGVTd2l0Y2hDb21wb25lbnQpLFxuICAgIG11bHRpOiB0cnVlXG59O1xuXG5sZXQgdW5pcXVlVG9nZ2xlU3dpdGNoSWQgPSAwO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LXRvZ2dsZXN3aXRjaCcsXG4gICAgdGVtcGxhdGU6IGA8bGFiZWwgW2F0dHIuZm9yXT1cImlucHV0SWRcIlxuICAgICAgIGNsYXNzPVwidXgtdG9nZ2xlc3dpdGNoXCJcbiAgICAgICBbY2xhc3MudXgtdG9nZ2xlc3dpdGNoLWNoZWNrZWRdPVwidmFsdWVcIlxuICAgICAgIFtjbGFzcy51eC10b2dnbGVzd2l0Y2gtZGlzYWJsZWRdPVwiZGlzYWJsZWRcIlxuICAgICAgIFtjbGFzcy51eC10b2dnbGVzd2l0Y2gtZm9jdXNlZF09XCJmb2N1c2VkXCI+XG5cbiAgICA8aW5wdXQgY2xhc3M9XCJ1eC10b2dnbGVzd2l0Y2gtaW5wdXRcIlxuICAgICAgICAgICB0eXBlPVwiY2hlY2tib3hcIlxuICAgICAgICAgICByb2xlPVwic3dpdGNoXCJcbiAgICAgICAgICAgW2lkXT1cImlucHV0SWRcIlxuICAgICAgICAgICBbY2hlY2tlZF09XCJ2YWx1ZVwiXG4gICAgICAgICAgIFtkaXNhYmxlZF09XCJkaXNhYmxlZFwiXG4gICAgICAgICAgIFthdHRyLm5hbWVdPVwibmFtZVwiXG4gICAgICAgICAgIFt0YWJpbmRleF09XCJ0YWJpbmRleFwiXG4gICAgICAgICAgIFthdHRyLmFyaWEtbGFiZWxdPVwiYXJpYUxhYmVsXCJcbiAgICAgICAgICAgW2F0dHIuYXJpYS1sYWJlbGxlZGJ5XT1cImFyaWFMYWJlbGxlZGJ5XCJcbiAgICAgICAgICAgW2F0dHIuYXJpYS1jaGVja2VkXT1cInZhbHVlXCJcbiAgICAgICAgICAgKGZvY3VzKT1cImZvY3VzZWQgPSB0cnVlXCJcbiAgICAgICAgICAgKGJsdXIpPVwiZm9jdXNlZCA9IGZhbHNlXCJcbiAgICAgICAgICAgKGNoYW5nZSk9XCJ0b2dnbGUoKVwiXG4gICAgICAgICAgIChjbGljayk9XCIkZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcIj5cblxuICAgIDxkaXYgY2xhc3M9XCJ1eC10b2dnbGVzd2l0Y2gtY29udGFpbmVyXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJ1eC10b2dnbGVzd2l0Y2gtYmdcIj48L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInV4LXRvZ2dsZXN3aXRjaC1udWJcIj48L2Rpdj5cbiAgICA8L2Rpdj5cblxuICAgIDxzcGFuIGNsYXNzPVwidXgtdG9nZ2xlc3dpdGNoLWxhYmVsXCI+XG4gICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICA8L3NwYW4+XG48L2xhYmVsPmAsXG4gICAgcHJvdmlkZXJzOiBbVE9HR0xFU1dJVENIX1ZBTFVFX0FDQ0VTU09SXVxufSlcbmV4cG9ydCBjbGFzcyBUb2dnbGVTd2l0Y2hDb21wb25lbnQgaW1wbGVtZW50cyBDb250cm9sVmFsdWVBY2Nlc3NvciB7XG5cbiAgICBwcml2YXRlIF90b2dnbGVTd2l0Y2hJZDogc3RyaW5nID0gYHV4LXRvZ2dsZXN3aXRjaC0keysrdW5pcXVlVG9nZ2xlU3dpdGNoSWR9YDtcblxuICAgIEBJbnB1dCgpIGlkOiBzdHJpbmcgPSB0aGlzLl90b2dnbGVTd2l0Y2hJZDtcbiAgICBASW5wdXQoKSBuYW1lOiBzdHJpbmcgfCBudWxsO1xuICAgIEBJbnB1dCgpIHRhYmluZGV4OiBudW1iZXIgPSAwO1xuICAgIEBJbnB1dCgpIGNsaWNrYWJsZTogYm9vbGVhbiA9IHRydWU7XG4gICAgQElucHV0KCkgZGlzYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBASW5wdXQoJ2FyaWEtbGFiZWwnKSBhcmlhTGFiZWw6IHN0cmluZyA9ICcnO1xuICAgIEBJbnB1dCgnYXJpYS1sYWJlbGxlZGJ5JykgYXJpYUxhYmVsbGVkYnk6IHN0cmluZyA9IG51bGw7XG5cbiAgICBAT3V0cHV0KCkgdmFsdWVDaGFuZ2U6IEV2ZW50RW1pdHRlcjxib29sZWFuPiA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oKTtcblxuICAgIEBJbnB1dCgpXG4gICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgfVxuXG4gICAgc2V0IHZhbHVlKHZhbHVlOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG5cbiAgICAgICAgLy8gVXBkYXRlIHZhbHVlIG91dHB1dFxuICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlLmVtaXQodmFsdWUpO1xuXG4gICAgICAgIC8vIE5vdGlmeSBuZ01vZGVsXG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjayh2YWx1ZSk7XG4gICAgICAgIHRoaXMub25Ub3VjaGVkQ2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICBnZXQgaW5wdXRJZCgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5pZCB8fCB0aGlzLl90b2dnbGVTd2l0Y2hJZH0taW5wdXRgO1xuICAgIH1cblxuICAgIHByaXZhdGUgX3ZhbHVlOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBmb2N1c2VkOiBib29sZWFuID0gZmFsc2U7XG4gICAgb25Ub3VjaGVkQ2FsbGJhY2s6ICgpID0+IHZvaWQgPSAoKSA9PiB7IH07XG4gICAgb25DaGFuZ2VDYWxsYmFjazogKF86IGFueSkgPT4gdm9pZCA9ICgpID0+IHsgfTtcblxuICAgIHRvZ2dsZSgpOiB2b2lkIHtcbiAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVkICYmIHRoaXMuY2xpY2thYmxlKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gIXRoaXMudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB3cml0ZVZhbHVlKHZhbHVlOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIHRoaXMudmFsdWUgPSAhIXZhbHVlO1xuICAgIH1cblxuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm46IGFueSk6IHZvaWQge1xuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2sgPSBmbjtcbiAgICB9XG5cbiAgICByZWdpc3Rlck9uVG91Y2hlZChmbjogYW55KTogdm9pZCB7XG4gICAgICAgIHRoaXMub25Ub3VjaGVkQ2FsbGJhY2sgPSBmbjtcbiAgICB9XG5cbiAgICBzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQ6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGlzRGlzYWJsZWQ7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZvcm1zTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5pbXBvcnQgeyBUb2dnbGVTd2l0Y2hDb21wb25lbnQgfSBmcm9tICcuL3RvZ2dsZXN3aXRjaC5jb21wb25lbnQnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFsgRm9ybXNNb2R1bGUgXSxcbiAgICBleHBvcnRzOiBbIFRvZ2dsZVN3aXRjaENvbXBvbmVudCBdLFxuICAgIGRlY2xhcmF0aW9uczogWyBUb2dnbGVTd2l0Y2hDb21wb25lbnQgXVxufSlcbmV4cG9ydCBjbGFzcyBUb2dnbGVTd2l0Y2hNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEhvc3RMaXN0ZW5lciwgT3V0cHV0LCBFdmVudEVtaXR0ZXIsIEVsZW1lbnRSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbdXhUb29sYmFyU2VhcmNoQnV0dG9uXSdcbn0pXG5leHBvcnQgY2xhc3MgVG9vbGJhclNlYXJjaEJ1dHRvbkRpcmVjdGl2ZSB7XG5cbiAgICBAT3V0cHV0KClcbiAgICBjbGlja2VkID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuXG4gICAgZ2V0IHdpZHRoKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZikgeyB9XG5cbiAgICBASG9zdExpc3RlbmVyKCdjbGljaycpXG4gICAgY2xpY2tIYW5kbGVyKCkge1xuICAgICAgICB0aGlzLmNsaWNrZWQuZW1pdCgpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBIb3N0TGlzdGVuZXIsIE9wdGlvbmFsLCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE5nTW9kZWwgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmNvbnN0IEtFWVMgPSB7XG4gICAgRU5URVI6IDEzLFxuICAgIEVTQ0FQRTogMjdcbn07XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3V4VG9vbGJhclNlYXJjaEZpZWxkXSdcbn0pXG5leHBvcnQgY2xhc3MgVG9vbGJhclNlYXJjaEZpZWxkRGlyZWN0aXZlIHtcblxuICAgIEBPdXRwdXQoKVxuICAgIGNhbmNlbCA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcblxuICAgIEBPdXRwdXQoKVxuICAgIHN1Ym1pdCA9IG5ldyBFdmVudEVtaXR0ZXI8c3RyaW5nPigpO1xuXG4gICAgZ2V0IHRleHQoKTogc3RyaW5nIHtcbiAgICAgICAgLy8gVXNlIG5nTW9kZWwgaWYgc3BlY2lmaWVkIG9uIHRoZSBob3N0OyBvdGhlcndpc2UgcmVhZCB0aGUgRE9NXG4gICAgICAgIGlmICh0aGlzLl9uZ01vZGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbmdNb2RlbC52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQudmFsdWU7XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYsXG4gICAgICAgIEBPcHRpb25hbCgpIHByaXZhdGUgX25nTW9kZWw6IE5nTW9kZWwpIHsgfVxuXG4gICAgZm9jdXMoKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGJsdXIoKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmJsdXIoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIC8vIFVzZSBuZ01vZGVsIGlmIHNwZWNpZmllZCBvbiB0aGUgaG9zdDsgb3RoZXJ3aXNlIHVzZSB0aGUgRE9NXG4gICAgICAgIGlmICh0aGlzLl9uZ01vZGVsKSB7XG4gICAgICAgICAgICB0aGlzLl9uZ01vZGVsLnJlc2V0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQudmFsdWUgPSAnJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ2tleWRvd24nLCBbJyRldmVudCddKVxuICAgIGtleWRvd25IYW5kbGVyKGV2ZW50OiBLZXlib2FyZEV2ZW50KSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IEtFWVMuRU5URVIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1Ym1pdC5lbWl0KHRoaXMudGV4dCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT09IEtFWVMuRVNDQVBFKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmJsdXIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbmNlbC5lbWl0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IGFuaW1hdGUsIEFuaW1hdGlvbkV2ZW50LCBzdGF0ZSwgc3R5bGUsIHRyYW5zaXRpb24sIHRyaWdnZXIgfSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcbmltcG9ydCB7IERPQ1VNRU5UIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IEFmdGVyQ29udGVudEluaXQsIENvbXBvbmVudCwgQ29udGVudENoaWxkLCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIEhvc3RCaW5kaW5nLCBIb3N0TGlzdGVuZXIsIEluamVjdCwgSW5wdXQsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29sb3JTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvY29sb3IvY29sb3Iuc2VydmljZSc7XG5pbXBvcnQgeyBUb29sYmFyU2VhcmNoQnV0dG9uRGlyZWN0aXZlIH0gZnJvbSAnLi90b29sYmFyLXNlYXJjaC1idXR0b24uZGlyZWN0aXZlJztcbmltcG9ydCB7IFRvb2xiYXJTZWFyY2hGaWVsZERpcmVjdGl2ZSB9IGZyb20gJy4vdG9vbGJhci1zZWFyY2gtZmllbGQuZGlyZWN0aXZlJztcblxuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LXRvb2xiYXItc2VhcmNoJyxcbiAgICB0ZW1wbGF0ZTogYDxuZy1jb250ZW50PjwvbmctY29udGVudD5gLFxuICAgIGFuaW1hdGlvbnM6IFtcbiAgICAgICAgdHJpZ2dlcignZXhwYW5kZWQnLCBbXG4gICAgICAgICAgICBzdGF0ZShcbiAgICAgICAgICAgICAgICAnY29sbGFwc2VkJyxcbiAgICAgICAgICAgICAgICBzdHlsZSh7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiAne3tpbml0aWFsV2lkdGh9fSdcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtczogeyBpbml0aWFsV2lkdGg6ICczMHB4JyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHN0YXRlKFxuICAgICAgICAgICAgICAgICdleHBhbmRlZCcsXG4gICAgICAgICAgICAgICAgc3R5bGUoe1xuICAgICAgICAgICAgICAgICAgICB3aWR0aDogJzEwMCUnXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICB0cmFuc2l0aW9uKCdjb2xsYXBzZWQgPD0+IGV4cGFuZGVkJywgW2FuaW1hdGUoJzAuM3MgZWFzZS1vdXQnKV0pXG4gICAgICAgIF0pXG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBUb29sYmFyU2VhcmNoQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdCB7XG5cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmV4cGFuZGVkJylcbiAgICBASW5wdXQoKVxuICAgIGdldCBleHBhbmRlZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4cGFuZGVkO1xuICAgIH1cblxuICAgIHNldCBleHBhbmRlZCh2YWx1ZTogYm9vbGVhbikge1xuICAgICAgICB0aGlzLl9leHBhbmRlZCA9IHZhbHVlO1xuXG4gICAgICAgIHRoaXMuZXhwYW5kZWRDaGFuZ2UuZW1pdCh2YWx1ZSk7XG5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBTZXQgZm9jdXMgb24gdGhlIGlucHV0IHdoZW4gZXhwYW5kZWRcbiAgICAgICAgICAgIHRoaXMuZmllbGQuZm9jdXMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIENsZWFyIHRleHQgd2hlbiBjb250cmFjdGVkXG4gICAgICAgICAgICB0aGlzLmZpZWxkLmNsZWFyKCk7XG5cbiAgICAgICAgICAgIC8vIFJlbW92ZSBmb2N1cyAod29ya3MgYXJvdW5kIGFuIElFIGlzc3VlIHdoZXJlIHRoZSBjYXJldCByZW1haW5zIHZpc2libGUpXG4gICAgICAgICAgICB0aGlzLmZpZWxkLmJsdXIoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIEBJbnB1dCgpXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcycpXG4gICAgZGlyZWN0aW9uOiAnbGVmdCcgfCAncmlnaHQnID0gJ3JpZ2h0JztcblxuICAgIEBJbnB1dCgpXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5pbnZlcnNlJylcbiAgICBpbnZlcnNlID0gZmFsc2U7XG5cbiAgICBASW5wdXQoKVxuICAgIHNldCBiYWNrZ3JvdW5kKHZhbHVlOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLl9jb2xvclNlcnZpY2UucmVzb2x2ZSh2YWx1ZSkgfHwgJ3RyYW5zcGFyZW50JztcbiAgICB9XG5cbiAgICBAT3V0cHV0KClcbiAgICBleHBhbmRlZENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oKTtcblxuICAgIEBPdXRwdXQoKVxuICAgIHNlYXJjaCA9IG5ldyBFdmVudEVtaXR0ZXI8c3RyaW5nPigpO1xuXG4gICAgcHJpdmF0ZSBfZXhwYW5kZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIEBIb3N0QmluZGluZygnQGV4cGFuZGVkJylcbiAgICBnZXQgZXhwYW5kZWRBbmltYXRpb24oKTogYW55IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLmV4cGFuZGVkID8gJ2V4cGFuZGVkJyA6ICdjb2xsYXBzZWQnLFxuICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgaW5pdGlhbFdpZHRoOiB0aGlzLmJ1dHRvbi53aWR0aCArICdweCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBASG9zdEJpbmRpbmcoJ3N0eWxlLnBvc2l0aW9uJykgcG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgIEBIb3N0QmluZGluZygnc3R5bGUuYmFja2dyb3VuZC1jb2xvcicpIGJhY2tncm91bmRDb2xvciA9ICd0cmFuc3BhcmVudCc7XG4gICAgQENvbnRlbnRDaGlsZChUb29sYmFyU2VhcmNoRmllbGREaXJlY3RpdmUpIGZpZWxkOiBUb29sYmFyU2VhcmNoRmllbGREaXJlY3RpdmU7XG4gICAgQENvbnRlbnRDaGlsZChUb29sYmFyU2VhcmNoQnV0dG9uRGlyZWN0aXZlKSBidXR0b246IFRvb2xiYXJTZWFyY2hCdXR0b25EaXJlY3RpdmU7XG5cbiAgICBwcml2YXRlIF9wbGFjZWhvbGRlcjogSFRNTEVsZW1lbnQ7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZixcbiAgICAgICAgcHJpdmF0ZSBfY29sb3JTZXJ2aWNlOiBDb2xvclNlcnZpY2UsXG4gICAgICAgIEBJbmplY3QoRE9DVU1FTlQpIHByaXZhdGUgX2RvY3VtZW50OiBhbnkpIHtcbiAgICB9XG5cbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgICAgIC8vIFN1YnNjcmliZSB0byB0aGUgc3VibWl0IGV2ZW50IG9uIHRoZSBpbnB1dCBmaWVsZCwgdHJpZ2dlcmluZyB0aGUgc2VhcmNoIGV2ZW50XG4gICAgICAgIHRoaXMuZmllbGQuc3VibWl0LnN1YnNjcmliZSgodGV4dDogc3RyaW5nKSA9PiB0aGlzLnNlYXJjaC5lbWl0KHRleHQpKTtcblxuICAgICAgICAvLyBTdWJzY3JpYmUgdG8gY2FuY2VsIGV2ZW50cyBjb21pbmcgZnJvbSB0aGUgaW5wdXQgZmllbGRcbiAgICAgICAgdGhpcy5maWVsZC5jYW5jZWwuc3Vic2NyaWJlKCgpID0+IHRoaXMuZXhwYW5kZWQgPSBmYWxzZSk7XG5cbiAgICAgICAgLy8gU3Vic2NyaWJlIHRvIHRoZSBidXR0b24gY2xpY2sgZXZlbnRcbiAgICAgICAgdGhpcy5idXR0b24uY2xpY2tlZC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuZXhwYW5kZWQgJiYgdGhpcy5maWVsZC50ZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWFyY2guZW1pdCh0aGlzLmZpZWxkLnRleHQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV4cGFuZGVkID0gIXRoaXMuZXhwYW5kZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIENyZWF0ZSBwbGFjZWhvbGRlciBlbGVtZW50IHRvIGF2b2lkIGNoYW5naW5nIGxheW91dCB3aGVuIHN3aXRjaGluZyB0byBwb3NpdGlvbjogYWJzb2x1dGVcbiAgICAgICAgdGhpcy5jcmVhdGVQbGFjZWhvbGRlcigpO1xuICAgIH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ0BleHBhbmRlZC5zdGFydCcsIFsnJGV2ZW50J10pXG4gICAgYW5pbWF0aW9uU3RhcnQoZXZlbnQ6IEFuaW1hdGlvbkV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC50b1N0YXRlID09PSAnZXhwYW5kZWQnKSB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlUGxhY2Vob2xkZXIodHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBASG9zdExpc3RlbmVyKCdAZXhwYW5kZWQuZG9uZScsIFsnJGV2ZW50J10pXG4gICAgYW5pbWF0aW9uRG9uZShldmVudDogQW5pbWF0aW9uRXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LnRvU3RhdGUgPT09ICdjb2xsYXBzZWQnKSB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlUGxhY2Vob2xkZXIoZmFsc2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmVhdGVQbGFjZWhvbGRlcigpIHtcbiAgICAgICAgLy8gR2V0IHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIGNvbXBvbmVudFxuICAgICAgICBjb25zdCBzdHlsZXMgPSBnZXRDb21wdXRlZFN0eWxlKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGludmlzaWJsZSBkaXYgd2l0aCB0aGUgc2FtZSBkaW1lbnNpb25zXG4gICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyID0gdGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyLnN0eWxlLndpZHRoID0gdGhpcy5idXR0b24ud2lkdGggKyAncHgnO1xuICAgICAgICB0aGlzLl9wbGFjZWhvbGRlci5zdHlsZS5oZWlnaHQgPSBzdHlsZXMuaGVpZ2h0O1xuICAgICAgICB0aGlzLl9wbGFjZWhvbGRlci5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG5cbiAgICAgICAgLy8gQWRkIGFzIGEgc2libGluZ1xuICAgICAgICB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5fcGxhY2Vob2xkZXIsIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBlbmFibGVQbGFjZWhvbGRlcihlbmFibGVkOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyLnN0eWxlLmRpc3BsYXkgPSAoZW5hYmxlZCA/ICdpbmxpbmUtYmxvY2snIDogJ25vbmUnKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcblxuaW1wb3J0IHsgVG9vbGJhclNlYXJjaENvbXBvbmVudCB9IGZyb20gJy4vdG9vbGJhci1zZWFyY2guY29tcG9uZW50JztcbmltcG9ydCB7IFRvb2xiYXJTZWFyY2hGaWVsZERpcmVjdGl2ZSB9IGZyb20gJy4vdG9vbGJhci1zZWFyY2gtZmllbGQuZGlyZWN0aXZlJztcbmltcG9ydCB7IFRvb2xiYXJTZWFyY2hCdXR0b25EaXJlY3RpdmUgfSBmcm9tICcuL3Rvb2xiYXItc2VhcmNoLWJ1dHRvbi5kaXJlY3RpdmUnO1xuXG5jb25zdCBERUNMQVJBVElPTlMgPSBbXG4gICAgVG9vbGJhclNlYXJjaENvbXBvbmVudCxcbiAgICBUb29sYmFyU2VhcmNoRmllbGREaXJlY3RpdmUsXG4gICAgVG9vbGJhclNlYXJjaEJ1dHRvbkRpcmVjdGl2ZVxuXTtcblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZVxuICAgIF0sXG4gICAgZXhwb3J0czogREVDTEFSQVRJT05TLFxuICAgIGRlY2xhcmF0aW9uczogREVDTEFSQVRJT05TLFxuICAgIHByb3ZpZGVyczogW10sXG59KVxuZXhwb3J0IGNsYXNzIFRvb2xiYXJTZWFyY2hNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBEaXJlY3RpdmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQERpcmVjdGl2ZSh7IFxuICAgIHNlbGVjdG9yOiAnW3V4VmlydHVhbFNjcm9sbExvYWRpbmddJyBcbn0pXG5leHBvcnQgY2xhc3MgVmlydHVhbFNjcm9sbExvYWRpbmdEaXJlY3RpdmUgeyB9IiwiaW1wb3J0IHsgRGlyZWN0aXZlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3V4VmlydHVhbFNjcm9sbExvYWRCdXR0b25dJyBcbn0pXG5leHBvcnQgY2xhc3MgVmlydHVhbFNjcm9sbExvYWRCdXR0b25EaXJlY3RpdmUgeyB9IiwiaW1wb3J0IHsgRGlyZWN0aXZlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBEaXJlY3RpdmUoeyBcbiAgICBzZWxlY3RvcjogJ1t1eFZpcnR1YWxTY3JvbGxDZWxsXScgXG59KVxuZXhwb3J0IGNsYXNzIFZpcnR1YWxTY3JvbGxDZWxsRGlyZWN0aXZlIHtcblxufSIsImltcG9ydCB7IENvbXBvbmVudCwgT25Jbml0LCBFdmVudEVtaXR0ZXIsIE91dHB1dCwgSW5wdXQsIEhvc3RMaXN0ZW5lciwgRWxlbWVudFJlZiwgQWZ0ZXJDb250ZW50SW5pdCwgQ29udGVudENoaWxkLCBUZW1wbGF0ZVJlZiwgT25EZXN0cm95LCBTaW1wbGVDaGFuZ2VzIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBSZXNpemVTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9yZXNpemUvaW5kZXgnO1xuaW1wb3J0IHsgVmlydHVhbFNjcm9sbExvYWRpbmdEaXJlY3RpdmUgfSBmcm9tICcuL2RpcmVjdGl2ZXMvdmlydHVhbC1zY3JvbGwtbG9hZGluZy5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgVmlydHVhbFNjcm9sbExvYWRCdXR0b25EaXJlY3RpdmUgfSBmcm9tICcuL2RpcmVjdGl2ZXMvdmlydHVhbC1zY3JvbGwtbG9hZC1idXR0b24uZGlyZWN0aXZlJztcbmltcG9ydCB7IFZpcnR1YWxTY3JvbGxDZWxsRGlyZWN0aXZlIH0gZnJvbSAnLi9kaXJlY3RpdmVzL3ZpcnR1YWwtc2Nyb2xsLWNlbGwuZGlyZWN0aXZlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzL09ic2VydmFibGUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcy9TdWJzY3JpcHRpb24nO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LXZpcnR1YWwtc2Nyb2xsJyxcbiAgICB0ZW1wbGF0ZTogYDxkaXYgY2xhc3M9XCJ2aXJ0dWFsLXNjcm9sbC1jb250ZW50LWhlaWdodFwiIFtzdHlsZS5oZWlnaHQucHhdPVwiZ2V0VG90YWxIZWlnaHQoKVwiPjwvZGl2PlxuPGRpdiBjbGFzcz1cInZpcnR1YWwtc2Nyb2xsLWNvbnRlbnRcIiBbc3R5bGUudHJhbnNmb3JtXT1cIid0cmFuc2xhdGVZKCcgKyBzY3JvbGxUb3AgKyAncHgpJ1wiPlxuXG4gICAgPCEtLSBWaXJ0dWFsbHkgUmVuZGVyIENlbGxzIC0tPlxuICAgIDxuZy1jb250YWluZXIgKm5nRm9yPVwibGV0IGNlbGwgb2YgY2VsbHMgfCBhc3luY1wiPlxuICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiY2VsbFRlbXBsYXRlOyBjb250ZXh0OiB7IGNlbGw6IGNlbGwgfVwiPjwvbmctY29udGFpbmVyPlxuICAgIDwvbmctY29udGFpbmVyPlxuXG4gICAgPCEtLSBMb2FkaW5nIEluZGljYXRvciAtLT5cbiAgICA8bmctY29udGFpbmVyICpuZ0lmPVwibG9hZGluZ0luZGljYXRvclRlbXBsYXRlICYmIGlzTG9hZGluZ1wiIFtuZ1RlbXBsYXRlT3V0bGV0XT1cImxvYWRpbmdJbmRpY2F0b3JUZW1wbGF0ZVwiPjwvbmctY29udGFpbmVyPlxuXG4gICAgPCEtLSBMb2FkaW5nIEJ1dHRvbiAtLT5cbiAgICA8ZGl2IGNsYXNzPVwidmlydHVhbC1zY3JvbGwtbG9hZC1idXR0b25cIiAqbmdJZj1cImxvYWRCdXR0b25UZW1wbGF0ZSAmJiAhbG9hZE9uU2Nyb2xsICYmICFsb2FkaW5nQ29tcGxldGUgJiYgIWlzTG9hZGluZ1wiIChjbGljayk9XCJsb2FkTmV4dFBhZ2UoKVwiPlxuICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwibG9hZEJ1dHRvblRlbXBsYXRlXCI+PC9uZy1jb250YWluZXI+XG4gICAgPC9kaXY+XG4gICAgXG48L2Rpdj5gXG59KVxuZXhwb3J0IGNsYXNzIFZpcnR1YWxTY3JvbGxDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIEFmdGVyQ29udGVudEluaXQsIE9uRGVzdHJveSB7XG5cbiAgICBASW5wdXQoKSBjb2xsZWN0aW9uOiBPYnNlcnZhYmxlPGFueVtdPiA9IE9ic2VydmFibGUuY3JlYXRlKCk7XG4gICAgQElucHV0KCkgY2VsbEhlaWdodDogbnVtYmVyO1xuICAgIEBJbnB1dCgpIGxvYWRPblNjcm9sbDogYm9vbGVhbiA9IHRydWU7XG5cbiAgICBAT3V0cHV0KCkgbG9hZGluZzogRXZlbnRFbWl0dGVyPG51bWJlcj4gPSBuZXcgRXZlbnRFbWl0dGVyPG51bWJlcj4oKTtcblxuICAgIEBDb250ZW50Q2hpbGQoVmlydHVhbFNjcm9sbENlbGxEaXJlY3RpdmUsIHsgcmVhZDogVGVtcGxhdGVSZWYgfSkgY2VsbFRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICAgIEBDb250ZW50Q2hpbGQoVmlydHVhbFNjcm9sbExvYWRpbmdEaXJlY3RpdmUsIHsgcmVhZDogVGVtcGxhdGVSZWYgfSkgbG9hZGluZ0luZGljYXRvclRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICAgIEBDb250ZW50Q2hpbGQoVmlydHVhbFNjcm9sbExvYWRCdXR0b25EaXJlY3RpdmUsIHsgcmVhZDogVGVtcGxhdGVSZWYgfSkgbG9hZEJ1dHRvblRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgY2VsbHM6IEJlaGF2aW9yU3ViamVjdDxhbnlbXT4gPSBuZXcgQmVoYXZpb3JTdWJqZWN0KFtdKTtcbiAgICBzY3JvbGxUb3A6IG51bWJlciA9IDA7XG4gICAgaXNMb2FkaW5nOiBib29sZWFuID0gZmFsc2U7XG4gICAgcGFnZU51bWJlcjogbnVtYmVyID0gMDtcbiAgICBkYXRhOiBhbnlbXSA9IFtdO1xuICAgIGxvYWRpbmdDb21wbGV0ZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG4gICAgcHJpdmF0ZSBfaGVpZ2h0OiBudW1iZXI7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmLCByZXNpemVTZXJ2aWNlOiBSZXNpemVTZXJ2aWNlKSB7XG5cbiAgICAgICAgLy8gd2F0Y2ggZm9yIGFueSBmdXR1cmUgY2hhbmdlcyB0byBzaXplXG4gICAgICAgIHJlc2l6ZVNlcnZpY2UuYWRkUmVzaXplTGlzdGVuZXIoX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCkuc3Vic2NyaWJlKGV2ZW50ID0+IHRoaXMuX2hlaWdodCA9IGV2ZW50LmhlaWdodCk7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLmNlbGxIZWlnaHQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVmlydHVhbCBTY3JvbGwgQ29tcG9uZW50IHJlcXVpcmVzIFwiY2VsbEhlaWdodFwiIHByb3BlcnR5IHRvIGJlIGRlZmluZWQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzdWJzY3JpYmUgdG8gdGhlIGNvbGxlY3Rpb25cbiAgICAgICAgdGhpcy5zZXR1cE9ic2VydmFibGUoKTtcblxuICAgICAgICAvLyBsb2FkIHRoZSBmaXJzdCBwYWdlIG9mIGRhdGFcbiAgICAgICAgdGhpcy5sb2FkTmV4dFBhZ2UoKTtcbiAgICB9XG5cbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZCB7XG4gICAgICAgIC8vIHJlLXJlbmRlciBjZWxscyBub3cgdGhhdCB3ZSBjYW4gZGlzcGxheSBhbnkgbG9hZGluZyBpbmRpY2F0b3Igb3IgbG9hZGluZyBidXR0b25cbiAgICAgICAgdGhpcy5yZW5kZXJDZWxscygpO1xuICAgIH1cblxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcbiAgICAgICAgaWYgKGNoYW5nZXMuY29sbGVjdGlvbiAmJiBjaGFuZ2VzLmNvbGxlY3Rpb24uY3VycmVudFZhbHVlICE9PSBjaGFuZ2VzLmNvbGxlY3Rpb24ucHJldmlvdXNWYWx1ZSAmJiAhY2hhbmdlcy5jb2xsZWN0aW9uLmlzRmlyc3RDaGFuZ2UoKSkge1xuICAgICAgICAgICAgdGhpcy5zZXR1cE9ic2VydmFibGUoKTtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG5cbiAgICBzZXR1cE9ic2VydmFibGUoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgYSBjdXJyZW50IHN1YnNjcmlwdGlvbiwgdW5zdWJzY3JpYmVcbiAgICAgICAgaWYgKHRoaXMuX3N1YnNjcmlwdGlvbiAmJiB0aGlzLl9zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUpIHtcbiAgICAgICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gdGhpcy5jb2xsZWN0aW9uLnN1YnNjcmliZShjb2xsZWN0aW9uID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGF0YS5wdXNoKC4uLmNvbGxlY3Rpb24pO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJDZWxscygpO1xuICAgICAgICAgICAgdGhpcy5pc0xvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgfSwgbnVsbCwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5sb2FkaW5nQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBASG9zdExpc3RlbmVyKCdzY3JvbGwnKSByZW5kZXJDZWxscygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5jZWxscy5uZXh0KHRoaXMuZ2V0VmlzaWJsZUNlbGxzKCkpO1xuXG4gICAgICAgIGlmICh0aGlzLmxvYWRPblNjcm9sbCAmJiAhdGhpcy5pc0xvYWRpbmcgJiYgIXRoaXMubG9hZGluZ0NvbXBsZXRlKSB7XG4gICAgICAgICAgICBjb25zdCByZW1haW5pbmdTY3JvbGwgPSB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuc2Nyb2xsSGVpZ2h0IC0gKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5zY3JvbGxUb3AgKyB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuY2xpZW50SGVpZ2h0KTtcblxuICAgICAgICAgICAgLy8gaWYgdGhlIGN1cnJlbnQgY2VsbHMgdGFrZSB1cCBsZXNzIHRoYW4gdGhlIGhlaWdodCBvZiB0aGUgY29tcG9uZW50IHRoZW4gbG9hZCB0aGUgbmV4dCBwYWdlXG4gICAgICAgICAgICBpZiAocmVtYWluaW5nU2Nyb2xsIDw9IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5jbGllbnRIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWROZXh0UGFnZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0VmlzaWJsZUNlbGxzKCk6IGFueVtdIHtcblxuICAgICAgICAvLyBzdG9yZSB0aGUgaW5pdGlhbCBlbGVtZW50IGhlaWdodFxuICAgICAgICBpZiAoIXRoaXMuX2hlaWdodCkge1xuICAgICAgICAgICAgdGhpcy5faGVpZ2h0ID0gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHBlcmZvcm0gc29tZSBjYWxjdWxhdGlvbnNcbiAgICAgICAgY29uc3Qgc2Nyb2xsVG9wID0gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnNjcm9sbFRvcDtcbiAgICAgICAgY29uc3Qgc3RhcnRDZWxsID0gTWF0aC5mbG9vcihzY3JvbGxUb3AgLyB0aGlzLmNlbGxIZWlnaHQpO1xuICAgICAgICBjb25zdCBlbmRDZWxsID0gTWF0aC5jZWlsKHRoaXMuX2hlaWdodCAvIHRoaXMuY2VsbEhlaWdodCkgKyAxO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgc2Nyb2xsIHBvc2l0aW9uXG4gICAgICAgIHRoaXMuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wIC0gKHNjcm9sbFRvcCAlIHRoaXMuY2VsbEhlaWdodCk7XG5cbiAgICAgICAgLy8gcmV0dXJuIGEgc3VibGlzdCBvZiBpdGVtcyB2aXNpYmxlIG9uIHRoZSBzY3JlZW5cbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5zbGljZShzdGFydENlbGwsIHN0YXJ0Q2VsbCArIGVuZENlbGwpO1xuICAgIH1cblxuICAgIGdldFRvdGFsSGVpZ2h0KCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmNlbGxIZWlnaHQgKiB0aGlzLmRhdGEubGVuZ3RoO1xuICAgIH1cblxuICAgIGxvYWROZXh0UGFnZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5pc0xvYWRpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLmxvYWRpbmcubmV4dCh0aGlzLnBhZ2VOdW1iZXIpO1xuICAgICAgICB0aGlzLnBhZ2VOdW1iZXIrKztcbiAgICB9XG5cbiAgICByZXNldCgpOiB2b2lkIHtcblxuICAgICAgICAvLyByZXNldCBhbGwgdmFsdWVzXG4gICAgICAgIHRoaXMuc2Nyb2xsVG9wID0gMDtcbiAgICAgICAgdGhpcy5kYXRhID0gW107XG4gICAgICAgIHRoaXMuX2hlaWdodCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5wYWdlTnVtYmVyID0gMDtcbiAgICAgICAgdGhpcy5sb2FkaW5nQ29tcGxldGUgPSBmYWxzZTtcblxuICAgICAgICAvLyBzZXQgc2Nyb2xsIHBvc2l0aW9uXG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5zY3JvbGxUb3AgPSAwO1xuXG4gICAgICAgIC8vIGNsZWFyIHRoZSBjdXJyZW50IGNlbGxzXG4gICAgICAgIHRoaXMucmVuZGVyQ2VsbHMoKTtcblxuICAgICAgICAvLyByZWxvYWQgZmlyc3QgcGFnZVxuICAgICAgICB0aGlzLmxvYWROZXh0UGFnZSgpO1xuICAgIH1cblxufSIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuXG5pbXBvcnQgeyBWaXJ0dWFsU2Nyb2xsQ29tcG9uZW50IH0gZnJvbSAnLi92aXJ0dWFsLXNjcm9sbC5jb21wb25lbnQnO1xuaW1wb3J0IHsgUmVzaXplTW9kdWxlIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9yZXNpemUvaW5kZXgnO1xuaW1wb3J0IHsgVmlydHVhbFNjcm9sbExvYWRpbmdEaXJlY3RpdmUgfSBmcm9tICcuL2RpcmVjdGl2ZXMvdmlydHVhbC1zY3JvbGwtbG9hZGluZy5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgVmlydHVhbFNjcm9sbExvYWRCdXR0b25EaXJlY3RpdmUgfSBmcm9tICcuL2RpcmVjdGl2ZXMvdmlydHVhbC1zY3JvbGwtbG9hZC1idXR0b24uZGlyZWN0aXZlJztcbmltcG9ydCB7IFZpcnR1YWxTY3JvbGxDZWxsRGlyZWN0aXZlIH0gZnJvbSAnLi9kaXJlY3RpdmVzL3ZpcnR1YWwtc2Nyb2xsLWNlbGwuZGlyZWN0aXZlJztcblxuY29uc3QgREVDTEFSQVRJT05TID0gW1xuICAgIFZpcnR1YWxTY3JvbGxDb21wb25lbnQsXG4gICAgVmlydHVhbFNjcm9sbExvYWRpbmdEaXJlY3RpdmUsXG4gICAgVmlydHVhbFNjcm9sbExvYWRCdXR0b25EaXJlY3RpdmUsXG4gICAgVmlydHVhbFNjcm9sbENlbGxEaXJlY3RpdmVcbl07XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIFJlc2l6ZU1vZHVsZVxuICAgIF0sXG4gICAgZXhwb3J0czogREVDTEFSQVRJT05TLFxuICAgIGRlY2xhcmF0aW9uczogREVDTEFSQVRJT05TXG59KVxuZXhwb3J0IGNsYXNzIFZpcnR1YWxTY3JvbGxNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBBZnRlclZpZXdJbml0LCBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEhvc3RMaXN0ZW5lciwgUmVuZGVyZXIyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1t1eEF1dG9Hcm93XSdcbn0pXG5leHBvcnQgY2xhc3MgQXV0b0dyb3dEaXJlY3RpdmUgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0IHtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmLCBwcml2YXRlIF9yZW5kZXJlcjogUmVuZGVyZXIyKSB7XG4gICAgLy8gZW5zdXJlIHRoaXMgaXMgYSB0ZXh0YXJlYSBvciBlbHNlIHRocm93IGVycm9yXG4gICAgaWYgKF9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpICE9PSAndGV4dGFyZWEnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3V4QXV0b0dyb3cgZGlyZWN0aXZlIGNhbiBvbmx5IGJlIHVzZWQgb24gPHRleHRhcmVhPiBlbGVtZW50cy4nKTtcbiAgICB9XG4gIH1cblxuICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuXG4gIEBIb3N0TGlzdGVuZXIoJ2lucHV0JylcbiAgdXBkYXRlKCk6IHZvaWQge1xuXG4gICAgLy8gcGVyZm9ybSBzaXppbmdcbiAgICB0aGlzLl9yZW5kZXJlci5zZXRTdHlsZSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdvdmVyZmxvd1knLCAnaGlkZGVuJyk7XG4gICAgdGhpcy5fcmVuZGVyZXIuc2V0U3R5bGUodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnaGVpZ2h0JywgJ2F1dG8nKTtcblxuICAgIC8vIGdldCB0aGUgbmV3IHRvdGFsIGhlaWdodCBhbmQgZWxlbWVudCBoZWlnaHRcbiAgICBjb25zdCB7IHNjcm9sbEhlaWdodCB9ID0gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgIGNvbnN0IHsgbWF4SGVpZ2h0IH0gPSBnZXRDb21wdXRlZFN0eWxlKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCk7XG5cbiAgICAvLyBkZXRlcm1pbmUgd2hhdCB0aGUgbWF4aW11bSBhbGxvd2VkIGhlaWdodCBpc1xuICAgIGNvbnN0IG1heGltdW0gPSAhaXNOYU4ocGFyc2VGbG9hdChtYXhIZWlnaHQpKSA/IHBhcnNlRmxvYXQobWF4SGVpZ2h0KSA6IEluZmluaXR5O1xuXG4gICAgLy8gaWYgdGhlcmUgaXMgYSBtYXggaGVpZ2h0IHNwZWNpZmVkIHdlIHdhbnQgdG8gc2hvdyB0aGUgc2Nyb2xsYmFyc1xuICAgIGlmIChtYXhpbXVtIDwgc2Nyb2xsSGVpZ2h0KSB7XG4gICAgICB0aGlzLl9yZW5kZXJlci5zZXRTdHlsZSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdvdmVyZmxvd1knLCAnYXV0bycpO1xuICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0U3R5bGUodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnaGVpZ2h0JywgbWF4aW11bSArICdweCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZW5kZXJlci5zZXRTdHlsZSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdoZWlnaHQnLCBzY3JvbGxIZWlnaHQgKyAncHgnKTtcbiAgICB9XG4gIH1cblxufSIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IEF1dG9Hcm93RGlyZWN0aXZlIH0gZnJvbSAnLi9hdXRvLWdyb3cuZGlyZWN0aXZlJztcblxuQE5nTW9kdWxlKHtcbiAgICBleHBvcnRzOiBbQXV0b0dyb3dEaXJlY3RpdmVdLFxuICAgIGRlY2xhcmF0aW9uczogW0F1dG9Hcm93RGlyZWN0aXZlXVxufSlcbmV4cG9ydCBjbGFzcyBBdXRvR3Jvd01vZHVsZSB7IH1cbiIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT25Jbml0LCBPdXRwdXQsIFJlbmRlcmVyMiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbdXhGaXhlZEhlYWRlclRhYmxlXSdcbn0pXG5leHBvcnQgY2xhc3MgRml4ZWRIZWFkZXJUYWJsZURpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCB7XG5cbiAgQElucHV0KCkgdGFibGVIZWlnaHQ6IG51bWJlciB8IHN0cmluZztcbiAgQE91dHB1dCgpIHRhYmxlUGFnaW5nOiBFdmVudEVtaXR0ZXI8bnVtYmVyPiA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyPigpO1xuXG4gIHByaXZhdGUgX3RhYmxlSGVhZDogSFRNTEVsZW1lbnQ7XG4gIHByaXZhdGUgX3RhYmxlQm9keTogSFRNTEVsZW1lbnQ7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZiwgcHJpdmF0ZSBfcmVuZGVyZXI6IFJlbmRlcmVyMikgeyB9XG5cbiAgbmdPbkluaXQoKTogdm9pZCB7XG5cbiAgICAvLyBhZGQgY2xhc3MgdG8gdGhlIHRhYmxlXG4gICAgdGhpcy5fcmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAndXgtZml4ZWQtaGVhZGVyLXRhYmxlJyk7XG5cbiAgICAvLyBsb2NhdGUgdGhlIGltcG9ydGFudCBlbGVtZW50c1xuICAgIHRoaXMuX3RhYmxlSGVhZCA9IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCd0aGVhZCcpO1xuICAgIHRoaXMuX3RhYmxlQm9keSA9IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCd0Ym9keScpO1xuXG4gICAgLy8gYmluZCB0byBzY3JvbGwgZXZlbnRzIG9uIHRoZSB0YWJsZSBib2R5XG4gICAgdGhpcy5fcmVuZGVyZXIubGlzdGVuKHRoaXMuX3RhYmxlQm9keSwgJ3Njcm9sbCcsIHRoaXMub25TY3JvbGwuYmluZCh0aGlzKSk7XG5cbiAgICAvLyByZXNpemUgdGhlIHRhYmxlIGhlYWRlciB0byBhY2NvdW50IGZvciBzY3JvbGxiYXJcbiAgICB0aGlzLnNldExheW91dCgpO1xuXG4gICAgLy8gdHJpZ2dlciB0aGUgbG9hZGluZyBvZiB0aGUgZmlyc3QgcGFnZVxuICAgIHRoaXMudGFibGVQYWdpbmcuZW1pdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdGFibGUgZWxlbWVudFxuICAgKiBQcmltYXJpbHkgdXNlZCBieSBjb2x1bW4gd2lkdGggZGlyZWN0aXZlXG4gICAqL1xuICBnZXRUYWJsZSgpOiBIVE1MVGFibGVFbGVtZW50IHtcbiAgICByZXR1cm4gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBzY3JvbGwgZXZlbnRzXG4gICAqL1xuICBwcml2YXRlIG9uU2Nyb2xsKCk6IHZvaWQge1xuXG4gICAgLy8gZGV0ZXJtaW5lIGlmIHdlIGFyZSBzY3JvbGxlZCB0byB0aGUgYm90dG9tIGFuZCBpZiBzbyBsb2FkIHRoZSBuZXh0IHBhZ2VcbiAgICBpZiAodGhpcy5fdGFibGVCb2R5LnNjcm9sbFRvcCA9PT0gKHRoaXMuX3RhYmxlQm9keS5zY3JvbGxIZWlnaHQgLSB0aGlzLl90YWJsZUJvZHkub2Zmc2V0SGVpZ2h0KSkge1xuICAgICAgdGhpcy50YWJsZVBhZ2luZy5lbWl0KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgc2l6ZSBvZiB0aGUgdGFibGUgaGVhZGVyIHRvIGFjY291bnQgZm9yIHRoZSBzY3JvbGxiYXIuXG4gICAqIFRoaXMgaXMgaW1wb3J0YW50IHRvIGtlZXAgdGhlIGNvbHVtbnMgYWxpZ25lZFxuICAgKi9cbiAgcHJpdmF0ZSBzZXRMYXlvdXQoKTogdm9pZCB7XG5cbiAgICAvLyBjYWxjdWxhdGUgdGhlIHNpemUgb2YgdGhlIHNjcm9sbGJhclxuICAgIGNvbnN0IHNjcm9sbGJhciA9IHRoaXMuX3RhYmxlQm9keS5vZmZzZXRXaWR0aCAtIHRoaXMuX3RhYmxlQm9keS5jbGllbnRXaWR0aDtcblxuICAgIC8vIGFkZCBwYWRkaW5nIHRvIHRoZSBoZWFkZXIgdG8gYWNjb3VudCBmb3IgdGhpc1xuICAgIHRoaXMuX3JlbmRlcmVyLnNldFN0eWxlKHRoaXMuX3RhYmxlSGVhZCwgJ3BhZGRpbmctcmlnaHQnLCBzY3JvbGxiYXIgKyAncHgnKTtcblxuICAgIC8vIHNldCB0aGUgZGVzaXJlZCBoZWlnaHQgb2YgdGhlIHRhYmxlIGJvZHlcbiAgICB0aGlzLl9yZW5kZXJlci5zZXRTdHlsZSh0aGlzLl90YWJsZUJvZHksICdoZWlnaHQnLCB0eXBlb2YgdGhpcy50YWJsZUhlaWdodCA9PT0gJ251bWJlcicgPyBgJHt0aGlzLnRhYmxlSGVpZ2h0fXB4YCA6IHRoaXMudGFibGVIZWlnaHQpO1xuICB9XG5cbn1cbiIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IEZpeGVkSGVhZGVyVGFibGVEaXJlY3RpdmUgfSBmcm9tICcuL2ZpeGVkLWhlYWRlci10YWJsZS5kaXJlY3RpdmUnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGV4cG9ydHM6IFtGaXhlZEhlYWRlclRhYmxlRGlyZWN0aXZlXSxcbiAgICBkZWNsYXJhdGlvbnM6IFtGaXhlZEhlYWRlclRhYmxlRGlyZWN0aXZlXVxufSlcbmV4cG9ydCBjbGFzcyBGaXhlZEhlYWRlclRhYmxlTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBIb3N0QmluZGluZywgSW5wdXQsIE9uQ2hhbmdlcywgT25EZXN0cm95LCBPbkluaXQsIFJlbmRlcmVyMiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1t1eEZsb2F0TGFiZWxdJyxcbiAgICBob3N0OiB7XG4gICAgICAgICdjbGFzcyc6ICd1eC1mbG9hdC1sYWJlbCdcbiAgICB9XG59KVxuZXhwb3J0IGNsYXNzIEZsb2F0TGFiZWxEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIE9uQ2hhbmdlcywgT25EZXN0cm95IHtcblxuICAgIEBJbnB1dCgndXhGbG9hdExhYmVsJylcbiAgICBpbnB1dDogSFRNTElucHV0RWxlbWVudDtcblxuICAgIEBJbnB1dCgpXG4gICAgdmFsdWU6IGFueTtcblxuICAgIEBJbnB1dCgpXG4gICAgbW9kZTogJ2ZvY3VzJyB8ICdpbnB1dCcgPSAnZm9jdXMnO1xuXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy51eC1mbG9hdC1sYWJlbC1yYWlzZWQnKVxuICAgIHJhaXNlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG5cbiAgICBwcml2YXRlIF9mb2N1c2VkID0gZmFsc2U7XG4gICAgcHJpdmF0ZSBfZXZlbnRIYW5kbGVzOiBhbnlbXSA9IFtdO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZiwgcHJpdmF0ZSBfcmVuZGVyZXI6IFJlbmRlcmVyMikgeyB9XG5cbiAgICBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fZXZlbnRIYW5kbGVzLnB1c2goXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5saXN0ZW4odGhpcy5pbnB1dCwgJ2ZvY3VzJywgdGhpcy5pbnB1dEZvY3VzLmJpbmQodGhpcykpLFxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIubGlzdGVuKHRoaXMuaW5wdXQsICdibHVyJywgdGhpcy5pbnB1dEJsdXIuYmluZCh0aGlzKSksXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5saXN0ZW4odGhpcy5pbnB1dCwgJ2lucHV0JywgdGhpcy5pbnB1dENoYW5nZS5iaW5kKHRoaXMpKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIENoZWNrIGluaXRpYWwgaW5wdXQgdmFsdWVcbiAgICAgICAgdGhpcy5yYWlzZWQgPSB0aGlzLmhhc1RleHQoKTtcblxuICAgICAgICAvLyBFbnN1cmUgdGhhdCB0aGUgYGZvcmAgYXR0cmlidXRlIGlzIHNldFxuICAgICAgICBpZiAoIXRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2ZvcicpICYmIHRoaXMuaW5wdXQuZ2V0QXR0cmlidXRlKCdpZCcpKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRBdHRyaWJ1dGUodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnZm9yJywgdGhpcy5pbnB1dC5nZXRBdHRyaWJ1dGUoJ2lkJykpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbmdPbkNoYW5nZXMoKTogdm9pZCB7XG4gICAgICAgIGlmICghKHRoaXMubW9kZSA9PT0gJ2ZvY3VzJyAmJiB0aGlzLl9mb2N1c2VkKSkge1xuICAgICAgICAgICAgdGhpcy5yYWlzZWQgPSB0aGlzLmhhc1RleHQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICAvLyBVbnN1YnNjcmliZSBldmVudCBoYW5kbGVzXG4gICAgICAgIHRoaXMuX2V2ZW50SGFuZGxlcy5mb3JFYWNoKChldmVudEhhbmRsZSkgPT4gZXZlbnRIYW5kbGUoKSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBoYXNUZXh0KCk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gISF0aGlzLmlucHV0LnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhIXRoaXMudmFsdWU7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpbnB1dEZvY3VzKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5tb2RlID09PSAnZm9jdXMnKSB7XG4gICAgICAgICAgICB0aGlzLl9mb2N1c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMucmFpc2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgaW5wdXRCbHVyKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5tb2RlID09PSAnZm9jdXMnKSB7XG4gICAgICAgICAgICB0aGlzLl9mb2N1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnJhaXNlZCA9IHRoaXMuaGFzVGV4dCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpbnB1dENoYW5nZSgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gJ2lucHV0Jykge1xuICAgICAgICAgICAgdGhpcy5yYWlzZWQgPSB0aGlzLmhhc1RleHQoKTtcbiAgICAgICAgfVxuICAgIH1cbn0iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBGbG9hdExhYmVsRGlyZWN0aXZlIH0gZnJvbSAnLi9mbG9hdC1sYWJlbC5kaXJlY3RpdmUnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtdLFxuICAgIGV4cG9ydHM6IFtGbG9hdExhYmVsRGlyZWN0aXZlXSxcbiAgICBkZWNsYXJhdGlvbnM6IFtGbG9hdExhYmVsRGlyZWN0aXZlXSxcbiAgICBwcm92aWRlcnM6IFtdLFxufSlcbmV4cG9ydCBjbGFzcyBGbG9hdExhYmVsTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcy9CZWhhdmlvclN1YmplY3QnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgSGVscENlbnRlclNlcnZpY2Uge1xuXG4gICAgaXRlbXM6IEJlaGF2aW9yU3ViamVjdDxIZWxwQ2VudGVySXRlbVtdPiA9IG5ldyBCZWhhdmlvclN1YmplY3Q8SGVscENlbnRlckl0ZW1bXT4oW10pO1xuXG4gICAgcmVnaXN0ZXJJdGVtKGl0ZW06IEhlbHBDZW50ZXJJdGVtKTogdm9pZCB7XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBjdXJyZW50IGl0ZW1zXG4gICAgICAgIGxldCBpdGVtcyA9IHRoaXMuaXRlbXMuZ2V0VmFsdWUoKTtcblxuICAgICAgICAvLyBhZGQgdGhlIG5ldyBpdGVtIHRvIHRoZSBsaXN0XG4gICAgICAgIGl0ZW1zLnB1c2goaXRlbSk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBvYnNlcnZhYmxlXG4gICAgICAgIHRoaXMuaXRlbXMubmV4dChpdGVtcyk7XG4gICAgfVxuXG4gICAgdW5yZWdpc3Rlckl0ZW0oaXRlbTogSGVscENlbnRlckl0ZW0pOiB2b2lkIHtcblxuICAgICAgICAvLyBnZXQgdGhlIGN1cnJlbnQgaXRlbXNcbiAgICAgICAgbGV0IGl0ZW1zID0gdGhpcy5pdGVtcy5nZXRWYWx1ZSgpO1xuXG4gICAgICAgIC8vIHJlbW92ZSB0aGUgaXRlbSBiZWluZyB1bnJlZ2lzdGVyZWRcbiAgICAgICAgaXRlbXMgPSBpdGVtcy5maWx0ZXIoaXRtID0+IGl0bSAhPT0gaXRlbSk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBvYnNlcnZhYmxlXG4gICAgICAgIHRoaXMuaXRlbXMubmV4dChpdGVtcyk7XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEhlbHBDZW50ZXJJdGVtIHtcbiAgICBpY29uPzogc3RyaW5nO1xuICAgIHRpdGxlOiBzdHJpbmc7XG4gICAgc2VsZWN0PzogKCkgPT4gdm9pZDtcbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIElucHV0LCBPbkluaXQsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSGVscENlbnRlclNlcnZpY2UsIEhlbHBDZW50ZXJJdGVtIH0gZnJvbSAnLi9oZWxwLWNlbnRlci5zZXJ2aWNlJztcblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW3V4SGVscENlbnRlckl0ZW1dJyB9KVxuZXhwb3J0IGNsYXNzIEhlbHBDZW50ZXJJdGVtRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuXG4gICAgQElucHV0KCkgdXhIZWxwQ2VudGVySXRlbTogSGVscENlbnRlckl0ZW07XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9oZWxwQ2VudGVyU2VydmljZTogSGVscENlbnRlclNlcnZpY2UpIHsgfVxuXG4gICAgbmdPbkluaXQoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gcmVnaXN0ZXIgdGhlIGl0ZW0gaW4gdGhlIHNlcnZpY2VcbiAgICAgICAgdGhpcy5faGVscENlbnRlclNlcnZpY2UucmVnaXN0ZXJJdGVtKHRoaXMudXhIZWxwQ2VudGVySXRlbSk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIC8vIHJlbW92ZSB0aGlzIGl0ZW0gd2hlbiBpdCBpcyBkZXN0cm95ZWRcbiAgICAgICAgdGhpcy5faGVscENlbnRlclNlcnZpY2UudW5yZWdpc3Rlckl0ZW0odGhpcy51eEhlbHBDZW50ZXJJdGVtKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEhlbHBDZW50ZXJJdGVtRGlyZWN0aXZlIH0gZnJvbSAnLi9oZWxwLWNlbnRlci1pdGVtLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBIZWxwQ2VudGVyU2VydmljZSB9IGZyb20gJy4vaGVscC1jZW50ZXIuc2VydmljZSc7XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW10sXG4gICAgZXhwb3J0czogW0hlbHBDZW50ZXJJdGVtRGlyZWN0aXZlXSxcbiAgICBkZWNsYXJhdGlvbnM6IFtIZWxwQ2VudGVySXRlbURpcmVjdGl2ZV0sXG4gICAgcHJvdmlkZXJzOiBbSGVscENlbnRlclNlcnZpY2VdLFxufSlcbmV4cG9ydCBjbGFzcyBIZWxwQ2VudGVyTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcy9CZWhhdmlvclN1YmplY3QnO1xuaW1wb3J0IHsgSG92ZXJBY3Rpb25Db250YWluZXJEaXJlY3RpdmUgfSBmcm9tICcuL2hvdmVyLWFjdGlvbi1jb250YWluZXIuZGlyZWN0aXZlJztcbmltcG9ydCB7IEhvdmVyQWN0aW9uRGlyZWN0aXZlIH0gZnJvbSAnLi9ob3Zlci1hY3Rpb24uZGlyZWN0aXZlJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEhvdmVyQWN0aW9uU2VydmljZSB7XG5cbiAgICBhY3RpdmU6IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPiA9IG5ldyBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4oZmFsc2UpO1xuXG4gICAgcHJpdmF0ZSBfY29udGFpbmVyOiBIb3ZlckFjdGlvbkNvbnRhaW5lckRpcmVjdGl2ZTtcbiAgICBwcml2YXRlIF9mb2N1c2VkOiBib29sZWFuID0gZmFsc2U7XG4gICAgcHJpdmF0ZSBfaG92ZXJlZDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIHByaXZhdGUgX2FjdGlvbnM6IEhvdmVyQWN0aW9uRGlyZWN0aXZlW10gPSBbXTtcblxuICAgIHJlZ2lzdGVyKGFjdGlvbjogSG92ZXJBY3Rpb25EaXJlY3RpdmUpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fYWN0aW9ucy5wdXNoKGFjdGlvbik7XG4gICAgfVxuXG4gICAgdW5yZWdpc3RlcihhY3Rpb246IEhvdmVyQWN0aW9uRGlyZWN0aXZlKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2FjdGlvbnMgPSB0aGlzLl9hY3Rpb25zLmZpbHRlcihhY3RuID0+IGFjdG4gIT09IGFjdGlvbik7XG4gICAgfVxuXG4gICAgc2V0Q29udGFpbmVyKGNvbnRhaW5lcjogSG92ZXJBY3Rpb25Db250YWluZXJEaXJlY3RpdmUpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIH1cblxuICAgIHNldEZvY3VzU3RhdGUoZm9jdXM6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fZm9jdXNlZCA9IGZvY3VzO1xuICAgICAgICB0aGlzLnVwZGF0ZVZpc2liaWxpdHkoKTtcbiAgICB9XG5cbiAgICBzZXRIb3ZlclN0YXRlKGhvdmVyOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2hvdmVyZWQgPSBob3ZlcjtcbiAgICAgICAgdGhpcy51cGRhdGVWaXNpYmlsaXR5KCk7XG4gICAgfVxuXG4gICAgbmV4dCgpOiB2b2lkIHtcblxuICAgICAgICAvLyBpZiBjb250YWluZXIgaGFzIGZvY3VzIHRoZW4gZm9jdXMgdGhlIGZpcnN0IGhvdmVyIGFjdGlvblxuICAgICAgICBpZiAodGhpcy5jb250YWluZXJIYXNGb2N1cygpKSB7XG4gICAgICAgICAgICB0aGlzLmZvY3VzQWN0aW9uQXRJbmRleCgwKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZVZpc2liaWxpdHkoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIGEgaG92ZXIgYWN0aW9uIGhhcyBmb2N1cyB0aGVuIGZvY3VzIHRoZSBuZXh0IGFjdGlvblxuICAgICAgICBpZiAodGhpcy5hY3Rpb25IYXNGb2N1cygpKSB7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSB0aGlzLmdldEZvY3VzZWRBY3Rpb25JbmRleCgpICsgMTtcbiAgICAgICAgICAgIHRoaXMuZm9jdXNBY3Rpb25BdEluZGV4KGluZGV4KTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmlzaWJpbGl0eSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJldmlvdXMoKTogdm9pZCB7XG4gICAgICAgIC8vIGlmIGEgaG92ZXIgYWN0aW9uIGhhcyBmb2N1cyB0aGVuIGZvY3VzIHRoZSBwcmV2aW91cyBhY3Rpb25cbiAgICAgICAgaWYgKHRoaXMuYWN0aW9uSGFzRm9jdXMoKSkge1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5nZXRGb2N1c2VkQWN0aW9uSW5kZXgoKSAtIDE7XG5cbiAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb2N1c0FjdGlvbkF0SW5kZXgoaW5kZXgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250YWluZXIuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXBkYXRlVmlzaWJpbGl0eSgpO1xuICAgIH1cblxuICAgIHVwZGF0ZVZpc2liaWxpdHkoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuYWN0aXZlLm5leHQodGhpcy5fZm9jdXNlZCB8fCB0aGlzLl9ob3ZlcmVkIHx8IHRoaXMuYWN0aW9uSGFzRm9jdXMoKSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBmb2N1c0FjdGlvbkF0SW5kZXgoaW5kZXg6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHRoaXMuX2FjdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25zW2luZGV4XS5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRGb2N1c2VkQWN0aW9uSW5kZXgoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGlvbnMuZmluZEluZGV4KGFjdGlvbiA9PiBhY3Rpb24gPT09IHRoaXMuZ2V0Rm9jdXNlZEFjdGlvbigpKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGNvbnRhaW5lckhhc0ZvY3VzKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZm9jdXNlZDtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFjdGlvbkhhc0ZvY3VzKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gISF0aGlzLmdldEZvY3VzZWRBY3Rpb24oKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldEZvY3VzZWRBY3Rpb24oKTogSG92ZXJBY3Rpb25EaXJlY3RpdmUge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWN0aW9ucy5maW5kKGFjdGlvbiA9PiBhY3Rpb24uZm9jdXNlZCk7XG4gICAgfVxufSIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSG9zdExpc3RlbmVyLCBJbnB1dCwgT25EZXN0cm95IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBIb3ZlckFjdGlvblNlcnZpY2UgfSBmcm9tICcuL2hvdmVyLWFjdGlvbi5zZXJ2aWNlJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbdXhIb3ZlckFjdGlvbkNvbnRhaW5lcl0nLFxuICAgIHByb3ZpZGVyczogW0hvdmVyQWN0aW9uU2VydmljZV0sXG4gICAgaG9zdDoge1xuICAgICAgICAnW2NsYXNzLmhvdmVyLWFjdGlvbi1jb250YWluZXItYWN0aXZlXSc6ICdhY3RpdmUnLFxuICAgICAgICAnW3RhYmluZGV4XSc6ICd0YWJpbmRleCdcbiAgICB9XG59KVxuZXhwb3J0IGNsYXNzIEhvdmVyQWN0aW9uQ29udGFpbmVyRGlyZWN0aXZlIGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICAgIEBJbnB1dCgpIHRhYmluZGV4OiBudW1iZXIgPSAwO1xuICAgIGFjdGl2ZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgcHJpdmF0ZSBhY3RpdmUkOiBTdWJzY3JpcHRpb247XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmLCBwcml2YXRlIF9ob3ZlckFjdGlvblNlcnZpY2U6IEhvdmVyQWN0aW9uU2VydmljZSkge1xuICAgICAgICAvLyByZWdpc3RlciB0aGUgY29udGFpbmVyIGVsZW1lbnQgd2l0aCB0aGUgc2VydmljZVxuICAgICAgICB0aGlzLl9ob3ZlckFjdGlvblNlcnZpY2Uuc2V0Q29udGFpbmVyKHRoaXMpO1xuXG4gICAgICAgIC8vIGFwcGx5IGEgY2xhc3MgYmFzZWQgb24gdGhlIGFjdGl2ZSBzdGF0ZSBvZiB0aGUgY29udGFpbmVyIGFuZCBpdCdzIGFjdGlvbnNcbiAgICAgICAgdGhpcy5hY3RpdmUkID0gdGhpcy5faG92ZXJBY3Rpb25TZXJ2aWNlLmFjdGl2ZS5zdWJzY3JpYmUoYWN0aXZlID0+IHRoaXMuYWN0aXZlID0gYWN0aXZlKTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5hY3RpdmUkLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcignY2xpY2snKSBmb2N1cygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcignZm9jdXMnKSBvbkZvY3VzKCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9ob3ZlckFjdGlvblNlcnZpY2Uuc2V0Rm9jdXNTdGF0ZSh0cnVlKTtcbiAgICB9XG5cbiAgICBASG9zdExpc3RlbmVyKCdibHVyJykgb25CbHVyKCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9ob3ZlckFjdGlvblNlcnZpY2Uuc2V0Rm9jdXNTdGF0ZShmYWxzZSk7XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcignbW91c2VlbnRlcicpIG9uSG92ZXIoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2hvdmVyQWN0aW9uU2VydmljZS5zZXRIb3ZlclN0YXRlKHRydWUpO1xuICAgIH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ21vdXNlbGVhdmUnKSBvbkxlYXZlKCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9ob3ZlckFjdGlvblNlcnZpY2Uuc2V0SG92ZXJTdGF0ZShmYWxzZSk7XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcigna2V5ZG93bi5hcnJvd3JpZ2h0JykgbmV4dCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5faG92ZXJBY3Rpb25TZXJ2aWNlLm5leHQoKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBIb3N0TGlzdGVuZXIsIE9uRGVzdHJveSwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEhvdmVyQWN0aW9uU2VydmljZSB9IGZyb20gJy4vaG92ZXItYWN0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcy9TdWJzY3JpcHRpb24nO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1t1eEhvdmVyQWN0aW9uXScsXG4gICAgaG9zdDoge1xuICAgICAgICAnW2NsYXNzLmhvdmVyLWFjdGlvbi1hY3RpdmVdJzogJ2FjdGl2ZScsXG4gICAgICAgICdbY2xhc3MuaG92ZXItYWN0aW9uLWZvY3VzZWRdJzogJ2ZvY3VzZWQnLFxuICAgICAgICAnW3RhYmluZGV4XSc6ICd0YWJpbmRleCdcbiAgICB9XG59KVxuZXhwb3J0IGNsYXNzIEhvdmVyQWN0aW9uRGlyZWN0aXZlIGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICAgIEBJbnB1dCgpIHRhYmluZGV4OiBudW1iZXIgPSAxO1xuICAgIGFjdGl2ZTogYm9vbGVhbiA9IGZhbHNlO1xuICAgIGZvY3VzZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIHByaXZhdGUgYWN0aXZlJDogU3Vic2NyaXB0aW9uO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZiwgcHJpdmF0ZSBfaG92ZXJBY3Rpb25TZXJ2aWNlOiBIb3ZlckFjdGlvblNlcnZpY2UpIHtcblxuICAgICAgICAvLyByZWdpc3RlciB0aGUgYWN0aW9uXG4gICAgICAgIHRoaXMuX2hvdmVyQWN0aW9uU2VydmljZS5yZWdpc3Rlcih0aGlzKTtcblxuICAgICAgICAvLyB3YXRjaCBmb3IgY2hhbmdlcyB0byB0aGUgYWN0aXZlbmVzcyBvZiB0aGUgY29udGFpbmVyXG4gICAgICAgIHRoaXMuYWN0aXZlJCA9IHRoaXMuX2hvdmVyQWN0aW9uU2VydmljZS5hY3RpdmUuc3Vic2NyaWJlKGFjdGl2ZSA9PiB0aGlzLmFjdGl2ZSA9IGFjdGl2ZSk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2hvdmVyQWN0aW9uU2VydmljZS51bnJlZ2lzdGVyKHRoaXMpO1xuICAgICAgICB0aGlzLmFjdGl2ZSQudW5zdWJzY3JpYmUoKTtcbiAgICB9XG5cbiAgICBmb2N1cygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcignZm9jdXMnKSBvbkZvY3VzKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmZvY3VzZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9ob3ZlckFjdGlvblNlcnZpY2UudXBkYXRlVmlzaWJpbGl0eSgpO1xuICAgIH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ2JsdXInKSBvbkJsdXIoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9ob3ZlckFjdGlvblNlcnZpY2UudXBkYXRlVmlzaWJpbGl0eSgpO1xuICAgIH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ2tleWRvd24uYXJyb3dsZWZ0JywgWyckZXZlbnQnXSkgcHJldmlvdXMoZXZlbnQ6IE1vdXNlRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7ICAgICAgICBcbiAgICAgICAgdGhpcy5faG92ZXJBY3Rpb25TZXJ2aWNlLnByZXZpb3VzKCk7XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcigna2V5ZG93bi5hcnJvd3JpZ2h0JywgWyckZXZlbnQnXSkgbmV4dChldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgdGhpcy5faG92ZXJBY3Rpb25TZXJ2aWNlLm5leHQoKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEhvdmVyQWN0aW9uQ29udGFpbmVyRGlyZWN0aXZlIH0gZnJvbSAnLi9ob3Zlci1hY3Rpb24tY29udGFpbmVyLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBIb3ZlckFjdGlvbkRpcmVjdGl2ZSB9IGZyb20gJy4vaG92ZXItYWN0aW9uLmRpcmVjdGl2ZSc7XG5cbmNvbnN0IERFQ0xBUkFUSU9OUyA9IFtcbiAgICBIb3ZlckFjdGlvbkRpcmVjdGl2ZSxcbiAgICBIb3ZlckFjdGlvbkNvbnRhaW5lckRpcmVjdGl2ZVxuXTtcblxuQE5nTW9kdWxlKHtcbiAgICBleHBvcnRzOiBERUNMQVJBVElPTlMsXG4gICAgZGVjbGFyYXRpb25zOiBERUNMQVJBVElPTlNcbn0pXG5leHBvcnQgY2xhc3MgSG92ZXJBY3Rpb25Nb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVtYmVkZGVkVmlld1JlZiwgSW5wdXQsIFRlbXBsYXRlUmVmLCBWaWV3Q29udGFpbmVyUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3V4TGF5b3V0U3dpdGNoZXJJdGVtXSdcbn0pXG5leHBvcnQgY2xhc3MgTGF5b3V0U3dpdGNoZXJJdGVtRGlyZWN0aXZlIHtcblxuICAgIEBJbnB1dCgndXhMYXlvdXRTd2l0Y2hlckl0ZW0nKSBwcml2YXRlIF9jb25maWc6IExheW91dFN3aXRjaGVySXRlbTtcblxuICAgIHByaXZhdGUgX2VtYmVkZGVkVmlldzogRW1iZWRkZWRWaWV3UmVmPGFueT47XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF90ZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8YW55PiwgcHJpdmF0ZSBfdmlld0NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZikgeyB9XG5cbiAgICBnZXRMYXlvdXQoKTogVGVtcGxhdGVSZWY8YW55PiB7XG4gICAgICAgIHJldHVybiB0aGlzLl90ZW1wbGF0ZVJlZjtcbiAgICB9XG5cbiAgICBnZXRDb25maWcoKTogTGF5b3V0U3dpdGNoZXJJdGVtIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbmZpZztcbiAgICB9XG5cbiAgICBhY3RpdmF0ZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fZW1iZWRkZWRWaWV3ID0gdGhpcy5fdmlld0NvbnRhaW5lclJlZi5jcmVhdGVFbWJlZGRlZFZpZXcodGhpcy5fdGVtcGxhdGVSZWYpO1xuICAgIH1cblxuICAgIGRlYWN0aXZhdGUoKTogdm9pZCB7XG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMuX3ZpZXdDb250YWluZXJSZWYuaW5kZXhPZih0aGlzLl9lbWJlZGRlZFZpZXcpO1xuICAgICAgICB0aGlzLl92aWV3Q29udGFpbmVyUmVmLnJlbW92ZShpbmRleCk7XG4gICAgICAgIHRoaXMuX2VtYmVkZGVkVmlldyA9IG51bGw7XG4gICAgfVxuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGF5b3V0U3dpdGNoZXJJdGVtIHtcbiAgICBncm91cD86IHN0cmluZztcbiAgICBtaW5XaWR0aD86IG51bWJlcjtcbiAgICBtYXhXaWR0aD86IG51bWJlcjtcbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIFF1ZXJ5TGlzdCwgQ29udGVudENoaWxkcmVuLCBJbnB1dCwgQWZ0ZXJDb250ZW50SW5pdCwgVmlld0NvbnRhaW5lclJlZiwgT25DaGFuZ2VzLCBTaW1wbGVDaGFuZ2VzIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBSZXNpemVTZXJ2aWNlIH0gZnJvbSAnLi4vcmVzaXplL2luZGV4JztcbmltcG9ydCB7IExheW91dFN3aXRjaGVySXRlbURpcmVjdGl2ZSB9IGZyb20gJy4vbGF5b3V0LXN3aXRjaGVyLWl0ZW0uZGlyZWN0aXZlJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbdXhMYXlvdXRTd2l0Y2hlcl0nXG59KVxuZXhwb3J0IGNsYXNzIExheW91dFN3aXRjaGVyRGlyZWN0aXZlIGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdCwgT25DaGFuZ2VzIHtcblxuICAgIEBJbnB1dCgpIGdyb3VwOiBzdHJpbmc7XG4gICAgQENvbnRlbnRDaGlsZHJlbihMYXlvdXRTd2l0Y2hlckl0ZW1EaXJlY3RpdmUpIHByaXZhdGUgX2xheW91dHM6IFF1ZXJ5TGlzdDxMYXlvdXRTd2l0Y2hlckl0ZW1EaXJlY3RpdmU+O1xuICAgIFxuICAgIHByaXZhdGUgX3dpZHRoOiBudW1iZXI7XG4gICAgcHJpdmF0ZSBfYWN0aXZlTGF5b3V0OiBMYXlvdXRTd2l0Y2hlckl0ZW1EaXJlY3RpdmU7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmLCByZXNpemVTZXJ2aWNlOiBSZXNpemVTZXJ2aWNlLFxuICAgICAgICBwcml2YXRlIF92aWV3Q29udGFpbmVyUmVmOiBWaWV3Q29udGFpbmVyUmVmKSB7XG5cbiAgICAgICAgLy8gd2F0Y2ggZm9yIGNoYW5nZXMgdG8gdGhlIGNvbnRhaW5lciBzaXplXG4gICAgICAgIHJlc2l6ZVNlcnZpY2UuYWRkUmVzaXplTGlzdGVuZXIoX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCkuc3Vic2NyaWJlKGV2ZW50ID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3dpZHRoID0gZXZlbnQud2lkdGg7XG5cbiAgICAgICAgICAgIC8vIHJlbmRlciB0aGUgYXBwcm9wcmlhdGUgbGF5b3V0XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUFjdGl2ZUxheW91dCgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG5cbiAgICAgICAgLy8gaWYgdGhlIGFjdGl2ZSBncm91cCBoYXMgY2hhbmdlZCB0aGVuIHJlbmRlciB0aGUgYXBwcm9wcmlhdGUgbGF5b3V0XG4gICAgICAgIGlmIChjaGFuZ2VzLmdyb3VwLmN1cnJlbnRWYWx1ZSAhPT0gY2hhbmdlcy5ncm91cC5wcmV2aW91c1ZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUFjdGl2ZUxheW91dCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0QWN0aXZlTGF5b3V0KCk6IExheW91dFN3aXRjaGVySXRlbURpcmVjdGl2ZSB8IG51bGwge1xuXG4gICAgICAgIC8vIGlmIHRoZXJlIGFyZSBjdXJyZW50bHkgbm8gbGF5b3V0cyB0aGVuIGRvIG5vdGhpbmdcbiAgICAgICAgaWYgKCF0aGlzLl9sYXlvdXRzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG90aGVyd2lzZSBmaW5kIGxheW91dHMgdGhhdCBtYXRjaCB0aGUgYWN0aXZlIGdyb3VwIGFuZCB0aGF0IG1lZXQgdGhlIGNvbnN0cmFpbnRzXG4gICAgICAgIHJldHVybiB0aGlzLl9sYXlvdXRzLmZpbHRlcihsYXlvdXQgPT4gdGhpcy5ncm91cCA9PT0gbGF5b3V0LmdldENvbmZpZygpLmdyb3VwKS5maW5kKGxheW91dCA9PiB7XG5cbiAgICAgICAgICAgIGxldCBtaW5XaWR0aCA9IGxheW91dC5nZXRDb25maWcoKS5taW5XaWR0aCB8fCAwO1xuICAgICAgICAgICAgbGV0IG1heFdpZHRoID0gbGF5b3V0LmdldENvbmZpZygpLm1heFdpZHRoIHx8IEluZmluaXR5O1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2lkdGggPj0gbWluV2lkdGggJiYgdGhpcy5fd2lkdGggPCBtYXhXaWR0aDtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdXBkYXRlQWN0aXZlTGF5b3V0KCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGdldCB0aGUgbGF5b3V0IHRoYXQgc2hvdWxkIGJlIHNob3duXG4gICAgICAgIGxldCBsYXlvdXQgPSB0aGlzLmdldEFjdGl2ZUxheW91dCgpO1xuXG4gICAgICAgIC8vIGNoZWNrIGlmIHdlIGFyZSBjdXJyZW50bHkgc2hvd2luZyB0aGUgbGF5b3V0XG4gICAgICAgIGlmICh0aGlzLl9hY3RpdmVMYXlvdXQgPT09IGxheW91dCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVtb3ZlIHRoZSBjdXJyZW50IGxheW91dFxuICAgICAgICBpZiAodGhpcy5fYWN0aXZlTGF5b3V0KSB7XG4gICAgICAgICAgICB0aGlzLl9hY3RpdmVMYXlvdXQuZGVhY3RpdmF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc3RvcmUgdGhlIG5ldyBhY3RpdmUgbGF5b3V0XG4gICAgICAgIHRoaXMuX2FjdGl2ZUxheW91dCA9IGxheW91dDtcblxuICAgICAgICAvLyBpZiB0aGVyZSBpcyBhbiBhY3RpdmUgbGF5b3V0IHRoZW4gYWN0aXZhdGVcbiAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZUxheW91dCkge1xuICAgICAgICAgICAgdGhpcy5fYWN0aXZlTGF5b3V0LmFjdGl2YXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gc3RvcmUgdGhlIGluaXRpYWwgY3VycmVudCBlbGVtZW50IHdpZHRoXG4gICAgICAgIHRoaXMuX3dpZHRoID0gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoO1xuXG4gICAgICAgIC8vIHJlbmRlciB0aGUgYXBwcm9wcmlhdGUgbGF5b3V0IC0gbmVlZCBhIGRlbGF5IGFzIEFuZ3VsYXIgZG9lc24ndCBsaWtlIGNoYW5nZXMgbGlrZSB0aGlzIGluIHRoZXNlIGxpZmVjeWNsZSBob29rc1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy51cGRhdGVBY3RpdmVMYXlvdXQuYmluZCh0aGlzKSk7XG4gICAgfVxufSIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBMYXlvdXRTd2l0Y2hlckRpcmVjdGl2ZSB9IGZyb20gJy4vbGF5b3V0LXN3aXRjaGVyLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBMYXlvdXRTd2l0Y2hlckl0ZW1EaXJlY3RpdmUgfSBmcm9tICcuL2xheW91dC1zd2l0Y2hlci1pdGVtLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBSZXNpemVNb2R1bGUgfSBmcm9tICcuLi9yZXNpemUvaW5kZXgnO1xuXG5jb25zdCBERUNMQVJBVElPTlMgPSBbXG4gICAgTGF5b3V0U3dpdGNoZXJEaXJlY3RpdmUsXG4gICAgTGF5b3V0U3dpdGNoZXJJdGVtRGlyZWN0aXZlXG5dO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgUmVzaXplTW9kdWxlXG4gICAgXSxcbiAgICBleHBvcnRzOiBERUNMQVJBVElPTlMsXG4gICAgZGVjbGFyYXRpb25zOiBERUNMQVJBVElPTlMsXG4gICAgcHJvdmlkZXJzOiBbXSxcbn0pXG5leHBvcnQgY2xhc3MgTGF5b3V0U3dpdGNoZXJNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBBZnRlclZpZXdJbml0LCBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE9uRGVzdHJveSwgT25Jbml0LCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW3V4T3ZlcmZsb3dPYnNlcnZlcl0sIFt1eE92ZXJmbG93SG9yaXpvbnRhbE9ic2VydmVyXSwgW3V4T3ZlcmZsb3dWZXJ0aWNhbE9ic2VydmVyXScsXG4gIGV4cG9ydEFzOiAndXgtb3ZlcmZsb3ctb2JzZXJ2ZXInXG59KVxuZXhwb3J0IGNsYXNzIE92ZXJmbG93RGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBBZnRlclZpZXdJbml0LCBPbkRlc3Ryb3kge1xuXG4gIC8qKiBBbGxvdyBhIG9ic2VydmFibGUgdG8gYmUgdXNlZCB0byBjaGVjayBmb3Igb3ZlcmZsb3cgKi9cbiAgQElucHV0KCkgdHJpZ2dlcjogT2JzZXJ2YWJsZTx2b2lkPjtcblxuICAvKiogQWxsb3cgb3ZlcmZsb3cgdG8gYmUgd2l0aGluIGEgcmFuZ2UgYmVmb3JlIGVtaXR0aW5nICovXG4gIEBJbnB1dCgpIHRvbGVyYW5jZTogbnVtYmVyID0gMDtcblxuICAvKiogRW1pdCB3aGVuIHRoZXJlIGlzIGEgY2hhbmdlIHRvIHRoZSBvdmVyZmxvdyBzdGF0ZSAtIGhvcml6b250YWwgb3IgdmVydGljYWwgKi9cbiAgQE91dHB1dCgpIHV4T3ZlcmZsb3dPYnNlcnZlciA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oKTtcblxuICAvKiogRW1pdCB3aGVuIHRoZXJlIGlzIGEgY2hhbmdlIHRvIG92ZXJmbG93IG9uIHRoZSBob3Jpem9udGFsIGF4aXMgKi9cbiAgQE91dHB1dCgpIHV4T3ZlcmZsb3dIb3Jpem9udGFsT2JzZXJ2ZXIgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XG5cbiAgLyoqIEVtaXQgd2hlbiB0aGVyZSBpcyBhIGNoYW5nZSB0byBvdmVyZmxvdyBvbiB0aGUgdmVydGljYWwgYXhpcyAqL1xuICBAT3V0cHV0KCkgdXhPdmVyZmxvd1ZlcnRpY2FsT2JzZXJ2ZXIgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XG5cbiAgLyoqIFN0b3JlIHRoZSBvdmVyZmxvdyBzdGF0ZSBvbiBib3RoIGF4aXMgKi9cbiAgcHJpdmF0ZSBfc3RhdGUgPSB7IGhvcml6b250YWxPdmVyZmxvdzogZmFsc2UsIHZlcnRpY2FsT3ZlcmZsb3c6IGZhbHNlIH07XG5cbiAgLyoqIFVuc3Vic2NyaWJlIGZyb20gYWxsIHRoZSBvYnNlcnZhYmxlcyAqL1xuICBwcml2YXRlIF9vbkRlc3Ryb3kgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYpIHsgfVxuXG4gIC8qKiBTZXQgdXAgdGhlIHRyaWdnZXIgaWYgc3BlY2lmaWVkICovXG4gIG5nT25Jbml0KCk6IHZvaWQge1xuICAgIGlmICh0aGlzLnRyaWdnZXIpIHtcbiAgICAgIHRoaXMudHJpZ2dlci5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5jaGVja0Zvck92ZXJmbG93KCkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBQZXJmb3JtIGFuIGludGlhbCBjaGVjayBmb3Igb3ZlcmZsb3cgKi9cbiAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLmNoZWNrRm9yT3ZlcmZsb3coKSk7XG4gIH1cblxuICAvKiogVW5zdWJzY3JpYmUgZnJvbSB0aGUgdHJpZ2dlciAqL1xuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLl9vbkRlc3Ryb3kubmV4dCgpO1xuICAgIHRoaXMuX29uRGVzdHJveS5jb21wbGV0ZSgpO1xuICB9XG5cbiAgLyoqIFByb2dyYW1tYXRpY2FsbHkgdHJpZ2dlciBjaGVjayBmb3Igb3ZlcmZsb3cgKi9cbiAgY2hlY2tGb3JPdmVyZmxvdygpOiB2b2lkIHtcblxuICAgIGNvbnN0IHsgb2Zmc2V0V2lkdGgsIG9mZnNldEhlaWdodCwgc2Nyb2xsV2lkdGgsIHNjcm9sbEhlaWdodCB9ID0gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgIGNvbnN0IGhvcml6b250YWxPdmVyZmxvdyA9IChzY3JvbGxXaWR0aCAtIG9mZnNldFdpZHRoKSA+IHRoaXMudG9sZXJhbmNlO1xuICAgIGNvbnN0IHZlcnRpY2FsT3ZlcmZsb3cgPSAoc2Nyb2xsSGVpZ2h0IC0gb2Zmc2V0SGVpZ2h0KSA+IHRoaXMudG9sZXJhbmNlO1xuXG4gICAgaWYgKGhvcml6b250YWxPdmVyZmxvdyAhPT0gdGhpcy5fc3RhdGUuaG9yaXpvbnRhbE92ZXJmbG93KSB7XG4gICAgICB0aGlzLnV4T3ZlcmZsb3dIb3Jpem9udGFsT2JzZXJ2ZXIuZW1pdChob3Jpem9udGFsT3ZlcmZsb3cpO1xuICAgIH1cblxuICAgIGlmICh2ZXJ0aWNhbE92ZXJmbG93ICE9PSB0aGlzLl9zdGF0ZS52ZXJ0aWNhbE92ZXJmbG93KSB7XG4gICAgICB0aGlzLnV4T3ZlcmZsb3dWZXJ0aWNhbE9ic2VydmVyLmVtaXQodmVydGljYWxPdmVyZmxvdyk7XG4gICAgfVxuXG4gICAgaWYgKGhvcml6b250YWxPdmVyZmxvdyAhPT0gdGhpcy5fc3RhdGUuaG9yaXpvbnRhbE92ZXJmbG93IHx8IHZlcnRpY2FsT3ZlcmZsb3cgIT09IHRoaXMuX3N0YXRlLnZlcnRpY2FsT3ZlcmZsb3cpIHtcbiAgICAgIHRoaXMudXhPdmVyZmxvd09ic2VydmVyLmVtaXQoKGhvcml6b250YWxPdmVyZmxvdyB8fCB2ZXJ0aWNhbE92ZXJmbG93KSk7XG4gICAgfVxuXG4gICAgLy8gc3RvcmUgdGhlIHN0YXRlXG4gICAgdGhpcy5fc3RhdGUgPSB7IGhvcml6b250YWxPdmVyZmxvdywgdmVydGljYWxPdmVyZmxvdyB9O1xuICB9XG59XG4iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgT3ZlcmZsb3dEaXJlY3RpdmUgfSBmcm9tICcuL292ZXJmbG93L292ZXJmbG93LW9ic2VydmVyLmRpcmVjdGl2ZSc7XG5cbkBOZ01vZHVsZSh7XG4gIGV4cG9ydHM6IFtPdmVyZmxvd0RpcmVjdGl2ZV0sXG4gIGRlY2xhcmF0aW9uczogW092ZXJmbG93RGlyZWN0aXZlXVxufSlcbmV4cG9ydCBjbGFzcyBPYnNlcnZlcnNNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBTZWxlY3Rpb25TZXJ2aWNlIH0gZnJvbSAnLi4vc2VsZWN0aW9uLnNlcnZpY2UnO1xuXG5leHBvcnQgY2xhc3MgU2VsZWN0aW9uU3RyYXRlZ3kge1xuXG4gIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBzZWxlY3Rpb25TZXJ2aWNlPzogU2VsZWN0aW9uU2VydmljZSkgeyB9XG5cbiAgc2V0U2VsZWN0aW9uU2VydmljZShzZWxlY3Rpb25TZXJ2aWNlOiBTZWxlY3Rpb25TZXJ2aWNlKTogdm9pZCB7XG4gICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlID0gc2VsZWN0aW9uU2VydmljZTtcbiAgfVxuXG4gIG1vdXNlZG93bihldmVudDogTW91c2VFdmVudCwgZGF0YTogYW55KTogdm9pZCB7IH1cblxuICBjbGljayhldmVudDogTW91c2VFdmVudCwgZGF0YTogYW55KTogdm9pZCB7IH1cblxuICBrZXlkb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50LCBkYXRhOiBhbnkpOiB2b2lkIHsgfVxuXG4gIC8qKlxuICAgKiBTZWxlY3QgdGhlIGl0ZW0gLSBkZWZhdWx0IGJlaGF2aW9yXG4gICAqL1xuICBzZWxlY3QoLi4uZGF0YTogYW55W10pOiB2b2lkIHtcbiAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2Uuc2VsZWN0KC4uLmRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRvZ2dsZSB0aGUgaXRlbSdzIHNlbGVjdGVkIHN0YXRlIC0gZGVmYXVsdCBiZWhhdmlvclxuICAgKi9cbiAgdG9nZ2xlKC4uLmRhdGE6IGFueVtdKTogdm9pZCB7XG4gICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLnRvZ2dsZSguLi5kYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXNlbGVjdCB0aGUgaXRlbSAtIGRlZmF1bHQgYmVoYXZpb3JcbiAgICovXG4gIGRlc2VsZWN0KC4uLmRhdGE6IGFueVtdKTogdm9pZCB7XG4gICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmRlc2VsZWN0KC4uLmRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbGVjdCBhbGwgaXRlbXMgLSBkZWZhdWx0IGJlaGF2aW9yXG4gICAqL1xuICBzZWxlY3RBbGwoKTogdm9pZCB7XG4gICAgdGhpcy5zZWxlY3QoLi4udGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmRhdGFzZXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlc2VsZWN0IGFsbCBpdGVtcyAtIGRlZmF1bHQgYmVoYXZpb3JcbiAgICovXG4gIGRlc2VsZWN0QWxsKCk6IHZvaWQge1xuICAgIHRoaXMuZGVzZWxlY3QoLi4udGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmRhdGFzZXQpO1xuICB9XG5cbiAgZGVzdHJveSgpOiB2b2lkIHsgfVxufVxuIiwiaW1wb3J0IHsgS2V5Q29kZSB9IGZyb20gJy4va2V5Y29kZS5lbnVtJztcbmltcG9ydCB7IFNlbGVjdGlvblN0cmF0ZWd5IH0gZnJvbSAnLi9zZWxlY3Rpb24uc3RyYXRlZ3knO1xuXG5leHBvcnQgY2xhc3MgUm93U2VsZWN0aW9uU3RyYXRlZ3kgZXh0ZW5kcyBTZWxlY3Rpb25TdHJhdGVneSB7XG5cbiAgLy8gc3RvcmUgdGhlIG1vc3QgcmVjZW50bHkgc2VsZWN0ZWQgcm93XG4gIHByaXZhdGUgX3NlbGVjdGlvbjogU2VsZWN0aW9uID0geyBzdGFydDogbnVsbCwgZW5kOiBudWxsIH07XG5cbiAgLyoqXG4gICAqIEJ5IGRlZmF1bHQgb24gc2hpZnQgY2xpY2sgdGhlIGJyb3dzZXIgd2lsbCBoaWdobGlnaHRcbiAgICogdGV4dC4gVGhpcyBsb29rcyBiYWQgYW5kIHdlIGRvbid0IHdhbnQgdGhpcyB0byBvY2N1clxuICAgKi9cbiAgbW91c2Vkb3duKGV2ZW50OiBNb3VzZUV2ZW50KTogdm9pZCB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGVuIGEgcm93IGlzIGNsaWNrZWQgd2Ugd2FudCB0byBoYW5kbGUgc2VsZWN0aW9uXG4gICAqL1xuICBjbGljayhldmVudDogTW91c2VFdmVudCwgZGF0YTogYW55KTogdm9pZCB7XG5cbiAgICAvLyBkZXRlcm1pbmUgd2hpY2ggbW9kaWZpZXIga2V5cyBhcmUgcHJlc3NlZFxuICAgIGNvbnN0IHsgY3RybEtleSwgc2hpZnRLZXkgfSA9IGV2ZW50O1xuXG4gICAgLy8gaWYgdGhlIHNoaWZ0IGtleSBpcyBwcmVzc2VkIHdlIHdhbnQgdG8gcGVyZm9ybSBhIG11bHRpcGxlIHNlbGVjdGlvblxuICAgIGlmIChzaGlmdEtleSkge1xuICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbGVTZWxlY3QoZGF0YSk7XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlIGNvbnRyb2wga2V5IGlzIHByZXNzZWQgd2Ugd2FudCB0byBwZXJmb3JtIGFuIGFkZGl0aXZlIHRvZ2dsZSBzZWxlY3Rpb25cbiAgICBpZiAoY3RybEtleSkge1xuICAgICAgcmV0dXJuIHRoaXMudG9nZ2xlKGRhdGEpO1xuICAgIH1cblxuICAgIC8vIHBlcmZvcm0gYSBzaW5nbGUgc2VsZWN0aW9uIHdoZXJlIGFsbCBvdGhlciByb3dzIGFyZSBkZXNlbGVjdGVkXG4gICAgdGhpcy5zaW5nbGVTZWxlY3QoZGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogVG8gc3VwcG9ydCBmdWxsIGtleWJvYXJkIGNvbnRyb2wgd2UgbmVlZCB0byBzdXBwb3J0IHRoZSBmb2xsb3dpbmc6XG4gICAqIDEuIEFycm93IGtleXMgdG8gbmF2aWdhdGUgdXAgYW5kIGRvd25cbiAgICogMi4gU3BhY2ViYXIgdG8gdG9nZ2xlIHNlbGVjdGlvblxuICAgKiAzLiBTaGlmdCArIEFycm93IGtleXMgdG8gbXVsdGlwbGUgc2VsZWN0XG4gICAqIDQuIEN0cmwgKyBBcnJvdyBrZXlzIHRvIGFsbG93IHJldGFpbmVkIHNlbGVjdGlvbiBhbmQgbmF2aWdhdGlvblxuICAgKi9cbiAga2V5ZG93bihldmVudDogS2V5Ym9hcmRFdmVudCwgZGF0YTogYW55KTogdm9pZCB7XG5cbiAgICBzd2l0Y2ggKGV2ZW50LmtleUNvZGUpIHtcblxuICAgICAgY2FzZSBLZXlDb2RlLlVwQXJyb3c6XG4gICAgICBjYXNlIEtleUNvZGUuRG93bkFycm93OlxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLm5hdmlnYXRlKGV2ZW50LCBkYXRhKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgS2V5Q29kZS5TcGFjZWJhcjpcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLnN0cmF0ZWd5LnRvZ2dsZShkYXRhLCB0cnVlKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogT3ZlcnJpZGUgdGhlIHN0YW5kYXJkIHRvZ2dsZSBmdW5jdGlvbiB0byBzdG9yZSBvciBjbGVhciB0aGVcbiAgICogbW9zdCByZWNlbnRseSBzZWxlY3RlZCBpdGVtXG4gICAqL1xuICB0b2dnbGUoZGF0YTogYW55LCBhY3RpdmF0ZTogYm9vbGVhbiA9IGZhbHNlKTogdm9pZCB7XG4gICAgc3VwZXIudG9nZ2xlKGRhdGEpO1xuXG4gICAgLy8gc3RvcmUgb3IgY2xlYXIgdGhlIHNlbGVjdGlvblxuICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZS5pc1NlbGVjdGVkKGRhdGEpID8gdGhpcy5zZXRTZWxlY3Rpb25TdGFydChkYXRhKSA6IHRoaXMuY2xlYXJTZWxlY3Rpb24oKTtcblxuICAgIC8vIGlmIHdlIHdhbnQgdG8ga2VlcCB0aGUgaXRlbSBhY3RpdmF0ZWQgdGhlbiBhY3RpdmF0ZVxuICAgIGlmIChhY3RpdmF0ZSkge1xuICAgICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmFjdGl2YXRlKGRhdGEpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhciBhbGwgb3RoZXIgc2VsZWN0ZWQgaXRlbXMgYW5kIHNlbGVjdCBvbmx5XG4gICAqIHRoZSBtb3N0IHJlY2VudGx5IHNlbGVjdGVkIGl0ZW1cbiAgICovXG4gIHByaXZhdGUgc2luZ2xlU2VsZWN0KGRhdGE6IGFueSk6IHZvaWQge1xuXG4gICAgLy8gZGVzZWxlY3QgYWxsIG90aGVyIHJvd3MgaWYgbmVpdGhlciBtb2RpZmllciBrZXkgaXMgcHJlc3NlZFxuICAgIHRoaXMuZGVzZWxlY3RBbGwoKTtcblxuICAgIC8vIHNlbGVjdCB0aGUgY3VycmVudCByb3dcbiAgICB0aGlzLnNlbGVjdChkYXRhKTtcblxuICAgIC8vIHN0b3JlIHRoZSBjdXJyZW50IGl0ZW0gYXMgdGhlIHNlbGVjdGlvbiBzdGFydFxuICAgIHRoaXMuc2V0U2VsZWN0aW9uU3RhcnQoZGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIG11bHRpcGxlIHNlbGVjdGlvbjpcbiAgICogMS4gSWYgbm8gc3RhcnQgaXRlbSBzZWxlY3RlZCAtIHNlbGVjdCBpdFxuICAgKiAyLiBJZiBhIHN0YXJ0IGl0ZW0gaGFzIGJlZW4gc2VsZWN0ZWQgLSBzZWxlY3QgYWxsIGluIGJldHdlZW5cbiAgICogMy4gSWYgYSBzdGFydCBhbmQgZW5kIGl0ZW0gaGF2ZSBiZWVuIHNlbGVjdGVkIGNsZWFyIHRoZSByYW5nZSBhbmQgdGhlbiBzZWxlY3QgdGhlIG5ldyByYW5nZVxuICAgKi9cbiAgcHJvdGVjdGVkIG11bHRpcGxlU2VsZWN0KGRhdGE6IGFueSk6IHZvaWQge1xuXG4gICAgLy8gaWYgbm8gc2VsZWN0aW9uIGN1cnJlbnRseSBleGlzdHMgdGhlbiBwZXJmb3JtIGluaXRpYWwgc2VsZWN0aW9uXG4gICAgaWYgKCF0aGlzLl9zZWxlY3Rpb24uc3RhcnQpIHtcblxuICAgICAgLy8gc2VsZWN0IHRoZSByb3dcbiAgICAgIHRoaXMuc2VsZWN0KGRhdGEpO1xuXG4gICAgICAvLyBzdG9yZSB0aGUgc3RhcnRpbmcgcG9pbnRcbiAgICAgIHJldHVybiB0aGlzLnNldFNlbGVjdGlvblN0YXJ0KGRhdGEpO1xuICAgIH1cblxuICAgIC8vIGlmIGEgbXVsdGlwbGUgc2VsZWN0aW9uIGFscmVhZHkgdG9vayBwbGFjZSAtIGNsZWFyIHRoZSBwcmV2aW91cyBzZWxlY3Rpb25cbiAgICBpZiAodGhpcy5fc2VsZWN0aW9uLnN0YXJ0ICYmIHRoaXMuX3NlbGVjdGlvbi5lbmQpIHtcbiAgICAgIHRoaXMuZGVzZWxlY3QoLi4udGhpcy5nZXRTZWxlY3RlZEl0ZW1zKCkpO1xuICAgIH1cblxuICAgIC8vIHNldCB0aGUgbmV3IHNlbGVjdGlvbiBlbmQgcG9pbnRcbiAgICB0aGlzLnNldFNlbGVjdGlvbkVuZChkYXRhKTtcblxuICAgIC8vIHNlbGVjdCBhbGwgdGhlIGl0ZW1zIGluIHRoZSByYW5nZVxuICAgIHRoaXMuc2VsZWN0KC4uLnRoaXMuZ2V0U2VsZWN0ZWRJdGVtcygpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHNlbGVjdGlvbiBzdGFydCBwb2ludC4gSWYgdGhlcmUgd2FzIHByZXZpb3VzbHkgYVxuICAgKiBzZWxlY3Rpb24gZW5kIHBvaW50IHRoZW4gY2xlYXIgaXQgYXMgdGhpcyBpcyBhIG5ldyBzZWxlY3Rpb25cbiAgICovXG4gIHByaXZhdGUgc2V0U2VsZWN0aW9uU3RhcnQoZGF0YTogYW55KTogdm9pZCB7XG4gICAgdGhpcy5fc2VsZWN0aW9uLnN0YXJ0ID0gZGF0YTtcbiAgICB0aGlzLl9zZWxlY3Rpb24uZW5kID0gbnVsbDtcblxuICAgIC8vIGFjdGl2YXRlIHRoZSBpdGVtXG4gICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmFjdGl2YXRlKGRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc2VsZWN0aW9uIGVuZCBwb2ludFxuICAgKi9cbiAgcHJpdmF0ZSBzZXRTZWxlY3Rpb25FbmQoZGF0YTogYW55KTogdm9pZCB7XG4gICAgdGhpcy5fc2VsZWN0aW9uLmVuZCA9IGRhdGE7XG5cbiAgICAvLyBhY3RpdmF0ZSB0aGUgaXRlbVxuICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZS5hY3RpdmF0ZShkYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhciBib3RoIHN0YXJ0IGFuZCBlbmQgc2VsZWN0aW9uIHBvaW50c1xuICAgKi9cbiAgcHJvdGVjdGVkIGNsZWFyU2VsZWN0aW9uKGRlYWN0aXZhdGU6IGJvb2xlYW4gPSB0cnVlKTogdm9pZCB7XG5cbiAgICAvLyByZXNldCB0aGUgc2VsZWN0ZWQgaXRlbVxuICAgIHRoaXMuX3NlbGVjdGlvbiA9IHsgc3RhcnQ6IG51bGwsIGVuZDogbnVsbCB9O1xuXG4gICAgLy8gcmVtb3ZlIHRoZSBjdXJyZW50IGFjdGl2ZSBpdGVtXG4gICAgaWYgKGRlYWN0aXZhdGUpIHtcbiAgICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZS5kZWFjdGl2YXRlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZSBhbGwgdGhlIGl0ZW1zIGFmZmVjdGVkIGJ5IHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAgICogTm90ZSB0aGF0IHRoZSBlbmQgcG9pbnQgbWF5IGJlIGFib3ZlIHRoZSBzdGFydCBwb2ludCBzb1xuICAgKiB3ZSBuZWVkIHRvIGFjY291bnQgZm9yIHRoaXMuXG4gICAqL1xuICBwcml2YXRlIGdldFNlbGVjdGVkSXRlbXMoKTogYW55W10ge1xuXG4gICAgLy8gZ2V0IHRoZSBsYXRlc3QgZGF0YXNldFxuICAgIGNvbnN0IHsgZGF0YXNldCB9ID0gdGhpcy5zZWxlY3Rpb25TZXJ2aWNlO1xuXG4gICAgLy8gZ2V0IHRoZSBpbmRleGVzIG9mIHRoZSBzdGFydCBhbmQgZW5kIHBvaW50XG4gICAgY29uc3Qgc3RhcnRJZHggPSBkYXRhc2V0LmluZGV4T2YodGhpcy5fc2VsZWN0aW9uLnN0YXJ0KTtcbiAgICBjb25zdCBlbmRJZHggPSBkYXRhc2V0LmluZGV4T2YodGhpcy5fc2VsZWN0aW9uLmVuZCk7XG5cbiAgICAvLyBnZXQgdGhlIHJlZ2lvbiBvZiB0aGUgYXJyYXkgdGhhdCBpcyBzZWxlY3RlZCAtIG5vdGUgdGhlIGVuZElkeCBtYXkgYmUgYmVmb3JlIHRoZSBzdGFydElkeCBzbyBhY2NvdW50IGZvciB0aGlzXG4gICAgcmV0dXJuIGRhdGFzZXQuc2xpY2UoTWF0aC5taW4oc3RhcnRJZHgsIGVuZElkeCksIE1hdGgubWF4KHN0YXJ0SWR4LCBlbmRJZHgpICsgMSk7XG4gIH1cblxuICAvKipcbiAgICogQWN0aXZhdGUgdGhlIHNpYmxpbmcgaXRlbSB3aGVuIGFycm93IGtleXMgYXJlIHByZXNzZWRcbiAgICovXG4gIHByaXZhdGUgbmF2aWdhdGUoZXZlbnQ6IEtleWJvYXJkRXZlbnQsIGRhdGE6IGFueSk6IHZvaWQge1xuXG4gICAgLy8gZGV0ZXJtaW5lIHdoaWNoIG1vZGlmaWVyIGtleXMgYXJlIHByZXNzZWRcbiAgICBjb25zdCB7IGN0cmxLZXksIHNoaWZ0S2V5IH0gPSBldmVudDtcblxuICAgIC8vIGlmIG5vIG1vZGlmaWVyIGtleXMgYXJlIHByZXNzZWQgdGhlbiBkZXNlbGVjdCBhbGwgYW5kIGNsZWFyIHRoZSBzZWxlY3Rpb25cbiAgICBpZiAoIWN0cmxLZXkgJiYgIXNoaWZ0S2V5KSB7XG4gICAgICB0aGlzLmRlc2VsZWN0QWxsKCk7XG4gICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKGZhbHNlKTtcbiAgICB9XG5cbiAgICAvLyBhY3RpdmF0ZSB0aGUgc2libGluZyAtIGlmIHRoZSB1cCBhcnJvdyBpcyBwcmVzc2VkIHRoZW4gbmF2aWdhdGUgdG8gdGhlIHByZXZpb3VzIHNpYmxpbmdcbiAgICBjb25zdCBzaWJsaW5nID0gdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmFjdGl2YXRlU2libGluZyhldmVudC5rZXlDb2RlID09PSBLZXlDb2RlLlVwQXJyb3cpO1xuXG4gICAgLy8gaWYgdGhlIHNoaWZ0IGtleSBpcyBwcmVzc2VkIHRoZW4gd2UgYWxzbyB3YW50IHRvIHRvZ2dsZSB0aGUgc3RhdGUgaWYgdGhlIGl0ZW1cbiAgICBpZiAoc2hpZnRLZXkgJiYgc2libGluZykge1xuXG4gICAgICAvLyBpZiB0aGVyZSBpcyBubyBjdXJyZW50IHNlbGVjdGlvbiBzdGFydCB0aGVuIHNlbGVjdCB0aGUgY3VycmVudCByb3dcbiAgICAgIGlmICghdGhpcy5fc2VsZWN0aW9uLnN0YXJ0KSB7XG4gICAgICAgIHRoaXMubXVsdGlwbGVTZWxlY3QoZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubXVsdGlwbGVTZWxlY3Qoc2libGluZyk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VsZWN0aW9uIHtcbiAgc3RhcnQ6IGFueTtcbiAgZW5kOiBhbnk7XG59XG4iLCJpbXBvcnQgeyBLZXlDb2RlIH0gZnJvbSAnLi9rZXljb2RlLmVudW0nO1xyXG5pbXBvcnQgeyBSb3dTZWxlY3Rpb25TdHJhdGVneSB9IGZyb20gJy4vcm93LXNlbGVjdGlvbi5zdHJhdGVneSc7XHJcblxyXG5leHBvcnQgY2xhc3MgUm93QWx0U2VsZWN0aW9uU3RyYXRlZ3kgZXh0ZW5kcyBSb3dTZWxlY3Rpb25TdHJhdGVneSB7XHJcbiAgICBrZXlkb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50LCBkYXRhOiBhbnkpOiB2b2lkIHtcclxuICAgICAgICBzd2l0Y2ggKGV2ZW50LmtleUNvZGUpIHtcclxuICAgICAgICAgICAgY2FzZSBLZXlDb2RlLlVwQXJyb3c6XHJcbiAgICAgICAgICAgIGNhc2UgS2V5Q29kZS5Eb3duQXJyb3c6XHJcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVDdXJzb3JLZXkoZXZlbnQsIGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlIEtleUNvZGUuU3BhY2ViYXI6XHJcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLnN0cmF0ZWd5LnRvZ2dsZShkYXRhKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNlbGVjdCB0aGUgc2libGluZyBpdGVtIHdoZW4gYXJyb3cga2V5cyBhcmUgcHJlc3NlZFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGhhbmRsZUN1cnNvcktleShldmVudDogS2V5Ym9hcmRFdmVudCwgZGF0YTogYW55KTogdm9pZCB7XHJcbiAgICAgICAgLy8gZGV0ZXJtaW5lIHdoaWNoIG1vZGlmaWVyIGtleXMgYXJlIHByZXNzZWRcclxuICAgICAgICBjb25zdCB7IGN0cmxLZXksIHNoaWZ0S2V5IH0gPSBldmVudDtcclxuXHJcbiAgICAgICAgLy8gaWYgbm8gbW9kaWZpZXIga2V5cyBhcmUgcHJlc3NlZCB0aGVuIGRlc2VsZWN0IGFsbCBhbmQgY2xlYXIgdGhlIHNlbGVjdGlvblxyXG4gICAgICAgIGlmICghY3RybEtleSAmJiAhc2hpZnRLZXkpIHtcclxuICAgICAgICAgICAgdGhpcy5kZXNlbGVjdEFsbCgpO1xyXG4gICAgICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKGZhbHNlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChjdHJsS2V5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZS5hY3RpdmF0ZVNpYmxpbmcoZXZlbnQua2V5Q29kZSA9PT0gS2V5Q29kZS5VcEFycm93KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBzaWJsaW5nID0gdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmdldFNpYmxpbmcoZXZlbnQua2V5Q29kZSA9PT0gS2V5Q29kZS5VcEFycm93KTtcclxuICAgICAgICAgICAgdGhpcy5tdWx0aXBsZVNlbGVjdChzaWJsaW5nID8gc2libGluZyA6IGRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBLZXlDb2RlIH0gZnJvbSAnLi9rZXljb2RlLmVudW0nO1xuaW1wb3J0IHsgU2VsZWN0aW9uU3RyYXRlZ3kgfSBmcm9tICcuL3NlbGVjdGlvbi5zdHJhdGVneSc7XG5cbmV4cG9ydCBjbGFzcyBTaW1wbGVTZWxlY3Rpb25TdHJhdGVneSBleHRlbmRzIFNlbGVjdGlvblN0cmF0ZWd5IHtcblxuICAvKipcbiAgICogV2hlbiB0aGUgaXRlbSBpcyBjbGlja2VkIHNpbXBseSB0b2dnbGUgdGhlIGN1cnJlbnQgc2VsZWN0ZWQgc3RhdGVcbiAgICovXG4gIGNsaWNrKGV2ZW50OiBNb3VzZUV2ZW50LCBkYXRhOiBhbnkpOiB2b2lkIHtcbiAgICB0aGlzLnRvZ2dsZShkYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYmFzaWMga2V5Ym9hcmQgc3VwcG9ydCBmb3IgbmF2aWdhdGluZ1xuICAgKiBhbmQgc2VsZWN0aW5nL2Rlc2VsZWN0aW5nIGl0ZW1zXG4gICAqL1xuICBrZXlkb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50LCBkYXRhOiBhbnkpOiB2b2lkIHtcblxuICAgIHN3aXRjaCAoZXZlbnQua2V5Q29kZSkge1xuXG4gICAgICBjYXNlIEtleUNvZGUuVXBBcnJvdzpcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uU2VydmljZS5hY3RpdmF0ZVNpYmxpbmcodHJ1ZSk7XG5cbiAgICAgIGNhc2UgS2V5Q29kZS5Eb3duQXJyb3c6XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvblNlcnZpY2UuYWN0aXZhdGVTaWJsaW5nKGZhbHNlKTtcblxuICAgICAgY2FzZSBLZXlDb2RlLlNwYWNlYmFyOlxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gdGhpcy50b2dnbGUoZGF0YSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIHRoZSBzdGFuZGFyZCB0b2dnbGUgZnVuY3Rpb24gdG8gYWx3YXlzIGFjdGl2YXRlIHRoZSBpdGVtXG4gICAqL1xuICB0b2dnbGUoZGF0YTogYW55KTogdm9pZCB7XG4gICAgc3VwZXIudG9nZ2xlKGRhdGEpO1xuICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZS5hY3RpdmF0ZShkYXRhKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSwgT25EZXN0cm95IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QgfSBmcm9tICdyeGpzL0JlaGF2aW9yU3ViamVjdCc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcy9PYnNlcnZhYmxlJztcbmltcG9ydCB7IGRpc3RpbmN0VW50aWxDaGFuZ2VkLCBtYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBSb3dBbHRTZWxlY3Rpb25TdHJhdGVneSB9IGZyb20gJy4vc3RyYXRlZ2llcy9yb3ctYWx0LXNlbGVjdGlvbi5zdHJhdGVneSc7XG5pbXBvcnQgeyBSb3dTZWxlY3Rpb25TdHJhdGVneSB9IGZyb20gJy4vc3RyYXRlZ2llcy9yb3ctc2VsZWN0aW9uLnN0cmF0ZWd5JztcbmltcG9ydCB7IFNlbGVjdGlvblN0cmF0ZWd5IH0gZnJvbSAnLi9zdHJhdGVnaWVzL3NlbGVjdGlvbi5zdHJhdGVneSc7XG5pbXBvcnQgeyBTaW1wbGVTZWxlY3Rpb25TdHJhdGVneSB9IGZyb20gJy4vc3RyYXRlZ2llcy9zaW1wbGUtc2VsZWN0aW9uLnN0cmF0ZWd5JztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFNlbGVjdGlvblNlcnZpY2UgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuXG4gIHByaXZhdGUgX3NlbGVjdGlvbiA9IG5ldyBTZXQoKTtcbiAgcHJpdmF0ZSBfc3RyYXRlZ3lUb0Rlc3Ryb3k6IFNlbGVjdGlvblN0cmF0ZWd5O1xuXG4gIGRhdGFzZXQ6IGFueVtdID0gW107XG4gIGVuYWJsZWQ6IGJvb2xlYW4gPSB0cnVlO1xuICBjbGlja0VuYWJsZWQ6IGJvb2xlYW4gPSB0cnVlO1xuICBrZXlib2FyZEVuYWJsZWQ6IGJvb2xlYW4gPSB0cnVlO1xuICBzdHJhdGVneTogU2VsZWN0aW9uU3RyYXRlZ3kgPSBuZXcgU2ltcGxlU2VsZWN0aW9uU3RyYXRlZ3kodGhpcyk7XG5cbiAgYWN0aXZlJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8YW55PihudWxsKTtcbiAgZm9jdXNUYXJnZXQkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxhbnk+KG51bGwpO1xuICBzZWxlY3Rpb24kID0gbmV3IEJlaGF2aW9yU3ViamVjdDxhbnlbXT4oW10pO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX3N0cmF0ZWd5VG9EZXN0cm95ID0gdGhpcy5zdHJhdGVneTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgIGlmICh0aGlzLl9zdHJhdGVneVRvRGVzdHJveSkge1xuICAgICAgdGhpcy5fc3RyYXRlZ3lUb0Rlc3Ryb3kuZGVzdHJveSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJZiB0aGUgaXRlbSBpcyBub3QgY3VycmVudGx5IHNlbGVjdGVkIHRoZW4gYWRkIGl0XG4gICAqIHRvIHRoZSBsaXN0IG9mIHNlbGVjdGVkIGl0ZW1zXG4gICAqL1xuICBzZWxlY3QoLi4uc2VsZWN0aW9uczogYW55W10pOiB2b2lkIHtcblxuICAgIC8vIGFkZCBlYWNoIHNlbGVjdGlvbiB0byB0aGUgc2V0XG4gICAgc2VsZWN0aW9ucy5mb3JFYWNoKHNlbGVjdGlvbiA9PiB0aGlzLl9zZWxlY3Rpb24uYWRkKHNlbGVjdGlvbikpO1xuXG4gICAgLy8gcHJvcGFnYXRlIHRoZSBjaGFuZ2VzXG4gICAgdGhpcy5zZWxlY3Rpb25IYXNNdXRhdGVkKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFuIGl0ZW0gZnJvbSB0aGUgbGlzdCBvZiBzZWxlY3RlZCBpdGVtc1xuICAgKi9cbiAgZGVzZWxlY3QoLi4uc2VsZWN0aW9uczogYW55W10pOiB2b2lkIHtcbiAgICAvLyByZW1vdmUgZWFjaCBpdGVtIGZyb20gdGhlIHNldFxuICAgIHNlbGVjdGlvbnMuZm9yRWFjaChzZWxlY3Rpb24gPT4gdGhpcy5fc2VsZWN0aW9uLmRlbGV0ZShzZWxlY3Rpb24pKTtcblxuICAgIC8vIHByb3BhZ2F0ZSB0aGUgY2hhbmdlc1xuICAgIHRoaXMuc2VsZWN0aW9uSGFzTXV0YXRlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRvZ2dsZSB0aGUgc2VsZWN0ZWQgc3RhdGUgb2YgYW55IHNwZWNpZmllZCBpdGVtc1xuICAgKi9cbiAgdG9nZ2xlKC4uLnNlbGVjdGlvbnM6IGFueVtdKTogdm9pZCB7XG4gICAgc2VsZWN0aW9ucy5mb3JFYWNoKHNlbGVjdGlvbiA9PiB0aGlzLmlzU2VsZWN0ZWQoc2VsZWN0aW9uKSA/IHRoaXMuZGVzZWxlY3Qoc2VsZWN0aW9uKSA6IHRoaXMuc2VsZWN0KHNlbGVjdGlvbikpO1xuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZSB3aGV0aGVyIG9yIG5vdCBhIHNwZWNpZmljIGl0ZW0gaXMgY3VycmVudGx5IHNlbGVjdGVkXG4gICAqL1xuICBpc1NlbGVjdGVkKGRhdGE6IGFueSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9zZWxlY3Rpb24uaGFzKGRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBvYnNlcnZhYmxlIHNwZWNpZmljYWxseSBmb3Igbm90aWZ5aW5nIHRoZSBzdWJzY3JpYmVyXG4gICAqIG9ubHkgd2hlbiB0aGUgc2VsZWN0aW9uIHN0YXRlIG9mIGEgc3BlY2lmaWMgb2JqZWN0IGhhcyBjaGFuZ2VkXG4gICAqL1xuICBzZWxlY3RlZCQoZGF0YTogYW55KTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uJC5waXBlKG1hcCgoKSA9PiB0aGlzLmlzU2VsZWN0ZWQoZGF0YSkpLCBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmUgaG93IHNlbGVjdGlvbnMgc2hvdWxkIGJlIHBlcmZvcm1lZC5cbiAgICogVGhpcyBhbGxvd3MgdXMgdG8gdXNlIGFuIHN0cmF0ZWd5IHBhdHRlcm4gdG8gaGFuZGxlIHRoZSB2YXJpb3VzIGtleWJvYXJkXG4gICAqIGFuZCBtb3VzZSBpbnRlcmFjdGlvbnMgd2hpbGUga2VlcGluZyBlYWNoIG1vZGUgc2VwYXJhdGVkIGFuZFxuICAgKiBlYXNpbHkgZXh0ZW5zaWJsZSBpZiB3ZSB3YW50IHRvIGFkZCBtb3JlIG1vZGVzIGluIGZ1dHVyZSFcbiAgICovXG4gIHNldE1vZGUobW9kZTogU2VsZWN0aW9uTW9kZSB8IFNlbGVjdGlvblN0cmF0ZWd5KTogdm9pZCB7XG5cbiAgICBpZiAodGhpcy5fc3RyYXRlZ3lUb0Rlc3Ryb3kpIHtcbiAgICAgIC8vIERlc3Ryb3kgcHJldmlvdXMgc3RyYXRlZ3kgaWYgaXQgd2FzIGNyZWF0ZWQgaW50ZXJuYWxseVxuICAgICAgdGhpcy5fc3RyYXRlZ3lUb0Rlc3Ryb3kuZGVzdHJveSgpO1xuICAgICAgdGhpcy5fc3RyYXRlZ3lUb0Rlc3Ryb3kgPSBudWxsO1xuICAgIH1cblxuICAgIGlmIChtb2RlIGluc3RhbmNlb2YgU2VsZWN0aW9uU3RyYXRlZ3kpIHtcblxuICAgICAgLy8gQ3VzdG9tIHN0cmF0ZWd5IC0gcGFzcyBpbiB0aGUgc2VydmljZSBpbnN0YW5jZVxuICAgICAgdGhpcy5zdHJhdGVneSA9IG1vZGU7XG4gICAgICB0aGlzLnN0cmF0ZWd5LnNldFNlbGVjdGlvblNlcnZpY2UodGhpcyk7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICBzd2l0Y2ggKG1vZGUudG9Mb3dlckNhc2UoKS50cmltKCkpIHtcblxuICAgICAgICBjYXNlICdzaW1wbGUnOlxuICAgICAgICAgIHRoaXMuc3RyYXRlZ3kgPSB0aGlzLl9zdHJhdGVneVRvRGVzdHJveSA9IG5ldyBTaW1wbGVTZWxlY3Rpb25TdHJhdGVneSh0aGlzKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdyb3cnOlxuICAgICAgICAgIHRoaXMuc3RyYXRlZ3kgPSB0aGlzLl9zdHJhdGVneVRvRGVzdHJveSA9IG5ldyBSb3dTZWxlY3Rpb25TdHJhdGVneSh0aGlzKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdyb3ctYWx0JzpcbiAgICAgICAgICB0aGlzLnN0cmF0ZWd5ID0gdGhpcy5fc3RyYXRlZ3lUb0Rlc3Ryb3kgPSBuZXcgUm93QWx0U2VsZWN0aW9uU3RyYXRlZ3kodGhpcyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBzZWxlY3Rpb24gbW9kZSAnJHttb2RlfScgZG9lcyBub3QgZXhpc3QuIFZhbGlkIG1vZGVzIGFyZSAnc2ltcGxlJywgJ3JvdycsIG9yICdyb3ctYWx0Jy5gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBjdXJyZW50IGFjdGl2ZSBpdGVtXG4gICAqL1xuICBhY3RpdmF0ZShkYXRhOiBhbnkpOiB2b2lkIHtcbiAgICB0aGlzLmFjdGl2ZSQubmV4dChkYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWFjdGl2ZSBhbGwgaXRlbXNcbiAgICovXG4gIGRlYWN0aXZhdGUoKTogdm9pZCB7XG4gICAgdGhpcy5hY3RpdmUkLm5leHQobnVsbCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBuZXh0IG9yIHByZXZpb3VzIHNpYmxpbmcgb2YgdGhlIGN1cnJlbnQgYWN0aXZlIGl0ZW0uXG4gICAqIEBwYXJhbSBwcmV2aW91cyBJZiB0cnVlLCB0aGUgcHJldmlvdXMgc2libGluZyB3aWxsIGJlIHJldHVybmVkLlxuICAgKi9cbiAgZ2V0U2libGluZyhwcmV2aW91czogYm9vbGVhbiA9IGZhbHNlKTogYW55IHtcblxuICAgIC8vIGdldCB0aGUgY3VycmVudGx5IGFjdGl2ZSBpdGVtXG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuYWN0aXZlJC5nZXRWYWx1ZSgpO1xuXG4gICAgLy8gY2hlY2sgaWYgdGhlcmUgaXMgYSBjdXJyZW50IGFjdGl2ZSBpdGVtXG4gICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgY3VycmVudCBpdGVtXG4gICAgY29uc3QgaWR4ID0gdGhpcy5kYXRhc2V0LmluZGV4T2YoY3VycmVudCk7XG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5kYXRhc2V0W3ByZXZpb3VzID8gaWR4IC0gMSA6IGlkeCArIDFdO1xuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY3RpdmF0ZSB0aGUgc2libGluZyBvZiB0aGUgY3VycmVudCBhY3RpdmUgaXRlbS5cbiAgICogSWYgcHJldmlvdXMgaXMgc2V0IHRvIHRydWUgdGhlIHByZXZpb3VzIHNpYmxpbmcgd2lsbCBiZSBhY3RpdmF0ZWRcbiAgICogcmF0aGVyIHRoYW4gdGhlIG5leHQgc2libGluZy4gVGhpcyBmdW5jdGlvbiB3aWxsIGFsc28gcmV0dXJuIHRoZVxuICAgKiBkYXRhIG9mIHRoZSBuZXdseSBhY3RpdmF0ZWQgc2libGluZ1xuICAgKi9cbiAgYWN0aXZhdGVTaWJsaW5nKHByZXZpb3VzOiBib29sZWFuID0gZmFsc2UpOiBhbnkge1xuXG4gICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5nZXRTaWJsaW5nKHByZXZpb3VzKTtcblxuICAgIC8vIGNoZWNrIGlmIHRoZSB0YXJnZXQgZXhpc3RzXG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgdGhpcy5hY3RpdmF0ZSh0YXJnZXQpO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICBzZXREaXNhYmxlZChkaXNhYmxlZDogYm9vbGVhbik6IHZvaWQge1xuICAgIC8vIHN0b3JlIHRoZSBjdXJyZW50IGRpc2FibGVkIHN0YXRlXG4gICAgdGhpcy5lbmFibGVkID0gIWRpc2FibGVkO1xuXG4gICAgLy8gY2xlYXIgYW55IHN0YXRlZnVsIGRhdGFcbiAgICB0aGlzLmFjdGl2ZSQubmV4dChudWxsKTtcbiAgICB0aGlzLl9zZWxlY3Rpb24uY2xlYXIoKTtcblxuICAgIC8vIGVtaXQgdGhlIHNlbGVjdGlvbiBjaGFuZ2UgaW5mb3JtYXRpb25cbiAgICB0aGlzLnNlbGVjdGlvbkhhc011dGF0ZWQoKTtcbiAgfVxuXG4gIHByaXZhdGUgc2VsZWN0aW9uSGFzTXV0YXRlZCgpOiB2b2lkIHtcbiAgICB0aGlzLnNlbGVjdGlvbiQubmV4dChBcnJheS5mcm9tKHRoaXMuX3NlbGVjdGlvbikpO1xuICB9XG59XG5cbmV4cG9ydCB0eXBlIFNlbGVjdGlvbk1vZGUgPSAnc2ltcGxlJyB8ICdyb3cnIHwgJ3Jvdy1hbHQnO1xuIiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIEhvc3RCaW5kaW5nLCBIb3N0TGlzdGVuZXIsIElucHV0LCBPbkRlc3Ryb3ksIE9uSW5pdCwgT3V0cHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IG1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcy9TdWJzY3JpcHRpb24nO1xyXG5pbXBvcnQgeyBTZWxlY3Rpb25TZXJ2aWNlIH0gZnJvbSAnLi9zZWxlY3Rpb24uc2VydmljZSc7XHJcblxyXG5ARGlyZWN0aXZlKHtcclxuICBzZWxlY3RvcjogJ1t1eFNlbGVjdGlvbkl0ZW1dJyxcclxuICBleHBvcnRBczogJ3V4LXNlbGVjdGlvbi1pdGVtJ1xyXG59KVxyXG5leHBvcnQgY2xhc3MgU2VsZWN0aW9uSXRlbURpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcclxuXHJcbiAgQElucHV0KCkgdXhTZWxlY3Rpb25JdGVtOiBhbnk7XHJcblxyXG4gIEBJbnB1dCgpIEBIb3N0QmluZGluZygnY2xhc3MudXgtc2VsZWN0aW9uLXNlbGVjdGVkJylcclxuICBzZXQgc2VsZWN0ZWQoc2VsZWN0ZWQ6IGJvb2xlYW4pIHtcclxuICAgIHNlbGVjdGVkID8gdGhpcy5zZWxlY3QoKSA6IHRoaXMuZGVzZWxlY3QoKTtcclxuICB9XHJcblxyXG4gIGdldCBzZWxlY3RlZCgpOiBib29sZWFuIHtcclxuICAgIHJldHVybiB0aGlzLl9zZWxlY3RlZDtcclxuICB9XHJcblxyXG4gIEBJbnB1dCgpIHRhYmluZGV4OiBudW1iZXIgPSBudWxsO1xyXG5cclxuICBAT3V0cHV0KCkgc2VsZWN0ZWRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XHJcblxyXG4gIEBIb3N0QmluZGluZygnY2xhc3MudXgtc2VsZWN0aW9uLWZvY3VzZWQnKSBhY3RpdmU6IGJvb2xlYW4gPSBmYWxzZTtcclxuXHJcbiAgQEhvc3RCaW5kaW5nKCdhdHRyLnRhYmluZGV4JylcclxuICBnZXQgYXR0clRhYkluZGV4KCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gKHRoaXMudGFiaW5kZXggIT09IG51bGwpID8gdGhpcy50YWJpbmRleCA6IHRoaXMuX21hbmFnZWRUYWJJbmRleDtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgX3NlbGVjdGVkOiBib29sZWFuID0gZmFsc2U7XHJcbiAgcHJpdmF0ZSBfbWFuYWdlZFRhYkluZGV4OiBudW1iZXIgPSAtMTtcclxuICBwcml2YXRlIF9zdWJzY3JpcHRpb25zID0gbmV3IFN1YnNjcmlwdGlvbigpO1xyXG5cclxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9zZWxlY3Rpb25TZXJ2aWNlOiBTZWxlY3Rpb25TZXJ2aWNlLCBwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmKSB7IH1cclxuXHJcbiAgbmdPbkluaXQoKTogdm9pZCB7XHJcblxyXG4gICAgLy8gaWYgdGhlcmUgaXMgbm8gYXNzb2NpYXRlZCBkYXRhIHRoZW4gdGhyb3cgYW4gZXJyb3JcclxuICAgIGlmICghdGhpcy51eFNlbGVjdGlvbkl0ZW0pIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgdXhTZWxlY3Rpb25JdGVtIGRpcmVjdGl2ZSBtdXN0IGhhdmUgZGF0YSBhc3NvY2lhdGVkIHdpdGggaXQuJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gc3Vic2NyaWJlIHRvIHNlbGVjdGlvbiBjaGFuZ2VzIG9uIHRoaXMgaXRlbVxyXG4gICAgdGhpcy5fc3Vic2NyaXB0aW9ucy5hZGQodGhpcy5fc2VsZWN0aW9uU2VydmljZS5zZWxlY3RlZCQodGhpcy51eFNlbGVjdGlvbkl0ZW0pLnN1YnNjcmliZShzZWxlY3RlZCA9PiB7XHJcblxyXG4gICAgICAvLyBzdG9yZSB0aGUgc2VsZWN0ZWQgc3RhdGVcclxuICAgICAgdGhpcy5fc2VsZWN0ZWQgPSBzZWxlY3RlZDtcclxuXHJcbiAgICAgIC8vIGVtaXQgdGhlIHNlbGVjdGVkIHN0YXRlXHJcbiAgICAgIHRoaXMuc2VsZWN0ZWRDaGFuZ2UuZW1pdChzZWxlY3RlZCk7XHJcbiAgICB9KSk7XHJcblxyXG4gICAgLy8gc3Vic2NyaWJlIHRvIGNoYW5nZXMgdG8gdGhlIGFjdGl2ZSBzdGF0ZVxyXG4gICAgdGhpcy5fc3Vic2NyaXB0aW9ucy5hZGQodGhpcy5fc2VsZWN0aW9uU2VydmljZS5hY3RpdmUkLnBpcGUobWFwKGFjdGl2ZSA9PiBhY3RpdmUgPT09IHRoaXMudXhTZWxlY3Rpb25JdGVtKSkuc3Vic2NyaWJlKGFjdGl2ZSA9PiB7XHJcblxyXG4gICAgICAvLyBzdG9yZSB0aGUgZm9jdXMgc3RhdGVcclxuICAgICAgdGhpcy5hY3RpdmUgPSBhY3RpdmU7XHJcblxyXG4gICAgICAvLyBpZiBpdCBpcyBhY3RpdmUgdGhlbiBmb2N1cyB0aGUgZWxlbWVudFxyXG4gICAgICBpZiAoYWN0aXZlID09PSB0cnVlKSB7XHJcbiAgICAgICAgdGhpcy5fc2VsZWN0aW9uU2VydmljZS5mb2N1c1RhcmdldCQubmV4dCh0aGlzLnV4U2VsZWN0aW9uSXRlbSk7XHJcbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XHJcbiAgICAgIH1cclxuICAgIH0pKTtcclxuXHJcbiAgICAvLyBTdWJzY3JpYmUgdG8gY2hhbmdlcyB0byB0aGUgZm9jdXMgdGFyZ2V0XHJcbiAgICAvLyBUaGlzIGlzIG1vc3RseSB0aGUgc2FtZSBhcyBhY3RpdmUkLCBleGNlcHQgdGhhdCBpdCBoYXMgYW4gaW5pdGlhbCB2YWx1ZSBvZiB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgY29sbGVjdGlvbi5cclxuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMuYWRkKHRoaXMuX3NlbGVjdGlvblNlcnZpY2UuZm9jdXNUYXJnZXQkLnN1YnNjcmliZShmb2N1c1RhcmdldCA9PiB7XHJcbiAgICAgIHRoaXMuX21hbmFnZWRUYWJJbmRleCA9IChmb2N1c1RhcmdldCA9PT0gdGhpcy51eFNlbGVjdGlvbkl0ZW0pID8gMCA6IC0xO1xyXG4gICAgfSkpO1xyXG4gIH1cclxuXHJcbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XHJcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25zLnVuc3Vic2NyaWJlKCk7XHJcbiAgfVxyXG5cclxuICBASG9zdExpc3RlbmVyKCdjbGljaycsIFsnJGV2ZW50J10pIGNsaWNrKGV2ZW50OiBNb3VzZUV2ZW50KTogdm9pZCB7XHJcbiAgICBpZiAodGhpcy5fc2VsZWN0aW9uU2VydmljZS5lbmFibGVkICYmIHRoaXMuX3NlbGVjdGlvblNlcnZpY2UuY2xpY2tFbmFibGVkKSB7XHJcbiAgICAgIHRoaXMuX3NlbGVjdGlvblNlcnZpY2Uuc3RyYXRlZ3kuY2xpY2soZXZlbnQsIHRoaXMudXhTZWxlY3Rpb25JdGVtKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIEBIb3N0TGlzdGVuZXIoJ21vdXNlZG93bicsIFsnJGV2ZW50J10pIG1vdXNlZG93bihldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xyXG4gICAgaWYgKHRoaXMuX3NlbGVjdGlvblNlcnZpY2UuZW5hYmxlZCAmJiB0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlLmNsaWNrRW5hYmxlZCkge1xyXG4gICAgICB0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlLnN0cmF0ZWd5Lm1vdXNlZG93bihldmVudCwgdGhpcy51eFNlbGVjdGlvbkl0ZW0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgQEhvc3RMaXN0ZW5lcigna2V5ZG93bicsIFsnJGV2ZW50J10pIGtleWRvd24oZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlLmVuYWJsZWQgJiYgdGhpcy5fc2VsZWN0aW9uU2VydmljZS5rZXlib2FyZEVuYWJsZWQpIHtcclxuICAgICAgdGhpcy5fc2VsZWN0aW9uU2VydmljZS5zdHJhdGVneS5rZXlkb3duKGV2ZW50LCB0aGlzLnV4U2VsZWN0aW9uSXRlbSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBASG9zdExpc3RlbmVyKCdmb2N1cycpIGZvY3VzKCk6IHZvaWQge1xyXG4gICAgLy8gSWYgdGFiYmVkIHRvIGZyb20gb3V0c2lkZSB0aGUgY29tcG9uZW50LCBhY3RpdmF0ZS5cclxuICAgIGlmICh0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlLmFjdGl2ZSQuZ2V0VmFsdWUoKSAhPT0gdGhpcy51eFNlbGVjdGlvbkl0ZW0pIHtcclxuICAgICAgdGhpcy5fc2VsZWN0aW9uU2VydmljZS5hY3RpdmF0ZSh0aGlzLnV4U2VsZWN0aW9uSXRlbSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZWxlY3QgdGhpcyBpdGVtIHVzaW5nIHRoZSBjdXJyZW50IHN0cmF0ZWd5XHJcbiAgICovXHJcbiAgc2VsZWN0KCk6IHZvaWQge1xyXG4gICAgaWYgKHRoaXMuX3NlbGVjdGlvblNlcnZpY2UuZW5hYmxlZCkge1xyXG4gICAgICB0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlLnN0cmF0ZWd5LnNlbGVjdCh0aGlzLnV4U2VsZWN0aW9uSXRlbSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXNlbGVjdCB0aGlzIGl0ZW0gdXNpbmcgdGhlIGN1cnJlbnQgc3RyYXRlZ3lcclxuICAgKi9cclxuICBkZXNlbGVjdCgpOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlLmVuYWJsZWQpIHtcclxuICAgICAgdGhpcy5fc2VsZWN0aW9uU2VydmljZS5zdHJhdGVneS5kZXNlbGVjdCh0aGlzLnV4U2VsZWN0aW9uSXRlbSk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCB7IEFmdGVyQ29udGVudEluaXQsIENoYW5nZURldGVjdG9yUmVmLCBDb250ZW50Q2hpbGRyZW4sIERpcmVjdGl2ZSwgRXZlbnRFbWl0dGVyLCBIb3N0QmluZGluZywgSW5wdXQsIE9uRGVzdHJveSwgT3V0cHV0LCBRdWVyeUxpc3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IFNlbGVjdGlvbkl0ZW1EaXJlY3RpdmUgfSBmcm9tICcuL3NlbGVjdGlvbi1pdGVtLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBTZWxlY3Rpb25Nb2RlLCBTZWxlY3Rpb25TZXJ2aWNlIH0gZnJvbSAnLi9zZWxlY3Rpb24uc2VydmljZSc7XG5pbXBvcnQgeyBTZWxlY3Rpb25TdHJhdGVneSB9IGZyb20gJy4vc3RyYXRlZ2llcy9zZWxlY3Rpb24uc3RyYXRlZ3knO1xuXG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1t1eFNlbGVjdGlvbl0nLFxuICBleHBvcnRBczogJ3V4LXNlbGVjdGlvbicsXG4gIHByb3ZpZGVyczogWyBTZWxlY3Rpb25TZXJ2aWNlIF1cbn0pXG5leHBvcnQgY2xhc3MgU2VsZWN0aW9uRGlyZWN0aXZlIGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdCwgT25EZXN0cm95IHtcblxuICBASW5wdXQoKSBzZXQgdXhTZWxlY3Rpb24oaXRlbXM6IGFueVtdKSB7XG4gICAgdGhpcy5fc2VsZWN0aW9uU2VydmljZS5zZWxlY3QoLi4uaXRlbXMpO1xuICB9XG5cbiAgQElucHV0KCkgc2V0IGRpc2FibGVkKGRpc2FibGVkOiBib29sZWFuKSB7XG4gICAgdGhpcy5fc2VsZWN0aW9uU2VydmljZS5zZXREaXNhYmxlZChkaXNhYmxlZCk7XG4gIH1cblxuICBASW5wdXQoKSBzZXQgbW9kZShtb2RlOiBTZWxlY3Rpb25Nb2RlIHwgU2VsZWN0aW9uU3RyYXRlZ3kpIHtcbiAgICB0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlLnNldE1vZGUobW9kZSk7XG4gIH1cblxuICBASW5wdXQoKSBzZXQgY2xpY2tTZWxlY3Rpb24oZW5hYmxlZDogYm9vbGVhbikge1xuICAgIHRoaXMuX3NlbGVjdGlvblNlcnZpY2UuY2xpY2tFbmFibGVkID0gZW5hYmxlZDtcbiAgfVxuXG4gIEBJbnB1dCgpIHNldCBrZXlib2FyZFNlbGVjdGlvbihlbmFibGVkOiBib29sZWFuKSB7XG4gICAgdGhpcy5fc2VsZWN0aW9uU2VydmljZS5rZXlib2FyZEVuYWJsZWQgPSBlbmFibGVkO1xuICB9XG5cbiAgQElucHV0KCkgQEhvc3RCaW5kaW5nKCdhdHRyLnRhYmluZGV4JykgdGFiaW5kZXg6IG51bWJlciA9IG51bGw7XG5cbiAgQE91dHB1dCgpIHV4U2VsZWN0aW9uQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxhbnlbXT4oKTtcblxuICBAQ29udGVudENoaWxkcmVuKFNlbGVjdGlvbkl0ZW1EaXJlY3RpdmUpIGl0ZW1zOiBRdWVyeUxpc3Q8U2VsZWN0aW9uSXRlbURpcmVjdGl2ZT47XG5cbiAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9ucyA9IG5ldyBTdWJzY3JpcHRpb24oKTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9zZWxlY3Rpb25TZXJ2aWNlOiBTZWxlY3Rpb25TZXJ2aWNlLCBwcml2YXRlIF9jZFJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYpIHtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25zLmFkZChfc2VsZWN0aW9uU2VydmljZS5zZWxlY3Rpb24kLnN1YnNjcmliZShpdGVtcyA9PiB0aGlzLnV4U2VsZWN0aW9uQ2hhbmdlLmVtaXQoaXRlbXMpKSk7XG4gIH1cblxuICBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZCB7XG4gICAgLy8gcHJvdmlkZSB0aGUgaW5pdGlhbCBsaXN0IG9mIHNlbGVjdGlvbiBpdGVtc1xuICAgIHRoaXMudXBkYXRlKCk7XG5cbiAgICAvLyBpZiB0aGUgbGlzdCBjaGFuZ2VzIHRoZW4gaW5mb3JtIHRoZSBzZXJ2aWNlXG4gICAgdGhpcy5fc3Vic2NyaXB0aW9ucy5hZGQodGhpcy5pdGVtcy5jaGFuZ2VzLnN1YnNjcmliZSgoKSA9PiB0aGlzLnVwZGF0ZSgpKSk7XG5cbiAgICAvLyBUaGUgYWJvdmUgY291bGQgdHJpZ2dlciBhIGNoYW5nZSBpbiB0aGUgY29tcHV0ZWQgdGFiaW5kZXggZm9yIHNlbGVjdGlvbiBpdGVtc1xuICAgIHRoaXMuX2NkUmVmLmRldGVjdENoYW5nZXMoKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMudW5zdWJzY3JpYmUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGRhdGFzZXQgdG8gcmVmbGVjdCB0aGUgbGF0ZXN0IHNlbGVjdGlvbiBpdGVtc1xuICAgKi9cbiAgdXBkYXRlKCk6IHZvaWQge1xuXG4gICAgdGhpcy5fc2VsZWN0aW9uU2VydmljZS5kYXRhc2V0ID0gdGhpcy5pdGVtcy5tYXAoaXRlbSA9PiBpdGVtLnV4U2VsZWN0aW9uSXRlbSk7XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhhdCBhIHRhYiB0YXJnZXQgaGFzIGJlZW4gZGVmaW5lZCBzbyB0aGF0IHRoZSBjb21wb25lbnQgY2FuIGJlIHRhYmJlZCB0by5cbiAgICBpZiAodGhpcy5fc2VsZWN0aW9uU2VydmljZS5mb2N1c1RhcmdldCQuZ2V0VmFsdWUoKSA9PT0gbnVsbCAmJiB0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlLmRhdGFzZXQubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5fc2VsZWN0aW9uU2VydmljZS5mb2N1c1RhcmdldCQubmV4dCh0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlLmRhdGFzZXRbMF0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZWxlY3QgYWxsIHRoZSBpdGVtcyBpbiB0aGUgbGlzdFxuICAgKi9cbiAgc2VsZWN0QWxsKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlLmVuYWJsZWQpIHtcbiAgICAgIHRoaXMuX3NlbGVjdGlvblNlcnZpY2Uuc3RyYXRlZ3kuc2VsZWN0QWxsKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlc2VsZWN0IGFsbCBjdXJyZW50bHkgc2VsZWN0ZWQgaXRlbXNcbiAgICovXG4gIGRlc2VsZWN0QWxsKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlLmVuYWJsZWQpIHtcbiAgICAgIHRoaXMuX3NlbGVjdGlvblNlcnZpY2Uuc3RyYXRlZ3kuZGVzZWxlY3RBbGwoKTtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU2VsZWN0aW9uSXRlbURpcmVjdGl2ZSB9IGZyb20gJy4vc2VsZWN0aW9uLWl0ZW0uZGlyZWN0aXZlJztcbmltcG9ydCB7IFNlbGVjdGlvbkRpcmVjdGl2ZSB9IGZyb20gJy4vc2VsZWN0aW9uLmRpcmVjdGl2ZSc7XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtcbiAgICBDb21tb25Nb2R1bGVcbiAgXSxcbiAgZGVjbGFyYXRpb25zOiBbU2VsZWN0aW9uRGlyZWN0aXZlLCBTZWxlY3Rpb25JdGVtRGlyZWN0aXZlXSxcbiAgZXhwb3J0czogW1NlbGVjdGlvbkRpcmVjdGl2ZSwgU2VsZWN0aW9uSXRlbURpcmVjdGl2ZV1cbn0pXG5leHBvcnQgY2xhc3MgU2VsZWN0aW9uTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbmplY3RvciwgSW5wdXQsIE91dHB1dCwgRXZlbnRFbWl0dGVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBVcGdyYWRlQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvdXBncmFkZS9zdGF0aWMnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ2NvbnRhY3QtZ3JvdXAnXG59KVxuZXhwb3J0IGNsYXNzIENvbnRhY3RzTmcxQ29tcG9uZW50IGV4dGVuZHMgVXBncmFkZUNvbXBvbmVudCB7XG5cbiAgICBASW5wdXQoKSBjb250YWN0czogQ29udGFjdFtdO1xuICAgIEBJbnB1dCgpIG9yZ2FuaXphdGlvbjogc3RyaW5nO1xuICAgIEBJbnB1dCgpIHNpemU6ICdtZWRpdW0nIHwgJ3NtYWxsJztcbiAgICBASW5wdXQoKSBjb2xvcnM6IGFueTtcbiAgICBASW5wdXQoKSBtYXhDb250YWN0czogbnVtYmVyO1xuXG4gICAgQE91dHB1dCgpIG92ZXJmbG93Q2xpY2s6IEV2ZW50RW1pdHRlcjx2b2lkPiA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcblxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIGluamVjdG9yOiBJbmplY3Rvcikge1xuICAgICAgICBzdXBlcignY29udGFjdEdyb3VwJywgZWxlbWVudFJlZiwgaW5qZWN0b3IpO1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb250YWN0IHtcbiAgICB0ZXN0OiBzdHJpbmc7XG4gICAgc3RhdHVzOiAnYWN0aXZlJyB8ICdwYXNzaXZlJztcbiAgICBjdXN0b21Ub29sdGlwPzoge1xuICAgICAgICB0ZW1wbGF0ZTogc3RyaW5nLFxuICAgICAgICB0b29sdGlwUG9zaXRpb246IHN0cmluZztcbiAgICAgICAgZGF0YT86IGFueTtcbiAgICB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE9yZ2FuaXphdGlvbiB7XG4gICAgdGV4dDogc3RyaW5nO1xuICAgIGxhYmVsOiAnZXh0ZXJuYWwnIHwgJ3Jpc2snO1xuICAgIHRvb2x0aXA/OiBzdHJpbmc7XG4gICAgY3VzdG9tVG9vbHRpcD86IHtcbiAgICAgICAgdGVtcGxhdGU6IHN0cmluZyxcbiAgICAgICAgdG9vbHRpcFBvc2l0aW9uOiBzdHJpbmc7XG4gICAgICAgIGRhdGE/OiBhbnk7XG4gICAgfTtcbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEluamVjdG9yLCBJbnB1dCwgT3V0cHV0LCBFdmVudEVtaXR0ZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFVwZ3JhZGVDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci91cGdyYWRlL3N0YXRpYyc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnZXhwYW5kLWlucHV0J1xufSlcbmV4cG9ydCBjbGFzcyBFeHBhbmRJbnB1dE5nMUNvbXBvbmVudCBleHRlbmRzIFVwZ3JhZGVDb21wb25lbnQge1xuXG4gICAgQElucHV0KCkgZWxuYW1lOiBzdHJpbmc7XG4gICAgQElucHV0KCkgcGxhY2VIb2xkZXI6IHN0cmluZztcbiAgICBASW5wdXQoKSBjbGFzc05hbWU6IHN0cmluZztcbiAgICBASW5wdXQoKSBjbGVhclRleHRJY29uOiBzdHJpbmc7XG4gICAgQElucHV0KCkgY2xvc2VTZWFyY2g6IHN0cmluZztcbiAgICBASW5wdXQoKSBleHBhbmRBbHdheXM6IGJvb2xlYW47XG4gICAgQElucHV0KCkgb25FbnRlcjogRnVuY3Rpb247XG5cbiAgICBAT3V0cHV0KCkgZm9jdXM6IEV2ZW50RW1pdHRlcjxzdHJpbmc+ID0gbmV3IEV2ZW50RW1pdHRlcjxzdHJpbmc+KCk7XG5cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50UmVmOiBFbGVtZW50UmVmLCBpbmplY3RvcjogSW5qZWN0b3IpIHtcbiAgICAgICAgc3VwZXIoJ2V4cGFuZElucHV0JywgZWxlbWVudFJlZiwgaW5qZWN0b3IpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEluamVjdG9yLCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVXBncmFkZUNvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL3VwZ3JhZGUvc3RhdGljJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdmbG9hdGluZy1hY3Rpb24tYnV0dG9uJ1xufSlcbmV4cG9ydCBjbGFzcyBGbG9hdGluZ0FjdGlvbkJ1dHRvbk5nMUNvbXBvbmVudCBleHRlbmRzIFVwZ3JhZGVDb21wb25lbnQge1xuXG4gICAgQElucHV0KCkgaXRlbXM6IEZsb2F0aW5nQWN0aW9uQnV0dG9uSXRlbVtdID0gW107XG4gICAgQElucHV0KCkgcHJpbWFyeTogc3RyaW5nO1xuICAgIEBJbnB1dCgpIGRpcmVjdGlvbjogJ3RvcCcgfCAncmlnaHQnIHwgJ2JvdHRvbScgfCAnbGVmdCc7XG4gICAgQElucHV0KCkgZmFiVG9vbHRpcDogc3RyaW5nO1xuICAgIEBJbnB1dCgpIGZhYlRvb2x0aXBQbGFjZW1lbnQ6ICd0b3AnIHwgJ3JpZ2h0JyB8ICdib3R0b20nIHwgJ2xlZnQnO1xuXG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZjogRWxlbWVudFJlZiwgaW5qZWN0b3I6IEluamVjdG9yKSB7XG4gICAgICAgIHN1cGVyKCdmbG9hdGluZ0FjdGlvbkJ1dHRvbicsIGVsZW1lbnRSZWYsIGluamVjdG9yKTtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmxvYXRpbmdBY3Rpb25CdXR0b25JdGVtIHtcbiAgICBpY29uOiBzdHJpbmc7XG4gICAgZXZlbnQ6IEZ1bmN0aW9uO1xuICAgIHRvb2x0aXA/OiBzdHJpbmc7XG4gICAgdG9vbHRpcFBsYWNlbWVudD86IHN0cmluZztcbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEluamVjdG9yLCBJbnB1dCwgT3V0cHV0LCBFdmVudEVtaXR0ZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFVwZ3JhZGVDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci91cGdyYWRlL3N0YXRpYyc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnZmxvdCdcbn0pXG5leHBvcnQgY2xhc3MgRmxvdE5nMUNvbXBvbmVudCBleHRlbmRzIFVwZ3JhZGVDb21wb25lbnQge1xuXG4gICAgQElucHV0KCkgZGF0YXNldDogYW55O1xuICAgIEBJbnB1dCgpIG9wdGlvbnM6IGFueTtcbiAgICBASW5wdXQoKSBjYWxsYmFjazogYW55O1xuICAgIEBJbnB1dCgpIGRvbnV0TGFiZWxzOiBhbnk7XG4gICAgQE91dHB1dCgpIG9uUGxvdENsaWNrID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG4gICAgQE91dHB1dCgpIG9uUGxvdEhvdmVyID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50UmVmOiBFbGVtZW50UmVmLCBpbmplY3RvcjogSW5qZWN0b3IpIHtcbiAgICAgICAgc3VwZXIoJ3V4RmxvdE5nMScsIGVsZW1lbnRSZWYsIGluamVjdG9yKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbmplY3RvciwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFVwZ3JhZGVDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci91cGdyYWRlL3N0YXRpYyc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnZ3JpZCdcbn0pXG5leHBvcnQgY2xhc3MgR3JpZE5nMUNvbXBvbmVudCBleHRlbmRzIFVwZ3JhZGVDb21wb25lbnQge1xuXG4gICAgQElucHV0KCkgc291cmNlOiBhbnlbXSA9IFtdO1xuICAgIEBJbnB1dCgpIGNvbHVtbnM6IEdyaWRDb2x1bW5bXSA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZvbGxvd2luZyBpbnB1dHMgYXJlIHVuZG9jdW1lbnRlZFxuICAgICAqL1xuICAgIEBJbnB1dCgpIG9wdGlvbnM6IGFueTtcbiAgICBASW5wdXQoKSBldmVudHM6IGFueTtcbiAgICBASW5wdXQoKSBwbHVnaW5zOiBhbnk7XG5cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50UmVmOiBFbGVtZW50UmVmLCBpbmplY3RvcjogSW5qZWN0b3IpIHtcbiAgICAgICAgc3VwZXIoJ2dyaWQnLCBlbGVtZW50UmVmLCBpbmplY3Rvcik7XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdyaWRDb2x1bW4ge1xuICAgIHRpdGxlOiBzdHJpbmc7XG4gICAgdGVtcGxhdGU6IHN0cmluZztcbiAgICB3aWR0aD86IHN0cmluZztcbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEluamVjdG9yLCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVXBncmFkZUNvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL3VwZ3JhZGUvc3RhdGljJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdoaWVyYXJjaHktYmFyJ1xufSlcbmV4cG9ydCBjbGFzcyBIaWVyYXJjaHlCYXJOZzFDb21wb25lbnQgZXh0ZW5kcyBVcGdyYWRlQ29tcG9uZW50IHtcblxuICAgIEBJbnB1dCgpIGRhdGE6IGFueVtdO1xuICAgIEBJbnB1dCgpIG9wdGlvbnM6IEhpZXJhcmNoeUJhck9wdGlvbnM7XG4gICAgQElucHV0KCkgc2VsZWN0Tm9kZTogYW55O1xuICAgIEBJbnB1dCgpIGNvbnRhaW5lckNsYXNzOiBhbnk7XG5cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50UmVmOiBFbGVtZW50UmVmLCBpbmplY3RvcjogSW5qZWN0b3IpIHtcbiAgICAgICAgc3VwZXIoJ2hpZXJhcmNoeUJhcicsIGVsZW1lbnRSZWYsIGluamVjdG9yKTtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSGllcmFyY2h5QmFyT3B0aW9ucyB7XG4gICAgZW5hYmxlZDogYm9vbGVhbjtcbiAgICBvdmVydmlldz86IEZ1bmN0aW9uO1xuICAgIGltYWdlOiBGdW5jdGlvbjtcbiAgICB2YWx1ZUZvcm1hdHRlcjogRnVuY3Rpb247XG4gICAgYWN0aW9uPzoge1xuICAgICAgICB0aXRsZTogc3RyaW5nO1xuICAgICAgICBldmVudDogRnVuY3Rpb247XG4gICAgfTtcbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEluamVjdG9yLCBJbnB1dCwgT3V0cHV0LCBFdmVudEVtaXR0ZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFVwZ3JhZGVDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci91cGdyYWRlL3N0YXRpYyc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnbWFycXVlZS13aXphcmQnXG59KVxuZXhwb3J0IGNsYXNzIE1hcnF1ZWVXaXphcmROZzFDb21wb25lbnQgZXh0ZW5kcyBVcGdyYWRlQ29tcG9uZW50IHtcblxuICAgIEBJbnB1dCgpIHdpemFyZEljb246IHN0cmluZztcbiAgICBASW5wdXQoKSB3aXphcmRTdGVwczogTWFycXVlZVdpemFyZFN0ZXBbXTtcbiAgICBASW5wdXQoKSBidXR0b25PcHRpb25zOiBNYXJxdWVlV2l6YXJkT3B0aW9ucztcbiAgICBASW5wdXQoKSBvbkNoYW5naW5nOiBGdW5jdGlvbjtcbiAgICBASW5wdXQoKSBvbkZpbmlzaGVkOiBGdW5jdGlvbjtcbiAgICBASW5wdXQoKSBvbkZpbmlzaGluZzogRnVuY3Rpb247XG4gICAgQElucHV0KCkgb25DYW5jZWxlZDogRnVuY3Rpb247XG4gICAgQElucHV0KCkgaXNWaXNpdGVkOiBib29sZWFuO1xuICAgIEBJbnB1dCgpIHNpZGVJbmZvOiBNYXJxdWVlV2l6YXJkU2lkZUluZm87XG5cbiAgICBAT3V0cHV0KCkgd2l6YXJkU3RlcHNDaGFuZ2U6IEV2ZW50RW1pdHRlcjxNYXJxdWVlV2l6YXJkU3RlcFtdPiA9IG5ldyBFdmVudEVtaXR0ZXI8TWFycXVlZVdpemFyZFN0ZXBbXT4oKTtcblxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIGluamVjdG9yOiBJbmplY3Rvcikge1xuICAgICAgICBzdXBlcignbWFycXVlZVdpemFyZCcsIGVsZW1lbnRSZWYsIGluamVjdG9yKTtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWFycXVlZVdpemFyZFN0ZXAge1xuICAgIHRpdGxlOiBzdHJpbmc7XG4gICAgaHRtbD86IHN0cmluZztcbiAgICBoZWFkZXI/OiBzdHJpbmc7XG4gICAgdGVtcGxhdGVVcmw/OiBzdHJpbmc7XG4gICAgaGlkZGVuPzogYm9vbGVhbjtcbiAgICBlcnJvcj86IGJvb2xlYW47XG4gICAgY29tcGxldGVkPzogYm9vbGVhbjtcbiAgICB2aXNpdGVkPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNYXJxdWVlV2l6YXJkT3B0aW9ucyB7XG4gICAgbmV4dFRleHQ/OiBzdHJpbmc7XG4gICAgcHJldmlvdXNUZXh0Pzogc3RyaW5nO1xuICAgIGZpbmlzaFRleHQ/OiBzdHJpbmc7XG4gICAgc2hvd05leHQ/OiBib29sZWFuO1xuICAgIHNob3dQcmV2aW91cz86IGJvb2xlYW47XG4gICAgc2hvd0ZpbmlzaD86IGJvb2xlYW47XG4gICAgbmV4dFRvb2x0aXA/OiBzdHJpbmc7XG4gICAgcHJldmlvdXNUb29sdGlwPzogc3RyaW5nO1xuICAgIGZpbmlzaFRvb2x0aXA/OiBzdHJpbmc7XG4gICAgcHJldmlvdXNFbmFibGVkPzogYm9vbGVhbjtcbiAgICBuZXh0RW5hYmxlZD86IGJvb2xlYW47XG4gICAgZmluaXNoRW5hYmxlZD86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWFycXVlZVdpemFyZFNpZGVJbmZvIHtcbiAgICB0aXRsZTogc3RyaW5nO1xuICAgIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbmplY3RvciwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFVwZ3JhZGVDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci91cGdyYWRlL3N0YXRpYyc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnbmVzdGVkLWRvbnV0J1xufSlcbmV4cG9ydCBjbGFzcyBOZXN0ZWREb251dE5nMUNvbXBvbmVudCBleHRlbmRzIFVwZ3JhZGVDb21wb25lbnQge1xuXG4gICAgQElucHV0KCkgZGF0YXNldDogYW55O1xuICAgIEBJbnB1dCgpIG9wdGlvbnM6IGFueTtcblxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIGluamVjdG9yOiBJbmplY3Rvcikge1xuICAgICAgICBzdXBlcigndXhOZXN0ZWREb251dE5nMScsIGVsZW1lbnRSZWYsIGluamVjdG9yKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbmplY3RvciwgSW5wdXQsIE91dHB1dCwgRXZlbnRFbWl0dGVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBVcGdyYWRlQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvdXBncmFkZS9zdGF0aWMnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ29yZ2FuaXphdGlvbi1jaGFydCdcbn0pXG5leHBvcnQgY2xhc3MgT3JnYW5pemF0aW9uQ2hhcnROZzFDb21wb25lbnQgZXh0ZW5kcyBVcGdyYWRlQ29tcG9uZW50IHtcblxuICAgIEBJbnB1dCgpIGRhdGE6IGFueTtcbiAgICBASW5wdXQoKSBvcHRpb25zOiBhbnk7XG4gICAgQE91dHB1dCgpIGRhdGFDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcbiAgICBAT3V0cHV0KCkgb3B0aW9uc0NoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZjogRWxlbWVudFJlZiwgaW5qZWN0b3I6IEluamVjdG9yKSB7XG4gICAgICAgIHN1cGVyKCd1eE9yZ2FuaXphdGlvbkNoYXJ0TmcxJywgZWxlbWVudFJlZiwgaW5qZWN0b3IpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEluamVjdG9yLCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVXBncmFkZUNvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL3VwZ3JhZGUvc3RhdGljJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdwYXJ0aXRpb24tbWFwJ1xufSlcbmV4cG9ydCBjbGFzcyBQYXJ0aXRpb25NYXBOZzFDb21wb25lbnQgZXh0ZW5kcyBVcGdyYWRlQ29tcG9uZW50IHtcblxuICAgIEBJbnB1dCgpIGNoYXJ0RGF0YTogYW55O1xuICAgIEBJbnB1dCgpIGNoYXJ0T3B0aW9uczogYW55O1xuICAgIEBJbnB1dCgpIGNoYXJ0TG9hZGluZzogYW55O1xuXG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZjogRWxlbWVudFJlZiwgaW5qZWN0b3I6IEluamVjdG9yKSB7XG4gICAgICAgIHN1cGVyKCd1eFBhcnRpdGlvbk1hcE5nMScsIGVsZW1lbnRSZWYsIGluamVjdG9yKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbmplY3RvciwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFVwZ3JhZGVDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci91cGdyYWRlL3N0YXRpYyc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnYmFyLWNoYXJ0J1xufSlcbmV4cG9ydCBjbGFzcyBQZWl0eUJhckNoYXJ0TmcxQ29tcG9uZW50IGV4dGVuZHMgVXBncmFkZUNvbXBvbmVudCB7XG5cbiAgICBASW5wdXQoKSBkYXRhOiBhbnk7XG4gICAgQElucHV0KCkgb3B0aW9uczogYW55O1xuXG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZjogRWxlbWVudFJlZiwgaW5qZWN0b3I6IEluamVjdG9yKSB7XG4gICAgICAgIHN1cGVyKCd1eFBlaXR5QmFyQ2hhcnROZzEnLCBlbGVtZW50UmVmLCBpbmplY3Rvcik7XG4gICAgfVxufSIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSW5qZWN0b3IsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBVcGdyYWRlQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvdXBncmFkZS9zdGF0aWMnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ2xpbmUtY2hhcnQnXG59KVxuZXhwb3J0IGNsYXNzIFBlaXR5TGluZUNoYXJ0TmcxQ29tcG9uZW50IGV4dGVuZHMgVXBncmFkZUNvbXBvbmVudCB7XG5cbiAgICBASW5wdXQoKSBkYXRhOiBhbnk7XG4gICAgQElucHV0KCkgb3B0aW9uczogYW55O1xuXG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZjogRWxlbWVudFJlZiwgaW5qZWN0b3I6IEluamVjdG9yKSB7XG4gICAgICAgIHN1cGVyKCd1eFBlaXR5TGluZUNoYXJ0TmcxJywgZWxlbWVudFJlZiwgaW5qZWN0b3IpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEluamVjdG9yLCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVXBncmFkZUNvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL3VwZ3JhZGUvc3RhdGljJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdwaWUtY2hhcnQnXG59KVxuZXhwb3J0IGNsYXNzIFBlaXR5UGllQ2hhcnROZzFDb21wb25lbnQgZXh0ZW5kcyBVcGdyYWRlQ29tcG9uZW50IHtcblxuICAgIEBJbnB1dCgpIGRhdGE6IGFueTtcbiAgICBASW5wdXQoKSBvcHRpb25zOiBhbnk7XG5cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50UmVmOiBFbGVtZW50UmVmLCBpbmplY3RvcjogSW5qZWN0b3IpIHtcbiAgICAgICAgc3VwZXIoJ3V4UGVpdHlQaWVDaGFydE5nMScsIGVsZW1lbnRSZWYsIGluamVjdG9yKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbmplY3RvciwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFVwZ3JhZGVDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci91cGdyYWRlL3N0YXRpYyc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAndXBkYXRpbmctbGluZS1jaGFydCdcbn0pXG5leHBvcnQgY2xhc3MgUGVpdHlVcGRhdGluZ0xpbmVDaGFydE5nMUNvbXBvbmVudCBleHRlbmRzIFVwZ3JhZGVDb21wb25lbnQge1xuXG4gICAgQElucHV0KCkgZGF0YTogYW55O1xuICAgIEBJbnB1dCgpIG9wdGlvbnM6IGFueTtcbiAgICBASW5wdXQoKSBtZXRob2Q6IGFueTtcbiAgICBASW5wdXQoKSB1cGRhdGVpbnRlcnZhbDogYW55O1xuXG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZjogRWxlbWVudFJlZiwgaW5qZWN0b3I6IEluamVjdG9yKSB7XG4gICAgICAgIHN1cGVyKCd1eFBlaXR5VXBkYXRpbmdMaW5lQ2hhcnROZzEnLCBlbGVtZW50UmVmLCBpbmplY3Rvcik7XG4gICAgfVxufSIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSW5qZWN0b3IsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBVcGdyYWRlQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvdXBncmFkZS9zdGF0aWMnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ3NhbmtleSdcbn0pXG5leHBvcnQgY2xhc3MgU2Fua2V5TmcxQ29tcG9uZW50IGV4dGVuZHMgVXBncmFkZUNvbXBvbmVudCB7XG5cbiAgICBASW5wdXQoKSBjaGFydFNpemU6IGFueTtcbiAgICBASW5wdXQoKSBjaGFydERhdGE6IGFueTtcbiAgICBASW5wdXQoKSBvcHRpb25zOiBhbnk7XG4gICAgQElucHV0KCkgY2xpY2s6IGFueTtcblxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIGluamVjdG9yOiBJbmplY3Rvcikge1xuICAgICAgICBzdXBlcigndXhTYW5rZXlOZzEnLCBlbGVtZW50UmVmLCBpbmplY3Rvcik7XG4gICAgfVxufSIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSW5qZWN0b3IsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBVcGdyYWRlQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvdXBncmFkZS9zdGF0aWMnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ3NlYXJjaC10b29sYmFyJ1xufSlcbmV4cG9ydCBjbGFzcyBTZWFyY2hUb29sYmFyTmcxQ29tcG9uZW50IGV4dGVuZHMgVXBncmFkZUNvbXBvbmVudCB7XG5cbiAgICBASW5wdXQoKSBzZWFyY2hUeXBlYWhlYWQ6IGFueVtdO1xuICAgIEBJbnB1dCgpIHBsYWNlSG9sZGVyOiBzdHJpbmc7XG4gICAgQElucHV0KCkgY2xvc2VTZWFyY2g6IHN0cmluZztcbiAgICBASW5wdXQoKSBvblNlYXJjaDogRnVuY3Rpb247XG4gICAgQElucHV0KCkgb25Gb2N1czogRnVuY3Rpb247XG5cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50UmVmOiBFbGVtZW50UmVmLCBpbmplY3RvcjogSW5qZWN0b3IpIHtcbiAgICAgICAgc3VwZXIoJ3NlYXJjaFRvb2xiYXInLCBlbGVtZW50UmVmLCBpbmplY3Rvcik7XG4gICAgfVxufSIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSW5qZWN0b3IsIElucHV0LCBPdXRwdXQsIEV2ZW50RW1pdHRlciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVXBncmFkZUNvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL3VwZ3JhZGUvc3RhdGljJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdzZWxlY3QtdGFibGUnXG59KVxuZXhwb3J0IGNsYXNzIFNlbGVjdFRhYmxlTmcxQ29tcG9uZW50IGV4dGVuZHMgVXBncmFkZUNvbXBvbmVudCB7XG5cbiAgICBASW5wdXQoKSB2YWx1ZXM6IGFueVtdO1xuICAgIEBJbnB1dCgpIG11bHRpcGxlU2VsZWN0OiBib29sZWFuO1xuICAgIEBJbnB1dCgpIHNlbGVjdEtleTogc3RyaW5nO1xuICAgIEBJbnB1dCgpIHNlbGVjdGVkOiBzdHJpbmc7XG4gICAgQElucHV0KCkgc2VhcmNoVGV4dDogc3RyaW5nO1xuICAgIEBJbnB1dCgpIHRhYmxlSGVpZ2h0OiBzdHJpbmc7XG4gICAgQElucHV0KCkgc2VsZWN0SGlkZGVuSXRlbXM6ICdjbGVhcicgfCAncmVzZWxlY3QnO1xuXG4gICAgQE91dHB1dCgpIHNlbGVjdGVkQ2hhbmdlOiBFdmVudEVtaXR0ZXI8c3RyaW5nPiA9IG5ldyBFdmVudEVtaXR0ZXI8c3RyaW5nPigpO1xuXG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZjogRWxlbWVudFJlZiwgaW5qZWN0b3I6IEluamVjdG9yKSB7XG4gICAgICAgIHN1cGVyKCdzZWxlY3RUYWJsZScsIGVsZW1lbnRSZWYsIGluamVjdG9yKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbmplY3RvciwgSW5wdXQsIE91dHB1dCwgRXZlbnRFbWl0dGVyLCBmb3J3YXJkUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBVcGdyYWRlQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvdXBncmFkZS9zdGF0aWMnO1xuaW1wb3J0IHsgQ29udHJvbFZhbHVlQWNjZXNzb3IsIE5HX1ZBTFVFX0FDQ0VTU09SIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5leHBvcnQgY29uc3QgU0xJREVSX0NIQVJUX1ZBTFVFX0FDQ0VTU09SOiBhbnkgPSB7XG4gICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gU2xpZGVyQ2hhcnROZzFDb21wb25lbnQpLFxuICAgIG11bHRpOiB0cnVlXG59O1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ3NsaWRlci1jaGFydCcsXG4gICAgcHJvdmlkZXJzOiBbU0xJREVSX0NIQVJUX1ZBTFVFX0FDQ0VTU09SXVxufSlcbmV4cG9ydCBjbGFzcyBTbGlkZXJDaGFydE5nMUNvbXBvbmVudCBleHRlbmRzIFVwZ3JhZGVDb21wb25lbnQgaW1wbGVtZW50cyBDb250cm9sVmFsdWVBY2Nlc3NvciB7XG5cbiAgICBASW5wdXQoKSBzbGlkZXJPcHRpb25zOiBhbnk7XG4gICAgQElucHV0KCkgbmdNb2RlbDogYW55O1xuICAgIEBJbnB1dCgpIGNoYXJ0T3B0aW9uczogYW55O1xuICAgIEBJbnB1dCgpIGNoYXJ0RGF0YTogYW55O1xuXG4gICAgQE91dHB1dCgpIG5nTW9kZWxDaGFuZ2U6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50UmVmOiBFbGVtZW50UmVmLCBpbmplY3RvcjogSW5qZWN0b3IpIHtcbiAgICAgICAgc3VwZXIoJ3NsaWRlckNoYXJ0JywgZWxlbWVudFJlZiwgaW5qZWN0b3IpO1xuICAgIH1cblxuICAgIHdyaXRlVmFsdWUob2JqOiBhbnkpOiB2b2lkIHsgfVxuXG4gICAgcmVnaXN0ZXJPbkNoYW5nZShmbjogYW55KTogdm9pZCB7IH1cblxuICAgIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiBhbnkpOiB2b2lkIHsgfVxufSIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSW5qZWN0b3IsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBVcGdyYWRlQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvdXBncmFkZS9zdGF0aWMnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ3NvY2lhbC1jaGFydCdcbn0pXG5leHBvcnQgY2xhc3MgU29jaWFsQ2hhcnROZzFDb21wb25lbnQgZXh0ZW5kcyBVcGdyYWRlQ29tcG9uZW50IHtcblxuICAgIEBJbnB1dCgpIGRhdGE6IGFueTtcbiAgICBASW5wdXQoKSBvcHRpb25zOiBhbnk7XG4gICAgQElucHV0KCkgd2lkdGg6IGFueTtcbiAgICBASW5wdXQoKSBoZWlnaHQ6IGFueTtcbiAgICBASW5wdXQoKSBhcGk6IGFueTtcbiAgICBASW5wdXQoKSBjb21tdW5pdGllczogYW55O1xuICAgIEBJbnB1dCgpIGRldGFpbFN0eWxlOiBhbnk7XG4gICAgQElucHV0KCkgcG9wb3ZlclN0eWxlOiBhbnk7XG4gICAgQElucHV0KCkgbm9kZURldGFpbDogYW55O1xuICAgIEBJbnB1dCgpIGVkZ2VEZXRhaWw6IGFueTtcbiAgICBASW5wdXQoKSBub2RlUG9wb3ZlcjogYW55O1xuICAgIEBJbnB1dCgpIGVkZ2VQb3BvdmVyOiBhbnk7XG4gICAgQElucHV0KCkgZm9yY2VBdGxhc0R1cmF0aW9uOiBhbnk7XG4gICAgQElucHV0KCkgbm9kZVNpemVBdHRyaWJ1dGU6IGFueTtcbiAgICBASW5wdXQoKSBzdGFydE1heGltaXplZDogYW55O1xuICAgIEBJbnB1dCgpIHN0YXJ0TWF4aW1pc2VkOiBhbnk7XG4gICAgQElucHV0KCkgc2hvd01heGltaXplQ29udHJvbDogYW55O1xuICAgIEBJbnB1dCgpIHNob3dNYXhpbWlzZUNvbnRyb2w6IGFueTtcbiAgICBASW5wdXQoKSBzb2NpYWxDaGFydENvbnRhaW5lcjogYW55O1xuICAgIEBJbnB1dCgpIGZ1bGxzY3JlZW5CdXR0b25Qb3NpdGlvbjogYW55O1xuICAgIEBJbnB1dCgpIGxvY2FsU3RyaW5nczogYW55O1xuICAgIEBJbnB1dCgpIGNoYXJ0VGl0bGU6IGFueTtcbiAgICBASW5wdXQoKSB0aXRsZURpc3BsYXlUaW1lOiBhbnk7XG4gICAgQElucHV0KCkgZWRnZVdlaWdodEluZmx1ZW5jZTogYW55O1xuICAgIEBJbnB1dCgpIG1pbkxhYmVsczogYW55O1xuICAgIFxuXG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZjogRWxlbWVudFJlZiwgaW5qZWN0b3I6IEluamVjdG9yKSB7XG4gICAgICAgIHN1cGVyKCd1eFNvY2lhbENoYXJ0TmcxJywgZWxlbWVudFJlZiwgaW5qZWN0b3IpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEluamVjdG9yLCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVXBncmFkZUNvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL3VwZ3JhZGUvc3RhdGljJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdzb3J0LWRpcmVjdGlvbi10b2dnbGUnXG59KVxuZXhwb3J0IGNsYXNzIFNvcnREaXJlY3Rpb25Ub2dnbGVOZzFDb21wb25lbnQgZXh0ZW5kcyBVcGdyYWRlQ29tcG9uZW50IHtcblxuICAgIEBJbnB1dCgpIGxhYmVsOiBzdHJpbmc7XG4gICAgQElucHV0KCkgc29ydGVyczogU29ydERpcmVjdGlvblRvZ2dsZVNvcnRlcltdO1xuICAgIEBJbnB1dCgpIGRlc2NlbmQ6IGJvb2xlYW47XG5cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50UmVmOiBFbGVtZW50UmVmLCBpbmplY3RvcjogSW5qZWN0b3IpIHtcbiAgICAgICAgc3VwZXIoJ3NvcnREaXJlY3Rpb25Ub2dnbGUnLCBlbGVtZW50UmVmLCBpbmplY3Rvcik7XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNvcnREaXJlY3Rpb25Ub2dnbGVTb3J0ZXIge1xuICAgIG5hbWU6IHN0cmluZztcbiAgICBzb3J0OiBzdHJpbmc7XG4gICAgZGVmYXVsdFNvcnRlcjogYm9vbGVhbjtcbiAgICBzZWxlY3Q6IEZ1bmN0aW9uO1xufSIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSW5qZWN0b3IsIElucHV0LCBPdXRwdXQsIEV2ZW50RW1pdHRlciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVXBncmFkZUNvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL3VwZ3JhZGUvc3RhdGljJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICd0cmVlZ3JpZCdcbn0pXG5leHBvcnQgY2xhc3MgVHJlZUdyaWROZzFDb21wb25lbnQgZXh0ZW5kcyBVcGdyYWRlQ29tcG9uZW50IHtcblxuICAgIEBJbnB1dCgpIGRhdGE6IFRyZWVHcmlkRGF0YVtdIHwgRnVuY3Rpb247XG4gICAgQElucHV0KCkgY29sdW1uczogVHJlZUdyaWRDb2x1bW5bXTtcbiAgICBASW5wdXQoKSB0cmVlRGF0YTogVHJlZUdyaWREYXRhW107XG4gICAgQElucHV0KCkgc2VsZWN0ZWQ6IGFueVtdO1xuICAgIEBJbnB1dCgpIGN1cnJlbnRSb3c6IGFueTtcbiAgICBASW5wdXQoKSBvcHRpb25zOiBUcmVlR3JpZE9wdGlvbnM7XG5cbiAgICBAT3V0cHV0KCkgb3B0aW9uc0NoYW5nZTogRXZlbnRFbWl0dGVyPFRyZWVHcmlkT3B0aW9ucz4gPSBuZXcgRXZlbnRFbWl0dGVyPFRyZWVHcmlkT3B0aW9ucz4oKTtcbiAgICBAT3V0cHV0KCkgc2VsZWN0ZWRDaGFuZ2U6IEV2ZW50RW1pdHRlcjxhbnlbXT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueVtdPigpO1xuICAgIEBPdXRwdXQoKSBjdXJyZW50Um93Q2hhbmdlOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuICAgIEBPdXRwdXQoKSB0cmVlRGF0YUNoYW5nZTogRXZlbnRFbWl0dGVyPFRyZWVHcmlkRGF0YVtdPiA9IG5ldyBFdmVudEVtaXR0ZXI8VHJlZUdyaWREYXRhW10+KCk7ICAgIFxuXG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZjogRWxlbWVudFJlZiwgaW5qZWN0b3I6IEluamVjdG9yKSB7XG4gICAgICAgIHN1cGVyKCd0cmVlZ3JpZCcsIGVsZW1lbnRSZWYsIGluamVjdG9yKTtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJlZUdyaWRDb2x1bW4ge1xuICAgIG5hbWU6IHN0cmluZztcbiAgICB2YWx1ZT86IHN0cmluZyB8IEZ1bmN0aW9uO1xuICAgIHRlbXBsYXRlPzogc3RyaW5nO1xuICAgIGhlYWRlckNsYXNzPzogc3RyaW5nO1xuICAgIGNlbGxDbGFzcz86IHN0cmluZztcbiAgICB3aWR0aD86IHN0cmluZztcbiAgICB0b29sdGlwPzogc3RyaW5nO1xuICAgIHRvb2x0aXBQbGFjZW1lbnQ/OiAndG9wJyB8ICdib3R0b20nIHwgJ2xlZnQnIHwgJ3JpZ2h0Jztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUcmVlR3JpZERhdGEge1xuICAgIGRhdGFJdGVtOiBhbnk7XG4gICAgY2hpbGRyZW46IGFueVtdO1xuICAgIGV4cGFuZGVkOiBib29sZWFuO1xuICAgIGV4cGFuZGluZzogYm9vbGVhbjtcbiAgICBsZXZlbDogbnVtYmVyO1xuICAgIGFwaTogYW55O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRyZWVHcmlkT3B0aW9ucyB7XG4gICAgY2hpbGRyZW5Qcm9wZXJ0eT86IHN0cmluZztcbiAgICBoYXNDaGlsZHJlbj86IEZ1bmN0aW9uO1xuICAgIG1heERlcHRoPzogbnVtYmVyO1xuICAgIGV4cGFuZFRvcExldmVsPzogYm9vbGVhbjtcbiAgICBzZWxlY3Q/OiBhbnk7XG4gICAgZXhwYW5kZXI/OiBhbnk7XG4gICAgaWNvbnM/OiBhbnk7XG4gICAgcm93Q2xhc3M/OiBzdHJpbmcgfCBGdW5jdGlvbjtcbiAgICBzb3J0PzogRnVuY3Rpb247XG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbmplY3RvciwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFVwZ3JhZGVDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci91cGdyYWRlL3N0YXRpYyc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAndGh1bWJuYWlsJ1xufSlcbmV4cG9ydCBjbGFzcyBUaHVtYm5haWxOZzFDb21wb25lbnQgZXh0ZW5kcyBVcGdyYWRlQ29tcG9uZW50IHtcblxuICAgIEBJbnB1dCgpIHVybDogc3RyaW5nO1xuICAgIEBJbnB1dCgpIHNob3c6IGJvb2xlYW47XG4gICAgQElucHV0KCkgd2lkdGg6IHN0cmluZztcbiAgICBASW5wdXQoKSBoZWlnaHQ6IHN0cmluZztcblxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIGluamVjdG9yOiBJbmplY3Rvcikge1xuICAgICAgICBzdXBlcigndGh1bWJuYWlsJywgZWxlbWVudFJlZiwgaW5qZWN0b3IpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBJbmplY3QsIEluamVjdG9yIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBJTmF2aWdhdGlvbk1lbnVTZXJ2aWNlIH0gZnJvbSAnLi9uYXZpZ2F0aW9uLW1lbnUuaW50ZXJmYWNlJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIE5hdmlnYXRpb25NZW51U2VydmljZSBpbXBsZW1lbnRzIElOYXZpZ2F0aW9uTWVudVNlcnZpY2Uge1xuXG4gICAgY29uc3RydWN0b3IoIEBJbmplY3QoJyRuYXZpZ2F0aW9uTWVudScpIHByaXZhdGUgX25hdmlnYXRpb25NZW51U2VydmljZTogSU5hdmlnYXRpb25NZW51U2VydmljZSkgeyB9XG5cbiAgICBzaG93KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9uYXZpZ2F0aW9uTWVudVNlcnZpY2Uuc2hvdygpO1xuICAgIH1cblxuICAgIGhpZGUoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX25hdmlnYXRpb25NZW51U2VydmljZS5oaWRlKCk7XG4gICAgfVxuXG4gICAgdmlzaWJsZSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hdmlnYXRpb25NZW51U2VydmljZS52aXNpYmxlKCk7XG4gICAgfVxuXG4gICAgY29sbGFwc2VBdFdpZHRoKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYXZpZ2F0aW9uTWVudVNlcnZpY2UuY29sbGFwc2VBdFdpZHRoKCk7XG4gICAgfVxuXG4gICAgc2V0Q29sbGFwc2VBdFdpZHRoKHdpZHRoOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fbmF2aWdhdGlvbk1lbnVTZXJ2aWNlLnNldENvbGxhcHNlQXRXaWR0aCh3aWR0aCk7XG4gICAgfVxuXG4gICAgc2V0RGVmYXVsdENvbGxhcHNlQXRXaWR0aCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fbmF2aWdhdGlvbk1lbnVTZXJ2aWNlLnNldERlZmF1bHRDb2xsYXBzZUF0V2lkdGgoKTtcbiAgICB9XG5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5hdmlnYXRpb25NZW51U2VydmljZUZhY3RvcnkoaW5qZWN0b3I6IEluamVjdG9yKSB7XG4gICAgcmV0dXJuIGluamVjdG9yLmdldCgnJG5hdmlnYXRpb25NZW51Jyk7XG59XG5cbmV4cG9ydCBjb25zdCBuYXZpZ2F0aW9uTWVudVNlcnZpY2VQcm92aWRlciA9IHtcbiAgICBwcm92aWRlOiAnJG5hdmlnYXRpb25NZW51JyxcbiAgICB1c2VGYWN0b3J5OiBuYXZpZ2F0aW9uTWVudVNlcnZpY2VGYWN0b3J5LFxuICAgIGRlcHM6IFsnJGluamVjdG9yJ11cbn07IiwiaW1wb3J0IHsgSW5qZWN0YWJsZSwgSW5qZWN0LCBJbmplY3RvciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSVBkZlNlcnZpY2UsIFBkZkNvbHVtbnMsIFBkZk9wdGlvbnMsIFBkZkRvY3VtZW50IH0gZnJvbSAnLi9wZGYuaW50ZXJmYWNlJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFBkZlNlcnZpY2UgaW1wbGVtZW50cyBJUGRmU2VydmljZSB7XG4gICAgXG4gICAgY29uc3RydWN0b3IoQEluamVjdCgnJHBkZicpIHByaXZhdGUgX3BkZlNlcnZpY2U6IElQZGZTZXJ2aWNlKSB7IH1cbiAgICBcbiAgICBjcmVhdGVUYWJsZShjb2x1bW5zOiBQZGZDb2x1bW5zLCByb3dzOiBhbnlbXSwgb3B0aW9uczogUGRmT3B0aW9ucyA9IHt9KTogUGRmRG9jdW1lbnQge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGRmU2VydmljZS5jcmVhdGVUYWJsZShjb2x1bW5zLCByb3dzLCBvcHRpb25zKTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwZGZTZXJ2aWNlRmFjdG9yeShpbmplY3RvcjogSW5qZWN0b3IpIHtcbiAgICByZXR1cm4gaW5qZWN0b3IuZ2V0KCckcGRmJyk7XG59XG5cbmV4cG9ydCBjb25zdCBwZGZTZXJ2aWNlUHJvdmlkZXIgPSB7XG4gICAgcHJvdmlkZTogJyRwZGYnLFxuICAgIHVzZUZhY3Rvcnk6IHBkZlNlcnZpY2VGYWN0b3J5LFxuICAgIGRlcHM6IFsnJGluamVjdG9yJ11cbn07IiwiaW1wb3J0IHsgSW5qZWN0YWJsZSwgSW5qZWN0LCBJbmplY3RvciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSVRpbWVBZ29TZXJ2aWNlLCBUaW1lQWdvTG9jYWxpemVkVGltZXMgfSBmcm9tICcuL3RpbWUtYWdvLmludGVyZmFjZSc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBUaW1lQWdvU2VydmljZSBpbXBsZW1lbnRzIElUaW1lQWdvU2VydmljZSB7XG5cbiAgICBjb25zdHJ1Y3RvcihASW5qZWN0KCd0aW1lQWdvU2VydmljZScpIHByaXZhdGUgX3RpbWVBZ29TZXJ2aWNlOiBJVGltZUFnb1NlcnZpY2UpIHsgfVxuXG4gICAgc2V0U3RyaW5ncyhzdHJpbmdzOiBUaW1lQWdvTG9jYWxpemVkVGltZXMpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fdGltZUFnb1NlcnZpY2Uuc2V0U3RyaW5ncyhzdHJpbmdzKTtcbiAgICB9XG5cbiAgICB0aW1lU2luY2UocGFzdDogRGF0ZSwgcHJlc2VudDogRGF0ZSk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLl90aW1lQWdvU2VydmljZS50aW1lU2luY2UocGFzdCwgcHJlc2VudCk7XG4gICAgfVxuXG4gICAgdGltZVNpbmNlTm93KG1vbWVudDogRGF0ZSk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLl90aW1lQWdvU2VydmljZS50aW1lU2luY2VOb3cobW9tZW50KTtcbiAgICB9XG5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRpbWVBZ29TZXJ2aWNlRmFjdG9yeShpbmplY3RvcjogSW5qZWN0b3IpIHtcbiAgICByZXR1cm4gaW5qZWN0b3IuZ2V0KCd0aW1lQWdvU2VydmljZScpO1xufVxuXG5leHBvcnQgY29uc3QgdGltZUFnb1NlcnZpY2VQcm92aWRlciA9IHtcbiAgICBwcm92aWRlOiAndGltZUFnb1NlcnZpY2UnLFxuICAgIHVzZUZhY3Rvcnk6IHRpbWVBZ29TZXJ2aWNlRmFjdG9yeSxcbiAgICBkZXBzOiBbJyRpbmplY3RvciddXG59OyIsImltcG9ydCB7IE5nTW9kdWxlLCBJbmplY3RvciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBGbG9hdGluZ0FjdGlvbkJ1dHRvbk5nMUNvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50cy9mbG9hdGluZy1hY3Rpb24tYnV0dG9uL2Zsb2F0aW5nLWFjdGlvbi1idXR0b24uY29tcG9uZW50JztcbmltcG9ydCB7IEZsb3ROZzFDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvZmxvdC9mbG90LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBOZXN0ZWREb251dE5nMUNvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50cy9uZXN0ZWQtZG9udXQvbmVzdGVkLWRvbnV0LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBPcmdhbml6YXRpb25DaGFydE5nMUNvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50cy9vcmdhbml6YXRpb24tY2hhcnQvb3JnYW5pemF0aW9uLWNoYXJ0LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBQYXJ0aXRpb25NYXBOZzFDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvcGFydGl0aW9uLW1hcC9wYXJ0aXRpb24tbWFwLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBQZWl0eUJhckNoYXJ0TmcxQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL3BlaXR5LWNoYXJ0L3BlaXR5LWJhci1jaGFydC5jb21wb25lbnQnO1xuaW1wb3J0IHsgUGVpdHlMaW5lQ2hhcnROZzFDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvcGVpdHktY2hhcnQvcGVpdHktbGluZS1jaGFydC5jb21wb25lbnQnO1xuaW1wb3J0IHsgUGVpdHlQaWVDaGFydE5nMUNvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50cy9wZWl0eS1jaGFydC9wZWl0eS1waWUtY2hhcnQuY29tcG9uZW50JztcbmltcG9ydCB7IFBlaXR5VXBkYXRpbmdMaW5lQ2hhcnROZzFDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvcGVpdHktY2hhcnQvcGVpdHktdXBkYXRpbmctbGluZS1jaGFydC5jb21wb25lbnQnO1xuaW1wb3J0IHsgU2Fua2V5TmcxQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL3NhbmtleS1jaGFydC9zYW5rZXkuY29tcG9uZW50JztcbmltcG9ydCB7IFNvY2lhbENoYXJ0TmcxQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL3NvY2lhbC1jaGFydC9zb2NpYWwtY2hhcnQuY29tcG9uZW50JztcbmltcG9ydCB7IFRpbWVBZ29TZXJ2aWNlLCB0aW1lQWdvU2VydmljZVByb3ZpZGVyIH0gZnJvbSAnLi9zZXJ2aWNlcy90aW1lLWFnby90aW1lLWFnby5zZXJ2aWNlJztcbmltcG9ydCB7IFBkZlNlcnZpY2UsIHBkZlNlcnZpY2VQcm92aWRlciB9IGZyb20gJy4vc2VydmljZXMvcGRmL3BkZi5zZXJ2aWNlJztcbmltcG9ydCB7IE5hdmlnYXRpb25NZW51U2VydmljZSwgbmF2aWdhdGlvbk1lbnVTZXJ2aWNlUHJvdmlkZXIgfSBmcm9tICcuL3NlcnZpY2VzL25hdmlnYXRpb24tbWVudS9uYXZpZ2F0aW9uLW1lbnUuc2VydmljZSc7XG5pbXBvcnQgeyBHcmlkTmcxQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL2dyaWQvZ3JpZC5jb21wb25lbnQnO1xuaW1wb3J0IHsgVGh1bWJuYWlsTmcxQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL3RodW1ibmFpbC90aHVtYm5haWwuY29tcG9uZW50JztcbmltcG9ydCB7IEhpZXJhcmNoeUJhck5nMUNvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50cy9oaWVyYXJjaHktYmFyL2hpZXJhcmNoeS1iYXIuY29tcG9uZW50JztcbmltcG9ydCB7IENvbnRhY3RzTmcxQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL2NvbnRhY3RzL2NvbnRhY3RzLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBFeHBhbmRJbnB1dE5nMUNvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50cy9leHBhbmQtaW5wdXQvZXhwYW5kLWlucHV0LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBTb3J0RGlyZWN0aW9uVG9nZ2xlTmcxQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL3NvcnQtZGlyZWN0aW9uLXRvZ2dsZS9zb3J0LWRpcmVjdGlvbi10b2dnbGUuY29tcG9uZW50JztcbmltcG9ydCB7IFNlYXJjaFRvb2xiYXJOZzFDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvc2VhcmNoLXRvb2xiYXIvc2VhcmNoLXRvb2xiYXIuY29tcG9uZW50JztcbmltcG9ydCB7IFRyZWVHcmlkTmcxQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL3RyZWUtZ3JpZC90cmVlLWdyaWQuY29tcG9uZW50JztcbmltcG9ydCB7IFNlbGVjdFRhYmxlTmcxQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL3NlbGVjdC10YWJsZS9zZWxlY3QtdGFibGUuY29tcG9uZW50JztcbmltcG9ydCB7IE1hcnF1ZWVXaXphcmROZzFDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvbWFycXVlZS13aXphcmQvbWFycXVlZS13aXphcmQuY29tcG9uZW50JztcbmltcG9ydCB7IFNsaWRlckNoYXJ0TmcxQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL3NsaWRlci1jaGFydC9zbGlkZXItY2hhcnQuZGlyZWN0aXZlJztcblxuY29uc3QgZGVjbGFyYXRpb25zID0gW1xuICAgIENvbnRhY3RzTmcxQ29tcG9uZW50LFxuICAgIEV4cGFuZElucHV0TmcxQ29tcG9uZW50LFxuICAgIEZsb2F0aW5nQWN0aW9uQnV0dG9uTmcxQ29tcG9uZW50LFxuICAgIEZsb3ROZzFDb21wb25lbnQsXG4gICAgR3JpZE5nMUNvbXBvbmVudCxcbiAgICBIaWVyYXJjaHlCYXJOZzFDb21wb25lbnQsXG4gICAgTWFycXVlZVdpemFyZE5nMUNvbXBvbmVudCxcbiAgICBOZXN0ZWREb251dE5nMUNvbXBvbmVudCxcbiAgICBPcmdhbml6YXRpb25DaGFydE5nMUNvbXBvbmVudCxcbiAgICBQYXJ0aXRpb25NYXBOZzFDb21wb25lbnQsXG4gICAgUGVpdHlCYXJDaGFydE5nMUNvbXBvbmVudCxcbiAgICBQZWl0eUxpbmVDaGFydE5nMUNvbXBvbmVudCxcbiAgICBQZWl0eVBpZUNoYXJ0TmcxQ29tcG9uZW50LFxuICAgIFBlaXR5VXBkYXRpbmdMaW5lQ2hhcnROZzFDb21wb25lbnQsXG4gICAgU2Fua2V5TmcxQ29tcG9uZW50LFxuICAgIFNlYXJjaFRvb2xiYXJOZzFDb21wb25lbnQsXG4gICAgU2VsZWN0VGFibGVOZzFDb21wb25lbnQsXG4gICAgU2xpZGVyQ2hhcnROZzFDb21wb25lbnQsXG4gICAgU29jaWFsQ2hhcnROZzFDb21wb25lbnQsXG4gICAgU29ydERpcmVjdGlvblRvZ2dsZU5nMUNvbXBvbmVudCxcbiAgICBUcmVlR3JpZE5nMUNvbXBvbmVudCxcbiAgICBUaHVtYm5haWxOZzFDb21wb25lbnQsXG5dO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtdLFxuICAgIGV4cG9ydHM6IGRlY2xhcmF0aW9ucyxcbiAgICBkZWNsYXJhdGlvbnM6IGRlY2xhcmF0aW9ucyxcbiAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgbmF2aWdhdGlvbk1lbnVTZXJ2aWNlUHJvdmlkZXIsXG4gICAgICAgIHBkZlNlcnZpY2VQcm92aWRlcixcbiAgICAgICAgdGltZUFnb1NlcnZpY2VQcm92aWRlcixcbiAgICAgICAgVGltZUFnb1NlcnZpY2UsXG4gICAgICAgIFBkZlNlcnZpY2UsXG4gICAgICAgIE5hdmlnYXRpb25NZW51U2VydmljZSxcbiAgICBdLFxufSlcbmV4cG9ydCBjbGFzcyBIeWJyaWRNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBQaXBlLCBJbmplY3RhYmxlLCBQaXBlVHJhbnNmb3JtIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBQaXBlKHtcbiAgICBuYW1lOiAnc3RyaW5nRmlsdGVyJ1xufSlcbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBTdHJpbmdGaWx0ZXJQaXBlIGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSB7XG4gICAgdHJhbnNmb3JtKGl0ZW1zOiBhbnlbXSwgdmFsdWU6IHN0cmluZyk6IGFueVtdIHsgIFxuICAgICAgICBpZiAoIWl0ZW1zKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW1zLmZpbHRlcihpdCA9PiBpdC50b0xvd2VyQ2FzZSgpLmluZGV4T2YodmFsdWUudG9Mb3dlckNhc2UoKSkgPj0gMCk7XG4gICAgfVxufSIsImltcG9ydCB7IFN0cmluZ0ZpbHRlclBpcGUgfSBmcm9tICcuL3N0cmluZy1maWx0ZXIucGlwZSc7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGV4cG9ydHM6IFtTdHJpbmdGaWx0ZXJQaXBlXSxcbiAgICBkZWNsYXJhdGlvbnM6IFtTdHJpbmdGaWx0ZXJQaXBlXVxufSlcbmV4cG9ydCBjbGFzcyBTdHJpbmdGaWx0ZXJNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBTdG9yYWdlQWRhcHRlciB9IGZyb20gJy4vc3RvcmFnZS1hZGFwdGVyJztcblxuZXhwb3J0IGNsYXNzIENvb2tpZUFkYXB0ZXIgaW1wbGVtZW50cyBTdG9yYWdlQWRhcHRlciB7XG5cbiAgICBnZXRJdGVtKGtleTogc3RyaW5nKTogc3RyaW5nIHtcblxuICAgICAgICBpZiAoZG9jdW1lbnQuY29va2llKSB7XG5cbiAgICAgICAgICAgIC8vIGdldCBhbGwgdGhlIGNvb2tpZXMgZm9yIHRoaXMgc2l0ZVxuICAgICAgICAgICAgY29uc3QgY29va2llcyA9IGRvY3VtZW50LmNvb2tpZS5zcGxpdCgnOycpO1xuXG4gICAgICAgICAgICAvLyBwcm9jZXNzIHRoZSBjb29raWVzIGludG8gYSBmcm9tIHdlIGNhbiBlYXNpbHkgbWFuYWdlXG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IGNvb2tpZXNcbiAgICAgICAgICAgICAgICAubWFwKGNvb2tpZSA9PiAoeyBrZXk6IGNvb2tpZS5zcGxpdCgnPScpWzBdLnRyaW0oKSwgdmFsdWU6IGNvb2tpZS5zcGxpdCgnPScpWzFdLnRyaW0oKSB9KSlcbiAgICAgICAgICAgICAgICAuZmluZChjb29raWUgPT4gY29va2llLmtleSA9PT0ga2V5KTtcblxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoID8gbWF0Y2gudmFsdWUgOiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgc2V0SXRlbShrZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICBkb2N1bWVudC5jb29raWUgPSBgJHtrZXl9PSR7dmFsdWV9OyBwYXRoPS9gO1xuICAgIH1cblxuICAgIHJlbW92ZUl0ZW0oa2V5OiBzdHJpbmcpOiB2b2lkIHtcblxuICAgICAgICBkb2N1bWVudC5jb29raWUuc3BsaXQoJzsnKS5mb3JFYWNoKGNvb2tpZSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlcVBvcyA9IGNvb2tpZS5pbmRleE9mKCc9Jyk7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gZXFQb3MgPiAtMSA/IGNvb2tpZS5zdWJzdHIoMCwgZXFQb3MpLnRyaW0oKSA6IGNvb2tpZTtcblxuICAgICAgICAgICAgaWYgKG5hbWUgPT09IGtleSkge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IGNvb2tpZS50cmltKCkucmVwbGFjZSgvPS4qLywgYD07ZXhwaXJlcz0ke25ldyBEYXRlKCkudG9VVENTdHJpbmcoKX07cGF0aD0vYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGNsZWFyKCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGNhbGwgcmVtb3ZlIGl0ZW0gb24gZWFjaCBjb29raWVcbiAgICAgICAgZG9jdW1lbnQuY29va2llLnNwbGl0KCc7JykubWFwKGNvb2tpZSA9PiBjb29raWUuc3BsaXQoJz0nKVswXS50cmltKCkpXG4gICAgICAgICAgICAuZm9yRWFjaChjb29raWUgPT4gdGhpcy5yZW1vdmVJdGVtKGNvb2tpZSkpO1xuICAgIH1cblxuICAgIGdldFN1cHBvcnRlZCgpOiBTdG9yYWdlQWRhcHRlciB7XG4gICAgICAgIC8vIGNvb2tpZXMgYXJlIHN1cHBvcnRlZCBpbiBhbGwgYnJvd3NlcnNcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG59IiwiaW1wb3J0IHsgU3RvcmFnZUFkYXB0ZXIgfSBmcm9tICcuL3N0b3JhZ2UtYWRhcHRlcic7XG5pbXBvcnQgeyBDb29raWVBZGFwdGVyIH0gZnJvbSAnLi9jb29raWUtYWRhcHRlcic7XG5cbmV4cG9ydCBjbGFzcyBMb2NhbFN0b3JhZ2VBZGFwdGVyIGltcGxlbWVudHMgU3RvcmFnZUFkYXB0ZXIge1xuXG4gICAgZ2V0SXRlbShrZXk6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICAgIH1cblxuICAgIHNldEl0ZW0oa2V5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmVtb3ZlSXRlbShrZXk6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xuICAgIH1cblxuICAgIGNsZWFyKCk6IHZvaWQge1xuICAgICAgICBsb2NhbFN0b3JhZ2UuY2xlYXIoKTtcbiAgICB9XG5cbiAgICBnZXRTdXBwb3J0ZWQoKTogU3RvcmFnZUFkYXB0ZXIge1xuXG4gICAgICAgIC8vIGlmIGxvY2FsIHN0b3JhZ2UgdmFyaWFibGUgZG9lcyBub3QgZXhpc3QgZmFsbCBiYWNrIHRvIGNvb2tpZXNcbiAgICAgICAgaWYgKCFsb2NhbFN0b3JhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29va2llQWRhcHRlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdHJ5IHRvIG1ha2UgYSB0ZXN0IHNhdmUgdG8gbG9jYWwgc3RvcmFnZSB0byBzZWUgaWYgdGhlcmUgYXJlIGFueSBleGNlcHRpb25zXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgndXgtcGVyc2lzdGVudC1kYXRhLXNlcnZpY2UnLCAndXgtcGVyc2lzdGVudC1kYXRhLXNlcnZpY2UnKTtcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCd1eC1wZXJzaXN0ZW50LWRhdGEtc2VydmljZScpO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvb2tpZUFkYXB0ZXIoKTtcbiAgICAgICAgfVxuICAgIH1cblxufSIsImltcG9ydCB7IFN0b3JhZ2VBZGFwdGVyIH0gZnJvbSAnLi9zdG9yYWdlLWFkYXB0ZXInO1xuaW1wb3J0IHsgQ29va2llQWRhcHRlciB9IGZyb20gJy4vY29va2llLWFkYXB0ZXInO1xuXG5leHBvcnQgY2xhc3MgU2Vzc2lvblN0b3JhZ2VBZGFwdGVyIGltcGxlbWVudHMgU3RvcmFnZUFkYXB0ZXIge1xuXG4gICAgZ2V0SXRlbShrZXk6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgfVxuXG4gICAgc2V0SXRlbShrZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKGtleSwgdmFsdWUpO1xuICAgIH1cblxuICAgIHJlbW92ZUl0ZW0oa2V5OiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xuICAgIH1cblxuICAgIGNsZWFyKCk6IHZvaWQge1xuICAgICAgICBzZXNzaW9uU3RvcmFnZS5jbGVhcigpO1xuICAgIH1cblxuICAgIGdldFN1cHBvcnRlZCgpOiBTdG9yYWdlQWRhcHRlciB7XG5cbiAgICAgICAgLy8gaWYgbG9jYWwgc3RvcmFnZSB2YXJpYWJsZSBkb2VzIG5vdCBleGlzdCBmYWxsIGJhY2sgdG8gY29va2llc1xuICAgICAgICBpZiAoIXNlc3Npb25TdG9yYWdlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvb2tpZUFkYXB0ZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRyeSB0byBtYWtlIGEgdGVzdCBzYXZlIHRvIGxvY2FsIHN0b3JhZ2UgdG8gc2VlIGlmIHRoZXJlIGFyZSBhbnkgZXhjZXB0aW9uc1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbSgndXgtcGVyc2lzdGVudC1kYXRhLXNlcnZpY2UnLCAndXgtcGVyc2lzdGVudC1kYXRhLXNlcnZpY2UnKTtcbiAgICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0oJ3V4LXBlcnNpc3RlbnQtZGF0YS1zZXJ2aWNlJyk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29va2llQWRhcHRlcigpO1xuICAgICAgICB9XG4gICAgfVxuXG59IiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3RvcmFnZUFkYXB0ZXIgfSBmcm9tICcuL2FkYXB0ZXJzL3N0b3JhZ2UtYWRhcHRlcic7XG5pbXBvcnQgeyBDb29raWVBZGFwdGVyIH0gZnJvbSAnLi9hZGFwdGVycy9jb29raWUtYWRhcHRlcic7XG5pbXBvcnQgeyBMb2NhbFN0b3JhZ2VBZGFwdGVyIH0gZnJvbSAnLi9hZGFwdGVycy9sb2NhbC1zdG9yYWdlLWFkYXB0ZXInO1xuaW1wb3J0IHsgU2Vzc2lvblN0b3JhZ2VBZGFwdGVyIH0gZnJvbSAnLi9hZGFwdGVycy9zZXNzaW9uLXN0b3JhZ2UtYWRhcHRlcic7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBQZXJzaXN0ZW50RGF0YVNlcnZpY2Uge1xuXG4gICAgLyoqXG4gICAgICogU2F2ZSB0aGUgaXRlbSBpbiBzb21lIGZvcm0gb2YgcGVyc2lzdGVudCBzdG9yYWdlXG4gICAgICovXG4gICAgc2V0SXRlbShrZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZywgdHlwZTogUGVyc2lzdGVudERhdGFTdG9yYWdlVHlwZSA9IFBlcnNpc3RlbnREYXRhU3RvcmFnZVR5cGUuTG9jYWxTdG9yYWdlKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZ2V0QWRhcHRlcih0eXBlKS5zZXRJdGVtKGtleSwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBhIHN0b3JlZCB2YWx1ZSBmcm9tIHBlcnNpc3RlbnQgc3RvcmFnZVxuICAgICAqL1xuICAgIGdldEl0ZW0oa2V5OiBzdHJpbmcsIHR5cGU6IFBlcnNpc3RlbnREYXRhU3RvcmFnZVR5cGUgPSBQZXJzaXN0ZW50RGF0YVN0b3JhZ2VUeXBlLkxvY2FsU3RvcmFnZSk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEFkYXB0ZXIodHlwZSkuZ2V0SXRlbShrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIHN0b3JlZCB2YWx1ZSBmcm9tIHBlcnNpc3RlbnQgc3RvcmFnZVxuICAgICAqL1xuICAgIHJlbW92ZUl0ZW0oa2V5OiBzdHJpbmcsIHR5cGU6IFBlcnNpc3RlbnREYXRhU3RvcmFnZVR5cGUgPSBQZXJzaXN0ZW50RGF0YVN0b3JhZ2VUeXBlLkxvY2FsU3RvcmFnZSk6IHZvaWQge1xuICAgICAgICB0aGlzLmdldEFkYXB0ZXIodHlwZSkucmVtb3ZlSXRlbShrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIHN0b3JlZCB2YWx1ZSBmcm9tIHBlcnNpc3RlbnQgc3RvcmFnZVxuICAgICAqL1xuICAgIGNsZWFyKHR5cGU6IFBlcnNpc3RlbnREYXRhU3RvcmFnZVR5cGUgPSBQZXJzaXN0ZW50RGF0YVN0b3JhZ2VUeXBlLkxvY2FsU3RvcmFnZSk6IHZvaWQge1xuICAgICAgICB0aGlzLmdldEFkYXB0ZXIodHlwZSkuY2xlYXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGFwcHJvcHJpYXRlIGFkYXB0ZXIgYmFzZWQgb24gdGhlIHR5cGUgcmVxdWVzdGVkXG4gICAgICovXG4gICAgcHJpdmF0ZSBnZXRBZGFwdGVyKHR5cGU6IFBlcnNpc3RlbnREYXRhU3RvcmFnZVR5cGUpOiBTdG9yYWdlQWRhcHRlciB7XG5cbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG5cbiAgICAgICAgICAgIGNhc2UgUGVyc2lzdGVudERhdGFTdG9yYWdlVHlwZS5Db29raWU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb29raWVBZGFwdGVyKCk7XG5cbiAgICAgICAgICAgIGNhc2UgUGVyc2lzdGVudERhdGFTdG9yYWdlVHlwZS5Mb2NhbFN0b3JhZ2U6XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxTdG9yYWdlQWRhcHRlciA9IG5ldyBMb2NhbFN0b3JhZ2VBZGFwdGVyKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmFnZUFkYXB0ZXIuZ2V0U3VwcG9ydGVkKCk7XG5cbiAgICAgICAgICAgIGNhc2UgUGVyc2lzdGVudERhdGFTdG9yYWdlVHlwZS5TZXNzaW9uU3RvcmFnZTpcbiAgICAgICAgICAgICAgICBjb25zdCBzZXNzaW9uU3RvcmFnZUFkYXB0ZXIgPSBuZXcgU2Vzc2lvblN0b3JhZ2VBZGFwdGVyKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlc3Npb25TdG9yYWdlQWRhcHRlci5nZXRTdXBwb3J0ZWQoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGVudW0gUGVyc2lzdGVudERhdGFTdG9yYWdlVHlwZSB7XG4gICAgTG9jYWxTdG9yYWdlLFxuICAgIENvb2tpZSxcbiAgICBTZXNzaW9uU3RvcmFnZVxufSIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IFBlcnNpc3RlbnREYXRhU2VydmljZSB9IGZyb20gJy4vcGVyc2lzdGVudC1kYXRhLnNlcnZpY2UnO1xuXG5ATmdNb2R1bGUoe1xuICAgIHByb3ZpZGVyczogW1BlcnNpc3RlbnREYXRhU2VydmljZV0sXG59KVxuZXhwb3J0IGNsYXNzIFBlcnNpc3RlbnREYXRhTW9kdWxlIHsgfVxuIiwiZXhwb3J0IGFic3RyYWN0IGNsYXNzIFN0b3JhZ2VBZGFwdGVyIHtcbiAgICBhYnN0cmFjdCBnZXRJdGVtKGtleTogc3RyaW5nKTogc3RyaW5nO1xuICAgIGFic3RyYWN0IHNldEl0ZW0oa2V5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpOiB2b2lkO1xuICAgIGFic3RyYWN0IHJlbW92ZUl0ZW0oa2V5OiBzdHJpbmcpOiB2b2lkO1xuICAgIGFic3RyYWN0IGNsZWFyKCk6IHZvaWQ7XG4gICAgYWJzdHJhY3QgZ2V0U3VwcG9ydGVkKCk6IFN0b3JhZ2VBZGFwdGVyO1xufSJdLCJuYW1lcyI6WyJzdGF0ZSIsInRzbGliXzEuX19leHRlbmRzIiwidHNsaWJfMS5fX2Fzc2lnbiIsInN0eWxlIiwiZmlyc3QiLCJtb250aHMiLCJUb29sdGlwRGlyZWN0aXZlIiwiKC8qKiBAdHlwZSB7P30gKi8gKGRyYWd1bGFOYW1lc3BhY2UpKS5kZWZhdWx0IiwidHNsaWJfMS5fX3ZhbHVlcyIsIkRFQ0xBUkFUSU9OUyIsImZpbHRlciIsImZyb20iLCJtYXAiLCJxdWVyeSIsImNvbWJpbmVMYXRlc3QiLCJmaWx0ZXJPcGVyYXRvciIsInVuaXF1ZUlkIiwiZGVsYXkiLCJUeXBlYWhlYWRNb2R1bGUiLCJFWFBPUlRTIiwiRE9DVU1FTlQiLCJTdWJqZWN0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7O0lBNkJJLHlDQUFVOzs7OztJQUFWLFVBQVcsS0FBaUIsRUFBRSxLQUFpQjtRQUMzQyxJQUFJLEtBQUssQ0FBQyxPQUFPLEVBQUU7WUFDZixLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUM7U0FDbkM7S0FDSjs7Z0JBL0JKLFNBQVMsU0FBQztvQkFDUCxRQUFRLEVBQUUsZ0JBQWdCO29CQUMxQixRQUFRLEVBQUUsMHRCQWtCUDtpQkFDTjs7Ozs7MkJBSUksS0FBSzs7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QUFPO3lCQUVVO1lBQ2xDLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFO1lBQy9CLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFO1lBQy9CLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFO1lBQzlCLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFO1lBQzlCLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFO1lBQzlCLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFO1lBQzlCLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFO1lBQzlCLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFO1lBQzlCLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFO1lBQzlCLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFO1lBQzlCLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsRUFBRSxFQUFFO1lBQzdCLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsQ0FBQyxFQUFFO1lBQzFCLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDOUIsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxDQUFDLEdBQUcsRUFBRTtZQUMvQixFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsTUFBTSxFQUFFLENBQUMsR0FBRyxFQUFFO1lBQy9CLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsQ0FBQyxHQUFHLEVBQUU7WUFDL0IsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxDQUFDLEdBQUcsRUFB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LENBQUMsV0FBVyxDQUFDLGFBQWEsRUFBRSxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBQ3ZILFNBQVMsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLGFBQWEsRUFBRSxZQUFZLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBQ2pJLFNBQVMsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLGFBQWEsRUFBRSxZQUFZLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBQ2pJLFNBQVMsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLGFBQWEsRUFBRSxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBQ3ZILFNBQVMsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLGFBQWEsRUFBRSxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDOztRQUdySCxJQUFJLENBQUMsZUFBZSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQzVCLE1BQU0sQ0FBQyxjQUFNLE9B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