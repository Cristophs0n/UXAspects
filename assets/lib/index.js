(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('rxjs/Subject'), require('@angular/common'), require('@angular/router'), require('resize-observer-polyfill'), require('rxjs/ReplaySubject'), require('rxjs/operators'), require('rxjs/BehaviorSubject'), require('@angular/forms'), require('rxjs/observable/combineLatest'), require('@angular/cdk/a11y'), require('angular-split'), require('rxjs/Observable'), require('@angular/cdk/keycodes'), require('@angular/cdk/overlay'), require('@angular/cdk/portal'), require('rxjs/observable/fromEvent'), require('@angular/cdk/observers'), require('rxjs/Subscription'), require('rxjs/observable/from'), require('rxjs/observable/of'), require('dragula/dist/dragula'), require('ngx-bootstrap/dropdown'), require('@angular/animations'), require('ngx-bootstrap/tooltip'), require('rxjs/observable/concat'), require('rxjs/observable/timer'), require('@angular/common/http'), require('rxjs/operators/filter'), require('rxjs-compat/BehaviorSubject'), require('@angular/upgrade/static')) :
    typeof define === 'function' && define.amd ? define('@ux-aspects/ux-aspects', ['exports', '@angular/core', 'rxjs/Subject', '@angular/common', '@angular/router', 'resize-observer-polyfill', 'rxjs/ReplaySubject', 'rxjs/operators', 'rxjs/BehaviorSubject', '@angular/forms', 'rxjs/observable/combineLatest', '@angular/cdk/a11y', 'angular-split', 'rxjs/Observable', '@angular/cdk/keycodes', '@angular/cdk/overlay', '@angular/cdk/portal', 'rxjs/observable/fromEvent', '@angular/cdk/observers', 'rxjs/Subscription', 'rxjs/observable/from', 'rxjs/observable/of', 'dragula/dist/dragula', 'ngx-bootstrap/dropdown', '@angular/animations', 'ngx-bootstrap/tooltip', 'rxjs/observable/concat', 'rxjs/observable/timer', '@angular/common/http', 'rxjs/operators/filter', 'rxjs-compat/BehaviorSubject', '@angular/upgrade/static'], factory) :
    (factory((global['ux-aspects'] = global['ux-aspects'] || {}, global['ux-aspects']['ux-aspects'] = {}),global.ng.core,global.rxjs.Subject,global.ng.common,global.ng.router,null,global.rxjs.ReplaySubject,global.rxjs.operators,global.rxjs.BehaviorSubject,global.ng.forms,global.rxjs['observable/combineLatest'],global.ng.cdk.a11y,null,global.rxjs.Observable,global.ng.cdk.keycodes,global.ng.cdk.overlay,global.ng.cdk.portal,global.rxjs['observable/fromEvent'],global.ng.cdk.observers,global.rxjs.Subscription,global.rxjs['observable/from'],global.rxjs['observable/of'],null,null,global.ng.animations,null,global.rxjs['observable/concat'],global.rxjs['observable/timer'],global.ng.common.http,global.rxjs['operators/filter'],null,global.ng.upgrade.static));
}(this, (function (exports,core,Subject,common,router,ResizeObserver,ReplaySubject,operators,BehaviorSubject,forms,combineLatest,a11y,angularSplit,Observable,keycodes,overlay,portal,fromEvent,observers,Subscription,from,of,dragulaNamespace,dropdown,animations,tooltip,concat,timer,http,filter,BehaviorSubject$1,_static) { 'use strict';

    ResizeObserver = ResizeObserver && ResizeObserver.hasOwnProperty('default') ? ResizeObserver['default'] : ResizeObserver;
    var dragulaNamespace__default = 'default' in dragulaNamespace ? dragulaNamespace['default'] : dragulaNamespace;

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AccordionPanelHeadingDirective = (function () {
        function AccordionPanelHeadingDirective() {
        }
        AccordionPanelHeadingDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'ux-accordion-panel-header'
                    },] }
        ];
        return AccordionPanelHeadingDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AccordionService = (function () {
        function AccordionService() {
            this.collapseOthers = false;
            this.collapse = new Subject.Subject();
        }
        /**
         * @return {?}
         */
        AccordionService.prototype.collapseAll = /**
         * @return {?}
         */
            function () {
                this.collapse.next();
            };
        AccordionService.decorators = [
            { type: core.Injectable }
        ];
        return AccordionService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ uniqueId = 1;
    var AccordionPanelComponent = (function () {
        function AccordionPanelComponent(accordion) {
            var _this = this;
            this.accordion = accordion;
            this.panelId = "ux-accordion-panel-" + uniqueId++;
            this.headingId = this.panelId + "-heading";
            this.disabled = false;
            this.expanded = false;
            this.expandedChange = new core.EventEmitter();
            accordion.collapse.subscribe(function () { return _this.collapse(); });
        }
        /**
         * @return {?}
         */
        AccordionPanelComponent.prototype.toggle = /**
         * @return {?}
         */
            function () {
                if (this.expanded) {
                    this.collapse();
                    return;
                }
                // check if we should collapse others
                if (this.accordion.collapseOthers) {
                    this.accordion.collapseAll();
                }
                // store the new expanded state
                this.expand();
            };
        /**
         * @return {?}
         */
        AccordionPanelComponent.prototype.expand = /**
         * @return {?}
         */
            function () {
                if (this.disabled === false && this.expanded === false) {
                    this.expanded = true;
                    this.expandedChange.next(true);
                }
            };
        /**
         * @return {?}
         */
        AccordionPanelComponent.prototype.collapse = /**
         * @return {?}
         */
            function () {
                if (this.disabled === false && this.expanded === true) {
                    this.expanded = false;
                    this.expandedChange.next(false);
                }
            };
        AccordionPanelComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-accordion-panel',
                        template: "<div class=\"panel-heading\"\n      role=\"button\"\n      [tabindex]=\"disabled ? -1 : 0\"\n      [id]=\"headingId\"\n      [attr.aria-expanded]=\"expanded\"\n      [attr.aria-controls]=\"panelId\"\n      (click)=\"toggle()\"\n      (keydown.enter)=\"toggle()\"\n      (keydown.space)=\"toggle(); $event.preventDefault()\"\n      (keydown.spacebar)=\"toggle(); $event.preventDefault()\">\n\n  <div class=\"panel-title\">\n      {{ heading }}\n      <ng-content select=\"ux-accordion-panel-header\"></ng-content>\n  </div>\n</div>\n\n<div [id]=\"panelId\"\n      class=\"panel-collapse collapse\"\n      [class.in]=\"expanded\"\n      role=\"tabpanel\"\n      [attr.aria-labelledby]=\"headingId\">\n\n  <div class=\"panel-body\">\n    <ng-content></ng-content>\n  </div>\n</div>",
                        host: {
                            'class': 'panel panel-default',
                            'role': 'tab'
                        }
                    }] }
        ];
        /** @nocollapse */
        AccordionPanelComponent.ctorParameters = function () {
            return [
                { type: AccordionService }
            ];
        };
        AccordionPanelComponent.propDecorators = {
            panelId: [{ type: core.Input }],
            headingId: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            heading: [{ type: core.Input }],
            expanded: [{ type: core.Input }, { type: core.HostBinding, args: ['class.panel-open',] }],
            expandedChange: [{ type: core.Output }]
        };
        return AccordionPanelComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AccordionComponent = (function () {
        function AccordionComponent(_accordion) {
            this._accordion = _accordion;
        }
        Object.defineProperty(AccordionComponent.prototype, "collapseOthers", {
            set: /**
             * @param {?} collapseOthers
             * @return {?}
             */ function (collapseOthers) {
                this._accordion.collapseOthers = collapseOthers;
            },
            enumerable: true,
            configurable: true
        });
        AccordionComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-accordion',
                        template: "<ng-content></ng-content>",
                        providers: [AccordionService],
                        host: {
                            'class': 'panel-group',
                            'role': 'tablist',
                            'aria-multiselectable': 'true'
                        }
                    }] }
        ];
        /** @nocollapse */
        AccordionComponent.ctorParameters = function () {
            return [
                { type: AccordionService }
            ];
        };
        AccordionComponent.propDecorators = {
            collapseOthers: [{ type: core.Input }]
        };
        return AccordionComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AccordionModule = (function () {
        function AccordionModule() {
        }
        AccordionModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule
                        ],
                        declarations: [
                            AccordionComponent,
                            AccordionPanelComponent,
                            AccordionPanelHeadingDirective
                        ],
                        exports: [
                            AccordionComponent,
                            AccordionPanelComponent,
                            AccordionPanelHeadingDirective
                        ]
                    },] }
        ];
        return AccordionModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var BreadcrumbsComponent = (function () {
        function BreadcrumbsComponent() {
        }
        /**
         * @param {?} event
         * @param {?} crumb
         * @return {?}
         */
        BreadcrumbsComponent.prototype.clickCrumb = /**
         * @param {?} event
         * @param {?} crumb
         * @return {?}
         */
            function (event, crumb) {
                if (crumb.onClick) {
                    crumb.onClick.call(null, event);
                }
            };
        BreadcrumbsComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-breadcrumbs',
                        template: "<nav aria-label=\"Breadcrumb\">\n    <ol class=\"breadcrumb\">\n        <li *ngFor=\"let crumb of crumbs\">\n\n            <!-- If there is a router link then use a tag -->\n            <a *ngIf=\"crumb.routerLink || crumb.onClick\"\n                tabindex=\"0\"\n                [routerLink]=\"crumb.routerLink\"\n                [fragment]=\"crumb.fragment\"\n                [queryParams]=\"crumb.queryParams\"\n                (click)=\"clickCrumb($event, crumb)\">\n                {{ crumb.title }}\n            </a>\n\n            <!-- If there is not router link then display text in a span -->\n            <span *ngIf=\"!crumb.routerLink && !crumb.onClick\">{{ crumb.title }}</span>\n        </li>\n    </ol>\n</nav>"
                    }] }
        ];
        BreadcrumbsComponent.propDecorators = {
            crumbs: [{ type: core.Input }]
        };
        return BreadcrumbsComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var BreadcrumbsModule = (function () {
        function BreadcrumbsModule() {
        }
        BreadcrumbsModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            router.RouterModule
                        ],
                        exports: [BreadcrumbsComponent],
                        declarations: [BreadcrumbsComponent]
                    },] }
        ];
        return BreadcrumbsModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b)
            if (b.hasOwnProperty(p))
                d[p] = b[p]; };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
                if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
        }
        return t;
    };
    function __awaiter(thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [0, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m)
            return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length)
                    o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ResizeService = (function () {
        function ResizeService(_zone) {
            this._zone = _zone;
            this._observer = new ResizeObserver(this.elementDidResize.bind(this));
            this._targets = new WeakMap();
        }
        /**
         * @return {?}
         */
        ResizeService.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._observer.disconnect();
            };
        /**
         * @param {?} target
         * @return {?}
         */
        ResizeService.prototype.addResizeListener = /**
         * @param {?} target
         * @return {?}
         */
            function (target) {
                var _this = this;
                this._zone.runOutsideAngular(function () { return _this._observer.observe(target); });
                if (this._targets.has(target)) {
                    return this._targets.get(target);
                }
                else {
                    var /** @type {?} */ emitter = new ReplaySubject.ReplaySubject();
                    this._targets.set(target, emitter);
                    return emitter;
                }
            };
        /**
         * @param {?} target
         * @return {?}
         */
        ResizeService.prototype.removeResizeListener = /**
         * @param {?} target
         * @return {?}
         */
            function (target) {
                this._observer.unobserve(target);
            };
        /**
         * @param {?} entries
         * @return {?}
         */
        ResizeService.prototype.elementDidResize = /**
         * @param {?} entries
         * @return {?}
         */
            function (entries) {
                var _this = this;
                this._zone.run(function () {
                    try {
                        for (var entries_1 = __values(entries), entries_1_1 = entries_1.next(); !entries_1_1.done; entries_1_1 = entries_1.next()) {
                            var entry = entries_1_1.value;
                            if (_this._targets.has(/** @type {?} */ (entry.target))) {
                                var /** @type {?} */ emitter = _this._targets.get(/** @type {?} */ (entry.target));
                                emitter.next({ width: ((entry.target)).offsetWidth, height: ((entry.target)).offsetHeight });
                            }
                        }
                    }
                    catch (e_1_1) {
                        e_1 = { error: e_1_1 };
                    }
                    finally {
                        try {
                            if (entries_1_1 && !entries_1_1.done && (_a = entries_1.return))
                                _a.call(entries_1);
                        }
                        finally {
                            if (e_1)
                                throw e_1.error;
                        }
                    }
                    var e_1, _a;
                });
            };
        ResizeService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        ResizeService.ctorParameters = function () {
            return [
                { type: core.NgZone }
            ];
        };
        return ResizeService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ResizeDirective = (function () {
        function ResizeDirective(_elementRef, _resizeService, _ngZone) {
            this._elementRef = _elementRef;
            this._resizeService = _resizeService;
            this._ngZone = _ngZone;
            this.throttle = 0;
            this.uxResize = new core.EventEmitter();
        }
        /**
         * @return {?}
         */
        ResizeDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this._subscription = this._resizeService.addResizeListener(this._elementRef.nativeElement)
                    .pipe(operators.debounceTime(this.throttle))
                    .subscribe(function (event) { return _this._ngZone.run(function () { return _this.uxResize.emit(event); }); });
            };
        /**
         * @return {?}
         */
        ResizeDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._resizeService.removeResizeListener(this._elementRef.nativeElement);
                this._subscription.unsubscribe();
            };
        ResizeDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxResize]',
                        providers: [ResizeService]
                    },] }
        ];
        /** @nocollapse */
        ResizeDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: ResizeService },
                { type: core.NgZone }
            ];
        };
        ResizeDirective.propDecorators = {
            throttle: [{ type: core.Input }],
            uxResize: [{ type: core.Output }]
        };
        return ResizeDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ResizeModule = (function () {
        function ResizeModule() {
        }
        ResizeModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [ResizeDirective],
                        declarations: [ResizeDirective],
                        providers: [ResizeService]
                    },] }
        ];
        return ResizeModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var CardTabContentDirective = (function () {
        function CardTabContentDirective() {
        }
        CardTabContentDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxCardTabContent]'
                    },] }
        ];
        return CardTabContentDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var CardTabsService = (function () {
        function CardTabsService() {
            var _this = this;
            this.tab$ = new BehaviorSubject.BehaviorSubject(null);
            this.tabs$ = new BehaviorSubject.BehaviorSubject([]);
            this.position$ = new BehaviorSubject.BehaviorSubject('top');
            // when a tab is added or removed ensure we always select one if any are available
            this._subscription = this.tabs$.pipe(operators.filter(function (tabs) { return !_this.tab$.value || !tabs.find(function (tab) { return tab === _this.tab$.value; }); })).subscribe(function (tabs) { return _this.tab$.next(tabs.length > 0 ? tabs[0] : null); });
        }
        /**
         * @return {?}
         */
        CardTabsService.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * Add a tab to the list of tabs
         */
        /**
         * Add a tab to the list of tabs
         * @param {?} tab
         * @return {?}
         */
        CardTabsService.prototype.addTab = /**
         * Add a tab to the list of tabs
         * @param {?} tab
         * @return {?}
         */
            function (tab) {
                this.tabs$.next(__spread(this.tabs$.value, [tab]));
            };
        /**
         * Remove a tab from the list
         */
        /**
         * Remove a tab from the list
         * @param {?} tab
         * @return {?}
         */
        CardTabsService.prototype.removeTab = /**
         * Remove a tab from the list
         * @param {?} tab
         * @return {?}
         */
            function (tab) {
                this.tabs$.next(this.tabs$.value.filter(function (_tab) { return _tab !== tab; }));
            };
        /**
         * Select the tab
         */
        /**
         * Select the tab
         * @param {?} tab
         * @return {?}
         */
        CardTabsService.prototype.select = /**
         * Select the tab
         * @param {?} tab
         * @return {?}
         */
            function (tab) {
                this.tab$.next(tab);
            };
        /**
         * Set the position of the tab content
         */
        /**
         * Set the position of the tab content
         * @param {?} position
         * @return {?}
         */
        CardTabsService.prototype.setPosition = /**
         * Set the position of the tab content
         * @param {?} position
         * @return {?}
         */
            function (position) {
                this.position$.next(position);
            };
        CardTabsService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        CardTabsService.ctorParameters = function () { return []; };
        return CardTabsService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var CardTabComponent = (function () {
        function CardTabComponent(_tabService) {
            var _this = this;
            this._tabService = _tabService;
            this.active$ = this._tabService.tab$.pipe(operators.map(function (tab) { return tab === _this; }));
            this._tabService.addTab(this);
        }
        /**
         * @return {?}
         */
        CardTabComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._tabService.removeTab(this);
            };
        CardTabComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-card-tab',
                        template: "<ng-content *ngIf=\"active$ | async\"></ng-content>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        CardTabComponent.ctorParameters = function () {
            return [
                { type: CardTabsService }
            ];
        };
        CardTabComponent.propDecorators = {
            content: [{ type: core.ContentChild, args: [CardTabContentDirective, { read: core.TemplateRef },] }]
        };
        return CardTabComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var CardTabsetComponent = (function () {
        function CardTabsetComponent(tabService) {
            this.tabService = tabService;
            this.offset = 0;
            this.bounds = { lower: 0, upper: 0 };
        }
        Object.defineProperty(CardTabsetComponent.prototype, "position", {
            get: /**
             * @return {?}
             */ function () {
                return this.tabService.position$.getValue();
            },
            set: /**
             * @param {?} direction
             * @return {?}
             */ function (direction) {
                this.tabService.setPosition(direction);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} tab
         * @param {?} element
         * @return {?}
         */
        CardTabsetComponent.prototype.select = /**
         * @param {?} tab
         * @param {?} element
         * @return {?}
         */
            function (tab, element) {
                // select the tab
                this.tabService.select(tab);
                // ensure the tab is moved into view if required
                this.moveIntoView(element);
            };
        /**
         * @param {?} dimensions
         * @return {?}
         */
        CardTabsetComponent.prototype.resize = /**
         * @param {?} dimensions
         * @return {?}
         */
            function (dimensions) {
                this._width = dimensions.width;
                this._innerWidth = this.tablist.nativeElement.scrollWidth;
                this.bounds.lower = 0;
                this.bounds.upper = -(this._innerWidth - this._width);
            };
        /**
         * @return {?}
         */
        CardTabsetComponent.prototype.previous = /**
         * @return {?}
         */
            function () {
                this.offset += this._width;
                // ensure it remains within the allowed bounds
                this.offset = Math.min(this.offset, this.bounds.lower);
            };
        /**
         * @return {?}
         */
        CardTabsetComponent.prototype.next = /**
         * @return {?}
         */
            function () {
                this.offset -= this._width;
                // ensure it remains within the allowed bounds
                this.offset = Math.max(this.offset, this.bounds.upper);
            };
        /**
         * @param {?} element
         * @return {?}
         */
        CardTabsetComponent.prototype.moveIntoView = /**
         * @param {?} element
         * @return {?}
         */
            function (element) {
                // if we dont have the dimensions we cant check
                if (!this._width || !this._innerWidth) {
                    return;
                }
                // get the current element bounds
                var offsetLeft = element.offsetLeft, offsetWidth = element.offsetWidth;
                var _a = getComputedStyle(element), marginLeft = _a.marginLeft, marginRight = _a.marginRight;
                // calculate the visible area
                var /** @type {?} */ viewportStart = Math.abs(this.offset);
                var /** @type {?} */ viewportEnd = viewportStart + this._width;
                var /** @type {?} */ cardWidth = parseFloat(marginLeft) + offsetWidth + parseFloat(marginRight);
                // if we need to move to the left - figure out how much
                if (offsetLeft < viewportStart) {
                    this.offset -= (offsetLeft - parseFloat(marginLeft)) - viewportStart;
                }
                // if we need to move to the right - figure out how much
                if ((offsetLeft + cardWidth) > viewportEnd) {
                    this.offset -= (offsetLeft + cardWidth) - viewportEnd;
                }
            };
        CardTabsetComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-card-tabset',
                        template: "<div class=\"card-tab-content\" role=\"tabpanel\" *ngIf=\"(tabService.tab$ | async)\">\r\n    <ng-content></ng-content>\r\n</div>\r\n\r\n<div class=\"card-tabs\" #tabs>\r\n\r\n    <button class=\"card-tabs-paging-btn card-tabs-paging-btn-previous\" aria-label=\"Previous Tabs\" (click)=\"previous()\" *ngIf=\"offset < bounds.lower\">\r\n        <i class=\"hpe-icon hpe-previous\"></i>\r\n    </button>\r\n\r\n    <div class=\"card-tabs-list\" role=\"tablist\" #tablist (uxResize)=\"resize($event)\" [style.transform]=\"'translateX(' + offset + 'px)'\">\r\n\r\n        <div class=\"card-tab\"\r\n            role=\"tab\"\r\n            tabindex=\"0\" #card\r\n            *ngFor=\"let tab of tabService.tabs$ | async\"\r\n            [ngClass]=\"tabService.position$ | async\"\r\n            [class.active]=\"tab.active$ | async\"\r\n            [attr.aria-selected]=\"tab.active$ | async\"\r\n            (click)=\"select(tab, card)\"\r\n            (focus)=\"tabs.scrollLeft = 0\"\r\n            (keydown.enter)=\"select(tab, card)\">\r\n\r\n            <ng-container [ngTemplateOutlet]=\"tab.content\"></ng-container>\r\n        </div>\r\n\r\n    </div>\r\n\r\n    <button class=\"card-tabs-paging-btn card-tabs-paging-btn-next\" aria-label=\"Next Tabs\" (click)=\"next()\" *ngIf=\"offset > bounds.upper\">\r\n        <i class=\"hpe-icon hpe-next\"></i>\r\n    </button>\r\n</div>",
                        providers: [CardTabsService]
                    }] }
        ];
        /** @nocollapse */
        CardTabsetComponent.ctorParameters = function () {
            return [
                { type: CardTabsService }
            ];
        };
        CardTabsetComponent.propDecorators = {
            position: [{ type: core.HostBinding, args: ['class',] }, { type: core.Input }],
            tablist: [{ type: core.ViewChild, args: ['tablist',] }]
        };
        return CardTabsetComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var CardTabsModule = (function () {
        function CardTabsModule() {
        }
        CardTabsModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            ResizeModule
                        ],
                        declarations: [CardTabsetComponent, CardTabComponent, CardTabContentDirective],
                        exports: [CardTabsetComponent, CardTabComponent, CardTabContentDirective]
                    },] }
        ];
        return CardTabsModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ CHECKBOX_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return CheckboxComponent; }),
        multi: true
    };
    var /** @type {?} */ uniqueCheckboxId = 0;
    var CheckboxComponent = (function () {
        function CheckboxComponent() {
            this._checkboxId = "ux-checkbox-" + ++uniqueCheckboxId;
            this.id = this._checkboxId;
            this.tabindex = 0;
            this.clickable = true;
            this.simplified = false;
            this.indeterminateValue = -1;
            this.disabled = false;
            this.ariaLabel = '';
            this.ariaLabelledby = null;
            this.valueChange = new core.EventEmitter();
            this._value = false;
            this.indeterminate = false;
            this.focused = false;
            this.onTouchedCallback = function () { };
            this.onChangeCallback = function () { };
        }
        Object.defineProperty(CheckboxComponent.prototype, "value", {
            get: /**
             * @return {?}
             */ function () {
                return this._value;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._value = value;
                // determine if it is in the indeterminate state
                this.indeterminate = this._value === this.indeterminateValue;
                // determine the checked state
                this.ariaChecked = this.indeterminate ? 'mixed' : this._value;
                // invoke change event
                this.valueChange.emit(this._value);
                // call callback
                this.onChangeCallback(this._value);
                this.onTouchedCallback();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CheckboxComponent.prototype, "inputId", {
            get: /**
             * @return {?}
             */ function () {
                return (this.id || this._checkboxId) + "-input";
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        CheckboxComponent.prototype.toggle = /**
         * @return {?}
         */
            function () {
                if (this.disabled || !this.clickable) {
                    return;
                }
                if (this.value === this.indeterminateValue) {
                    this.value = true;
                    return;
                }
                // toggle the checked state
                this.value = !this.value;
            };
        // Functions required to update ngModel
        /**
         * @param {?} value
         * @return {?}
         */
        CheckboxComponent.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (value !== this._value) {
                    this._value = value;
                }
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        CheckboxComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onChangeCallback = fn;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        CheckboxComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onTouchedCallback = fn;
            };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        CheckboxComponent.prototype.setDisabledState = /**
         * @param {?} isDisabled
         * @return {?}
         */
            function (isDisabled) {
                this.disabled = isDisabled;
            };
        CheckboxComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-checkbox',
                        template: "<label [attr.for]=\"inputId\"\n       class=\"ux-checkbox\"\n       [class.ux-checkbox-checked]=\"value === true\"\n       [class.ux-checkbox-indeterminate]=\"indeterminate\"\n       [class.ux-checkbox-simplified]=\"simplified\"\n       [class.ux-checkbox-disabled]=\"disabled\"\n       [class.ux-checkbox-focused]=\"focused\">\n\n    <div class=\"ux-checkbox-container\">\n        <input type=\"checkbox\"\n               class=\"ux-checkbox-input\"\n               [id]=\"inputId\"\n               [required]=\"required\"\n               [checked]=\"value\"\n               [attr.value]=\"value\"\n               [disabled]=\"disabled\"\n               [attr.name]=\"name\"\n               [tabindex]=\"tabindex\"\n               [indeterminate]=\"indeterminate\"\n               [attr.aria-label]=\"ariaLabel\"\n               [attr.aria-labelledby]=\"ariaLabelledby\"\n               [attr.aria-checked]=\"ariaChecked\"\n               (focus)=\"focused = true\"\n               (blur)=\"focused = false\"\n               (change)=\"$event.stopPropagation()\"\n               (click)=\"toggle()\">\n    </div>\n\n    <span class=\"ux-checkbox-label\">\n        <ng-content></ng-content>\n    </span>\n</label>\n",
                        providers: [CHECKBOX_VALUE_ACCESSOR]
                    }] }
        ];
        CheckboxComponent.propDecorators = {
            id: [{ type: core.Input }],
            name: [{ type: core.Input }],
            required: [{ type: core.Input }],
            tabindex: [{ type: core.Input }],
            clickable: [{ type: core.Input }],
            simplified: [{ type: core.Input }],
            indeterminateValue: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            ariaLabel: [{ type: core.Input, args: ['aria-label',] }],
            ariaLabelledby: [{ type: core.Input, args: ['aria-labelledby',] }],
            valueChange: [{ type: core.Output }],
            value: [{ type: core.Input }]
        };
        return CheckboxComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var CheckboxModule = (function () {
        function CheckboxModule() {
        }
        CheckboxModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [forms.FormsModule],
                        exports: [CheckboxComponent],
                        declarations: [CheckboxComponent]
                    },] }
        ];
        return CheckboxModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ColorService = (function () {
        function ColorService() {
            this._colorSet = colorSets.keppel;
            if (this._colorSet.colorClassSet) {
                this.setColors();
            }
            else {
                for (var /** @type {?} */ key in this._colorSet.colorValueSet) {
                    this._colors[key] = this.getColorValueByHex(this._colorSet.colorValueSet[key]);
                }
            }
        }
        /**
         * @return {?}
         */
        ColorService.prototype.setColors = /**
         * @return {?}
         */
            function () {
                this._html = '';
                for (var /** @type {?} */ key in this._colorSet.colorClassSet) {
                    this._html += '<div class="' + this._colorSet.colorClassSet[key] + '-color"></div>';
                }
                this._element = document.createElement('div');
                this._element.className = 'color-chart';
                this._element.innerHTML = this._html;
                document.body.appendChild(this._element);
                this._colors = {};
                for (var /** @type {?} */ key in this._colorSet.colorClassSet) {
                    this._colors[key] = this.getColorValue(this._colorSet.colorClassSet[key]);
                }
                this._element.parentNode.removeChild(this._element);
            };
        /**
         * @param {?} color
         * @return {?}
         */
        ColorService.prototype.getColorValueByHex = /**
         * @param {?} color
         * @return {?}
         */
            function (color) {
                var /** @type {?} */ hex = color.replace('#', '');
                var /** @type {?} */ r = parseInt(hex.substring(0, 2), 16).toString();
                var /** @type {?} */ g = parseInt(hex.substring(2, 4), 16).toString();
                var /** @type {?} */ b = parseInt(hex.substring(4, 6), 16).toString();
                return new ThemeColor(r, g, b, '1');
            };
        /**
         * @param {?} color
         * @return {?}
         */
        ColorService.prototype.getColorValue = /**
         * @param {?} color
         * @return {?}
         */
            function (color) {
                var /** @type {?} */ target = this._element.querySelector('.' + this._colorSet.colorClassSet[color] + '-color');
                if (!target) {
                    throw new Error('Invalid color');
                }
                var /** @type {?} */ colorValue = window.getComputedStyle(target).backgroundColor;
                var /** @type {?} */ rgba = colorValue.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+(?:\.\d+)?))?\)$/);
                return new ThemeColor(rgba[1], rgba[2], rgba[3], rgba[4]);
            };
        /**
         * @param {?} color
         * @return {?}
         */
        ColorService.prototype.getColor = /**
         * @param {?} color
         * @return {?}
         */
            function (color) {
                var /** @type {?} */ themeColor = this._colors[this.resolveColorName(color)];
                if (!themeColor) {
                    throw new Error('Color not found: ' + color);
                }
                return new ThemeColor(themeColor.getRed(), themeColor.getGreen(), themeColor.getBlue(), themeColor.getAlpha());
            };
        /**
         * @return {?}
         */
        ColorService.prototype.getColorSet = /**
         * @return {?}
         */
            function () {
                return this._colorSet;
            };
        /**
         * @param {?} colorSet
         * @return {?}
         */
        ColorService.prototype.setColorSet = /**
         * @param {?} colorSet
         * @return {?}
         */
            function (colorSet) {
                this._colorSet = colorSet;
                this._colors = {};
                if (this._colorSet.colorClassSet) {
                    this.setColors();
                }
                else {
                    for (var /** @type {?} */ key in this._colorSet.colorValueSet) {
                        this._colors[key] = this.getColorValueByHex(this._colorSet.colorValueSet[key]);
                    }
                }
            };
        /**
         * @param {?} value
         * @return {?}
         */
        ColorService.prototype.resolve = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (!value) {
                    return;
                }
                var /** @type {?} */ colorName = this.resolveColorName(value);
                for (var /** @type {?} */ color in this._colors) {
                    if (colorName === color.toLowerCase()) {
                        return this.getColor(colorName).toRgba();
                    }
                }
                return value;
            };
        /**
         * @param {?=} value
         * @return {?}
         */
        ColorService.prototype.resolveColorName = /**
         * @param {?=} value
         * @return {?}
         */
            function (value) {
                if (value === void 0) {
                    value = '';
                }
                return value.replace(/\s+/g, '-').toLowerCase();
            };
        ColorService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        ColorService.ctorParameters = function () { return []; };
        return ColorService;
    }());
    var ThemeColor = (function () {
        function ThemeColor(r, g, b, a) {
            this._r = r;
            this._g = g;
            this._b = b;
            this._a = a === undefined ? '1' : a;
        }
        /**
         * @param {?} value
         * @return {?}
         */
        ThemeColor.parse = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                var /** @type {?} */ r, /** @type {?} */ g, /** @type {?} */ b, /** @type {?} */ a = '1';
                var /** @type {?} */ rgbaPattern = /^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+(?:\.\d+)?))?\)$/;
                var /** @type {?} */ shortHexPattern = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
                var /** @type {?} */ longHexPattern = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i;
                var /** @type {?} */ rgbaMatch = value.match(rgbaPattern);
                var /** @type {?} */ shortHexMatch = value.match(shortHexPattern);
                var /** @type {?} */ longHexMatch = value.match(longHexPattern);
                if (rgbaMatch) {
                    r = rgbaMatch[1];
                    g = rgbaMatch[2];
                    b = rgbaMatch[3];
                    a = rgbaMatch[4] ? rgbaMatch[4] : '1';
                }
                else if (longHexMatch) {
                    r = parseInt(longHexMatch[1], 16).toString();
                    g = parseInt(longHexMatch[2], 16).toString();
                    b = parseInt(longHexMatch[3], 16).toString();
                }
                else if (shortHexMatch) {
                    r = parseInt(shortHexMatch[1] + shortHexMatch[1], 16).toString();
                    g = parseInt(shortHexMatch[2] + shortHexMatch[2], 16).toString();
                    b = parseInt(shortHexMatch[3] + shortHexMatch[3], 16).toString();
                }
                else {
                    throw new Error("Cannot parse color - " + value + " is not a valid color.");
                }
                return new ThemeColor(r, g, b, a);
            };
        /**
         * @return {?}
         */
        ThemeColor.prototype.toHex = /**
         * @return {?}
         */
            function () {
                var /** @type {?} */ red = parseInt(this._r).toString(16);
                var /** @type {?} */ green = parseInt(this._g).toString(16);
                var /** @type {?} */ blue = parseInt(this._b).toString(16);
                if (red.length < 2) {
                    red = '0' + red;
                }
                if (green.length < 2) {
                    green = '0' + green;
                }
                if (blue.length < 2) {
                    blue = '0' + blue;
                }
                return '#' + red + green + blue;
            };
        /**
         * @return {?}
         */
        ThemeColor.prototype.toRgb = /**
         * @return {?}
         */
            function () {
                return 'rgb(' + this._r + ', ' + this._g + ', ' + this._b + ')';
            };
        /**
         * @return {?}
         */
        ThemeColor.prototype.toRgba = /**
         * @return {?}
         */
            function () {
                return 'rgba(' + this._r + ', ' + this._g + ', ' + this._b + ', ' + this._a + ')';
            };
        /**
         * @return {?}
         */
        ThemeColor.prototype.getRed = /**
         * @return {?}
         */
            function () {
                return this._r;
            };
        /**
         * @return {?}
         */
        ThemeColor.prototype.getGreen = /**
         * @return {?}
         */
            function () {
                return this._g;
            };
        /**
         * @return {?}
         */
        ThemeColor.prototype.getBlue = /**
         * @return {?}
         */
            function () {
                return this._b;
            };
        /**
         * @return {?}
         */
        ThemeColor.prototype.getAlpha = /**
         * @return {?}
         */
            function () {
                return this._a;
            };
        /**
         * @param {?} red
         * @return {?}
         */
        ThemeColor.prototype.setRed = /**
         * @param {?} red
         * @return {?}
         */
            function (red) {
                this._r = red;
                return this;
            };
        /**
         * @param {?} green
         * @return {?}
         */
        ThemeColor.prototype.setGreen = /**
         * @param {?} green
         * @return {?}
         */
            function (green) {
                this._g = green;
                return this;
            };
        /**
         * @param {?} blue
         * @return {?}
         */
        ThemeColor.prototype.setBlue = /**
         * @param {?} blue
         * @return {?}
         */
            function (blue) {
                this._b = blue;
                return this;
            };
        /**
         * @param {?} alpha
         * @return {?}
         */
        ThemeColor.prototype.setAlpha = /**
         * @param {?} alpha
         * @return {?}
         */
            function (alpha) {
                this._a = alpha.toString();
                return this;
            };
        return ThemeColor;
    }());
    var /** @type {?} */ colorSets = {
        keppel: {
            colorClassSet: {
                'primary': 'primary',
                'accent': 'accent',
                'secondary': 'secondary',
                'alternate1': 'alternate1',
                'alternate2': 'alternate2',
                'alternate3': 'alternate3',
                'vibrant1': 'vibrant1',
                'vibrant2': 'vibrant2',
                'grey1': 'grey1',
                'grey2': 'grey2',
                'grey3': 'grey3',
                'grey4': 'grey4',
                'grey5': 'grey5',
                'grey6': 'grey6',
                'grey7': 'grey7',
                'grey8': 'grey8',
                'chart1': 'chart1',
                'chart2': 'chart2',
                'chart3': 'chart3',
                'chart4': 'chart4',
                'chart5': 'chart5',
                'chart6': 'chart6',
                'ok': 'ok',
                'warning': 'warning',
                'critical': 'critical',
                'partition1': 'partition1',
                'partition9': 'partition9',
                'partition10': 'partition10',
                'partition11': 'partition11',
                'partition12': 'partition12',
                'partition13': 'partition13',
                'partition14': 'partition14',
                'social-chart-node': 'social-chart-node',
                'social-chart-edge': 'social-chart-edge'
            }
        },
        microFocus: {
            'colorValueSet': {
                'cerulean': '#1668c1',
                'aqua': '#29ceff',
                'aquamarine': '#2fd6c3',
                'fuchsia': '#c6179d',
                'indigo': '#7425ad',
                'dark-blue': '#231ca5',
                'white': '#ffffff',
                'slightly-gray': '#f5f7f8',
                'bright-gray': '#f1f2f3',
                'gray': '#dcdedf',
                'silver': '#bdbec0',
                'dim-gray': '#656668',
                'dark-gray': '#323435',
                'black': '#000000',
                'crimson-negative': '#e5004c',
                'apricot': '#f48b34',
                'yellow': '#fcdb1f',
                'green-positive': '#1aac60',
                'ultramarine': '#3939c6',
                'skyblue': '#00abf3',
                'pale-aqua': '#43e4ff',
                'pale-green': '#1ffbba',
                'lime': '#75da4d',
                'orange': '#ffce00',
                'magenta': '#eb23c2',
                'pale-purple': '#ba47e2',
                'dark-ultramarine': '#271782',
                'steelblue': '#014272',
                'arctic-blue': '#0b8eac',
                'emerald': '#00a989',
                'olive': '#5bba36',
                'goldenrod': '#ffb000',
                'purple': '#9b1e83',
                'pale-eggplant': '#5216ac',
                'red': '#ff454f',
                'pale-amber': '#ffb24d',
                'pale-lemon': '#fde159',
                'pale-emerald': '#33c180',
                'plum': '#b21646',
                'copper': '#e57828',
                'amber': '#ffc002',
                'leaf-green': '#118c4f',
                'forest-green': '#00645a',
                'primary': '#0073e7',
                'accent': '#7425ad',
                'secondary': '#ffffff',
                'alternate1': '#29ceff',
                'alternate2': '#2fd6c3',
                'alternate3': '#c6179d',
                'vibrant1': '#43e4ff',
                'vibrant2': '#ffce00',
                'grey1': '#000000',
                'grey2': '#323435',
                'grey3': '#656668',
                'grey4': '#bdbec0',
                'grey5': '#dcdedf',
                'grey6': '#f1f2f3',
                'grey7': '#f5f7f8',
                'grey8': '#ffffff',
                'chart1': '#3939c6',
                'chart2': '#00abf3',
                'chart3': '#75da4d',
                'chart4': '#ffce00',
                'chart5': '#eb23c2',
                'chart6': '#ba47e2',
                'ok': '#1aac60',
                'warning': '#f48b34',
                'critical': 'e5004c',
                'partition1': '#7425ad',
                'partition9': '#5216ac',
                'partition10': '#5bba36',
                'partition11': '#014272',
                'partition12': '#ffb000',
                'partition13': '#bdbec0',
                'partition14': '#271782',
                'social-chart-node': '#ff00ff',
                'social-chart-edge': '#ff00ff'
            }
        }
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    // Values corresponding to stylesheet
    var /** @type {?} */ BUTTON_MARGIN = 8;
    var /** @type {?} */ BUTTON_WIDTHS = {
        'sm': 26,
        'md': 32,
        'lg': 40
    };
    var /** @type {?} */ uniqueId$1 = 0;
    var ColorPickerComponent = (function () {
        function ColorPickerComponent() {
            this.id = "ux-color-picker-" + uniqueId$1++;
            this.buttonStyle = 'circle';
            this.showTooltips = false;
            this.showInput = false;
            this.inputMode = 'hex';
            this.selectedChange = new core.EventEmitter();
            this.inputSubmit = new core.EventEmitter();
            this.cssWidth = 'auto';
            this.colors = [];
            this.selected$ = new BehaviorSubject.BehaviorSubject(null);
            this.columns$ = new BehaviorSubject.BehaviorSubject(-1);
            this.buttonSize$ = new BehaviorSubject.BehaviorSubject('md');
            this.inputPatterns = {
                'hex': /^#(?:[\da-fA-F]{3}){1,2}$/,
                'rgba': /^(?:rgb\(\d{1,3},\s*\d{1,3},\s*\d{1,3}\))|(?:rgba\(\d{1,3},\s*\d{1,3},\s*\d{1,3},\s*\d(\.\d+)?\))$/
            };
            this._onDestroy = new Subject.Subject();
        }
        Object.defineProperty(ColorPickerComponent.prototype, "inputColors", {
            set: /**
             * @param {?} colors
             * @return {?}
             */ function (colors) {
                var /** @type {?} */ normalizedColors;
                // If it's a 1d array, convert it to 2d
                if (colors.length === 0 || !Array.isArray(colors[0])) {
                    normalizedColors = [/** @type {?} */ (colors)];
                }
                else {
                    normalizedColors = /** @type {?} */ (colors);
                }
                // Convert any string colors to ColorPickerColor
                this.colors = normalizedColors.map(function (row) {
                    return row.map(function (color) { return color instanceof ColorPickerColor ? color : new ColorPickerColor(color, color); });
                });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColorPickerComponent.prototype, "selected", {
            set: /**
             * @param {?} selected
             * @return {?}
             */ function (selected) {
                this.selected$.next(selected);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColorPickerComponent.prototype, "columns", {
            set: /**
             * @param {?} columns
             * @return {?}
             */ function (columns) {
                this.columns$.next(columns);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColorPickerComponent.prototype, "buttonSize", {
            set: /**
             * @param {?} buttonSize
             * @return {?}
             */ function (buttonSize) {
                this.buttonSize$.next(buttonSize);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ColorPickerComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // Skip emitting the initial selectedChange
                this.selected$.pipe(operators.pairwise(), operators.takeUntil(this._onDestroy)).subscribe(function (_a) {
                    var _b = __read(_a, 2), prev = _b[0], curr = _b[1];
                    if (prev) {
                        _this.selectedChange.emit(curr);
                    }
                });
                // Set the width based on column count and button size
                combineLatest.combineLatest(this.columns$, this.buttonSize$)
                    .pipe(operators.takeUntil(this._onDestroy))
                    .subscribe(function (_a) {
                    var _b = __read(_a, 2), columns = _b[0], buttonSize = _b[1];
                    if (columns > 0) {
                        var /** @type {?} */ w = columns * (BUTTON_WIDTHS[buttonSize] + (2 * BUTTON_MARGIN));
                        _this.cssWidth = w + "px";
                    }
                    else {
                        _this.cssWidth = 'auto';
                    }
                });
            };
        /**
         * @return {?}
         */
        ColorPickerComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @param {?} input
         * @param {?} mode
         * @return {?}
         */
        ColorPickerComponent.prototype.updateColorValue = /**
         * @param {?} input
         * @param {?} mode
         * @return {?}
         */
            function (input, mode) {
                if (this.inputPatterns[mode].test(input)) {
                    this.selected$.next(new ColorPickerColor('Custom', input, mode));
                }
            };
        /**
         * @return {?}
         */
        ColorPickerComponent.prototype.toggleColorEntryType = /**
         * @return {?}
         */
            function () {
                this.inputMode = (this.inputMode === 'hex') ? 'rgba' : 'hex';
            };
        ColorPickerComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-color-picker',
                        exportAs: 'ux-color-picker',
                        template: "<div class=\"ux-color-picker\" uxTabbableList direction=\"horizontal\">\n    <div class=\"ux-color-picker-swatch\">\n        <div *ngFor=\"let row of colors\" class=\"ux-color-picker-swatch-row\">\n            <div *ngFor=\"let color of row\"\n                class=\"ux-color-picker-color\"\n                [class.ux-small]=\"(buttonSize$ | async) === 'sm'\"\n                [class.ux-large]=\"(buttonSize$ | async) === 'lg'\"\n                [class.ux-circle]=\"buttonStyle === 'circle'\"\n                [class.ux-selected]=\"color === (selected$ | async)\">\n                <button type=\"button\"\n                    attr.aria-label=\"Select color {{color.name}}\" i18n-aria-label\n                    aria-selected=\"color === (selected$ | async)\"\n                    class=\"btn btn-icon\"\n                    [style.background-color]=\"color.rgba\"\n                    (click)=\"selected$.next(color)\"\n                    uxTabbableListItem\n                    [uxTooltip]=\"color.name\"\n                    [tooltipDisabled]=\"!showTooltips\"></button>\n            </div>\n        </div>\n    </div>\n    <div *ngIf=\"showInput\" class=\"ux-color-picker-input-panel\">\n        <div class=\"ux-color-picker-input-header\">\n            <div class=\"ux-color-picker-preview\"\n                [style.background-color]=\"(selected$ | async).rgba\"\n                [class.ux-circle]=\"buttonStyle === 'circle'\"></div>\n            <label *ngIf=\"inputMode === 'hex'\" attr.for=\"{{id}}-input-field\">HEX</label>\n            <label *ngIf=\"inputMode === 'rgba'\" attr.for=\"{{id}}-input-field\">RGBA</label>\n            <button type=\"button\"\n                attr.aria-label=\"Switch input mode to {{inputMode === 'hex' ? 'RGBA' : 'hex'}}\" i18n-aria-label\n                class=\"btn btn-link btn-icon button-secondary ux-color-picker-input-toggle\"\n                (click)=\"toggleColorEntryType(); $event.stopPropagation()\">\n                <span class=\"hpe-icon hpe-chevron-right\"></span>\n            </button>\n        </div>\n        <div class=\"ux-color-picker-input\"\n            [class.has-error]=\"inputField.errors\"\n            [class.has-feedback]=\"inputField.errors\">\n            <input type=\"text\"\n                attr.id=\"{{id}}-input-field\"\n                attr.aria-description=\"Edit {{inputMode}} color value\" i18n-aria-description\n                class=\"form-control\"\n                #inputField=\"ngModel\"\n                [ngModel]=\"(selected$ | async)[inputMode]\"\n                (ngModelChange)=\"updateColorValue($event, inputMode)\"\n                [pattern]=\"inputPatterns[inputMode].source\"\n                (keyup.enter)=\"inputSubmit.emit()\">\n            <span class=\"hpe-icon hpe-alert form-control-feedback\"></span>\n        </div>\n    </div>\n</div>\n"
                    }] }
        ];
        ColorPickerComponent.propDecorators = {
            id: [{ type: core.Input }, { type: core.HostBinding, args: ['attr.id',] }],
            inputColors: [{ type: core.Input, args: ['colors',] }],
            selected: [{ type: core.Input }],
            columns: [{ type: core.Input }],
            buttonStyle: [{ type: core.Input }],
            buttonSize: [{ type: core.Input }],
            showTooltips: [{ type: core.Input }],
            showInput: [{ type: core.Input }],
            inputMode: [{ type: core.Input }],
            selectedChange: [{ type: core.Output }],
            inputSubmit: [{ type: core.Output }],
            cssWidth: [{ type: core.HostBinding, args: ['style.width',] }]
        };
        return ColorPickerComponent;
    }());
    /**
     * Type representing a color, including its descriptive name.
     */
    var /**
     * Type representing a color, including its descriptive name.
     */ ColorPickerColor = (function () {
        function ColorPickerColor(name, value, inputMode) {
            this.name = name;
            this._color = ThemeColor.parse(value);
            // Preserve the format entered by the user if it's valid
            if (inputMode === 'hex') {
                this._originalHexValue = value;
            }
            else if (inputMode === 'rgba') {
                this._originalRgbaValue = value;
            }
        }
        Object.defineProperty(ColorPickerColor.prototype, "hex", {
            /**
             * Hex value of the color, e.g. `#ffffff`.
             */
            get: /**
             * Hex value of the color, e.g. `#ffffff`.
             * @return {?}
             */ function () {
                return this._originalHexValue ? this._originalHexValue : this._color.toHex();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColorPickerColor.prototype, "rgba", {
            /**
             * RGBA value of the color, e.g. `rgba(255, 255, 255, 1)`.
             */
            get: /**
             * RGBA value of the color, e.g. `rgba(255, 255, 255, 1)`.
             * @return {?}
             */ function () {
                return this._originalRgbaValue ? this._originalRgbaValue : this._color.toRgba();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColorPickerColor.prototype, "r", {
            get: /**
             * @return {?}
             */ function () {
                return parseInt(this._color.getRed());
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColorPickerColor.prototype, "g", {
            get: /**
             * @return {?}
             */ function () {
                return parseInt(this._color.getGreen());
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColorPickerColor.prototype, "b", {
            get: /**
             * @return {?}
             */ function () {
                return parseInt(this._color.getBlue());
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ColorPickerColor.prototype, "a", {
            get: /**
             * @return {?}
             */ function () {
                return parseFloat(this._color.getAlpha());
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ColorPickerColor.prototype.toString = /**
         * @return {?}
         */
            function () {
                return this._color.toRgba();
            };
        return ColorPickerColor;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FocusWithinDirective = (function () {
        function FocusWithinDirective(_elementRef, _focusMonitor, ngZone) {
            var _this = this;
            this._elementRef = _elementRef;
            this._focusMonitor = _focusMonitor;
            this.uxFocusWithin = new core.EventEmitter();
            this.uxBlurWithin = new core.EventEmitter();
            _focusMonitor.monitor(this._elementRef.nativeElement, true)
                .subscribe(function (origin) { return ngZone.run(function () { return origin ? _this.uxFocusWithin.emit() : _this.uxBlurWithin.emit(); }); });
        }
        /**
         * @return {?}
         */
        FocusWithinDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._focusMonitor.stopMonitoring(this._elementRef.nativeElement);
            };
        FocusWithinDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxFocusWithin],[uxBlurWithin]',
                    },] }
        ];
        /** @nocollapse */
        FocusWithinDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: a11y.FocusMonitor },
                { type: core.NgZone }
            ];
        };
        FocusWithinDirective.propDecorators = {
            uxFocusWithin: [{ type: core.Output }],
            uxBlurWithin: [{ type: core.Output }]
        };
        return FocusWithinDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SplitterAccessibilityDirective = (function () {
        function SplitterAccessibilityDirective(_elementRef, _renderer, _platform, _splitter) {
            var _this = this;
            this._elementRef = _elementRef;
            this._renderer = _renderer;
            this._platform = _platform;
            this._splitter = _splitter;
            /**
             * Emit an event whenever the gutter is moved using the keyboard
             */
            this.gutterKeydown = new core.EventEmitter();
            /**
             * Store all the gutter elements
             */
            this._gutters = [];
            /**
             * Teardown our observables on destroy
             */
            this._onDestroy = new Subject.Subject();
            // update aria values when the a gutter is dragged
            _splitter.dragProgress
                .pipe(operators.takeUntil(this._onDestroy))
                .subscribe(function () { return _this.updateGutterAttributes(); });
        }
        /** Once initialised make the gutters accessible */
        /**
         * Once initialised make the gutters accessible
         * @return {?}
         */
        SplitterAccessibilityDirective.prototype.ngAfterViewInit = /**
         * Once initialised make the gutters accessible
         * @return {?}
         */
            function () {
                var _this = this;
                // find the gutters
                this.onGutterChange();
                // if the number of split areas change then update the gutters and apply aria properties
                this.areas.changes.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.onGutterChange(); });
                // we can't know when additional split-gutters appear using ContentChildren as the directive class is not exported and selector doesn't work - use mutation observer instead
                if (common.isPlatformBrowser(this._platform)) {
                    // create the mutation observer
                    this._observer = new MutationObserver(function () { return _this.onGutterChange(); });
                    // begin observing the child nodes
                    this._observer.observe(this._elementRef.nativeElement, { childList: true });
                }
            };
        /** Destroy all observables and observers */
        /**
         * Destroy all observables and observers
         * @return {?}
         */
        SplitterAccessibilityDirective.prototype.ngOnDestroy = /**
         * Destroy all observables and observers
         * @return {?}
         */
            function () {
                if (this._observer) {
                    this._observer.disconnect();
                }
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /** We should focus the gutter when it is clicked */
        /**
         * We should focus the gutter when it is clicked
         * @param {?} event
         * @return {?}
         */
        SplitterAccessibilityDirective.prototype.onClick = /**
         * We should focus the gutter when it is clicked
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this.isSplitterGutter(/** @type {?} */ (event.target))) {
                    ((event.target)).focus();
                }
            };
        /**
         * Find all the gutters and set their attributes
         * @return {?}
         */
        SplitterAccessibilityDirective.prototype.onGutterChange = /**
         * Find all the gutters and set their attributes
         * @return {?}
         */
            function () {
                this._gutters = this.getGutters();
                this.setGutterAttributes();
            };
        /**
         * Get all the gutter elements
         * @return {?}
         */
        SplitterAccessibilityDirective.prototype.getGutters = /**
         * Get all the gutter elements
         * @return {?}
         */
            function () {
                // This function uses DOM accessing properties - which won't work if server side rendered
                if (common.isPlatformBrowser(this._platform)) {
                    var /** @type {?} */ gutters = [];
                    for (var /** @type {?} */ idx = 0; idx < this._elementRef.nativeElement.children.length; idx++) {
                        var /** @type {?} */ node = this._elementRef.nativeElement.children.item(idx);
                        if (this.isSplitterGutter(/** @type {?} */ (node))) {
                            gutters.push(/** @type {?} */ (node));
                        }
                    }
                    return gutters;
                }
                return [];
            };
        /**
         * Set the appropriate attributes on the gutter elements
         * @return {?}
         */
        SplitterAccessibilityDirective.prototype.setGutterAttributes = /**
         * Set the appropriate attributes on the gutter elements
         * @return {?}
         */
            function () {
                var _this = this;
                // apply attribute to every gutter
                this._gutters.forEach(function (gutter) {
                    // apply the separator role
                    // apply the separator role
                    _this._renderer.setAttribute(gutter, 'role', 'separator');
                    // make the gutters tabbable
                    // make the gutters tabbable
                    _this._renderer.setAttribute(gutter, 'tabindex', '0');
                    // set the value now aria property
                    // set the value now aria property
                    _this.updateGutterAttributes();
                });
            };
        /**
         * Apply the aria attribute values
         * @return {?}
         */
        SplitterAccessibilityDirective.prototype.updateGutterAttributes = /**
         * Apply the aria attribute values
         * @return {?}
         */
            function () {
                var _this = this;
                // update the value now properties of each gutter
                this._gutters.forEach(function (gutter, idx) {
                    _this.setGutterValueNow(gutter, idx);
                    _this.setGutterValueMin(gutter, idx);
                    _this.setGutterValueMax(gutter, idx);
                });
            };
        /**
         * Apply the value now aria attribute
         * @param {?} gutter
         * @param {?} index
         * @return {?}
         */
        SplitterAccessibilityDirective.prototype.setGutterValueNow = /**
         * Apply the value now aria attribute
         * @param {?} gutter
         * @param {?} index
         * @return {?}
         */
            function (gutter, index) {
                // get the matching split area
                var /** @type {?} */ area = this._splitter.displayedAreas[index];
                // indicate the size
                this._renderer.setAttribute(gutter, 'aria-valuenow', "" + Math.round(area.size * 100));
            };
        /**
         * Apply the value min aria attribute
         * @param {?} gutter
         * @param {?} index
         * @return {?}
         */
        SplitterAccessibilityDirective.prototype.setGutterValueMin = /**
         * Apply the value min aria attribute
         * @param {?} gutter
         * @param {?} index
         * @return {?}
         */
            function (gutter, index) {
                // get the matching split area
                var /** @type {?} */ area = this.areas.toArray()[index];
                // indicate the minimum size
                this._renderer.setAttribute(gutter, 'aria-valuemin', "" + Math.round(area.minSize * 100));
            };
        /**
         * Apply the value max aria attribute
         * @param {?} gutter
         * @param {?} index
         * @return {?}
         */
        SplitterAccessibilityDirective.prototype.setGutterValueMax = /**
         * Apply the value max aria attribute
         * @param {?} gutter
         * @param {?} index
         * @return {?}
         */
            function (gutter, index) {
                // get every other splitter area
                var /** @type {?} */ availableSize = this.areas
                    .filter(function (_area, idx) { return index !== idx; })
                    .reduce(function (total, area) { return total + area.minSize; }, 0);
                // indicate the minimum size
                this._renderer.setAttribute(gutter, 'aria-valuemax', "" + (100 - Math.round(availableSize * 100)));
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SplitterAccessibilityDirective.prototype.onKeydown = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this.isSplitterGutter(/** @type {?} */ (event.target))) {
                    this.gutterKeydown.emit(event);
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SplitterAccessibilityDirective.prototype.onIncreaseKey = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // only perform a move if a gutter is focused
                if (this.isSplitterGutter(/** @type {?} */ (event.target))) {
                    this.setGutterPosition(/** @type {?} */ (event.target), -0.01);
                    // stop the browser from scrolling
                    event.preventDefault();
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SplitterAccessibilityDirective.prototype.onDecreaseKey = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // only perform a move if a gutter is focused
                if (this.isSplitterGutter(/** @type {?} */ (event.target))) {
                    this.setGutterPosition(/** @type {?} */ (event.target), 0.01);
                    // stop the browser from scrolling
                    event.preventDefault();
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SplitterAccessibilityDirective.prototype.onHomeKey = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this.isSplitterGutter(/** @type {?} */ (event.target))) {
                    // get the affected panels
                    var /** @type {?} */ areas = this.getAreasFromGutter(/** @type {?} */ (event.target));
                    // set the previous area to it's minimum size
                    var /** @type {?} */ delta = areas.previous.size - areas.previous.comp.minSize;
                    // update the sizes accordingly
                    this.setGutterPosition(/** @type {?} */ (event.target), delta);
                    // stop the browser from scrolling
                    event.preventDefault();
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SplitterAccessibilityDirective.prototype.onEndKey = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this.isSplitterGutter(/** @type {?} */ (event.target))) {
                    // get the affected panels
                    var /** @type {?} */ areas = this.getAreasFromGutter(/** @type {?} */ (event.target));
                    // set the next area to it's minimum size
                    var /** @type {?} */ delta = areas.next.size - areas.next.comp.minSize;
                    // update the sizes accordingly
                    this.setGutterPosition(/** @type {?} */ (event.target), -delta);
                    // stop the browser from scrolling
                    event.preventDefault();
                }
            };
        /**
         * Determine if an element is a gutter
         * @param {?} element
         * @return {?}
         */
        SplitterAccessibilityDirective.prototype.isSplitterGutter = /**
         * Determine if an element is a gutter
         * @param {?} element
         * @return {?}
         */
            function (element) {
                return element.tagName === 'SPLIT-GUTTER';
            };
        /**
         * Update the gutter position
         * @param {?} gutter
         * @param {?} delta
         * @return {?}
         */
        SplitterAccessibilityDirective.prototype.setGutterPosition = /**
         * Update the gutter position
         * @param {?} gutter
         * @param {?} delta
         * @return {?}
         */
            function (gutter, delta) {
                // get the affected panels
                var /** @type {?} */ areas = this.getAreasFromGutter(gutter);
                // ensure we can perform the resize
                if (areas.previous.size - delta < areas.previous.comp.minSize || areas.next.size + delta < areas.next.comp.minSize) {
                    return;
                }
                // perform the resize
                areas.previous.size -= delta;
                areas.next.size += delta;
                // update the splitter - this is a private method but we need to call it
                ((this._splitter)).refreshStyleSizes();
                // update the gutter aria values
                this.updateGutterAttributes();
            };
        /**
         * Get the split areas associated with a given gutter
         * @param {?} gutter
         * @return {?}
         */
        SplitterAccessibilityDirective.prototype.getAreasFromGutter = /**
         * Get the split areas associated with a given gutter
         * @param {?} gutter
         * @return {?}
         */
            function (gutter) {
                var /** @type {?} */ index = this._gutters.indexOf(gutter);
                return {
                    previous: this._splitter.displayedAreas[index],
                    next: this._splitter.displayedAreas[index + 1]
                };
            };
        SplitterAccessibilityDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'split'
                    },] }
        ];
        /** @nocollapse */
        SplitterAccessibilityDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Renderer2 },
                { type: String, decorators: [{ type: core.Inject, args: [core.PLATFORM_ID,] }] },
                { type: angularSplit.SplitComponent }
            ];
        };
        SplitterAccessibilityDirective.propDecorators = {
            gutterKeydown: [{ type: core.Output }],
            areas: [{ type: core.ContentChildren, args: [angularSplit.SplitAreaDirective,] }],
            onClick: [{ type: core.HostListener, args: ['click', ['$event'],] }],
            onKeydown: [{ type: core.HostListener, args: ['keydown', ['$event'],] }],
            onIncreaseKey: [{ type: core.HostListener, args: ['keydown.ArrowDown', ['$event'],] }, { type: core.HostListener, args: ['keydown.ArrowRight', ['$event'],] }],
            onDecreaseKey: [{ type: core.HostListener, args: ['keydown.ArrowUp', ['$event'],] }, { type: core.HostListener, args: ['keydown.ArrowLeft', ['$event'],] }],
            onHomeKey: [{ type: core.HostListener, args: ['keydown.Home', ['$event'],] }],
            onEndKey: [{ type: core.HostListener, args: ['keydown.End', ['$event'],] }]
        };
        return SplitterAccessibilityDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * This is a simple RxJS operator to allow us to avoid the
     * "expression has changed after it was checked issue"
     * by making the subscription asynchronous. We could just use a
     * delay operator but this uses a timeout which is significantly
     * slower than using requestAnimationFrame.
     */
    var /** @type {?} */ tick = function () {
        return function (source) {
            return new Observable.Observable(function (subscriber) {
                source.subscribe({
                    next: /**
                     * @param {?} value
                     * @return {?}
                     */ function (value) { requestAnimationFrame(function () { return subscriber.next(value); }); },
                    error: /**
                     * @param {?} err
                     * @return {?}
                     */ function (err) { subscriber.error(err); },
                    complete: /**
                     * @return {?}
                     */ function () { subscriber.complete(); },
                });
            });
        };
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TabbableListService = (function () {
        function TabbableListService() {
            this.hierarchy = false;
            this.allowAltModifier = true;
            this.allowCtrlModifier = true;
            this._onDestroy = new Subject.Subject();
        }
        /**
         * @return {?}
         */
        TabbableListService.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @param {?} items
         * @param {?} direction
         * @param {?} wrap
         * @return {?}
         */
        TabbableListService.prototype.initialize = /**
         * @param {?} items
         * @param {?} direction
         * @param {?} wrap
         * @return {?}
         */
            function (items, direction, wrap) {
                var _this = this;
                // store the items
                this._items = items;
                // create the new focus key manager
                this.focusKeyManager = new a11y.FocusKeyManager(items);
                // set the direction of the list
                direction === 'vertical' ? this.focusKeyManager.withVerticalOrientation() : this.focusKeyManager.withHorizontalOrientation('ltr');
                this._direction = direction;
                // enable wrapping if required
                if (wrap) {
                    this.focusKeyManager.withWrap();
                }
                // make sure the first item in the list is tabbable
                this.setFirstItemTabbable();
                // call the init function on each item
                this._items.forEach(function (item) { return item.onInit(); });
                // if the list changes we need to ensure there is always at least one tabbable item
                this._items.changes.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () {
                    // call the on init function on any new items
                    // call the on init function on any new items
                    _this._items.filter(function (item) { return !item.initialized; }).forEach(function (item) { return item.onInit(); });
                    // ensure there is at least one item tabbable at all times
                    // ensure there is at least one item tabbable at all times
                    _this.ensureTabbableItem();
                });
            };
        /**
         * @param {?} item
         * @return {?}
         */
        TabbableListService.prototype.activate = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                if (!item) {
                    return;
                }
                // get the item index
                var /** @type {?} */ index = this._items.toArray().indexOf(item);
                // active the item if it is not already active
                if (this.focusKeyManager.activeItemIndex !== index) {
                    this.focusKeyManager.setActiveItem(index);
                }
            };
        /**
         * @param {?} item
         * @return {?}
         */
        TabbableListService.prototype.isItemActive = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                return this.focusKeyManager.activeItem.id === item.id;
            };
        /**
         * @return {?}
         */
        TabbableListService.prototype.setFirstItemTabbable = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // delay to prevent expression changed after check error
                setTimeout(function () {
                    if (_this._items.first) {
                        _this._items.first.tabindex = 0;
                    }
                });
            };
        /**
         * @return {?}
         */
        TabbableListService.prototype.ensureTabbableItem = /**
         * @return {?}
         */
            function () {
                // check to see if any item is tabbable
                var /** @type {?} */ active = this._items.find(function (item) { return item.tabindex === 0; });
                if (!active) {
                    this.setFirstItemTabbable();
                }
            };
        /**
         * @return {?}
         */
        TabbableListService.prototype.focusTabbableItem = /**
         * @return {?}
         */
            function () {
                if (!this._items) {
                    return;
                }
                // find the item in the list with a tab index
                var /** @type {?} */ index = this._items.toArray().findIndex(function (item) { return item.tabindex === 0; });
                // if an item was found then focus it
                if (index !== -1) {
                    this.focusKeyManager.setActiveItem(index);
                }
            };
        /**
         * @param {?} source
         * @param {?} event
         * @return {?}
         */
        TabbableListService.prototype.onKeydown = /**
         * @param {?} source
         * @param {?} event
         * @return {?}
         */
            function (source, event) {
                // prevent anything happening when modifier keys are pressed if they have been disabled
                if (!this.allowAltModifier && event.altKey || !this.allowCtrlModifier && event.ctrlKey) {
                    return;
                }
                this.focusKeyManager.onKeydown(event);
                if (this.hierarchy) {
                    if ((this._direction === 'horizontal' && event.keyCode === keycodes.DOWN_ARROW) ||
                        (this._direction === 'vertical' && event.keyCode === keycodes.RIGHT_ARROW)) {
                        source.keyboardExpanded$.next(true);
                    }
                    else if ((this._direction === 'horizontal' && event.keyCode === keycodes.UP_ARROW) ||
                        (this._direction === 'vertical' && event.keyCode === keycodes.LEFT_ARROW)) {
                        if (source.children.length > 0 && source.expanded) {
                            source.keyboardExpanded$.next(false);
                        }
                        else if (source.parent) {
                            source.parent.keyboardExpanded$.next(false);
                        }
                    }
                }
            };
        /**
         * @param {?} list
         * @return {?}
         */
        TabbableListService.prototype.sortItemsByHierarchy = /**
         * @param {?} list
         * @return {?}
         */
            function (list) {
                var /** @type {?} */ topLevel = [];
                // Populating children - clear previously generated collection
                list.forEach(function (item) { return item.children = []; });
                // Populating children - map from child -> parent relationship
                list.forEach(function (item) {
                    if (item.parent) {
                        item.parent.children.push(item);
                    }
                    else {
                        topLevel.push(item);
                    }
                });
                // Flatten the tree to produce the cursor key order
                var /** @type {?} */ result = this.flattenHierarchy(topLevel);
                return result;
            };
        /**
         * @param {?} items
         * @return {?}
         */
        TabbableListService.prototype.flattenHierarchy = /**
         * @param {?} items
         * @return {?}
         */
            function (items) {
                var _this = this;
                var /** @type {?} */ flatList = [];
                items.forEach(function (item) {
                    item.children.sort(function (a, b) { return a.rank - b.rank; });
                    var /** @type {?} */ descendants = _this.flattenHierarchy(item.children);
                    flatList.push.apply(flatList, __spread([item], descendants));
                });
                return flatList;
            };
        TabbableListService.decorators = [
            { type: core.Injectable }
        ];
        return TabbableListService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ nextId = 0;
    var TabbableListItemDirective = (function () {
        function TabbableListItemDirective(_tabbableList, _elementRef) {
            var _this = this;
            this._tabbableList = _tabbableList;
            this._elementRef = _elementRef;
            this.rank = 0;
            this.disabled = false;
            this.expanded = false;
            this.expandedChange = new core.EventEmitter();
            this.tabindex = -1;
            this.id = nextId++;
            this.initialized = false;
            this.children = [];
            this.keyboardExpanded$ = new Subject.Subject();
            this._onDestroy = new Subject.Subject();
            this.keyboardExpanded$.pipe(tick(), operators.takeUntil(this._onDestroy)).subscribe(function (expanded) {
                // Emit event which may alter the DOM
                // Emit event which may alter the DOM
                _this.expandedChange.emit(expanded);
                // Activate the appropriate item
                if (expanded) {
                    if (_this.children.length > 0) {
                        _this._tabbableList.activate(_this.children[0]);
                    }
                }
                else {
                    _this._tabbableList.activate(_this);
                }
            });
        }
        /**
         * @return {?}
         */
        TabbableListItemDirective.prototype.onInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.initialized = true;
                this._tabbableList.focusKeyManager.change
                    .pipe(operators.takeUntil(this._onDestroy), operators.map(function () { return _this._tabbableList.isItemActive(_this); }))
                    .subscribe(function (active) { return _this.tabindex = active ? 0 : -1; });
            };
        /**
         * @return {?}
         */
        TabbableListItemDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                // check if this is the currently focused item - if so we need to make another item tabbable
                if (this.tabindex === 0) {
                    this._tabbableList.setFirstItemTabbable();
                }
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @return {?}
         */
        TabbableListItemDirective.prototype.focus = /**
         * @return {?}
         */
            function () {
                // apply focus to the element
                this._elementRef.nativeElement.focus();
                // ensure the focus key manager updates the active item correctly
                this._tabbableList.activate(this);
            };
        /**
         * @param {?} event
         * @return {?}
         */
        TabbableListItemDirective.prototype.onKeydown = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this._tabbableList.onKeydown(this, event);
            };
        TabbableListItemDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxTabbableListItem]',
                        exportAs: 'ux-tabbable-list-item'
                    },] }
        ];
        /** @nocollapse */
        TabbableListItemDirective.ctorParameters = function () {
            return [
                { type: TabbableListService },
                { type: core.ElementRef }
            ];
        };
        TabbableListItemDirective.propDecorators = {
            parent: [{ type: core.Input }],
            rank: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            expanded: [{ type: core.Input }],
            expandedChange: [{ type: core.Output }],
            tabindex: [{ type: core.HostBinding }],
            focus: [{ type: core.HostListener, args: ['focus',] }],
            onKeydown: [{ type: core.HostListener, args: ['keydown', ['$event'],] }]
        };
        return TabbableListItemDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TabbableListDirective = (function () {
        function TabbableListDirective(_tabbableList) {
            this._tabbableList = _tabbableList;
            /**
             * Determine whether the up/down arrows should be used or the left/right arrows
             */
            this.direction = 'vertical';
            /**
             * Indicate whether or not focus should loop back to the first element after the last
             */
            this.wrap = true;
            /**
             * Indicate whether or not the first item should receive focus on show - useful for modals and popovers
             */
            this.focusOnShow = false;
            /**
             * Indicate whether or not focus should be returned to the previous element (only applicable when using focusOnShow)
             */
            this.returnFocus = false;
        }
        Object.defineProperty(TabbableListDirective.prototype, "hierarchy", {
            /** Enabling handling of hierarchical lists via use of the `TabbableListItemDirective.parent` property. */
            set: /**
             * Enabling handling of hierarchical lists via use of the `TabbableListItemDirective.parent` property.
             * @param {?} value
             * @return {?}
             */ function (value) { this._tabbableList.hierarchy = value; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TabbableListDirective.prototype, "allowAltModifier", {
            /** Prevent keyboard interaction when alt modifier key is pressed */
            set: /**
             * Prevent keyboard interaction when alt modifier key is pressed
             * @param {?} value
             * @return {?}
             */ function (value) { this._tabbableList.allowAltModifier = value; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TabbableListDirective.prototype, "allowCtrlModifier", {
            /** Prevent keyboard interaction when ctrl modifier key is pressed */
            set: /**
             * Prevent keyboard interaction when ctrl modifier key is pressed
             * @param {?} value
             * @return {?}
             */ function (value) { this._tabbableList.allowCtrlModifier = value; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TabbableListDirective.prototype, "focusKeyManager", {
            get: /**
             * @return {?}
             */ function () {
                return this._tabbableList.focusKeyManager;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        TabbableListDirective.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // store the currently focused element
                this._focusedElement = /** @type {?} */ (document.activeElement);
                if (this._tabbableList.hierarchy) {
                    // Sort items in a hierarchy
                    this._orderedItems = new core.QueryList();
                    this._orderedItems.reset(this._tabbableList.sortItemsByHierarchy(this.items));
                    // Ensure that the child items remain sorted
                    this.items.changes.subscribe(function () {
                        _this._orderedItems.reset(_this._tabbableList.sortItemsByHierarchy(_this.items));
                        _this._orderedItems.notifyOnChanges();
                    });
                }
                else {
                    // Items are already in order
                    this._orderedItems = this.items;
                }
                // Set up the focus monitoring
                this._tabbableList.initialize(this._orderedItems, this.direction, this.wrap);
                // focus the first element if specified
                if (this.focusOnShow) {
                    this._tabbableList.focusKeyManager.setFirstItemActive();
                }
            };
        /**
         * @return {?}
         */
        TabbableListDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                var _this = this;
                if (this.returnFocus && this._focusedElement instanceof HTMLElement) {
                    setTimeout(function () { return _this._focusedElement.focus(); });
                }
            };
        /**
         * @return {?}
         */
        TabbableListDirective.prototype.focus = /**
         * @return {?}
         */
            function () {
                if (this._tabbableList.focusKeyManager && this._tabbableList.focusKeyManager.activeItem) {
                    this._tabbableList.focusKeyManager.activeItem.focus();
                }
            };
        /**
         * @return {?}
         */
        TabbableListDirective.prototype.focusTabbableItem = /**
         * @return {?}
         */
            function () {
                this._tabbableList.focusTabbableItem();
            };
        TabbableListDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxTabbableList]',
                        exportAs: 'ux-tabbable-list',
                        providers: [TabbableListService]
                    },] }
        ];
        /** @nocollapse */
        TabbableListDirective.ctorParameters = function () {
            return [
                { type: TabbableListService }
            ];
        };
        TabbableListDirective.propDecorators = {
            direction: [{ type: core.Input }],
            wrap: [{ type: core.Input }],
            focusOnShow: [{ type: core.Input }],
            returnFocus: [{ type: core.Input }],
            hierarchy: [{ type: core.Input }],
            allowAltModifier: [{ type: core.Input }],
            allowCtrlModifier: [{ type: core.Input }],
            items: [{ type: core.ContentChildren, args: [TabbableListItemDirective, { descendants: true },] }]
        };
        return TabbableListDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AccessibilityModule = (function () {
        function AccessibilityModule() {
        }
        AccessibilityModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            FocusWithinDirective,
                            TabbableListDirective,
                            TabbableListItemDirective,
                            SplitterAccessibilityDirective
                        ],
                        imports: [
                            a11y.A11yModule
                        ],
                        exports: [
                            FocusWithinDirective,
                            TabbableListDirective,
                            TabbableListItemDirective,
                            SplitterAccessibilityDirective
                        ]
                    },] }
        ];
        return AccessibilityModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ NUMBER_PICKER_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return NumberPickerComponent; }),
        multi: true
    };
    var NumberPickerComponent = (function () {
        function NumberPickerComponent() {
            this._min = -Infinity;
            this._max = Infinity;
            this._step = 1;
            this._disabled = false;
            this._value = 0;
            this._propagateChange = function (_) { };
            this.valid = true;
            this.valueChange = new core.EventEmitter();
        }
        Object.defineProperty(NumberPickerComponent.prototype, "value", {
            get: /**
             * @return {?}
             */ function () {
                return this._value;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._value = value;
                this.valueChange.emit(value);
                this._propagateChange(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NumberPickerComponent.prototype, "min", {
            get: /**
             * @return {?}
             */ function () {
                return this._min;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._min = typeof value === 'string' ? parseFloat(value) : value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NumberPickerComponent.prototype, "max", {
            get: /**
             * @return {?}
             */ function () {
                return this._max;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._max = typeof value === 'string' ? parseFloat(value) : value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NumberPickerComponent.prototype, "step", {
            get: /**
             * @return {?}
             */ function () {
                return this._step;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._step = typeof value === 'string' ? parseFloat(value) : value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NumberPickerComponent.prototype, "disabled", {
            get: /**
             * @return {?}
             */ function () {
                return this._disabled;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._disabled = typeof value === 'string' && (value === '' || value === 'true' || value === 'disabled') || value === true;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} event
         * @return {?}
         */
        NumberPickerComponent.prototype.increment = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                event.preventDefault();
                if (!this.disabled) {
                    this.value = Math.max(Math.min(this.value + this.step, this.max), this.min);
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        NumberPickerComponent.prototype.decrement = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                event.preventDefault();
                if (!this.disabled) {
                    this.value = Math.min(Math.max(this.value - this.step, this.min), this.max);
                }
            };
        /**
         * @return {?}
         */
        NumberPickerComponent.prototype.isValid = /**
         * @return {?}
         */
            function () {
                if (this.value < this.min || this.value > this.max) {
                    return false;
                }
                return this.valid;
            };
        /**
         * @param {?} event
         * @return {?}
         */
        NumberPickerComponent.prototype.onScroll = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                var /** @type {?} */ scrollValue = event.deltaY || event.wheelDelta;
                if (scrollValue < 0) {
                    this.increment(event);
                }
                else {
                    this.decrement(event);
                }
            };
        /**
         * @param {?} value
         * @return {?}
         */
        NumberPickerComponent.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (value !== undefined) {
                    this._value = value;
                }
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        NumberPickerComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this._propagateChange = fn;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        NumberPickerComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) { };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        NumberPickerComponent.prototype.setDisabledState = /**
         * @param {?} isDisabled
         * @return {?}
         */
            function (isDisabled) {
                this.disabled = isDisabled;
            };
        NumberPickerComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-number-picker',
                        template: "<input type=\"number\"\n       role=\"spinbutton\"\n       class=\"form-control number-picker-input\"\n       [(ngModel)]=\"value\"\n       [min]=\"min\"\n       [max]=\"max\"\n       (keydown.ArrowDown)=\"decrement($event)\"\n       (keydown.ArrowUp)=\"increment($event)\"\n       (wheel)=\"onScroll($event)\"\n       step=\"any\"\n       [disabled]=\"disabled\"\n       [attr.aria-valuemin]=\"min\"\n       [attr.aria-valuenow]=\"value\"\n       [attr.aria-valuemax]=\"max\">\n\n<div class=\"number-picker-controls\">\n\n    <div class=\"number-picker-control-up\"\n         (click)=\"increment($event)\"\n         [class.disabled]=\"disabled || value >= max\">\n\n        <span class=\"hpe-icon hpe-up\"></span>\n    </div>\n\n    <div class=\"number-picker-control-down\"\n         (click)=\"decrement($event)\"\n         [class.disabled]=\"disabled || value <= min\">\n\n        <span class=\"hpe-icon hpe-down\"></span>\n    </div>\n\n</div>",
                        providers: [NUMBER_PICKER_VALUE_ACCESSOR],
                        host: {
                            '[class.has-error]': '!isValid()'
                        }
                    }] }
        ];
        NumberPickerComponent.propDecorators = {
            valid: [{ type: core.Input }],
            valueChange: [{ type: core.Output }],
            value: [{ type: core.Input, args: ['value',] }],
            min: [{ type: core.Input }],
            max: [{ type: core.Input }],
            step: [{ type: core.Input }],
            disabled: [{ type: core.Input }]
        };
        return NumberPickerComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var NumberPickerModule = (function () {
        function NumberPickerModule() {
        }
        NumberPickerModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            forms.FormsModule
                        ],
                        exports: [NumberPickerComponent],
                        declarations: [NumberPickerComponent]
                    },] }
        ];
        return NumberPickerModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ uniqueTooltipId = 0;
    var TooltipComponent = (function () {
        function TooltipComponent(_changeDetectorRef) {
            this._changeDetectorRef = _changeDetectorRef;
            /**
             * Define a unique id for each tooltip
             */
            this.id = "ux-tooltip-" + ++uniqueTooltipId;
            /**
             * Define the tooltip role
             */
            this.role = 'tooltip';
            /**
             * Allow a custom class to be added to the tooltip to allow custom styling
             */
            this.customClass = '';
            /**
             * Indicates whether or not the content is a string or a TemplateRef
             */
            this.isTemplateRef = false;
            /**
             * Emit when the tooltip need to update it's position
             */
            this.reposition$ = new Subject.Subject();
        }
        /** Cleanup after the component is destroyed */
        /**
         * Cleanup after the component is destroyed
         * @return {?}
         */
        TooltipComponent.prototype.ngOnDestroy = /**
         * Cleanup after the component is destroyed
         * @return {?}
         */
            function () {
                this.reposition$.complete();
            };
        /** Inform the parent directive that it needs to recalulate the position */
        /**
         * Inform the parent directive that it needs to recalulate the position
         * @return {?}
         */
        TooltipComponent.prototype.reposition = /**
         * Inform the parent directive that it needs to recalulate the position
         * @return {?}
         */
            function () {
                this.reposition$.next();
            };
        /** This will update the content of the tooltip and trigger change detection */
        /**
         * This will update the content of the tooltip and trigger change detection
         * @param {?} content
         * @return {?}
         */
        TooltipComponent.prototype.setContent = /**
         * This will update the content of the tooltip and trigger change detection
         * @param {?} content
         * @return {?}
         */
            function (content) {
                this.content = content;
                this.isTemplateRef = content instanceof core.TemplateRef;
                this._changeDetectorRef.markForCheck();
            };
        /** This will update the tooltip placement and trigger change detection */
        /**
         * This will update the tooltip placement and trigger change detection
         * @param {?} placement
         * @return {?}
         */
        TooltipComponent.prototype.setPlacement = /**
         * This will update the tooltip placement and trigger change detection
         * @param {?} placement
         * @return {?}
         */
            function (placement) {
                if (!placement) {
                    return;
                }
                this.placement = placement;
                this._changeDetectorRef.markForCheck();
            };
        /** This will set a custom class on the tooltip and trigger change detection */
        /**
         * This will set a custom class on the tooltip and trigger change detection
         * @param {?} customClass
         * @return {?}
         */
        TooltipComponent.prototype.setClass = /**
         * This will set a custom class on the tooltip and trigger change detection
         * @param {?} customClass
         * @return {?}
         */
            function (customClass) {
                if (!customClass) {
                    return;
                }
                this.customClass = customClass;
                this._changeDetectorRef.markForCheck();
            };
        /** Updates the context used by the TemplateRef */
        /**
         * Updates the context used by the TemplateRef
         * @param {?} context
         * @return {?}
         */
        TooltipComponent.prototype.setContext = /**
         * Updates the context used by the TemplateRef
         * @param {?} context
         * @return {?}
         */
            function (context) {
                if (!context) {
                    return;
                }
                this.context = context;
                this._changeDetectorRef.markForCheck();
            };
        /** Specify the tooltip role attribute */
        /**
         * Specify the tooltip role attribute
         * @param {?} role
         * @return {?}
         */
        TooltipComponent.prototype.setRole = /**
         * Specify the tooltip role attribute
         * @param {?} role
         * @return {?}
         */
            function (role) {
                if (!role) {
                    return;
                }
                this.role = role;
                this._changeDetectorRef.markForCheck();
            };
        TooltipComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-tooltip',
                        template: "<div class=\"tooltip in\" [id]=\"id\" [attr.role]=\"role\" [ngClass]=\"[placement, customClass]\">\n    <div class=\"tooltip-arrow\"></div>\n    <div class=\"tooltip-inner\" (cdkObserveContent)=\"reposition()\">\n        <ng-container *ngIf=\"!isTemplateRef\">{{ content }}</ng-container>\n        <ng-container *ngIf=\"isTemplateRef\" [ngTemplateOutlet]=\"content\" [ngTemplateOutletContext]=\"context\"></ng-container>\n    </div>\n</div>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        TooltipComponent.ctorParameters = function () {
            return [
                { type: core.ChangeDetectorRef }
            ];
        };
        return TooltipComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TooltipService = (function () {
        function TooltipService() {
            this.shown$ = new Subject.Subject();
        }
        TooltipService.decorators = [
            { type: core.Injectable }
        ];
        return TooltipService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TooltipDirective = (function () {
        function TooltipDirective(_elementRef, _viewContainerRef, _overlay, _scrollDispatcher, _changeDetectorRef, _renderer, _tooltipService) {
            this._elementRef = _elementRef;
            this._viewContainerRef = _viewContainerRef;
            this._overlay = _overlay;
            this._scrollDispatcher = _scrollDispatcher;
            this._changeDetectorRef = _changeDetectorRef;
            this._renderer = _renderer;
            this._tooltipService = _tooltipService;
            /**
             * All the user to add a custom class to the tooltip
             */
            this.customClass = '';
            /**
             * All the user to add a role to the tooltip - default is tooltip
             */
            this.role = 'tooltip';
            /**
             * Provide the TemplateRef a context object
             */
            this.context = {};
            /**
             * Delay the showing of the tooltip by a number of miliseconds
             */
            this.delay = 0;
            /**
             * Programmatically show and hide the tooltip
             */
            this.isOpen = false;
            /**
             * Customize how the tooltip should be positioned relative to the element
             */
            this.placement = 'top';
            /**
             * Specify which events should show the tooltip
             */
            this.showTriggers = ['mouseenter', 'focus'];
            /**
             * Specify which events should hide the tooltip
             */
            this.hideTriggers = ['mouseleave', 'blur'];
            /**
             * Emits an event when the tooltip is shown
             */
            this.shown = new core.EventEmitter();
            /**
             * Emits a event when the tooltip is hidden
             */
            this.hidden = new core.EventEmitter();
            /**
             * Allow two way binding to track the visibility of the tooltip
             */
            this.isOpenChange = new core.EventEmitter();
            /**
             * Keep track of the tooltip visibility
             */
            this.isVisible = false;
            /**
             * This will emit when the directive is destroyed allowing us to unsubscribe all subscriptions automatically
             */
            this._onDestroy = new Subject.Subject();
            /**
             * Internally store the type of this component - usual for distinctions when extending this class
             */
            this._type = 'tooltip';
        }
        /** Set up the triggers and bind to the show/hide events to keep visibility in sync */
        /**
         * Set up the triggers and bind to the show/hide events to keep visibility in sync
         * @return {?}
         */
        TooltipDirective.prototype.ngOnInit = /**
         * Set up the triggers and bind to the show/hide events to keep visibility in sync
         * @return {?}
         */
            function () {
                var _this = this;
                // set up show and hide event triggers
                fromEvent.fromEvent(this._elementRef.nativeElement, 'click').pipe(operators.takeUntil(this._onDestroy)).subscribe(this.onClick.bind(this));
                fromEvent.fromEvent(this._elementRef.nativeElement, 'mouseenter').pipe(operators.takeUntil(this._onDestroy)).subscribe(this.onMouseEnter.bind(this));
                fromEvent.fromEvent(this._elementRef.nativeElement, 'mouseleave').pipe(operators.takeUntil(this._onDestroy)).subscribe(this.onMouseLeave.bind(this));
                fromEvent.fromEvent(this._elementRef.nativeElement, 'focus').pipe(operators.takeUntil(this._onDestroy)).subscribe(this.onFocus.bind(this));
                fromEvent.fromEvent(this._elementRef.nativeElement, 'blur').pipe(operators.takeUntil(this._onDestroy)).subscribe(this.onBlur.bind(this));
                // when any other tooltips open hide this one
                this._tooltipService.shown$.pipe(operators.filter(function () { return _this._type === 'tooltip'; }), operators.filter(function (tooltip$$1) { return tooltip$$1 !== _this._instance; }), operators.takeUntil(this._onDestroy)).subscribe(this.hide.bind(this));
                // if the tooltip should be initially visible then open it
                if (this.isOpen) {
                    this.show();
                }
            };
        /**
         * We need to send input changes to the tooltip component
         * We can't use setters as they may trigger before tooltip initialised and can't resend once initialised
         **/
        /**
         * We need to send input changes to the tooltip component
         * We can't use setters as they may trigger before tooltip initialised and can't resend once initialised
         *
         * @param {?} changes
         * @return {?}
         */
        TooltipDirective.prototype.ngOnChanges = /**
         * We need to send input changes to the tooltip component
         * We can't use setters as they may trigger before tooltip initialised and can't resend once initialised
         *
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                // we can ignore the first change as it's handled in ngOnInit
                if (changes["isOpen"] && !changes["isOpen"].firstChange && changes["isOpen"].currentValue !== this.isVisible) {
                    changes["isOpen"].currentValue ? this.show() : this.hide();
                }
                // destroy the overlay ref so a new correctly positioned instance will be created next time
                if (changes["placement"]) {
                    this.destroyOverlay();
                }
                if (this._instance && changes["placement"]) {
                    this._instance.setPlacement(changes["placement"].currentValue);
                }
                if (this._instance && changes["content"]) {
                    this._instance.setContent(changes["content"].currentValue);
                }
                if (this._instance && changes["customClass"]) {
                    this._instance.setClass(changes["customClass"].currentValue);
                }
                if (this._instance && changes["context"]) {
                    this._instance.setContext(changes["context"].currentValue);
                }
                if (this._instance && changes["role"]) {
                    this._instance.setContext(changes["role"].currentValue);
                }
            };
        /** Ensure we clean up after ourselves */
        /**
         * Ensure we clean up after ourselves
         * @return {?}
         */
        TooltipDirective.prototype.ngOnDestroy = /**
         * Ensure we clean up after ourselves
         * @return {?}
         */
            function () {
                // ensure we close the tooltip when the host is destroyed
                if (this._overlayRef) {
                    this._overlayRef.dispose();
                    this._instance = null;
                }
                // emit this event to automatically unsubscribe from all subscriptions
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /** Make the tooltip open */
        /**
         * Make the tooltip open
         * @return {?}
         */
        TooltipDirective.prototype.show = /**
         * Make the tooltip open
         * @return {?}
         */
            function () {
                var _this = this;
                // if the tooltip is disabled then do nothing
                if (this.disabled || this.isVisible || this._showTimeoutId || !this.content) {
                    return;
                }
                // delay the show by the delay amount
                this._showTimeoutId = window.setTimeout(function () {
                    // create the tooltip and get the overlay ref
                    var /** @type {?} */ overlayRef = _this.createOverlay();
                    // create the portal to create the tooltip component
                    // create the portal to create the tooltip component
                    _this._portal = _this.createPortal();
                    _this._instance = _this.createInstance(overlayRef);
                    // watch for any changes to the content
                    // watch for any changes to the content
                    _this._instance.reposition$.pipe(operators.takeUntil(_this._onDestroy)).subscribe(_this.reposition.bind(_this));
                    // store the visible state
                    // store the visible state
                    _this.isVisible = true;
                    // ensure the overlay has the correct initial position
                    // ensure the overlay has the correct initial position
                    _this.reposition();
                    // emit the show events
                    // emit the show events
                    _this.shown.emit();
                    _this.isOpenChange.next(true);
                    // clear the interval id
                    // clear the interval id
                    _this._showTimeoutId = null;
                    // emit the show event to close any other tooltips
                    // emit the show event to close any other tooltips
                    _this._tooltipService.shown$.next(_this._instance);
                    // ensure change detection is run
                    // ensure change detection is run
                    _this._changeDetectorRef.detectChanges();
                }, this.delay);
            };
        /** If a tooltip exists and is visible, hide it */
        /**
         * If a tooltip exists and is visible, hide it
         * @return {?}
         */
        TooltipDirective.prototype.hide = /**
         * If a tooltip exists and is visible, hide it
         * @return {?}
         */
            function () {
                // if we are waiting to show a tooltip then cancel the pending timeout
                if (this._showTimeoutId) {
                    clearTimeout(this._showTimeoutId);
                    this._showTimeoutId = null;
                    return;
                }
                if (this._overlayRef && this._overlayRef.hasAttached()) {
                    this._overlayRef.detach();
                }
                this.setAriaDescribedBy(null);
                this._instance = null;
                // store the visible state
                this.isVisible = false;
                // emit the hide events
                this.hidden.emit();
                this.isOpenChange.next(false);
                // ensure change detection is run
                this._changeDetectorRef.detectChanges();
            };
        /** Toggle the visibility of the tooltip */
        /**
         * Toggle the visibility of the tooltip
         * @return {?}
         */
        TooltipDirective.prototype.toggle = /**
         * Toggle the visibility of the tooltip
         * @return {?}
         */
            function () {
                this.isVisible ? this.hide() : this.show();
            };
        /** Recalculate the position of the popover */
        /**
         * Recalculate the position of the popover
         * @return {?}
         */
        TooltipDirective.prototype.reposition = /**
         * Recalculate the position of the popover
         * @return {?}
         */
            function () {
                if (this.isVisible && this._overlayRef) {
                    this._overlayRef.updatePosition();
                }
            };
        /** Create an instance from the overlay ref - allows overriding and additional logic here */
        /**
         * Create an instance from the overlay ref - allows overriding and additional logic here
         * @param {?} overlayRef
         * @return {?}
         */
        TooltipDirective.prototype.createInstance = /**
         * Create an instance from the overlay ref - allows overriding and additional logic here
         * @param {?} overlayRef
         * @return {?}
         */
            function (overlayRef) {
                var /** @type {?} */ instance = (overlayRef.attach(this._portal).instance);
                // supply the tooltip with the correct properties
                instance.setContent(this.content);
                instance.setPlacement(this.placement);
                instance.setClass(this.customClass);
                instance.setContext(this.context);
                instance.setRole(this.role);
                // Update the aria-describedby attribute
                this.setAriaDescribedBy(instance.id);
                return instance;
            };
        /** Create the component portal - allows overriding to allow other portals eg. popovers */
        /**
         * Create the component portal - allows overriding to allow other portals eg. popovers
         * @return {?}
         */
        TooltipDirective.prototype.createPortal = /**
         * Create the component portal - allows overriding to allow other portals eg. popovers
         * @return {?}
         */
            function () {
                return this._portal || new portal.ComponentPortal(TooltipComponent, this._viewContainerRef);
            };
        /**
         * Create the overlay and set up the scroll handling behavior
         * @return {?}
         */
        TooltipDirective.prototype.createOverlay = /**
         * Create the overlay and set up the scroll handling behavior
         * @return {?}
         */
            function () {
                // if the tooltip has already been created then just return the existing instance
                if (this._overlayRef) {
                    return this._overlayRef;
                }
                // configure the tooltip
                var /** @type {?} */ strategy = this._overlay.position()
                    .connectedTo(this._elementRef, this.getOrigin(), this.getOverlayPosition());
                // correctly handle scrolling
                var /** @type {?} */ scrollableAncestors = this._scrollDispatcher
                    .getAncestorScrollContainers(this._elementRef);
                strategy.withScrollableContainers(scrollableAncestors);
                this._overlayRef = this._overlay.create({
                    positionStrategy: strategy,
                    panelClass: 'ux-overlay-pane',
                    scrollStrategy: this._overlay.scrollStrategies.reposition({ scrollThrottle: 0 }),
                    hasBackdrop: false
                });
                return this._overlayRef;
            };
        /**
         * Recreate the overlay ref using the updated origin and overlay positions
         * @return {?}
         */
        TooltipDirective.prototype.destroyOverlay = /**
         * Recreate the overlay ref using the updated origin and overlay positions
         * @return {?}
         */
            function () {
                // destroy the existing overlay
                if (this._overlayRef && this._overlayRef.hasAttached()) {
                    this._overlayRef.detach();
                }
                if (this._overlayRef) {
                    this._overlayRef.dispose();
                    this._overlayRef = null;
                }
                this.isVisible = false;
            };
        /**
         * Get the origin position based on the specified tooltip placement
         * @return {?}
         */
        TooltipDirective.prototype.getOrigin = /**
         * Get the origin position based on the specified tooltip placement
         * @return {?}
         */
            function () {
                // ensure placement is defined
                this.placement = this.placement || 'top';
                if (this.placement == 'top' || this.placement == 'bottom') {
                    return { originX: 'center', originY: this.placement };
                }
                else if (this.placement == 'left') {
                    return { originX: 'start', originY: 'center' };
                }
                else if (this.placement == 'right') {
                    return { originX: 'end', originY: 'center' };
                }
            };
        /**
         * Calculate the overlay position based on the specified tooltip placement
         * @return {?}
         */
        TooltipDirective.prototype.getOverlayPosition = /**
         * Calculate the overlay position based on the specified tooltip placement
         * @return {?}
         */
            function () {
                // ensure placement is defined
                this.placement = this.placement || 'top';
                if (this.placement == 'top') {
                    return { overlayX: 'center', overlayY: 'bottom' };
                }
                else if (this.placement == 'bottom') {
                    return { overlayX: 'center', overlayY: 'top' };
                }
                else if (this.placement == 'left') {
                    return { overlayX: 'end', overlayY: 'center' };
                }
                else if (this.placement == 'right') {
                    return { overlayX: 'start', overlayY: 'center' };
                }
            };
        /**
         * Simple utility method - because IE doesn't support array.includes
         * And it isn't included in the core-js/es6 polyfills which are the
         * only ones required by Angular and guaranteed to be there
         **/
        /**
         * Simple utility method - because IE doesn't support array.includes
         * And it isn't included in the core-js/es6 polyfills which are the
         * only ones required by Angular and guaranteed to be there
         *
         * @template T
         * @param {?} array
         * @param {?} value
         * @return {?}
         */
        TooltipDirective.prototype.includes = /**
         * Simple utility method - because IE doesn't support array.includes
         * And it isn't included in the core-js/es6 polyfills which are the
         * only ones required by Angular and guaranteed to be there
         *
         * @template T
         * @param {?} array
         * @param {?} value
         * @return {?}
         */
            function (array, value) {
                return Array.isArray(array) && !!array.find(function (item) { return item === value; });
            };
        /** Handle the click event - show or hide accordingly */
        /**
         * Handle the click event - show or hide accordingly
         * @param {?} event
         * @return {?}
         */
        TooltipDirective.prototype.onClick = /**
         * Handle the click event - show or hide accordingly
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // if its not visible and click is a show trigger open it
                if (!this.isVisible && this.includes(this.showTriggers, 'click')) {
                    return this.show();
                }
                // if its visible and click is a hide trigger close it
                if (this.isVisible && this.includes(this.hideTriggers, 'click')) {
                    return this.hide();
                }
            };
        /** Handle the mouse enter event - show or hide accordingly */
        /**
         * Handle the mouse enter event - show or hide accordingly
         * @param {?} event
         * @return {?}
         */
        TooltipDirective.prototype.onMouseEnter = /**
         * Handle the mouse enter event - show or hide accordingly
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // this is an show only trigger - if already open or it isn't a trigger do nothing
                if (this.isVisible || !this.includes(this.showTriggers, 'mouseenter')) {
                    return;
                }
                // otherwise open the tooltip
                this.show();
            };
        /** Handle the mouse leave event - show or hide accordingly */
        /**
         * Handle the mouse leave event - show or hide accordingly
         * @param {?} event
         * @return {?}
         */
        TooltipDirective.prototype.onMouseLeave = /**
         * Handle the mouse leave event - show or hide accordingly
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // this is an hide only trigger - if not open or it isn't a trigger do nothing
                if (!this.isVisible || !this.includes(this.hideTriggers, 'mouseleave')) {
                    return;
                }
                // otherwise close the tooltip
                this.hide();
            };
        /** Handle the focus event - show or hide accordingly */
        /**
         * Handle the focus event - show or hide accordingly
         * @param {?} event
         * @return {?}
         */
        TooltipDirective.prototype.onFocus = /**
         * Handle the focus event - show or hide accordingly
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // this is an show only trigger - if already open or it isn't a trigger do nothing
                if (this.isVisible || !this.includes(this.showTriggers, 'focus')) {
                    return;
                }
                // otherwise open the tooltip
                this.show();
            };
        /** Handle the blur event - show or hide accordingly */
        /**
         * Handle the blur event - show or hide accordingly
         * @param {?} event
         * @return {?}
         */
        TooltipDirective.prototype.onBlur = /**
         * Handle the blur event - show or hide accordingly
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // this is an hide only trigger - if not open or it isn't a trigger do nothing
                if (!this.isVisible || !this.includes(this.hideTriggers, 'blur')) {
                    return;
                }
                // otherwise close the tooltip
                this.hide();
            };
        /**
         * Determine if the trigger element is focused
         * @return {?}
         */
        TooltipDirective.prototype.isFocused = /**
         * Determine if the trigger element is focused
         * @return {?}
         */
            function () {
                return document.activeElement === this._elementRef.nativeElement;
            };
        /** Programmatically update the aria-describedby property */
        /**
         * Programmatically update the aria-describedby property
         * @param {?} id
         * @return {?}
         */
        TooltipDirective.prototype.setAriaDescribedBy = /**
         * Programmatically update the aria-describedby property
         * @param {?} id
         * @return {?}
         */
            function (id) {
                if (id === null) {
                    this._renderer.removeAttribute(this._elementRef.nativeElement, 'aria-describedby');
                }
                else {
                    this._renderer.setAttribute(this._elementRef.nativeElement, 'aria-describedby', id);
                }
            };
        TooltipDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxTooltip]',
                        exportAs: 'ux-tooltip'
                    },] }
        ];
        /** @nocollapse */
        TooltipDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.ViewContainerRef },
                { type: overlay.Overlay },
                { type: overlay.ScrollDispatcher },
                { type: core.ChangeDetectorRef },
                { type: core.Renderer2 },
                { type: TooltipService }
            ];
        };
        TooltipDirective.propDecorators = {
            content: [{ type: core.Input, args: ['uxTooltip',] }],
            disabled: [{ type: core.Input, args: ['tooltipDisabled',] }],
            customClass: [{ type: core.Input, args: ['tooltipClass',] }],
            role: [{ type: core.Input, args: ['tooltipRole',] }],
            context: [{ type: core.Input, args: ['tooltipContext',] }],
            delay: [{ type: core.Input, args: ['tooltipDelay',] }],
            isOpen: [{ type: core.Input }],
            placement: [{ type: core.Input }],
            showTriggers: [{ type: core.Input }],
            hideTriggers: [{ type: core.Input }],
            shown: [{ type: core.Output }],
            hidden: [{ type: core.Output }],
            isOpenChange: [{ type: core.Output }]
        };
        return TooltipDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TooltipModule = (function () {
        function TooltipModule() {
        }
        TooltipModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            overlay.OverlayModule,
                            observers.ObserversModule
                        ],
                        exports: [TooltipDirective],
                        declarations: [TooltipComponent, TooltipDirective],
                        providers: [TooltipService],
                        entryComponents: [TooltipComponent]
                    },] }
        ];
        return TooltipModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ColorPickerModule = (function () {
        function ColorPickerModule() {
        }
        ColorPickerModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            AccessibilityModule,
                            common.CommonModule,
                            forms.FormsModule,
                            NumberPickerModule,
                            TooltipModule,
                        ],
                        exports: [ColorPickerComponent],
                        declarations: [ColorPickerComponent],
                        providers: [],
                    },] }
        ];
        return ColorPickerModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ColumnSortingDirective = (function () {
        function ColumnSortingDirective() {
            this.events = new Subject.Subject();
            this.order = [];
        }
        /**
         * @return {?}
         */
        ColumnSortingDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.events.complete();
            };
        /**
         * @param {?} sorting
         * @return {?}
         */
        ColumnSortingDirective.prototype.toggleColumn = /**
         * @param {?} sorting
         * @return {?}
         */
            function (sorting) {
                // apply sorting based on the single or multiple sort
                this.order = this.singleSort ? this.toggleSingleColumn(sorting) : this.toggleMultipleColumn(sorting);
                // emit the latest order
                this.events.next(this.order);
                return this.order;
            };
        /**
         * @param {?} sorting
         * @return {?}
         */
        ColumnSortingDirective.prototype.toggleSingleColumn = /**
         * @param {?} sorting
         * @return {?}
         */
            function (sorting) {
                return sorting.state === ColumnSortingState.NoSort ? [] : [{ key: sorting.key, state: sorting.state }];
            };
        /**
         * @param {?} sorting
         * @return {?}
         */
        ColumnSortingDirective.prototype.toggleMultipleColumn = /**
         * @param {?} sorting
         * @return {?}
         */
            function (sorting) {
                // reorder columns here
                var /** @type {?} */ idx = this.order.findIndex(function (column) { return column.key === sorting.key; });
                // if wasnt previously selected add to list
                if (idx === -1) {
                    return __spread(this.order, [{ key: sorting.key, state: sorting.state }]);
                }
                // if we are sorting it change the sorting order
                if (sorting.state === ColumnSortingState.Ascending || sorting.state === ColumnSortingState.Descending) {
                    return __spread(this.order.filter(function (_column) { return _column.key !== sorting.key; }), [{ key: sorting.key, state: sorting.state }]);
                }
                // Otherwise remove the item
                return this.order.filter(function (_column) { return _column.key !== sorting.key; });
            };
        ColumnSortingDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxColumnSorting]'
                    },] }
        ];
        ColumnSortingDirective.propDecorators = {
            singleSort: [{ type: core.Input }]
        };
        return ColumnSortingDirective;
    }());
    /** @enum {string} */
    var ColumnSortingState = {
        Ascending: 'ascending',
        Descending: 'descending',
        NoSort: 'none',
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ColumnSortingComponent = (function () {
        function ColumnSortingComponent(_columnSorter) {
            var _this = this;
            this._columnSorter = _columnSorter;
            this.stateChange = new core.EventEmitter();
            this.columnSortingState = ColumnSortingState;
            this._onDestroy = new Subject.Subject();
            this._columnSorter.events.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (event) {
                // if we are sorting this column then find the matching data
                var /** @type {?} */ columnIdx = event.findIndex(function (_column) { return _column.key === _this.key; });
                // if we are not sorting this column then mark it as NoSort
                if (columnIdx === -1) {
                    _this.state = ColumnSortingState.NoSort;
                }
                // only store the number if we have 2 or more columns being sorted
                // only store the number if we have 2 or more columns being sorted
                _this.order = event.length < 2 || columnIdx === -1 ? null : columnIdx + 1;
                // Emit the latest change
                // Emit the latest change
                _this.stateChange.emit(_this.state);
            });
        }
        /**
         * @return {?}
         */
        ColumnSortingComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @return {?}
         */
        ColumnSortingComponent.prototype.changeState = /**
         * @return {?}
         */
            function () {
                switch (this.state) {
                    case ColumnSortingState.Ascending:
                        this.state = ColumnSortingState.Descending;
                        break;
                    case ColumnSortingState.Descending:
                        this.state = ColumnSortingState.NoSort;
                        break;
                    default:
                        this.state = ColumnSortingState.Ascending;
                }
                // inform parent
                return this._columnSorter.toggleColumn({ key: this.key, state: this.state });
            };
        ColumnSortingComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-column-sorting',
                        template: "<div class=\"ux-column-sorting\">\n\n    <i class=\"ux-column-sorting-icon hpe-icon\"\n       [class.hpe-ascend]=\"state === columnSortingState.Ascending\"\n       [class.hpe-descend]=\"state === columnSortingState.Descending\"\n       [class.column-sorting-icon-hidden]=\"state === columnSortingState.NoSort\">\n    </i>\n\n    <p class=\"ux-column-sorting-number\" aria-hidden=\"true\">{{ order }}</p>\n</div>",
                        exportAs: 'ux-column-sorting'
                    }] }
        ];
        /** @nocollapse */
        ColumnSortingComponent.ctorParameters = function () {
            return [
                { type: ColumnSortingDirective }
            ];
        };
        ColumnSortingComponent.propDecorators = {
            state: [{ type: core.Input }],
            key: [{ type: core.Input }],
            stateChange: [{ type: core.Output }]
        };
        return ColumnSortingComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ColumnSortingModule = (function () {
        function ColumnSortingModule() {
        }
        ColumnSortingModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [ColumnSortingComponent, ColumnSortingDirective],
                        declarations: [ColumnSortingComponent, ColumnSortingDirective]
                    },] }
        ];
        return ColumnSortingModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ConduitSubject = (function () {
        function ConduitSubject(conduit, _zone, zoneId) {
            this.conduit = conduit;
            this._zone = _zone;
            this.zoneId = zoneId;
            this._onDestroy = new Subject.Subject();
            // store the target subject object
            this._subject = conduit.subject;
            // check if there are any conduits that have supplied an initial value
            this.getInitialValue();
            // subscribe to changes to the source subject
            this._subject.pipe(operators.distinctUntilChanged(conduit.changeDetection), operators.takeUntil(this._onDestroy))
                .subscribe(this.onOutput.bind(this));
            // subscribe to the zone events and root zone events
            _zone.getEvents().pipe(operators.filter(function (event) { return event.conduit.id === conduit.id; }), operators.takeUntil(this._onDestroy)).subscribe(this.onInput.bind(this));
        }
        /** Check all allow inputs to see if there is a value we should initially set the conduit to */
        /**
         * Check all allow inputs to see if there is a value we should initially set the conduit to
         * @return {?}
         */
        ConduitSubject.prototype.getInitialValue = /**
         * Check all allow inputs to see if there is a value we should initially set the conduit to
         * @return {?}
         */
            function () {
                var _this = this;
                // if we do not accept inputs then do nothing
                if (this.conduit.acceptsInput === false) {
                    return;
                }
                // return all subjects that are 1) Not itself 2) In a zone that is listed in acceptsInput 3) Have a currentValue set
                var /** @type {?} */ subjects = this._zone.getSubjects().filter(function (subject) {
                    // If this is itself or if it has not value to give us then do nothing
                    if (subject === _this || subject.conduit.id !== _this.conduit.id || !subject.conduit.hasOwnProperty('currentValue')) {
                        return false;
                    }
                    // if acceptsInput is true then we return every time
                    if (_this.conduit.acceptsInput === true) {
                        return true;
                    }
                    if (Array.isArray(_this.conduit.acceptsInput)) {
                        return _this.conduit.acceptsInput.indexOf(subject.zoneId) !== -1;
                    }
                });
                // if there are no matches then do nothing
                if (subjects.length === 0) {
                    return;
                }
                // otherwise sort by the last modified field
                subjects.sort(function (subjectOne, subjectTwo) { return subjectOne.conduit.lastModified.getTime() < subjectTwo.conduit.lastModified.getTime() ? 1 : -1; });
                // get the most recent value
                this._subject.next(subjects[0].conduit.currentValue);
            };
        /** This will be triggered when a conduits value has changed */
        /**
         * This will be triggered when a conduits value has changed
         * @param {?} event
         * @return {?}
         */
        ConduitSubject.prototype.onInput = /**
         * This will be triggered when a conduits value has changed
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // if we dont accept input or we emitted this value then do nothing
                if (this.conduit.acceptsInput === false || event.conduit === this.conduit) {
                    return;
                }
                // check if the conduit produces output - if not we only do something if we are in the same zone
                if (event.conduit.producesOutput === false && event.zoneId !== this.zoneId) {
                    return;
                }
                // check if we only accept inputs from specific zones
                if (Array.isArray(this.conduit.acceptsInput)) {
                    // check if the event came from an acceptable zone
                    if (!this.conduit.acceptsInput.find(function (zone) { return zone === event.zoneId; })) {
                        return;
                    }
                }
                // if required transform the value
                var /** @type {?} */ outputValue = this.conduit.map ? this.conduit.map(event.value) : event.value;
                // update the subject
                this._subject.next(outputValue);
            };
        /** This will be fired when this conduit emits a new value */
        /**
         * This will be fired when this conduit emits a new value
         * @param {?} value
         * @return {?}
         */
        ConduitSubject.prototype.onOutput = /**
         * This will be fired when this conduit emits a new value
         * @param {?} value
         * @return {?}
         */
            function (value) {
                // store the most recent value and when it was modified - can be used for any new conduits to lookup a value
                this.conduit.currentValue = value;
                this.conduit.lastModified = new Date();
                // check if this should produce output
                if (this.conduit.producesOutput) {
                    this._zone.emit({ conduit: this.conduit, zoneId: this.zoneId, value: value });
                }
            };
        /** Unsubscribe once this subject is destroyed */
        /**
         * Unsubscribe once this subject is destroyed
         * @return {?}
         */
        ConduitSubject.prototype.destroy = /**
         * Unsubscribe once this subject is destroyed
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        return ConduitSubject;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * This utility is to ensure a all functions with the specified name are called in all super classes
     * @param {?} target
     * @param {?} functionName
     * @return {?}
     */
    function invokeSuperFunction(target, functionName) {
        // get all instances of the function
        var /** @type {?} */ functionList = [];
        // store the current prototype we are checking
        var /** @type {?} */ prototype = target;
        // look through every base class and check it
        do {
            if (prototype.hasOwnProperty(functionName)) {
                functionList.push(prototype[functionName]);
            }
            prototype = prototype.__proto__;
        } while (prototype.__proto__);
        // augment the top level function to call all the functions
        target[functionName] = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            functionList.forEach(function (func) { return func.call.apply(func, __spread([target], args)); });
        };
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ConduitZone = (function () {
        function ConduitZone() {
        }
        /**
         * @return {?}
         */
        ConduitZone.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // find all conduit subjects that are part of this zone
                ConduitZone.subjects.filter(function (_subject) { return _subject.zoneId === _this._zoneId; })
                    .forEach(function (_subject) { return _this.unregisterConduit(_subject.conduit); });
            };
        /** Store reference to the repository and begin watching for and emitting changes */
        /**
         * Store reference to the repository and begin watching for and emitting changes
         * @param {?} conduit
         * @return {?}
         */
        ConduitZone.prototype.registerConduit = /**
         * Store reference to the repository and begin watching for and emitting changes
         * @param {?} conduit
         * @return {?}
         */
            function (conduit) {
                ConduitZone.subjects.push(new ConduitSubject(conduit, this, this._zoneId));
            };
        /** Destroy a conduit */
        /**
         * Destroy a conduit
         * @param {?} conduit
         * @return {?}
         */
        ConduitZone.prototype.unregisterConduit = /**
         * Destroy a conduit
         * @param {?} conduit
         * @return {?}
         */
            function (conduit) {
                var /** @type {?} */ subject = this.getConduitSubject(conduit.subject);
                if (subject) {
                    // remove the subject from the internal list of conduit subjects
                    ConduitZone.subjects = ConduitZone.subjects.filter(function (_subject) { return _subject !== subject; });
                    // perform all unsubscriptions
                    subject.destroy();
                }
            };
        /** Provide the zone with an ID */
        /**
         * Provide the zone with an ID
         * @param {?} zoneId
         * @return {?}
         */
        ConduitZone.prototype.setZoneId = /**
         * Provide the zone with an ID
         * @param {?} zoneId
         * @return {?}
         */
            function (zoneId) {
                this._zoneId = zoneId;
            };
        /** Emit a value to all zones for checking */
        /**
         * Emit a value to all zones for checking
         * @param {?} event
         * @return {?}
         */
        ConduitZone.prototype.emit = /**
         * Emit a value to all zones for checking
         * @param {?} event
         * @return {?}
         */
            function (event) {
                ConduitZone.events.next(event);
            };
        /** Retrieve a conduit subsject object from the rxjs subject */
        /**
         * Retrieve a conduit subsject object from the rxjs subject
         * @param {?} subject
         * @return {?}
         */
        ConduitZone.prototype.getConduitSubject = /**
         * Retrieve a conduit subsject object from the rxjs subject
         * @param {?} subject
         * @return {?}
         */
            function (subject) {
                return ConduitZone.subjects.find(function (_subject) { return _subject.conduit.subject === subject; });
            };
        /** Get all subjects from all zones */
        /**
         * Get all subjects from all zones
         * @return {?}
         */
        ConduitZone.prototype.getSubjects = /**
         * Get all subjects from all zones
         * @return {?}
         */
            function () {
                return ConduitZone.subjects;
            };
        /** Alter the properties of a conduit dynamically */
        /**
         * Alter the properties of a conduit dynamically
         * @param {?} subject
         * @param {?} properties
         * @return {?}
         */
        ConduitZone.prototype.setConduitProperties = /**
         * Alter the properties of a conduit dynamically
         * @param {?} subject
         * @param {?} properties
         * @return {?}
         */
            function (subject, properties) {
                // find the conduit with the matching subject
                var /** @type {?} */ conduitSubject = this.getSubjects().find(function (_conduit) { return _conduit.conduit.subject === subject; });
                // if a match was found update the properties
                if (conduitSubject) {
                    // update each specified property
                    for (var /** @type {?} */ prop in properties) {
                        conduitSubject.conduit[prop] = properties[prop];
                    }
                }
            };
        /** Programmatically create a conduit at runtime */
        /**
         * Programmatically create a conduit at runtime
         * @param {?} subject
         * @param {?} properties
         * @return {?}
         */
        ConduitZone.prototype.createConduit = /**
         * Programmatically create a conduit at runtime
         * @param {?} subject
         * @param {?} properties
         * @return {?}
         */
            function (subject, properties) {
                // register the conduit with the zone
                this.registerConduit(__assign({}, properties, { subject: subject }));
            };
        /** Register all conduits in a component */
        /**
         * Register all conduits in a component
         * @param {?} component
         * @return {?}
         */
        ConduitZone.prototype.registerConduits = /**
         * Register all conduits in a component
         * @param {?} component
         * @return {?}
         */
            function (component) {
                var _this = this;
                if (Array.isArray(component._conduits)) {
                    component._conduits.forEach(function (conduit) { return _this.registerConduit(__assign({}, conduit, { subject: component[conduit.propertyKey] })); });
                }
            };
        /** Register all conduits in a component */
        /**
         * Register all conduits in a component
         * @param {?} component
         * @return {?}
         */
        ConduitZone.prototype.unregisterConduits = /**
         * Register all conduits in a component
         * @param {?} component
         * @return {?}
         */
            function (component) {
                var _this = this;
                if (Array.isArray(component._conduits)) {
                    component._conduits.forEach(function (conduit) { return _this.unregisterConduit(conduit); });
                }
            };
        /** Return the global event stream */
        /**
         * Return the global event stream
         * @return {?}
         */
        ConduitZone.prototype.getEvents = /**
         * Return the global event stream
         * @return {?}
         */
            function () {
                return ConduitZone.events;
            };
        /**
         * Create a global subject store
         */
        ConduitZone.subjects = [];
        /**
         * Expose an event stream of new values
         */
        ConduitZone.events = new Subject.Subject();
        ConduitZone.decorators = [
            { type: core.Injectable }
        ];
        return ConduitZone;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ConduitComponent = (function () {
        function ConduitComponent(_zone) {
            this._zone = _zone;
            // we want to ensure these functions get called even if a class overrides them
            invokeSuperFunction(this, 'ngOnInit');
            invokeSuperFunction(this, 'ngOnDestroy');
        }
        /** We need to register the conduits with the zone when the component is initialised */
        /**
         * We need to register the conduits with the zone when the component is initialised
         * @return {?}
         */
        ConduitComponent.prototype.ngOnInit = /**
         * We need to register the conduits with the zone when the component is initialised
         * @return {?}
         */
            function () {
                // register the conduit in the zone and ensure it gets the correct instance of the target
                this._zone.registerConduits(this);
            };
        /** We need to unregister the conduits when the component is destroyed */
        /**
         * We need to unregister the conduits when the component is destroyed
         * @return {?}
         */
        ConduitComponent.prototype.ngOnDestroy = /**
         * We need to unregister the conduits when the component is destroyed
         * @return {?}
         */
            function () {
                this._zone.unregisterConduits(this);
            };
        /** Alter the properties of a conduit dynamically */
        /**
         * Alter the properties of a conduit dynamically
         * @param {?} subject
         * @param {?} properties
         * @return {?}
         */
        ConduitComponent.prototype.setConduitProperties = /**
         * Alter the properties of a conduit dynamically
         * @param {?} subject
         * @param {?} properties
         * @return {?}
         */
            function (subject, properties) {
                this._zone.setConduitProperties(subject, properties);
            };
        /** Programmatically create a conduit at runtime */
        /**
         * Programmatically create a conduit at runtime
         * @param {?} subject
         * @param {?} properties
         * @return {?}
         */
        ConduitComponent.prototype.createConduit = /**
         * Programmatically create a conduit at runtime
         * @param {?} subject
         * @param {?} properties
         * @return {?}
         */
            function (subject, properties) {
                this._zone.createConduit(subject, properties);
            };
        /** @nocollapse */
        ConduitComponent.ctorParameters = function () {
            return [
                { type: ConduitZone, decorators: [{ type: core.Optional }] }
            ];
        };
        return ConduitComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * @abstract
     */
    var /**
     * @abstract
     */ ConduitZoneComponent = (function (_super) {
        __extends(ConduitZoneComponent, _super);
        function ConduitZoneComponent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @return {?}
         */
        ConduitZoneComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this._zone.setZoneId(this.zoneId);
            };
        return ConduitZoneComponent;
    }(ConduitComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ defaultConduitProps = {
        acceptsInput: true,
        producesOutput: true,
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Expose the property that conduits will be stored in
     */
    var /** @type {?} */ CONDUITS = '_conduits';
    /**
     * Create the conduit property decorator
     * @param {?} properties
     * @return {?}
     */
    function Conduit(properties) {
        return function (target, propertyKey) {
            if (typeof properties === 'function') {
                properties = properties.call(null);
            }
            // if the target does not already have a conduit list then create one
            if (!target.hasOwnProperty(CONDUITS)) {
                Object.defineProperty(target, CONDUITS, { value: [] });
            }
            // add the conduit to the list ensuring all required properties are provided
            target[CONDUITS].push(/** @type {?} */ (__assign({}, defaultConduitProps, properties, { target: target, propertyKey: propertyKey })));
        };
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DashboardService = (function () {
        function DashboardService() {
            var _this = this;
            this._rowHeight = 0;
            this.widgets$ = new BehaviorSubject.BehaviorSubject([]);
            this.options$ = new BehaviorSubject.BehaviorSubject(defaultOptions);
            this.dimensions$ = new BehaviorSubject.BehaviorSubject({});
            this.height$ = this.dimensions$.pipe(operators.delay(0), operators.map(function (dimensions) { return dimensions.height; }), operators.distinctUntilChanged());
            this.placeholder$ = new BehaviorSubject.BehaviorSubject({ visible: false, x: 0, y: 0, width: 0, height: 0 });
            this.layout$ = new Subject.Subject();
            this.stacked$ = new BehaviorSubject.BehaviorSubject(false);
            this.layout$.subscribe(this.setLayoutData.bind(this));
            this.stacked$.pipe(operators.filter(function (stacked) { return stacked === true; })).subscribe(this.updateWhenStacked.bind(this));
            this.widgets$.pipe(operators.delay(0)).subscribe(function () { return _this.renderDashboard(); });
            this.dimensions$.pipe(operators.delay(0)).subscribe(function () { return _this.renderDashboard(); });
        }
        Object.defineProperty(DashboardService.prototype, "options", {
            get: /**
             * @return {?}
             */ function () {
                return this.options$.getValue();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DashboardService.prototype, "widgets", {
            get: /**
             * @return {?}
             */ function () {
                return this.widgets$.getValue();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DashboardService.prototype, "stacked", {
            get: /**
             * @return {?}
             */ function () {
                return this.stacked$.getValue();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DashboardService.prototype, "dimensions", {
            get: /**
             * @return {?}
             */ function () {
                return this.dimensions$.getValue();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DashboardService.prototype, "columnWidth", {
            get: /**
             * @return {?}
             */ function () {
                return this.dimensions.width / this.options.columns;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Add a widget to the dashboard
         * @param widget The widget component to add to the dashboard
         */
        /**
         * Add a widget to the dashboard
         * @param {?} widget The widget component to add to the dashboard
         * @return {?}
         */
        DashboardService.prototype.addWidget = /**
         * Add a widget to the dashboard
         * @param {?} widget The widget component to add to the dashboard
         * @return {?}
         */
            function (widget) {
                this.widgets$.next(__spread(this.widgets$.getValue(), [widget]));
            };
        /**
         * Remove a widget from the dashboard
         * @param widget The widget to remove
         */
        /**
         * Remove a widget from the dashboard
         * @param {?} widget The widget to remove
         * @return {?}
         */
        DashboardService.prototype.removeWidget = /**
         * Remove a widget from the dashboard
         * @param {?} widget The widget to remove
         * @return {?}
         */
            function (widget) {
                this.widgets$.next(this.widgets$.getValue().filter(function (_widget) { return _widget !== widget; }));
            };
        /**
         * Indicate that the dashboard element has been resized
         * @param width The width of the dashboard element in px
         * @param height The height of the dashboard element in px
         */
        /**
         * Indicate that the dashboard element has been resized
         * @param {?=} width The width of the dashboard element in px
         * @param {?=} height The height of the dashboard element in px
         * @return {?}
         */
        DashboardService.prototype.setDimensions = /**
         * Indicate that the dashboard element has been resized
         * @param {?=} width The width of the dashboard element in px
         * @param {?=} height The height of the dashboard element in px
         * @return {?}
         */
            function (width, height) {
                if (width === void 0) {
                    width = this.dimensions.width;
                }
                if (height === void 0) {
                    height = this.dimensions.height;
                }
                if (this.dimensions.width !== width || this.dimensions.height !== height) {
                    this.dimensions$.next({ width: width, height: height });
                }
            };
        /**
         * Produce an object containing all the required layout data.
         * This can be useful for exporting/saving a layout
         */
        /**
         * Produce an object containing all the required layout data.
         * This can be useful for exporting/saving a layout
         * @return {?}
         */
        DashboardService.prototype.getLayoutData = /**
         * Produce an object containing all the required layout data.
         * This can be useful for exporting/saving a layout
         * @return {?}
         */
            function () {
                return this.widgets.map(function (widget) {
                    return { id: widget.id, col: widget.getColumn(), row: widget.getRow(), colSpan: widget.getColumnSpan(), rowSpan: widget.getRowSpan() };
                });
            };
        /**
         * Position widgets programatically
         */
        /**
         * Position widgets programatically
         * @param {?} widgets
         * @return {?}
         */
        DashboardService.prototype.setLayoutData = /**
         * Position widgets programatically
         * @param {?} widgets
         * @return {?}
         */
            function (widgets) {
                var _this = this;
                // iterate through each widget data and find a match
                widgets.forEach(function (widget) {
                    // find the matching widget
                    var /** @type {?} */ target = _this.widgets.find(function (_widget) { return _widget.id === widget.id; });
                    if (target) {
                        target.setColumn(widget.col);
                        target.setRow(widget.row);
                        target.setColumnSpan(widget.colSpan);
                        target.setRowSpan(widget.rowSpan);
                    }
                });
            };
        /**
         * Update the positions and sizes of the widgets
         */
        /**
         * Update the positions and sizes of the widgets
         * @return {?}
         */
        DashboardService.prototype.renderDashboard = /**
         * Update the positions and sizes of the widgets
         * @return {?}
         */
            function () {
                var _this = this;
                // get the dimensions of the dashboard
                this._rowHeight = this.options.rowHeight || this.columnWidth;
                // ensure the column width is not below the min widths
                this.stacked$.next(this.columnWidth < this.options.minWidth);
                // ensure the row height is not below the min widths
                if (this._rowHeight < this.options.minWidth) {
                    this._rowHeight = this.options.minWidth;
                }
                this.setDashboardLayout();
                // iterate through each widget and set the size - except the one being resized
                this.widgets.filter(function (widget) { return !_this._actionWidget || widget !== _this._actionWidget.widget; })
                    .forEach(function (widget) { return widget.render(); });
            };
        /**
         * Determine where widgets should be positioned based on their positions, width and the size of the container
         */
        /**
         * Determine where widgets should be positioned based on their positions, width and the size of the container
         * @return {?}
         */
        DashboardService.prototype.setDashboardLayout = /**
         * Determine where widgets should be positioned based on their positions, width and the size of the container
         * @return {?}
         */
            function () {
                var _this = this;
                // find any widgets that do not currently have a position set
                this.widgets.filter(function (widget) { return widget.getColumn() === undefined || widget.getRow() === undefined; })
                    .forEach(function (widget) { return _this.setWidgetPosition(widget); });
                this.setDashboardHeight();
            };
        /**
         * @return {?}
         */
        DashboardService.prototype.updateWhenStacked = /**
         * @return {?}
         */
            function () {
                // iterate through each widget set it's stacked state and
                this.getWidgetsByOrder().forEach(function (widget, idx) {
                    widget.setColumn(0);
                    widget.setRow(idx);
                });
            };
        /**
         * @return {?}
         */
        DashboardService.prototype.getWidgetsByOrder = /**
         * @return {?}
         */
            function () {
                return this.widgets.sort(function (w1, w2) {
                    var /** @type {?} */ w1Position = w1.getColumn() * w1.getRow();
                    var /** @type {?} */ w2Position = w2.getColumn() * w2.getRow();
                    if (w1Position < w2Position) {
                        return -1;
                    }
                    if (w1Position > w2Position) {
                        return 1;
                    }
                    return 0;
                });
            };
        /**
         * Find a position that a widget can fit in the dashboard
         * @param widget The widget to try and position
         */
        /**
         * Find a position that a widget can fit in the dashboard
         * @param {?} widget The widget to try and position
         * @return {?}
         */
        DashboardService.prototype.setWidgetPosition = /**
         * Find a position that a widget can fit in the dashboard
         * @param {?} widget The widget to try and position
         * @return {?}
         */
            function (widget) {
                // find a position for the widget
                var /** @type {?} */ position = 0;
                var /** @type {?} */ success = false;
                // repeat until a space is found
                while (!success) {
                    // get a position to try
                    var /** @type {?} */ column = position % this.options.columns;
                    var /** @type {?} */ row = Math.floor(position / this.options.columns);
                    // check the current position
                    if (this.getPositionAvailable(column, row, widget.getColumnSpan(), widget.getRowSpan())) {
                        success = true;
                        widget.setColumn(column);
                        widget.setRow(row);
                        return;
                    }
                    if (column === 0 && widget.colSpan > this.options.columns) {
                        throw new Error('Dashboard widgets have a colSpan greater than the max number of dashboard columns!');
                    }
                    position++;
                }
            };
        /**
         * Check if a position in the dashboard is vacant or not
         */
        /**
         * Check if a position in the dashboard is vacant or not
         * @param {?} column
         * @param {?} row
         * @param {?} columnSpan
         * @param {?} rowSpan
         * @param {?=} ignoreWidget
         * @return {?}
         */
        DashboardService.prototype.getPositionAvailable = /**
         * Check if a position in the dashboard is vacant or not
         * @param {?} column
         * @param {?} row
         * @param {?} columnSpan
         * @param {?} rowSpan
         * @param {?=} ignoreWidget
         * @return {?}
         */
            function (column, row, columnSpan, rowSpan, ignoreWidget) {
                // get a list of grid spaces that are populated
                var /** @type {?} */ spaces = this.getOccupiedSpaces();
                // check if the block would still be in bounds
                if (column + columnSpan > this.options.columns) {
                    return false;
                }
                var _loop_1 = function (x) {
                    var _loop_2 = function (y) {
                        if (spaces.find(function (block) { return block.column === x && block.row === y && block.widget !== ignoreWidget; })) {
                            return { value: false };
                        }
                    };
                    for (var /** @type {?} */ y = row; y < row + rowSpan; y++) {
                        var state_1 = _loop_2(y);
                        if (typeof state_1 === "object")
                            return state_1;
                    }
                };
                // check each required position
                for (var /** @type {?} */ x = column; x < column + columnSpan; x++) {
                    var state_2 = _loop_1(x);
                    if (typeof state_2 === "object")
                        return state_2.value;
                }
                return true;
            };
        /**
         * @return {?}
         */
        DashboardService.prototype.getOccupiedSpaces = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // find all spaces that are currently occupied
                return this.widgets.filter(function (widget) { return widget.getColumn() !== undefined && widget.getRow() !== undefined; })
                    .reduce(function (value, widget) {
                    _this.forEachBlock(widget, function (column, row) { return value.push({ widget: widget, column: column, row: row }); });
                    return value;
                }, []);
            };
        /**
         * Begin resizing a widget
         * @param action The the widget to resize
         */
        /**
         * Begin resizing a widget
         * @param {?} action The the widget to resize
         * @return {?}
         */
        DashboardService.prototype.onResizeStart = /**
         * Begin resizing a widget
         * @param {?} action The the widget to resize
         * @return {?}
         */
            function (action) {
                // store the mouse event
                this._mouseEvent = action.event;
                this._actionWidget = action;
                // bring the widget to the font
                this.bringToFront(action.widget);
            };
        /**
         * @param {?} action
         * @return {?}
         */
        DashboardService.prototype.onResizeDrag = /**
         * @param {?} action
         * @return {?}
         */
            function (action) {
                var /** @type {?} */ mousePosX = this._mouseEvent.pageX - pageXOffset;
                var /** @type {?} */ mousePosY = this._mouseEvent.pageY - pageYOffset;
                // if there was no movement then do nothing
                if (action.event.x === mousePosX && action.event.y === mousePosY) {
                    return;
                }
                // update the stored mouse event
                this._mouseEvent = action.event;
                // get handle for direction
                var handle = action.handle;
                // get the bounds of the handle
                var /** @type {?} */ bounds = handle.getBoundingClientRect();
                // get the center of the handle
                var /** @type {?} */ centerX = bounds.left + (bounds.width / 2);
                var /** @type {?} */ centerY = bounds.top + (bounds.height / 2);
                // get the current mouse position
                var /** @type {?} */ mouseX = mousePosX - centerX;
                var /** @type {?} */ mouseY = mousePosY - centerY;
                // store the new proposed dimensions for the widget
                var /** @type {?} */ dimensions = {
                    x: action.widget.x,
                    y: action.widget.y,
                    width: action.widget.width,
                    height: action.widget.height
                };
                // update widget based on the handle being dragged
                switch (action.direction) {
                    case ActionDirection.Right:
                        dimensions.width += mouseX;
                        break;
                    case ActionDirection.Left:
                        dimensions.x += mouseX;
                        dimensions.width -= mouseX;
                        if (dimensions.width < this.options.minWidth) {
                            var /** @type {?} */ difference = this.options.minWidth - dimensions.width;
                            dimensions.x -= difference;
                            dimensions.width += difference;
                        }
                        break;
                    case ActionDirection.Bottom:
                        dimensions.height += mouseY;
                        break;
                    case ActionDirection.Top:
                        dimensions.y += mouseY;
                        dimensions.height -= mouseY;
                        if (dimensions.height < this.options.minHeight) {
                            var /** @type {?} */ difference = this.options.minHeight - dimensions.height;
                            dimensions.y -= difference;
                            dimensions.height += difference;
                        }
                        break;
                    // Support resizing on multiple axis simultaneously
                    case ActionDirection.TopLeft:
                        dimensions.x += mouseX;
                        dimensions.width -= mouseX;
                        if (dimensions.width < this.options.minWidth) {
                            var /** @type {?} */ difference = this.options.minWidth - dimensions.width;
                            dimensions.x -= difference;
                            dimensions.width += difference;
                        }
                        dimensions.y += mouseY;
                        dimensions.height -= mouseY;
                        if (dimensions.height < this.options.minHeight) {
                            var /** @type {?} */ difference = this.options.minHeight - dimensions.height;
                            dimensions.y -= difference;
                            dimensions.height += difference;
                        }
                        break;
                    case ActionDirection.TopRight:
                        dimensions.width += mouseX;
                        dimensions.y += mouseY;
                        dimensions.height -= mouseY;
                        if (dimensions.height < this.options.minHeight) {
                            var /** @type {?} */ difference = this.options.minHeight - dimensions.height;
                            dimensions.y -= difference;
                            dimensions.height += difference;
                        }
                        break;
                    case ActionDirection.BottomLeft:
                        dimensions.height += mouseY;
                        dimensions.x += mouseX;
                        dimensions.width -= mouseX;
                        if (dimensions.width < this.options.minWidth) {
                            var /** @type {?} */ difference = this.options.minWidth - dimensions.width;
                            dimensions.x -= difference;
                            dimensions.width += difference;
                        }
                        break;
                    case ActionDirection.BottomRight:
                        dimensions.height += mouseY;
                        dimensions.width += mouseX;
                        break;
                }
                var /** @type {?} */ currentWidth = action.widget.x + action.widget.width;
                var /** @type {?} */ currentHeight = action.widget.y + action.widget.height;
                // ensure values are within the dashboard bounds
                if (dimensions.x < 0) {
                    dimensions.x = 0;
                    dimensions.width = currentWidth;
                }
                if (dimensions.y < 0) {
                    dimensions.y = 0;
                    dimensions.height = currentHeight;
                }
                if ((dimensions.x + dimensions.width) > this.dimensions.width) {
                    dimensions.width = this.dimensions.width - dimensions.x;
                }
                // if the proposed width is smaller than allowed then reset width to minimum and ignore x changes
                if (dimensions.width < this.options.minWidth) {
                    dimensions.x = action.widget.x;
                    dimensions.width = this.options.minWidth;
                }
                // if the proposed height is smaller than allowed then reset height to minimum and ignore y changes
                if (dimensions.height < this.options.minHeight) {
                    dimensions.y = action.widget.y;
                    dimensions.height = this.options.minHeight;
                }
                // update the widget actual values
                action.widget.setBounds(dimensions.x, dimensions.y, dimensions.width, dimensions.height);
                // update placeholder position and value
                this.setPlaceholderBounds(true, dimensions.x, dimensions.y, dimensions.width, dimensions.height);
                // show the widget positions if the current positions and sizes were to persist
                this.updateWidgetPositions(action.widget);
            };
        /**
         * @return {?}
         */
        DashboardService.prototype.onResizeEnd = /**
         * @return {?}
         */
            function () {
                var /** @type {?} */ placeholder = this.placeholder$.getValue();
                // commit resize changes
                this.commitWidgetChanges();
                // hide placeholder
                placeholder.visible = false;
                // update the placeholder
                this.placeholder$.next(placeholder);
                this._actionWidget = null;
                this._mouseEvent = null;
                // ensure any vacant upper spaces are filled where required
                this.shiftWidgetsUp();
                // update dashboard height
                this.setDashboardHeight();
                // emit information about the layout
                this.layout$.next(this.getLayoutData());
            };
        /**
         * @param {?} action
         * @return {?}
         */
        DashboardService.prototype.onDragStart = /**
         * @param {?} action
         * @return {?}
         */
            function (action) {
                this.onResizeStart(action);
                // store the starting placeholder position
                this.setWidgetOrigin();
                this.cacheWidgets();
            };
        /**
         * @return {?}
         */
        DashboardService.prototype.onDragEnd = /**
         * @return {?}
         */
            function () {
                this.onResizeEnd();
                this._widgetOrigin = {};
            };
        /**
         * @param {?} action
         * @return {?}
         */
        DashboardService.prototype.onDrag = /**
         * @param {?} action
         * @return {?}
         */
            function (action) {
                // if there was no movement then do nothing
                if (action.event.pageX === this._mouseEvent.pageX && action.event.pageY === this._mouseEvent.pageY) {
                    return;
                }
                // get the current mouse position
                var /** @type {?} */ mouseX = action.event.pageX - this._mouseEvent.pageX;
                var /** @type {?} */ mouseY = action.event.pageY - this._mouseEvent.pageY;
                // store the latest event
                this._mouseEvent = action.event;
                var /** @type {?} */ dimensions = {
                    x: action.widget.x + mouseX,
                    y: action.widget.y + mouseY,
                    width: action.widget.width,
                    height: action.widget.height
                };
                this.restoreWidgets(true);
                // update widget position
                action.widget.setBounds(dimensions.x, dimensions.y, dimensions.width, dimensions.height);
                // update placeholder position and value
                this.setPlaceholderBounds(true, dimensions.x, dimensions.y, dimensions.width, dimensions.height);
                // show the widget positions if the current positions and sizes were to persist
                this.shiftWidgets();
                this.setDashboardHeight();
            };
        /**
         * @return {?}
         */
        DashboardService.prototype.getRowHeight = /**
         * @return {?}
         */
            function () {
                return this._rowHeight;
            };
        /**
         * @return {?}
         */
        DashboardService.prototype.cacheWidgets = /**
         * @return {?}
         */
            function () {
                this._cache = this.widgets.map(function (widget) { return ({ id: widget.id, column: widget.getColumn(), row: widget.getRow() }); });
            };
        /**
         * @param {?=} ignoreActionWidget
         * @return {?}
         */
        DashboardService.prototype.restoreWidgets = /**
         * @param {?=} ignoreActionWidget
         * @return {?}
         */
            function (ignoreActionWidget) {
                var _this = this;
                if (ignoreActionWidget === void 0) {
                    ignoreActionWidget = false;
                }
                this._cache.filter(function (widget) { return !ignoreActionWidget || widget.id !== _this._actionWidget.widget.id; }).forEach(function (widget) {
                    var /** @type {?} */ match = _this.widgets.find(function (wgt) { return wgt.id === widget.id; });
                    if (match) {
                        match.setColumn(widget.column);
                        match.setRow(widget.row);
                    }
                });
            };
        /**
         * When dragging any widgets that need to be moved should be moved to an appropriate position
         */
        /**
         * When dragging any widgets that need to be moved should be moved to an appropriate position
         * @return {?}
         */
        DashboardService.prototype.shiftWidgets = /**
         * When dragging any widgets that need to be moved should be moved to an appropriate position
         * @return {?}
         */
            function () {
                var _this = this;
                var /** @type {?} */ widgetsToMove = [];
                var /** @type {?} */ placeholder = this.placeholder$.getValue();
                var _loop_3 = function (row) {
                    var _loop_4 = function (column) {
                        // store reference to any widgets that need moved
                        this_1.getOccupiedSpaces()
                            .filter(function (space) { return space.column === column && space.row === row && space.widget !== _this._actionWidget.widget; })
                            .forEach(function (space) { return widgetsToMove.push(space.widget); });
                    };
                    for (var /** @type {?} */ column = placeholder.column; column < placeholder.column + placeholder.columnSpan; column++) {
                        _loop_4(column);
                    }
                };
                var this_1 = this;
                // check if there are any widgets under the placeholder
                for (var /** @type {?} */ row = placeholder.row; row < placeholder.row + placeholder.rowSpan; row++) {
                    _loop_3(row);
                }
                // remove any duplicates
                widgetsToMove = widgetsToMove.filter(function (widget, idx, array) { return array.indexOf(widget) === idx; });
                // if no widgets need moved then we can stop here
                if (widgetsToMove.length === 0) {
                    return;
                }
                // create a duplicate we can use to keep track of which have been moved
                var /** @type {?} */ unmovedWidgets = widgetsToMove.slice();
                // attempt to move any widgets to the previous widget position
                widgetsToMove.forEach(function (widget) {
                    // get a grid off all occupied spaces - taking into account the placeholder and ignoring widgets that need moved
                    var /** @type {?} */ grid = _this.getOccupiedSpaces().filter(function (space) { return !unmovedWidgets.find(function (wgt) { return wgt === space.widget; }); });
                    // iterate each free block
                    for (var /** @type {?} */ row = _this._widgetOrigin.row; row < _this._widgetOrigin.row + _this._widgetOrigin.rowSpan; row++) {
                        for (var /** @type {?} */ column = _this._widgetOrigin.column; column < _this._widgetOrigin.column + _this._widgetOrigin.columnSpan; column++) {
                            // determine if the block can fit in this space
                            var /** @type {?} */ requiredSpaces = _this.getRequiredSpacesFromPoint(widget, column, row);
                            // check if widget would fit in space
                            var /** @type {?} */ available = requiredSpaces.every(function (space) {
                                return !grid.find(function (gridSpace) { return gridSpace.column === space.column && gridSpace.row === space.row; }) && space.column < _this.getColumnCount();
                            });
                            if (available) {
                                widget.setColumn(column);
                                widget.setRow(row);
                                unmovedWidgets.splice(unmovedWidgets.findIndex(function (wgt) { return wgt === widget; }), 1);
                                return;
                            }
                        }
                    }
                    // if we get to here then we can't simply swap the positions - next try moving right
                    if (_this.canWidgetMoveRight(widget, true)) {
                        // after the shift check if placeholder position is still valid
                        // after the shift check if placeholder position is still valid
                        _this.validatePlaceholderPosition(ActionDirection.Right);
                        return;
                    }
                    // next try moving left
                    if (_this.canWidgetMoveLeft(widget, true)) {
                        // after the shift check if placeholder position is still valid
                        // after the shift check if placeholder position is still valid
                        _this.validatePlaceholderPosition(ActionDirection.Left);
                        return;
                    }
                    // determine the distance that the widget needs to be moved down
                    var /** @type {?} */ distance = (_this._actionWidget.widget.getRow() - widget.getRow()) + _this._actionWidget.widget.getRowSpan();
                    // as a last resort move the widget downwards
                    // as a last resort move the widget downwards
                    _this.moveWidgetDown(widget, distance);
                });
            };
        /**
         * After shifts have taken place we should verify the place holder position is still valid
         * @param shiftDirection - the position widgets were shifted
         */
        /**
         * After shifts have taken place we should verify the place holder position is still valid
         * @param {?} shiftDirection - the position widgets were shifted
         * @return {?}
         */
        DashboardService.prototype.validatePlaceholderPosition = /**
         * After shifts have taken place we should verify the place holder position is still valid
         * @param {?} shiftDirection - the position widgets were shifted
         * @return {?}
         */
            function (shiftDirection) {
                var /** @type {?} */ placeholder = this.placeholder$.getValue();
                // check if the placeholder is over a widget
                if (this.getWidgetsAtPosition(placeholder.column, placeholder.row, true).length > 0) {
                    // move the placeholder the opposite direction
                    switch (shiftDirection) {
                        case ActionDirection.Left:
                            this.setPlaceholderBounds(placeholder.visible, placeholder.x + this.getColumnWidth(), placeholder.y, placeholder.width, placeholder.height);
                            break;
                        case ActionDirection.Right:
                            this.setPlaceholderBounds(placeholder.visible, placeholder.x - this.getColumnWidth(), placeholder.y, placeholder.width, placeholder.height);
                            break;
                    }
                    // validate this new position again
                    this.validatePlaceholderPosition(shiftDirection);
                }
            };
        /**
         * Determine if a widget can be moved left - or if it can move the widgets to the right to make space for the widget
         */
        /**
         * Determine if a widget can be moved left - or if it can move the widgets to the right to make space for the widget
         * @param {?} widget
         * @param {?=} performMove
         * @return {?}
         */
        DashboardService.prototype.canWidgetMoveLeft = /**
         * Determine if a widget can be moved left - or if it can move the widgets to the right to make space for the widget
         * @param {?} widget
         * @param {?=} performMove
         * @return {?}
         */
            function (widget, performMove) {
                var _this = this;
                if (performMove === void 0) {
                    performMove = false;
                }
                // check if the widget is the action widget or occupies the first column
                if (widget === this._actionWidget.widget || widget.getColumn() === 0) {
                    return false;
                }
                // find the positions required
                var /** @type {?} */ targetSpaces = this.getOccupiedSpaces().filter(function (space) { return space.widget === widget; }).map(function (space) {
                    return { column: space.column - widget.getColumnSpan(), row: space.row, widget: space.widget };
                });
                // check if there are widget in the required positions and if so, can they move right?
                var /** @type {?} */ moveable = targetSpaces.every(function (space) { return _this.getWidgetsAtPosition(space.column, space.row).filter(function (wgt) { return wgt !== space.widget; }).every(function (wgt) { return _this.canWidgetMoveLeft(wgt); }); });
                if (performMove && moveable) {
                    // move all widgets to the right
                    targetSpaces.forEach(function (space) { return _this.getWidgetsAtPosition(space.column, space.row).filter(function (wgt) { return wgt !== space.widget; }).forEach(function (wgt) { return _this.canWidgetMoveLeft(wgt, true); }); });
                    // move current widget to the right
                    widget.setColumn(widget.getColumn() - 1);
                }
                return moveable;
            };
        /**
         * Determine if a widget can be moved right - or if it can move the widgets to the right to make space for the widget
         */
        /**
         * Determine if a widget can be moved right - or if it can move the widgets to the right to make space for the widget
         * @param {?} widget
         * @param {?=} performMove
         * @return {?}
         */
        DashboardService.prototype.canWidgetMoveRight = /**
         * Determine if a widget can be moved right - or if it can move the widgets to the right to make space for the widget
         * @param {?} widget
         * @param {?=} performMove
         * @return {?}
         */
            function (widget, performMove) {
                var _this = this;
                if (performMove === void 0) {
                    performMove = false;
                }
                // check if the widget is the dragging widget or the widget occupies the final column
                if (widget === this._actionWidget.widget || widget.getColumn() + widget.getColumnSpan() === this.options.columns) {
                    return false;
                }
                // find the positions required
                var /** @type {?} */ targetSpaces = this.getOccupiedSpaces().filter(function (space) { return space.widget === widget; }).map(function (space) {
                    return { column: space.column + widget.getColumnSpan(), row: space.row, widget: space.widget };
                });
                // check if there are widget in the required positions and if so, can they move right?
                var /** @type {?} */ moveable = targetSpaces.every(function (space) { return _this.getWidgetsAtPosition(space.column, space.row).filter(function (wgt) { return wgt !== space.widget; }).every(function (wgt) { return _this.canWidgetMoveRight(wgt); }); });
                if (performMove && moveable) {
                    // move all widgets to the right
                    targetSpaces.forEach(function (space) { return _this.getWidgetsAtPosition(space.column, space.row).filter(function (wgt) { return wgt !== space.widget; }).forEach(function (wgt) { return _this.canWidgetMoveRight(wgt, true); }); });
                    // move current widget to the right
                    widget.setColumn(widget.getColumn() + 1);
                }
                return moveable;
            };
        /**
         * Store the initial position of the widget being dragged
         */
        /**
         * Store the initial position of the widget being dragged
         * @return {?}
         */
        DashboardService.prototype.setWidgetOrigin = /**
         * Store the initial position of the widget being dragged
         * @return {?}
         */
            function () {
                this._widgetOrigin = {
                    column: this._actionWidget.widget.getColumn(),
                    row: this._actionWidget.widget.getRow(),
                    columnSpan: this._actionWidget.widget.getColumnSpan(),
                    rowSpan: this._actionWidget.widget.getRowSpan()
                };
            };
        /**
         * Calculate all the required positions is a widget was to be positioned at a particular point
         */
        /**
         * Calculate all the required positions is a widget was to be positioned at a particular point
         * @param {?} widget
         * @param {?} column
         * @param {?} row
         * @return {?}
         */
        DashboardService.prototype.getRequiredSpacesFromPoint = /**
         * Calculate all the required positions is a widget was to be positioned at a particular point
         * @param {?} widget
         * @param {?} column
         * @param {?} row
         * @return {?}
         */
            function (widget, column, row) {
                var /** @type {?} */ spaces = [];
                for (var /** @type {?} */ y = row; y < row + widget.getRowSpan(); y++) {
                    for (var /** @type {?} */ x = column; x < column + widget.getColumnSpan(); x++) {
                        spaces.push({ column: x, row: y, widget: widget });
                    }
                }
                return spaces;
            };
        /**
         * Position widgets based on the position of the placeholder - this is temporary until confirmed
         */
        /**
         * Position widgets based on the position of the placeholder - this is temporary until confirmed
         * @param {?} widget
         * @return {?}
         */
        DashboardService.prototype.updateWidgetPositions = /**
         * Position widgets based on the position of the placeholder - this is temporary until confirmed
         * @param {?} widget
         * @return {?}
         */
            function (widget) {
                var _this = this;
                var /** @type {?} */ placeholder = this.placeholder$.getValue();
                // check all spaces the placeholder will occupy and move any widget currently in them down
                for (var /** @type {?} */ column = placeholder.column; column < placeholder.column + placeholder.columnSpan; column++) {
                    for (var /** @type {?} */ row = placeholder.row; row < placeholder.row + placeholder.rowSpan; row++) {
                        this.getWidgetsAtPosition(column, row, true)
                            .filter(function (wgt) { return wgt !== widget; })
                            .forEach(function (wgt) { return _this.moveWidgetDown(wgt); });
                    }
                }
                // update the height of the dashboard
                this.setDashboardHeight();
                // if we arent dragging the top handle then fill spaces
                if (this._actionWidget.direction !== ActionDirection.Top &&
                    this._actionWidget.direction !== ActionDirection.TopLeft &&
                    this._actionWidget.direction !== ActionDirection.TopRight) {
                    this.shiftWidgetsUp();
                }
            };
        /**
         * Determine if a widget is occupying a specific row and column
         * @param column The columns to check if occupied
         * @param row The row to check if occupied
         * @param ignoreResizing Whether or not to ignore the widget currently being resized
         */
        /**
         * Determine if a widget is occupying a specific row and column
         * @param {?} column The columns to check if occupied
         * @param {?} row The row to check if occupied
         * @param {?=} ignoreResizing Whether or not to ignore the widget currently being resized
         * @return {?}
         */
        DashboardService.prototype.getWidgetsAtPosition = /**
         * Determine if a widget is occupying a specific row and column
         * @param {?} column The columns to check if occupied
         * @param {?} row The row to check if occupied
         * @param {?=} ignoreResizing Whether or not to ignore the widget currently being resized
         * @return {?}
         */
            function (column, row, ignoreResizing) {
                var _this = this;
                if (ignoreResizing === void 0) {
                    ignoreResizing = false;
                }
                return this.getOccupiedSpaces()
                    .filter(function (space) { return space.column === column && space.row === row; })
                    .filter(function (space) { return space.widget !== _this._actionWidget.widget || !ignoreResizing; })
                    .map(function (space) { return space.widget; });
            };
        /**
         * Update the placeholder visibility, position and size
         */
        /**
         * Update the placeholder visibility, position and size
         * @param {?} visible
         * @param {?} x
         * @param {?} y
         * @param {?} width
         * @param {?} height
         * @return {?}
         */
        DashboardService.prototype.setPlaceholderBounds = /**
         * Update the placeholder visibility, position and size
         * @param {?} visible
         * @param {?} x
         * @param {?} y
         * @param {?} width
         * @param {?} height
         * @return {?}
         */
            function (visible, x, y, width, height) {
                var _this = this;
                var /** @type {?} */ placeholder = this.placeholder$.getValue();
                var /** @type {?} */ rounding = this._actionWidget.direction === ActionDirection.Left ||
                    this._actionWidget.direction === ActionDirection.Top ? Rounding.RoundDownBelowHalf : Rounding.RoundUpOverHalf;
                placeholder.visible = visible;
                placeholder.column = this.getPlaceholderColumn(x, width);
                placeholder.row = this.getPlaceholderRow(y, height);
                placeholder.columnSpan = this.getPlaceholderColumnSpan(width);
                placeholder.rowSpan = this.getPlaceholderRowSpan(height);
                // calculate the maximum number of rows
                var /** @type {?} */ rowCount = this.widgets.filter(function (widget) { return widget !== _this._actionWidget.widget; })
                    .reduce(function (previous, widget) { return Math.max(widget.getRow() + widget.getRowSpan(), previous); }, 0);
                // constrain maximum placeholder row
                placeholder.row = Math.min(placeholder.row, rowCount);
                placeholder.x = (placeholder.column * this.getColumnWidth()) + this.options.padding;
                placeholder.y = (placeholder.row * this._rowHeight) + this.options.padding;
                placeholder.width = (placeholder.columnSpan * this.getColumnWidth()) - (this.options.padding * 2);
                placeholder.height = (placeholder.rowSpan * this._rowHeight) - (this.options.padding * 2);
                // set the values of the widget to match the values of the placeholder - however do not render the changes
                this._actionWidget.widget.setColumn(placeholder.column, false);
                this._actionWidget.widget.setRow(placeholder.row, false);
                this._actionWidget.widget.setColumnSpan(placeholder.columnSpan, false);
                this._actionWidget.widget.setRowSpan(placeholder.rowSpan, false);
                // update the placeholder
                this.placeholder$.next(placeholder);
            };
        /**
         * Get the placeholder column position
         */
        /**
         * Get the placeholder column position
         * @param {?} x
         * @param {?} width
         * @return {?}
         */
        DashboardService.prototype.getPlaceholderColumn = /**
         * Get the placeholder column position
         * @param {?} x
         * @param {?} width
         * @return {?}
         */
            function (x, width) {
                var /** @type {?} */ column = this.getColumnFromPx(x, this._actionWidget.direction === ActionDirection.Move ? Rounding.RoundUpOverHalf : Rounding.RoundDown);
                var /** @type {?} */ columnSpan = Math.floor(width / this.getColumnWidth());
                var /** @type {?} */ upperLimit = this.getColumnCount() - columnSpan;
                // if we arent dragging left then just return the column
                if (this._actionWidget.direction !== ActionDirection.Left &&
                    this._actionWidget.direction !== ActionDirection.TopLeft &&
                    this._actionWidget.direction !== ActionDirection.BottomLeft) {
                    return Math.max(Math.min(column, upperLimit), 0);
                }
                // get any overflow
                var /** @type {?} */ overflow = width % this.getColumnWidth();
                return (x <= 0 || overflow === 0 || columnSpan === 0 || overflow > (this.getColumnWidth() / 2)) ?
                    Math.max(Math.min(column, upperLimit), 0) :
                    Math.max(Math.min(column + 1, upperLimit), 0);
            };
        /**
         * Get the column span of the placeholder
         */
        /**
         * Get the column span of the placeholder
         * @param {?} width
         * @return {?}
         */
        DashboardService.prototype.getPlaceholderColumnSpan = /**
         * Get the column span of the placeholder
         * @param {?} width
         * @return {?}
         */
            function (width) {
                var /** @type {?} */ columnSpan = this.getColumnFromPx(width);
                // if we arent dragging right or left then just return the column span
                if (this._actionWidget.direction !== ActionDirection.Right &&
                    this._actionWidget.direction !== ActionDirection.TopRight &&
                    this._actionWidget.direction !== ActionDirection.BottomRight &&
                    this._actionWidget.direction !== ActionDirection.Left &&
                    this._actionWidget.direction !== ActionDirection.TopLeft &&
                    this._actionWidget.direction !== ActionDirection.BottomLeft) {
                    return Math.max(columnSpan, 1);
                }
                // get the current column span and any overflow
                var /** @type {?} */ overflow = width % this.getColumnWidth();
                return (columnSpan > 0 && overflow > (this.getColumnWidth() / 2)) ? Math.max(columnSpan + 1, 1) : Math.max(columnSpan, 1);
            };
        /**
         * Get the row position of the placeholder
         */
        /**
         * Get the row position of the placeholder
         * @param {?} y
         * @param {?} height
         * @return {?}
         */
        DashboardService.prototype.getPlaceholderRow = /**
         * Get the row position of the placeholder
         * @param {?} y
         * @param {?} height
         * @return {?}
         */
            function (y, height) {
                var /** @type {?} */ row = this.getRowFromPx(y, this._actionWidget.direction === ActionDirection.Move ? Rounding.RoundUpOverHalf : Rounding.RoundDown);
                var /** @type {?} */ rowSpan = Math.ceil(height / this._rowHeight);
                // if we arent dragging up then just return the row
                if (this._actionWidget.direction !== ActionDirection.Top &&
                    this._actionWidget.direction !== ActionDirection.TopLeft &&
                    this._actionWidget.direction !== ActionDirection.TopRight) {
                    return Math.max(row, 0);
                }
                // get any overflow
                var /** @type {?} */ overflow = height < this._rowHeight ? 0 : height % this._rowHeight;
                return (y <= 0 || rowSpan === 0 || overflow === 0 || overflow > (this._rowHeight / 2)) ? Math.max(row, 0) : Math.max(row + 1, 0);
            };
        /**
         * Get the row span of the placeholder
         */
        /**
         * Get the row span of the placeholder
         * @param {?} height
         * @return {?}
         */
        DashboardService.prototype.getPlaceholderRowSpan = /**
         * Get the row span of the placeholder
         * @param {?} height
         * @return {?}
         */
            function (height) {
                var /** @type {?} */ rowSpan = this.getRowFromPx(height);
                // if we arent dragging up or down then just return the column span
                if (this._actionWidget.direction !== ActionDirection.Top &&
                    this._actionWidget.direction !== ActionDirection.TopLeft &&
                    this._actionWidget.direction !== ActionDirection.TopRight &&
                    this._actionWidget.direction !== ActionDirection.Bottom &&
                    this._actionWidget.direction !== ActionDirection.BottomLeft &&
                    this._actionWidget.direction !== ActionDirection.BottomRight) {
                    return Math.max(rowSpan, 1);
                }
                // get the current column span and any overflow
                var /** @type {?} */ overflow = height % this._rowHeight;
                return (overflow > (this._rowHeight / 2)) ? Math.max(rowSpan + 1, 1) : Math.max(rowSpan, 1);
            };
        /**
         * @param {?} x
         * @param {?=} rounding
         * @return {?}
         */
        DashboardService.prototype.getColumnFromPx = /**
         * @param {?} x
         * @param {?=} rounding
         * @return {?}
         */
            function (x, rounding) {
                if (rounding === void 0) {
                    rounding = Rounding.RoundDown;
                }
                var /** @type {?} */ column = Math.floor(x / Math.floor(this.getColumnWidth()));
                var /** @type {?} */ overflow = (x % Math.floor(this.getColumnWidth()));
                var /** @type {?} */ half = this.getColumnWidth() / 2;
                switch (rounding) {
                    case Rounding.RoundDown:
                        return column;
                    case Rounding.RoundDownBelowHalf:
                        return overflow < half ? column : column + 1;
                    case Rounding.RoundUpOverHalf:
                        return overflow > half ? column + 1 : column;
                    case Rounding.RoundUp:
                        return overflow > 0 ? column + 1 : column;
                }
            };
        /**
         * @param {?} y
         * @param {?=} rounding
         * @return {?}
         */
        DashboardService.prototype.getRowFromPx = /**
         * @param {?} y
         * @param {?=} rounding
         * @return {?}
         */
            function (y, rounding) {
                if (rounding === void 0) {
                    rounding = Rounding.RoundDown;
                }
                var /** @type {?} */ row = Math.floor(y / Math.floor(this._rowHeight));
                var /** @type {?} */ overflow = (y % Math.floor(this._rowHeight));
                var /** @type {?} */ half = this._rowHeight / 2;
                switch (rounding) {
                    case Rounding.RoundDown:
                        return row;
                    case Rounding.RoundDownBelowHalf:
                        return overflow < half ? row : row + 1;
                    case Rounding.RoundUpOverHalf:
                        return overflow > half ? row + 1 : row;
                    case Rounding.RoundUp:
                        return overflow > 0 ? row + 1 : row;
                }
            };
        /**
         * @return {?}
         */
        DashboardService.prototype.commitWidgetChanges = /**
         * @return {?}
         */
            function () {
                var /** @type {?} */ placeholder = this.placeholder$.getValue();
                // check that we have all the values we need
                if (placeholder.column === undefined || placeholder.row === undefined ||
                    placeholder.columnSpan === undefined || placeholder.rowSpan === undefined) {
                    return;
                }
                if (this._actionWidget) {
                    this._actionWidget.widget.setColumn(placeholder.column);
                    this._actionWidget.widget.setRow(placeholder.row);
                    this._actionWidget.widget.setColumnSpan(placeholder.columnSpan);
                    this._actionWidget.widget.setRowSpan(placeholder.rowSpan);
                }
                // reset all placeholder values
                placeholder.column = undefined;
                placeholder.row = undefined;
                placeholder.columnSpan = undefined;
                placeholder.rowSpan = undefined;
                // emit the new placeholder values
                this.placeholder$.next(placeholder);
            };
        /**
         * Get the current column width
         */
        /**
         * Get the current column width
         * @return {?}
         */
        DashboardService.prototype.getColumnWidth = /**
         * Get the current column width
         * @return {?}
         */
            function () {
                return Math.floor(this.columnWidth);
            };
        /**
         * Calculate the number of rows populated with widgets
         */
        /**
         * Calculate the number of rows populated with widgets
         * @return {?}
         */
        DashboardService.prototype.getRowCount = /**
         * Calculate the number of rows populated with widgets
         * @return {?}
         */
            function () {
                return this.widgets.reduce(function (previous, widget) { return Math.max(widget.getRow() + widget.getRowSpan(), previous); }, 0);
            };
        /**
         * Set the height of the dashboard container element
         */
        /**
         * Set the height of the dashboard container element
         * @return {?}
         */
        DashboardService.prototype.setDashboardHeight = /**
         * Set the height of the dashboard container element
         * @return {?}
         */
            function () {
                // size the dashboard container to ensure all rows fit
                var /** @type {?} */ rowCount = this.getRowCount();
                // if we should show an empty row increment the row count by 1
                if (this.options.emptyRow) {
                    rowCount++;
                }
                this.setDimensions(undefined, rowCount * this._rowHeight);
            };
        /**
         * Orders the z-index of all widgets to move the active one to the front
         * @param widget The widget that should be brought to the front
         */
        /**
         * Orders the z-index of all widgets to move the active one to the front
         * @param {?} widget The widget that should be brought to the front
         * @return {?}
         */
        DashboardService.prototype.bringToFront = /**
         * Orders the z-index of all widgets to move the active one to the front
         * @param {?} widget The widget that should be brought to the front
         * @return {?}
         */
            function (widget) {
                this.widgets.forEach(function (_widget) { return _widget === widget ? _widget.bringToFront() : _widget.sendToBack(); });
            };
        /**
         * Move a widget down - if widgets are in the position below, then move them down further
         * @param widget The widget to move downwards
         */
        /**
         * Move a widget down - if widgets are in the position below, then move them down further
         * @param {?} widget The widget to move downwards
         * @param {?=} distance
         * @return {?}
         */
        DashboardService.prototype.moveWidgetDown = /**
         * Move a widget down - if widgets are in the position below, then move them down further
         * @param {?} widget The widget to move downwards
         * @param {?=} distance
         * @return {?}
         */
            function (widget, distance) {
                var _this = this;
                if (distance === void 0) {
                    distance = 1;
                }
                // move the widget down one position
                widget.setRow(widget.getRow() + distance);
                // check every space the widget occupies for collisions
                this.forEachBlock(widget, function (column, row) {
                    return _this.getWidgetsAtPosition(column, row, true)
                        .filter(function (wgt) { return wgt !== widget; })
                        .forEach(function (wgt) { return _this.moveWidgetDown(wgt, distance); });
                });
            };
        /**
         * Widgets should not be allowed to have a vacant space above them - if there is one they should move upwards to fill it
         */
        /**
         * Widgets should not be allowed to have a vacant space above them - if there is one they should move upwards to fill it
         * @return {?}
         */
        DashboardService.prototype.shiftWidgetsUp = /**
         * Widgets should not be allowed to have a vacant space above them - if there is one they should move upwards to fill it
         * @return {?}
         */
            function () {
                var _this = this;
                // check whether or not changes have been made - if so we need to repeat until stable
                var /** @type {?} */ stable = true;
                // iterate each widget and
                this.widgets.forEach(function (widget) {
                    // if widget is already on the top row then do nothing
                    if (widget.getRow() === 0) {
                        return;
                    }
                    // if we are currently dragging and this is the dragging widget then skip
                    if (_this._actionWidget && _this._actionWidget.widget === widget) {
                        return;
                    }
                    if (_this.getPositionAvailable(widget.getColumn(), widget.getRow() - 1, widget.getColumnSpan(), 1)) {
                        widget.setRow(widget.getRow() - 1);
                        stable = false;
                    }
                });
                // if changes occurred then we should repeat the process
                if (!stable) {
                    this.shiftWidgetsUp();
                }
            };
        /**
         * Iterate over each space a widget occupied
         * @param widget The widget to determine spaces
         * @param callback The function to be called for each space, should expect a column and row argument witht he context being the widget
         */
        /**
         * Iterate over each space a widget occupied
         * @param {?} widget The widget to determine spaces
         * @param {?} callback The function to be called for each space, should expect a column and row argument witht he context being the widget
         * @return {?}
         */
        DashboardService.prototype.forEachBlock = /**
         * Iterate over each space a widget occupied
         * @param {?} widget The widget to determine spaces
         * @param {?} callback The function to be called for each space, should expect a column and row argument witht he context being the widget
         * @return {?}
         */
            function (widget, callback) {
                for (var /** @type {?} */ row = widget.getRow(); row < widget.getRow() + widget.getRowSpan(); row++) {
                    for (var /** @type {?} */ column = widget.getColumn(); column < widget.getColumn() + widget.getColumnSpan(); column++) {
                        callback.call(widget, column, row);
                    }
                }
            };
        /**
         * Returns the number of columns available
         */
        /**
         * Returns the number of columns available
         * @return {?}
         */
        DashboardService.prototype.getColumnCount = /**
         * Returns the number of columns available
         * @return {?}
         */
            function () {
                return this.stacked ? 1 : this.options.columns;
            };
        DashboardService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        DashboardService.ctorParameters = function () { return []; };
        return DashboardService;
    }());
    var /** @type {?} */ defaultOptions = { columns: 5, padding: 5, minWidth: 100, minHeight: 100, emptyRow: true };
    /** @enum {number} */
    var ActionDirection = {
        Top: 0,
        TopRight: 1,
        Right: 2,
        BottomRight: 3,
        Bottom: 4,
        BottomLeft: 5,
        Left: 6,
        TopLeft: 7,
        Move: 8,
    };
    ActionDirection[ActionDirection.Top] = "Top";
    ActionDirection[ActionDirection.TopRight] = "TopRight";
    ActionDirection[ActionDirection.Right] = "Right";
    ActionDirection[ActionDirection.BottomRight] = "BottomRight";
    ActionDirection[ActionDirection.Bottom] = "Bottom";
    ActionDirection[ActionDirection.BottomLeft] = "BottomLeft";
    ActionDirection[ActionDirection.Left] = "Left";
    ActionDirection[ActionDirection.TopLeft] = "TopLeft";
    ActionDirection[ActionDirection.Move] = "Move";
    /** @enum {number} */
    var Rounding = {
        RoundDown: 0,
        RoundDownBelowHalf: 1,
        RoundUp: 2,
        RoundUpOverHalf: 3,
    };
    Rounding[Rounding.RoundDown] = "RoundDown";
    Rounding[Rounding.RoundDownBelowHalf] = "RoundDownBelowHalf";
    Rounding[Rounding.RoundUp] = "RoundUp";
    Rounding[Rounding.RoundUpOverHalf] = "RoundUpOverHalf";

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DashboardComponent = (function () {
        function DashboardComponent(dashboardService) {
            var _this = this;
            this.dashboardService = dashboardService;
            this.layoutChange = new core.EventEmitter();
            dashboardService.layout$.subscribe(function (layout) { return _this.layoutChange.emit(layout); });
        }
        Object.defineProperty(DashboardComponent.prototype, "layout", {
            set: /**
             * @param {?} layout
             * @return {?}
             */ function (layout) {
                if (layout) {
                    this.dashboardService.layout$.next(layout);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DashboardComponent.prototype, "options", {
            set: /**
             * @param {?} options
             * @return {?}
             */ function (options) {
                this.dashboardService.options$.next(__assign({}, defaultOptions, options));
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Set the initial dimensions
         */
        /**
         * Set the initial dimensions
         * @return {?}
         */
        DashboardComponent.prototype.ngAfterViewInit = /**
         * Set the initial dimensions
         * @return {?}
         */
            function () {
                this.dashboardService.setDimensions(this.dashboardElement.nativeElement.offsetWidth, this.dashboardElement.nativeElement.offsetHeight);
            };
        /**
         * @param {?} event
         * @return {?}
         */
        DashboardComponent.prototype.onResize = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.dashboardService.setDimensions(event.width, event.height);
            };
        DashboardComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-dashboard',
                        template: "<div #dashboard class=\"dashboard-container\" [style.height.px]=\"dashboardService.height$ | async\">\n    <div (uxResize)=\"onResize($event)\" [throttle]=\"16\" class=\"dashboard\">\n        <ng-content></ng-content>\n    </div>\n    \n    <div class=\"position-indicator\" *ngIf=\"(dashboardService.placeholder$ | async).visible\" \n        [style.left.px]=\"(dashboardService.placeholder$ | async).x\" \n        [style.top.px]=\"(dashboardService.placeholder$ | async).y\" \n        [style.width.px]=\"(dashboardService.placeholder$ | async).width\"\n        [style.height.px]=\"(dashboardService.placeholder$ | async).height\"></div>\n</div>",
                        providers: [DashboardService],
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        DashboardComponent.ctorParameters = function () {
            return [
                { type: DashboardService }
            ];
        };
        DashboardComponent.propDecorators = {
            layout: [{ type: core.Input }],
            options: [{ type: core.Input }],
            layoutChange: [{ type: core.Output }],
            dashboardElement: [{ type: core.ViewChild, args: ['dashboard',] }]
        };
        return DashboardComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DashboardWidgetComponent = (function () {
        function DashboardWidgetComponent(dashboardService) {
            var _this = this;
            this.dashboardService = dashboardService;
            this.colSpan = 1;
            this.rowSpan = 1;
            this.resizable = false;
            this.x = 0;
            this.y = 0;
            this.width = 100;
            this.height = 100;
            this.padding = 0;
            this.zIndex = 0;
            this._column = { regular: undefined, stacked: undefined };
            this._row = { regular: undefined, stacked: undefined };
            this._columnSpan = { regular: 1, stacked: 1 };
            this._rowSpan = { regular: 1, stacked: 1 };
            this._subscription = dashboardService.options$.subscribe(function () { return _this.update(); });
        }
        /**
         * @return {?}
         */
        DashboardWidgetComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this._columnSpan.regular = this.colSpan;
                this._rowSpan.regular = this.rowSpan;
                if (!this.id) {
                    console.warn('Dashboard Widget is missing an ID.');
                    // set random id - keeps things working but prevents exporting of positions
                    this.id = Math.floor(Math.random() * 100000).toString();
                }
            };
        /**
         * @return {?}
         */
        DashboardWidgetComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                // add the widget to the dashboard
                this.dashboardService.addWidget(this);
                // apply the current options
                this.update();
            };
        /**
         * If component is removed, then unregister it from the service
         */
        /**
         * If component is removed, then unregister it from the service
         * @return {?}
         */
        DashboardWidgetComponent.prototype.ngOnDestroy = /**
         * If component is removed, then unregister it from the service
         * @return {?}
         */
            function () {
                this._subscription.unsubscribe();
                this.dashboardService.removeWidget(this);
            };
        /**
         * Apply the current dashboard options
         */
        /**
         * Apply the current dashboard options
         * @return {?}
         */
        DashboardWidgetComponent.prototype.update = /**
         * Apply the current dashboard options
         * @return {?}
         */
            function () {
                // get the current options at the time
                var _a = this.dashboardService.options, padding = _a.padding, columns = _a.columns;
                this.padding = padding;
                this._columnSpan.stacked = columns;
            };
        /**
         * Set the actual position and size values
         */
        /**
         * Set the actual position and size values
         * @return {?}
         */
        DashboardWidgetComponent.prototype.render = /**
         * Set the actual position and size values
         * @return {?}
         */
            function () {
                this.x = this.getColumn() * this.dashboardService.getColumnWidth();
                this.y = this.getRow() * this.dashboardService.getRowHeight();
                this.width = this.getColumnSpan() * this.dashboardService.getColumnWidth();
                this.height = this.getRowSpan() * this.dashboardService.getRowHeight();
            };
        /**
         * @return {?}
         */
        DashboardWidgetComponent.prototype.getColumn = /**
         * @return {?}
         */
            function () {
                return this.getStackableValue(this._column);
            };
        /**
         * @return {?}
         */
        DashboardWidgetComponent.prototype.getRow = /**
         * @return {?}
         */
            function () {
                return this.getStackableValue(this._row);
            };
        /**
         * @param {?} column
         * @param {?=} render
         * @return {?}
         */
        DashboardWidgetComponent.prototype.setColumn = /**
         * @param {?} column
         * @param {?=} render
         * @return {?}
         */
            function (column, render) {
                if (render === void 0) {
                    render = true;
                }
                this.setStackableValue(this._column, column);
                if (render) {
                    this.render();
                }
            };
        /**
         * @param {?} row
         * @param {?=} render
         * @return {?}
         */
        DashboardWidgetComponent.prototype.setRow = /**
         * @param {?} row
         * @param {?=} render
         * @return {?}
         */
            function (row, render) {
                if (render === void 0) {
                    render = true;
                }
                this.setStackableValue(this._row, row);
                if (render) {
                    this.render();
                }
            };
        /**
         * @return {?}
         */
        DashboardWidgetComponent.prototype.getColumnSpan = /**
         * @return {?}
         */
            function () {
                return this.getStackableValue(this._columnSpan);
            };
        /**
         * @return {?}
         */
        DashboardWidgetComponent.prototype.getRowSpan = /**
         * @return {?}
         */
            function () {
                return this.getStackableValue(this._rowSpan);
            };
        /**
         * @param {?} columnSpan
         * @param {?=} render
         * @return {?}
         */
        DashboardWidgetComponent.prototype.setColumnSpan = /**
         * @param {?} columnSpan
         * @param {?=} render
         * @return {?}
         */
            function (columnSpan, render) {
                if (render === void 0) {
                    render = true;
                }
                this.setStackableValue(this._columnSpan, columnSpan);
                if (render) {
                    this.render();
                }
            };
        /**
         * @param {?} rowSpan
         * @param {?=} render
         * @return {?}
         */
        DashboardWidgetComponent.prototype.setRowSpan = /**
         * @param {?} rowSpan
         * @param {?=} render
         * @return {?}
         */
            function (rowSpan, render) {
                if (render === void 0) {
                    render = true;
                }
                this.setStackableValue(this._rowSpan, rowSpan);
                if (render) {
                    this.render();
                }
            };
        /**
         * @return {?}
         */
        DashboardWidgetComponent.prototype.bringToFront = /**
         * @return {?}
         */
            function () {
                this.zIndex = 1;
            };
        /**
         * @return {?}
         */
        DashboardWidgetComponent.prototype.sendToBack = /**
         * @return {?}
         */
            function () {
                this.zIndex = 0;
            };
        /**
         * @param {?} x
         * @param {?} y
         * @param {?} width
         * @param {?} height
         * @return {?}
         */
        DashboardWidgetComponent.prototype.setBounds = /**
         * @param {?} x
         * @param {?} y
         * @param {?} width
         * @param {?} height
         * @return {?}
         */
            function (x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
            };
        /**
         * @param {?} handle
         * @param {?} event
         * @param {?} direction
         * @return {?}
         */
        DashboardWidgetComponent.prototype.dragstart = /**
         * @param {?} handle
         * @param {?} event
         * @param {?} direction
         * @return {?}
         */
            function (handle, event, direction) {
                this.dashboardService.onResizeStart({ widget: this, direction: direction, event: event, handle: handle });
            };
        /**
         * @param {?} handle
         * @param {?} event
         * @param {?} direction
         * @return {?}
         */
        DashboardWidgetComponent.prototype.drag = /**
         * @param {?} handle
         * @param {?} event
         * @param {?} direction
         * @return {?}
         */
            function (handle, event, direction) {
                this.dashboardService.onResizeDrag({ widget: this, direction: direction, event: event, handle: handle });
            };
        /**
         * @return {?}
         */
        DashboardWidgetComponent.prototype.dragend = /**
         * @return {?}
         */
            function () {
                this.dashboardService.onResizeEnd();
            };
        /**
         * Allows automatic setting of stackable value
         * @param {?} property The current StackableValue object
         * @param {?} value The value to set in the appropriate field
         * @return {?}
         */
        DashboardWidgetComponent.prototype.setStackableValue = /**
         * Allows automatic setting of stackable value
         * @param {?} property The current StackableValue object
         * @param {?} value The value to set in the appropriate field
         * @return {?}
         */
            function (property, value) {
                if (this.dashboardService.stacked) {
                    property.stacked = value;
                }
                else {
                    property.regular = value;
                }
            };
        /**
         * Return the appropriate value from a stackable value
         * @param {?} property The Stackable value object
         * @return {?}
         */
        DashboardWidgetComponent.prototype.getStackableValue = /**
         * Return the appropriate value from a stackable value
         * @param {?} property The Stackable value object
         * @return {?}
         */
            function (property) {
                return this.dashboardService.stacked ? property.stacked : property.regular;
            };
        DashboardWidgetComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-dashboard-widget',
                        template: "<div class=\"widget-content widget-col-span-{{ getColumnSpan() }} widget-row-span-{{ getRowSpan() }}\">\n    <ng-content></ng-content>\n</div>\n\n<div uxDrag\n     #handleTop\n     class=\"resizer-handle handle-top\"\n     (onDragStart)=\"dragstart(handleTop, $event, 0)\"\n     (onDrag)=\"drag(handleTop, $event, 0)\"\n     (onDragEnd)=\"dragend()\"\n     [style.top.px]=\"padding\"\n     [hidden]=\"!resizable\">\n</div>\n\n<div uxDrag\n     #handleTopRight\n     class=\"resizer-handle handle-top-right\"\n     (onDragStart)=\"dragstart(handleTopRight, $event, 1)\"\n     (onDrag)=\"drag(handleTopRight, $event, 1)\"\n     (onDragEnd)=\"dragend()\"\n     [style.top.px]=\"padding\"\n     [style.right.px]=\"padding\"\n     [hidden]=\"!resizable && !(dashboardService.stacked$ | async)\">\n</div>\n\n<div uxDrag\n     #handleRight\n     class=\"resizer-handle handle-right\"\n     (onDragStart)=\"dragstart(handleRight, $event, 2)\"\n     (onDrag)=\"drag(handleRight, $event, 2)\"\n     (onDragEnd)=\"dragend()\"\n     [style.right.px]=\"padding\"\n     [hidden]=\"!resizable || (dashboardService.stacked$ | async)\">\n</div>\n\n<div uxDrag\n     #handleBottomRight\n     class=\"resizer-handle handle-bottom-right\"\n     (onDragStart)=\"dragstart(handleBottomRight, $event, 3)\"\n     (onDrag)=\"drag(handleBottomRight, $event, 3)\"\n     (onDragEnd)=\"dragend()\"\n     [style.bottom.px]=\"padding\"\n     [style.right.px]=\"padding\"\n     [hidden]=\"!resizable && !(dashboardService.stacked$ | async)\">\n</div>\n\n<div uxDrag\n     #handleBottom\n     class=\"resizer-handle handle-bottom\"\n     (onDragStart)=\"dragstart(handleBottom, $event, 4)\"\n     (onDrag)=\"drag(handleBottom, $event, 4)\"\n     (onDragEnd)=\"dragend()\"\n     [style.bottom.px]=\"padding\"\n     [hidden]=\"!resizable\">\n</div>\n\n<div uxDrag\n     #handleBottomLeft\n     class=\"resizer-handle handle-bottom-left\"\n     (onDragStart)=\"dragstart(handleBottomLeft, $event, 5)\"\n     (onDrag)=\"drag(handleBottomLeft, $event, 5)\"\n     (onDragEnd)=\"dragend()\"\n     [style.bottom.px]=\"padding\"\n     [style.left.px]=\"padding\"\n     [hidden]=\"!resizable && !(dashboardService.stacked$ | async)\">\n</div>\n\n<div uxDrag\n     #handleLeft\n     class=\"resizer-handle handle-left\"\n     (onDragStart)=\"dragstart(handleLeft, $event, 6)\"\n     (onDrag)=\"drag(handleLeft, $event, 6)\"\n     (onDragEnd)=\"dragend()\"\n     [style.left.px]=\"padding\"\n     [hidden]=\"!resizable || (dashboardService.stacked$ | async)\">\n</div>\n\n<div uxDrag\n     #handleTopLeft\n     class=\"resizer-handle handle-top-left\"\n     (onDragStart)=\"dragstart(handleTopLeft, $event, 7)\"\n     (onDrag)=\"drag(handleTopLeft, $event, 7)\"\n     (onDragEnd)=\"dragend()\"\n     [style.top.px]=\"padding\"\n     [style.left.px]=\"padding\"\n     [hidden]=\"!resizable && !(dashboardService.stacked$ | async)\">\n</div>"
                    }] }
        ];
        /** @nocollapse */
        DashboardWidgetComponent.ctorParameters = function () {
            return [
                { type: DashboardService }
            ];
        };
        DashboardWidgetComponent.propDecorators = {
            id: [{ type: core.Input }],
            col: [{ type: core.Input }],
            row: [{ type: core.Input }],
            colSpan: [{ type: core.Input }],
            rowSpan: [{ type: core.Input }],
            resizable: [{ type: core.Input }],
            x: [{ type: core.HostBinding, args: ['style.left.px',] }],
            y: [{ type: core.HostBinding, args: ['style.top.px',] }],
            width: [{ type: core.HostBinding, args: ['style.width.px',] }],
            height: [{ type: core.HostBinding, args: ['style.height.px',] }],
            padding: [{ type: core.HostBinding, args: ['style.padding.px',] }],
            zIndex: [{ type: core.HostBinding, args: ['style.z-index',] }]
        };
        return DashboardWidgetComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DragService = (function () {
        function DragService() {
            /**
             * Emit when dragging begins
             */
            this.onDragStart = new Subject.Subject();
            /**
             * Emit when dragging moves
             */
            this.onDrag = new Subject.Subject();
            /**
             * Emit when dragging ends
             */
            this.onDragEnd = new Subject.Subject();
            /**
             * Emit when the user is dragging over the drop area
             */
            this.onDropEnter = new Subject.Subject();
            /**
             * Emit when the user is dragging out of the drop area
             */
            this.onDropLeave = new Subject.Subject();
            /**
             * Emit when a drop occurs
             */
            this.onDrop = new Subject.Subject();
        }
        /** Destroy all observables */
        /**
         * Destroy all observables
         * @return {?}
         */
        DragService.prototype.ngOnDestroy = /**
         * Destroy all observables
         * @return {?}
         */
            function () {
                this.onDragStart.complete();
                this.onDrag.complete();
                this.onDragEnd.complete();
                this.onDrop.complete();
                this.onDropEnter.complete();
                this.onDropLeave.complete();
            };
        DragService.decorators = [
            { type: core.Injectable }
        ];
        return DragService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DragDirective = (function () {
        function DragDirective(_elementRef, _ngZone, _renderer, _drag) {
            var _this = this;
            this._elementRef = _elementRef;
            this._ngZone = _ngZone;
            this._renderer = _renderer;
            this._drag = _drag;
            /**
             * Detemine if we should show a clone when dragging
             */
            this.clone = false;
            /**
             * Allow the dragging to be enabled/disabled
             */
            this.draggable = true;
            /**
             * Emit an event when dragging starts
             */
            this.onDragStart = new core.EventEmitter();
            /**
             * Emit an event when the mouse moves while dragging
             */
            this.onDrag = new core.EventEmitter();
            /**
             * Emit an event when the dragging finishes
             */
            this.onDragEnd = new core.EventEmitter();
            /**
             * Emit when the user drops an item in a drop area
             */
            this.onDrop = new core.EventEmitter();
            /**
             * Emit when the user drags over a drop area
             */
            this.onDropEnter = new core.EventEmitter();
            /**
             * Emit when the user drags out of a drop area
             */
            this.onDropLeave = new core.EventEmitter();
            /**
             * Store the dragging state
             */
            this._isDragging = false;
            /**
             * Create an observable from the mouse down event
             */
            this._mousedown$ = fromEvent.fromEvent(this._elementRef.nativeElement, 'mousedown');
            /**
             * Create an observable from the mouse move event
             */
            this._mousemove$ = fromEvent.fromEvent(document, 'mousemove');
            /**
             * Create an observable from the mouse up event
             */
            this._mouseup$ = fromEvent.fromEvent(document, 'mouseup');
            /**
             * Use an observable to unsubscribe from all subscriptions
             */
            this._onDestroy = new Subject.Subject();
            // ensure all mouse down events on the object are captured
            this._mousedown$.pipe(operators.filter(function () { return _this.draggable; }), operators.takeUntil(this._onDestroy)).subscribe(this.dragStart.bind(this));
            // emit the outputs when drag events occur
            _drag.onDragStart.pipe(operators.takeUntil(this._onDestroy), operators.filter(function () { return _this._isDragging; }))
                .subscribe(function (dragEvent) { return _this.onDragStart.emit(dragEvent.event); });
            _drag.onDrag.pipe(operators.takeUntil(this._onDestroy), operators.filter(function () { return _this._isDragging; }))
                .subscribe(function (dragEvent) { return _this.onDrag.emit(dragEvent.event); });
            _drag.onDragEnd.pipe(operators.takeUntil(this._onDestroy), operators.filter(function () { return _this._isDragging; }))
                .subscribe(function () { return _this.onDragEnd.emit(); });
            _drag.onDrop.pipe(operators.takeUntil(this._onDestroy), operators.filter(function () { return _this._isDragging; }))
                .subscribe(function (event) { return _this.onDrop.emit(event); });
            _drag.onDropEnter.pipe(operators.takeUntil(this._onDestroy), operators.filter(function () { return _this._isDragging; }))
                .subscribe(function () { return _this.onDropEnter.emit(); });
            _drag.onDropLeave.pipe(operators.takeUntil(this._onDestroy), operators.filter(function () { return _this._isDragging; }))
                .subscribe(function () { return _this.onDropLeave.emit(); });
        }
        /** Emit events and create clone when drag starts */
        /**
         * Emit events and create clone when drag starts
         * @param {?} event
         * @return {?}
         */
        DragDirective.prototype.dragStart = /**
         * Emit events and create clone when drag starts
         * @param {?} event
         * @return {?}
         */
            function (event) {
                var _this = this;
                event.preventDefault();
                if (this.clone) {
                    // clone the node
                    this.cloneNode(event);
                }
                // apply a class to the element being dragged
                this._renderer.addClass(this._elementRef.nativeElement, 'ux-drag-dragging');
                // store the dragging state
                this._isDragging = true;
                // emit the drag start event
                this._ngZone.run(function () { return _this._drag.onDragStart.next({ event: event, group: _this.group, data: _this.model }); });
                this._mousemove$.pipe(operators.takeUntil(this._mouseup$), operators.takeUntil(this._onDestroy))
                    .subscribe(this.dragMove.bind(this), null, this.dragEnd.bind(this));
            };
        /** Emit event and update clone position when dragging moves */
        /**
         * Emit event and update clone position when dragging moves
         * @param {?} event
         * @return {?}
         */
        DragDirective.prototype.dragMove = /**
         * Emit event and update clone position when dragging moves
         * @param {?} event
         * @return {?}
         */
            function (event) {
                var _this = this;
                event.preventDefault();
                if (this._clone) {
                    this.updateNodePosition(event);
                }
                // emit the drag start event
                this._ngZone.run(function () { return _this._drag.onDrag.next({ event: event, group: _this.group, data: _this.model }); });
            };
        /** Emit event and destroy clone when dragging ends */
        /**
         * Emit event and destroy clone when dragging ends
         * @return {?}
         */
        DragDirective.prototype.dragEnd = /**
         * Emit event and destroy clone when dragging ends
         * @return {?}
         */
            function () {
                var _this = this;
                // if there was a clone, remove it
                if (this._clone) {
                    this._renderer.removeChild(document.body, this._clone);
                    this._clone = null;
                }
                // remove the dragging class
                this._renderer.removeClass(this._elementRef.nativeElement, 'ux-drag-dragging');
                // emit the on drag end output
                this._ngZone.run(function () { return _this._drag.onDragEnd.next({ group: _this.group, data: _this.model }); });
                // store the dragging state
                this._isDragging = false;
            };
        /** Create an exact clone of an element */
        /**
         * Create an exact clone of an element
         * @param {?} event
         * @return {?}
         */
        DragDirective.prototype.cloneNode = /**
         * Create an exact clone of an element
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // duplicate the node
                this._clone = this._elementRef.nativeElement.cloneNode(true);
                // store the position within the draggable element
                var _a = this._elementRef.nativeElement.getBoundingClientRect(), top = _a.top, left = _a.left, width = _a.width;
                this._offset = { x: event.clientX - left, y: event.clientY - top };
                // inline all styles so it looks identical regardless of its position in the DOM
                this.inlineStyles(this._elementRef.nativeElement, this._clone);
                // IE doesn't always calculate the correct width value using getComputedStyles... use bounding client value instead
                this._renderer.setStyle(this._clone, 'width', width + 'px');
                // ensure we can easily position the node an it is above all other elements
                this._renderer.setAttribute(this._clone, 'aria-hidden', 'true');
                this._renderer.setStyle(this._clone, 'position', 'absolute');
                this._renderer.setStyle(this._clone, 'z-index', '99999');
                // apply a class to allow custom styling
                this._renderer.addClass(this._clone, 'ux-drag-dragging-clone');
                // insert the cloned element
                this._renderer.appendChild(document.body, this._clone);
                // set the cloned element initial position
                this.updateNodePosition(event);
            };
        /** Position the clone relative to the mouse */
        /**
         * Position the clone relative to the mouse
         * @param {?} event
         * @return {?}
         */
        DragDirective.prototype.updateNodePosition = /**
         * Position the clone relative to the mouse
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this._renderer.setStyle(this._clone, 'left', (event.pageX - this._offset.x) + 'px');
                this._renderer.setStyle(this._clone, 'top', (event.pageY - this._offset.y) + 'px');
            };
        /** Inline all styles to ensure styling is consistent regardless of its position in the dom */
        /**
         * Inline all styles to ensure styling is consistent regardless of its position in the dom
         * @param {?} source
         * @param {?} target
         * @return {?}
         */
        DragDirective.prototype.inlineStyles = /**
         * Inline all styles to ensure styling is consistent regardless of its position in the dom
         * @param {?} source
         * @param {?} target
         * @return {?}
         */
            function (source, target) {
                // get all the computed styles from the source element
                var /** @type {?} */ styles = getComputedStyle(source);
                // inline every specified style
                for (var /** @type {?} */ idx = 0; idx < styles.length; idx++) {
                    var /** @type {?} */ style = styles.item(idx);
                    if (style !== undefined) {
                        this._renderer.setStyle(target, styles[idx], styles[style]);
                    }
                }
                // ensure we dont capture any move events
                this._renderer.setStyle(target, 'pointer-events', 'none');
                // do the same for all the child elements
                for (var /** @type {?} */ idx = 0; idx < source.children.length; idx++) {
                    this.inlineStyles(source.children[idx], target.children[idx]);
                }
            };
        /** Unsubscribe from all subscriptions */
        /**
         * Unsubscribe from all subscriptions
         * @return {?}
         */
        DragDirective.prototype.ngOnDestroy = /**
         * Unsubscribe from all subscriptions
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        DragDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxDrag]'
                    },] }
        ];
        /** @nocollapse */
        DragDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.NgZone },
                { type: core.Renderer2 },
                { type: DragService }
            ];
        };
        DragDirective.propDecorators = {
            clone: [{ type: core.Input }],
            group: [{ type: core.Input }],
            model: [{ type: core.Input }],
            draggable: [{ type: core.Input }],
            onDragStart: [{ type: core.Output }],
            onDrag: [{ type: core.Output }],
            onDragEnd: [{ type: core.Output }],
            onDrop: [{ type: core.Output }],
            onDropEnter: [{ type: core.Output }],
            onDropLeave: [{ type: core.Output }]
        };
        return DragDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DropDirective = (function () {
        function DropDirective(_dragService) {
            var _this = this;
            this._dragService = _dragService;
            /**
             * Emit the model of the item dropped
             */
            this.onDrop = new core.EventEmitter();
            /**
             * Determine whether or not the mouse is within the drop region
             */
            this.isMouseOver = false;
            /**
             * Determine whether or not we are currently dragging an item
             */
            this.isDragging = false;
            /**
             * Ensure we destroy all subscriptions
             */
            this._onDestroy = new Subject.Subject();
            // subscribe to drag events
            _dragService.onDragStart.pipe(operators.takeUntil(this._onDestroy), operators.filter(function (event) { return _this.isGroupAllowed(event.group); })).subscribe(this.onDragStart.bind(this));
            _dragService.onDragEnd.pipe(operators.takeUntil(this._onDestroy), operators.filter(function (event) { return _this.isGroupAllowed(event.group); })).subscribe(this.onDragEnd.bind(this));
        }
        /**
         * @return {?}
         */
        DropDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /** Update the mouse over state */
        /**
         * Update the mouse over state
         * @return {?}
         */
        DropDirective.prototype.onMouseOver = /**
         * Update the mouse over state
         * @return {?}
         */
            function () {
                if (this.isGroupAllowed(this._group)) {
                    this.isMouseOver = true;
                    // emit that we are over a drop area
                    this._dragService.onDropEnter.next();
                }
            };
        /** Update the mouse over state */
        /**
         * Update the mouse over state
         * @return {?}
         */
        DropDirective.prototype.onMouseLeave = /**
         * Update the mouse over state
         * @return {?}
         */
            function () {
                // always ensure this value is reset
                this.isMouseOver = false;
                // only emit the dropd leave event when appropriate
                if (this.isGroupAllowed(this._group)) {
                    this._dragService.onDropLeave.next();
                }
            };
        /** Update the dragging state */
        /**
         * Update the dragging state
         * @param {?} event
         * @return {?}
         */
        DropDirective.prototype.onDragStart = /**
         * Update the dragging state
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.isDragging = true;
                this._group = event.group;
            };
        /** Update the dragging state */
        /**
         * Update the dragging state
         * @param {?} event
         * @return {?}
         */
        DropDirective.prototype.onDragEnd = /**
         * Update the dragging state
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // update the dragging state
                this.isDragging = false;
                // clear the cached group
                this._group = null;
                // if the mouse is over and it is in an allowed group emit the dop event
                if (this.isMouseOver && this.isGroupAllowed(event.group)) {
                    this.onDrop.emit(event.data);
                    this._dragService.onDrop.next(event.data);
                }
            };
        /**
         * Determine whether or not the event is part of the specified groups
         * @param {?} group
         * @return {?}
         */
        DropDirective.prototype.isGroupAllowed = /**
         * Determine whether or not the event is part of the specified groups
         * @param {?} group
         * @return {?}
         */
            function (group) {
                // if no group specified allow all groups
                if (!this.group) {
                    return true;
                }
                // if it is an array then ensure it is allowed
                if (Array.isArray(this.group)) {
                    return !!this.group.find(function (_group) { return _group === group; });
                }
                return this.group === group;
            };
        DropDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxDrop]',
                        host: {
                            '[class.ux-drop-hover]': 'isMouseOver && isDragging'
                        }
                    },] }
        ];
        /** @nocollapse */
        DropDirective.ctorParameters = function () {
            return [
                { type: DragService }
            ];
        };
        DropDirective.propDecorators = {
            group: [{ type: core.Input }],
            onDrop: [{ type: core.Output }],
            onMouseOver: [{ type: core.HostListener, args: ['mouseenter',] }],
            onMouseLeave: [{ type: core.HostListener, args: ['mouseleave',] }]
        };
        return DropDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DragModule = (function () {
        function DragModule() {
        }
        DragModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [DragDirective, DropDirective],
                        declarations: [DragDirective, DropDirective],
                        providers: [DragService]
                    },] }
        ];
        return DragModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DashboardDragHandleDirective = (function (_super) {
        __extends(DashboardDragHandleDirective, _super);
        function DashboardDragHandleDirective(widget, dashboardService, elementRef, ngZone, renderer, drag) {
            var _this = _super.call(this, elementRef, ngZone, renderer, drag) || this;
            _this.onDragStart.pipe(operators.takeUntil(_this._onDestroy))
                .subscribe(function (event) { return dashboardService.onDragStart({ widget: widget, direction: ActionDirection.Move, event: event }); });
            _this.onDrag.pipe(operators.takeUntil(_this._onDestroy))
                .subscribe(function (event) { return dashboardService.onDrag({ widget: widget, direction: ActionDirection.Move, event: event }); });
            _this.onDragEnd.pipe(operators.takeUntil(_this._onDestroy))
                .subscribe(function () { return dashboardService.onDragEnd(); });
            return _this;
        }
        DashboardDragHandleDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxDashboardWidgetDragHandle], [ux-dashboard-widget-drag-handle]'
                    },] }
        ];
        /** @nocollapse */
        DashboardDragHandleDirective.ctorParameters = function () {
            return [
                { type: DashboardWidgetComponent },
                { type: DashboardService },
                { type: core.ElementRef },
                { type: core.NgZone },
                { type: core.Renderer2 },
                { type: DragService }
            ];
        };
        return DashboardDragHandleDirective;
    }(DragDirective));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ DECLARATIONS = [
        DashboardComponent,
        DashboardWidgetComponent,
        DashboardDragHandleDirective
    ];
    var DashboardModule = (function () {
        function DashboardModule() {
        }
        DashboardModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            ResizeModule,
                            DragModule
                        ],
                        exports: DECLARATIONS,
                        declarations: DECLARATIONS,
                        providers: [DashboardService],
                    },] }
        ];
        return DashboardModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ SPIN_BUTTON_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return SpinButtonComponent; }),
        multi: true
    };
    var SpinButtonComponent = (function () {
        function SpinButtonComponent() {
            this.type = 'text';
            this.placeholder = '';
            this.disabled = false;
            this.spinners = true;
            this.readOnly = true;
            this.scrolling = true;
            this.arrowkeys = true;
            this.valueChange = new core.EventEmitter();
            this.increment = new core.EventEmitter();
            this.decrement = new core.EventEmitter();
            this.onTouchedCallback = function () { };
            this.onChangeCallback = function () { };
        }
        Object.defineProperty(SpinButtonComponent.prototype, "value", {
            get: /**
             * @return {?}
             */ function () {
                return this._value;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._value = value;
                this.onChangeCallback(value);
                this.onTouchedCallback();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} event
         * @return {?}
         */
        SpinButtonComponent.prototype.scroll = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (!this.scrolling) {
                    return;
                }
                if (event.deltaY > 0) {
                    this.triggerDecrement();
                }
                else {
                    this.triggerIncrement();
                }
                event.preventDefault();
            };
        /**
         * @return {?}
         */
        SpinButtonComponent.prototype.triggerIncrement = /**
         * @return {?}
         */
            function () {
                if (!this.disabled) {
                    this.increment.emit();
                }
            };
        /**
         * @return {?}
         */
        SpinButtonComponent.prototype.triggerDecrement = /**
         * @return {?}
         */
            function () {
                if (!this.disabled) {
                    this.decrement.emit();
                }
            };
        /**
         * @param {?} value
         * @return {?}
         */
        SpinButtonComponent.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                this.value = value;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        SpinButtonComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onChangeCallback = fn;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        SpinButtonComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onTouchedCallback = fn;
            };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        SpinButtonComponent.prototype.setDisabledState = /**
         * @param {?} isDisabled
         * @return {?}
         */
            function (isDisabled) {
                this.disabled = isDisabled;
            };
        SpinButtonComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-spin-button',
                        template: "<button class=\"spin-button\"\n        *ngIf=\"spinners\"\n        tabindex=\"-1\"\n        [disabled]=\"disabled\"\n        [attr.aria-label]=\"incrementAriaLabel\"\n        [attr.aria-disabled]=\"disabled\"\n        (click)=\"triggerIncrement()\">\n\n  <span class=\"hpe-icon hpe-up\"></span>\n</button>\n\n<input [type]=\"type\"\n       role=\"spinbutton\"\n       [min]=\"min\"\n       [max]=\"max\"\n       [tabindex]=\"0\"\n       class=\"form-control\"\n       [placeholder]=\"placeholder\"\n       [readOnly]=\"readOnly\"\n       [disabled]=\"disabled\"\n       [attr.aria-label]=\"inputAriaLabel\"\n       [attr.aria-disabled]=\"disabled\"\n       [attr.aria-valuemin]=\"min\"\n       [attr.aria-valuenow]=\"value\"\n       [attr.aria-valuemax]=\"max\"\n       [attr.aria-readonly]=\"readOnly\"\n       [ngModel]=\"value\"\n       (ngModelChange)=\"valueChange.emit($event)\"\n       (wheel)=\"scroll($event)\"\n       (keydown.arrowup)=\"arrowkeys ? triggerIncrement() : null; $event.preventDefault()\"\n       (keydown.arrowdown)=\"arrowkeys ? triggerDecrement() : null; $event.preventDefault()\">\n\n<button class=\"spin-button\"\n        *ngIf=\"spinners\"\n        tabindex=\"-1\"\n        [disabled]=\"disabled\"\n        [attr.aria-label]=\"decrementAriaLabel\"\n        [attr.aria-disabled]=\"disabled\"\n        (click)=\"triggerDecrement()\">\n\n  <span class=\"hpe-icon hpe-down\"></span>\n</button>",
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        providers: [SPIN_BUTTON_VALUE_ACCESSOR]
                    }] }
        ];
        SpinButtonComponent.propDecorators = {
            value: [{ type: core.Input }],
            type: [{ type: core.Input }],
            min: [{ type: core.Input }],
            max: [{ type: core.Input }],
            placeholder: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            spinners: [{ type: core.Input }],
            readOnly: [{ type: core.Input }],
            scrolling: [{ type: core.Input }],
            arrowkeys: [{ type: core.Input }],
            incrementAriaLabel: [{ type: core.Input }],
            inputAriaLabel: [{ type: core.Input }],
            decrementAriaLabel: [{ type: core.Input }],
            valueChange: [{ type: core.Output }],
            increment: [{ type: core.Output }],
            decrement: [{ type: core.Output }]
        };
        return SpinButtonComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SpinButtonModule = (function () {
        function SpinButtonModule() {
        }
        SpinButtonModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            forms.FormsModule
                        ],
                        exports: [SpinButtonComponent],
                        declarations: [SpinButtonComponent]
                    },] }
        ];
        return SpinButtonModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TimeFormatPipe = (function () {
        function TimeFormatPipe() {
        }
        /**
         * @param {?} value
         * @param {?} pad
         * @return {?}
         */
        TimeFormatPipe.prototype.transform = /**
         * @param {?} value
         * @param {?} pad
         * @return {?}
         */
            function (value, pad) {
                return value < 10 && pad ? '0' + value : value;
            };
        TimeFormatPipe.decorators = [
            { type: core.Pipe, args: [{
                        name: 'timeFormat'
                    },] }
        ];
        return TimeFormatPipe;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ TIME_PICKER_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return TimePickerComponent; }),
        multi: true
    };
    var TimePickerComponent = (function () {
        function TimePickerComponent() {
            var _this = this;
            this.arrowkeys = true;
            this.mousewheel = true;
            this.disabled = false;
            this.readOnly = false;
            this.showMeridian = false;
            this.showHours = true;
            this.showMinutes = true;
            this.showSeconds = false;
            this.showSpinners = true;
            this.hourStep = 1;
            this.minuteStep = 1;
            this.secondStep = 1;
            this.meridians = ['AM', 'PM'];
            this.valueChange = new core.EventEmitter();
            this.isValid = new core.EventEmitter();
            this.onTouchedCallback = function () { };
            this.onChangeCallback = function () { };
            this.value$ = new BehaviorSubject.BehaviorSubject(new Date());
            // create observables that are derived from the latest value
            this.hour$ = this.value$.pipe(operators.map(function (date) { return date.getHours(); }), operators.map(function (hour) { return _this.showMeridian ? _this.getMeridianTime(hour) : hour; }));
            this.minute$ = this.value$.pipe(operators.map(function (date) { return date.getMinutes(); }));
            this.second$ = this.value$.pipe(operators.map(function (date) { return date.getSeconds(); }));
            this.meridian$ = this.value$.pipe(operators.map(function (date) { return date.getHours() < 12 ? _this.meridians[0] : _this.meridians[1]; }));
            this.valid$ = this.value$.pipe(operators.map(function (date) { return _this.checkValidity(date); }));
            this._meridian = this.meridians[0];
            this._subscription = this.valid$.pipe(operators.distinctUntilChanged()).subscribe(function (valid) { return _this.isValid.emit(valid); });
        }
        Object.defineProperty(TimePickerComponent.prototype, "value", {
            get: /**
             * @return {?}
             */ function () {
                return new Date(this.value$.value);
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.value$.next(new Date(value));
                this.valueChange.emit(this.value$.value);
                this.onChangeCallback(this.value$.value);
                this.onTouchedCallback();
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        TimePickerComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @param {?} value
         * @return {?}
         */
        TimePickerComponent.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                this.value = value;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        TimePickerComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onChangeCallback = fn;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        TimePickerComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onTouchedCallback = fn;
            };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        TimePickerComponent.prototype.setDisabledState = /**
         * @param {?} isDisabled
         * @return {?}
         */
            function (isDisabled) {
                this.disabled = isDisabled;
            };
        /**
         * @param {?} hour
         * @return {?}
         */
        TimePickerComponent.prototype.getMeridianTime = /**
         * @param {?} hour
         * @return {?}
         */
            function (hour) {
                return hour > 12 ? hour - 12 : hour;
            };
        /**
         * @param {?} hour
         * @return {?}
         */
        TimePickerComponent.prototype.setHour = /**
         * @param {?} hour
         * @return {?}
         */
            function (hour) {
                var /** @type {?} */ date = this.value;
                date.setHours(hour ? hour : 0);
                this.value = date;
            };
        /**
         * @param {?} minute
         * @return {?}
         */
        TimePickerComponent.prototype.setMinute = /**
         * @param {?} minute
         * @return {?}
         */
            function (minute) {
                var /** @type {?} */ date = this.value;
                date.setMinutes(minute ? minute : 0);
                this.value = date;
            };
        /**
         * @param {?} seconds
         * @return {?}
         */
        TimePickerComponent.prototype.setSeconds = /**
         * @param {?} seconds
         * @return {?}
         */
            function (seconds) {
                var /** @type {?} */ date = this.value;
                date.setSeconds(seconds ? seconds : 0);
                this.value = date;
            };
        /**
         * @param {?=} arrowkey
         * @return {?}
         */
        TimePickerComponent.prototype.incrementHour = /**
         * @param {?=} arrowkey
         * @return {?}
         */
            function (arrowkey) {
                if (arrowkey === void 0) {
                    arrowkey = false;
                }
                if (this.disabled || arrowkey && !this.arrowkeys) {
                    return;
                }
                this.setHour(this.value.getHours() + this.hourStep);
            };
        /**
         * @param {?=} arrowkey
         * @return {?}
         */
        TimePickerComponent.prototype.decrementHour = /**
         * @param {?=} arrowkey
         * @return {?}
         */
            function (arrowkey) {
                if (arrowkey === void 0) {
                    arrowkey = false;
                }
                if (this.disabled || arrowkey && !this.arrowkeys) {
                    return;
                }
                this.setHour(this.value.getHours() - this.hourStep);
            };
        /**
         * @param {?=} arrowkey
         * @return {?}
         */
        TimePickerComponent.prototype.incrementMinute = /**
         * @param {?=} arrowkey
         * @return {?}
         */
            function (arrowkey) {
                if (arrowkey === void 0) {
                    arrowkey = false;
                }
                if (this.disabled || arrowkey && !this.arrowkeys) {
                    return;
                }
                this.setMinute(this.value.getMinutes() + this.minuteStep);
            };
        /**
         * @param {?=} arrowkey
         * @return {?}
         */
        TimePickerComponent.prototype.decrementMinute = /**
         * @param {?=} arrowkey
         * @return {?}
         */
            function (arrowkey) {
                if (arrowkey === void 0) {
                    arrowkey = false;
                }
                if (this.disabled || arrowkey && !this.arrowkeys) {
                    return;
                }
                this.setMinute(this.value.getMinutes() - this.minuteStep);
            };
        /**
         * @param {?=} arrowkey
         * @return {?}
         */
        TimePickerComponent.prototype.incrementSecond = /**
         * @param {?=} arrowkey
         * @return {?}
         */
            function (arrowkey) {
                if (arrowkey === void 0) {
                    arrowkey = false;
                }
                if (this.disabled || arrowkey && !this.arrowkeys) {
                    return;
                }
                this.setSeconds(this.value.getSeconds() + this.secondStep);
            };
        /**
         * @param {?=} arrowkey
         * @return {?}
         */
        TimePickerComponent.prototype.decrementSecond = /**
         * @param {?=} arrowkey
         * @return {?}
         */
            function (arrowkey) {
                if (arrowkey === void 0) {
                    arrowkey = false;
                }
                if (this.disabled || arrowkey && !this.arrowkeys) {
                    return;
                }
                this.setSeconds(this.value.getSeconds() - this.secondStep);
            };
        /**
         * @param {?} meridian
         * @return {?}
         */
        TimePickerComponent.prototype.selectMeridian = /**
         * @param {?} meridian
         * @return {?}
         */
            function (meridian) {
                this._meridian = meridian;
                // get the current time
                var /** @type {?} */ hour = this.value.getHours();
                // if we have selected AM
                if (meridian === this.meridians[0]) {
                    if (hour >= 12) {
                        this.setHour(hour - 12);
                    }
                }
                // if we have selected PM
                if (meridian === this.meridians[1]) {
                    if (hour < 12) {
                        this.setHour(hour + 12);
                    }
                }
            };
        /**
         * @param {?} date
         * @return {?}
         */
        TimePickerComponent.prototype.checkValidity = /**
         * @param {?} date
         * @return {?}
         */
            function (date) {
                var /** @type {?} */ valid = true;
                if (this.min && date.getTime() <= this.min.getTime()) {
                    valid = false;
                }
                if (this.max && date.getTime() >= this.max.getTime()) {
                    valid = false;
                }
                return valid;
            };
        /**
         * @param {?} value
         * @return {?}
         */
        TimePickerComponent.prototype.hourChange = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                // convert the string to a number
                var /** @type {?} */ hour = parseInt(value);
                var /** @type {?} */ currentHour = this.value.getHours();
                // if the value hasn't changed, do nothing
                if (hour === currentHour) {
                    return;
                }
                // ensure the hours is valid
                if (!isNaN(hour)) {
                    if (hour < 0) {
                        hour = 0;
                    }
                    if (hour > (this.showMeridian ? 12 : 23)) {
                        hour = this.showMeridian ? 12 : 23;
                    }
                }
                hour = isNaN(hour) ? currentHour : hour;
                // if the number is invalid then restore it to the previous value
                if (this._meridian === this.meridians[0]) {
                    if (hour >= 12) {
                        hour -= 12;
                    }
                }
                // if we have selected PM
                if (this._meridian === this.meridians[1]) {
                    if (hour < 12) {
                        hour += 12;
                    }
                }
                this.setHour(hour);
            };
        /**
         * @param {?} value
         * @return {?}
         */
        TimePickerComponent.prototype.minuteChange = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                // convert the string to a number
                var /** @type {?} */ minute = parseInt(value);
                var /** @type {?} */ currentMinute = this.value.getMinutes();
                // if the value hasn't changed, do nothing
                if (minute === currentMinute) {
                    return;
                }
                // ensure the hours is valid
                if (!isNaN(minute)) {
                    if (minute < 0) {
                        minute = 59;
                    }
                    if (minute > 59) {
                        minute = 0;
                    }
                }
                // if the number is invalid then restore it to the previous value
                this.setMinute(isNaN(minute) ? currentMinute : minute);
            };
        /**
         * @param {?} value
         * @return {?}
         */
        TimePickerComponent.prototype.secondChange = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                // convert the string to a number
                var /** @type {?} */ second = parseInt(value);
                var /** @type {?} */ currentSecond = this.value.getSeconds();
                // if the value hasn't changed, do nothing
                if (second === currentSecond) {
                    return;
                }
                // ensure the hours is valid
                if (!isNaN(second)) {
                    if (second < 0) {
                        second = 0;
                    }
                    if (second > 59) {
                        second = 59;
                    }
                }
                // if the number is invalid then restore it to the previous value
                this.setSeconds(isNaN(second) ? currentSecond : second);
            };
        TimePickerComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-time-picker',
                        template: "<div class=\"time-picker\" aria-label=\"Time picker\">\n\n    <div class=\"time-picker-column\" [class.has-error]=\"!(valid$ | async)\" *ngIf=\"showHours\">\n\n        <ux-spin-button\n            type=\"text\"\n            class=\"time-spinner\"\n            placeholder=\"HH\"\n            [min]=\"0\"\n            [max]=\"showMeridian ? 12 : 23\"\n            [value]=\"hour$ | async | timeFormat:!showMeridian\"\n            (valueChange)=\"hourChange($event)\"\n            [spinners]=\"showSpinners\"\n            [disabled]=\"disabled\"\n            [readOnly]=\"readOnly\"\n            inputAriaLabel=\"hour\"\n            incrementAriaLabel=\"Increment the hour\"\n            decrementAriaLabel=\"Decrement the hour\"\n            (increment)=\"incrementHour()\"\n            (decrement)=\"decrementHour()\">\n        </ux-spin-button>\n\n    </div>\n\n    <div class=\"time-picker-separator\" *ngIf=\"showMinutes\">:</div>\n\n    <div class=\"time-picker-column\" [class.has-error]=\"!(valid$ | async)\" *ngIf=\"showMinutes\">\n\n        <ux-spin-button\n            type=\"text\"\n            class=\"time-spinner\"\n            placeholder=\"MM\"\n            [min]=\"0\"\n            [max]=\"59\"\n            [value]=\"minute$ | async | timeFormat:true\"\n            (valueChange)=\"minuteChange($event)\"\n            [spinners]=\"showSpinners\"\n            [disabled]=\"disabled\"\n            [readOnly]=\"readOnly\"\n            inputAriaLabel=\"minute\"\n            incrementAriaLabel=\"Increment the minute\"\n            decrementAriaLabel=\"Decrement the minute\"\n            (increment)=\"incrementMinute()\"\n            (decrement)=\"decrementMinute()\">\n        </ux-spin-button>\n\n    </div>\n\n    <div class=\"time-picker-separator\" *ngIf=\"showSeconds\">:</div>\n\n    <div class=\"time-picker-column\" [class.has-error]=\"!(valid$ | async)\" *ngIf=\"showSeconds\">\n\n        <ux-spin-button\n            type=\"text\"\n            class=\"time-spinner\"\n            placeholder=\"SS\"\n            [min]=\"0\"\n            [max]=\"59\"\n            [value]=\"second$ | async | timeFormat:true\"\n            (valueChange)=\"secondChange($event)\"\n            [spinners]=\"showSpinners\"\n            [disabled]=\"disabled\"\n            [readOnly]=\"readOnly\"\n            inputAriaLabel=\"seconds\"\n            incrementAriaLabel=\"Increment the second\"\n            decrementAriaLabel=\"Decrement the second\"\n            (increment)=\"incrementSecond()\"\n            (decrement)=\"decrementSecond()\">\n        </ux-spin-button>\n\n    </div>\n</div>\n\n<div class=\"time-picker-meridian\" *ngIf=\"showMeridian\">\n\n    <div class=\"btn-group\" role=\"radiogroup\">\n\n        <button class=\"btn button-toggle-accent\"\n                *ngFor=\"let meridian of meridians\"\n                role=\"radio\"\n                tabindex=\"0\"\n                [disabled]=\"disabled\"\n                (click)=\"selectMeridian(meridian)\"\n                [class.active]=\"meridian === (meridian$ | async)\"\n                [attr.aria-label]=\"meridian\"\n                [attr.aria-checked]=\"meridian === (meridian$ | async)\"\n                [attr.aria-disabled]=\"disabled\">\n                {{ meridian }}\n        </button>\n\n    </div>\n</div>",
                        encapsulation: core.ViewEncapsulation.None,
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        providers: [TIME_PICKER_VALUE_ACCESSOR],
                        host: {
                            'aria-label': 'Time Picker'
                        }
                    }] }
        ];
        /** @nocollapse */
        TimePickerComponent.ctorParameters = function () { return []; };
        TimePickerComponent.propDecorators = {
            arrowkeys: [{ type: core.Input }],
            mousewheel: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            readOnly: [{ type: core.Input }],
            showMeridian: [{ type: core.Input }],
            showHours: [{ type: core.Input }],
            showMinutes: [{ type: core.Input }],
            showSeconds: [{ type: core.Input }],
            showSpinners: [{ type: core.Input }],
            hourStep: [{ type: core.Input }],
            minuteStep: [{ type: core.Input }],
            secondStep: [{ type: core.Input }],
            min: [{ type: core.Input }],
            max: [{ type: core.Input }],
            meridians: [{ type: core.Input }],
            value: [{ type: core.Input }],
            valueChange: [{ type: core.Output }],
            isValid: [{ type: core.Output }]
        };
        return TimePickerComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TimePickerModule = (function () {
        function TimePickerModule() {
        }
        TimePickerModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            SpinButtonModule
                        ],
                        exports: [TimePickerComponent],
                        declarations: [TimePickerComponent, TimeFormatPipe],
                    },] }
        ];
        return TimePickerModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Convert a single dimension array to a double dimension array
     * @template T
     * @param {?} items the single dimension array to convert
     * @param {?} columns the number of items each array should have
     * @return {?}
     */
    function gridify(items, columns) {
        // create a copy of array so not to effect the original
        items = items.slice(0);
        var /** @type {?} */ grid = [];
        while (items.length) {
            grid.push(items.splice(0, columns));
        }
        return grid;
    }
    /**
     * Create an array of numbers between two limits
     * @param {?} start the lower limit
     * @param {?} end the upper limit
     * @return {?}
     */
    function range(start, end) {
        var /** @type {?} */ list = [];
        for (var /** @type {?} */ idx = start; idx <= end; idx++) {
            list.push(idx);
        }
        return list;
    }
    /**
     * Create an array of dates between two points
     * @param {?} start the date to start the array
     * @param {?} end the date to end the array
     * @return {?}
     */
    function dateRange(start, end) {
        var /** @type {?} */ dates = [];
        // loop through all the days between the date range
        while (start <= end) {
            // add the date to the array
            dates.push(new Date(start));
            // move to the next day
            start.setDate(start.getDate() + 1);
        }
        return dates;
    }
    /**
     * Compare two dates to see if they are on the same day
     * @param {?} day1 the first date to compare
     * @param {?} day2 the second date to compare
     * @return {?}
     */
    function compareDays(day1, day2) {
        return day1.getDate() === day2.getDate() &&
            day1.getMonth() === day2.getMonth() &&
            day1.getFullYear() === day2.getFullYear();
    }
    /**
     * Date comparison for use primarily with distinctUntilChanged
     * @param {?} dateOne
     * @param {?} dateTwo
     * @return {?}
     */
    function dateComparator(dateOne, dateTwo) {
        return dateOne.getTime() === dateTwo.getTime();
    }
    /**
     * Timezone comparison for use primarily with distinctUntilChanged
     * @param {?} zoneOne
     * @param {?} zoneTwo
     * @return {?}
     */
    function timezoneComparator(zoneOne, zoneTwo) {
        return zoneOne.name === zoneTwo.name && zoneOne.offset === zoneTwo.offset;
    }
    /**
     * Export an array of all the available months
     */
    var /** @type {?} */ months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
    var /** @type {?} */ monthsShort = months.map(function (month) { return month.substring(0, 3); });
    /**
     * Export an array of all the available days of the week
     */
    var /** @type {?} */ weekdays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
    var /** @type {?} */ weekdaysShort = weekdays.map(function (weekday) { return weekday.substring(0, 3); });

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DateTimePickerConfig = (function () {
        function DateTimePickerConfig() {
            this.showDate = true;
            this.showTime = true;
            this.showTimezone = true;
            this.showSeconds = false;
            this.showMeridian = true;
            this.showSpinners = true;
            this.weekdays = weekdaysShort;
            this.nowBtnText = 'Today';
            this.timezones = [
                { name: 'GMT-11', offset: 660 },
                { name: 'GMT-10', offset: 600 },
                { name: 'GMT-9', offset: 540 },
                { name: 'GMT-8', offset: 480 },
                { name: 'GMT-7', offset: 420 },
                { name: 'GMT-6', offset: 360 },
                { name: 'GMT-5', offset: 300 },
                { name: 'GMT-4', offset: 240 },
                { name: 'GMT-3', offset: 180 },
                { name: 'GMT-2', offset: 120 },
                { name: 'GMT-1', offset: 60 },
                { name: 'GMT', offset: 0 },
                { name: 'GMT+1', offset: -60 },
                { name: 'GMT+2', offset: -120 },
                { name: 'GMT+3', offset: -180 },
                { name: 'GMT+4', offset: -240 },
                { name: 'GMT+5', offset: -300 },
                { name: 'GMT+6', offset: -360 },
                { name: 'GMT+7', offset: -420 },
                { name: 'GMT+8', offset: -480 },
                { name: 'GMT+9', offset: -540 },
                { name: 'GMT+10', offset: -600 },
                { name: 'GMT+11', offset: -660 },
                { name: 'GMT+12', offset: -720 }
            ];
        }
        DateTimePickerConfig.decorators = [
            { type: core.Injectable }
        ];
        return DateTimePickerConfig;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DateTimePickerService = (function () {
        function DateTimePickerService(_config) {
            var _this = this;
            this._config = _config;
            this.mode$ = new BehaviorSubject.BehaviorSubject(DatePickerMode.Day);
            this.date$ = new BehaviorSubject.BehaviorSubject(new Date());
            this.timezone$ = new BehaviorSubject.BehaviorSubject(this.getCurrentTimezone());
            this.selected$ = new BehaviorSubject.BehaviorSubject(new Date());
            // the month and year to display in the viewport
            this.month$ = new BehaviorSubject.BehaviorSubject(new Date().getMonth());
            this.year$ = new BehaviorSubject.BehaviorSubject(new Date().getFullYear());
            this.showDate$ = new BehaviorSubject.BehaviorSubject(this._config.showDate);
            this.showTime$ = new BehaviorSubject.BehaviorSubject(this._config.showTime);
            this.showTimezone$ = new BehaviorSubject.BehaviorSubject(this._config.showTimezone);
            this.showSeconds$ = new BehaviorSubject.BehaviorSubject(this._config.showSeconds);
            this.showMeridian$ = new BehaviorSubject.BehaviorSubject(this._config.showMeridian);
            this.showSpinners$ = new BehaviorSubject.BehaviorSubject(this._config.showSpinners);
            this.weekdays$ = new BehaviorSubject.BehaviorSubject(this._config.weekdays);
            this.nowBtnText$ = new BehaviorSubject.BehaviorSubject(this._config.nowBtnText);
            this.timezones$ = new BehaviorSubject.BehaviorSubject(this._config.timezones);
            this.header$ = new BehaviorSubject.BehaviorSubject(null);
            this.headerEvent$ = new Subject.Subject();
            this.modeDirection = ModeDirection.None;
            // when the active date changes set the currently selected date
            this._subscription = this.selected$.pipe(operators.distinctUntilChanged(dateComparator)).subscribe(function (date) {
                // the month and year displayed in the viewport should reflect the newly selected items
                // the month and year displayed in the viewport should reflect the newly selected items
                _this.setViewportMonth(date.getMonth());
                _this.setViewportYear(date.getFullYear());
                // emit the new date to the component host
                // emit the new date to the component host
                _this.date$.next(date);
            });
        }
        /**
         * @return {?}
         */
        DateTimePickerService.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @param {?} month
         * @return {?}
         */
        DateTimePickerService.prototype.setViewportMonth = /**
         * @param {?} month
         * @return {?}
         */
            function (month) {
                if (month < 0) {
                    this.month$.next(11);
                    this.year$.next(this.year$.value - 1);
                }
                else if (month > 11) {
                    this.month$.next(0);
                    this.year$.next(this.year$.value + 1);
                }
                else {
                    this.month$.next(month);
                }
            };
        /**
         * @param {?} year
         * @return {?}
         */
        DateTimePickerService.prototype.setViewportYear = /**
         * @param {?} year
         * @return {?}
         */
            function (year) {
                this.year$.next(year);
            };
        /**
         * @param {?} day
         * @param {?} month
         * @param {?} year
         * @return {?}
         */
        DateTimePickerService.prototype.setDate = /**
         * @param {?} day
         * @param {?} month
         * @param {?} year
         * @return {?}
         */
            function (day, month, year) {
                var /** @type {?} */ date = new Date(this.selected$.value);
                date.setDate(day);
                date.setMonth(month);
                date.setFullYear(year);
                this.selected$.next(date);
            };
        /**
         * @return {?}
         */
        DateTimePickerService.prototype.setDateToNow = /**
         * @return {?}
         */
            function () {
                this.selected$.next(new Date());
            };
        /**
         * @param {?} mode
         * @return {?}
         */
        DateTimePickerService.prototype.setViewportMode = /**
         * @param {?} mode
         * @return {?}
         */
            function (mode) {
                this.mode$.next(mode);
            };
        /**
         * @return {?}
         */
        DateTimePickerService.prototype.goToChildMode = /**
         * @return {?}
         */
            function () {
                this.modeDirection = ModeDirection.Descend;
                switch (this.mode$.value) {
                    case DatePickerMode.Year:
                        return this.setViewportMode(DatePickerMode.Month);
                    case DatePickerMode.Month:
                        return this.setViewportMode(DatePickerMode.Day);
                }
            };
        /**
         * @return {?}
         */
        DateTimePickerService.prototype.goToParentMode = /**
         * @return {?}
         */
            function () {
                this.modeDirection = ModeDirection.Ascend;
                switch (this.mode$.value) {
                    case DatePickerMode.Day:
                        return this.setViewportMode(DatePickerMode.Month);
                    case DatePickerMode.Month:
                        return this.setViewportMode(DatePickerMode.Year);
                }
            };
        /**
         * @return {?}
         */
        DateTimePickerService.prototype.goToNext = /**
         * @return {?}
         */
            function () {
                this.headerEvent$.next(DatePickerHeaderEvent.Next);
            };
        /**
         * @return {?}
         */
        DateTimePickerService.prototype.goToPrevious = /**
         * @return {?}
         */
            function () {
                this.headerEvent$.next(DatePickerHeaderEvent.Previous);
            };
        /**
         * @param {?} header
         * @return {?}
         */
        DateTimePickerService.prototype.setHeader = /**
         * @param {?} header
         * @return {?}
         */
            function (header) {
                this.header$.next(header);
            };
        /**
         * @return {?}
         */
        DateTimePickerService.prototype.getCurrentTimezone = /**
         * @return {?}
         */
            function () {
                var /** @type {?} */ offset = new Date().getTimezoneOffset();
                return this._config.timezones.find(function (timezone) { return timezone.offset === offset; });
            };
        /**
         * @param {?} timezone
         * @return {?}
         */
        DateTimePickerService.prototype.setTimezone = /**
         * @param {?} timezone
         * @return {?}
         */
            function (timezone) {
                this.timezone$.next(timezone);
            };
        DateTimePickerService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        DateTimePickerService.ctorParameters = function () {
            return [
                { type: DateTimePickerConfig }
            ];
        };
        return DateTimePickerService;
    }());
    /** @enum {number} */
    var DatePickerMode = {
        Day: 0,
        Month: 1,
        Year: 2,
    };
    DatePickerMode[DatePickerMode.Day] = "Day";
    DatePickerMode[DatePickerMode.Month] = "Month";
    DatePickerMode[DatePickerMode.Year] = "Year";
    /** @enum {number} */
    var ModeDirection = {
        None: 0,
        Ascend: 1,
        Descend: 2,
    };
    ModeDirection[ModeDirection.None] = "None";
    ModeDirection[ModeDirection.Ascend] = "Ascend";
    ModeDirection[ModeDirection.Descend] = "Descend";
    /** @enum {number} */
    var DatePickerHeaderEvent = {
        Previous: 0,
        Next: 1,
    };
    DatePickerHeaderEvent[DatePickerHeaderEvent.Previous] = "Previous";
    DatePickerHeaderEvent[DatePickerHeaderEvent.Next] = "Next";

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DateTimePickerComponent = (function () {
        function DateTimePickerComponent(datepicker) {
            var _this = this;
            this.datepicker = datepicker;
            this.dateChange = new core.EventEmitter();
            this.timezoneChange = new core.EventEmitter();
            // expose enum to view
            this.DatePickerMode = DatePickerMode;
            this._subscription = new Subscription.Subscription();
            var /** @type {?} */ valueChange = datepicker.selected$.pipe(operators.distinctUntilChanged(dateComparator))
                .subscribe(function (date) { return _this.dateChange.emit(date); });
            var /** @type {?} */ timezoneChange = datepicker.timezone$.pipe(operators.distinctUntilChanged(timezoneComparator))
                .subscribe(function (timezone) { return _this.timezoneChange.emit(timezone); });
        }
        Object.defineProperty(DateTimePickerComponent.prototype, "showDate", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.datepicker.showDate$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "showTime", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.datepicker.showTime$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "showTimezone", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.datepicker.showTimezone$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "showSeconds", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.datepicker.showSeconds$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "showMeridian", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.datepicker.showMeridian$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "showSpinners", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.datepicker.showSpinners$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "weekdays", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.datepicker.weekdays$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "nowBtnText", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.datepicker.nowBtnText$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "timezones", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.datepicker.timezones$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "date", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (!dateComparator(value, this.datepicker.selected$.value)) {
                    this.datepicker.selected$.next(new Date(value));
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DateTimePickerComponent.prototype, "timezone", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.datepicker.timezone$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        DateTimePickerComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * Change the date to the current date and time
         */
        /**
         * Change the date to the current date and time
         * @return {?}
         */
        DateTimePickerComponent.prototype.setToNow = /**
         * Change the date to the current date and time
         * @return {?}
         */
            function () {
                // set the date to the current moment
                this.datepicker.setDateToNow();
            };
        DateTimePickerComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-date-time-picker',
                        template: "<div class=\"calendar-container\">\n\n  <ux-date-time-picker-header></ux-date-time-picker-header>\n\n  <ng-container *ngIf=\"datepicker.showDate$ | async\" [ngSwitch]=\"datepicker.mode$ | async\">\n\n      <!-- Display days in the current month -->\n      <ux-date-time-picker-day-view *ngSwitchCase=\"DatePickerMode.Day\"></ux-date-time-picker-day-view>\n\n      <!-- Display the months in the current year -->\n      <ux-date-time-picker-month-view *ngSwitchCase=\"DatePickerMode.Month\"></ux-date-time-picker-month-view>\n\n      <!-- Display a decade -->\n      <ux-date-time-picker-year-view *ngSwitchCase=\"DatePickerMode.Year\"></ux-date-time-picker-year-view>\n\n  </ng-container>\n\n  <!-- Display a Time Picker -->\n  <ux-date-time-picker-time-view *ngIf=\"datepicker.showTime$ | async\"></ux-date-time-picker-time-view>\n\n</div>\n\n<button class=\"now-button\" aria-label=\"Set date to now\" (click)=\"setToNow()\">{{ datepicker.nowBtnText$ | async }}</button>",
                        providers: [DateTimePickerService],
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        DateTimePickerComponent.ctorParameters = function () {
            return [
                { type: DateTimePickerService }
            ];
        };
        DateTimePickerComponent.propDecorators = {
            showDate: [{ type: core.Input }],
            showTime: [{ type: core.Input }],
            showTimezone: [{ type: core.Input }],
            showSeconds: [{ type: core.Input }],
            showMeridian: [{ type: core.Input }],
            showSpinners: [{ type: core.Input }],
            weekdays: [{ type: core.Input }],
            nowBtnText: [{ type: core.Input }],
            timezones: [{ type: core.Input }],
            dateChange: [{ type: core.Output }],
            timezoneChange: [{ type: core.Output }],
            date: [{ type: core.Input }],
            timezone: [{ type: core.Input }]
        };
        return DateTimePickerComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DayViewService = (function () {
        function DayViewService(_datepicker) {
            var _this = this;
            this._datepicker = _datepicker;
            this.grid$ = new BehaviorSubject.BehaviorSubject([[]]);
            this.focused$ = new BehaviorSubject.BehaviorSubject(null);
            this._subscription = combineLatest.combineLatest(_datepicker.month$, _datepicker.year$)
                .subscribe(function (_a) {
                var _b = __read(_a, 2), month = _b[0], year = _b[1];
                return _this.createDayGrid(month, year);
            });
        }
        /**
         * @return {?}
         */
        DayViewService.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @param {?} day
         * @param {?} month
         * @param {?} year
         * @return {?}
         */
        DayViewService.prototype.setFocus = /**
         * @param {?} day
         * @param {?} month
         * @param {?} year
         * @return {?}
         */
            function (day, month, year) {
                this.focused$.next({ day: day, month: month, year: year });
                // update the date picker to show the required month and year
                this._datepicker.setViewportMonth(month);
                this._datepicker.setViewportYear(year);
            };
        /**
         * @param {?} month
         * @param {?} year
         * @return {?}
         */
        DayViewService.prototype.createDayGrid = /**
         * @param {?} month
         * @param {?} year
         * @return {?}
         */
            function (month, year) {
                var _this = this;
                // update the header
                this._datepicker.setHeader(months[month] + ' ' + year);
                // find the lower and upper boundaries
                var /** @type {?} */ start = new Date(year, month, 1);
                var /** @type {?} */ end = new Date(year, month + 1, 0);
                // we always want to show from the sunday - this may include showing some dates from the previous month
                start.setDate(start.getDate() - start.getDay());
                // we also want to make sure that the range ends on a saturday
                end.setDate(end.getDate() + (6 - end.getDay()));
                // create an array of all the days to display
                var /** @type {?} */ dates = dateRange(start, end).map(function (date) {
                    return ({
                        day: date.getDate(),
                        month: date.getMonth(),
                        year: date.getFullYear(),
                        date: date,
                        isToday: _this.isToday(date),
                        isActive: _this.isActive(date),
                        isCurrentMonth: date.getMonth() === month
                    });
                });
                // turn the dates into a grid
                var /** @type {?} */ items = gridify(dates, 7);
                this.grid$.next(items);
                // if no item has yet been focused then focus the first day of the month
                if ((this._datepicker.modeDirection === ModeDirection.None || this._datepicker.modeDirection === ModeDirection.Descend) && this.focused$.value === null) {
                    // check if the selected item is visible
                    var /** @type {?} */ selectedDay = dates.find(function (day) { return day.isCurrentMonth && day.isActive; });
                    if (selectedDay) {
                        this.setFocus(selectedDay.day, selectedDay.month, selectedDay.year);
                    }
                    else {
                        // find the first day of the month
                        var /** @type {?} */ first = dates.find(function (date) { return date.day === 1; });
                        // focus the date
                        this.setFocus(first.day, first.month, first.year);
                    }
                }
            };
        /**
         * Determine whether or not a specific date is today
         * @param {?} date The date to check
         * @return {?}
         */
        DayViewService.prototype.isToday = /**
         * Determine whether or not a specific date is today
         * @param {?} date The date to check
         * @return {?}
         */
            function (date) {
                return compareDays(new Date(), date);
            };
        /**
         * Determines whether or not a specific date is the selected one
         * @param {?} date the date to check
         * @return {?}
         */
        DayViewService.prototype.isActive = /**
         * Determines whether or not a specific date is the selected one
         * @param {?} date the date to check
         * @return {?}
         */
            function (date) {
                return compareDays(this._datepicker.selected$.value, date);
            };
        DayViewService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        DayViewService.ctorParameters = function () {
            return [
                { type: DateTimePickerService }
            ];
        };
        return DayViewService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DayViewComponent = (function () {
        function DayViewComponent(datePicker, dayService) {
            var _this = this;
            this.datePicker = datePicker;
            this.dayService = dayService;
            this._subscription = datePicker.headerEvent$
                .subscribe(function (event) { return event === DatePickerHeaderEvent.Next ? _this.next() : _this.previous(); });
        }
        /**
         * @return {?}
         */
        DayViewComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * Navigate to the previous page of dates
         */
        /**
         * Navigate to the previous page of dates
         * @return {?}
         */
        DayViewComponent.prototype.previous = /**
         * Navigate to the previous page of dates
         * @return {?}
         */
            function () {
                this.datePicker.setViewportMonth(this.datePicker.month$.value - 1);
            };
        /**
         * Navigate to the next page of dates
         */
        /**
         * Navigate to the next page of dates
         * @return {?}
         */
        DayViewComponent.prototype.next = /**
         * Navigate to the next page of dates
         * @return {?}
         */
            function () {
                this.datePicker.setViewportMonth(this.datePicker.month$.value + 1);
            };
        /**
         * Select a particular date
         * @param date the date to select
         */
        /**
         * Select a particular date
         * @param {?} date the date to select
         * @return {?}
         */
        DayViewComponent.prototype.select = /**
         * Select a particular date
         * @param {?} date the date to select
         * @return {?}
         */
            function (date) {
                // update the current date object
                this.datePicker.setDate(date.getDate(), date.getMonth(), date.getFullYear());
                // focus the newly selected date
                this.dayService.setFocus(date.getDate(), date.getMonth(), date.getFullYear());
            };
        /**
         * @param {?} index
         * @return {?}
         */
        DayViewComponent.prototype.trackWeekByFn = /**
         * @param {?} index
         * @return {?}
         */
            function (index) {
                return index;
            };
        /**
         * @param {?} index
         * @param {?} item
         * @return {?}
         */
        DayViewComponent.prototype.trackDayByFn = /**
         * @param {?} index
         * @param {?} item
         * @return {?}
         */
            function (index, item) {
                return item.day + " " + item.month + " " + item.year;
            };
        /**
         * @param {?} item
         * @param {?} dayOffset
         * @return {?}
         */
        DayViewComponent.prototype.focusDate = /**
         * @param {?} item
         * @param {?} dayOffset
         * @return {?}
         */
            function (item, dayOffset) {
                // determine the date of the day
                var /** @type {?} */ target = new Date(item.date.setDate(item.date.getDate() + dayOffset));
                // identify which date should be focused
                this.dayService.setFocus(target.getDate(), target.getMonth(), target.getFullYear());
            };
        /**
         * @param {?} item
         * @return {?}
         */
        DayViewComponent.prototype.getTabbable = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                var /** @type {?} */ focused = this.dayService.focused$.value;
                var /** @type {?} */ grid = this.dayService.grid$.value;
                // if there is a focused month check if this is it
                if (focused) {
                    // check if the focused day is visible
                    var /** @type {?} */ isFocusedDayVisible = !!grid.find(function (row) { return !!row.find(function (_item) { return _item.day === focused.day && _item.month === focused.month && _item.year === focused.year; }); });
                    if (isFocusedDayVisible) {
                        return focused.day === item.day && focused.month === item.month && focused.year === item.year;
                    }
                }
                // if there is no focusable day then check if there is a selected day
                var /** @type {?} */ isSelectedDayVisible = !!grid.find(function (row) { return !!row.find(function (day) { return day.isActive; }); });
                if (isSelectedDayVisible) {
                    return item.isActive;
                }
                // otherwise make the first day tabbable
                return item.day === 1;
            };
        DayViewComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-date-time-picker-day-view',
                        template: "<table class=\"calendar\">\n    <thead>\n        <tr>\n            <th *ngFor=\"let day of datePicker.weekdays$ | async\" class=\"weekday\" [attr.aria-label]=\"day\">{{ day }}</th>\n        </tr>\n    </thead>\n\n    <tbody role=\"grid\">\n        <tr role=\"row\" *ngFor=\"let row of dayService.grid$ | async; trackBy: trackWeekByFn\">\n\n            <td *ngFor=\"let item of row; trackBy: trackDayByFn\" class=\"date-cell\" role=\"gridcell\">\n\n                <button class=\"date-button\"\n                        [focusIf]=\"(dayService.focused$ | async)?.day === item.day && (dayService.focused$ | async)?.month === item.month && (dayService.focused$ | async)?.year === item.year\"\n                        [attr.aria-label]=\"item.date | date\"\n                        [attr.aria-selected]=\"item.isActive\"\n                        [attr.aria-hidden]=\"!item.isCurrentMonth\"\n                        [class.current]=\"item.isToday\"\n                        [class.active]=\"item.isActive\"\n                        [class.preview]=\"!item.isCurrentMonth\"\n                        [tabindex]=\"getTabbable(item) ? 0 : -1\"\n                        (click)=\"select(item.date); $event.stopPropagation()\"\n                        (keydown.ArrowLeft)=\"focusDate(item, -1); $event.preventDefault()\"\n                        (keydown.ArrowRight)=\"focusDate(item, 1); $event.preventDefault()\"\n                        (keydown.ArrowUp)=\"focusDate(item, -7); $event.preventDefault()\"\n                        (keydown.ArrowDown)=\"focusDate(item, 7); $event.preventDefault()\">\n\n                    {{ item.date.getDate() }}\n                </button>\n\n            </td>\n        </tr>\n    </tbody>\n</table>",
                        providers: [DayViewService],
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        DayViewComponent.ctorParameters = function () {
            return [
                { type: DateTimePickerService },
                { type: DayViewService }
            ];
        };
        return DayViewComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var HeaderComponent = (function () {
        function HeaderComponent(datepicker) {
            this.datepicker = datepicker;
            this.canAscend$ = this.datepicker.mode$.pipe(operators.map(function (mode) { return mode !== DatePickerMode.Year; }));
            this.mode$ = this.datepicker.mode$.pipe(operators.map(function (mode) {
                switch (mode) {
                    case DatePickerMode.Day:
                        return 'Day';
                    case DatePickerMode.Month:
                        return 'Month';
                    case DatePickerMode.Year:
                        return 'Year';
                }
            }));
            this.headerAria$ = this.datepicker.mode$.pipe(operators.map(function (mode) {
                switch (mode) {
                    case DatePickerMode.Day:
                        return 'Switch to show months in the year';
                    case DatePickerMode.Month:
                        return 'Switch to show years in the decade';
                    case DatePickerMode.Year:
                        return '';
                }
            }));
            this.previousAria$ = this.datepicker.mode$.pipe(operators.map(function (mode) {
                switch (mode) {
                    case DatePickerMode.Day:
                        return 'Previous month';
                    case DatePickerMode.Month:
                        return 'Previous year';
                    case DatePickerMode.Year:
                        return 'Previous decade';
                }
            }));
            this.nextAria$ = this.datepicker.mode$.pipe(operators.map(function (mode) {
                switch (mode) {
                    case DatePickerMode.Day:
                        return 'Next month';
                    case DatePickerMode.Month:
                        return 'Next year';
                    case DatePickerMode.Year:
                        return 'Next decade';
                }
            }));
        }
        /**
         * @return {?}
         */
        HeaderComponent.prototype.previous = /**
         * @return {?}
         */
            function () {
                this.datepicker.goToPrevious();
            };
        /**
         * @return {?}
         */
        HeaderComponent.prototype.ascend = /**
         * @return {?}
         */
            function () {
                this.datepicker.goToParentMode();
            };
        /**
         * @return {?}
         */
        HeaderComponent.prototype.next = /**
         * @return {?}
         */
            function () {
                this.datepicker.goToNext();
            };
        HeaderComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-date-time-picker-header',
                        template: "<header class=\"header\">\n\n  <button class=\"header-navigation\"\n          (click)=\"previous(); $event.stopPropagation()\"\n          [attr.aria-label]=\"previousAria$ | async\"\n          tabindex=\"0\">\n\n    <i class=\"hpe-icon hpe-previous\"></i>\n  </button>\n\n  <button class=\"header-title\"\n          [attr.aria-label]=\"headerAria$ | async\"\n          [class.active]=\"canAscend$ | async\"\n          (click)=\"ascend(); $event.stopPropagation()\"\n          [tabindex]=\"(canAscend$ | async) ? 0 : -1\">\n       {{ datepicker.header$ | async }}\n  </button>\n\n  <button class=\"header-navigation\"\n          (click)=\"next(); $event.stopPropagation()\"\n          [attr.aria-label]=\"nextAria$ | async\"\n          tabindex=\"0\">\n\n    <i class=\"hpe-icon hpe-next\"></i>\n  </button>\n</header>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        HeaderComponent.ctorParameters = function () {
            return [
                { type: DateTimePickerService }
            ];
        };
        return HeaderComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MonthViewService = (function () {
        function MonthViewService(_datepicker) {
            var _this = this;
            this._datepicker = _datepicker;
            this.grid$ = new BehaviorSubject.BehaviorSubject([[]]);
            this.focused$ = new BehaviorSubject.BehaviorSubject(null);
            this._subscription = _datepicker.year$.subscribe(function (year) { return _this.createMonthGrid(year); });
        }
        /**
         * @return {?}
         */
        MonthViewService.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @param {?} month
         * @param {?} year
         * @return {?}
         */
        MonthViewService.prototype.setFocus = /**
         * @param {?} month
         * @param {?} year
         * @return {?}
         */
            function (month, year) {
                this.focused$.next({ month: month, year: year });
                // update the viewport to ensure focused month is visible
                this._datepicker.setViewportYear(year);
            };
        /**
         * @param {?} year
         * @return {?}
         */
        MonthViewService.prototype.createMonthGrid = /**
         * @param {?} year
         * @return {?}
         */
            function (year) {
                // update the header
                this._datepicker.setHeader(year.toString());
                // get the current year and month
                var /** @type {?} */ currentMonth = new Date().getMonth();
                var /** @type {?} */ currentYear = new Date().getFullYear();
                // get the currently selected month
                var /** @type {?} */ activeMonth = this._datepicker.selected$.value.getMonth();
                var /** @type {?} */ activeYear = this._datepicker.selected$.value.getFullYear();
                // create a 4x3 grid of month numbers
                var /** @type {?} */ months$$1 = range(0, 11).map(function (month) {
                    return {
                        name: monthsShort[month],
                        month: month,
                        year: year,
                        isCurrentMonth: year === currentYear && month === currentMonth,
                        isActiveMonth: year === activeYear && month === activeMonth
                    };
                });
                // map these to the appropriate format
                var /** @type {?} */ items = gridify(months$$1, 4);
                // update the grid
                this.grid$.next(items);
                // if there is no focused month select the first one
                if (this._datepicker.modeDirection === ModeDirection.Descend && this.focused$.value === null) {
                    // check if the selected month is in view
                    var /** @type {?} */ selectedMonth = months$$1.find(function (month) { return month.isActiveMonth; });
                    this.setFocus(selectedMonth ? selectedMonth.month : 0, year);
                }
            };
        MonthViewService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        MonthViewService.ctorParameters = function () {
            return [
                { type: DateTimePickerService }
            ];
        };
        return MonthViewService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MonthViewComponent = (function () {
        function MonthViewComponent(_datePicker, monthService) {
            var _this = this;
            this._datePicker = _datePicker;
            this.monthService = monthService;
            this._subscription = _datePicker.headerEvent$
                .subscribe(function (event) { return event === DatePickerHeaderEvent.Next ? _this.next() : _this.previous(); });
        }
        /**
         * @return {?}
         */
        MonthViewComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * Go to the previous year
         */
        /**
         * Go to the previous year
         * @return {?}
         */
        MonthViewComponent.prototype.previous = /**
         * Go to the previous year
         * @return {?}
         */
            function () {
                this._datePicker.setViewportYear(this._datePicker.year$.value - 1);
            };
        /**
         * Go to the next year
         */
        /**
         * Go to the next year
         * @return {?}
         */
        MonthViewComponent.prototype.next = /**
         * Go to the next year
         * @return {?}
         */
            function () {
                this._datePicker.setViewportYear(this._datePicker.year$.value + 1);
            };
        /**
         * Select a month in the calendar
         * @param month the index of the month to select
         */
        /**
         * Select a month in the calendar
         * @param {?} month the index of the month to select
         * @return {?}
         */
        MonthViewComponent.prototype.select = /**
         * Select a month in the calendar
         * @param {?} month the index of the month to select
         * @return {?}
         */
            function (month) {
                this._datePicker.setViewportMonth(month);
                // show the day picker
                this._datePicker.goToChildMode();
            };
        /**
         * @param {?} item
         * @param {?} monthOffset
         * @return {?}
         */
        MonthViewComponent.prototype.focusMonth = /**
         * @param {?} item
         * @param {?} monthOffset
         * @return {?}
         */
            function (item, monthOffset) {
                var /** @type {?} */ targetMonth = item.month + monthOffset;
                var /** @type {?} */ targetYear = item.year;
                if (targetMonth < 0) {
                    targetMonth += 12;
                    targetYear -= 1;
                }
                if (targetMonth >= 12) {
                    targetMonth -= 12;
                    targetYear += 1;
                }
                this.monthService.setFocus(targetMonth, targetYear);
            };
        /**
         * @param {?} index
         * @return {?}
         */
        MonthViewComponent.prototype.trackRowByFn = /**
         * @param {?} index
         * @return {?}
         */
            function (index) {
                return index;
            };
        /**
         * @param {?} index
         * @param {?} item
         * @return {?}
         */
        MonthViewComponent.prototype.trackMonthByFn = /**
         * @param {?} index
         * @param {?} item
         * @return {?}
         */
            function (index, item) {
                return item.month + " " + item.year;
            };
        /**
         * @param {?} item
         * @return {?}
         */
        MonthViewComponent.prototype.getTabbable = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                var /** @type {?} */ focused = this.monthService.focused$.value;
                var /** @type {?} */ grid = this.monthService.grid$.value;
                // if there is a focused month check if this is it
                if (focused) {
                    // check if the focused month is visible
                    var /** @type {?} */ isFocusedMonthVisible = !!grid.find(function (row) { return !!row.find(function (_item) { return _item.month === focused.month && _item.year === focused.year; }); });
                    if (isFocusedMonthVisible) {
                        return focused.month === item.month && focused.year === item.year;
                    }
                }
                // if there is no focusable month then check if there is a selected month
                var /** @type {?} */ isSelectedMonthVisible = !!grid.find(function (row) { return !!row.find(function (month) { return month.isActiveMonth; }); });
                if (isSelectedMonthVisible) {
                    return item.isActiveMonth;
                }
                // otherwise make the first month tabbable
                return item.month === 0;
            };
        MonthViewComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-date-time-picker-month-view',
                        template: "<div class=\"calendar\" role=\"grid\">\n  <div class=\"calendar-row\" *ngFor=\"let row of monthService.grid$ | async; trackBy: trackRowByFn\" role=\"row\">\n\n    <button role=\"gridcell\"\n         class=\"calendar-item\"\n         *ngFor=\"let item of row; trackBy: trackMonthByFn\"\n         [focusIf]=\"(monthService.focused$ | async)?.month === item.month && (monthService.focused$ | async)?.year === item.year\"\n         [tabindex]=\"getTabbable(item) ? 0 : -1\"\n         [attr.aria-label]=\"item.name + ' ' + item.year\"\n         [attr.aria-selected]=\"item.isActiveMonth\"\n         [class.active]=\"item.isActiveMonth\"\n         [class.current]=\"item.isCurrentMonth\"\n         (click)=\"select(item.month); $event.stopPropagation()\"\n         (keydown.ArrowLeft)=\"focusMonth(item, -1); $event.preventDefault()\"\n         (keydown.ArrowRight)=\"focusMonth(item, 1); $event.preventDefault()\"\n         (keydown.ArrowUp)=\"focusMonth(item, -4); $event.preventDefault()\"\n         (keydown.ArrowDown)=\"focusMonth(item, 4); $event.preventDefault()\">\n         {{ item.name }}\n    </button>\n  </div>\n</div>\n",
                        providers: [MonthViewService],
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        MonthViewComponent.ctorParameters = function () {
            return [
                { type: DateTimePickerService },
                { type: MonthViewService }
            ];
        };
        return MonthViewComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TimeViewComponent = (function () {
        function TimeViewComponent(datepicker) {
            this.datepicker = datepicker;
        }
        /**
         * @param {?} name
         * @return {?}
         */
        TimeViewComponent.prototype.selectTimezone = /**
         * @param {?} name
         * @return {?}
         */
            function (name) {
                var /** @type {?} */ timezones = this.datepicker.timezones$.value;
                // find matching timezone
                var /** @type {?} */ timezone = timezones.find(function (_timezone) { return _timezone.name === name; });
                if (timezone) {
                    this.datepicker.setTimezone(timezone);
                }
            };
        /**
         * @return {?}
         */
        TimeViewComponent.prototype.incrementTimezone = /**
         * @return {?}
         */
            function () {
                var /** @type {?} */ timezone = this.datepicker.timezone$.value;
                var /** @type {?} */ timezones = this.datepicker.timezones$.value;
                var /** @type {?} */ currentZone = timezones.findIndex(function (zone) { return zone.name === timezone.name && zone.offset === timezone.offset; });
                // try to get the previous zone
                this.datepicker.setTimezone(timezones[currentZone + 1] ? timezones[currentZone + 1] : timezones[currentZone]);
            };
        /**
         * @return {?}
         */
        TimeViewComponent.prototype.decrementTimezone = /**
         * @return {?}
         */
            function () {
                var /** @type {?} */ timezone = this.datepicker.timezone$.value;
                var /** @type {?} */ timezones = this.datepicker.timezones$.value;
                var /** @type {?} */ currentZone = timezones.findIndex(function (zone) { return zone.name === timezone.name && zone.offset === timezone.offset; });
                // try to get the previous zone
                this.datepicker.setTimezone(timezones[currentZone - 1] ? timezones[currentZone - 1] : timezones[currentZone]);
            };
        TimeViewComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-date-time-picker-time-view',
                        template: "<ux-time-picker *ngIf=\"datepicker.showTime$ | async\"\n    [value]=\"datepicker.selected$ | async\"\n    (valueChange)=\"datepicker.selected$.next($event)\"\n    [showSeconds]=\"datepicker.showSeconds$ | async\"\n    [showMeridian]=\"datepicker.showMeridian$ | async\"\n    [showSpinners]=\"datepicker.showSpinners$ | async\">\n</ux-time-picker>\n\n<ng-container *ngIf=\"datepicker.showTimezone$ | async\">\n\n    <div class=\"time-zone-picker\" *ngIf=\"datepicker.showSpinners$ | async\">\n\n        <ux-spin-button\n            class=\"time-zone-spinner\"\n            [value]=\"(datepicker.timezone$ | async).name\"\n            [readOnly]=\"true\"\n            (increment)=\"incrementTimezone()\"\n            (decrement)=\"decrementTimezone()\"\n            inputAriaLabel=\"Time Zone\"\n            incrementAriaLabel=\"Switch to the next time zone\"\n            decrementAriaLabel=\"Switch to the previous time zone\">\n        </ux-spin-button>\n    </div>\n\n    <div class=\"time-zone-picker\" *ngIf=\"!(datepicker.showSpinners$ | async)\">\n\n        <select class=\"form-control time-zone-select\"\n                tabindex=\"0\"\n                [ngModel]=\"(datepicker.timezone$ | async).name\"\n                (ngModelChange)=\"selectTimezone($event)\"\n                aria-label=\"Timezone\"\n                [attr.aria-valuenow]=\"(datepicker.timezone$ | async).name\">\n\n            <option *ngFor=\"let zone of datepicker.timezones$ | async\"\n                    [selected]=\"zone.name === (datepicker.timezone$ | async).name\"\n                    [value]=\"zone.name\">\n                {{ zone?.name }}\n            </option>\n\n        </select>\n    </div>\n\n</ng-container>\n",
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        TimeViewComponent.ctorParameters = function () {
            return [
                { type: DateTimePickerService }
            ];
        };
        return TimeViewComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var YearViewService = (function () {
        function YearViewService(_datepicker) {
            var _this = this;
            this._datepicker = _datepicker;
            this.grid$ = new BehaviorSubject.BehaviorSubject([[]]);
            this.focused$ = new BehaviorSubject.BehaviorSubject(null);
            this._year = new Date().getFullYear();
            this._subscription = new Subscription.Subscription();
            var /** @type {?} */ year = _datepicker.year$.subscribe(function (_year) { return _this.createYearGrid(_year); });
            var /** @type {?} */ event = _datepicker.headerEvent$
                .subscribe(function (_event) { return _event === DatePickerHeaderEvent.Next ? _this.goToNextDecade() : _this.goToPreviousDecade(); });
            this._subscription.add(year);
            this._subscription.add(event);
        }
        /**
         * @return {?}
         */
        YearViewService.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @param {?} year
         * @return {?}
         */
        YearViewService.prototype.setFocus = /**
         * @param {?} year
         * @return {?}
         */
            function (year) {
                this.focused$.next(year);
                this.createYearGrid(year);
            };
        /**
         * @return {?}
         */
        YearViewService.prototype.goToPreviousDecade = /**
         * @return {?}
         */
            function () {
                this.createYearGrid(this._year - 10);
            };
        /**
         * @return {?}
         */
        YearViewService.prototype.goToNextDecade = /**
         * @return {?}
         */
            function () {
                this.createYearGrid(this._year + 10);
            };
        /**
         * @param {?=} year
         * @return {?}
         */
        YearViewService.prototype.createYearGrid = /**
         * @param {?=} year
         * @return {?}
         */
            function (year) {
                var _this = this;
                if (year === void 0) {
                    year = this._year;
                }
                this._year = year;
                // get the years to display
                var /** @type {?} */ decade = this.getDecade(year);
                var /** @type {?} */ currentYear = new Date().getFullYear();
                // produce items in the correct format
                var /** @type {?} */ items = decade.range.map(function (_year) {
                    return {
                        year: _year,
                        isCurrentYear: _year === currentYear,
                        isActiveYear: _year === _this._datepicker.year$.value
                    };
                });
                // update the header text
                this._datepicker.setHeader(decade.start + ' - ' + decade.end);
                // create the grid
                this.grid$.next(gridify(items, 4));
            };
        /**
         * Get the years in the current decade to display
         * @param {?} year
         * @return {?}
         */
        YearViewService.prototype.getDecade = /**
         * Get the years in the current decade to display
         * @param {?} year
         * @return {?}
         */
            function (year) {
                // figure the start and end points
                var /** @type {?} */ start = (year - (year % 10));
                var /** @type {?} */ end = start + 9;
                // create an array containing all the numbers between the start and end points
                return { start: start, end: end, range: range(start, end) };
            };
        YearViewService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        YearViewService.ctorParameters = function () {
            return [
                { type: DateTimePickerService }
            ];
        };
        return YearViewService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var YearViewComponent = (function () {
        function YearViewComponent(_datePicker, yearService) {
            this._datePicker = _datePicker;
            this.yearService = yearService;
        }
        /**
         * @param {?} year
         * @return {?}
         */
        YearViewComponent.prototype.select = /**
         * @param {?} year
         * @return {?}
         */
            function (year) {
                this._datePicker.setViewportYear(year);
                // show the month picker
                this._datePicker.goToChildMode();
            };
        /**
         * @param {?} item
         * @param {?} yearOffset
         * @return {?}
         */
        YearViewComponent.prototype.focusYear = /**
         * @param {?} item
         * @param {?} yearOffset
         * @return {?}
         */
            function (item, yearOffset) {
                this.yearService.setFocus(item.year + yearOffset);
            };
        /**
         * @param {?} index
         * @return {?}
         */
        YearViewComponent.prototype.trackRowByFn = /**
         * @param {?} index
         * @return {?}
         */
            function (index) {
                return index;
            };
        /**
         * @param {?} index
         * @param {?} item
         * @return {?}
         */
        YearViewComponent.prototype.trackYearByFn = /**
         * @param {?} index
         * @param {?} item
         * @return {?}
         */
            function (index, item) {
                return item.year;
            };
        /**
         * @param {?} item
         * @return {?}
         */
        YearViewComponent.prototype.getTabbable = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                var /** @type {?} */ focused = this.yearService.focused$.value;
                var /** @type {?} */ grid = this.yearService.grid$.value;
                // if there is a focused year check if this is it
                if (focused) {
                    // check if the focused year is visible
                    var /** @type {?} */ isFocusedYearVisible = !!grid.find(function (row) { return !!row.find(function (_item) { return _item.year === focused; }); });
                    if (isFocusedYearVisible) {
                        return focused === item.year;
                    }
                }
                // if there is no focusable year then check if there is a selected year
                var /** @type {?} */ isSelectedYearVisible = !!grid.find(function (row) { return !!row.find(function (year) { return year.isActiveYear; }); });
                if (isSelectedYearVisible) {
                    return item.isActiveYear;
                }
                // otherwise make the first month tabbable
                return grid[0][0].year === item.year;
            };
        YearViewComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-date-time-picker-year-view',
                        template: "<div class=\"calendar\" role=\"grid\">\n  <div class=\"calendar-row\" role=\"row\" *ngFor=\"let row of yearService.grid$ | async; trackBy: trackRowByFn\">\n\n    <button *ngFor=\"let item of row; trackBy: trackYearByFn\"\n         role=\"gridcell\"\n         class=\"calendar-item\"\n         [focusIf]=\"(yearService.focused$ | async) === item.year\"\n         [attr.aria-label]=\"item.year\"\n         [attr.aria-selected]=\"item.isActiveYear\"\n         [class.current]=\"item.isCurrentYear\"\n         [class.active]=\"item.isActiveYear\"\n         (click)=\"select(item.year); $event.stopPropagation()\"\n         (keydown.ArrowLeft)=\"focusYear(item, -1); $event.preventDefault()\"\n         (keydown.ArrowRight)=\"focusYear(item, 1); $event.preventDefault()\"\n         (keydown.ArrowUp)=\"focusYear(item, -4); $event.preventDefault()\"\n         (keydown.ArrowDown)=\"focusYear(item, 4); $event.preventDefault()\"\n         [tabindex]=\"getTabbable(item) ? 0 : -1\">\n         {{ item.year }}\n    </button>\n  </div>\n</div>\n",
                        providers: [YearViewService],
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        YearViewComponent.ctorParameters = function () {
            return [
                { type: DateTimePickerService },
                { type: YearViewService }
            ];
        };
        return YearViewComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FocusIfDirective = (function () {
        function FocusIfDirective(_elementRef) {
            this._elementRef = _elementRef;
            this.focusIfDelay = 0;
            this.focusIfScroll = true;
            this._timeout = null;
        }
        Object.defineProperty(FocusIfDirective.prototype, "focusIf", {
            set: /**
             * @param {?} focus
             * @return {?}
             */ function (focus) {
                var _this = this;
                // if a timeout is pending then cancel it
                if (!focus && this._timeout !== null) {
                    clearTimeout(this._timeout);
                    this._timeout = null;
                }
                if (focus && this._timeout === null) {
                    this._timeout = window.setTimeout(function () {
                        _this._elementRef.nativeElement.focus({ preventScroll: !_this.focusIfScroll });
                        _this._timeout = null;
                    }, this.focusIfDelay);
                }
            },
            enumerable: true,
            configurable: true
        });
        FocusIfDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[focusIf]'
                    },] }
        ];
        /** @nocollapse */
        FocusIfDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef }
            ];
        };
        FocusIfDirective.propDecorators = {
            focusIfDelay: [{ type: core.Input }],
            focusIfScroll: [{ type: core.Input }],
            focusIf: [{ type: core.Input }]
        };
        return FocusIfDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FocusIfModule = (function () {
        function FocusIfModule() {
        }
        FocusIfModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [FocusIfDirective],
                        declarations: [FocusIfDirective]
                    },] }
        ];
        return FocusIfModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DateTimePickerModule = (function () {
        function DateTimePickerModule() {
        }
        DateTimePickerModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            TimePickerModule,
                            SpinButtonModule,
                            FocusIfModule
                        ],
                        exports: [DateTimePickerComponent],
                        declarations: [DateTimePickerComponent, HeaderComponent, DayViewComponent, MonthViewComponent, YearViewComponent, TimeViewComponent],
                        providers: [
                            DateTimePickerConfig
                        ]
                    },] }
        ];
        return DateTimePickerModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var EboxComponent = (function () {
        function EboxComponent() {
        }
        EboxComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-ebox',
                        template: "<div class=\"ux-ebox-header\">\n    <ng-content select=\"ux-ebox-header\"></ng-content>\n</div>\n\n<div class=\"ux-ebox-content\">\n    <ng-content select=\"ux-ebox-content\"></ng-content>\n</div>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        return EboxComponent;
    }());
    var EboxHeaderDirective = (function () {
        function EboxHeaderDirective() {
        }
        EboxHeaderDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'ux-ebox-header'
                    },] }
        ];
        return EboxHeaderDirective;
    }());
    var EboxContentDirective = (function () {
        function EboxContentDirective() {
        }
        EboxContentDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'ux-ebox-content'
                    },] }
        ];
        return EboxContentDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var EboxModule = (function () {
        function EboxModule() {
        }
        EboxModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [EboxComponent, EboxContentDirective, EboxHeaderDirective],
                        declarations: [EboxComponent, EboxContentDirective, EboxHeaderDirective]
                    },] }
        ];
        return EboxModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TypeaheadOptionEvent = (function () {
        function TypeaheadOptionEvent(option) {
            this.option = option;
        }
        return TypeaheadOptionEvent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TypeaheadKeyService = (function () {
        function TypeaheadKeyService() {
        }
        /**
         * @param {?} event
         * @param {?} typeahead
         * @return {?}
         */
        TypeaheadKeyService.prototype.handleKey = /**
         * @param {?} event
         * @param {?} typeahead
         * @return {?}
         */
            function (event, typeahead) {
                if (typeahead) {
                    switch (event.key) {
                        case 'ArrowUp':
                        case 'Up':
                            if (!typeahead.open) {
                                typeahead.open = true;
                            }
                            else {
                                typeahead.moveHighlight(-1);
                            }
                            event.preventDefault();
                            break;
                        case 'ArrowDown':
                        case 'Down':
                            if (!typeahead.open) {
                                typeahead.open = true;
                            }
                            else {
                                typeahead.moveHighlight(1);
                            }
                            event.preventDefault();
                            break;
                        case 'Escape':
                        case 'Esc':
                            typeahead.open = false;
                            break;
                        case 'Enter':
                            if (typeahead.selectOnEnter) {
                                typeahead.selectHighlighted();
                            }
                    }
                }
            };
        TypeaheadKeyService.decorators = [
            { type: core.Injectable }
        ];
        return TypeaheadKeyService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TypeaheadService = (function () {
        function TypeaheadService() {
            this.open$ = new BehaviorSubject.BehaviorSubject(false);
            this.highlightedElement$ = new BehaviorSubject.BehaviorSubject(null);
        }
        TypeaheadService.decorators = [
            { type: core.Injectable }
        ];
        return TypeaheadService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ uniqueId$2 = 0;
    var TypeaheadComponent = (function () {
        function TypeaheadComponent(typeaheadElement, _changeDetector, _service) {
            var _this = this;
            this.typeaheadElement = typeaheadElement;
            this._changeDetector = _changeDetector;
            this._service = _service;
            this.id = "ux-typeahead-" + ++uniqueId$2;
            this.openChange = new core.EventEmitter();
            this.dropDirection = 'down';
            this.maxHeight = '250px';
            this.multiselectable = false;
            this.openOnFilterChange = true;
            this.pageSize = 20;
            this.selectFirst = true;
            this.selectOnEnter = false;
            this.loading = false;
            this.optionSelected = new core.EventEmitter();
            this.highlightedChange = new core.EventEmitter();
            this.highlightedElementChange = new core.EventEmitter();
            this.visibleOptions$ = new BehaviorSubject.BehaviorSubject([]);
            this.clicking = false;
            this.highlighted$ = new BehaviorSubject.BehaviorSubject(null);
            this.highlightedKey = null;
            this._onDestroy = new Subject.Subject();
            this.optionApi = {
                getKey: this.getKey.bind(this),
                getDisplay: this.getDisplay.bind(this),
                getDisplayHtml: this.getDisplayHtml.bind(this)
            };
            this.loadOptionsCallback = function (pageNum, pageSize, filter$$1) {
                if (typeof _this.options === 'function') {
                    // Invoke the callback which may return an array or a promise.
                    var /** @type {?} */ arrayOrPromise = _this.options(pageNum, pageSize, filter$$1);
                    // Map the results to an array of TypeaheadVisibleOption.
                    return Promise.resolve(arrayOrPromise).then(function (newOptions) {
                        if (!Array.isArray(newOptions)) {
                            return newOptions;
                        }
                        return newOptions.map(function (option) {
                            return {
                                value: option,
                                key: _this.getKey(option)
                            };
                        });
                    });
                }
                return null;
            };
            this._service.open$.pipe(operators.distinctUntilChanged(), operators.takeUntil(this._onDestroy)).subscribe(function (next) {
                _this.openChange.emit(next);
                if (next) {
                    _this.initOptions();
                }
            });
            this.highlighted$.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (next) {
                _this.highlightedKey = next ? next.key : null;
                _this.highlightedChange.emit(next ? next.value : null);
            });
            combineLatest.combineLatest(this._service.open$, this._service.highlightedElement$, this.visibleOptions$)
                .pipe(operators.takeUntil(this._onDestroy))
                .subscribe(function (_a) {
                var _b = __read(_a, 3), open = _b[0], highlightedElement = _b[1], visibleOptions = _b[2];
                _this.highlightedElementChange.emit(open && visibleOptions.length > 0 ? highlightedElement : null);
            });
        }
        Object.defineProperty(TypeaheadComponent.prototype, "open", {
            get: /**
             * @return {?}
             */ function () {
                return this._service.open$.getValue();
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._service.open$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TypeaheadComponent.prototype, "highlighted", {
            get: /**
             * @return {?}
             */ function () {
                var /** @type {?} */ value = this.highlighted$.getValue();
                return value ? value.value : null;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} changes
         * @return {?}
         */
        TypeaheadComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                // Open the dropdown if the filter value updates
                if (changes["filter"]) {
                    if (this.openOnFilterChange && changes["filter"].currentValue && changes["filter"].currentValue.length > 0) {
                        this.open = true;
                    }
                }
                // Re-filter visibleOptions
                this.updateOptions();
            };
        /**
         * @return {?}
         */
        TypeaheadComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @return {?}
         */
        TypeaheadComponent.prototype.mousedownHandler = /**
         * @return {?}
         */
            function () {
                this.clicking = true;
            };
        /**
         * @return {?}
         */
        TypeaheadComponent.prototype.mouseupHandler = /**
         * @return {?}
         */
            function () {
                this.clicking = false;
            };
        /**
         * @param {?} event
         * @return {?}
         */
        TypeaheadComponent.prototype.optionMousedownHandler = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // Workaround to prevent focus changing when an option is clicked
                event.preventDefault();
            };
        /**
         * @param {?} event
         * @param {?} option
         * @return {?}
         */
        TypeaheadComponent.prototype.optionClickHandler = /**
         * @param {?} event
         * @param {?} option
         * @return {?}
         */
            function (event, option) {
                this.select(option);
            };
        /**
         * Returns the unique key value of the given option.
         */
        /**
         * Returns the unique key value of the given option.
         * @param {?} option
         * @return {?}
         */
        TypeaheadComponent.prototype.getKey = /**
         * Returns the unique key value of the given option.
         * @param {?} option
         * @return {?}
         */
            function (option) {
                if (typeof this.key === 'function') {
                    return this.key(option);
                }
                if (typeof this.key === 'string' && option && option.hasOwnProperty(this.key)) {
                    return option[(this.key)];
                }
                return this.getDisplay(option);
            };
        /**
         * Returns the display value of the given option.
         */
        /**
         * Returns the display value of the given option.
         * @param {?} option
         * @return {?}
         */
        TypeaheadComponent.prototype.getDisplay = /**
         * Returns the display value of the given option.
         * @param {?} option
         * @return {?}
         */
            function (option) {
                if (typeof this.display === 'function') {
                    return this.display(option);
                }
                if (typeof this.display === 'string' && option && option.hasOwnProperty(this.display)) {
                    return option[(this.display)];
                }
                return option;
            };
        /**
         * Returns the display value of the given option with HTML markup added to highlight the part which matches the current filter value.
         * @param option
         */
        /**
         * Returns the display value of the given option with HTML markup added to highlight the part which matches the current filter value.
         * @param {?} option
         * @return {?}
         */
        TypeaheadComponent.prototype.getDisplayHtml = /**
         * Returns the display value of the given option with HTML markup added to highlight the part which matches the current filter value.
         * @param {?} option
         * @return {?}
         */
            function (option) {
                var /** @type {?} */ displayText = this.getDisplay(option).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                var /** @type {?} */ displayHtml = displayText;
                if (this.filter) {
                    var /** @type {?} */ length_1 = this.filter.length;
                    var /** @type {?} */ matchIndex = displayText.toLowerCase().indexOf(this.filter.toLowerCase());
                    if (matchIndex >= 0) {
                        var /** @type {?} */ highlight = "<span class=\"ux-filter-match\">" + displayText.substr(matchIndex, length_1) + "</span>";
                        displayHtml = displayText.substr(0, matchIndex) + highlight + displayText.substr(matchIndex + length_1);
                    }
                }
                return displayHtml;
            };
        /**
         * Returns true if the infinite scroll component should load
         */
        /**
         * Returns true if the infinite scroll component should load
         * @return {?}
         */
        TypeaheadComponent.prototype.isInfiniteScroll = /**
         * Returns true if the infinite scroll component should load
         * @return {?}
         */
            function () {
                return typeof this.options === 'function';
            };
        /**
         * Selects the given option, emitting the optionSelected event and closing the dropdown.
         */
        /**
         * Selects the given option, emitting the optionSelected event and closing the dropdown.
         * @param {?} option
         * @return {?}
         */
        TypeaheadComponent.prototype.select = /**
         * Selects the given option, emitting the optionSelected event and closing the dropdown.
         * @param {?} option
         * @return {?}
         */
            function (option) {
                if (!this.isDisabled(option)) {
                    this.optionSelected.emit(new TypeaheadOptionEvent(option.value));
                    this.highlighted$.next(null);
                    this.open = false;
                }
            };
        /**
         * Returns true if the given option is part of the disabledOptions array.
         */
        /**
         * Returns true if the given option is part of the disabledOptions array.
         * @param {?} option
         * @return {?}
         */
        TypeaheadComponent.prototype.isDisabled = /**
         * Returns true if the given option is part of the disabledOptions array.
         * @param {?} option
         * @return {?}
         */
            function (option) {
                var _this = this;
                if (this.disabledOptions) {
                    var /** @type {?} */ result = this.disabledOptions.find(function (selectedOption) {
                        return _this.getKey(selectedOption) === option.key;
                    });
                    return result !== undefined;
                }
                return false;
            };
        /**
         * Set the given option as the current highlighted option, available in the highlightedOption parameter.
         */
        /**
         * Set the given option as the current highlighted option, available in the highlightedOption parameter.
         * @param {?} option
         * @return {?}
         */
        TypeaheadComponent.prototype.highlight = /**
         * Set the given option as the current highlighted option, available in the highlightedOption parameter.
         * @param {?} option
         * @return {?}
         */
            function (option) {
                if (!this.isDisabled(option)) {
                    this.highlighted$.next(option);
                    this._changeDetector.detectChanges();
                }
            };
        /**
         * Increment or decrement the highlighted option in the list. Disabled options are skipped.
         * @param d Value to be added to the index of the highlighted option, i.e. -1 to move backwards, +1 to move forwards.
         */
        /**
         * Increment or decrement the highlighted option in the list. Disabled options are skipped.
         * @param {?} d Value to be added to the index of the highlighted option, i.e. -1 to move backwards, +1 to move forwards.
         * @return {?}
         */
        TypeaheadComponent.prototype.moveHighlight = /**
         * Increment or decrement the highlighted option in the list. Disabled options are skipped.
         * @param {?} d Value to be added to the index of the highlighted option, i.e. -1 to move backwards, +1 to move forwards.
         * @return {?}
         */
            function (d) {
                var /** @type {?} */ visibleOptions = this.visibleOptions$.getValue();
                var /** @type {?} */ highlightIndex = this.indexOfVisibleOption(this.highlighted);
                var /** @type {?} */ newIndex = highlightIndex;
                var /** @type {?} */ disabled = true;
                var /** @type {?} */ inBounds = true;
                do {
                    newIndex = newIndex + d;
                    inBounds = (newIndex >= 0 && newIndex < visibleOptions.length);
                    disabled = inBounds && this.isDisabled(visibleOptions[newIndex]);
                } while (inBounds && disabled);
                if (!disabled && inBounds) {
                    this.highlight(visibleOptions[newIndex]);
                }
                return this.highlighted;
            };
        /**
         * @return {?}
         */
        TypeaheadComponent.prototype.selectHighlighted = /**
         * @return {?}
         */
            function () {
                if (this.highlighted) {
                    this.select({ value: this.highlighted, key: this.getKey(this.highlighted) });
                }
            };
        /**
         * Set up the options before the dropdown is displayed.
         */
        /**
         * Set up the options before the dropdown is displayed.
         * @return {?}
         */
        TypeaheadComponent.prototype.initOptions = /**
         * Set up the options before the dropdown is displayed.
         * @return {?}
         */
            function () {
                // Clear previous highlight
                this.highlighted$.next(null);
                if (this.selectFirst) {
                    // This will highlight the first non-disabled option.
                    this.moveHighlight(1);
                }
            };
        /**
         * Update the visibleOptions array with the current filter.
         */
        /**
         * Update the visibleOptions array with the current filter.
         * @return {?}
         */
        TypeaheadComponent.prototype.updateOptions = /**
         * Update the visibleOptions array with the current filter.
         * @return {?}
         */
            function () {
                var _this = this;
                if (typeof this.options === 'object') {
                    var /** @type {?} */ normalisedInput_1 = (this.filter || '').toLowerCase();
                    var /** @type {?} */ visibleOptions = this.options
                        .filter(function (option) {
                        return _this.getDisplay(option).toLowerCase().indexOf(normalisedInput_1) >= 0;
                    })
                        .map(function (value) {
                        return {
                            value: value,
                            key: _this.getKey(value)
                        };
                    });
                    this.visibleOptions$.next(visibleOptions);
                }
                this.initOptions();
                this._changeDetector.detectChanges();
            };
        /**
         * Return the index of the given option in the visibleOptions array. Returns -1 if the option is not currently visible.
         * @param {?} option
         * @return {?}
         */
        TypeaheadComponent.prototype.indexOfVisibleOption = /**
         * Return the index of the given option in the visibleOptions array. Returns -1 if the option is not currently visible.
         * @param {?} option
         * @return {?}
         */
            function (option) {
                if (option) {
                    var /** @type {?} */ optionKey_1 = this.getKey(option);
                    return this.visibleOptions$.getValue().findIndex(function (el) {
                        return el.key === optionKey_1;
                    });
                }
                return -1;
            };
        TypeaheadComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-typeahead',
                        template: "<div class=\"ux-typeahead-options\"\n    [uxInfiniteScroll]=\"loadOptionsCallback\"\n    [collection]=\"visibleOptions$ | async\"\n    (collectionChange)=\"visibleOptions$.next($event)\"\n    [enabled]=\"isInfiniteScroll()\"\n    [filter]=\"filter\"\n    [loadOnScroll]=\"true\"\n    [pageSize]=\"pageSize\"\n    [scrollElement]=\"typeaheadElement\"\n    (loading)=\"loading = true\"\n    (loaded)=\"loading = false\">\n\n    <ol *ngIf=\"(visibleOptions$ | async).length > 0\">\n        <li *ngFor=\"let option of (visibleOptions$ | async); let i = index\"\n            [attr.id]=\"id + '-option-' + i\"\n            [class.disabled]=\"isDisabled(option)\"\n            [class.highlighted]=\"highlightedKey === option.key\"\n            [attr.aria-selected]=\"multiselectable ? isDisabled(option) : null\"\n            [uxTypeaheadHighlight]=\"highlightedKey === option.key\"\n            [uxScrollIntoViewIf]=\"highlightedKey === option.key\"\n            [scrollParent]=\"typeaheadElement.nativeElement\"\n            (mousedown)=\"optionMousedownHandler($event)\"\n            (click)=\"optionClickHandler($event, option)\"\n            (mouseover)=\"highlight(option)\">\n\n            <ng-container [ngTemplateOutlet]=\"optionTemplate || defaultOptionTemplate\"\n                [ngTemplateOutletContext]=\"{option: option.value, api: optionApi}\">\n            </ng-container>\n\n        </li>\n    </ol>\n\n    <div *uxInfiniteScrollLoading>\n        <ng-container [ngTemplateOutlet]=\"loadingTemplate || defaultLoadingTemplate\"></ng-container>\n    </div>\n\n    <div *ngIf=\"isInfiniteScroll() === false && (visibleOptions$ | async).length === 0 && loading\">\n        <ng-container [ngTemplateOutlet]=\"loadingTemplate || defaultLoadingTemplate\"></ng-container>\n    </div>\n\n</div>\n<div *ngIf=\"(visibleOptions$ | async).length === 0 && !loading\">\n    <ng-container [ngTemplateOutlet]=\"noOptionsTemplate || defaultNoOptionsTemplate\">\n    </ng-container>\n</div>\n\n<ng-template #defaultLoadingTemplate>\n    <div class=\"ux-typeahead-loading\">\n        <div class=\"spinner spinner-accent spinner-bounce-middle\"></div>\n        <div>Loading...</div>\n    </div>\n</ng-template>\n\n<ng-template #defaultOptionTemplate let-option=\"option\" let-api=\"api\">\n    <span class=\"ux-typeahead-option\" [innerHtml]=\"api.getDisplayHtml(option)\"></span>\n</ng-template>\n\n<ng-template #defaultNoOptionsTemplate>\n    <span class=\"ux-typeahead-no-options\">No results</span>\n</ng-template>",
                        providers: [TypeaheadService],
                        host: {
                            'role': 'listbox',
                            '[class.open]': 'open',
                            '[class.drop-up]': 'dropDirection === "up"',
                            '[style.maxHeight]': 'maxHeight'
                        }
                    }] }
        ];
        /** @nocollapse */
        TypeaheadComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.ChangeDetectorRef },
                { type: TypeaheadService }
            ];
        };
        TypeaheadComponent.propDecorators = {
            id: [{ type: core.Input }, { type: core.HostBinding, args: ['attr.id',] }],
            options: [{ type: core.Input }],
            filter: [{ type: core.Input }],
            open: [{ type: core.Input }],
            openChange: [{ type: core.Output }],
            display: [{ type: core.Input }],
            key: [{ type: core.Input }],
            disabledOptions: [{ type: core.Input }],
            dropDirection: [{ type: core.Input }],
            maxHeight: [{ type: core.Input }],
            multiselectable: [{ type: core.Input }, { type: core.HostBinding, args: ['attr.aria-multiselectable',] }],
            openOnFilterChange: [{ type: core.Input }],
            pageSize: [{ type: core.Input }],
            selectFirst: [{ type: core.Input }],
            selectOnEnter: [{ type: core.Input }],
            loading: [{ type: core.Input }],
            loadingTemplate: [{ type: core.Input }],
            optionTemplate: [{ type: core.Input }],
            noOptionsTemplate: [{ type: core.Input }],
            optionSelected: [{ type: core.Output }],
            highlightedChange: [{ type: core.Output }],
            highlightedElementChange: [{ type: core.Output }],
            mousedownHandler: [{ type: core.HostListener, args: ['mousedown',] }],
            mouseupHandler: [{ type: core.HostListener, args: ['mouseup',] }]
        };
        return TypeaheadComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var InfiniteScrollLoadButtonDirective = (function () {
        function InfiniteScrollLoadButtonDirective(_element, _template, _viewContainer, _renderer) {
            this._element = _element;
            this._template = _template;
            this._viewContainer = _viewContainer;
            this._renderer = _renderer;
            this._visible = false;
            this._load = new Subject.Subject();
            this.load = /** @type {?} */ (this._load.asObservable());
        }
        Object.defineProperty(InfiniteScrollLoadButtonDirective.prototype, "visible", {
            get: /**
             * @return {?}
             */ function () {
                return this._visible;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value !== this._visible) {
                    if (value) {
                        this._viewContainer.createEmbeddedView(this._template);
                        // Template content follows the elementRef, which is a comment.
                        var /** @type {?} */ clickTarget = this.getNextElementSibling(this._template.elementRef.nativeElement);
                        this._renderer.listen(clickTarget, 'click', this.onClick.bind(this));
                    }
                    else {
                        this._viewContainer.clear();
                    }
                }
                this._visible = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} event
         * @return {?}
         */
        InfiniteScrollLoadButtonDirective.prototype.onClick = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this._load.next(event);
            };
        /**
         * @param {?} element
         * @return {?}
         */
        InfiniteScrollLoadButtonDirective.prototype.getNextElementSibling = /**
         * @param {?} element
         * @return {?}
         */
            function (element) {
                var /** @type {?} */ next = element;
                while (next = next.nextSibling) {
                    if (next.nodeType === 1) {
                        return next;
                    }
                }
                return null;
            };
        InfiniteScrollLoadButtonDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxInfiniteScrollLoadButton]'
                    },] }
        ];
        /** @nocollapse */
        InfiniteScrollLoadButtonDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.TemplateRef },
                { type: core.ViewContainerRef },
                { type: core.Renderer2 }
            ];
        };
        InfiniteScrollLoadButtonDirective.propDecorators = {
            visible: [{ type: core.Input, args: ['uxInfiniteScrollLoadButton',] }],
            load: [{ type: core.Output }]
        };
        return InfiniteScrollLoadButtonDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var InfiniteScrollLoadingDirective = (function () {
        function InfiniteScrollLoadingDirective(_templateRef, _viewContainer) {
            this._templateRef = _templateRef;
            this._viewContainer = _viewContainer;
            this._visible = false;
        }
        Object.defineProperty(InfiniteScrollLoadingDirective.prototype, "visible", {
            get: /**
             * @return {?}
             */ function () {
                return this._visible;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value !== this._visible) {
                    if (value) {
                        this._viewContainer.createEmbeddedView(this._templateRef);
                    }
                    else {
                        this._viewContainer.clear();
                    }
                }
                this._visible = value;
            },
            enumerable: true,
            configurable: true
        });
        InfiniteScrollLoadingDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxInfiniteScrollLoading]'
                    },] }
        ];
        /** @nocollapse */
        InfiniteScrollLoadingDirective.ctorParameters = function () {
            return [
                { type: core.TemplateRef },
                { type: core.ViewContainerRef }
            ];
        };
        InfiniteScrollLoadingDirective.propDecorators = {
            visible: [{ type: core.Input, args: ['uxInfiniteScrollLoading',] }]
        };
        return InfiniteScrollLoadingDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var InfiniteScrollDirective = (function () {
        function InfiniteScrollDirective(_element) {
            this._element = _element;
            this._collection = [];
            this.enabled = true;
            this.loadOnInit = true;
            this.loadOnScroll = true;
            this.pageSize = 20;
            this.collectionChange = new core.EventEmitter();
            this.loadingEvent = new core.EventEmitter();
            this.loadedEvent = new core.EventEmitter();
            this.loadErrorEvent = new core.EventEmitter();
            this._nextPageNum = 0;
            this._updateRequests = new Subject.Subject();
            this._isLoading = new BehaviorSubject.BehaviorSubject(false);
            this._isExhausted = new BehaviorSubject.BehaviorSubject(false);
            this._loadButtonEnabled = new BehaviorSubject.BehaviorSubject(false);
            this._subscriptions = [];
            this._loadButtonSubscriptions = [];
            this._onDestroy = new Subject.Subject();
            this._canLoadManually = this._isLoading.pipe(operators.combineLatest(this._isExhausted, this._loadButtonEnabled, function (isLoading, isExhausted, loadButtonEnabled) {
                return !isLoading && !isExhausted && loadButtonEnabled;
            }));
        }
        Object.defineProperty(InfiniteScrollDirective.prototype, "collection", {
            get: /**
             * @return {?}
             */ function () {
                return this._collection;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.collectionChange.emit(value);
                this._collection = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InfiniteScrollDirective.prototype, "scrollElement", {
            set: /**
             * @param {?} element
             * @return {?}
             */ function (element) {
                this._scrollElement = element instanceof core.ElementRef ? element : new core.ElementRef(element);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        InfiniteScrollDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                if (!this._scrollElement) {
                    this._scrollElement = this._element;
                }
                this._loadButtonEnabled.next(!this.loadOnScroll);
            };
        /**
         * @return {?}
         */
        InfiniteScrollDirective.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // There are two kinds of update requests: check and load.
                // Check requests are throttled and will only cause an update if more data is required
                // to fill the scrolling view, and it isn't already loading some.
                // Load requests are not throttled and always request a page of data.
                this._updateRequests.pipe(operators.filter(function (request) { return request.check; }), operators.auditTime(200), operators.takeUntil(this._onDestroy)).subscribe(this.doRequest.bind(this));
                this._updateRequests.pipe(operators.filter(function (request) { return !request.check; }), operators.takeUntil(this._onDestroy)).subscribe(this.doRequest.bind(this));
                if (this.enabled) {
                    // Subscribe to scroll events and DOM changes.
                    this.attachEventHandlers();
                }
                // Connect the Load More button visible state.
                this._canLoadManually.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (canLoad) {
                    _this._loadButtonQuery.forEach(function (loadButton) {
                        loadButton.visible = canLoad;
                    });
                });
                // Connect the loading indicator visible state.
                this._isLoading.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (isLoading) {
                    _this._loadingIndicatorQuery.forEach(function (loading) {
                        loading.visible = isLoading;
                    });
                });
                // Link the Load More button click event to trigger an update.
                this.attachLoadButtonEvents();
                this._loadButtonQuery.changes.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () {
                    _this.attachLoadButtonEvents();
                });
                // Initial update.
                if (this.loadOnInit) {
                    this.loadNextPage();
                }
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        InfiniteScrollDirective.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                var /** @type {?} */ check = true;
                if (changes["enabled"] && changes["enabled"].currentValue !== changes["enabled"].previousValue) {
                    if (changes["enabled"].currentValue) {
                        this.attachEventHandlers();
                        this.reset();
                        check = false;
                    }
                    else {
                        this.detachEventHandlers();
                    }
                }
                if (this.enabled) {
                    if (changes["filter"] && changes["filter"].currentValue !== changes["filter"].previousValue) {
                        this.reset();
                        check = false;
                    }
                    if (changes["loadOnScroll"]) {
                        this._loadButtonEnabled.next(!changes["loadOnScroll"].currentValue);
                    }
                    if (changes["pageSize"] && changes["pageSize"].currentValue !== changes["pageSize"].previousValue) {
                        this.reset();
                        check = false;
                    }
                    this._updateRequests.next({
                        check: check,
                        pageNumber: this._nextPageNum,
                        pageSize: this.pageSize,
                        filter: this.filter
                    });
                }
            };
        /**
         * @return {?}
         */
        InfiniteScrollDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.detachEventHandlers();
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * Request an additional page of data.
         */
        /**
         * Request an additional page of data.
         * @return {?}
         */
        InfiniteScrollDirective.prototype.loadNextPage = /**
         * Request an additional page of data.
         * @return {?}
         */
            function () {
                if (!this.enabled) {
                    return;
                }
                this._updateRequests.next({
                    check: false,
                    pageNumber: this._nextPageNum,
                    pageSize: this.pageSize,
                    filter: this.filter
                });
            };
        /**
         * Request a check for whether an additional page of data is required. This is throttled.
         */
        /**
         * Request a check for whether an additional page of data is required. This is throttled.
         * @return {?}
         */
        InfiniteScrollDirective.prototype.check = /**
         * Request a check for whether an additional page of data is required. This is throttled.
         * @return {?}
         */
            function () {
                if (!this.enabled) {
                    return;
                }
                this._updateRequests.next({
                    check: true,
                    pageNumber: this._nextPageNum,
                    pageSize: this.pageSize,
                    filter: this.filter
                });
            };
        /**
         * Clear the collection. Future requests will load from page 0.
         */
        /**
         * Clear the collection. Future requests will load from page 0.
         * @return {?}
         */
        InfiniteScrollDirective.prototype.reset = /**
         * Clear the collection. Future requests will load from page 0.
         * @return {?}
         */
            function () {
                if (!this.enabled) {
                    return;
                }
                // Reset the page counter.
                this._nextPageNum = 0;
                this._pages = [];
                // Clear the collection (without changing the reference).
                if (this.collection) {
                    this.collection.length = 0;
                }
                // Reset the exhausted flag, allowing the Load More button to appear.
                this._isExhausted.next(false);
                // Cancel any pending requests
                if (this._subscriptions) {
                    this._subscriptions.forEach(function (request) { return request.unsubscribe(); });
                }
            };
        /**
         * Reload the data without clearing the view.
         */
        /**
         * Reload the data without clearing the view.
         * @return {?}
         */
        InfiniteScrollDirective.prototype.reload = /**
         * Reload the data without clearing the view.
         * @return {?}
         */
            function () {
                var _this = this;
                this._pages.forEach(function (page, i) { return _this.reloadPage(i); });
            };
        /**
         * Reload the data in a specific page without clearing the view.
         * @param pageNum Page number
         */
        /**
         * Reload the data in a specific page without clearing the view.
         * @param {?} pageNum Page number
         * @return {?}
         */
        InfiniteScrollDirective.prototype.reloadPage = /**
         * Reload the data in a specific page without clearing the view.
         * @param {?} pageNum Page number
         * @return {?}
         */
            function (pageNum) {
                if (!this.enabled) {
                    return;
                }
                this._updateRequests.next({
                    check: false,
                    pageNumber: pageNum,
                    pageSize: this.pageSize,
                    filter: this.filter,
                    reload: true
                });
            };
        /**
         * Attach scroll event handler and DOM observer.
         * @return {?}
         */
        InfiniteScrollDirective.prototype.attachEventHandlers = /**
         * Attach scroll event handler and DOM observer.
         * @return {?}
         */
            function () {
                // if the scrollElement is documentElement we must watch for a scroll event on the document
                var /** @type {?} */ target = this._scrollElement.nativeElement instanceof HTMLHtmlElement ? document : this._scrollElement.nativeElement;
                // Subscribe to the scroll event on the target element.
                this._scrollEventSub = fromEvent.fromEvent(target, 'scroll').subscribe(this.check.bind(this));
                // Subscribe to child DOM changes. The main effect of this is to check whether even more data is
                // required after the initial load.
                this._domObserver = new MutationObserver(this.check.bind(this));
                this._domObserver.observe(this._scrollElement.nativeElement, {
                    childList: true,
                    subtree: true
                });
            };
        /**
         * Detach scroll event handler and DOM observer.
         * @return {?}
         */
        InfiniteScrollDirective.prototype.detachEventHandlers = /**
         * Detach scroll event handler and DOM observer.
         * @return {?}
         */
            function () {
                if (this._scrollEventSub) {
                    this._scrollEventSub.unsubscribe();
                    this._scrollEventSub = null;
                }
                if (this._domObserver) {
                    this._domObserver.disconnect();
                    this._domObserver = null;
                }
            };
        /**
         * Remove any existing event subscriptions for the load button `load` event, then attach subscriptions
         * for any in the query.
         * @return {?}
         */
        InfiniteScrollDirective.prototype.attachLoadButtonEvents = /**
         * Remove any existing event subscriptions for the load button `load` event, then attach subscriptions
         * for any in the query.
         * @return {?}
         */
            function () {
                var _this = this;
                this._loadButtonSubscriptions.forEach(function (s) { return s.unsubscribe(); });
                this._loadButtonSubscriptions = this._loadButtonQuery.map(function (loadButton) { return loadButton.load.subscribe(_this.loadNextPage.bind(_this)); });
            };
        /**
         * Conditionally loads a page into the collection based on directive state and request parameters.
         * @param {?} request
         * @return {?}
         */
        InfiniteScrollDirective.prototype.doRequest = /**
         * Conditionally loads a page into the collection based on directive state and request parameters.
         * @param {?} request
         * @return {?}
         */
            function (request) {
                var _this = this;
                // Load a new page if the scroll position is beyond the threshhold and if the client code did not
                // cancel.
                if (this.needsData(request) && this.beginLoading(request)) {
                    // Invoke the callback load function, which returns a promose or plain data.
                    var /** @type {?} */ loadResult = this.load(request.pageNumber, request.pageSize, request.filter);
                    var /** @type {?} */ observable = Array.isArray(loadResult) ? of.of(loadResult) : from.from(loadResult);
                    var /** @type {?} */ subscription_1 = observable.pipe(operators.first()).subscribe(function (items) {
                        // Make sure that the parameters have not changed since the load started;
                        // otherwise discard the results.
                        if (request.filter === _this.filter && request.pageSize === _this.pageSize) {
                            if (items && items.length) {
                                _this.setPageItems(request.pageNumber, items);
                            }
                            // Emit the loaded event
                            // Emit the loaded event
                            _this.endLoading(request, items);
                        }
                    }, function (reason) {
                        // Emit the loadError event
                        // Emit the loadError event
                        _this.endLoadingWithError(request, reason);
                    }, function () {
                        // remove this request from the list
                        // remove this request from the list
                        _this._subscriptions = _this._subscriptions.filter(function (s) { return s !== subscription_1; });
                    });
                    // add the subscription to the list of requests
                    this._subscriptions.push(subscription_1);
                }
            };
        /**
         * Returns true if the request should be fulfilled.
         * @param {?} request
         * @return {?}
         */
        InfiniteScrollDirective.prototype.needsData = /**
         * Returns true if the request should be fulfilled.
         * @param {?} request
         * @return {?}
         */
            function (request) {
                if (!this.enabled) {
                    return false;
                }
                // Always load for a load request
                if (!request.check) {
                    return true;
                }
                // Ignore a check request when the end of data has been detected, or if data is currently loading.
                if (this._isExhausted.getValue() || this._isLoading.getValue()) {
                    return false;
                }
                // Load if the remaining scroll area is <= the element height.
                if (this._scrollElement && this.loadOnScroll) {
                    var /** @type {?} */ element = (this._scrollElement.nativeElement);
                    var /** @type {?} */ remainingScroll = element.scrollHeight -
                        (element.scrollTop + element.clientHeight);
                    return remainingScroll <= element.clientHeight;
                }
                return false;
            };
        /**
         * Updates state for the beginning of a load. Returns false if the `loading` event was cancelled.
         * @param {?} request
         * @return {?}
         */
        InfiniteScrollDirective.prototype.beginLoading = /**
         * Updates state for the beginning of a load. Returns false if the `loading` event was cancelled.
         * @param {?} request
         * @return {?}
         */
            function (request) {
                var /** @type {?} */ event = new InfiniteScrollLoadingEvent(request.pageNumber, request.pageSize, request.filter);
                this.loadingEvent.emit(event);
                this._isLoading.next(!event.defaultPrevented());
                return !event.defaultPrevented();
            };
        /**
         * @param {?} pageNum
         * @param {?} items
         * @return {?}
         */
        InfiniteScrollDirective.prototype.setPageItems = /**
         * @param {?} pageNum
         * @param {?} items
         * @return {?}
         */
            function (pageNum, items) {
                this._pages[pageNum] = items;
                this.collection = this._pages.reduce(function (previous, current) { return previous.concat(current); }, []);
            };
        /**
         * Updates state from a successful load. Raises the `loaded` event.
         * @param {?} request
         * @param {?=} data
         * @return {?}
         */
        InfiniteScrollDirective.prototype.endLoading = /**
         * Updates state from a successful load. Raises the `loaded` event.
         * @param {?} request
         * @param {?=} data
         * @return {?}
         */
            function (request, data) {
                this._isLoading.next(false);
                var /** @type {?} */ isExhausted = !!(data && data.length < this.pageSize);
                this._isExhausted.next(isExhausted);
                this.loadedEvent.emit(new InfiniteScrollLoadedEvent(request.pageNumber, request.pageSize, request.filter, data, isExhausted));
                if (!request.reload) {
                    this._nextPageNum += 1;
                }
            };
        /**
         * Updates state from a failed load. Raises the `loadError` event.
         * @param {?} request
         * @param {?} error
         * @return {?}
         */
        InfiniteScrollDirective.prototype.endLoadingWithError = /**
         * Updates state from a failed load. Raises the `loadError` event.
         * @param {?} request
         * @param {?} error
         * @return {?}
         */
            function (request, error) {
                this._isLoading.next(false);
                this.loadErrorEvent.emit(new InfiniteScrollLoadErrorEvent(request.pageNumber, request.pageSize, request.filter, error));
            };
        InfiniteScrollDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxInfiniteScroll]',
                        exportAs: 'uxInfiniteScroll'
                    },] }
        ];
        /** @nocollapse */
        InfiniteScrollDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef }
            ];
        };
        InfiniteScrollDirective.propDecorators = {
            load: [{ type: core.Input, args: ['uxInfiniteScroll',] }],
            _collection: [{ type: core.Input, args: ['collection',] }],
            scrollElement: [{ type: core.Input }],
            enabled: [{ type: core.Input }],
            filter: [{ type: core.Input }],
            loadOnInit: [{ type: core.Input }],
            loadOnScroll: [{ type: core.Input }],
            pageSize: [{ type: core.Input }],
            collectionChange: [{ type: core.Output }],
            loadingEvent: [{ type: core.Output, args: ['loading',] }],
            loadedEvent: [{ type: core.Output, args: ['loaded',] }],
            loadErrorEvent: [{ type: core.Output, args: ['loadError',] }],
            _loadButtonQuery: [{ type: core.ContentChildren, args: [InfiniteScrollLoadButtonDirective,] }],
            _loadingIndicatorQuery: [{ type: core.ContentChildren, args: [InfiniteScrollLoadingDirective,] }]
        };
        return InfiniteScrollDirective;
    }());
    /**
     * Event raised before the `loading` function is called.
     */
    var /**
     * Event raised before the `loading` function is called.
     */ InfiniteScrollLoadingEvent = (function () {
        function InfiniteScrollLoadingEvent(pageNumber, pageSize, filter$$1) {
            this.pageNumber = pageNumber;
            this.pageSize = pageSize;
            this.filter = filter$$1;
            this._defaultPrevented = false;
        }
        /**
         * Prevents the default behaviour of the `loading` event (loading function will not be called).
         */
        /**
         * Prevents the default behaviour of the `loading` event (loading function will not be called).
         * @return {?}
         */
        InfiniteScrollLoadingEvent.prototype.preventDefault = /**
         * Prevents the default behaviour of the `loading` event (loading function will not be called).
         * @return {?}
         */
            function () {
                this._defaultPrevented = true;
            };
        /**
         * @return {?}
         */
        InfiniteScrollLoadingEvent.prototype.defaultPrevented = /**
         * @return {?}
         */
            function () {
                return this._defaultPrevented;
            };
        return InfiniteScrollLoadingEvent;
    }());
    /**
     * Event raised when the loading function result has been resolved and added to the collection.
     */
    var /**
     * Event raised when the loading function result has been resolved and added to the collection.
     */ InfiniteScrollLoadedEvent = (function () {
        function InfiniteScrollLoadedEvent(pageNumber, pageSize, filter$$1, data, exhausted) {
            this.pageNumber = pageNumber;
            this.pageSize = pageSize;
            this.filter = filter$$1;
            this.data = data;
            this.exhausted = exhausted;
        }
        return InfiniteScrollLoadedEvent;
    }());
    /**
     * Event raised if the loading function returns a rejected promise.
     */
    var /**
     * Event raised if the loading function returns a rejected promise.
     */ InfiniteScrollLoadErrorEvent = (function () {
        function InfiniteScrollLoadErrorEvent(pageNumber, pageSize, filter$$1, error) {
            this.pageNumber = pageNumber;
            this.pageSize = pageSize;
            this.filter = filter$$1;
            this.error = error;
        }
        return InfiniteScrollLoadErrorEvent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var InfiniteScrollModule = (function () {
        function InfiniteScrollModule() {
        }
        InfiniteScrollModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [],
                        exports: [
                            InfiniteScrollDirective,
                            InfiniteScrollLoadButtonDirective,
                            InfiniteScrollLoadingDirective
                        ],
                        declarations: [
                            InfiniteScrollDirective,
                            InfiniteScrollLoadButtonDirective,
                            InfiniteScrollLoadingDirective
                        ],
                        providers: [],
                    },] }
        ];
        return InfiniteScrollModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ScrollIntoViewService = (function () {
        function ScrollIntoViewService() {
        }
        /**
         * @param {?} elem
         * @param {?} scrollParent
         * @return {?}
         */
        ScrollIntoViewService.prototype.scrollIntoView = /**
         * @param {?} elem
         * @param {?} scrollParent
         * @return {?}
         */
            function (elem, scrollParent) {
                var /** @type {?} */ offsetTop = (elem.getBoundingClientRect().top + scrollParent.scrollTop) - scrollParent.getBoundingClientRect().top;
                if (offsetTop < scrollParent.scrollTop) {
                    scrollParent.scrollTop = offsetTop;
                }
                else {
                    var /** @type {?} */ offsetBottom = offsetTop + elem.offsetHeight;
                    if (offsetBottom > (scrollParent.scrollTop + scrollParent.clientHeight)) {
                        scrollParent.scrollTop = offsetBottom - scrollParent.clientHeight;
                    }
                }
            };
        ScrollIntoViewService.decorators = [
            { type: core.Injectable }
        ];
        return ScrollIntoViewService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ScrollIntoViewIfDirective = (function () {
        function ScrollIntoViewIfDirective(_element, _scrollIntoViewService) {
            this._element = _element;
            this._scrollIntoViewService = _scrollIntoViewService;
            this.condition = false;
        }
        /**
         * @return {?}
         */
        ScrollIntoViewIfDirective.prototype.ngOnChanges = /**
         * @return {?}
         */
            function () {
                var _this = this;
                if (this.condition) {
                    setTimeout(function () { return _this._scrollIntoViewService.scrollIntoView(_this._element.nativeElement, _this.scrollParent); });
                }
            };
        ScrollIntoViewIfDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxScrollIntoViewIf]',
                        providers: [ScrollIntoViewService]
                    },] }
        ];
        /** @nocollapse */
        ScrollIntoViewIfDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: ScrollIntoViewService }
            ];
        };
        ScrollIntoViewIfDirective.propDecorators = {
            condition: [{ type: core.Input, args: ['uxScrollIntoViewIf',] }],
            scrollParent: [{ type: core.Input }]
        };
        return ScrollIntoViewIfDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ScrollIntoViewDirective = (function () {
        function ScrollIntoViewDirective(_elementRef) {
            this._elementRef = _elementRef;
            /**
             * Allow a condition around whether or not this should scroll into view
             */
            this.uxScrollIntoView = true;
            /**
             * Allow user to provide the browser supported options
             */
            this.scrollIntoViewOptions = true;
        }
        /**
         * @return {?}
         */
        ScrollIntoViewDirective.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                if (this.uxScrollIntoView) {
                    this._elementRef.nativeElement.scrollIntoView(this.scrollIntoViewOptions);
                }
            };
        ScrollIntoViewDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxScrollIntoView]'
                    },] }
        ];
        /** @nocollapse */
        ScrollIntoViewDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef }
            ];
        };
        ScrollIntoViewDirective.propDecorators = {
            uxScrollIntoView: [{ type: core.Input }],
            scrollIntoViewOptions: [{ type: core.Input }]
        };
        return ScrollIntoViewDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ScrollModule = (function () {
        function ScrollModule() {
        }
        ScrollModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [ScrollIntoViewIfDirective, ScrollIntoViewDirective],
                        declarations: [ScrollIntoViewIfDirective, ScrollIntoViewDirective]
                    },] }
        ];
        return ScrollModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TypeaheadHighlightDirective = (function () {
        function TypeaheadHighlightDirective(_service, _elementRef) {
            this._service = _service;
            this._elementRef = _elementRef;
        }
        Object.defineProperty(TypeaheadHighlightDirective.prototype, "highlight", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value) {
                    this._service.highlightedElement$.next(this._elementRef.nativeElement);
                }
            },
            enumerable: true,
            configurable: true
        });
        TypeaheadHighlightDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxTypeaheadHighlight]'
                    },] }
        ];
        /** @nocollapse */
        TypeaheadHighlightDirective.ctorParameters = function () {
            return [
                { type: TypeaheadService },
                { type: core.ElementRef }
            ];
        };
        TypeaheadHighlightDirective.propDecorators = {
            highlight: [{ type: core.Input, args: ['uxTypeaheadHighlight',] }]
        };
        return TypeaheadHighlightDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TypeaheadModule = (function () {
        function TypeaheadModule() {
        }
        TypeaheadModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            InfiniteScrollModule,
                            ScrollModule
                        ],
                        exports: [TypeaheadComponent],
                        declarations: [TypeaheadComponent, TypeaheadHighlightDirective],
                        providers: [TypeaheadKeyService],
                    },] }
        ];
        return TypeaheadModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ReorderableHandleDirective = (function () {
        function ReorderableHandleDirective() {
        }
        ReorderableHandleDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxReorderableHandle]'
                    },] }
        ];
        return ReorderableHandleDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ReorderableModelDirective = (function () {
        // this can be used to identify which instance of the directive relates to which element
        function ReorderableModelDirective(elementRef) {
            this.elementRef = elementRef;
        }
        ReorderableModelDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxReorderableModel]'
                    },] }
        ];
        /** @nocollapse */
        ReorderableModelDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef }
            ];
        };
        ReorderableModelDirective.propDecorators = {
            uxReorderableModel: [{ type: core.Input }]
        };
        return ReorderableModelDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ dragula = dragulaNamespace__default || dragulaNamespace;

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ReorderableService = (function () {
        function ReorderableService() {
            this._groups = {};
            this._uniqueGroupId = 0;
        }
        /**
         * Returns a unique string which can be used as a group name if one was not configured.
         */
        /**
         * Returns a unique string which can be used as a group name if one was not configured.
         * @return {?}
         */
        ReorderableService.prototype.getUniqueGroupName = /**
         * Returns a unique string which can be used as a group name if one was not configured.
         * @return {?}
         */
            function () {
                return '_uxReorderable_' + this._uniqueGroupId++;
            };
        /**
         * Adds the container to the named group.
         */
        /**
         * Adds the container to the named group.
         * @param {?} groupName
         * @param {?} container
         * @return {?}
         */
        ReorderableService.prototype.register = /**
         * Adds the container to the named group.
         * @param {?} groupName
         * @param {?} container
         * @return {?}
         */
            function (groupName, container) {
                if (!this._groups[groupName]) {
                    this._groups[groupName] = new ReorderableGroup();
                }
                this._groups[groupName].register(container);
                return this._groups[groupName];
            };
        /**
         * Removes the container from the named group. If it was the last container in the group, destroys the group.
         */
        /**
         * Removes the container from the named group. If it was the last container in the group, destroys the group.
         * @param {?} groupName
         * @param {?} container
         * @return {?}
         */
        ReorderableService.prototype.unregister = /**
         * Removes the container from the named group. If it was the last container in the group, destroys the group.
         * @param {?} groupName
         * @param {?} container
         * @return {?}
         */
            function (groupName, container) {
                var /** @type {?} */ group = this._groups[groupName];
                if (group) {
                    group.unregister(container);
                    if (group.isEmpty()) {
                        group.destroy();
                        delete this._groups[groupName];
                    }
                }
            };
        /**
         * Creates the dragula instance with the current config and attaches the events, if not already created.
         */
        /**
         * Creates the dragula instance with the current config and attaches the events, if not already created.
         * @param {?} groupName
         * @return {?}
         */
        ReorderableService.prototype.initialize = /**
         * Creates the dragula instance with the current config and attaches the events, if not already created.
         * @param {?} groupName
         * @return {?}
         */
            function (groupName) {
                var /** @type {?} */ group = this._groups[groupName];
                if (group) {
                    group.initialize();
                }
                return group;
            };
        /**
         * Returns the group object for the given name.
         */
        /**
         * Returns the group object for the given name.
         * @param {?} group
         * @return {?}
         */
        ReorderableService.prototype.getGroup = /**
         * Returns the group object for the given name.
         * @param {?} group
         * @return {?}
         */
            function (group) {
                return this._groups[group];
            };
        ReorderableService.decorators = [
            { type: core.Injectable }
        ];
        return ReorderableService;
    }());
    /**
     * Represents a collection of drag-and-drop containers (uxReorderable) that items can be dragged between.
     */
    var /**
     * Represents a collection of drag-and-drop containers (uxReorderable) that items can be dragged between.
     */ ReorderableGroup = (function () {
        function ReorderableGroup() {
            this.drag = new core.EventEmitter();
            this.dragEnd = new core.EventEmitter();
            this.drop = new core.EventEmitter();
            this.cancel = new core.EventEmitter();
            this.cloned = new core.EventEmitter();
            this._containers = [];
            this._config = {
                moves: this.canMove.bind(this)
            };
        }
        /**
         * Returns true if there are no containers registered with the group.
         */
        /**
         * Returns true if there are no containers registered with the group.
         * @return {?}
         */
        ReorderableGroup.prototype.isEmpty = /**
         * Returns true if there are no containers registered with the group.
         * @return {?}
         */
            function () {
                return this._containers.length === 0;
            };
        /**
         * Returns the model object (uxReorderableModel) for an elements in one of the containers in the group.
         */
        /**
         * Returns the model object (uxReorderableModel) for an elements in one of the containers in the group.
         * @param {?} element
         * @return {?}
         */
        ReorderableGroup.prototype.getModelForElement = /**
         * Returns the model object (uxReorderableModel) for an elements in one of the containers in the group.
         * @param {?} element
         * @return {?}
         */
            function (element) {
                try {
                    for (var _a = __values(this._containers), _b = _a.next(); !_b.done; _b = _a.next()) {
                        var container = _b.value;
                        var /** @type {?} */ model = container.getModelFromElement(element);
                        if (model) {
                            return model;
                        }
                    }
                }
                catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                }
                finally {
                    try {
                        if (_b && !_b.done && (_c = _a.return))
                            _c.call(_a);
                    }
                    finally {
                        if (e_1)
                            throw e_1.error;
                    }
                }
                return null;
                var e_1, _c;
            };
        /**
         * Adds the container to the group.
         */
        /**
         * Adds the container to the group.
         * @param {?} container
         * @return {?}
         */
        ReorderableGroup.prototype.register = /**
         * Adds the container to the group.
         * @param {?} container
         * @return {?}
         */
            function (container) {
                this._containers.push(container);
                if (this._instance) {
                    this._instance.containers = this._containers.map(function (c) { return c.element; });
                }
                if (!this._config.mirrorContainer) {
                    this._config.mirrorContainer = container.element;
                }
            };
        /**
         * Removes the container from the group.
         */
        /**
         * Removes the container from the group.
         * @param {?} container
         * @return {?}
         */
        ReorderableGroup.prototype.unregister = /**
         * Removes the container from the group.
         * @param {?} container
         * @return {?}
         */
            function (container) {
                var /** @type {?} */ index = this._containers.indexOf(container);
                if (index >= 0) {
                    this._containers.splice(index, 1);
                    if (this._instance) {
                        this._instance.containers = this._containers.map(function (c) { return c.element; });
                    }
                }
            };
        /**
         * Creates the dragula instance with the current config and attaches the events, if not already created.
         */
        /**
         * Creates the dragula instance with the current config and attaches the events, if not already created.
         * @return {?}
         */
        ReorderableGroup.prototype.initialize = /**
         * Creates the dragula instance with the current config and attaches the events, if not already created.
         * @return {?}
         */
            function () {
                var _this = this;
                if (this._instance) {
                    return;
                }
                this._instance = dragula(this._containers.map(function (c) { return c.element; }), this._config);
                this._instance.on('drag', function (element, source) {
                    _this.drag.emit({
                        model: _this.getModelForElement(element),
                        element: element,
                        source: source
                    });
                });
                this._instance.on('dragend', function (element) {
                    _this.dragEnd.emit({
                        model: _this.getModelForElement(element),
                        element: element
                    });
                });
                this._instance.on('drop', function (element, target, source, sibling) {
                    _this.drop.emit({
                        model: _this.getModelForElement(element),
                        element: element,
                        target: target,
                        source: source,
                        sibling: sibling
                    });
                });
                this._instance.on('cancel', function (element) {
                    _this.cancel.emit({
                        model: _this.getModelForElement(element),
                        element: element
                    });
                });
                this._instance.on('cloned', function (clone, element, type) {
                    _this.cloned.emit({
                        clone: clone,
                        element: element,
                        type: type
                    });
                });
            };
        /**
         * Destroys the dragula instance.
         */
        /**
         * Destroys the dragula instance.
         * @return {?}
         */
        ReorderableGroup.prototype.destroy = /**
         * Destroys the dragula instance.
         * @return {?}
         */
            function () {
                if (this._instance) {
                    this._instance.destroy();
                    this._instance = null;
                }
            };
        /**
         * Finds the container for the containerElement and returns the results of canMove.
         * @param {?} element
         * @param {?} containerElement
         * @param {?} handle
         * @return {?}
         */
        ReorderableGroup.prototype.canMove = /**
         * Finds the container for the containerElement and returns the results of canMove.
         * @param {?} element
         * @param {?} containerElement
         * @param {?} handle
         * @return {?}
         */
            function (element, containerElement, handle) {
                try {
                    for (var _a = __values(this._containers), _b = _a.next(); !_b.done; _b = _a.next()) {
                        var container = _b.value;
                        if (container.element.isSameNode(containerElement)) {
                            return container.canMove(element, containerElement, handle);
                        }
                    }
                }
                catch (e_2_1) {
                    e_2 = { error: e_2_1 };
                }
                finally {
                    try {
                        if (_b && !_b.done && (_c = _a.return))
                            _c.call(_a);
                    }
                    finally {
                        if (e_2)
                            throw e_2.error;
                    }
                }
                var e_2, _c;
            };
        return ReorderableGroup;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ReorderableDirective = (function () {
        function ReorderableDirective(_elementRef, _renderer, _service) {
            this._elementRef = _elementRef;
            this._renderer = _renderer;
            this._service = _service;
            this.reorderingDisabled = false;
            this.reorderableModelChange = new core.EventEmitter();
            this.reorderStart = new core.EventEmitter();
            this.reorderCancel = new core.EventEmitter();
            this.reorderEnd = new core.EventEmitter();
            this.dragging = false;
            this._subscriptions = new Subscription.Subscription();
        }
        /**
         * Initialise dragula and bind to all the required events
         */
        /**
         * Initialise dragula and bind to all the required events
         * @return {?}
         */
        ReorderableDirective.prototype.ngOnInit = /**
         * Initialise dragula and bind to all the required events
         * @return {?}
         */
            function () {
                var _this = this;
                // If no group name then generate a unique one for this instance only
                if (!this.reorderableGroup) {
                    this.reorderableGroup = this._service.getUniqueGroupName();
                }
                this._container = {
                    element: this._elementRef.nativeElement,
                    getModelFromElement: this.getModelFromElement.bind(this),
                    canMove: this.canMove.bind(this)
                };
                // Register for drag events on this element
                var /** @type {?} */ group = this._service.register(this.reorderableGroup, this._container);
                this._subscriptions.add(group.drag.subscribe(this.onDrag.bind(this)));
                this._subscriptions.add(group.dragEnd.subscribe(this.onDragEnd.bind(this)));
                this._subscriptions.add(group.drop.subscribe(this.onDrop.bind(this)));
                this._subscriptions.add(group.cancel.subscribe(function (event) { return _this.reorderCancel.emit({ element: event.element, model: event.model }); }));
                this._subscriptions.add(group.cloned.subscribe(this.onClone.bind(this)));
            };
        /**
         * @return {?}
         */
        ReorderableDirective.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                this._service.initialize(this.reorderableGroup);
            };
        /**
         * We need to destroy the dragula instance on component destroy
         */
        /**
         * We need to destroy the dragula instance on component destroy
         * @return {?}
         */
        ReorderableDirective.prototype.ngOnDestroy = /**
         * We need to destroy the dragula instance on component destroy
         * @return {?}
         */
            function () {
                this._service.unregister(this.reorderableGroup, this._container);
                this._subscriptions.unsubscribe();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        ReorderableDirective.prototype.onDrag = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.dragging = true;
                this.reorderStart.emit({ element: event.element, model: event.model });
            };
        /**
         * This is fired when items get reordered - we need to emit the new order of the models
         */
        /**
         * This is fired when items get reordered - we need to emit the new order of the models
         * @param {?} event
         * @return {?}
         */
        ReorderableDirective.prototype.onDrop = /**
         * This is fired when items get reordered - we need to emit the new order of the models
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // if there is no provided module we can skip this
                if (!this.reorderableModel) {
                    return;
                }
                var /** @type {?} */ changed = false;
                if (event.source.isSameNode(this._elementRef.nativeElement)) {
                    // remove this model from the list of models
                    var /** @type {?} */ index = this.reorderableModel.indexOf(event.model);
                    if (index >= 0) {
                        this.reorderableModel.splice(index, 1);
                        changed = true;
                    }
                }
                if (event.target.isSameNode(this._elementRef.nativeElement)) {
                    // get the position of sibling element
                    var /** @type {?} */ index = event.sibling && !event.sibling.classList.contains('gu-mirror') ?
                        this.reorderableModel.indexOf(this.getModelFromElement(event.sibling)) :
                        this.reorderableModel.length;
                    // insert the model at its new location
                    this.reorderableModel.splice(index, 0, event.model);
                    changed = true;
                }
                // Emit event if any changes were made
                if (changed) {
                    this.reorderableModelChange.emit(this.reorderableModel);
                }
            };
        /**
         * Return the model assciated with a particular element in the list.
         * This should ensure that the items have the draggable model directive applied
         */
        /**
         * Return the model assciated with a particular element in the list.
         * This should ensure that the items have the draggable model directive applied
         * @param {?} element
         * @return {?}
         */
        ReorderableDirective.prototype.getModelFromElement = /**
         * Return the model assciated with a particular element in the list.
         * This should ensure that the items have the draggable model directive applied
         * @param {?} element
         * @return {?}
         */
            function (element) {
                var /** @type {?} */ model = this.models.find(function (_model) { return _model.elementRef.nativeElement === element; });
                if (!model) {
                    return null;
                }
                return model.uxReorderableModel;
            };
        /**
         * When we finish dragging remove the utillity class from the element being moved
         */
        /**
         * When we finish dragging remove the utillity class from the element being moved
         * @param {?} event
         * @return {?}
         */
        ReorderableDirective.prototype.onDragEnd = /**
         * When we finish dragging remove the utillity class from the element being moved
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.dragging = false;
                if (this._elementRef.nativeElement.contains(event.element)) {
                    this._renderer.removeClass(event.element, 'ux-reorderable-moving');
                    this.reorderEnd.emit({
                        element: event.element,
                        model: event.model
                    });
                }
            };
        /**
         * We want to ensure that the cloned element is identical
         * to the original, regardless of it's location in the DOM tree
         */
        /**
         * We want to ensure that the cloned element is identical
         * to the original, regardless of it's location in the DOM tree
         * @param {?} event
         * @return {?}
         */
        ReorderableDirective.prototype.onClone = /**
         * We want to ensure that the cloned element is identical
         * to the original, regardless of it's location in the DOM tree
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this._elementRef.nativeElement.contains(event.element)) {
                    this.setTableCellWidths(event.element, event.clone);
                    this.captureCanvases(event.element, event.clone);
                    this._renderer.addClass(event.element, 'ux-reorderable-moving');
                }
            };
        /**
         * If elements contain handles then only drag when the handle is dragged
         * otherwise drag whenever an immediate child is specified
         */
        /**
         * If elements contain handles then only drag when the handle is dragged
         * otherwise drag whenever an immediate child is specified
         * @param {?} element
         * @param {?} container
         * @param {?} handle
         * @return {?}
         */
        ReorderableDirective.prototype.canMove = /**
         * If elements contain handles then only drag when the handle is dragged
         * otherwise drag whenever an immediate child is specified
         * @param {?} element
         * @param {?} container
         * @param {?} handle
         * @return {?}
         */
            function (element, container, handle) {
                if (this.reorderingDisabled) {
                    return false;
                }
                return this.handles.length === 0 ? true : !!this.handles.find(function (_handle) { return _handle.nativeElement === handle; });
            };
        /**
         * @param {?} source
         * @param {?} target
         * @return {?}
         */
        ReorderableDirective.prototype.setTableCellWidths = /**
         * @param {?} source
         * @param {?} target
         * @return {?}
         */
            function (source, target) {
                // if it is not a table row then skip this
                if (source.tagName !== 'TR') {
                    return;
                }
                // find any immediate td children and fix their width
                var /** @type {?} */ sourceCells = (Array.from(source.children));
                var /** @type {?} */ targetCells = (Array.from(target.children));
                // fix the width of these cells
                sourceCells.forEach(function (cell, idx) { return targetCells[idx].style.minWidth = getComputedStyle(cell).getPropertyValue('width'); });
            };
        /**
         * @param {?} source
         * @param {?} target
         * @return {?}
         */
        ReorderableDirective.prototype.captureCanvases = /**
         * @param {?} source
         * @param {?} target
         * @return {?}
         */
            function (source, target) {
                // find all child canvas elements
                var /** @type {?} */ sourceCanvases = Array.from(source.querySelectorAll('canvas'));
                var /** @type {?} */ targetCanvases = Array.from(target.querySelectorAll('canvas'));
                // replicate the canvas content
                targetCanvases.map(function (canvas) { return canvas.getContext('2d'); })
                    .forEach(function (context, idx) { return context.drawImage(sourceCanvases[idx], 0, 0); });
            };
        ReorderableDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxReorderable]'
                    },] }
        ];
        /** @nocollapse */
        ReorderableDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Renderer2 },
                { type: ReorderableService }
            ];
        };
        ReorderableDirective.propDecorators = {
            reorderableModel: [{ type: core.Input }],
            reorderableGroup: [{ type: core.Input }],
            reorderingDisabled: [{ type: core.Input }],
            reorderableModelChange: [{ type: core.Output }],
            reorderStart: [{ type: core.Output }],
            reorderCancel: [{ type: core.Output }],
            reorderEnd: [{ type: core.Output }],
            handles: [{ type: core.ContentChildren, args: [ReorderableHandleDirective, { read: core.ElementRef, descendants: true },] }],
            models: [{ type: core.ContentChildren, args: [ReorderableModelDirective,] }],
            dragging: [{ type: core.HostBinding, args: ['class.ux-reorderable-container-moving',] }]
        };
        return ReorderableDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ReorderableModule = (function () {
        function ReorderableModule() {
        }
        ReorderableModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule
                        ],
                        declarations: [
                            ReorderableDirective,
                            ReorderableHandleDirective,
                            ReorderableModelDirective
                        ],
                        exports: [
                            ReorderableDirective,
                            ReorderableHandleDirective,
                            ReorderableModelDirective
                        ],
                        providers: [
                            ReorderableService
                        ]
                    },] }
        ];
        return ReorderableModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FacetSelect = (function () {
        function FacetSelect(facet) {
            this.facet = facet;
        }
        return FacetSelect;
    }());
    var FacetDeselect = (function () {
        function FacetDeselect(facet) {
            this.facet = facet;
        }
        return FacetDeselect;
    }());
    var FacetDeselectAll = (function () {
        function FacetDeselectAll() {
        }
        return FacetDeselectAll;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FacetContainerComponent = (function () {
        function FacetContainerComponent(_announcer) {
            this._announcer = _announcer;
            this.header = 'Selected:';
            this.clearTooltip = 'Clear All';
            this.emptyText = 'No Items';
            this.facets = [];
            this.facetsReorderable = false;
            this.facetsChange = new core.EventEmitter();
            this.events = new core.EventEmitter();
        }
        /**
         * @return {?}
         */
        FacetContainerComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.events.complete();
            };
        /**
         * @param {?} facet
         * @return {?}
         */
        FacetContainerComponent.prototype.selectFacet = /**
         * @param {?} facet
         * @return {?}
         */
            function (facet) {
                // push the facet on to the list
                this.facets.push(facet);
                // update the two way binding
                this.facetsChange.emit(this.facets);
                // trigger event
                this.triggerEvent(new FacetSelect(facet));
            };
        /**
         * @param {?} facet
         * @param {?=} tag
         * @return {?}
         */
        FacetContainerComponent.prototype.deselectFacet = /**
         * @param {?} facet
         * @param {?=} tag
         * @return {?}
         */
            function (facet, tag) {
                // find the index of the item in the selected array
                var /** @type {?} */ idx = this.facets.findIndex(function (selectedFacet) { return facet === selectedFacet; });
                // if match there was no match then finish
                if (idx === -1) {
                    return;
                }
                // remove the last item
                this.facets.splice(idx, 1);
                // update the two way binding
                this.facetsChange.emit(this.facets);
                // trigger event
                this.triggerEvent(new FacetDeselect(facet));
                // announce the facet removal
                this._announcer.announce("Option " + facet.title + " deselected.", 'assertive');
                // focus another tag if there is one
                if (tag) {
                    var /** @type {?} */ sibling = tag.previousElementSibling || tag.nextElementSibling;
                    // if there is a sibling then focus it
                    if (sibling) {
                        ((sibling)).focus();
                    }
                }
            };
        /**
         * @return {?}
         */
        FacetContainerComponent.prototype.deselectAllFacets = /**
         * @return {?}
         */
            function () {
                // empty the selected array
                this.facets = [];
                // update the two way binding
                this.facetsChange.emit(this.facets);
                // trigger event
                this.triggerEvent(new FacetDeselectAll());
                // announce the facet removal
                this._announcer.announce("All options deselected.", 'assertive');
            };
        /**
         * @param {?} _index
         * @param {?} facet
         * @return {?}
         */
        FacetContainerComponent.prototype.trackBy = /**
         * @param {?} _index
         * @param {?} facet
         * @return {?}
         */
            function (_index, facet) {
                return facet.id || facet.title;
            };
        /**
         * @param {?} facet
         * @param {?} element
         * @return {?}
         */
        FacetContainerComponent.prototype.shiftRight = /**
         * @param {?} facet
         * @param {?} element
         * @return {?}
         */
            function (facet, element) {
                // only move the item if reordering is allowed
                if (this.facetsReorderable === false) {
                    return;
                }
                // perform the movement
                this.shiftFacet(facet, 1);
                // the item may become unfocused during the reorder so we should refocus it
                requestAnimationFrame(function () { return element.focus(); });
                // announce the move
                this._announcer.announce("Option " + facet.title + " moved down.");
            };
        /**
         * @param {?} facet
         * @param {?} element
         * @return {?}
         */
        FacetContainerComponent.prototype.shiftLeft = /**
         * @param {?} facet
         * @param {?} element
         * @return {?}
         */
            function (facet, element) {
                // only move the item if reordering is allowed
                if (this.facetsReorderable === false) {
                    return;
                }
                // perform the movement
                this.shiftFacet(facet, -1);
                // the item may become unfocused during the reorder so we should refocus it
                requestAnimationFrame(function () { return element.focus(); });
                // announce the move
                this._announcer.announce("Option " + facet.title + " moved up.");
            };
        /**
         * @param {?} facet
         * @param {?} distance
         * @return {?}
         */
        FacetContainerComponent.prototype.shiftFacet = /**
         * @param {?} facet
         * @param {?} distance
         * @return {?}
         */
            function (facet, distance) {
                var /** @type {?} */ index = this.facets.indexOf(facet);
                var /** @type {?} */ target = index + distance;
                // Ensure the move is valid
                if (target < 0 || target === this.facets.length) {
                    return;
                }
                // Perform the move
                this.facets.splice(index, 1);
                this.facets.splice(target, 0, facet);
            };
        /**
         * @param {?} event
         * @return {?}
         */
        FacetContainerComponent.prototype.triggerEvent = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.events.next(event);
            };
        FacetContainerComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-facet-container',
                        template: "<!-- Display Any Selected Facets -->\n<div class=\"facets-selected-container\">\n\n    <!-- Display Title an Clear Button -->\n    <div class=\"facets-selected-header-container\">\n\n        <!-- Show The Selected Text -->\n        <span class=\"facets-selected-header-label\">{{ header }}</span>\n\n        <!-- Add a Clear Button -->\n        <button class=\"btn btn-link btn-icon button-secondary\"\n            tabindex=\"0\"\n            [attr.aria-label]=\"clearTooltip\"\n            [uxTooltip]=\"clearTooltip\"\n            placement=\"left\"\n            (click)=\"deselectAllFacets()\"\n            *ngIf=\"facets.length > 0\">\n\n            <svg class=\"facets-selected-clear-graphic\" focusable=\"false\" viewBox=\"0 0 19 12\" shape-rendering=\"geometricPrecision\">\n                <rect class=\"light-grey\" x=\"0\" y=\"2\" width=\"7\" height=\"2\"></rect>\n                <rect class=\"dark-grey\" x=\"0\" y=\"5\" width=\"9\" height=\"2\"></rect>\n                <rect class=\"light-grey\" x=\"0\" y=\"8\" width=\"7\" height=\"2\"></rect>\n                <path class=\"dark-grey\" d=\"M9,1 h1 l9,9 v1 h-1 l-9,-9 v-1 Z\"></path>\n                <path class=\"dark-grey\" d=\"M9,11 v-1 l9,-9 h1 v1 l-9,9 h-1 Z\"></path>\n            </svg>\n        </button>\n\n    </div>\n\n    <!-- Display Tags For Selected Items -->\n    <div class=\"facets-selected-list\"\n        uxReorderable\n        role=\"list\"\n        [reorderingDisabled]=\"!facetsReorderable\"\n        [(reorderableModel)]=\"facets\"\n        (reorderableModelChange)=\"facetsChange.emit(facets)\">\n\n        <!-- Show Selected Tags -->\n        <div #tag\n            class=\"facet-selected-tag\"\n            role=\"listitem\"\n            tabindex=\"0\"\n            uxReorderableHandle\n            *ngFor=\"let facet of facets; trackBy: trackBy\"\n            [attr.aria-label]=\"facet.title\"\n            [uxReorderableModel]=\"facet\"\n            (mousedown)=\"tag.focus()\"\n            (keydown.ArrowRight)=\"shiftRight(facet, tag)\"\n            (keydown.ArrowLeft)=\"shiftLeft(facet, tag)\">\n\n            <!-- Display Label -->\n            <span class=\"facet-selected-tag-label\">{{ facet.title }}</span>\n\n            <!-- Display Remove Icon -->\n            <button class=\"facet-selected-remove-btn\"\n                i18n-aria-label\n                aria-label=\"Deselect Facet\"\n                (click)=\"deselectFacet(facet, tag)\">\n\n                <i class=\"hpe-icon hpe-close\"></i>\n            </button>\n        </div>\n\n    </div>\n\n    <!-- Show Message Here if No Facets Selected -->\n    <p class=\"facets-selected-none-label\" *ngIf=\"emptyText && facets.length === 0\">{{ emptyText }}</p>\n\n</div>\n\n<!-- Any Facet Elements Should be Added Here By User -->\n<div class=\"facets-region\">\n    <ng-content></ng-content>\n</div>"
                    }] }
        ];
        /** @nocollapse */
        FacetContainerComponent.ctorParameters = function () {
            return [
                { type: a11y.LiveAnnouncer }
            ];
        };
        FacetContainerComponent.propDecorators = {
            header: [{ type: core.Input }],
            clearTooltip: [{ type: core.Input }],
            emptyText: [{ type: core.Input }],
            facets: [{ type: core.Input }],
            facetsReorderable: [{ type: core.Input }],
            facetsChange: [{ type: core.Output }],
            events: [{ type: core.Output }]
        };
        return FacetContainerComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FacetBaseComponent = (function () {
        function FacetBaseComponent(facetContainer, _elementRef) {
            var _this = this;
            this.facetContainer = facetContainer;
            this._elementRef = _elementRef;
            this.selected = [];
            this.selectedChange = new core.EventEmitter();
            this.events = new Subject.Subject();
            this._onDestroy = new Subject.Subject();
            if (facetContainer) {
                // subscribe to any deselect events from the facet container
                facetContainer.events.pipe(operators.filter(function (event) { return event instanceof FacetDeselect; }), operators.filter(function (event) { return !!_this.selected.find(function (facet) { return facet === event.facet; }); }), operators.takeUntil(this._onDestroy)).subscribe(function (event) { return _this.deselectFacet(event.facet); });
                // subscribe to any deselect all events from facet container
                facetContainer.events.pipe(operators.filter(function (event) { return event instanceof FacetDeselectAll; }), operators.takeUntil(this._onDestroy)).subscribe(function (_) { return _this.deselectAll(); });
            }
        }
        /**
         * @return {?}
         */
        FacetBaseComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // check if there should be any facets initially selected
                if (this.facetContainer) {
                    this.selected.forEach(function (facet) { return _this.facetContainer.selectFacet(facet); });
                }
            };
        /**
         * @return {?}
         */
        FacetBaseComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @param {?} facet
         * @return {?}
         */
        FacetBaseComponent.prototype.selectFacet = /**
         * @param {?} facet
         * @return {?}
         */
            function (facet) {
                // if the facet is disabled it should not be selected
                if (facet.disabled) {
                    return;
                }
                // add the facet to the list of selected facets
                this.selected.push(facet);
                // send the new value to the event emitter
                this.selectedChange.emit(this.selected);
                // fire the event to the observable
                this.triggerEvent(new FacetSelect(facet));
                // tell the facet container about the selected facet
                if (this.facetContainer) {
                    this.facetContainer.selectFacet(facet);
                }
            };
        /**
         * @param {?} facet
         * @return {?}
         */
        FacetBaseComponent.prototype.deselectFacet = /**
         * @param {?} facet
         * @return {?}
         */
            function (facet) {
                // find facet to remove
                var /** @type {?} */ index = this.selected.findIndex(function (selectedFacet) { return selectedFacet === facet; });
                // only continue if facet is found
                if (index !== -1) {
                    // remove the facet from the selected list
                    this.selected.splice(index, 1);
                    // emit the changes to selected event emitter
                    this.selectedChange.emit(this.selected);
                    // fire the event to the observable
                    this.triggerEvent(new FacetDeselect(facet));
                    // deselect the facet in the facet container
                    if (this.facetContainer) {
                        this.facetContainer.deselectFacet(facet);
                    }
                }
            };
        /**
         * @return {?}
         */
        FacetBaseComponent.prototype.deselectAll = /**
         * @return {?}
         */
            function () {
                // remove all selected facets
                this.selected = [];
                // fire the event to the observable
                this.triggerEvent(new FacetDeselectAll());
                // emit the changes to the selected event emitter
                this.selectedChange.emit(this.selected);
            };
        /**
         * @param {?} facet
         * @return {?}
         */
        FacetBaseComponent.prototype.toggleFacetSelection = /**
         * @param {?} facet
         * @return {?}
         */
            function (facet) {
                // if the facet is selected then deselect - otherwise select it
                if (this.isFacetSelected(facet)) {
                    this.deselectFacet(facet);
                }
                else {
                    this.selectFacet(facet);
                }
            };
        /**
         * @param {?} facet
         * @return {?}
         */
        FacetBaseComponent.prototype.isFacetSelected = /**
         * @param {?} facet
         * @return {?}
         */
            function (facet) {
                // determine if a facet is currently selected
                return !!this.selected.find(function (selectedFacet) { return selectedFacet === facet; });
            };
        /**
         * @param {?} event
         * @return {?}
         */
        FacetBaseComponent.prototype.triggerEvent = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.events.next(event);
            };
        FacetBaseComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-facet-base',
                        template: ''
                    }] }
        ];
        /** @nocollapse */
        FacetBaseComponent.ctorParameters = function () {
            return [
                { type: FacetContainerComponent, decorators: [{ type: core.Host }] },
                { type: core.ElementRef }
            ];
        };
        FacetBaseComponent.propDecorators = {
            selected: [{ type: core.Input }],
            selectedChange: [{ type: core.Output }],
            events: [{ type: core.Output }]
        };
        return FacetBaseComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FacetHeaderComponent = (function () {
        function FacetHeaderComponent() {
            this.canExpand = true;
            this.expanded = true;
            this.expandedChange = new core.EventEmitter();
        }
        /**
         * @return {?}
         */
        FacetHeaderComponent.prototype.toggleExpand = /**
         * @return {?}
         */
            function () {
                // if not expandable then do nothing
                if (this.canExpand) {
                    this.expanded = !this.expanded;
                    this.expandedChange.emit(this.expanded);
                }
            };
        FacetHeaderComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-facet-header',
                        template: "<span class=\"facet-header-title\">{{ header }}</span>\n<span class=\"hpe-icon\" [class.hpe-down]=\"expanded\" [class.hpe-previous]=\"!expanded\" *ngIf=\"canExpand\"></span>",
                        host: {
                            'role': 'button',
                            'tabindex': '0',
                            '(click)': 'toggleExpand()',
                            '(keyup.enter)': 'toggleExpand()',
                            '[attr.aria-expanded]': 'expanded',
                            '[attr.aria-label]': 'header + \' Facet: Activate to \' + (expanded ? \'collapse\' : \'expand\')'
                        }
                    }] }
        ];
        FacetHeaderComponent.propDecorators = {
            header: [{ type: core.Input }],
            canExpand: [{ type: core.Input }],
            expanded: [{ type: core.Input }],
            expandedChange: [{ type: core.Output }]
        };
        return FacetHeaderComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FacetCheckListItemComponent = (function () {
        function FacetCheckListItemComponent() {
            this.facet = null;
            this.selected = false;
            this.tabbable = false;
            this.selectedChange = new core.EventEmitter();
            this.itemFocus = new core.EventEmitter();
            this.itemBlur = new core.EventEmitter();
        }
        Object.defineProperty(FacetCheckListItemComponent.prototype, "disabled", {
            get: /**
             * @return {?}
             */ function () {
                return this.facet && this.facet.disabled;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        FacetCheckListItemComponent.prototype.getLabel = /**
         * @return {?}
         */
            function () {
                return this.facet ? this.facet.title : '';
            };
        /**
         * @return {?}
         */
        FacetCheckListItemComponent.prototype.focus = /**
         * @return {?}
         */
            function () {
                this.option.nativeElement.focus();
            };
        FacetCheckListItemComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-facet-check-list-item',
                        template: "<div #option\n    class=\"facet-check-list-item\"\n    [class.facet-active]=\"selected\"\n    [attr.aria-checked]=\"selected\"\n    role=\"option\"\n    [tabindex]=\"tabbable ? 0 : -1\"\n    (focus)=\"itemFocus.emit()\"\n    (blur)=\"itemBlur.emit()\"\n    (click)=\"selectedChange.emit(facet)\"\n    (keydown.enter)=\"selectedChange.emit(facet)\"\n    (keydown.space)=\"selectedChange.emit(facet); $event.preventDefault()\"\n    (keydown.spacebar)=\"selectedChange.emit(facet); $event.preventDefault()\"\n    [class.disabled]=\"facet?.disabled\">\n\n    <!-- Show check icon to indicate the state -->\n    <span class=\"facet-check-list-item-check\" aria-hidden=\"true\">\n        <span class=\"hpe-icon hpe-active\"></span>\n    </span>\n\n    <!-- Display the title -->\n    <span class=\"facet-check-list-item-title\">\n        {{ facet?.title }}\n    </span>\n\n    <!-- Display the count if specified -->\n    <span class=\"facet-check-list-item-count\"\n        *ngIf=\"facet?.count !== undefined\"\n        attr.aria-label=\"{{ facet?.count }}\"\n        i18n-aria-label>\n        ({{ facet?.count }})\n    </span>\n</div>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        FacetCheckListItemComponent.propDecorators = {
            facet: [{ type: core.Input }],
            selected: [{ type: core.Input }],
            tabbable: [{ type: core.Input }],
            selectedChange: [{ type: core.Output }],
            itemFocus: [{ type: core.Output }],
            itemBlur: [{ type: core.Output }],
            option: [{ type: core.ViewChild, args: ['option',] }]
        };
        return FacetCheckListItemComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FacetCheckListComponent = (function (_super) {
        __extends(FacetCheckListComponent, _super);
        function FacetCheckListComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.facets = [];
            _this.scrollbar = true;
            _this.expanded = true;
            _this.isFocused = false;
            _this.activeIndex = 0;
            return _this;
        }
        /**
         * @return {?}
         */
        FacetCheckListComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this._focusKeyManager = new a11y.FocusKeyManager(this.options)
                    .withVerticalOrientation();
                this._focusKeyManager.change.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (index) { return _this.activeIndex = index; });
            };
        /**
         * @param {?} index
         * @return {?}
         */
        FacetCheckListComponent.prototype.onFocus = /**
         * @param {?} index
         * @return {?}
         */
            function (index) {
                if (this._focusKeyManager.activeItemIndex === -1) {
                    this._focusKeyManager.setActiveItem(index);
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        FacetCheckListComponent.prototype.onKeydown = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this._focusKeyManager.onKeydown(event);
            };
        /**
         * @param {?} index
         * @param {?} facet
         * @return {?}
         */
        FacetCheckListComponent.prototype.toggleFacet = /**
         * @param {?} index
         * @param {?} facet
         * @return {?}
         */
            function (index, facet) {
                this.toggleFacetSelection(facet);
                this._focusKeyManager.setActiveItem(index);
            };
        FacetCheckListComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-facet-check-list',
                        template: "<ux-facet-header [header]=\"header\" [(expanded)]=\"expanded\"></ux-facet-header>\n\n<!-- Create a container which will show when section is expanded -->\n<div class=\"facet-check-list-container\"\n    tabindex=\"-1\"\n    role=\"listbox\"\n    [class.facet-check-list-scrollbar]=\"scrollbar\"\n    [class.facet-check-list-scrollbar-focused]=\"isFocused\"\n    *ngIf=\"expanded\">\n\n    <!-- Iterate through each possible facet -->\n    <ux-facet-check-list-item *ngFor=\"let facet of facets; let index = index\"\n        [facet]=\"facet\"\n        [tabbable]=\"activeIndex === index\"\n        [selected]=\"isFacetSelected(facet)\"\n        (selectedChange)=\"toggleFacet(index, facet)\"\n        (keydown)=\"onKeydown($event)\"\n        (itemFocus)=\"isFocused = true; onFocus(index)\"\n        (itemBlur)=\"isFocused = false\">\n    </ux-facet-check-list-item>\n\n</div>"
                    }] }
        ];
        FacetCheckListComponent.propDecorators = {
            facets: [{ type: core.Input }],
            header: [{ type: core.Input }],
            scrollbar: [{ type: core.Input }],
            expanded: [{ type: core.Input }],
            options: [{ type: core.ViewChildren, args: [FacetCheckListItemComponent,] }]
        };
        return FacetCheckListComponent;
    }(FacetBaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FacetTypeaheadListItemComponent = (function () {
        function FacetTypeaheadListItemComponent() {
            this.selected = false;
            this.simplified = false;
            this.tabbable = false;
            this.itemFocus = new core.EventEmitter();
            this.selectedChange = new core.EventEmitter();
        }
        Object.defineProperty(FacetTypeaheadListItemComponent.prototype, "disabled", {
            get: /**
             * @return {?}
             */ function () {
                return this.facet && this.facet.disabled;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        FacetTypeaheadListItemComponent.prototype.getLabel = /**
         * @return {?}
         */
            function () {
                return this.facet ? this.facet.title : null;
            };
        /**
         * @return {?}
         */
        FacetTypeaheadListItemComponent.prototype.focus = /**
         * @return {?}
         */
            function () {
                this.option.nativeElement.focus();
            };
        FacetTypeaheadListItemComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-facet-typeahead-list-item',
                        template: "<div #option\n    role=\"option\"\n    class=\"facet-typeahead-list-selected-option\"\n    [attr.aria-checked]=\"selected\"\n    [tabindex]=\"tabbable ? 0 : -1\"\n    (focus)=\"itemFocus.emit()\"\n    (click)=\"selectedChange.emit(facet)\"\n    (keydown.enter)=\"selectedChange.emit(facet)\"\n    (keydown.space)=\"selectedChange.emit(facet); $event.preventDefault()\"\n    (keydown.spacebar)=\"selectedChange.emit(facet); $event.preventDefault()\">\n\n    <ux-checkbox [clickable]=\"false\" [value]=\"selected\" [simplified]=\"simplified\" [tabindex]=\"-1\" [disabled]=\"disabled\">\n        <span class=\"facet-typeahead-list-selected-option-title\">{{ facet?.title }}</span>\n        <span class=\"facet-typeahead-list-selected-option-count\">({{ facet?.count }})</span>\n    </ux-checkbox>\n\n</div>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        FacetTypeaheadListItemComponent.propDecorators = {
            facet: [{ type: core.Input }],
            selected: [{ type: core.Input }],
            simplified: [{ type: core.Input }],
            tabbable: [{ type: core.Input }],
            itemFocus: [{ type: core.Output }],
            selectedChange: [{ type: core.Output }],
            option: [{ type: core.ViewChild, args: ['option',] }]
        };
        return FacetTypeaheadListItemComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ uniqueId$3 = 1;
    var FacetTypeaheadListComponent = (function (_super) {
        __extends(FacetTypeaheadListComponent, _super);
        function FacetTypeaheadListComponent(typeaheadKeyService, facetContainer, elementRef, _announcer) {
            var _this = _super.call(this, facetContainer, elementRef) || this;
            _this.typeaheadKeyService = typeaheadKeyService;
            _this._announcer = _announcer;
            _this.expanded = true;
            _this.suggestions = [];
            _this.simplified = true;
            _this.query$ = new BehaviorSubject.BehaviorSubject('');
            _this.loading = false;
            _this.activeIndex = 0;
            _this.typeaheadId = "ux-facet-typeahead-" + uniqueId$3++;
            _this.typeaheadOpen = false;
            _this.typeaheadOptions = [];
            _this._config = { placeholder: '', maxResults: 50, minCharacters: 1 };
            return _this;
        }
        Object.defineProperty(FacetTypeaheadListComponent.prototype, "typeaheadConfig", {
            get: /**
             * @return {?}
             */ function () {
                return this._config;
            },
            set: /**
             * @param {?} config
             * @return {?}
             */ function (config) {
                this._config = __assign({ placeholder: '', maxResults: 50, minCharacters: 1 }, config);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        FacetTypeaheadListComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // set up search query subscription
                this.query$.pipe(operators.takeUntil(this._onDestroy), operators.tap(function () {
                    _this.loading = true;
                    _this.typeaheadOptions = [];
                }), operators.mergeMap(function () {
                    return _this.getFacetObservable().pipe(operators.map(function (facets) {
                        return facets.filter(function (facet) { return !facet.disabled && !_this.selected.find(function (selectedFacet) { return selectedFacet === facet; }); })
                            .slice(0, _this._config.maxResults);
                    }));
                })).subscribe(function (facets) {
                    _this.loading = false;
                    _this.typeaheadOptions = facets;
                });
                this._focusKeyManager = new a11y.FocusKeyManager(this.options).withVerticalOrientation();
                this._focusKeyManager.change.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (index) { return _this.activeIndex = index; });
            };
        /**
         * @param {?} event
         * @return {?}
         */
        FacetTypeaheadListComponent.prototype.onKeydown = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this._focusKeyManager.onKeydown(event);
            };
        /**
         * @param {?} index
         * @return {?}
         */
        FacetTypeaheadListComponent.prototype.onFocus = /**
         * @param {?} index
         * @return {?}
         */
            function (index) {
                if (this._focusKeyManager.activeItemIndex === -1) {
                    this._focusKeyManager.setActiveItem(index);
                }
            };
        /**
         * @param {?} index
         * @param {?} facet
         * @return {?}
         */
        FacetTypeaheadListComponent.prototype.toggleFacet = /**
         * @param {?} index
         * @param {?} facet
         * @return {?}
         */
            function (index, facet) {
                this.toggleFacetSelection(facet);
                this._focusKeyManager.setActiveItem(index);
            };
        /** Only show typeahead if we have enough characters */
        /**
         * Only show typeahead if we have enough characters
         * @param {?=} query
         * @return {?}
         */
        FacetTypeaheadListComponent.prototype.updateTypeahead = /**
         * Only show typeahead if we have enough characters
         * @param {?=} query
         * @return {?}
         */
            function (query) {
                if (query === void 0) {
                    query = '';
                }
                this.typeaheadOpen = query.length >= this._config.minCharacters;
            };
        /**
         * @return {?}
         */
        FacetTypeaheadListComponent.prototype.getFacetObservable = /**
         * @return {?}
         */
            function () {
                return this.facets instanceof Observable.Observable ? this.facets : of.of(this.facets);
            };
        /**
         * @param {?} event
         * @return {?}
         */
        FacetTypeaheadListComponent.prototype.select = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // check to make sure that the item is not currently selected
                if (this.selected.find(function (facet) { return facet === event.option; })) {
                    return;
                }
                // select the facet
                this.selectFacet(event.option);
                // clear the typeahead
                this.query$.next('');
                // announce the selected facet
                this._announcer.announce((((event.option))).title + " selected.");
            };
        FacetTypeaheadListComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-facet-typeahead-list',
                        template: "<ux-facet-header [header]=\"header\" [(expanded)]=\"expanded\"></ux-facet-header>\n\n<div class=\"facet-typeahead-list-container\" role=\"listbox\" *ngIf=\"expanded\">\n\n    <div class=\"facet-typeahead-list-selected-container\" tabindex=\"-1\" *ngIf=\"suggestions?.length > 0\">\n\n        <ux-facet-typeahead-list-item\n            *ngFor=\"let facet of suggestions; let index = index\"\n            [facet]=\"facet\"\n            [tabbable]=\"activeIndex === index\"\n            [selected]=\"isFacetSelected(facet)\"\n            (selectedChange)=\"toggleFacet(index, facet)\"\n            (keydown)=\"onKeydown($event)\"\n            (itemFocus)=\"onFocus(index)\">\n        </ux-facet-typeahead-list-item>\n\n    </div>\n\n    <div class=\"facet-typeahead-list-control\">\n\n        <!-- Create Typeahead Control -->\n        <input type=\"text\"\n            class=\"form-control\"\n            [placeholder]=\"typeaheadConfig?.placeholder\"\n            [attr.aria-activedescendant]=\"highlightedElement?.id\"\n            aria-autocomplete=\"list\"\n            aria-multiline=\"false\"\n            [attr.aria-controls]=\"typeaheadId\"\n            [ngModel]=\"query$ | async\"\n            (ngModelChange)=\"query$.next($event); updateTypeahead($event)\"\n            (keydown)=\"typeaheadKeyService.handleKey($event, typeahead)\"\n            (blur)=\"typeaheadOpen = false\">\n\n        <ux-typeahead #typeahead\n            [id]=\"typeaheadId\"\n            [(open)]=\"typeaheadOpen\"\n            [loading]=\"loading\"\n            display=\"title\"\n            [options]=\"typeaheadOptions\"\n            [optionTemplate]=\"facetOptionTemplate\"\n            [selectOnEnter]=\"true\"\n            (optionSelected)=\"select($event)\"\n            (highlightedElementChange)=\"highlightedElement = $event\">\n        </ux-typeahead>\n\n    </div>\n\n</div>\n\n<ng-template #facetOptionTemplate let-option=\"option\" let-api=\"api\">\n    <p class=\"facet-typeahead-list-option\" [attr.aria-label]=\"option.title\">\n        <span [innerHTML]=\"option.title | facetTypeaheadHighlight: (query$ | async)\"></span>\n        <span class=\"facet-typeahead-list-option-count\"\n            *ngIf=\"option.count\">\n            ({{ option.count }})\n        </span>\n    </p>\n</ng-template>"
                    }] }
        ];
        /** @nocollapse */
        FacetTypeaheadListComponent.ctorParameters = function () {
            return [
                { type: TypeaheadKeyService },
                { type: FacetContainerComponent },
                { type: core.ElementRef },
                { type: a11y.LiveAnnouncer }
            ];
        };
        FacetTypeaheadListComponent.propDecorators = {
            facets: [{ type: core.Input }],
            header: [{ type: core.Input }],
            expanded: [{ type: core.Input }],
            suggestions: [{ type: core.Input }],
            simplified: [{ type: core.Input }],
            typeaheadConfig: [{ type: core.Input }],
            options: [{ type: core.ViewChildren, args: [FacetTypeaheadListItemComponent,] }]
        };
        return FacetTypeaheadListComponent;
    }(FacetBaseComponent));
    var FacetTypeaheadHighlight = (function () {
        function FacetTypeaheadHighlight() {
        }
        /**
         * @param {?} value
         * @param {?} searchQuery
         * @return {?}
         */
        FacetTypeaheadHighlight.prototype.transform = /**
         * @param {?} value
         * @param {?} searchQuery
         * @return {?}
         */
            function (value, searchQuery) {
                var /** @type {?} */ regex = new RegExp(searchQuery, 'i');
                return value.replace(regex, "<b class=\"facet-typeahead-highlighted\">" + value.match(regex) + "</b>");
            };
        FacetTypeaheadHighlight.decorators = [
            { type: core.Pipe, args: [{
                        name: 'facetTypeaheadHighlight'
                    },] }
        ];
        return FacetTypeaheadHighlight;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ DECLARATIONS$1 = [
        FacetContainerComponent,
        FacetHeaderComponent,
        FacetBaseComponent,
        FacetCheckListComponent,
        FacetCheckListItemComponent,
        FacetTypeaheadListComponent,
        FacetTypeaheadListItemComponent,
        FacetTypeaheadHighlight
    ];
    var FacetsModule = (function () {
        function FacetsModule() {
        }
        FacetsModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            a11y.A11yModule,
                            common.CommonModule,
                            forms.FormsModule,
                            CheckboxModule,
                            TooltipModule,
                            ReorderableModule,
                            TypeaheadModule
                        ],
                        exports: DECLARATIONS$1,
                        declarations: DECLARATIONS$1
                    },] }
        ];
        return FacetsModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var Facet = (function () {
        function Facet(title, data, count, disabled, id) {
            if (data === void 0) {
                data = {};
            }
            if (disabled === void 0) {
                disabled = false;
            }
            this.title = title;
            this.data = data;
            this.count = count;
            this.disabled = disabled;
            this.id = id;
        }
        return Facet;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MenuNavigationService = (function () {
        function MenuNavigationService() {
            this.active$ = new BehaviorSubject.BehaviorSubject(null);
        }
        MenuNavigationService.decorators = [
            { type: core.Injectable }
        ];
        return MenuNavigationService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MenuNavigationItemDirective = (function () {
        function MenuNavigationItemDirective(service, _elementRef) {
            var _this = this;
            this._elementRef = _elementRef;
            this.activated = new core.EventEmitter();
            this._subscription = service.active$.subscribe(function (next) {
                if (next === _this) {
                    _this.setActive();
                }
            });
        }
        /**
         * @return {?}
         */
        MenuNavigationItemDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @return {?}
         */
        MenuNavigationItemDirective.prototype.setActive = /**
         * @return {?}
         */
            function () {
                this._elementRef.nativeElement.focus();
                this.activated.emit();
            };
        MenuNavigationItemDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxMenuNavigationItem]'
                    },] }
        ];
        /** @nocollapse */
        MenuNavigationItemDirective.ctorParameters = function () {
            return [
                { type: MenuNavigationService },
                { type: core.ElementRef }
            ];
        };
        MenuNavigationItemDirective.propDecorators = {
            activated: [{ type: core.Output }]
        };
        return MenuNavigationItemDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MenuNavigationDirective = (function () {
        function MenuNavigationDirective(_service, _elementRef, document) {
            this._service = _service;
            this._elementRef = _elementRef;
            this.toggleButtonPosition = 'top';
            this.navigatedOut = new core.EventEmitter();
            this._subscription = new Subscription.Subscription();
            this._document = document;
        }
        Object.defineProperty(MenuNavigationDirective.prototype, "activeIndex", {
            get: /**
             * @return {?}
             */ function () {
                return this._itemsOrdered.indexOf(this._service.active$.value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MenuNavigationDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                if (this.toggleButton) {
                    this._subscription.add(this.toggleButton.keyEnter.subscribe(this.focusFirst.bind(this)));
                }
            };
        /**
         * @return {?}
         */
        MenuNavigationDirective.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this._subscription.add(this.items.changes.subscribe(function () {
                    _this._itemsOrdered = _this.items.toArray();
                }));
                this._itemsOrdered = this.items.toArray();
            };
        /**
         * @return {?}
         */
        MenuNavigationDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @return {?}
         */
        MenuNavigationDirective.prototype.focusFirst = /**
         * @return {?}
         */
            function () {
                this.moveFirst();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        MenuNavigationDirective.prototype.keydownHandler = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // Only handle events when focus in within the list of menu items
                if (!this._elementRef.nativeElement.contains(this._document.activeElement)) {
                    return;
                }
                var /** @type {?} */ handled = false;
                switch (event.key) {
                    case 'ArrowUp':
                    case 'Up':
                        this.movePrevious(event);
                        handled = true;
                        break;
                    case 'ArrowDown':
                    case 'Down':
                        this.moveNext(event);
                        handled = true;
                        break;
                    case 'ArrowLeft':
                    case 'Left':
                        if (this.toggleButtonPosition === 'left') {
                            this.moveToToggleButton(event);
                            handled = true;
                        }
                        break;
                    case 'ArrowRight':
                    case 'Right':
                        if (this.toggleButtonPosition === 'right') {
                            this.moveToToggleButton(event);
                            handled = true;
                        }
                        break;
                    case 'Home':
                        this.moveFirst();
                        handled = true;
                        break;
                    case 'End':
                        this.moveLast();
                        handled = true;
                        break;
                    case 'Escape':
                        this.navigatedOut.emit(event);
                        handled = true;
                        break;
                }
                if (handled) {
                    event.preventDefault();
                    event.stopPropagation();
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        MenuNavigationDirective.prototype.moveNext = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // Do nothing if there's no active menu item registered
                if (this.activeIndex < 0) {
                    return;
                }
                var /** @type {?} */ nextIndex = this.activeIndex + 1;
                if (nextIndex < this._itemsOrdered.length) {
                    // Activate the next menu item
                    // (uxMenuNavigationItem subscribes to this and applies focus if it matches)
                    this._service.active$.next(this._itemsOrdered[nextIndex]);
                }
                else {
                    // Check if focus went out of bounds in the direction of the origin toggle button
                    if (this.toggleButtonPosition === 'bottom') {
                        this.moveToToggleButton(event);
                    }
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        MenuNavigationDirective.prototype.movePrevious = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // Do nothing if there's no active menu item registered
                if (this.activeIndex < 0) {
                    return;
                }
                var /** @type {?} */ nextIndex = this.activeIndex - 1;
                if (nextIndex >= 0) {
                    // Activate the previous menu item
                    // (uxMenuNavigationItem subscribes to this and applies focus if it matches)
                    this._service.active$.next(this._itemsOrdered[nextIndex]);
                }
                else {
                    // Check if focus went out of bounds in the direction of the origin toggle button
                    if (this.toggleButtonPosition === 'top') {
                        this.moveToToggleButton(event);
                    }
                }
            };
        /**
         * @return {?}
         */
        MenuNavigationDirective.prototype.moveFirst = /**
         * @return {?}
         */
            function () {
                if (this._itemsOrdered.length > 0) {
                    this._service.active$.next(this._itemsOrdered[0]);
                }
            };
        /**
         * @return {?}
         */
        MenuNavigationDirective.prototype.moveLast = /**
         * @return {?}
         */
            function () {
                if (this._itemsOrdered.length > 0) {
                    this._service.active$.next(this._itemsOrdered[this._itemsOrdered.length - 1]);
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        MenuNavigationDirective.prototype.moveToToggleButton = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this.toggleButton) {
                    this.toggleButton.focus();
                    this.toggleButton.menuOpen = false;
                }
                this.navigatedOut.emit(event);
            };
        MenuNavigationDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxMenuNavigation]',
                        exportAs: 'uxMenuNavigation',
                        providers: [MenuNavigationService]
                    },] }
        ];
        /** @nocollapse */
        MenuNavigationDirective.ctorParameters = function () {
            return [
                { type: MenuNavigationService },
                { type: core.ElementRef },
                { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] }
            ];
        };
        MenuNavigationDirective.propDecorators = {
            toggleButton: [{ type: core.Input }],
            toggleButtonPosition: [{ type: core.Input }],
            navigatedOut: [{ type: core.Output }],
            items: [{ type: core.ContentChildren, args: [MenuNavigationItemDirective, { descendants: true },] }],
            keydownHandler: [{ type: core.HostListener, args: ['document:keydown', ['$event'],] }]
        };
        return MenuNavigationDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MenuNavigationToggleDirective = (function () {
        function MenuNavigationToggleDirective(_elementRef) {
            this._elementRef = _elementRef;
            this.menuPosition = 'bottom';
            this.menuOpenChange = new core.EventEmitter();
            this.keyEnter = new core.EventEmitter();
        }
        Object.defineProperty(MenuNavigationToggleDirective.prototype, "menuOpen", {
            get: /**
             * @return {?}
             */ function () {
                return this._menuOpen;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._menuOpen = value;
                this.menuOpenChange.emit(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MenuNavigationToggleDirective.prototype.focus = /**
         * @return {?}
         */
            function () {
                this._elementRef.nativeElement.focus();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        MenuNavigationToggleDirective.prototype.keydownHandler = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                var _this = this;
                if (this.isKeyMatch(event.key)) {
                    // Open the menu
                    this.menuOpen = true;
                    // Allow the menu to init, then send the event to give it focus
                    setTimeout(function () {
                        _this.keyEnter.emit();
                    });
                    event.preventDefault();
                    event.stopPropagation();
                }
            };
        /**
         * @param {?} key
         * @return {?}
         */
        MenuNavigationToggleDirective.prototype.isKeyMatch = /**
         * @param {?} key
         * @return {?}
         */
            function (key) {
                switch (key) {
                    case 'Enter':
                    case ' ':
                        return true;
                    case 'ArrowUp':
                    case 'Up':
                        return this.menuPosition === 'top';
                    case 'ArrowDown':
                    case 'Down':
                        return this.menuPosition === 'bottom';
                    case 'ArrowLeft':
                    case 'Left':
                        return this.menuPosition === 'left';
                    case 'ArrowRight':
                    case 'Right':
                        return this.menuPosition === 'right';
                }
                return false;
            };
        MenuNavigationToggleDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxMenuNavigationToggle]',
                        exportAs: 'uxMenuNavigationToggle'
                    },] }
        ];
        /** @nocollapse */
        MenuNavigationToggleDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef }
            ];
        };
        MenuNavigationToggleDirective.propDecorators = {
            menuOpen: [{ type: core.Input }],
            menuPosition: [{ type: core.Input }],
            menuOpenChange: [{ type: core.Output }],
            keydownHandler: [{ type: core.HostListener, args: ['keydown', ['$event'],] }]
        };
        return MenuNavigationToggleDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ EXPORTS = [
        MenuNavigationDirective,
        MenuNavigationItemDirective,
        MenuNavigationToggleDirective
    ];
    var MenuNavigationModule = (function () {
        function MenuNavigationModule() {
        }
        MenuNavigationModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [],
                        exports: EXPORTS,
                        declarations: EXPORTS,
                    },] }
        ];
        return MenuNavigationModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FilterContainerComponent = (function () {
        function FilterContainerComponent() {
            this.filters = [];
            this.filtersChange = new core.EventEmitter();
            this.events = new core.EventEmitter();
        }
        /**
         * @param {?} filter
         * @return {?}
         */
        FilterContainerComponent.prototype.addFilter = /**
         * @param {?} filter
         * @return {?}
         */
            function (filter$$1) {
                this.filters.push(filter$$1);
                this.events.next(new FilterAddEvent(filter$$1));
                this.filtersChange.emit(this.filters);
            };
        /**
         * @param {?} filter
         * @return {?}
         */
        FilterContainerComponent.prototype.removeFilter = /**
         * @param {?} filter
         * @return {?}
         */
            function (filter$$1) {
                var /** @type {?} */ idx = this.filters.findIndex(function (filters) { return filters === filter$$1; });
                if (idx !== -1) {
                    this.filters.splice(idx, 1);
                    this.events.next(new FilterRemoveEvent(filter$$1));
                    this.filtersChange.emit(this.filters);
                }
            };
        /**
         * @return {?}
         */
        FilterContainerComponent.prototype.removeAll = /**
         * @return {?}
         */
            function () {
                this.events.next(new FilterRemoveAllEvent());
            };
        FilterContainerComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-filter-container',
                        template: "<ng-content></ng-content>\n\n<!-- Add a Clear Button -->\n<button class=\"btn btn-link btn-icon btn-secondary m-l-xs\"\n    tabindex=\"0\"\n    aria-label=\"Clear all filters\"\n    i18n-aria-label\n    *ngIf=\"filters.length > 0\"\n    [uxTooltip]=\"clearTooltip || 'Clear All'\"\n    (click)=\"removeAll()\">\n\n    <svg class=\"filter-selected-clear-graphic\" width=\"100%\" viewBox=\"0 0 19 12\" shape-rendering=\"geometricPrecision\">\n        <rect class=\"light-grey\" x=\"0\" y=\"2\" width=\"7\" height=\"2\"></rect>\n        <rect class=\"dark-grey\" x=\"0\" y=\"5\" width=\"9\" height=\"2\"></rect>\n        <rect class=\"light-grey\" x=\"0\" y=\"8\" width=\"7\" height=\"2\"></rect>\n        <path class=\"dark-grey\" d=\"M9,1 h1 l9,9 v1 h-1 l-9,-9 v-1 Z\"></path>\n        <path class=\"dark-grey\" d=\"M9,11 v-1 l9,-9 h1 v1 l-9,9 h-1 Z\"></path>\n    </svg>\n\n</button>"
                    }] }
        ];
        FilterContainerComponent.propDecorators = {
            filters: [{ type: core.Input }],
            clearTooltip: [{ type: core.Input }],
            filtersChange: [{ type: core.Output }],
            events: [{ type: core.Output }]
        };
        return FilterContainerComponent;
    }());
    var FilterAddEvent = (function () {
        function FilterAddEvent(filter$$1) {
            this.filter = filter$$1;
        }
        return FilterAddEvent;
    }());
    var FilterRemoveEvent = (function () {
        function FilterRemoveEvent(filter$$1) {
            this.filter = filter$$1;
        }
        return FilterRemoveEvent;
    }());
    var FilterRemoveAllEvent = (function () {
        function FilterRemoveAllEvent() {
        }
        return FilterRemoveAllEvent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FilterBaseComponent = (function () {
        function FilterBaseComponent(filtersContainer, _announcer) {
            this.filtersContainer = filtersContainer;
            this._announcer = _announcer;
            this._subscription = filtersContainer.events.pipe(operators.filter(function (event) { return event instanceof FilterRemoveAllEvent; })).subscribe(this.removeFilter.bind(this));
        }
        /**
         * @return {?}
         */
        FilterBaseComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @param {?} _filter
         * @return {?}
         */
        FilterBaseComponent.prototype.addFilter = /**
         * @param {?} _filter
         * @return {?}
         */
            function (_filter) {
                if (!_filter.initial) {
                    this.filtersContainer.addFilter(_filter);
                    this._announcer.announce("Filter " + _filter.name + " selected.");
                }
            };
        /**
         * @param {?} _filter
         * @return {?}
         */
        FilterBaseComponent.prototype.removeFilter = /**
         * @param {?} _filter
         * @return {?}
         */
            function (_filter) {
                if (!_filter) {
                    return;
                }
                this.filtersContainer.removeFilter(_filter);
                this._announcer.announce("Filter " + _filter.name + " deselected.");
            };
        FilterBaseComponent.decorators = [
            { type: core.Directive, args: [{
                        selector: 'ux-filter-base'
                    },] }
        ];
        /** @nocollapse */
        FilterBaseComponent.ctorParameters = function () {
            return [
                { type: FilterContainerComponent, decorators: [{ type: core.Host }] },
                { type: a11y.LiveAnnouncer }
            ];
        };
        FilterBaseComponent.propDecorators = {
            filters: [{ type: core.Input }]
        };
        return FilterBaseComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FilterDropdownComponent = (function (_super) {
        __extends(FilterDropdownComponent, _super);
        function FilterDropdownComponent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @return {?}
         */
        FilterDropdownComponent.prototype.removeFilter = /**
         * @return {?}
         */
            function () {
                _super.prototype.removeFilter.call(this, this.selected);
                this.selected = this.initial;
            };
        /**
         * @return {?}
         */
        FilterDropdownComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.selected = this.initial;
            };
        /**
         * @param {?} filter
         * @param {?} event
         * @return {?}
         */
        FilterDropdownComponent.prototype.selectFilter = /**
         * @param {?} filter
         * @param {?} event
         * @return {?}
         */
            function (filter$$1, event) {
                this.removeFilter();
                this.selected = filter$$1;
                this.addFilter(this.selected);
                event.stopPropagation();
                event.preventDefault();
            };
        FilterDropdownComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-filter-dropdown',
                        template: "<div class=\"btn-group\" dropdown [autoClose]=\"true\" #dropdown=\"bs-dropdown\">\n\n    <button\n        type=\"button\"\n        tabindex=\"0\"\n        dropdownToggle\n        uxMenuNavigationToggle\n        #menuNavigationToggle=\"uxMenuNavigationToggle\"\n        [(menuOpen)]=\"dropdown.isOpen\"\n        aria-haspopup=\"true\"\n        [attr.aria-expanded]=\"dropdown.isOpen\"\n        class=\"filter-dropdown btn dropdown-toggle\"\n        [class.active]=\"selected !== initial\">\n        {{ selected?.title }}\n        <span class=\"hpe-icon hpe-down\"></span>\n    </button>\n\n    <ul *dropdownMenu\n        uxMenuNavigation\n        [toggleButton]=\"menuNavigationToggle\"\n        class=\"dropdown-menu\" role=\"menu\">\n\n        <li class=\"dropdown-list-item\"\n            *ngFor=\"let filter of filters\"\n            role=\"none\">\n\n            <a class=\"dropdown-item\"\n                role=\"listitem\"\n                tabindex=\"-1\"\n                uxMenuNavigationItem\n                [attr.aria-selected]=\"filter === selected\"\n                (click)=\"selectFilter(filter, $event); dropdown.hide(); menuNavigationToggle.focus()\"\n                (keydown.enter)=\"selectFilter(filter, $event); dropdown.hide(); menuNavigationToggle.focus()\">\n\n                <i class=\"hpe-icon\" [class.hpe-checkmark]=\"filter === selected\"></i>\n                <span class=\"filter-dropdown-title\">{{ filter.name }}</span>\n            </a>\n        </li>\n    </ul>\n</div>"
                    }] }
        ];
        FilterDropdownComponent.propDecorators = {
            initial: [{ type: core.Input }]
        };
        return FilterDropdownComponent;
    }(FilterBaseComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ uniqueId$4 = 1;
    var FilterDynamicComponent = (function (_super) {
        __extends(FilterDynamicComponent, _super);
        function FilterDynamicComponent(typeaheadKeyService, container, announcer) {
            var _this = _super.call(this, container, announcer) || this;
            _this.typeaheadKeyService = typeaheadKeyService;
            _this.defaultOptions = {
                placeholder: '',
                minCharacters: 3,
                maxResults: Infinity
            };
            _this.typeaheadId = "ux-filter-dynamic-typeahead-" + uniqueId$4++;
            _this.query$ = new BehaviorSubject.BehaviorSubject('');
            _this.showTypeahead = true;
            _this.typeaheadItems = [];
            _this.typeaheadOpen = false;
            _this._config = __assign({}, _this.defaultOptions);
            return _this;
        }
        Object.defineProperty(FilterDynamicComponent.prototype, "options", {
            get: /**
             * @return {?}
             */ function () {
                return this._config;
            },
            set: /**
             * @param {?} options
             * @return {?}
             */ function (options) {
                this._config = __assign({}, this.defaultOptions, options);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        FilterDynamicComponent.prototype.getItems = /**
         * @return {?}
         */
            function () {
                var _this = this;
                var /** @type {?} */ query = this.query$.value.toLowerCase();
                return this.filters.filter(function (item) { return item !== _this.initial && item.name.toLowerCase().indexOf(query) !== -1; })
                    .map(function (item) { return item.name; })
                    .slice(0, this._config.maxResults);
            };
        /**
         * @return {?}
         */
        FilterDynamicComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.selected = this.initial;
                this.typeaheadItems = this.getItems();
                if (this.options && this.options.maxIndividualItems && this.options.maxIndividualItems + 1 >= this.filters.length) {
                    this.showTypeahead = false;
                }
            };
        /**
         * @param {?} typeaheadOption
         * @return {?}
         */
        FilterDynamicComponent.prototype.selectOption = /**
         * @param {?} typeaheadOption
         * @return {?}
         */
            function (typeaheadOption) {
                this.removeFilter();
                var /** @type {?} */ idx = this.filters.findIndex(function (filter$$1) { return filter$$1.name === typeaheadOption.value; });
                this.selected = this.filters[idx];
                this.addFilter(this.selected);
                this.query$.next('');
                this.dropdown.hide();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        FilterDynamicComponent.prototype.clickOff = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                var /** @type {?} */ target = (event.target);
                var /** @type {?} */ hideDropdown = true;
                while (target && target.nodeName !== 'BODY') {
                    if (target.classList.contains('ux-dynamic-filter')) {
                        hideDropdown = false;
                        break;
                    }
                    else {
                        target = target.parentElement;
                    }
                }
                if (hideDropdown) {
                    this.query$.next('');
                    this.dropdown.hide();
                }
            };
        /**
         * @return {?}
         */
        FilterDynamicComponent.prototype.removeFilter = /**
         * @return {?}
         */
            function () {
                if (this.selected !== this.initial) {
                    _super.prototype.removeFilter.call(this, this.selected);
                    this.selected = this.initial;
                }
                this.query$.next('');
            };
        /**
         * @param {?} filter
         * @return {?}
         */
        FilterDynamicComponent.prototype.selectFilter = /**
         * @param {?} filter
         * @return {?}
         */
            function (filter$$1) {
                this.removeFilter();
                this.selected = filter$$1;
                this.addFilter(this.selected);
            };
        /**
         * @param {?} query
         * @return {?}
         */
        FilterDynamicComponent.prototype.updateTypeahead = /**
         * @param {?} query
         * @return {?}
         */
            function (query) {
                this.typeaheadOpen = query.length >= this._config.minCharacters;
                this.typeaheadItems = this.getItems();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        FilterDynamicComponent.prototype.select = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // find the filter with the matching name
                var /** @type {?} */ filter$$1 = this.filters.find(function (_filter) { return _filter.name === event.option; });
                if (filter$$1) {
                    this.selectFilter(filter$$1);
                }
            };
        FilterDynamicComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-filter-dynamic',
                        template: "<div class=\"btn-group ux-dynamic-filter\"\n    dropdown\n    [autoClose]=\"true\"\n    #dynamicDropdown=\"bs-dropdown\">\n\n    <button\n        type=\"button\"\n        tabindex=\"0\"\n        dropdownToggle\n        aria-haspopup=\"true\"\n        uxMenuNavigationToggle\n        #menuNavigationToggle=\"uxMenuNavigationToggle\"\n        [(menuOpen)]=\"dynamicDropdown.isOpen\"\n        [attr.aria-expanded]=\"dynamicDropdown.isOpen\"\n        [class.active]=\"selected !== initial\"\n        class=\"filter-dropdown btn dropdown-toggle\">\n        {{ selected?.title }}\n        <span class=\"hpe-icon hpe-down\"></span>\n    </button>\n\n    <ul *dropdownMenu\n        class=\"dropdown-menu\"\n        role=\"menu\"\n        uxMenuNavigation\n        [toggleButton]=\"menuNavigationToggle\">\n\n        <li class=\"dropdown-list-item\"\n            *ngIf=\"showTypeahead\"\n            role=\"none\">\n\n            <a class=\"dropdown-item\"\n                role=\"menuitem\"\n                tabindex=\"-1\"\n                uxMenuNavigationItem\n                [attr.aria-selected]=\"initial === selected\"\n                (click)=\"removeFilter(); $event.stopPropagation(); $event.preventDefault(); dynamicDropdown.hide(); menuNavigationToggle.focus()\"\n                (keydown.enter)=\"removeFilter(); $event.stopPropagation(); $event.preventDefault(); dynamicDropdown.hide(); menuNavigationToggle.focus()\">\n\n                <i class=\"hpe-icon\" [class.hpe-checkmark]=\"initial === selected\"></i>\n                <span class=\"filter-dropdown-title\">{{ initial.name }}</span>\n            </a>\n        </li>\n\n        <li class=\"dropdown-list-item\"\n            *ngIf=\"selected !== initial && showTypeahead\"\n            role=\"none\">\n\n            <a class=\"dropdown-item\"\n                role=\"menuitem\"\n                tabindex=\"-1\"\n                uxMenuNavigationItem>\n                <i class=\"hpe-icon hpe-checkmark\"></i>\n                <span class=\"filter-dropdown-title\">{{ selected.name }}</span>\n            </a>\n        </li>\n\n        <hr>\n\n        <li *ngIf=\"showTypeahead\" class=\"typeahead-box\" role=\"none\">\n\n                <input type=\"text\"\n                    class=\"form-control\"\n                    [placeholder]=\"options?.placeholder || defaultOptions.placeholder\"\n                    [attr.aria-activedescendant]=\"highlightedElement?.id\"\n                    [attr.aria-controls]=\"typeaheadId\"\n                    aria-autocomplete=\"list\"\n                    aria-multiline=\"false\"\n                    [ngModel]=\"query$ | async\"\n                    (ngModelChange)=\"query$.next($event); updateTypeahead($event)\"\n                    (keydown)=\"typeaheadKeyService.handleKey($event, typeahead); $event.stopPropagation();\"\n                    (keydown.enter)=\"$event.preventDefault()\"\n                    (blur)=\"typeaheadOpen = false\"\n                    (click)=\"$event.stopPropagation()\">\n\n                <ux-typeahead #typeahead\n                    [id]=\"typeaheadId\"\n                    [(open)]=\"typeaheadOpen\"\n                    display=\"title\"\n                    [selectOnEnter]=\"true\"\n                    [options]=\"typeaheadItems\"\n                    [optionTemplate]=\"filterOptionTemplate\"\n                    (optionSelected)=\"select($event); dynamicDropdown.hide(); menuNavigationToggle.focus()\"\n                    (highlightedElementChange)=\"highlightedElement = $event\">\n                </ux-typeahead>\n        </li>\n\n        <ng-container *ngIf=\"!showTypeahead\">\n\n            <li class=\"dropdown-list-item\"\n                *ngFor=\"let filter of filters\"\n                role=\"none\">\n\n                <a class=\"dropdown-item\"\n                    role=\"menuitem\"\n                    tabindex=\"-1\"\n                    uxMenuNavigationItem\n                    [attr.aria-selected]=\"filter === selected\"\n                    (click)=\"selectFilter(filter); $event.stopPropagation(); $event.preventDefault(); dynamicDropdown.hide(); menuNavigationToggle.focus()\"\n                    (keydown.enter)=\"selectFilter(filter); $event.stopPropagation(); $event.preventDefault(); dynamicDropdown.hide(); menuNavigationToggle.focus()\">\n\n                    <i class=\"hpe-icon\" [class.hpe-checkmark]=\"filter === selected\"></i>\n                    <span class=\"filter-dropdown-title\">{{ filter.name }}</span>\n                </a>\n            </li>\n\n        </ng-container>\n\n    </ul>\n</div>\n\n<ng-template #filterOptionTemplate let-option=\"option\" let-api=\"api\">\n    <span [attr.aria-label]=\"option\" [innerHTML]=\"option | filterTypeaheadHighlight: (query$ | async)\"></span>\n</ng-template>",
                        host: {
                            '(document:click)': 'clickOff($event)',
                        }
                    }] }
        ];
        /** @nocollapse */
        FilterDynamicComponent.ctorParameters = function () {
            return [
                { type: TypeaheadKeyService },
                { type: FilterContainerComponent },
                { type: a11y.LiveAnnouncer }
            ];
        };
        FilterDynamicComponent.propDecorators = {
            filters: [{ type: core.Input }],
            initial: [{ type: core.Input }],
            options: [{ type: core.Input }],
            dropdown: [{ type: core.ViewChild, args: [dropdown.BsDropdownDirective,] }]
        };
        return FilterDynamicComponent;
    }(FilterBaseComponent));
    var FilterTypeaheadHighlight = (function () {
        function FilterTypeaheadHighlight() {
        }
        /**
         * @param {?} value
         * @param {?} searchQuery
         * @return {?}
         */
        FilterTypeaheadHighlight.prototype.transform = /**
         * @param {?} value
         * @param {?} searchQuery
         * @return {?}
         */
            function (value, searchQuery) {
                var /** @type {?} */ regex = new RegExp(searchQuery, 'i');
                return value.replace(regex, "<b class=\"filter-typeahead-highlighted\">" + value.match(regex) + "</b>");
            };
        FilterTypeaheadHighlight.decorators = [
            { type: core.Pipe, args: [{
                        name: 'filterTypeaheadHighlight'
                    },] }
        ];
        return FilterTypeaheadHighlight;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ DECLARATIONS$2 = [
        FilterBaseComponent,
        FilterContainerComponent,
        FilterDropdownComponent,
        FilterDynamicComponent,
        FilterTypeaheadHighlight
    ];
    var FilterModule = (function () {
        function FilterModule() {
        }
        FilterModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            dropdown.BsDropdownModule.forRoot(),
                            TooltipModule,
                            forms.FormsModule,
                            MenuNavigationModule,
                            common.CommonModule,
                            TypeaheadModule,
                            a11y.A11yModule
                        ],
                        exports: DECLARATIONS$2,
                        declarations: DECLARATIONS$2
                    },] }
        ];
        return FilterModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FlippableCardComponent = (function () {
        function FlippableCardComponent() {
            this.direction = 'horizontal';
            this.trigger = 'hover';
            this.width = 280;
            this.height = 200;
            this.flipped = false;
            this.flippedChange = new core.EventEmitter();
        }
        /**
         * @param {?} state
         * @return {?}
         */
        FlippableCardComponent.prototype.setFlipped = /**
         * @param {?} state
         * @return {?}
         */
            function (state) {
                this.flipped = state;
                this.flippedChange.emit(this.flipped);
            };
        /**
         * @return {?}
         */
        FlippableCardComponent.prototype.toggleFlipped = /**
         * @return {?}
         */
            function () {
                this.setFlipped(!this.flipped);
            };
        /**
         * @return {?}
         */
        FlippableCardComponent.prototype.clickTrigger = /**
         * @return {?}
         */
            function () {
                // add or remove the class depending on whether or not the card has been flipped
                if (this.trigger === 'click') {
                    this.toggleFlipped();
                }
            };
        /**
         * @return {?}
         */
        FlippableCardComponent.prototype.hoverEnter = /**
         * @return {?}
         */
            function () {
                // if the trigger is hover then begin to flip
                if (this.trigger === 'hover') {
                    this.setFlipped(true);
                }
            };
        /**
         * @return {?}
         */
        FlippableCardComponent.prototype.hoverExit = /**
         * @return {?}
         */
            function () {
                if (this.trigger === 'hover') {
                    this.setFlipped(false);
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        FlippableCardComponent.prototype.onKeyDown = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this.trigger !== 'manual') {
                    this.toggleFlipped();
                    event.preventDefault();
                }
            };
        FlippableCardComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-flippable-card',
                        template: "<div class=\"ux-flipper\"\n     [class.ux-flip-card]=\"flipped\"\n     [style.width.px]=\"width\"\n     [style.height.px]=\"height\">\n\n    <div class=\"ux-flippable-card-front\"\n         [style.width.px]=\"width\"\n         [style.height.px]=\"height\"\n         [attr.aria-hidden]=\"flipped\">\n\n        <ng-content select=\"ux-flippable-card-front\"></ng-content>\n    </div>\n\n    <div class=\"ux-flippable-card-back\"\n         [style.width.px]=\"width\"\n         [style.height.px]=\"height\"\n         [attr.aria-hidden]=\"!flipped\">\n\n        <ng-content select=\"ux-flippable-card-back\"></ng-content>\n    </div>\n</div>",
                        host: {
                            'tabindex': '0',
                            '[class.horizontal]': 'direction === "horizontal"',
                            '[class.vertical]': 'direction === "vertical"'
                        },
                        exportAs: 'ux-flippable-card'
                    }] }
        ];
        FlippableCardComponent.propDecorators = {
            direction: [{ type: core.Input }],
            trigger: [{ type: core.Input }],
            width: [{ type: core.Input }],
            height: [{ type: core.Input }],
            flipped: [{ type: core.Input }],
            flippedChange: [{ type: core.Output }],
            clickTrigger: [{ type: core.HostListener, args: ['click',] }],
            hoverEnter: [{ type: core.HostListener, args: ['mouseenter',] }],
            hoverExit: [{ type: core.HostListener, args: ['mouseleave',] }],
            onKeyDown: [{ type: core.HostListener, args: ['keydown.enter', ['$event'],] }, { type: core.HostListener, args: ['keydown.space', ['$event'],] }, { type: core.HostListener, args: ['keydown.spacebar', ['$event'],] }]
        };
        return FlippableCardComponent;
    }());
    var FlippableCardFrontDirective = (function () {
        function FlippableCardFrontDirective() {
        }
        FlippableCardFrontDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'ux-flippable-card-front'
                    },] }
        ];
        return FlippableCardFrontDirective;
    }());
    var FlippableCardBackDirective = (function () {
        function FlippableCardBackDirective() {
        }
        FlippableCardBackDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: 'ux-flippable-card-back'
                    },] }
        ];
        return FlippableCardBackDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FlippableCardModule = (function () {
        function FlippableCardModule() {
        }
        FlippableCardModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [FlippableCardComponent, FlippableCardBackDirective, FlippableCardFrontDirective],
                        declarations: [FlippableCardComponent, FlippableCardBackDirective, FlippableCardFrontDirective]
                    },] }
        ];
        return FlippableCardModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FloatingActionButtonsService = (function () {
        function FloatingActionButtonsService() {
            this.open$ = new BehaviorSubject.BehaviorSubject(false);
        }
        /**
         * @return {?}
         */
        FloatingActionButtonsService.prototype.open = /**
         * @return {?}
         */
            function () {
                this.open$.next(true);
            };
        /**
         * @return {?}
         */
        FloatingActionButtonsService.prototype.toggle = /**
         * @return {?}
         */
            function () {
                this.open$.next(!this.open$.getValue());
            };
        /**
         * @return {?}
         */
        FloatingActionButtonsService.prototype.close = /**
         * @return {?}
         */
            function () {
                this.open$.next(false);
            };
        FloatingActionButtonsService.decorators = [
            { type: core.Injectable }
        ];
        return FloatingActionButtonsService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FloatingActionButtonsComponent = (function () {
        function FloatingActionButtonsComponent(fab, _elementRef) {
            var _this = this;
            this.fab = fab;
            this._elementRef = _elementRef;
            this.direction = 'top';
            this.openChange = new core.EventEmitter();
            this._subscription = new Subscription.Subscription();
            this._subscription.add(this.fab.open$.subscribe(function (value) { return _this.openChange.emit(value); }));
        }
        /**
         * @return {?}
         */
        FloatingActionButtonsComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this._subscription.add(this.fab.open$.pipe(operators.filter(function (open) { return open === false; }))
                    .subscribe(function () { return _this.tooltips.forEach(function (tooltip$$1) { return tooltip$$1.hide(); }); }));
            };
        /**
         * @return {?}
         */
        FloatingActionButtonsComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._subscription.unsubscribe();
            };
        /*
         * Detect any clicks to trigger close of the menu
         */
        /**
         * @param {?} target
         * @return {?}
         */
        FloatingActionButtonsComponent.prototype.close = /**
         * @param {?} target
         * @return {?}
         */
            function (target) {
                if (!this._elementRef.nativeElement.contains(target)) {
                    this.fab.close();
                }
            };
        FloatingActionButtonsComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-floating-action-buttons',
                        template: "<ng-content select=\"[fab-primary]\"></ng-content>\n\n<div class=\"floating-action-button-list\" [@fabAnimation]=\"fab.open$ | async\" [ngClass]=\"direction\" *ngIf=\"fab.open$ | async\">\n    <ng-content></ng-content>\n</div>",
                        providers: [FloatingActionButtonsService],
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        preserveWhitespaces: false,
                        animations: [
                            animations.trigger('fabAnimation', [
                                animations.transition('void => true', [
                                    animations.query('ux-floating-action-button', animations.style({ opacity: 0 })),
                                    animations.query('ux-floating-action-button', animations.stagger(50, animations.animate(250, animations.style({ opacity: 1 }))))
                                ]),
                                animations.transition('true => void', [
                                    animations.query('ux-floating-action-button', animations.stagger(-50, animations.animate(250, animations.style({ opacity: 0 }))))
                                ])
                            ])
                        ]
                    }] }
        ];
        /** @nocollapse */
        FloatingActionButtonsComponent.ctorParameters = function () {
            return [
                { type: FloatingActionButtonsService },
                { type: core.ElementRef }
            ];
        };
        FloatingActionButtonsComponent.propDecorators = {
            direction: [{ type: core.Input }],
            tooltips: [{ type: core.ContentChildren, args: [tooltip.TooltipDirective,] }],
            openChange: [{ type: core.Output }],
            close: [{ type: core.HostListener, args: ['document:click', ['$event.target'],] }]
        };
        return FloatingActionButtonsComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FloatingActionButtonComponent = (function () {
        function FloatingActionButtonComponent(primary, fab) {
            this.fab = fab;
            this.tabindex = 1;
            this.primary = false;
            this.primary = primary !== null;
        }
        FloatingActionButtonComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-floating-action-button',
                        template: "<button class=\"btn floating-action-button\" \n        [class.button-primary]=\"primary\" \n        [class.button-secondary]=\"!primary\" \n        (click)=\"primary ? fab.toggle() : fab.close()\">\n\n    <span class=\"hpe-icon floating-action-button-icon\" *ngIf=\"icon\" [ngClass]=\"icon\"></span>\n    <ng-content *ngIf=\"!icon\"></ng-content>\n\n</button>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        preserveWhitespaces: false
                    }] }
        ];
        /** @nocollapse */
        FloatingActionButtonComponent.ctorParameters = function () {
            return [
                { type: String, decorators: [{ type: core.Attribute, args: ['fab-primary',] }] },
                { type: FloatingActionButtonsService }
            ];
        };
        FloatingActionButtonComponent.propDecorators = {
            icon: [{ type: core.Input }],
            tabindex: [{ type: core.HostBinding }]
        };
        return FloatingActionButtonComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FloatingActionButtonsModule = (function () {
        function FloatingActionButtonsModule() {
        }
        FloatingActionButtonsModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule
                        ],
                        exports: [
                            FloatingActionButtonsComponent,
                            FloatingActionButtonComponent
                        ],
                        declarations: [
                            FloatingActionButtonsComponent,
                            FloatingActionButtonComponent
                        ]
                    },] }
        ];
        return FloatingActionButtonsModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var HierarchyBarService = (function () {
        function HierarchyBarService() {
            this.nodes$ = new BehaviorSubject.BehaviorSubject([]);
            this._nodes = [];
        }
        /**
         * Store the root node of the hierarchy tree
         */
        /**
         * Store the root node of the hierarchy tree
         * @param {?} root
         * @return {?}
         */
        HierarchyBarService.prototype.setRootNode = /**
         * Store the root node of the hierarchy tree
         * @param {?} root
         * @return {?}
         */
            function (root) {
                // store the root node
                this._root = root;
                // create a flat structure of nodes
                this._nodes = this.getNodeList(root);
                // flatten the array - based on the selected node
                this.nodes$.next(this.getSelectedChildren(root));
            };
        /**
         * Select a node. This causes all nodes to be
         * deselected and the path to the selected node
         * to be selected
         */
        /**
         * Select a node. This causes all nodes to be
         * deselected and the path to the selected node
         * to be selected
         * @param {?} node
         * @return {?}
         */
        HierarchyBarService.prototype.selectNode = /**
         * Select a node. This causes all nodes to be
         * deselected and the path to the selected node
         * to be selected
         * @param {?} node
         * @return {?}
         */
            function (node) {
                // deselect all nodes
                this.deselectAll();
                // ensure the current node is selected and its parents
                this.select(node);
                // emit a new node list to trigger change detection
                this.nodes$.next(this.getSelectedChildren(this._root));
            };
        /**
         * Handles getting children with support for both arrays and observables
         */
        /**
         * Handles getting children with support for both arrays and observables
         * @param {?} node
         * @return {?}
         */
        HierarchyBarService.prototype.getChildren = /**
         * Handles getting children with support for both arrays and observables
         * @param {?} node
         * @return {?}
         */
            function (node) {
                var _this = this;
                if (Array.isArray(node.children)) {
                    return of.of({ loading: false, children: node.children });
                }
                var /** @type {?} */ children$ = node.children;
                // if it is an observable then handle loading
                return Observable.Observable.create(function (observer) {
                    // emit initial value
                    observer.next({ loading: true, children: [] });
                    // now wait until the children observable completes
                    children$.pipe(operators.first()).subscribe(function (children) {
                        // replace the observable with an array for future loading
                        node.children = children;
                        // rebuild the node tree
                        // rebuild the node tree
                        _this.setRootNode(_this._root);
                        // emit the latest value
                        observer.next({ loading: false, children: children });
                        // close the observable stream
                        observer.complete();
                    });
                });
            };
        /**
         * Traverses all the parents to ensure they are selected
         * @param {?} node
         * @return {?}
         */
        HierarchyBarService.prototype.select = /**
         * Traverses all the parents to ensure they are selected
         * @param {?} node
         * @return {?}
         */
            function (node) {
                node.selected = true;
                if (node.parent) {
                    this.select(node.parent);
                }
            };
        /**
         * Deselects all nodes
         * @return {?}
         */
        HierarchyBarService.prototype.deselectAll = /**
         * Deselects all nodes
         * @return {?}
         */
            function () {
                this._nodes.forEach(function (node) { return node.selected = false; });
            };
        /**
         * Gets all the nodes in the tree as a flat array.
         * It also stores the parent node in a parent property
         * on the node for easy traversal in both directions
         * @param {?} node
         * @return {?}
         */
        HierarchyBarService.prototype.getNodeList = /**
         * Gets all the nodes in the tree as a flat array.
         * It also stores the parent node in a parent property
         * on the node for easy traversal in both directions
         * @param {?} node
         * @return {?}
         */
            function (node) {
                var _this = this;
                // if there are no children then return only itself
                if (!node.children || node.children instanceof Observable.Observable || node.children.length === 0) {
                    return [node];
                }
                // store the parent property
                node.children.forEach(function (child) { return child.parent = node; });
                // get all descendants of this node
                var /** @type {?} */ descendants = node.children.reduce(function (nodes, current) { return __spread(nodes, _this.getNodeList(current)); }, []);
                return __spread([node], descendants);
            };
        /**
         * Gets all selected nodes from the parent node.
         * @param {?} node
         * @return {?}
         */
        HierarchyBarService.prototype.getSelectedChildren = /**
         * Gets all selected nodes from the parent node.
         * @param {?} node
         * @return {?}
         */
            function (node) {
                if (node.children instanceof Observable.Observable) {
                    return [node];
                }
                // get the children - and account for when there is none
                var /** @type {?} */ children = node.children || [];
                // check if any child is selected
                var /** @type {?} */ child = children.find(function (_child) { return _child.selected; });
                // return the remaining chain of selected items
                return child ? __spread([node], this.getSelectedChildren(child)) : [node];
            };
        HierarchyBarService.decorators = [
            { type: core.Injectable }
        ];
        return HierarchyBarService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var HierarchyBarComponent = (function () {
        function HierarchyBarComponent(hierarchyBar) {
            var _this = this;
            this.hierarchyBar = hierarchyBar;
            this.selectedChange = new core.EventEmitter();
            this.overflow$ = new BehaviorSubject.BehaviorSubject(false);
            this.overflowNodes$ = new BehaviorSubject.BehaviorSubject([]);
            this._subscription = new Subscription.Subscription();
            // subscribe to changes in the selected node
            var /** @type {?} */ selected = hierarchyBar.nodes$.subscribe(function (nodes) { return _this.selectedChange.emit(nodes.length === 0 ? null : nodes[nodes.length - 1]); });
            var /** @type {?} */ changed = hierarchyBar.nodes$.pipe(operators.debounceTime(0)).subscribe(function () { return _this.scrollIntoView(); });
            // store subscriptions
            this._subscription.add(selected);
            this._subscription.add(changed);
        }
        Object.defineProperty(HierarchyBarComponent.prototype, "root", {
            set: /**
             * @param {?} node
             * @return {?}
             */ function (node) {
                this.hierarchyBar.setRootNode(node);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HierarchyBarComponent.prototype, "selected", {
            set: /**
             * @param {?} node
             * @return {?}
             */ function (node) {
                this.hierarchyBar.selectNode(node);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        HierarchyBarComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * When there is overflow ensure that the rightmost
         * node remains in view at all times. The nodes no longer
         * visible be be displayed in a popover available on the
         * overflow indicator
         */
        /**
         * When there is overflow ensure that the rightmost
         * node remains in view at all times. The nodes no longer
         * visible be be displayed in a popover available on the
         * overflow indicator
         * @return {?}
         */
        HierarchyBarComponent.prototype.scrollIntoView = /**
         * When there is overflow ensure that the rightmost
         * node remains in view at all times. The nodes no longer
         * visible be be displayed in a popover available on the
         * overflow indicator
         * @return {?}
         */
            function () {
                var _this = this;
                if (!this.nodelist) {
                    return;
                }
                // get the native element
                var nativeElement = this.nodelist.nativeElement;
                // emit whether or not there is overflow
                this.overflow$.next(nativeElement.scrollWidth > nativeElement.offsetWidth);
                // if the hierarchy bar contents do not overflow then do nothing
                if (nativeElement.scrollWidth > nativeElement.offsetWidth) {
                    // determine the amount of overflow
                    var /** @type {?} */ overflowAmount_1 = nativeElement.scrollWidth - nativeElement.offsetWidth;
                    // determine which nodes are not fully visible
                    this.overflowNodes$.next(this.nodes.filter(function (node) { return node.nativeElement.offsetLeft < overflowAmount_1; })
                        .map(function (node, index) { return _this.hierarchyBar.nodes$.value[index]; }));
                    // move the scroll position to always show the last itme
                    this.nodelist.nativeElement.scrollLeft = overflowAmount_1;
                }
            };
        HierarchyBarComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-hierarchy-bar',
                        template: "<!-- Allow content to be placed on the left of the items -->\n<aside class=\"hierarchy-bar-addons\">\n    <ng-content select=\"[uxHierarchyBarLeftAddon]\"></ng-content>\n</aside>\n\n<main #nodelist class=\"hierarchy-bar-nodes\" (uxResize)=\"scrollIntoView()\">\n\n    <div *ngIf=\"overflow$ | async\"\n         #popover=\"ux-popover\"\n         class=\"hierarchy-bar-overflow-indicator\"\n         [style.left.px]=\"nodelist.scrollLeft\"\n         [uxPopover]=\"overflow\"\n         [popoverContext]=\"{ popover: popover }\"\n         placement=\"bottom\"\n         popoverClass=\"hierarchy-bar-popover\">\n        . . .\n    </div>\n\n    <div #nodeElement class=\"hierarchy-bar-node\"\n         *ngFor=\"let node of hierarchyBar.nodes$ | async\">\n\n        <button class=\"hierarchy-bar-node-content\"\n                [attr.aria-label]=\"node.title\"\n                (click)=\"hierarchyBar.selectNode(node)\">\n\n            <!-- Show an icon if specifed -->\n            <img class=\"hierarchy-bar-node-icon\" *ngIf=\"node.icon\" [src]=\"node.icon\" alt=\"Hierarchy Bar Icon\">\n\n            <!-- Show the name of the current node -->\n            <span class=\"hierarchy-bar-node-title\">{{ node.title }}</span>\n\n        </button>\n\n        <!-- Show a dropdown arrow if there are children -->\n        <button *ngIf=\"node.children\"\n              #popover=\"ux-popover\"\n              aria-label=\"Show children\"\n              role=\"button\"\n              class=\"hierarchy-bar-node-arrow hpe-icon hpe-next\"\n              [uxPopover]=\"content\"\n              [popoverContext]=\"{ node: node, popover: popover }\"\n              placement=\"bottom\"\n              popoverClass=\"hierarchy-bar-popover\"\n              tabindex=\"0\">\n        </button>\n\n    </div>\n\n</main>\n\n<!-- Allow content to be placed on the right of the items -->\n<aside class=\"hierarchy-bar-addons\">\n    <ng-content select=\"[uxHierarchyBarRightAddon]\"></ng-content>\n</aside>\n\n<!-- Template for the popover list -->\n<ng-template #content let-node=\"node\" let-popover=\"popover\">\n\n    <!-- Loading Indicator -->\n    <ul class=\"hierarchy-bar-node-list\" *ngIf=\"(hierarchyBar.getChildren(node) | async).loading\">\n\n        <li class=\"hierarchy-bar-node-list-item\">\n            <ng-container [ngTemplateOutlet]=\"loadingIndicator || defaultLoadingIndicator\"></ng-container>\n        </li>\n    </ul>\n\n    <!-- List of children -->\n    <ul class=\"hierarchy-bar-node-list\" *ngIf=\"!(hierarchyBar.getChildren(node) | async).loading\">\n\n        <li *ngFor=\"let child of (hierarchyBar.getChildren(node) | async).children; let first = first\"\n            class=\"hierarchy-bar-node-list-item\"\n            [focusIf]=\"first\"\n            tabindex=\"0\"\n            (keydown.enter)=\"hierarchyBar.selectNode(child); popover.hide()\"\n            (click)=\"hierarchyBar.selectNode(child); popover.hide()\">\n\n            <!-- Show an icon if specifed -->\n            <img class=\"hierarchy-bar-node-icon\" *ngIf=\"child.icon\" [src]=\"child.icon\" alt=\"Hierarchy Bar Icon\">\n\n            <!-- Show the name of the current node -->\n            <span class=\"hierarchy-bar-node-title\">{{ child.title }}</span>\n\n        </li>\n\n    </ul>\n</ng-template>\n\n<!-- Template for the overflow popover list -->\n<ng-template #overflow let-popover=\"popover\">\n\n    <ul class=\"hierarchy-bar-node-list\">\n\n        <li *ngFor=\"let child of overflowNodes$ | async; let first = first\"\n            class=\"hierarchy-bar-node-list-item\"\n            tabindex=\"0\"\n            [focusIf]=\"first\"\n            (click)=\"hierarchyBar.selectNode(child); popover.hide()\"\n            (keydown.enter)=\"hierarchyBar.selectNode(child); popover.hide()\">\n\n            <!-- Show an icon if specifed -->\n            <img class=\"hierarchy-bar-node-icon\" *ngIf=\"child.icon\" [src]=\"child.icon\" alt=\"Hierarchy Bar Icon\">\n\n            <!-- Show the name of the current node -->\n            <span class=\"hierarchy-bar-node-title\">{{ child.title }}</span>\n\n        </li>\n\n    </ul>\n</ng-template>\n\n<!-- Loading Indicator Template -->\n<ng-template #defaultLoadingIndicator>\n    <div class=\"hierarchy-bar-node-icon\" alt=\"Hierarchy Bar Loading Indicator\">\n        <div class=\"spinner spinner-accent spinner-bounce-middle\"></div>\n    </div>\n\n    <!-- Show the name of the current node -->\n    <span class=\"hierarchy-bar-node-title\">Loading...</span>\n</ng-template>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        viewProviders: [HierarchyBarService]
                    }] }
        ];
        /** @nocollapse */
        HierarchyBarComponent.ctorParameters = function () {
            return [
                { type: HierarchyBarService }
            ];
        };
        HierarchyBarComponent.propDecorators = {
            root: [{ type: core.Input }],
            selected: [{ type: core.Input }],
            loadingIndicator: [{ type: core.Input }],
            selectedChange: [{ type: core.Output }],
            nodelist: [{ type: core.ViewChild, args: ['nodelist',] }],
            nodes: [{ type: core.ViewChildren, args: ['nodeElement',] }]
        };
        return HierarchyBarComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ClickOutsideDirective = (function () {
        function ClickOutsideDirective(_elementRef) {
            var _this = this;
            this._elementRef = _elementRef;
            this.uxClickOutside = new core.EventEmitter();
            /**
             * Often a click event makes the element appear - if so we can end up closing it immediately
             */
            this._initialised = false;
            setTimeout(function () { return _this._initialised = true; });
        }
        /**
         * @param {?} event
         * @return {?}
         */
        ClickOutsideDirective.prototype.click = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this._initialised && this._elementRef.nativeElement !== event.target && !this._elementRef.nativeElement.contains(event.target)) {
                    this.uxClickOutside.emit(event);
                }
            };
        ClickOutsideDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxClickOutside]'
                    },] }
        ];
        /** @nocollapse */
        ClickOutsideDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef }
            ];
        };
        ClickOutsideDirective.propDecorators = {
            uxClickOutside: [{ type: core.Output }],
            click: [{ type: core.HostListener, args: ['document:click', ['$event'],] }]
        };
        return ClickOutsideDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ClickOutsideModule = (function () {
        function ClickOutsideModule() {
        }
        ClickOutsideModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [ClickOutsideDirective],
                        declarations: [ClickOutsideDirective]
                    },] }
        ];
        return ClickOutsideModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ uniquePopoverId = 0;
    var PopoverComponent = (function (_super) {
        __extends(PopoverComponent, _super);
        function PopoverComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * Define a unique id for each popover
             */
            _this.id = "ux-popover-" + ++uniquePopoverId;
            /**
             * This will emit an event any time the user clicks outside the popover
             */
            _this.clickOutside$ = new Subject.Subject();
            return _this;
        }
        /** This will update the title of the popover and trigger change detection */
        /**
         * This will update the title of the popover and trigger change detection
         * @param {?} title
         * @return {?}
         */
        PopoverComponent.prototype.setTitle = /**
         * This will update the title of the popover and trigger change detection
         * @param {?} title
         * @return {?}
         */
            function (title) {
                this.title = title;
                this._changeDetectorRef.markForCheck();
            };
        PopoverComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-popover',
                        template: "<div class=\"popover show\" [ngClass]=\"[placement, customClass]\" [id]=\"id\" [attr.role]=\"role\" (uxClickOutside)=\"clickOutside$.next($event)\">\n    <div class=\"arrow\"></div>\n    <h3 class=\"popover-title\" *ngIf=\"title\">{{ title }}</h3>\n    <div class=\"popover-content\" (cdkObserveContent)=\"reposition()\">\n        <ng-container *ngIf=\"!isTemplateRef\">{{ content }}</ng-container>\n        <ng-container *ngIf=\"isTemplateRef\" [ngTemplateOutlet]=\"content\" [ngTemplateOutletContext]=\"context\"></ng-container>\n    </div>\n</div>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        return PopoverComponent;
    }(TooltipComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PopoverDirective = (function (_super) {
        __extends(PopoverDirective, _super);
        function PopoverDirective() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * All the user to add a custom class to the popover
             */
            _this.customClass = '';
            /**
             * All the user to add a role to the popover - default is tooltip
             */
            _this.role = 'tooltip';
            /**
             * Provide the TemplateRef a context object
             */
            _this.context = {};
            /**
             * Delay the showing of the popover by a number of miliseconds
             */
            _this.delay = 0;
            /**
             * Specify which events should show the popover
             */
            _this.showTriggers = ['click'];
            /**
             * Specify which events should hide the popover
             */
            _this.hideTriggers = ['click', 'clickoutside', 'escape'];
            /**
             * Keep track of the tooltip visibility and update aria-expanded attribute
             */
            _this.isVisible = false;
            /**
             * Internally store the type of this component - usual for distinctions when extending the tooltip class
             */
            _this._type = 'popover';
            return _this;
        }
        /** Set up the triggers and bind to the show/hide events to keep visibility in sync */
        /**
         * Set up the triggers and bind to the show/hide events to keep visibility in sync
         * @return {?}
         */
        PopoverDirective.prototype.ngOnInit = /**
         * Set up the triggers and bind to the show/hide events to keep visibility in sync
         * @return {?}
         */
            function () {
                // set up the event triggers
                fromEvent.fromEvent(document, 'keydown').pipe(operators.takeUntil(this._onDestroy)).subscribe(this.onKeyDown.bind(this));
                // check if there is an aria-described by attribute
                this._ariaDescribedBy = this._elementRef.nativeElement.hasAttribute('aria-describedby');
                // set up the default event triggers
                _super.prototype.ngOnInit.call(this);
            };
        /**
         * We need to send input changes to the popover component
         * We can't use setters as they may trigger before popover initialised and can't resend once initialised
         **/
        /**
         * We need to send input changes to the popover component
         * We can't use setters as they may trigger before popover initialised and can't resend once initialised
         *
         * @param {?} changes
         * @return {?}
         */
        PopoverDirective.prototype.ngOnChanges = /**
         * We need to send input changes to the popover component
         * We can't use setters as they may trigger before popover initialised and can't resend once initialised
         *
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                _super.prototype.ngOnChanges.call(this, changes);
                if (this._instance && changes["title"]) {
                    this._instance.setTitle(changes["title"].currentValue);
                }
            };
        /**
         * @param {?} overlayRef
         * @return {?}
         */
        PopoverDirective.prototype.createInstance = /**
         * @param {?} overlayRef
         * @return {?}
         */
            function (overlayRef) {
                var /** @type {?} */ instance = (overlayRef.attach(this._portal).instance);
                // supply the tooltip with the correct properties
                instance.setTitle(this.title);
                instance.setContent(this.content);
                instance.setPlacement(this.placement);
                instance.setClass(this.customClass);
                instance.setContext(this.context);
                instance.setRole(this.role);
                // Update the aria-describedby attribute
                this.setAriaDescribedBy(instance.id);
                // subscribe to the outside click event
                instance.clickOutside$.pipe(operators.takeUntil(this._onDestroy)).subscribe(this.onClickOutside.bind(this));
                return instance;
            };
        /**
         * @return {?}
         */
        PopoverDirective.prototype.createPortal = /**
         * @return {?}
         */
            function () {
                return this._portal || new portal.ComponentPortal(PopoverComponent, this._viewContainerRef);
            };
        /**
         * @param {?} event
         * @return {?}
         */
        PopoverDirective.prototype.onKeyDown = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // if visible and the escape key is pressed and it is one of the hide triggers
                if (this.isVisible && event.keyCode === keycodes.ESCAPE && this.includes(this.hideTriggers, 'escape')) {
                    this.hide();
                }
            };
        /**
         * @return {?}
         */
        PopoverDirective.prototype.onClickOutside = /**
         * @return {?}
         */
            function () {
                // if visible and it is one of the hide triggers
                if (this.isVisible && this.includes(this.hideTriggers, 'clickoutside')) {
                    this.hide();
                }
            };
        /** Programmatically update the aria-describedby property */
        /**
         * Programmatically update the aria-describedby property
         * @param {?} id
         * @return {?}
         */
        PopoverDirective.prototype.setAriaDescribedBy = /**
         * Programmatically update the aria-describedby property
         * @param {?} id
         * @return {?}
         */
            function (id) {
                // we only want to set the aria-describedby attr when the content is a string and there was no user defined attribute already
                if (this._ariaDescribedBy === false && typeof this.content === 'string') {
                    _super.prototype.setAriaDescribedBy.call(this, id);
                }
            };
        PopoverDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxPopover]',
                        exportAs: 'ux-popover'
                    },] }
        ];
        PopoverDirective.propDecorators = {
            content: [{ type: core.Input, args: ['uxPopover',] }],
            title: [{ type: core.Input, args: ['popoverTitle',] }],
            disabled: [{ type: core.Input, args: ['popoverDisabled',] }],
            customClass: [{ type: core.Input, args: ['popoverClass',] }],
            role: [{ type: core.Input, args: ['popoverRole',] }],
            context: [{ type: core.Input, args: ['popoverContext',] }],
            delay: [{ type: core.Input, args: ['popoverDelay',] }],
            showTriggers: [{ type: core.Input }],
            hideTriggers: [{ type: core.Input }],
            isVisible: [{ type: core.HostBinding, args: ['attr.aria-expanded',] }]
        };
        return PopoverDirective;
    }(TooltipDirective));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PopoverModule = (function () {
        function PopoverModule() {
        }
        PopoverModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            overlay.OverlayModule,
                            observers.ObserversModule,
                            ClickOutsideModule,
                            TooltipModule
                        ],
                        exports: [PopoverDirective],
                        declarations: [PopoverComponent, PopoverDirective],
                        entryComponents: [PopoverComponent]
                    },] }
        ];
        return PopoverModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var HierarchyBarModule = (function () {
        function HierarchyBarModule() {
        }
        HierarchyBarModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            ResizeModule,
                            FocusIfModule,
                            PopoverModule
                        ],
                        exports: [HierarchyBarComponent],
                        declarations: [HierarchyBarComponent],
                    },] }
        ];
        return HierarchyBarModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SidePanelService = (function () {
        function SidePanelService() {
            this.open$ = new BehaviorSubject.BehaviorSubject(false);
        }
        /**
         * @return {?}
         */
        SidePanelService.prototype.open = /**
         * @return {?}
         */
            function () {
                this.open$.next(true);
            };
        /**
         * @return {?}
         */
        SidePanelService.prototype.close = /**
         * @return {?}
         */
            function () {
                this.open$.next(false);
            };
        SidePanelService.decorators = [
            { type: core.Injectable }
        ];
        return SidePanelService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SidePanelComponent = (function () {
        function SidePanelComponent(service, _elementRef) {
            this.service = service;
            this._elementRef = _elementRef;
            this.inline = false;
            this.attachTo = 'window';
            this.width = '50%';
            this.top = '0';
            this.modal = false;
            this.animate = false;
            this.closeOnExternalClick = false;
            this.focusOnShow = false;
            this.openChange = new core.EventEmitter();
            this._onDestroy = new Subject.Subject();
        }
        Object.defineProperty(SidePanelComponent.prototype, "open", {
            get: /**
             * @return {?}
             */ function () {
                return this.service.open$.value;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.service.open$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SidePanelComponent.prototype, "position", {
            get: /**
             * @return {?}
             */ function () {
                if (this.inline) {
                    return 'static';
                }
                if (this.attachTo === 'container') {
                    return 'absolute';
                }
                return 'fixed';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SidePanelComponent.prototype, "cssWidth", {
            get: /**
             * @return {?}
             */ function () {
                if (typeof this.width === 'number') {
                    return this.width === 0 ? '0' : this.width + 'px';
                }
                return this.width;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SidePanelComponent.prototype, "cssTop", {
            get: /**
             * @return {?}
             */ function () {
                if (typeof this.top === 'number') {
                    return this.top === 0 ? '0' : this.top + 'px';
                }
                return this.top;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SidePanelComponent.prototype, "componentWidth", {
            get: /**
             * @return {?}
             */ function () {
                if (this.inline) {
                    return this.open ? this.cssWidth : '0';
                }
                return null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SidePanelComponent.prototype, "hostWidth", {
            get: /**
             * @return {?}
             */ function () {
                return this.inline ? '100%' : this.cssWidth;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        SidePanelComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.service.open$.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (isOpen) { return _this.openChange.emit(isOpen); });
            };
        /**
         * @return {?}
         */
        SidePanelComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @return {?}
         */
        SidePanelComponent.prototype.openPanel = /**
         * @return {?}
         */
            function () {
                this.service.open();
            };
        /**
         * @return {?}
         */
        SidePanelComponent.prototype.closePanel = /**
         * @return {?}
         */
            function () {
                this.service.close();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SidePanelComponent.prototype.clickHandler = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (!this.open || !this.closeOnExternalClick) {
                    return;
                }
                var /** @type {?} */ target = (event.target);
                if (!this._elementRef.nativeElement.contains(target) ||
                    (target && target.classList.contains('modal-backdrop'))) {
                    this.closePanel();
                }
            };
        SidePanelComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-side-panel',
                        exportAs: 'ux-side-panel',
                        template: "<div *ngIf=\"modal && open\" class=\"modal-backdrop\"\n    [style.position]=\"position\"\n    [style.top]=\"cssTop\"></div>\n\n<div class=\"ux-side-panel-host\"\n    [class.modal-panel]=\"modal\"\n    [style.position]=\"position\"\n    [style.width]=\"hostWidth\"\n    [style.top]=\"cssTop\"\n    [tabindex]=\"open ? 0 : -1\"\n    [focusIf]=\"open && focusOnShow\"\n    [focusIfScroll]=\"false\"\n    [cdkTrapFocus]=\"open && modal\">\n    <ng-content></ng-content>\n</div>\n",
                        providers: [SidePanelService],
                        host: {
                            'class': 'ux-side-panel'
                        }
                    }] }
        ];
        /** @nocollapse */
        SidePanelComponent.ctorParameters = function () {
            return [
                { type: SidePanelService },
                { type: core.ElementRef }
            ];
        };
        SidePanelComponent.propDecorators = {
            open: [{ type: core.Input }, { type: core.HostBinding, args: ['class.open',] }],
            inline: [{ type: core.Input }, { type: core.HostBinding, args: ['class.inline',] }],
            attachTo: [{ type: core.Input }],
            width: [{ type: core.Input }],
            top: [{ type: core.Input }],
            modal: [{ type: core.Input }, { type: core.HostBinding, args: ['attr.aria-modal',] }],
            animate: [{ type: core.Input }, { type: core.HostBinding, args: ['class.animate',] }],
            closeOnExternalClick: [{ type: core.Input }],
            focusOnShow: [{ type: core.Input }],
            openChange: [{ type: core.Output }],
            componentWidth: [{ type: core.HostBinding, args: ['style.width',] }],
            closePanel: [{ type: core.HostListener, args: ['document:keyup.escape',] }],
            clickHandler: [{ type: core.HostListener, args: ['document:click', ['$event'],] }]
        };
        return SidePanelComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ItemDisplayPanelContentDirective = (function () {
        function ItemDisplayPanelContentDirective() {
        }
        ItemDisplayPanelContentDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxItemDisplayPanelContent]'
                    },] }
        ];
        return ItemDisplayPanelContentDirective;
    }());
    var ItemDisplayPanelFooterDirective = (function () {
        function ItemDisplayPanelFooterDirective() {
        }
        ItemDisplayPanelFooterDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxItemDisplayPanelFooter]'
                    },] }
        ];
        return ItemDisplayPanelFooterDirective;
    }());
    var ItemDisplayPanelComponent = (function (_super) {
        __extends(ItemDisplayPanelComponent, _super);
        function ItemDisplayPanelComponent(service, elementRef) {
            var _this = _super.call(this, service, elementRef) || this;
            _this.boxShadow = true;
            _this.closeVisible = true;
            _this.shadow = false;
            _this.visibleChange = new core.EventEmitter();
            _this.animate = false;
            _this.closeOnExternalClick = true;
            return _this;
        }
        Object.defineProperty(ItemDisplayPanelComponent.prototype, "preventClose", {
            get: /**
             * @return {?}
             */ function () {
                return !this.closeOnExternalClick;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.closeOnExternalClick = !value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ItemDisplayPanelComponent.prototype, "title", {
            get: /**
             * @return {?}
             */ function () {
                return this.header;
            },
            /**
             * @deprecated
             * Title used for adding tooltips and shouldn't be used as an input
             * instead header will be used. This is here to support backward compatibility only
             * this property should not be used.
             */
            set: /**
             * @deprecated
             * Title used for adding tooltips and shouldn't be used as an input
             * instead header will be used. This is here to support backward compatibility only
             * this property should not be used.
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.header = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ItemDisplayPanelComponent.prototype, "visible", {
            get: /**
             * @return {?}
             */ function () {
                return this.open;
            },
            set: /**
             * @param {?} visible
             * @return {?}
             */ function (visible) {
                this.open = visible;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ItemDisplayPanelComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.service.open$.pipe(operators.distinctUntilChanged(), operators.takeUntil(this._onDestroy)).subscribe(function (isVisible) { return _this.visibleChange.emit(isVisible); });
            };
        /**
         * @return {?}
         */
        ItemDisplayPanelComponent.prototype.focus = /**
         * @return {?}
         */
            function () {
                if (this.panel) {
                    this.panel.nativeElement.focus();
                }
            };
        ItemDisplayPanelComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-item-display-panel',
                        template: "<div class=\"ux-side-panel-host ux-item-display-panel\" #panel\n    [class.box-shadow]=\"boxShadow\"\n    [style.position]=\"position\"\n    [style.width]=\"hostWidth\"\n    [style.top]=\"cssTop\"\n    [tabindex]=\"open ? 0 : -1\"\n    [focusIf]=\"open && focusOnShow\">\n\n    <div class=\"ux-side-panel-header\" [class.item-display-panel-shadow]=\"shadow\">\n        <h3>{{ header }}</h3>\n        <button *ngIf=\"closeVisible\" aria-label=\"Close\" i18n-aria-label type=\"button\" class=\"btn btn-lg btn-link btn-icon button-secondary\" (click)=\"visible = false\">\n            <i class=\"hpe-icon hpe-close\"></i>\n        </button>\n    </div>\n\n    <div class=\"ux-side-panel-content\">\n        <ng-content select=\"[uxItemDisplayPanelContent]\"></ng-content>\n    </div>\n\n    <div class=\"ux-side-panel-footer\" *ngIf=\"footer\">\n        <ng-content select=\"[uxItemDisplayPanelFooter]\"></ng-content>\n    </div>\n\n</div>\n",
                        providers: [SidePanelService],
                        host: {
                            'class': 'ux-side-panel ux-item-display-panel'
                        }
                    }] }
        ];
        /** @nocollapse */
        ItemDisplayPanelComponent.ctorParameters = function () {
            return [
                { type: SidePanelService },
                { type: core.ElementRef }
            ];
        };
        ItemDisplayPanelComponent.propDecorators = {
            header: [{ type: core.Input }],
            boxShadow: [{ type: core.Input }],
            closeVisible: [{ type: core.Input }],
            preventClose: [{ type: core.Input }],
            shadow: [{ type: core.Input }],
            visibleChange: [{ type: core.Output }],
            footer: [{ type: core.ContentChild, args: [ItemDisplayPanelFooterDirective,] }],
            panel: [{ type: core.ViewChild, args: ['panel',] }],
            title: [{ type: core.Input }],
            visible: [{ type: core.Input }]
        };
        return ItemDisplayPanelComponent;
    }(SidePanelComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ DECLARATIONS$3 = [
        ItemDisplayPanelComponent,
        ItemDisplayPanelContentDirective,
        ItemDisplayPanelFooterDirective
    ];
    var ItemDisplayPanelModule = (function () {
        function ItemDisplayPanelModule() {
        }
        ItemDisplayPanelModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            FocusIfModule
                        ],
                        exports: DECLARATIONS$3,
                        declarations: DECLARATIONS$3
                    },] }
        ];
        return ItemDisplayPanelModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var WizardStepComponent = (function () {
        function WizardStepComponent() {
            this.valid = true;
            this.visitedChange = new core.EventEmitter();
            this._active = false;
            this._visited = false;
        }
        Object.defineProperty(WizardStepComponent.prototype, "visited", {
            get: /**
             * @return {?}
             */ function () {
                return this._visited;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._visited = value;
                this.visitedChange.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(WizardStepComponent.prototype, "active", {
            get: /**
             * @return {?}
             */ function () {
                return this._active;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                // store the active state of the step
                this._active = value;
                // if the value is true then the step should also be marked as visited
                if (value === true) {
                    this.visited = true;
                }
            },
            enumerable: true,
            configurable: true
        });
        WizardStepComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-wizard-step',
                        template: "<ng-container *ngIf=\"active\">\n    <ng-content></ng-content>\n</ng-container>"
                    }] }
        ];
        WizardStepComponent.propDecorators = {
            header: [{ type: core.Input }],
            valid: [{ type: core.Input }],
            visitedChange: [{ type: core.Input }],
            visited: [{ type: core.Input }]
        };
        return WizardStepComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var WizardComponent = (function () {
        function WizardComponent() {
            this._step = 0;
            this.steps = new core.QueryList();
            this.orientation = 'horizontal';
            this.nextText = 'Next';
            this.previousText = 'Previous';
            this.cancelText = 'Cancel';
            this.finishText = 'Finish';
            this.nextTooltip = 'Go to the next step';
            this.previousTooltip = 'Go to the previous step';
            this.cancelTooltip = 'Cancel the wizard';
            this.finishTooltip = 'Finish the wizard';
            this.nextDisabled = false;
            this.previousDisabled = false;
            this.cancelDisabled = false;
            this.finishDisabled = false;
            this.nextVisible = true;
            this.previousVisible = true;
            this.cancelVisible = true;
            this.finishVisible = true;
            this.cancelAlwaysVisible = false;
            this.finishAlwaysVisible = false;
            this.onNext = new core.EventEmitter();
            this.onPrevious = new core.EventEmitter();
            this.onCancel = new core.EventEmitter();
            this.onFinishing = new core.EventEmitter();
            this.onFinish = new core.EventEmitter();
            this.stepChanging = new core.EventEmitter();
            this.stepChange = new core.EventEmitter();
            this.invalidIndicator = false;
        }
        Object.defineProperty(WizardComponent.prototype, "step", {
            get: /**
             * @return {?}
             */ function () {
                return this._step;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                // only accept numbers as valid options
                if (typeof value === 'number') {
                    // store the active step
                    this._step = value;
                    // update which steps should be active
                    this.update();
                    // emit the change event
                    this.stepChange.next(this.step);
                    // reset the invalid state
                    this.invalidIndicator = false;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        WizardComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                // initially set the correct visibility of the steps
                setTimeout(this.update.bind(this));
            };
        /**
         * Navigate to the next step
         */
        /**
         * Navigate to the next step
         * @return {?}
         */
        WizardComponent.prototype.next = /**
         * Navigate to the next step
         * @return {?}
         */
            function () {
                this.stepChanging.next(new StepChangingEvent(this.step, this.step + 1));
                // check if current step is invalid
                if (!this.getCurrentStep().valid) {
                    this.invalidIndicator = true;
                    return;
                }
                // check if we are currently on the last step
                if ((this.step + 1) < this.steps.length) {
                    this.step++;
                    // emit the current step
                    this.onNext.next(this.step);
                }
            };
        /**
         * Navigate to the previous step
         */
        /**
         * Navigate to the previous step
         * @return {?}
         */
        WizardComponent.prototype.previous = /**
         * Navigate to the previous step
         * @return {?}
         */
            function () {
                this.stepChanging.next(new StepChangingEvent(this.step, this.step - 1));
                // check if we are currently on the last step
                if (this.step > 0) {
                    this.step--;
                    // emit the current step
                    this.onPrevious.next(this.step);
                }
            };
        /**
         * Perform actions when the finish button is clicked
         */
        /**
         * Perform actions when the finish button is clicked
         * @return {?}
         */
        WizardComponent.prototype.finish = /**
         * Perform actions when the finish button is clicked
         * @return {?}
         */
            function () {
                var _this = this;
                // fires when the finish button is clicked always
                this.onFinishing.next();
                /**
                         * This is required because we need to ensure change detection has run
                         * to determine whether or not we have the latest value for the 'valid' input
                         * on the current step. Unfortunately we can't use ChangeDetectorRef as we are looking to run
                         * on content children, and we cant use ApplicationRef.tick() as this does not work in a hybrid app, eg. our docs
                         */
                return new Promise(function (resolve) {
                    setTimeout(function () {
                        // only fires when the finish button is clicked and the step is valid
                        if (_this.getCurrentStep().valid) {
                            _this.onFinish.next();
                        }
                        resolve();
                    });
                });
            };
        /**
         * Perform actions when the cancel button is clicked
         */
        /**
         * Perform actions when the cancel button is clicked
         * @return {?}
         */
        WizardComponent.prototype.cancel = /**
         * Perform actions when the cancel button is clicked
         * @return {?}
         */
            function () {
                this.onCancel.next();
            };
        /**
         * Update the active state of each step
         */
        /**
         * Update the active state of each step
         * @return {?}
         */
        WizardComponent.prototype.update = /**
         * Update the active state of each step
         * @return {?}
         */
            function () {
                var _this = this;
                // update which steps should be active
                this.steps.forEach(function (step, idx) { return step.active = idx === _this.step; });
            };
        /**
         * Jump to a specific step only if the step has previously been visited
         */
        /**
         * Jump to a specific step only if the step has previously been visited
         * @param {?} step
         * @return {?}
         */
        WizardComponent.prototype.gotoStep = /**
         * Jump to a specific step only if the step has previously been visited
         * @param {?} step
         * @return {?}
         */
            function (step) {
                if (step.visited) {
                    var /** @type {?} */ stepIndex = this.steps.toArray().findIndex(function (stp) { return stp === step; });
                    this.stepChanging.next(new StepChangingEvent(this.step, stepIndex));
                    this.step = stepIndex;
                }
            };
        /**
         * Determine if the current step is the last step
         */
        /**
         * Determine if the current step is the last step
         * @return {?}
         */
        WizardComponent.prototype.isLastStep = /**
         * Determine if the current step is the last step
         * @return {?}
         */
            function () {
                return this.step === (this.steps.length - 1);
            };
        /**
         * Reset the wizard - goes to first step and resets visited state
         */
        /**
         * Reset the wizard - goes to first step and resets visited state
         * @return {?}
         */
        WizardComponent.prototype.reset = /**
         * Reset the wizard - goes to first step and resets visited state
         * @return {?}
         */
            function () {
                // mark all steps as not visited
                this.steps.forEach(function (step) { return step.visited = false; });
                // go to the first step
                this.step = 0;
            };
        /**
         * Get the step at the current index
         */
        /**
         * Get the step at the current index
         * @return {?}
         */
        WizardComponent.prototype.getCurrentStep = /**
         * Get the step at the current index
         * @return {?}
         */
            function () {
                return this.getStepAtIndex(this.step);
            };
        /**
         * Return a step at a specific index
         */
        /**
         * Return a step at a specific index
         * @param {?} index
         * @return {?}
         */
        WizardComponent.prototype.getStepAtIndex = /**
         * Return a step at a specific index
         * @param {?} index
         * @return {?}
         */
            function (index) {
                return this.steps.toArray()[index];
            };
        WizardComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-wizard',
                        template: "<div class=\"wizard-body\">\n\n    <div class=\"wizard-steps\">\n\n        <div class=\"wizard-step\" [class.active]=\"stp.active\" [class.visited]=\"stp.visited\" [class.invalid]=\"stp.active && !stp.valid && invalidIndicator\" (click)=\"gotoStep(stp)\" *ngFor=\"let stp of steps\">\n            {{ stp.header }}\n        </div>\n\n    </div>\n\n    <div class=\"wizard-content\">\n        <ng-content></ng-content>\n    </div>\n\n</div>\n\n<div class=\"wizard-footer\">\n    <button #tip=\"ux-tooltip\" class=\"btn button-secondary\" *ngIf=\"previousVisible\" [uxTooltip]=\"previousTooltip\" [disabled]=\"previousDisabled || step === 0\"\n        (click)=\"previous(); tip.hide()\">{{ previousText }}</button>\n\n    <button #tip=\"ux-tooltip\" class=\"btn button-primary\" *ngIf=\"nextVisible && !isLastStep()\" [uxTooltip]=\"nextTooltip\" [disabled]=\"nextDisabled\"\n        (click)=\"next(); tip.hide()\">{{ nextText }}</button>\n\n    <button #tip=\"ux-tooltip\" class=\"btn button-primary\" *ngIf=\"finishVisible && isLastStep() || finishAlwaysVisible\" [uxTooltip]=\"finishTooltip\"\n        [disabled]=\"finishDisabled\" (click)=\"finish(); tip.hide()\">{{ finishText }}</button>\n\n    <button #tip=\"ux-tooltip\" class=\"btn button-secondary\" *ngIf=\"cancelVisible && !isLastStep() || cancelAlwaysVisible\" [uxTooltip]=\"cancelTooltip\"\n        [disabled]=\"cancelDisabled\" (click)=\"cancel(); tip.hide()\">{{ cancelText }}</button>\n</div>",
                        host: {
                            '[class]': 'orientation'
                        }
                    }] }
        ];
        WizardComponent.propDecorators = {
            steps: [{ type: core.ContentChildren, args: [WizardStepComponent,] }],
            orientation: [{ type: core.Input }],
            nextText: [{ type: core.Input }],
            previousText: [{ type: core.Input }],
            cancelText: [{ type: core.Input }],
            finishText: [{ type: core.Input }],
            nextTooltip: [{ type: core.Input }],
            previousTooltip: [{ type: core.Input }],
            cancelTooltip: [{ type: core.Input }],
            finishTooltip: [{ type: core.Input }],
            nextDisabled: [{ type: core.Input }],
            previousDisabled: [{ type: core.Input }],
            cancelDisabled: [{ type: core.Input }],
            finishDisabled: [{ type: core.Input }],
            nextVisible: [{ type: core.Input }],
            previousVisible: [{ type: core.Input }],
            cancelVisible: [{ type: core.Input }],
            finishVisible: [{ type: core.Input }],
            cancelAlwaysVisible: [{ type: core.Input }],
            finishAlwaysVisible: [{ type: core.Input }],
            onNext: [{ type: core.Output }],
            onPrevious: [{ type: core.Output }],
            onCancel: [{ type: core.Output }],
            onFinishing: [{ type: core.Output }],
            onFinish: [{ type: core.Output }],
            stepChanging: [{ type: core.Output }],
            stepChange: [{ type: core.Output }],
            step: [{ type: core.Input }]
        };
        return WizardComponent;
    }());
    var StepChangingEvent = (function () {
        function StepChangingEvent(from$$1, to) {
            this.from = from$$1;
            this.to = to;
        }
        return StepChangingEvent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ DECLARATIONS$4 = [
        WizardComponent,
        WizardStepComponent
    ];
    var WizardModule = (function () {
        function WizardModule() {
        }
        WizardModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            TooltipModule
                        ],
                        exports: DECLARATIONS$4,
                        declarations: DECLARATIONS$4
                    },] }
        ];
        return WizardModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * This service is required to provide a form of communication
     * between the marquee wizard steps and the containing marquee wizard.
     * We cannot inject the Host due to the steps being content children
     * rather than view children.
     */
    var MarqueeWizardService = (function () {
        function MarqueeWizardService() {
            this.valid$ = new Subject.Subject();
        }
        MarqueeWizardService.decorators = [
            { type: core.Injectable }
        ];
        return MarqueeWizardService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MarqueeWizardStepComponent = (function (_super) {
        __extends(MarqueeWizardStepComponent, _super);
        function MarqueeWizardStepComponent(_marqueeWizardService) {
            var _this = _super.call(this) || this;
            _this._marqueeWizardService = _marqueeWizardService;
            _this.completed = false;
            _this.completedChange = new core.EventEmitter();
            _this._valid = true;
            return _this;
        }
        Object.defineProperty(MarqueeWizardStepComponent.prototype, "valid", {
            get: /**
             * @return {?}
             */ function () {
                return this._valid;
            },
            set: /**
             * @param {?} valid
             * @return {?}
             */ function (valid) {
                this._valid = valid;
                if (this._marqueeWizardService) {
                    this._marqueeWizardService.valid$.next({ step: this, valid: valid });
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Update the completed state and emit the latest value
         * @param completed whether or not the step is completed
         */
        /**
         * Update the completed state and emit the latest value
         * @param {?} completed whether or not the step is completed
         * @return {?}
         */
        MarqueeWizardStepComponent.prototype.setCompleted = /**
         * Update the completed state and emit the latest value
         * @param {?} completed whether or not the step is completed
         * @return {?}
         */
            function (completed) {
                this.completed = completed;
                this.completedChange.emit(completed);
            };
        MarqueeWizardStepComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-marquee-wizard-step',
                        template: "<ng-container *ngIf=\"active\">\n    <ng-content></ng-content>\n</ng-container>"
                    }] }
        ];
        /** @nocollapse */
        MarqueeWizardStepComponent.ctorParameters = function () {
            return [
                { type: MarqueeWizardService }
            ];
        };
        MarqueeWizardStepComponent.propDecorators = {
            icon: [{ type: core.Input }],
            completed: [{ type: core.Input }],
            completedChange: [{ type: core.Output }]
        };
        return MarqueeWizardStepComponent;
    }(WizardStepComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MarqueeWizardComponent = (function (_super) {
        __extends(MarqueeWizardComponent, _super);
        function MarqueeWizardComponent(marqueeWizardService) {
            var _this = _super.call(this) || this;
            _this.steps = new core.QueryList();
            marqueeWizardService.valid$.pipe(operators.filter(function (event) { return !event.valid; })).subscribe(_this.validChange.bind(_this));
            return _this;
        }
        Object.defineProperty(MarqueeWizardComponent.prototype, "isTemplate", {
            get: /**
             * @return {?}
             */ function () {
                return this.description && this.description instanceof core.TemplateRef;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * If the current step is valid, mark it as
         * complete and go to the next step
         */
        /**
         * If the current step is valid, mark it as
         * complete and go to the next step
         * @return {?}
         */
        MarqueeWizardComponent.prototype.next = /**
         * If the current step is valid, mark it as
         * complete and go to the next step
         * @return {?}
         */
            function () {
                // get the current step
                var /** @type {?} */ step = (this.getCurrentStep());
                if (step.valid) {
                    _super.prototype.next.call(this);
                    // mark this step as completed
                    step.setCompleted(true);
                }
            };
        /**
         * Emit the onFinishing event and if valid the onFinish event.
         * Also mark the final step as completed if it is valid
         */
        /**
         * Emit the onFinishing event and if valid the onFinish event.
         * Also mark the final step as completed if it is valid
         * @return {?}
         */
        MarqueeWizardComponent.prototype.finish = /**
         * Emit the onFinishing event and if valid the onFinish event.
         * Also mark the final step as completed if it is valid
         * @return {?}
         */
            function () {
                // get the current step
                var /** @type {?} */ step = (this.getCurrentStep());
                // call the original finish function
                return _super.prototype.finish.call(this).then(function () {
                    // if the step is valid indicate that it is now complete
                    if (step.valid) {
                        step.setCompleted(true);
                    }
                });
            };
        /**
         * If a step in the wizard becomes invalid, all steps sequentially after
         * it, should become unvisited and incomplete
         */
        /**
         * If a step in the wizard becomes invalid, all steps sequentially after
         * it, should become unvisited and incomplete
         * @param {?} state
         * @return {?}
         */
        MarqueeWizardComponent.prototype.validChange = /**
         * If a step in the wizard becomes invalid, all steps sequentially after
         * it, should become unvisited and incomplete
         * @param {?} state
         * @return {?}
         */
            function (state) {
                var /** @type {?} */ steps = this.steps.toArray();
                var /** @type {?} */ current = steps.findIndex(function (step) { return step === state.step; });
                var /** @type {?} */ affected = steps.slice(current);
                affected.forEach(function (step) {
                    // the step should no longer be completed
                    step.completed = false;
                    // if the step is not the current step then also mark it as unvisited
                    if (step !== state.step) {
                        step.visited = false;
                    }
                });
            };
        MarqueeWizardComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-marquee-wizard',
                        template: "<div class=\"marquee-wizard-side-panel\">\n\n    <div class=\"marquee-wizard-description-container\" *ngIf=\"description\">\n        <!-- If a template was provided display it -->\n        <ng-container *ngIf=\"isTemplate\" [ngTemplateOutlet]=\"description\"></ng-container>\n\n        <!-- Otherwise wimply display the string -->\n        <ng-container *ngIf=\"!isTemplate\">\n            <p>{{ description }}</p>\n        </ng-container>\n    </div>\n\n    <ul class=\"marquee-wizard-steps\">\n\n        <li class=\"marquee-wizard-step\" *ngFor=\"let step of steps\" (click)=\"gotoStep(step)\" [class.active]=\"step.active\" [class.visited]=\"step.visited\" [class.invalid]=\"!step.valid\">\n            <i class=\"marquee-wizard-step-icon\" [ngClass]=\"step.icon\"></i>\n            <span class=\"marquee-wizard-step-title\">{{ step.header }}</span>\n            <span class=\"marquee-wizard-step-status hpe-icon hpe-checkmark\" *ngIf=\"step.completed\"></span>\n        </li>\n\n    </ul>\n</div>\n\n<div class=\"marquee-wizard-content-panel\">\n    <div class=\"marquee-wizard-content\">\n        <ng-content></ng-content>\n    </div>\n\n    <div class=\"modal-footer\">\n\n        <button #tip=\"ux-tooltip\" class=\"btn button-secondary\" *ngIf=\"previousVisible\" [uxTooltip]=\"previousTooltip\" container=\"body\"\n            [disabled]=\"previousDisabled || step === 0\" (click)=\"previous(); tip.hide()\">{{ previousText }}</button>\n\n        <button #tip=\"ux-tooltip\" class=\"btn button-primary\" *ngIf=\"nextVisible && !isLastStep()\" [uxTooltip]=\"nextTooltip\" container=\"body\"\n            [disabled]=\"nextDisabled\" (click)=\"next(); tip.hide()\">{{ nextText }}</button>\n\n        <button #tip=\"ux-tooltip\" class=\"btn button-primary\" *ngIf=\"finishVisible && isLastStep() || finishAlwaysVisible\" [uxTooltip]=\"finishTooltip\"\n            container=\"body\" [disabled]=\"finishDisabled\" (click)=\"finish(); tip.hide()\">{{ finishText }}</button>\n\n        <button #tip=\"ux-tooltip\" class=\"btn button-secondary\" *ngIf=\"cancelVisible && !isLastStep() || cancelAlwaysVisible\" [uxTooltip]=\"cancelTooltip\"\n            container=\"body\" [disabled]=\"cancelDisabled\" (click)=\"cancel(); tip.hide()\">{{ cancelText }}</button>\n    </div>\n</div>",
                        providers: [MarqueeWizardService]
                    }] }
        ];
        /** @nocollapse */
        MarqueeWizardComponent.ctorParameters = function () {
            return [
                { type: MarqueeWizardService }
            ];
        };
        MarqueeWizardComponent.propDecorators = {
            description: [{ type: core.Input }],
            steps: [{ type: core.ContentChildren, args: [MarqueeWizardStepComponent,] }]
        };
        return MarqueeWizardComponent;
    }(WizardComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MarqueeWizardModule = (function () {
        function MarqueeWizardModule() {
        }
        MarqueeWizardModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            WizardModule,
                            TooltipModule
                        ],
                        exports: [
                            MarqueeWizardComponent,
                            MarqueeWizardStepComponent
                        ],
                        declarations: [
                            MarqueeWizardComponent,
                            MarqueeWizardStepComponent
                        ]
                    },] }
        ];
        return MarqueeWizardModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FrameExtractionService = (function () {
        function FrameExtractionService() {
        }
        /**
         * @param {?} source
         * @return {?}
         */
        FrameExtractionService.prototype.createVideoPlayer = /**
         * @param {?} source
         * @return {?}
         */
            function (source) {
                var /** @type {?} */ videoPlayer = document.createElement('video');
                videoPlayer.preload = 'auto';
                videoPlayer.src = source;
                return videoPlayer;
            };
        /**
         * @param {?} width
         * @param {?} height
         * @return {?}
         */
        FrameExtractionService.prototype.createCanvas = /**
         * @param {?} width
         * @param {?} height
         * @return {?}
         */
            function (width, height) {
                var /** @type {?} */ canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                return canvas;
            };
        /**
         * @param {?} videoPlayer
         * @param {?} time
         * @return {?}
         */
        FrameExtractionService.prototype.goToFrame = /**
         * @param {?} videoPlayer
         * @param {?} time
         * @return {?}
         */
            function (videoPlayer, time) {
                videoPlayer.currentTime = time;
                return fromEvent.fromEvent(videoPlayer, time === 0 ? 'loadeddata' : 'seeked');
            };
        /**
         * @param {?} videoPlayer
         * @param {?} canvas
         * @param {?} time
         * @param {?=} width
         * @param {?=} height
         * @return {?}
         */
        FrameExtractionService.prototype.getThumbnail = /**
         * @param {?} videoPlayer
         * @param {?} canvas
         * @param {?} time
         * @param {?=} width
         * @param {?=} height
         * @return {?}
         */
            function (videoPlayer, canvas, time, width, height) {
                var _this = this;
                if (width === void 0) {
                    width = 160;
                }
                if (height === void 0) {
                    height = 90;
                }
                return Observable.Observable.create(function (observer) {
                    // go to specified frame
                    var /** @type {?} */ subscription = _this.goToFrame(videoPlayer, time).subscribe(function () {
                        // create image from current frame
                        canvas.getContext('2d').drawImage(videoPlayer, 0, 0, width, height);
                        observer.next({ image: canvas.toDataURL(), width: width, height: height, time: time });
                        observer.complete();
                        subscription.unsubscribe();
                    });
                });
            };
        /**
         * @param {?} source
         * @param {?} width
         * @param {?} height
         * @param {?} time
         * @return {?}
         */
        FrameExtractionService.prototype.getFrameThumbnail = /**
         * @param {?} source
         * @param {?} width
         * @param {?} height
         * @param {?} time
         * @return {?}
         */
            function (source, width, height, time) {
                // create required elements
                var /** @type {?} */ videoPlayer = this.createVideoPlayer(source);
                var /** @type {?} */ canvas = this.createCanvas(width, height);
                var /** @type {?} */ frameSubscription = this.getThumbnail(videoPlayer, canvas, time, width, height);
                // ensure we release memory after we are finished
                frameSubscription.subscribe(null, null, function () {
                    videoPlayer = null;
                    canvas = null;
                });
                return frameSubscription;
            };
        /**
         * @param {?} source
         * @param {?} width
         * @param {?} height
         * @param {?} start
         * @param {?} end
         * @param {?=} skip
         * @return {?}
         */
        FrameExtractionService.prototype.getFrameThumbnails = /**
         * @param {?} source
         * @param {?} width
         * @param {?} height
         * @param {?} start
         * @param {?} end
         * @param {?=} skip
         * @return {?}
         */
            function (source, width, height, start, end, skip) {
                var _this = this;
                if (skip === void 0) {
                    skip = 5;
                }
                // create required elements
                var /** @type {?} */ videoPlayer = this.createVideoPlayer(source);
                var /** @type {?} */ canvas = this.createCanvas(width, height);
                return Observable.Observable.create(function (observer) {
                    fromEvent.fromEvent(videoPlayer, 'loadedmetadata').subscribe(function () {
                        // calculate the frames required
                        var /** @type {?} */ frames = [];
                        for (var /** @type {?} */ idx = start; idx < end; idx += skip) {
                            frames.push(_this.getThumbnail(videoPlayer, canvas, idx, width, height));
                        }
                        concat.concat.apply(void 0, __spread(frames)).subscribe(function (frame) { return observer.next(frame); }, null, function () {
                            videoPlayer = null;
                            canvas = null;
                            observer.complete();
                        });
                    });
                });
            };
        FrameExtractionService.decorators = [
            { type: core.Injectable }
        ];
        return FrameExtractionService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FrameExtractionModule = (function () {
        function FrameExtractionModule() {
        }
        FrameExtractionModule.decorators = [
            { type: core.NgModule, args: [{
                        providers: [FrameExtractionService],
                    },] }
        ];
        return FrameExtractionModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MediaPlayerService = (function () {
        function MediaPlayerService(_frameExtractionService) {
            var _this = this;
            this._frameExtractionService = _frameExtractionService;
            this.type = 'video';
            this.loaded = false;
            /*
                    Create observables for media player events
                */
            this.playing = new BehaviorSubject.BehaviorSubject(false);
            this.initEvent = new ReplaySubject.ReplaySubject();
            this.abortEvent = new Subject.Subject();
            this.canPlayEvent = new BehaviorSubject.BehaviorSubject(false);
            this.canPlayThroughEvent = new BehaviorSubject.BehaviorSubject(false);
            this.durationChangeEvent = new Subject.Subject();
            this.endedEvent = new Subject.Subject();
            this.errorEvent = new Subject.Subject();
            this.loadedDataEvent = new Subject.Subject();
            this.loadedMetadataEvent = new Subject.Subject();
            this.loadStartEvent = new Subject.Subject();
            this.pauseEvent = new Subject.Subject();
            this.playEvent = new Subject.Subject();
            this.playingEvent = new Subject.Subject();
            this.rateChangeEvent = new Subject.Subject();
            this.seekedEvent = new Subject.Subject();
            this.seekingEvent = new Subject.Subject();
            this.stalledEvent = new Subject.Subject();
            this.suspendEvent = new Subject.Subject();
            this.timeUpdateEvent = new Subject.Subject();
            this.volumeChangeEvent = new Subject.Subject();
            this.waitingEvent = new Subject.Subject();
            this.mediaClickEvent = new Subject.Subject();
            this.fullscreenEvent = new BehaviorSubject.BehaviorSubject(false);
            this.quietModeEvent = new BehaviorSubject.BehaviorSubject(false);
            this.progressEvent = Observable.Observable.create(function (observer) {
                // repeat until the whole video has fully loaded
                var /** @type {?} */ interval = setInterval(function () {
                    var /** @type {?} */ buffered = (_this._mediaPlayer.buffered);
                    observer.next(buffered);
                    if (buffered.length === 1 && buffered.start(0) === 0 && buffered.end(0) === _this.duration) {
                        observer.complete();
                        clearInterval(interval);
                    }
                }, 1000);
            });
            this._fullscreen = false;
        }
        Object.defineProperty(MediaPlayerService.prototype, "mediaPlayer", {
            /*
                Create all the getters and setters the can be used by media player extensions
            */
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "quietMode", {
            get: /**
             * @return {?}
             */ function () {
                return this._quietMode;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                // quiet mode cannot be enabled on audio player
                if (this.type === 'audio') {
                    value = false;
                }
                this._quietMode = value;
                this.quietModeEvent.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "mediaPlayerWidth", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.offsetWidth : 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "mediaPlayerHeight", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.offsetHeight : 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "audioTracks", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.audioTracks : [];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "autoplay", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.autoplay : false;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._mediaPlayer.autoplay = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "buffered", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.buffered : new TimeRanges();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "crossOrigin", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.crossOrigin : null;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._mediaPlayer.crossOrigin = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "currentSrc", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.currentSrc : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "currentTime", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.currentTime : 0;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._mediaPlayer.currentTime = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "defaultMuted", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.defaultMuted : false;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._mediaPlayer.defaultMuted = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "defaultPlaybackRate", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.defaultPlaybackRate : 1;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._mediaPlayer.defaultPlaybackRate = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "duration", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.duration : 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "ended", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.ended : false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "loop", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.loop : false;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._mediaPlayer.loop = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "muted", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.muted : false;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._mediaPlayer.muted = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "networkState", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer.networkState;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "paused", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.paused : true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "playbackRate", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.playbackRate : 1;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._mediaPlayer.playbackRate = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "played", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.played : new TimeRanges();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "preload", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.preload : 'auto';
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._mediaPlayer.preload = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "readyState", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.readyState : 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "seekable", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.seekable : new TimeRanges();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "seeking", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.seeking : false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "src", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.src : '';
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._mediaPlayer.src = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "textTracks", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? Array.from(this._mediaPlayer.textTracks) : [];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "videoTracks", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? Array.from(this._mediaPlayer.videoTracks) : [];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "volume", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._mediaPlayer.volume : 1;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (this._mediaPlayer) {
                    this._mediaPlayer.volume = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerService.prototype, "fullscreen", {
            get: /**
             * @return {?}
             */ function () {
                return this._mediaPlayer ? this._fullscreen : false;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._fullscreen = value;
                this.fullscreenEvent.next(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} hostElement
         * @param {?} mediaPlayer
         * @return {?}
         */
        MediaPlayerService.prototype.setMediaPlayer = /**
         * @param {?} hostElement
         * @param {?} mediaPlayer
         * @return {?}
         */
            function (hostElement, mediaPlayer) {
                this._hostElement = hostElement;
                this._mediaPlayer = mediaPlayer;
                this.initEvent.next(true);
            };
        /**
         * Toggle playing state
         */
        /**
         * Toggle playing state
         * @return {?}
         */
        MediaPlayerService.prototype.togglePlay = /**
         * Toggle playing state
         * @return {?}
         */
            function () {
                // prevent any action is not loaded
                if (this.loaded === false) {
                    return;
                }
                if (this.paused) {
                    this.play();
                }
                else {
                    this.pause();
                }
            };
        /**
         * Starts playing the audio/video
         */
        /**
         * Starts playing the audio/video
         * @return {?}
         */
        MediaPlayerService.prototype.play = /**
         * Starts playing the audio/video
         * @return {?}
         */
            function () {
                this._mediaPlayer.play();
            };
        /**
         * Pauses the currently playing audio/video
         */
        /**
         * Pauses the currently playing audio/video
         * @return {?}
         */
        MediaPlayerService.prototype.pause = /**
         * Pauses the currently playing audio/video
         * @return {?}
         */
            function () {
                this._mediaPlayer.pause();
            };
        /**
         * Re-loads the audio/video element
         */
        /**
         * Re-loads the audio/video element
         * @return {?}
         */
        MediaPlayerService.prototype.load = /**
         * Re-loads the audio/video element
         * @return {?}
         */
            function () {
                this._mediaPlayer.load();
            };
        /**
         * Checks if the browser can play the specified audio/video type
         */
        /**
         * Checks if the browser can play the specified audio/video type
         * @param {?} type
         * @return {?}
         */
        MediaPlayerService.prototype.canPlayType = /**
         * Checks if the browser can play the specified audio/video type
         * @param {?} type
         * @return {?}
         */
            function (type) {
                return this._mediaPlayer.canPlayType(type);
            };
        /**
         * Adds a new text track to the audio/video
         */
        /**
         * Adds a new text track to the audio/video
         * @param {?} kind
         * @param {?} label
         * @param {?} language
         * @return {?}
         */
        MediaPlayerService.prototype.addTextTrack = /**
         * Adds a new text track to the audio/video
         * @param {?} kind
         * @param {?} label
         * @param {?} language
         * @return {?}
         */
            function (kind, label, language) {
                return this._mediaPlayer.addTextTrack(kind, label, language);
            };
        /**
         * Attempt to display media in fullscreen mode
         */
        /**
         * Attempt to display media in fullscreen mode
         * @return {?}
         */
        MediaPlayerService.prototype.requestFullscreen = /**
         * Attempt to display media in fullscreen mode
         * @return {?}
         */
            function () {
                if (this._hostElement.requestFullscreen) {
                    this._hostElement.requestFullscreen();
                }
                else if (this._hostElement.webkitRequestFullscreen) {
                    this._hostElement.webkitRequestFullscreen();
                }
                else if (((this._hostElement)).msRequestFullscreen) {
                    ((this._hostElement)).msRequestFullscreen();
                }
                else if (((this._hostElement)).mozRequestFullScreen) {
                    ((this._hostElement)).mozRequestFullScreen();
                }
            };
        /**
         * Exit full screen mode
         */
        /**
         * Exit full screen mode
         * @return {?}
         */
        MediaPlayerService.prototype.exitFullscreen = /**
         * Exit full screen mode
         * @return {?}
         */
            function () {
                if (((this._hostElement)).exitFullscreen) {
                    document.exitFullscreen();
                }
                else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                }
                else if (((document)).msExitFullscreen) {
                    ((document)).msExitFullscreen();
                }
                else if (((document)).mozCancelFullScreen) {
                    ((document)).mozCancelFullScreen();
                }
            };
        /**
         * @return {?}
         */
        MediaPlayerService.prototype.fullscreenChange = /**
         * @return {?}
         */
            function () {
                this.fullscreen = ((document)).fullscreen || document.webkitIsFullScreen || ((document)).mozFullScreen || ((document)).msFullscreenElement !== null && ((document)).msFullscreenElement !== undefined;
                this.fullscreenEvent.next(this.fullscreen);
            };
        /**
         * Toggle Fullscreen State
         */
        /**
         * Toggle Fullscreen State
         * @return {?}
         */
        MediaPlayerService.prototype.toggleFullscreen = /**
         * Toggle Fullscreen State
         * @return {?}
         */
            function () {
                if (this.fullscreen) {
                    this.exitFullscreen();
                }
                else {
                    this.requestFullscreen();
                }
            };
        /**
         * Extract the frames from the video
         */
        /**
         * Extract the frames from the video
         * @param {?} width
         * @param {?} height
         * @param {?} skip
         * @return {?}
         */
        MediaPlayerService.prototype.getFrames = /**
         * Extract the frames from the video
         * @param {?} width
         * @param {?} height
         * @param {?} skip
         * @return {?}
         */
            function (width, height, skip) {
                if (this.type === 'video') {
                    return this._frameExtractionService.getFrameThumbnails(this.source, width, height, 0, this.duration, 10);
                }
                return from.from([]);
            };
        /**
         * @return {?}
         */
        MediaPlayerService.prototype.hideSubtitleTracks = /**
         * @return {?}
         */
            function () {
                for (var /** @type {?} */ index = 0; index < this.textTracks.length; index++) {
                    this.textTracks[index].mode = 'hidden';
                }
            };
        MediaPlayerService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        MediaPlayerService.ctorParameters = function () {
            return [
                { type: FrameExtractionService }
            ];
        };
        return MediaPlayerService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MediaPlayerBaseExtensionDirective = (function () {
        function MediaPlayerBaseExtensionDirective(mediaPlayerService) {
            this.mediaPlayerService = mediaPlayerService;
        }
        MediaPlayerBaseExtensionDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[mediaPlayerBaseExtension]'
                    },] }
        ];
        /** @nocollapse */
        MediaPlayerBaseExtensionDirective.ctorParameters = function () {
            return [
                { type: MediaPlayerService }
            ];
        };
        return MediaPlayerBaseExtensionDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ColorServiceModule = (function () {
        function ColorServiceModule() {
        }
        ColorServiceModule.decorators = [
            { type: core.NgModule, args: [{
                        providers: [ColorService],
                    },] }
        ];
        return ColorServiceModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SliderComponent = (function () {
        function SliderComponent(colorService, _changeDetectorRef) {
            this._changeDetectorRef = _changeDetectorRef;
            this.value = 0;
            this.valueChange = new core.EventEmitter();
            // expose enums to Angular view
            this.sliderType = SliderType;
            this.sliderStyle = SliderStyle;
            this.sliderSize = SliderSize;
            this.sliderSnap = SliderSnap;
            this.sliderThumb = SliderThumb;
            this.sliderTickType = SliderTickType;
            this.sliderThumbEvent = SliderThumbEvent;
            this.sliderCalloutTrigger = SliderCalloutTrigger;
            this.tracks = {
                lower: {
                    size: 0,
                    color: ''
                },
                middle: {
                    size: 0,
                    color: ''
                },
                upper: {
                    size: 0,
                    color: ''
                }
            };
            this.tooltips = {
                lower: {
                    visible: false,
                    position: 0,
                    label: ''
                },
                upper: {
                    visible: false,
                    position: 0,
                    label: ''
                }
            };
            this.thumbs = {
                lower: {
                    hover: false,
                    drag: false,
                    position: 0,
                    order: 100,
                    value: /** @type {?} */ (null)
                },
                upper: {
                    hover: false,
                    drag: false,
                    position: 0,
                    order: 101,
                    value: /** @type {?} */ (null)
                }
            };
            // store all the ticks to display
            this.ticks = [];
            // setup default options
            this.defaultOptions = {
                type: SliderType.Value,
                handles: {
                    style: SliderStyle.Button,
                    callout: {
                        trigger: SliderCalloutTrigger.None,
                        background: colorService.getColor('grey2').toHex(),
                        color: '#fff',
                        formatter: function (value) { return value; }
                    },
                    keyboard: {
                        major: 5,
                        minor: 1
                    },
                    aria: {
                        thumb: 'Slider value',
                        lowerThumb: 'Slider lower value',
                        upperThumb: 'Slider upper value'
                    }
                },
                track: {
                    height: SliderSize.Wide,
                    min: 0,
                    max: 100,
                    ticks: {
                        snap: SliderSnap.None,
                        major: {
                            show: true,
                            steps: 10,
                            labels: true,
                            formatter: function (value) { return value; }
                        },
                        minor: {
                            show: true,
                            steps: 5,
                            labels: false,
                            formatter: function (value) { return value; }
                        }
                    },
                    colors: {
                        lower: colorService.getColor('grey6').toHex(),
                        range: colorService.getColor('accent').setAlpha(0.75).toRgba(),
                        higher: colorService.getColor('grey6').toHex()
                    }
                }
            };
        }
        /**
         * @return {?}
         */
        SliderComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.updateOptions();
                this.updateValues();
                this.setThumbState(SliderThumb.Lower, false, false);
                this.setThumbState(SliderThumb.Upper, false, false);
                // emit the initial value
                this.valueChange.next(this.clone(this.value));
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.ngDoCheck = /**
         * @return {?}
         */
            function () {
                if (this.detectValueChange(this.value, this._value)) {
                    this.updateValues();
                    this._value = this.clone(this.value);
                }
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // persistent tooltips will need positioned correctly at this stage
                setTimeout(function () {
                    _this.updateTooltipPosition(SliderThumb.Lower);
                    _this.updateTooltipPosition(SliderThumb.Upper);
                    // mark as dirty
                    // mark as dirty
                    _this._changeDetectorRef.markForCheck();
                });
            };
        /**
         * @param {?} thumb
         * @param {?} snapTarget
         * @param {?} forwards
         * @return {?}
         */
        SliderComponent.prototype.snapToNearestTick = /**
         * @param {?} thumb
         * @param {?} snapTarget
         * @param {?} forwards
         * @return {?}
         */
            function (thumb, snapTarget, forwards) {
                // get the value for the thumb
                var value = this.getThumbState(thumb).value;
                // get the closest ticks - remove any tick if we are currently on it
                var /** @type {?} */ closest = this.getTickDistances(value, thumb, snapTarget)
                    .filter(function (tick) { return tick.value !== value; })
                    .find(function (tick) { return forwards ? tick.value > value : tick.value < value; });
                // If we have no ticks then move by a predefined amount
                if (closest) {
                    return this.setThumbValue(thumb, this.validateValue(thumb, closest.value));
                }
                var /** @type {?} */ step = snapTarget === SliderSnap.Major ? this.options.handles.keyboard.major : this.options.handles.keyboard.minor;
                this.setThumbValue(thumb, this.validateValue(thumb, value + (forwards ? step : -step)));
            };
        /**
         * @param {?} thumb
         * @param {?} forwards
         * @return {?}
         */
        SliderComponent.prototype.snapToEnd = /**
         * @param {?} thumb
         * @param {?} forwards
         * @return {?}
         */
            function (thumb, forwards) {
                this.setThumbValue(thumb, this.validateValue(thumb, forwards ? this.options.track.max : this.options.track.min));
            };
        /**
         * @param {?} thumb
         * @return {?}
         */
        SliderComponent.prototype.getThumbValue = /**
         * @param {?} thumb
         * @return {?}
         */
            function (thumb) {
                return this.getThumbState(thumb).value;
            };
        /**
         * @param {?} thumb
         * @return {?}
         */
        SliderComponent.prototype.getFormattedValue = /**
         * @param {?} thumb
         * @return {?}
         */
            function (thumb) {
                return this.options.handles.callout.formatter(this.getThumbState(thumb).value);
            };
        /**
         * @param {?} thumb
         * @return {?}
         */
        SliderComponent.prototype.getThumbState = /**
         * @param {?} thumb
         * @return {?}
         */
            function (thumb) {
                return thumb === SliderThumb.Lower ? this.thumbs.lower : this.thumbs.upper;
            };
        /**
         * @param {?} thumb
         * @param {?} hover
         * @param {?} drag
         * @return {?}
         */
        SliderComponent.prototype.setThumbState = /**
         * @param {?} thumb
         * @param {?} hover
         * @param {?} drag
         * @return {?}
         */
            function (thumb, hover, drag) {
                if (thumb === SliderThumb.Lower) {
                    this.thumbs.lower.hover = hover;
                    this.thumbs.lower.drag = drag;
                }
                else {
                    this.thumbs.upper.hover = hover;
                    this.thumbs.upper.drag = drag;
                }
                // update the visibility of the tooltips
                this.updateTooltips(thumb);
            };
        /**
         * @param {?} thumb
         * @param {?} event
         * @return {?}
         */
        SliderComponent.prototype.thumbEvent = /**
         * @param {?} thumb
         * @param {?} event
         * @return {?}
         */
            function (thumb, event) {
                // get the current thumb state
                var /** @type {?} */ state = this.getThumbState(thumb);
                // update based upon event
                switch (event) {
                    case SliderThumbEvent.DragStart:
                        state.drag = true;
                        break;
                    case SliderThumbEvent.DragEnd:
                        state.drag = false;
                        break;
                    case SliderThumbEvent.MouseOver:
                        state.hover = true;
                        break;
                    case SliderThumbEvent.MouseLeave:
                        state.hover = false;
                        break;
                    case SliderThumbEvent.None:
                        state.drag = false;
                        state.hover = false;
                        break;
                }
                // update the thumb state
                this.setThumbState(thumb, state.hover, state.drag);
            };
        /**
         * @param {?} thumb
         * @return {?}
         */
        SliderComponent.prototype.getAriaValueText = /**
         * @param {?} thumb
         * @return {?}
         */
            function (thumb) {
                // get the current thumb value
                var /** @type {?} */ value = this.getThumbValue(thumb);
                // get all the ticks
                var /** @type {?} */ tick = this.ticks.find(function (_tick) { return _tick.value === value; });
                if (tick && tick.label) {
                    return tick.label;
                }
                // otherwise simply display the formatted value
                return this.getFormattedValue(thumb);
            };
        /**
         * @param {?} thumb
         * @return {?}
         */
        SliderComponent.prototype.updateTooltips = /**
         * @param {?} thumb
         * @return {?}
         */
            function (thumb) {
                var /** @type {?} */ visible = false;
                var /** @type {?} */ state = this.getThumbState(thumb);
                switch (this.options.handles.callout.trigger) {
                    case SliderCalloutTrigger.Persistent:
                        visible = true;
                        break;
                    case SliderCalloutTrigger.Drag:
                        visible = state.drag;
                        break;
                    case SliderCalloutTrigger.Hover:
                        visible = state.hover || state.drag;
                        break;
                    case SliderCalloutTrigger.Dynamic:
                        visible = true;
                        break;
                }
                // update the state for the corresponding thumb
                this.getTooltip(thumb).visible = visible;
                // update the tooltip text
                this.updateTooltipText(thumb);
                // update the tooltip positions
                this.updateTooltipPosition(thumb);
            };
        /**
         * @param {?} thumb
         * @return {?}
         */
        SliderComponent.prototype.updateTooltipText = /**
         * @param {?} thumb
         * @return {?}
         */
            function (thumb) {
                // get the thumb value
                var /** @type {?} */ state = this.getThumbState(thumb);
                var /** @type {?} */ tooltip$$1 = this.getTooltip(thumb);
                // store the formatted label
                tooltip$$1.label = this.getFormattedValue(thumb).toString();
            };
        /**
         * @param {?} thumb
         * @return {?}
         */
        SliderComponent.prototype.getTooltipElement = /**
         * @param {?} thumb
         * @return {?}
         */
            function (thumb) {
                return thumb === SliderThumb.Lower ? this.lowerTooltip : this.upperTooltip;
            };
        /**
         * @param {?} thumb
         * @return {?}
         */
        SliderComponent.prototype.getTooltip = /**
         * @param {?} thumb
         * @return {?}
         */
            function (thumb) {
                return thumb === SliderThumb.Lower ? this.tooltips.lower : this.tooltips.upper;
            };
        /**
         * @param {?} thumb
         * @return {?}
         */
        SliderComponent.prototype.updateTooltipPosition = /**
         * @param {?} thumb
         * @return {?}
         */
            function (thumb) {
                var /** @type {?} */ tooltip$$1 = this.getTooltip(thumb);
                // if tooltip is not visible then stop here
                if (tooltip$$1.visible === false) {
                    return;
                }
                var /** @type {?} */ tooltipElement = this.getTooltipElement(thumb);
                // get the element widths
                var /** @type {?} */ thumbWidth;
                if (this.options.handles.style === SliderStyle.Button) {
                    thumbWidth = this.options.track.height === SliderSize.Narrow ? 16 : 24;
                }
                else {
                    thumbWidth = 2;
                }
                var /** @type {?} */ tooltipWidth = tooltipElement.nativeElement.offsetWidth;
                // calculate the tooltips new position
                var /** @type {?} */ tooltipPosition = Math.ceil((tooltipWidth - thumbWidth) / 2);
                // update tooltip position
                tooltip$$1.position = -tooltipPosition;
                if (this.options.type === SliderType.Range && this.options.handles.callout.trigger === SliderCalloutTrigger.Dynamic) {
                    this.preventTooltipOverlap(tooltip$$1);
                }
            };
        /**
         * @param {?} tooltip
         * @return {?}
         */
        SliderComponent.prototype.preventTooltipOverlap = /**
         * @param {?} tooltip
         * @return {?}
         */
            function (tooltip$$1) {
                var /** @type {?} */ trackWidth = this.track.nativeElement.offsetWidth;
                var /** @type {?} */ lower = (trackWidth / 100) * this.thumbs.lower.position;
                var /** @type {?} */ upper = (trackWidth / 100) * this.thumbs.upper.position;
                var /** @type {?} */ lowerWidth = this.lowerTooltip.nativeElement.offsetWidth / 2;
                var /** @type {?} */ upperWidth = this.upperTooltip.nativeElement.offsetWidth / 2;
                var /** @type {?} */ diff = (lower + lowerWidth) - (upper - upperWidth);
                // if the tooltips are closer than 16px then adjust so the dont move any close
                if (diff > 0) {
                    if (tooltip$$1 === this.tooltips.lower && this.thumbs.lower.drag === false) {
                        tooltip$$1.position -= (diff / 2);
                    }
                    else if (tooltip$$1 === this.tooltips.upper && this.thumbs.upper.drag === false) {
                        tooltip$$1.position += (diff / 2);
                    }
                }
            };
        /**
         * @param {?} value
         * @param {?} min
         * @param {?} max
         * @return {?}
         */
        SliderComponent.prototype.clamp = /**
         * @param {?} value
         * @param {?} min
         * @param {?} max
         * @return {?}
         */
            function (value, min, max) {
                return Math.min(Math.max(value, min), max);
            };
        /**
         * @param {?} event
         * @param {?} thumb
         * @return {?}
         */
        SliderComponent.prototype.updateThumbPosition = /**
         * @param {?} event
         * @param {?} thumb
         * @return {?}
         */
            function (event, thumb) {
                // get event position - either mouse or touch
                var /** @type {?} */ eventPosition = event instanceof MouseEvent ? event.clientX : event.touches && event.touches.length > 0 ? event.touches[0].clientX : null;
                // if event position is null do nothing
                if (eventPosition === null) {
                    return;
                }
                // get mouse position
                var /** @type {?} */ mouseX = window.pageXOffset + eventPosition;
                // get track size and position
                var /** @type {?} */ trackBounds = this.track.nativeElement.getBoundingClientRect();
                // restrict the value within the range size
                var /** @type {?} */ position = this.clamp(mouseX - trackBounds.left, 0, trackBounds.width);
                // get fraction representation of location within the track
                var /** @type {?} */ fraction = (position / trackBounds.width);
                // convert to value within the range
                var /** @type {?} */ value = ((this.options.track.max - this.options.track.min) * fraction) + this.options.track.min;
                // ensure value is valid
                value = this.validateValue(thumb, value);
                // snap to a tick if required
                value = this.snapToTick(value, thumb);
                // update the value accordingly
                this.setThumbValue(thumb, value);
                this.updateOrder(thumb);
                this.updateValues();
                // update tooltip text & position
                this.updateTooltipText(thumb);
                // update the position of all visible tooltips
                this.updateTooltipPosition(SliderThumb.Lower);
                this.updateTooltipPosition(SliderThumb.Upper);
                // mark as dirty for change detection
                this._changeDetectorRef.markForCheck();
            };
        /**
         * @param {?} thumb
         * @return {?}
         */
        SliderComponent.prototype.updateOrder = /**
         * @param {?} thumb
         * @return {?}
         */
            function (thumb) {
                var /** @type {?} */ lower = thumb === SliderThumb.Lower ? 101 : 100;
                var /** @type {?} */ upper = thumb === SliderThumb.Lower ? 100 : 101;
                // The most recently used thumb should be above
                this.thumbs.lower.order = lower;
                this.thumbs.upper.order = upper;
            };
        /**
         * @param {?} value
         * @param {?} thumb
         * @param {?} snapTarget
         * @return {?}
         */
        SliderComponent.prototype.getTickDistances = /**
         * @param {?} value
         * @param {?} thumb
         * @param {?} snapTarget
         * @return {?}
         */
            function (value, thumb, snapTarget) {
                // if snap target is none then return original value
                if (snapTarget === SliderSnap.None) {
                    return [];
                }
                // get filtered ticks
                var /** @type {?} */ ticks;
                switch (snapTarget) {
                    case SliderSnap.Minor:
                        ticks = this.ticks.filter(function (tick) { return tick.type === SliderTickType.Minor; });
                        break;
                    case SliderSnap.Major:
                        ticks = this.ticks.filter(function (tick) { return tick.type === SliderTickType.Major; });
                        break;
                    default:
                        ticks = this.ticks.slice(0);
                }
                // get the track limit
                var /** @type {?} */ lowerLimit = this.options.track.min;
                var /** @type {?} */ upperLimit = this.options.track.max;
                if (this.options.type === SliderType.Range && thumb === SliderThumb.Lower) {
                    upperLimit = this.thumbs.upper.value;
                }
                if (this.options.type === SliderType.Range && thumb === SliderThumb.Upper) {
                    lowerLimit = this.thumbs.lower.value;
                }
                // Find the closest tick to the current position
                var /** @type {?} */ range = ticks.filter(function (tick) { return tick.value >= lowerLimit && tick.value <= upperLimit; });
                // If there are no close ticks in the valid range then dont snap
                if (range.length === 0) {
                    return [];
                }
                return range.sort(function (tickOne, tickTwo) {
                    var /** @type {?} */ tickOneDelta = Math.max(tickOne.value, value) - Math.min(tickOne.value, value);
                    var /** @type {?} */ tickTwoDelta = Math.max(tickTwo.value, value) - Math.min(tickTwo.value, value);
                    return tickOneDelta - tickTwoDelta;
                });
            };
        /**
         * @param {?} value
         * @param {?} thumb
         * @return {?}
         */
        SliderComponent.prototype.snapToTick = /**
         * @param {?} value
         * @param {?} thumb
         * @return {?}
         */
            function (value, thumb) {
                var /** @type {?} */ tickDistances = this.getTickDistances(value, thumb, this.options.track.ticks.snap);
                // if there are no ticks return the current value
                if (tickDistances.length === 0) {
                    return value;
                }
                // get the closest tick
                return tickDistances[0].value;
            };
        /**
         * @param {?} thumb
         * @param {?} value
         * @return {?}
         */
        SliderComponent.prototype.validateValue = /**
         * @param {?} thumb
         * @param {?} value
         * @return {?}
         */
            function (thumb, value) {
                // if slider is not a range value is always valid providing it is within the chart min and max values
                if (this.options.type === SliderType.Value) {
                    return Math.max(Math.min(value, this.options.track.max), this.options.track.min);
                }
                // check if value is with chart ranges
                if (value > this.options.track.max) {
                    return thumb === SliderThumb.Lower ? Math.min(this.options.track.max, this.thumbs.upper.value) : this.options.track.max;
                }
                if (value < this.options.track.min) {
                    return thumb === SliderThumb.Upper ? Math.max(this.options.track.min, this.thumbs.lower.value) : this.options.track.min;
                }
                // otherwise we need to check to make sure lower thumb cannot go above higher and vice versa
                if (thumb === SliderThumb.Lower) {
                    if (this.thumbs.upper.value === null) {
                        return value;
                    }
                    return value <= this.thumbs.upper.value ? value : this.thumbs.upper.value;
                }
                if (thumb === SliderThumb.Upper) {
                    if (this.thumbs.lower.value === null) {
                        return value;
                    }
                    return value >= this.thumbs.lower.value ? value : this.thumbs.lower.value;
                }
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.updateOptions = /**
         * @return {?}
         */
            function () {
                // add in the default options that user hasn't specified
                this.options = this.deepMerge(this.options || {}, this.defaultOptions);
                this.updateTrackColors();
                this.updateTicks();
                this.updateValues();
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.updateValues = /**
         * @return {?}
         */
            function () {
                if (this.value === undefined || this.value === null) {
                    this.value = 0;
                }
                var /** @type {?} */ lowerValue = typeof this.value === 'number' ? this.value : this.value.low;
                var /** @type {?} */ upperValue = typeof this.value === 'number' ? this.value : this.value.high;
                // validate values
                lowerValue = this.validateValue(SliderThumb.Lower, Number(lowerValue.toFixed(4)));
                upperValue = this.validateValue(SliderThumb.Upper, Number(upperValue.toFixed(4)));
                // calculate the positions as percentages
                var /** @type {?} */ lowerPosition = (((lowerValue - this.options.track.min) / (this.options.track.max - this.options.track.min)) * 100);
                var /** @type {?} */ upperPosition = (((upperValue - this.options.track.min) / (this.options.track.max - this.options.track.min)) * 100);
                // update thumb positions
                this.thumbs.lower.position = lowerPosition;
                this.thumbs.upper.position = upperPosition;
                // calculate the track sizes
                this.tracks.lower.size = lowerPosition;
                this.tracks.middle.size = upperPosition - lowerPosition;
                this.tracks.upper.size = this.options.type === SliderType.Value ? 100 - lowerPosition : 100 - upperPosition;
                // update the value input
                this.setValue(lowerValue, upperValue);
            };
        /**
         * @param {?} low
         * @param {?=} high
         * @return {?}
         */
        SliderComponent.prototype.setValue = /**
         * @param {?} low
         * @param {?=} high
         * @return {?}
         */
            function (low, high) {
                this.thumbs.lower.value = low;
                this.thumbs.upper.value = high;
                var /** @type {?} */ previousValue = this.clone(this._value);
                this.value = this.options.type === SliderType.Value ? low : { low: low, high: high };
                // call the event emitter if changes occured
                if (this.detectValueChange(this.value, previousValue)) {
                    this.valueChange.emit(this.clone(this.value));
                    this.updateTooltipText(SliderThumb.Lower);
                    this.updateTooltipText(SliderThumb.Upper);
                }
                else {
                    this.valueChange.emit(this.clone(this.value));
                }
            };
        /**
         * @param {?} thumb
         * @param {?} value
         * @return {?}
         */
        SliderComponent.prototype.setThumbValue = /**
         * @param {?} thumb
         * @param {?} value
         * @return {?}
         */
            function (thumb, value) {
                // update the thumb value
                this.getThumbState(thumb).value = value;
                // forward these changes to the value
                this.setValue(this.thumbs.lower.value, this.thumbs.upper.value);
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.updateTicks = /**
         * @return {?}
         */
            function () {
                // get tick options
                var /** @type {?} */ majorOptions = this.options.track.ticks.major;
                var /** @type {?} */ minorOptions = this.options.track.ticks.minor;
                // check if we should show ticks
                if (majorOptions.show === false && minorOptions.show === false) {
                    this.ticks = [];
                }
                // create ticks for both major and minor - only get the ones to be shown
                var /** @type {?} */ majorTicks = this.getTicks(majorOptions, SliderTickType.Major).filter(function (tick) { return tick.showTicks; });
                var /** @type {?} */ minorTicks = this.getTicks(minorOptions, SliderTickType.Minor).filter(function (tick) { return tick.showTicks; });
                // remove any minor ticks that are on a major interval
                this.ticks = this.unionTicks(majorTicks, minorTicks);
            };
        /**
         * @return {?}
         */
        SliderComponent.prototype.updateTrackColors = /**
         * @return {?}
         */
            function () {
                // get colors for each part of the track
                var _a = this.options.track.colors, lower = _a.lower, range = _a.range, higher = _a.higher;
                // update the controller value
                this.tracks.lower.color = typeof lower === 'string' ? lower : "linear-gradient(to right, " + lower.join(', ') + ")";
                this.tracks.middle.color = typeof range === 'string' ? range : "linear-gradient(to right, " + range.join(', ') + ")";
                this.tracks.upper.color = typeof higher === 'string' ? higher : "linear-gradient(to right, " + higher.join(', ') + ")";
            };
        /**
         * @param {?} steps
         * @return {?}
         */
        SliderComponent.prototype.getSteps = /**
         * @param {?} steps
         * @return {?}
         */
            function (steps) {
                // if they are already an array just return it
                if (steps instanceof Array) {
                    return steps;
                }
                var /** @type {?} */ output = [];
                // otherwise calculate the steps
                for (var /** @type {?} */ idx = this.options.track.min; idx <= this.options.track.max; idx += steps) {
                    output.push(idx);
                }
                return output;
            };
        /**
         * @param {?} options
         * @param {?} type
         * @return {?}
         */
        SliderComponent.prototype.getTicks = /**
         * @param {?} options
         * @param {?} type
         * @return {?}
         */
            function (options, type) {
                // create an array to store the ticks and step points
                var /** @type {?} */ steps = this.getSteps(options.steps);
                // get some chart options
                var /** @type {?} */ min = this.options.track.min;
                var /** @type {?} */ max = this.options.track.max;
                // convert each step to a slider tick and remove invalid ticks
                return steps.map(function (step) {
                    return {
                        showTicks: options.show,
                        showLabels: options.labels,
                        type: type,
                        position: ((step - min) / (max - min)) * 100,
                        value: step,
                        label: options.formatter(step)
                    };
                }).filter(function (tick) { return tick.position >= 0 && tick.position <= 100; });
            };
        /**
         * @param {?} majorTicks
         * @param {?} minorTicks
         * @return {?}
         */
        SliderComponent.prototype.unionTicks = /**
         * @param {?} majorTicks
         * @param {?} minorTicks
         * @return {?}
         */
            function (majorTicks, minorTicks) {
                // get all ticks combined removing any minor ticks with the same value as major ticks
                return majorTicks.concat(minorTicks)
                    .filter(function (tick, index, array) { return tick.type === SliderTickType.Major || !array.find(function (tk) { return tk.type === SliderTickType.Major && tk.position === tick.position; }); })
                    .sort(function (t1, t2) { return t1.value - t2.value; });
            };
        /**
         * @template T
         * @param {?} destination
         * @param {?} source
         * @return {?}
         */
        SliderComponent.prototype.deepMerge = /**
         * @template T
         * @param {?} destination
         * @param {?} source
         * @return {?}
         */
            function (destination, source) {
                // loop though all of the properties in the source object
                for (var /** @type {?} */ prop in source) {
                    // check if the destination object has the property
                    if (!destination.hasOwnProperty(prop)) {
                        // copy the property across
                        destination[prop] = source[prop];
                        continue;
                    }
                    // if the property exists and is not an object then skip
                    if (typeof destination[prop] !== 'object') {
                        continue;
                    }
                    // check if property is an array
                    if (destination[prop] instanceof Array) {
                        continue;
                    }
                    // if it is an object then perform a recursive check
                    destination[prop] = this.deepMerge(destination[prop], source[prop]);
                }
                return destination;
            };
        /**
         * @param {?} value1
         * @param {?} value2
         * @return {?}
         */
        SliderComponent.prototype.detectValueChange = /**
         * @param {?} value1
         * @param {?} value2
         * @return {?}
         */
            function (value1, value2) {
                // compare two slider values
                if (this.isSliderValue(value1) && this.isSliderValue(value2)) {
                    // references to the objects in the correct types
                    var /** @type {?} */ obj1 = (value1);
                    var /** @type {?} */ obj2 = (value2);
                    return obj1.low !== obj2.low || obj1.high !== obj2.high;
                }
                // if not a slider value - should be number of nullable type - compare normally
                return value1 !== value2;
            };
        /**
         * Determines whether or not an object conforms to the
         * SliderValue interface.
         * @param {?} value - The object to check - this must be type any
         * @return {?}
         */
        SliderComponent.prototype.isSliderValue = /**
         * Determines whether or not an object conforms to the
         * SliderValue interface.
         * @param {?} value - The object to check - this must be type any
         * @return {?}
         */
            function (value) {
                // check if is an object
                if (typeof value !== 'object') {
                    return false;
                }
                // next check if it contains the necessary properties
                return 'low' in value && 'high' in value;
            };
        /**
         * @param {?} value
         * @return {?}
         */
        SliderComponent.prototype.clone = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                // if it is not an object simply return the value
                if (typeof value !== 'object') {
                    return value;
                }
                // create a new object from the existing one
                var /** @type {?} */ instance = __assign({}, value);
                // delete remove the value from the old object
                value = undefined;
                // return the new instance of the object
                return instance;
            };
        SliderComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-slider',
                        template: "<div class=\"track\" #track [class.narrow]=\"options.track.height === sliderSize.Narrow\" [class.wide]=\"options.track.height === sliderSize.Wide\" [class.range]=\"options.type === sliderType.Range\">\n\n    <!-- Section Beneath Lower Thumb -->\n    <div class=\"track-section track-lower\" [style.flex-grow]=\"tracks.lower.size\" [style.background]=\"tracks.lower.color\"></div>\n\n    <!-- Lower Thumb Button / Line -->\n    <div class=\"thumb lower\"\n        uxDrag\n        role=\"slider\"\n        tabindex=\"0\"\n        #lowerthumb\n        [attr.aria-label]=\"options.type === sliderType.Range ? options.handles.aria.lowerThumb : options.handles.aria.thumb\"\n        [attr.aria-valuemin]=\"options?.track?.min\"\n        [attr.aria-valuemax]=\"options.type === sliderType.Range ? getThumbValue(sliderThumb.Upper) : options?.track?.max\"\n        [attr.aria-valuenow]=\"getThumbValue(sliderThumb.Lower)\"\n        [attr.aria-valuetext]=\"getAriaValueText(sliderThumb.Lower)\"\n        [style.left.%]=\"thumbs.lower.position\"\n        [class.active]=\"thumbs.lower.drag\"\n        [style.z-index]=\"thumbs.lower.order\"\n        [class.button]=\"options.handles.style === sliderStyle.Button\"\n        [class.line]=\"options.handles.style === sliderStyle.Line\"\n        [class.narrow]=\"options.track.height === sliderSize.Narrow\"\n        [class.wide]=\"options.track.height === sliderSize.Wide\"\n        (onDragStart)=\"thumbEvent(sliderThumb.Lower, sliderThumbEvent.DragStart); lowerthumb.focus()\"\n        (onDrag)=\"updateThumbPosition($event, sliderThumb.Lower)\"\n        (onDragEnd)=\"thumbEvent(sliderThumb.Lower, sliderThumbEvent.DragEnd)\"\n        (mouseenter)=\"thumbEvent(sliderThumb.Lower, sliderThumbEvent.MouseOver)\"\n        (mouseleave)=\"thumbEvent(sliderThumb.Lower, sliderThumbEvent.MouseLeave)\"\n        (focus)=\"thumbEvent(sliderThumb.Lower, sliderThumbEvent.MouseOver)\"\n        (blur)=\"thumbEvent(sliderThumb.Lower, sliderThumbEvent.MouseLeave)\"\n        (keydown.ArrowLeft)=\"snapToNearestTick(sliderThumb.Lower, sliderSnap.All, false); $event.preventDefault()\"\n        (keydown.ArrowRight)=\"snapToNearestTick(sliderThumb.Lower, sliderSnap.All, true); $event.preventDefault()\"\n        (keydown.ArrowUp)=\"snapToNearestTick(sliderThumb.Lower, sliderSnap.All, false); $event.preventDefault()\"\n        (keydown.ArrowDown)=\"snapToNearestTick(sliderThumb.Lower, sliderSnap.All, true); $event.preventDefault()\"\n        (keydown.PageDown)=\"snapToNearestTick(sliderThumb.Lower, sliderSnap.Major, false); $event.preventDefault()\"\n        (keydown.PageUp)=\"snapToNearestTick(sliderThumb.Lower, sliderSnap.Major, true); $event.preventDefault()\"\n        (keydown.Home)=\"snapToEnd(sliderThumb.Lower, false); $event.preventDefault()\"\n        (keydown.End)=\"snapToEnd(sliderThumb.Lower, true); $event.preventDefault()\">\n\n        <!-- Lower Thumb Callout -->\n        <div class=\"tooltip top tooltip-lower\" #lowerTooltip\n            [class.tooltip-dynamic]=\"options.handles.callout.trigger === sliderCalloutTrigger.Dynamic && thumbs.lower.drag === false\"\n            [style.opacity]=\"tooltips.lower.visible ? 1 : 0\"\n            [style.left.px]=\"tooltips.lower.position\">\n\n            <div class=\"tooltip-arrow\" [style.border-top-color]=\"options.handles.callout.background\"></div>\n\n            <div class=\"tooltip-inner\"\n                [style.background-color]=\"options.handles.callout.background\"\n                [style.color]=\"options.handles.callout.color\">\n                {{ tooltips.lower.label }}\n            </div>\n        </div>\n\n    </div>\n\n    <!-- Section of Track Between Lower and Upper Thumbs -->\n    <div class=\"track-section track-range\" *ngIf=\"options.type === sliderType.Range\" [style.flex-grow]=\"tracks.middle.size\" [style.background]=\"tracks.middle.color\">\n    </div>\n\n    <!-- Upper Thumb Button / Line -->\n    <div class=\"thumb upper\"\n        uxDrag\n        role=\"slider\"\n        tabindex=\"0\"\n        #upperthumb\n        [attr.aria-label]=\"options.handles.aria.upperThumb\"\n        [attr.aria-valuemin]=\"getThumbValue(sliderThumb.Lower) || options?.track?.min\"\n        [attr.aria-valuemax]=\"options?.track?.max\"\n        [attr.aria-valuenow]=\"getThumbValue(sliderThumb.Upper)\"\n        [attr.aria-valuetext]=\"getAriaValueText(sliderThumb.Upper)\"\n        [hidden]=\"options.type !== sliderType.Range\"\n        [class.active]=\"thumbs.upper.drag\"\n        [style.left.%]=\"thumbs.upper.position\"\n        [style.z-index]=\"thumbs.upper.order\"\n        [class.button]=\"options.handles.style === sliderStyle.Button\"\n        [class.line]=\"options.handles.style === sliderStyle.Line\"\n        [class.narrow]=\"options.track.height === sliderSize.Narrow\"\n        [class.wide]=\"options.track.height === sliderSize.Wide\"\n        (onDragStart)=\"thumbEvent(sliderThumb.Upper, sliderThumbEvent.DragStart); upperthumb.focus()\"\n        (onDrag)=\"updateThumbPosition($event, sliderThumb.Upper)\"\n        (onDragEnd)=\"thumbEvent(sliderThumb.Upper, sliderThumbEvent.DragEnd)\"\n        (mouseenter)=\"thumbEvent(sliderThumb.Upper, sliderThumbEvent.MouseOver)\"\n        (mouseleave)=\"thumbEvent(sliderThumb.Upper, sliderThumbEvent.MouseLeave)\"\n        (focus)=\"thumbEvent(sliderThumb.Upper, sliderThumbEvent.MouseOver)\"\n        (blur)=\"thumbEvent(sliderThumb.Upper, sliderThumbEvent.MouseLeave)\"\n        (keydown.ArrowLeft)=\"snapToNearestTick(sliderThumb.Upper, sliderSnap.All, false); $event.preventDefault()\"\n        (keydown.ArrowRight)=\"snapToNearestTick(sliderThumb.Upper, sliderSnap.All, true); $event.preventDefault()\"\n        (keydown.ArrowUp)=\"snapToNearestTick(sliderThumb.Upper, sliderSnap.All, false); $event.preventDefault()\"\n        (keydown.ArrowDown)=\"snapToNearestTick(sliderThumb.Upper, sliderSnap.All, true); $event.preventDefault()\"\n        (keydown.PageDown)=\"snapToNearestTick(sliderThumb.Upper, sliderSnap.Major, false); $event.preventDefault()\"\n        (keydown.PageUp)=\"snapToNearestTick(sliderThumb.Upper, sliderSnap.Major, true); $event.preventDefault()\"\n        (keydown.Home)=\"snapToEnd(sliderThumb.Upper, false); $event.preventDefault()\"\n        (keydown.End)=\"snapToEnd(sliderThumb.Upper, true); $event.preventDefault()\">\n\n        <!-- Upper Thumb Callout -->\n        <div class=\"tooltip top tooltip-upper\" #upperTooltip\n            [class.tooltip-dynamic]=\"options.handles.callout.trigger === sliderCalloutTrigger.Dynamic && thumbs.upper.drag === false\"\n            [style.opacity]=\"tooltips.upper.visible ? 1 : 0\"\n            [style.left.px]=\"tooltips.upper.position\">\n\n            <div class=\"tooltip-arrow\" [style.border-top-color]=\"options.handles.callout.background\"></div>\n\n            <div class=\"tooltip-inner\"\n                *ngIf=\"options.type === sliderType.Range\"\n                [style.background-color]=\"options.handles.callout.background\"\n                [style.color]=\"options.handles.callout.color\">\n                {{ tooltips.upper.label }}\n            </div>\n        </div>\n    </div>\n\n    <!-- Section of Track Abover Upper Thumb -->\n    <div class=\"track-section track-higher\" [style.flex-grow]=\"tracks.upper.size\" [style.background]=\"tracks.upper.color\"></div>\n\n</div>\n\n<!-- Chart Ticks and Tick Labels -->\n<div class=\"tick-container\"\n    role=\"presentation\"\n    *ngIf=\"(options.track.ticks.major.show || options.track.ticks.minor.show) && options.handles.callout.trigger !== sliderCalloutTrigger.Dynamic\"\n    [class.show-labels]=\"options.track.ticks.major.labels || options.track.ticks.minor.labels\">\n\n    <div class=\"tick\"\n        *ngFor=\"let tick of ticks\"\n        [class.major]=\"tick.type === sliderTickType.Major\"\n        [class.minor]=\"tick.type === sliderTickType.Minor\"\n        [style.left.%]=\"tick.position\"\n        [hidden]=\"!tick.showTicks\">\n\n        <div class=\"tick-indicator\"></div>\n        <div class=\"tick-label\" aria-hidden=\"true\" [hidden]=\"!tick.showLabels\">{{ tick.label }}</div>\n    </div>\n</div>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        SliderComponent.ctorParameters = function () {
            return [
                { type: ColorService },
                { type: core.ChangeDetectorRef }
            ];
        };
        SliderComponent.propDecorators = {
            value: [{ type: core.Input }],
            options: [{ type: core.Input }],
            valueChange: [{ type: core.Output }],
            lowerTooltip: [{ type: core.ViewChild, args: ['lowerTooltip',] }],
            upperTooltip: [{ type: core.ViewChild, args: ['upperTooltip',] }],
            track: [{ type: core.ViewChild, args: ['track',] }]
        };
        return SliderComponent;
    }());
    /** @enum {number} */
    var SliderType = {
        Value: 0,
        Range: 1,
    };
    SliderType[SliderType.Value] = "Value";
    SliderType[SliderType.Range] = "Range";
    /** @enum {number} */
    var SliderStyle = {
        Button: 0,
        Line: 1,
    };
    SliderStyle[SliderStyle.Button] = "Button";
    SliderStyle[SliderStyle.Line] = "Line";
    /** @enum {number} */
    var SliderSize = {
        Narrow: 0,
        Wide: 1,
    };
    SliderSize[SliderSize.Narrow] = "Narrow";
    SliderSize[SliderSize.Wide] = "Wide";
    /** @enum {number} */
    var SliderCalloutTrigger = {
        None: 0,
        Hover: 1,
        Drag: 2,
        Persistent: 3,
        Dynamic: 4,
    };
    SliderCalloutTrigger[SliderCalloutTrigger.None] = "None";
    SliderCalloutTrigger[SliderCalloutTrigger.Hover] = "Hover";
    SliderCalloutTrigger[SliderCalloutTrigger.Drag] = "Drag";
    SliderCalloutTrigger[SliderCalloutTrigger.Persistent] = "Persistent";
    SliderCalloutTrigger[SliderCalloutTrigger.Dynamic] = "Dynamic";
    /** @enum {number} */
    var SliderSnap = {
        None: 0,
        Minor: 1,
        Major: 2,
        All: 3,
    };
    SliderSnap[SliderSnap.None] = "None";
    SliderSnap[SliderSnap.Minor] = "Minor";
    SliderSnap[SliderSnap.Major] = "Major";
    SliderSnap[SliderSnap.All] = "All";
    /** @enum {number} */
    var SliderTickType = {
        Minor: 0,
        Major: 1,
    };
    SliderTickType[SliderTickType.Minor] = "Minor";
    SliderTickType[SliderTickType.Major] = "Major";
    /** @enum {number} */
    var SliderThumbEvent = {
        None: 0,
        MouseOver: 1,
        MouseLeave: 2,
        DragStart: 3,
        DragEnd: 4,
    };
    SliderThumbEvent[SliderThumbEvent.None] = "None";
    SliderThumbEvent[SliderThumbEvent.MouseOver] = "MouseOver";
    SliderThumbEvent[SliderThumbEvent.MouseLeave] = "MouseLeave";
    SliderThumbEvent[SliderThumbEvent.DragStart] = "DragStart";
    SliderThumbEvent[SliderThumbEvent.DragEnd] = "DragEnd";
    /** @enum {number} */
    var SliderThumb = {
        Lower: 0,
        Upper: 1,
    };
    SliderThumb[SliderThumb.Lower] = "Lower";
    SliderThumb[SliderThumb.Upper] = "Upper";

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SliderModule = (function () {
        function SliderModule() {
        }
        SliderModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            ColorServiceModule,
                            DragModule
                        ],
                        exports: [SliderComponent],
                        declarations: [SliderComponent]
                    },] }
        ];
        return SliderModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ uniqueId$5 = 1;
    var MediaPlayerControlsExtensionComponent = (function (_super) {
        __extends(MediaPlayerControlsExtensionComponent, _super);
        function MediaPlayerControlsExtensionComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.volumeActive = false;
            _this.volumeFocus = false;
            _this.returnFocus = true;
            _this.subtitlesId = "ux-media-player-subtitle-popover-" + uniqueId$5++;
            _this.subtitlesOpen = false;
            _this.mouseEnterVolume = new Subject.Subject();
            _this.mouseLeaveVolume = new Subject.Subject();
            _this.options = {
                handles: {
                    aria: {
                        thumb: 'Volume'
                    }
                },
                track: {
                    colors: {
                        lower: '#666'
                    },
                    height: SliderSize.Narrow,
                    ticks: {
                        major: {
                            show: false
                        },
                        minor: {
                            show: false
                        }
                    }
                }
            };
            _this._volume = 50;
            _this._previousVolume = 50;
            _this._onDestroy = new Subject.Subject();
            return _this;
        }
        Object.defineProperty(MediaPlayerControlsExtensionComponent.prototype, "volume", {
            get: /**
             * @return {?}
             */ function () {
                return this._volume;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value === 0 && this._volume !== 0) {
                    this._previousVolume = this._volume;
                }
                this._volume = Math.min(Math.max(value, 0), 100);
                this.mediaPlayerService.volume = this._volume / 100;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MediaPlayerControlsExtensionComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.mediaPlayerService.volumeChangeEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (volume) { return _this.volume = volume * 100; });
                this.mediaPlayerService.initEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.volume = _this.mediaPlayerService.volume * 100; });
                this.mouseEnterVolume.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.volumeActive = true; });
                this.mouseLeaveVolume.pipe(operators.switchMap(function () { return timer.timer(1500).pipe(operators.takeUntil(_this.mouseEnterVolume)); }), operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.volumeActive = false; });
            };
        /**
         * @return {?}
         */
        MediaPlayerControlsExtensionComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @return {?}
         */
        MediaPlayerControlsExtensionComponent.prototype.toggleMute = /**
         * @return {?}
         */
            function () {
                this.volume = this.volume === 0 ? this._previousVolume : 0;
            };
        /**
         * @return {?}
         */
        MediaPlayerControlsExtensionComponent.prototype.goToStart = /**
         * @return {?}
         */
            function () {
                this.mediaPlayerService.currentTime = 0;
            };
        /**
         * @return {?}
         */
        MediaPlayerControlsExtensionComponent.prototype.goToEnd = /**
         * @return {?}
         */
            function () {
                this.mediaPlayerService.currentTime = this.mediaPlayerService.duration;
            };
        /**
         * @return {?}
         */
        MediaPlayerControlsExtensionComponent.prototype.isSubtitleActive = /**
         * @return {?}
         */
            function () {
                for (var /** @type {?} */ idx = 0; idx < this.mediaPlayerService.textTracks.length; idx++) {
                    if (this.mediaPlayerService.textTracks[idx].mode === 'showing') {
                        return true;
                    }
                }
                return false;
            };
        /**
         * @param {?} track
         * @return {?}
         */
        MediaPlayerControlsExtensionComponent.prototype.setSubtitleTrack = /**
         * @param {?} track
         * @return {?}
         */
            function (track) {
                // hide all tracks
                this.mediaPlayerService.hideSubtitleTracks();
                // set the position of the subtitle track
                for (var /** @type {?} */ idx = 0; idx < track.cues.length; idx++) {
                    var /** @type {?} */ cue = track.cues[idx];
                    cue.line = -3;
                }
                // activate the selected one
                track.mode = 'showing';
            };
        /**
         * @return {?}
         */
        MediaPlayerControlsExtensionComponent.prototype.getSubtitleTrack = /**
         * @return {?}
         */
            function () {
                for (var /** @type {?} */ idx = 0; idx < this.mediaPlayerService.textTracks.length; idx++) {
                    if (this.mediaPlayerService.textTracks[idx].mode === 'showing') {
                        return this.mediaPlayerService.textTracks[idx].label;
                    }
                }
                return 'No subtitles';
            };
        MediaPlayerControlsExtensionComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-media-player-controls',
                        template: "<div class=\"volume-container\">\n\n    <div class=\"volume-slider-container\"\n        #volumeContainer\n        [class.active]=\"volumeActive || volumeFocus\"\n        (mouseenter)=\"mouseEnterVolume.next()\"\n        (mouseleave)=\"mouseLeaveVolume.next()\"\n        (uxFocusWithin)=\"volumeFocus = true\"\n        (uxBlurWithin)=\"volumeFocus = false\">\n\n        <button #volumeIcon\n                class=\"volume-slider-icon\"\n                attr.aria-label=\"{{ volume === 0 ? 'Unmute' : 'Mute' }}\"\n                i18n-aria-label\n                [uxTooltip]=\"muteTooltip\"\n                [showTriggers]=\"['mouseenter']\"\n                [hideTriggers]=\"['mouseleave']\"\n                (click)=\"toggleMute()\"\n                (mouseup)=\"volumeIcon.blur()\">\n\n            <span class=\"hpe-icon\"\n                  [class.hpe-volume-mute]=\"volume === 0\"\n                  [class.hpe-volume-low]=\"volume > 0 && volume <= 70\"\n                  [class.hpe-volume]=\"volume > 70\">\n            </span>\n        </button>\n\n        <div class=\"volume-slider-node\">\n            <ux-slider [(value)]=\"volume\" [options]=\"options\"></ux-slider>\n        </div>\n    </div>\n</div>\n\n<button #startButton\n    class=\"control-button\"\n    (click)=\"goToStart()\"\n    (mouseup)=\"startButton.blur()\"\n    aria-label=\"Go to start\"\n    i18n-aria-label>\n\n    <svg viewBox=\"0 0 51.5 64\" width=\"14\" height=\"17\" focusable=\"false\">\n        <rect x=\"0\" y=\"0\" width=\"7.5\" height=\"64\" />\n        <polygon points=\"51.5,64 51.5,0 7.4,32 \" />\n    </svg>\n</button>\n\n<button #playButton\n    class=\"control-button\"\n    attr.aria-label=\"{{ (mediaPlayerService.playing | async) ? 'Pause' : 'Play' }}\"\n    i18n-aria-label\n    (click)=\"mediaPlayerService.togglePlay()\"\n    (mouseup)=\"playButton.blur()\">\n\n    <svg *ngIf=\"!(mediaPlayerService.playing | async)\" viewBox=\"0 0 45 64\" width=\"20\" height=\"29\" focusable=\"false\">\n        <polygon points=\"0.4,0 0.4,64 44.6,32\" />\n    </svg>\n    <svg *ngIf=\"mediaPlayerService.playing | async\" viewBox=\"0 0 43 56.9\" width=\"20\" height=\"29\" focusable=\"false\">\n        <rect y=\"0.1\" width=\"15.7\" height=\"56.9\" />\n        <rect x=\"27.3\" y=\"0.1\" width=\"15.7\" height=\"56.9\" />\n    </svg>\n</button>\n\n<button #endButton\n    class=\"control-button\"\n    (click)=\"goToEnd()\"\n    (mouseup)=\"endButton.blur()\"\n    aria-label=\"Go to end\"\n    i18n-aria-label>\n\n    <svg viewBox=\"0 0 51.5 64\" width=\"14\" height=\"17\" focusable=\"false\">\n        <rect x=\"44.1\" y=\"0\" width=\"7.5\" height=\"64\" />\n        <polygon points=\"0,64 0,0 44.1,32\" />\n    </svg>\n</button>\n\n<div class=\"actions-list\">\n\n    <ng-content></ng-content>\n\n    <div class=\"action-button-container\" *ngIf=\"mediaPlayerService.textTracks.length > 0 && mediaPlayerService.type === 'video'\">\n        <button #subtitlesButton\n            class=\"action-button\"\n            (keydown)=\"returnFocus = true\"\n            (click)=\"subtitlesOpen = !subtitlesOpen\"\n            (mouseup)=\"subtitlesButton.blur(); returnFocus = false\"\n            i18n-aria-label\n            attr.aria-label=\"Select subtitles, {{ getSubtitleTrack() }} currently selected.\"\n            [attr.aria-expanded]=\"subtitlesOpen\"\n            [attr.aria-describedby]=\"subtitlesId\"\n            aria-haspopup=\"true\">\n            <span class=\"hpe-icon hpe-subtitles\"></span>\n        </button>\n\n        <div #subtitles\n            [style.top.px]=\"-subtitles.offsetHeight\"\n            class=\"popover top media-player-subtitles-popover show\"\n            [id]=\"subtitlesId\"\n            (keydown.escape)=\"subtitlesOpen = false\"\n            (uxClickOutside)=\"subtitlesOpen = false\"\n            *ngIf=\"subtitlesOpen\">\n            <div class=\"arrow\"></div>\n            <h3 class=\"popover-title\" i18n>Subtitles</h3>\n            <div class=\"popover-content\">\n                <ul class=\"subtitles-list\" uxTabbableList [focusOnShow]=\"returnFocus\" [returnFocus]=\"returnFocus\">\n                    <li uxTabbableListItem\n                        tabindex=\"0\"\n                        class=\"subtitles-list-item\"\n                        [class.active]=\"!isSubtitleActive()\"\n                        [attr.aria-selected]=\"isSubtitleActive()\"\n                        (click)=\"mediaPlayerService.hideSubtitleTracks(); subtitlesOpen = false\"\n                        (keydown.enter)=\"mediaPlayerService.hideSubtitleTracks(); subtitlesOpen = false; returnFocus = true\">\n\n                        <i class=\"hpe-icon hpe-checkmark m-r-xs\"></i>\n                        <span i18n>Subtitles Off</span>\n                    </li>\n                    <li uxTabbableListItem\n                        class=\"subtitles-list-item\"\n                        *ngFor=\"let track of mediaPlayerService.textTracks\"\n                        [class.active]=\"track.mode === 'showing'\"\n                        [attr.aria-selected]=\"isSubtitleActive()\"\n                        (click)=\"setSubtitleTrack(track); subtitlesOpen = false\"\n                        (keydown.enter)=\"setSubtitleTrack(track); subtitlesOpen = false; returnFocus = true\">\n                        <i class=\"hpe-icon hpe-checkmark m-r-xs\"></i>\n                        <span>{{ track.label }}</span>\n                    </li>\n                </ul>\n            </div>\n        </div>\n    </div>\n\n    <div class=\"action-button-container\">\n        <button #fullscreenButton\n            *ngIf=\"mediaPlayerService.type !== 'audio'\"\n            class=\"action-button\"\n            attr.aria-label=\"{{ mediaPlayerService.fullscreen ? 'Exit full screen' : 'Full screen' }}\"\n            i18n-aria-label\n            (click)=\"mediaPlayerService.toggleFullscreen()\"\n            (mouseup)=\"fullscreenButton.blur()\">\n\n            <span class=\"hpe-icon\"\n                  [class.hpe-expand]=\"!mediaPlayerService.fullscreen\"\n                  [class.hpe-contract]=\"mediaPlayerService.fullscreen\">\n            </span>\n        </button>\n    </div>\n</div>\n\n\n\n<ng-template #muteTooltip>\n    <span aria-hidden=\"true\">{{ volume === 0 ? 'Unmute' : 'Mute' }}</span>\n</ng-template>",
                        host: {
                            '[class.quiet]': 'mediaPlayerService.quietMode || mediaPlayerService.fullscreen'
                        }
                    }] }
        ];
        return MediaPlayerControlsExtensionComponent;
    }(MediaPlayerBaseExtensionDirective));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MediaPlayerCustomControlDirective = (function () {
        function MediaPlayerCustomControlDirective() {
        }
        MediaPlayerCustomControlDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxMediaPlayerCustomControl]',
                    },] }
        ];
        return MediaPlayerCustomControlDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MediaPlayerTimelineExtensionComponent = (function (_super) {
        __extends(MediaPlayerTimelineExtensionComponent, _super);
        function MediaPlayerTimelineExtensionComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.current = 0;
            _this.position = 0;
            _this.buffered = [];
            _this.mouseDown = false;
            _this.scrub = { visible: false, position: 0, time: 0 };
            _this._onDestroy = new Subject.Subject();
            return _this;
        }
        /**
         * @return {?}
         */
        MediaPlayerTimelineExtensionComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // watch for changes to the current time
                this.mediaPlayerService.fullscreenEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (fullscreen) {
                    _this.scrub.position = 0;
                });
                this.mediaPlayerService.timeUpdateEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (current) {
                    _this.current = current;
                    _this.position = (_this.current / _this.mediaPlayerService.duration) * 100;
                });
                this.mediaPlayerService.progressEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (buffered) {
                    _this.buffered = [];
                    for (var /** @type {?} */ idx = 0; idx < buffered.length; idx++) {
                        _this.buffered.push({
                            start: (buffered.start(idx) / _this.mediaPlayerService.duration) * 100,
                            end: (buffered.end(idx) / _this.mediaPlayerService.duration) * 100
                        });
                    }
                });
            };
        /**
         * @return {?}
         */
        MediaPlayerTimelineExtensionComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                var /** @type {?} */ mousedown$ = fromEvent.fromEvent(this.thumb.nativeElement, 'mousedown');
                var /** @type {?} */ mousemove$ = fromEvent.fromEvent(document, 'mousemove');
                var /** @type {?} */ mouseup$ = fromEvent.fromEvent(document, 'mouseup');
                mousedown$.pipe(operators.switchMap(function () { return mousemove$.pipe(operators.takeUntil(mouseup$)); }), operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.scrub.visible = false; });
            };
        /**
         * @return {?}
         */
        MediaPlayerTimelineExtensionComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        MediaPlayerTimelineExtensionComponent.prototype.updateScrub = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                var /** @type {?} */ target = (event.target);
                if (target.classList.contains('media-progress-bar-thumb')) {
                    return;
                }
                var /** @type {?} */ timeline = (this.timelineRef.nativeElement);
                var /** @type {?} */ bounds = timeline.getBoundingClientRect();
                this.scrub.position = event.offsetX;
                this.scrub.time = (event.offsetX / bounds.width) * this.mediaPlayerService.duration;
                if (this.mouseDown) {
                    this.mediaPlayerService.pause();
                    this.mediaPlayerService.currentTime = this.scrub.time;
                }
            };
        /** Skip a number of seconds in any direction */
        /**
         * Skip a number of seconds in any direction
         * @param {?} seconds
         * @return {?}
         */
        MediaPlayerTimelineExtensionComponent.prototype.skip = /**
         * Skip a number of seconds in any direction
         * @param {?} seconds
         * @return {?}
         */
            function (seconds) {
                var /** @type {?} */ target = this.current + seconds;
                // ensure that the target position is within the bounds of the clip
                if (target < 0) {
                    target = 0;
                }
                if (target > this.mediaPlayerService.duration) {
                    target = this.mediaPlayerService.duration;
                }
                this.mediaPlayerService.currentTime = target;
            };
        MediaPlayerTimelineExtensionComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-media-player-timeline',
                        template: "<p class=\"current-time\">{{ current | duration }}</p>\n\n<div #timeline\n     class=\"timeline-bar\"\n     tabindex=\"0\"\n     role=\"slider\"\n     aria-label=\"Seek slider\"\n     i18n-aria-label\n     aria-valuemin=\"0\"\n     [attr.aria-valuemax]=\"mediaPlayerService.duration | number: '0.0-0'\"\n     [attr.aria-valuenow]=\"mediaPlayerService.currentTime | number: '0.0-0'\"\n     attr.aria-valuetext=\"{{ mediaPlayerService.currentTime | duration }} of {{ mediaPlayerService.duration | duration }}\"\n     (keydown.ArrowLeft)=\"skip(-5)\"\n     (keydown.ArrowRight)=\"skip(5)\"\n     (mouseenter)=\"scrub.visible = true; tooltip.show()\"\n     (mouseleave)=\"scrub.visible = false; tooltip.hide()\"\n     (mousemove)=\"updateScrub($event); tooltip.reposition()\"\n     (mouseup)=\"updateScrub($event)\"\n     (mousedown)=\"mouseDown = true; $event.preventDefault()\">\n\n    <div class=\"buffered-bar\"\n         *ngFor=\"let buffer of buffered\"\n         [style.left.%]=\"buffer.start\"\n         [style.width.%]=\"buffer.end - buffer.start\">\n    </div>\n\n    <div class=\"media-progress-bar\" [style.width.%]=\"position\">\n        <div #progressThumb\n             class=\"media-progress-bar-thumb\"\n             (mouseenter)=\"scrub.visible = false; tooltip.hide(); $event.stopPropagation()\"\n             (mouseleave)=\"scrub.visible = true; tooltip.show(); $event.stopPropagation()\">\n        </div>\n    </div>\n\n    <div #tooltip=\"ux-tooltip\"\n         class=\"scrub-handle\"\n         [class.scrub-handle-hidden]=\"!scrub.visible\"\n         [style.left.px]=\"scrub.position\"\n         [uxTooltip]=\"popTemplate\"\n         tooltipClass=\"ux-media-player-timeline-tooltip\"\n         placement=\"top\"\n         [showTriggers]=\"[]\"\n         [hideTriggers]=\"[]\"\n         [tooltipDelay]=\"100\"\n         [tooltipDisabled]=\"mediaPlayerService.duration === 0\"></div>\n</div>\n\n<p class=\"duration-time\">{{ mediaPlayerService.duration | duration }}</p>\n\n<ng-template #popTemplate>\n    <span>{{ scrub.time | duration }}</span>\n</ng-template>",
                        host: {
                            '(document:mouseup)': 'mouseDown = false',
                            '[class.quiet]': 'mediaPlayerService.quietMode || mediaPlayerService.fullscreen'
                        }
                    }] }
        ];
        MediaPlayerTimelineExtensionComponent.propDecorators = {
            thumb: [{ type: core.ViewChild, args: ['progressThumb',] }],
            timelineRef: [{ type: core.ViewChild, args: ['timeline',] }]
        };
        return MediaPlayerTimelineExtensionComponent;
    }(MediaPlayerBaseExtensionDirective));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AudioService = (function () {
        function AudioService(_http) {
            this._http = _http;
        }
        /**
         * @param {?} mediaElement
         * @return {?}
         */
        AudioService.prototype.getAudioFileMetadata = /**
         * @param {?} mediaElement
         * @return {?}
         */
            function (mediaElement) {
                var _this = this;
                return Observable.Observable.create(function (observer) {
                    _this._http.get(mediaElement.src, { responseType: 'blob' }).subscribe(function (response) {
                        var /** @type {?} */ filename = mediaElement.src.substring(mediaElement.src.lastIndexOf('/') + 1);
                        var /** @type {?} */ extension = mediaElement.src.substring(mediaElement.src.lastIndexOf('.') + 1).toLowerCase();
                        var /** @type {?} */ description;
                        switch (extension) {
                            case 'mp3':
                                description = 'MPEG audio layer 3 file';
                                break;
                            case 'wma':
                                description = 'Windows media audio file';
                                break;
                            case 'wav':
                                description = 'WAVE audio file';
                                break;
                            case 'ogg':
                                description = 'Ogg Vorbis file';
                                break;
                            case 'aac':
                                description = 'Advanced audio coding file';
                                break;
                            case 'midi':
                                description = 'Musical instrument digital interface file';
                                break;
                            default:
                                description = 'Audio file';
                                break;
                        }
                        observer.next({
                            filename: filename,
                            extension: extension,
                            description: description,
                            size: response.size
                        });
                    });
                });
            };
        /**
         * @param {?} url
         * @return {?}
         */
        AudioService.prototype.getWaveformFromUrl = /**
         * @param {?} url
         * @return {?}
         */
            function (url) {
                var _this = this;
                // if audio context is not support return a stream of empty data
                if (!((window)).AudioContext) {
                    return of.of([new Float32Array(0)]);
                }
                this._audioContext = new AudioContext();
                this.createVolumeNode();
                this.createAnalyserNode();
                return Observable.Observable.create(function (observer) {
                    // load the media from the URL provided
                    // load the media from the URL provided
                    _this._http.get(url, { responseType: 'arraybuffer' }).subscribe(function (response) {
                        _this.getAudioBuffer(response).subscribe(function (audioBuffer) {
                            // create the buffer source
                            // create the buffer source
                            _this.createBufferSource(audioBuffer);
                            var /** @type {?} */ dataPoints = [];
                            var /** @type {?} */ channels = _this._audioBuffer.numberOfChannels;
                            // extract the data from each channel
                            for (var /** @type {?} */ channelIdx = 0; channelIdx < channels; channelIdx++) {
                                dataPoints[channelIdx] = _this._audioBuffer.getChannelData(channelIdx);
                            }
                            observer.next(dataPoints);
                            observer.complete();
                            // cleanup after ourselves
                            dataPoints = null;
                        }, function (error) { return observer.error(error); });
                    }, function (error) { return observer.error(error); });
                });
            };
        /**
         * @param {?=} channels
         * @param {?=} skip
         * @return {?}
         */
        AudioService.prototype.getWaveformPoints = /**
         * @param {?=} channels
         * @param {?=} skip
         * @return {?}
         */
            function (channels, skip) {
                if (channels === void 0) {
                    channels = [];
                }
                if (skip === void 0) {
                    skip = 1000;
                }
                var /** @type {?} */ waveform = [];
                var /** @type {?} */ duration = channels.length > 0 ? channels[0].length : 0;
                var _loop_1 = function (idx) {
                    // get all the channel data for a specific point
                    var /** @type {?} */ points = channels.map(function (channel) { return channel[idx]; });
                    // find the minimum point and maximum points at each position across all channels
                    waveform.push({
                        min: points.reduce(function (previous, current) { return current < previous ? current : previous; }),
                        max: points.reduce(function (previous, current) { return current > previous ? current : previous; })
                    });
                };
                // convert each channel data to a series of waveform points
                for (var /** @type {?} */ idx = 0; idx < duration; idx += skip) {
                    _loop_1(idx);
                }
                return waveform;
            };
        /**
         * @param {?} arrayBuffer
         * @return {?}
         */
        AudioService.prototype.getAudioBuffer = /**
         * @param {?} arrayBuffer
         * @return {?}
         */
            function (arrayBuffer) {
                var _this = this;
                return Observable.Observable.create(function (observer) {
                    _this.getOfflineAudioContext().decodeAudioData(arrayBuffer, function (audioBuffer) {
                        observer.next(audioBuffer);
                        observer.complete();
                    }, function (error) { return observer.error(error); });
                });
            };
        /**
         * @return {?}
         */
        AudioService.prototype.getOfflineAudioContext = /**
         * @return {?}
         */
            function () {
                return new OfflineAudioContext(1, 2, this._audioContext.sampleRate || 44100);
            };
        /**
         * @param {?} audioBuffer
         * @return {?}
         */
        AudioService.prototype.createBufferSource = /**
         * @param {?} audioBuffer
         * @return {?}
         */
            function (audioBuffer) {
                this.disconnectSource();
                this._audioBuffer = audioBuffer;
                this._audioBufferSource = this._audioContext.createBufferSource();
                this._audioBufferSource.buffer = this._audioBuffer;
                this._audioBufferSource.connect(this._analyserNode);
            };
        /**
         * @return {?}
         */
        AudioService.prototype.createVolumeNode = /**
         * @return {?}
         */
            function () {
                this._gainNode = this._audioContext.createGain();
                this._gainNode.connect(this._audioContext.destination);
            };
        /**
         * @return {?}
         */
        AudioService.prototype.createAnalyserNode = /**
         * @return {?}
         */
            function () {
                this._analyserNode = this._audioContext.createAnalyser();
                this._analyserNode.connect(this._gainNode);
            };
        /**
         * @return {?}
         */
        AudioService.prototype.disconnectSource = /**
         * @return {?}
         */
            function () {
                if (this._audioBufferSource) {
                    this._audioBufferSource.disconnect();
                }
            };
        AudioService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        AudioService.ctorParameters = function () {
            return [
                { type: http.HttpClient }
            ];
        };
        return AudioService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AudioServiceModule = (function () {
        function AudioServiceModule() {
        }
        AudioServiceModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [http.HttpClientModule],
                        providers: [AudioService]
                    },] }
        ];
        return AudioServiceModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MediaPlayerComponent = (function () {
        function MediaPlayerComponent(mediaPlayerService, _audioService, _elementRef) {
            var _this = this;
            this.mediaPlayerService = mediaPlayerService;
            this._audioService = _audioService;
            this._elementRef = _elementRef;
            this.hovering = false;
            this.focused = false;
            this.crossorigin = 'use-credentials';
            this._onDestroy = new Subject.Subject();
            // show controls when hovering and in quiet mode
            fromEvent.fromEvent(this._elementRef.nativeElement, 'mousemove').pipe(operators.tap(function () { return _this.hovering = true; }), operators.debounceTime(2000), operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.hovering = false; });
        }
        Object.defineProperty(MediaPlayerComponent.prototype, "source", {
            get: /**
             * @return {?}
             */ function () {
                return this.mediaPlayerService.source;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.mediaPlayerService.source = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerComponent.prototype, "type", {
            get: /**
             * @return {?}
             */ function () {
                return this.mediaPlayerService.type;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.mediaPlayerService.type = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MediaPlayerComponent.prototype, "quietMode", {
            get: /**
             * @return {?}
             */ function () {
                return this.mediaPlayerService.quietMode;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.mediaPlayerService.quietMode = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        MediaPlayerComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.mediaPlayerService.setMediaPlayer(this._elementRef.nativeElement, this._playerRef.nativeElement);
                this.audioMetadata = this._audioService.getAudioFileMetadata(this._playerRef.nativeElement);
                this.mediaPlayerService.playingEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.mediaPlayerService.playing.next(true); });
                this.mediaPlayerService.pauseEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.mediaPlayerService.playing.next(false); });
                this.mediaPlayerService.mediaClickEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.mediaPlayerService.togglePlay(); });
                this.mediaPlayerService.loadedMetadataEvent.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.mediaPlayerService.loaded = true; });
                // initially hide all text tracks
                this.mediaPlayerService.hideSubtitleTracks();
            };
        /**
         * @return {?}
         */
        MediaPlayerComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        MediaPlayerComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-media-player',
                        template: "<div class=\"player-container\"\n     tabindex=\"0\"\n     aria-label=\"Media Player\"\n     i18n-aria-label\n     [cdkTrapFocus]=\"mediaPlayerService.fullscreen\">\n\n    <div class=\"video-player-container\" *ngIf=\"type === 'video'\">\n\n        <video class=\"video-player\"\n            #player\n            tabindex=\"-1\"\n            [src]=\"source\"\n            [crossOrigin]=\"crossorigin\"\n            (abort)=\"mediaPlayerService.abortEvent.next()\"\n            (canplay)=\"mediaPlayerService.canPlayEvent.next(true)\"\n            (canplaythrough)=\"mediaPlayerService.canPlayThroughEvent.next(true)\"\n            (durationchange)=\"mediaPlayerService.durationChangeEvent.next(player.duration)\"\n            (ended)=\"mediaPlayerService.endedEvent.next()\"\n            (error)=\"mediaPlayerService.errorEvent.next($event)\"\n            (loadeddata)=\"mediaPlayerService.loadedDataEvent.next($event)\"\n            (loadedmetadata)=\"mediaPlayerService.loadedMetadataEvent.next($event)\"\n            (loadstart)=\"mediaPlayerService.loadStartEvent.next()\"\n            (pause)=\"mediaPlayerService.pauseEvent.next()\"\n            (play)=\"mediaPlayerService.playEvent.next()\"\n            (playing)=\"mediaPlayerService.playingEvent.next(!player.paused)\"\n            (ratechange)=\"mediaPlayerService.rateChangeEvent.next(player.playbackRate)\"\n            (seeked)=\"mediaPlayerService.seekedEvent.next(player.currentTime)\"\n            (seeking)=\"mediaPlayerService.seekingEvent.next(player.currentTime)\"\n            (stalled)=\"mediaPlayerService.stalledEvent.next()\"\n            (suspend)=\"mediaPlayerService.suspendEvent.next()\"\n            (timeupdate)=\"mediaPlayerService.timeUpdateEvent.next(player.currentTime)\"\n            (volumechange)=\"mediaPlayerService.volumeChangeEvent.next(player.volume)\"\n            (waiting)=\"mediaPlayerService.waitingEvent.next()\"\n            (click)=\"mediaPlayerService.mediaClickEvent.next($event)\">\n\n            <ng-content select=\"track\"></ng-content>\n        </video>\n\n        <div class=\"video-overlay\" [class.playing]=\"mediaPlayerService.playing | async\">\n            <svg class=\"play-graphic\" x=\"0px\" y=\"0px\" viewBox=\"0 0 64 64\">\n                <circle class=\"play-circle\" cx=\"32.2\" cy=\"31.8\" r=\"31.8\" />\n                <polygon class=\"play-triangle\" points=\"23,14.1 23,50.8 48.3,32.5\" />\n            </svg>\n        </div>\n\n    </div>\n\n    <div class=\"audio-player\" *ngIf=\"type === 'audio'\">\n\n        <svg width=\"24px\" height=\"24px\" viewBox=\"0 0 24 24\">\n            <g stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\">\n                <g transform=\"translate(-98.000000, -458.000000)\">\n                    <g transform=\"translate(98.000000, 458.000000)\">\n                        <path d=\"M4.5,0.5 L18.0435308,0.5 L23.5,6.22251502 L23.5,23.5 L4.5,23.5 L4.5,0.5 Z\" fill=\"#CCEAE2\"></path>\n                        <path d=\"M4.5,8 L4.5,0.5 L18,0.5 L23.5,6 L23.5,23.5 L18,23.5\" stroke=\"#60798D\" fill=\"#CCEAE2\"></path>\n                        <path d=\"M4,13.5 L0.5,13.5 L0.5,18.5 L4,18.5 L9.5,22.5 L9.5,9.5 L4,13.5 Z\" stroke=\"#60798D\" fill=\"#85D2BE\"></path>\n                        <path d=\"M11.5,12.5137939 C13.7576225,12.5137939 14.5,14.3709236 14.5,16 C14.5,17.6849236 13.7089152,19.5420532 11.5,19.5420532\"\n                            stroke=\"#60798D\"></path>\n                        <path d=\"M11.5,9 C15.8037643,9.04168701 18.5,11.6604805 18.5,16 C18.5,20.3395195 15.8804302,23.0079956 11.5,23\" stroke=\"#60798D\"></path>\n                        <path d=\"M17.5219116,0.761413574 L17.5219116,6 L23,6\" stroke=\"#60798D\" fill=\"#85D2BE\"></path>\n                    </g>\n                </g>\n            </g>\n        </svg>\n\n        <p class=\"audio-file-name\">{{ (audioMetadata | async)?.filename }}</p>\n        <p class=\"audio-file-format\">{{ (audioMetadata | async)?.description }}</p>\n        <p class=\"audio-file-size\">{{ (audioMetadata | async)?.size | fileSize }}</p>\n\n        <audio #player\n            [src]=\"source\"\n            (abort)=\"mediaPlayerService.abortEvent.next()\"\n            (canplay)=\"mediaPlayerService.canPlayEvent.next(true)\"\n            (canplaythrough)=\"mediaPlayerService.canPlayThroughEvent.next(true)\"\n            (durationchange)=\"mediaPlayerService.durationChangeEvent.next(player.duration)\"\n            (ended)=\"mediaPlayerService.endedEvent.next()\"\n            (error)=\"mediaPlayerService.errorEvent.next($event)\"\n            (loadeddata)=\"mediaPlayerService.loadedDataEvent.next($event)\"\n            (loadedmetadata)=\"mediaPlayerService.loadedMetadataEvent.next($event)\"\n            (loadstart)=\"mediaPlayerService.loadStartEvent.next()\"\n            (pause)=\"mediaPlayerService.pauseEvent.next()\"\n            (play)=\"mediaPlayerService.playEvent.next()\"\n            (playing)=\"mediaPlayerService.playingEvent.next(!player.paused)\"\n            (ratechange)=\"mediaPlayerService.rateChangeEvent.next(player.playbackRate)\"\n            (seeked)=\"mediaPlayerService.seekedEvent.next(player.currentTime)\"\n            (seeking)=\"mediaPlayerService.seekingEvent.next(player.currentTime)\"\n            (stalled)=\"mediaPlayerService.stalledEvent.next()\"\n            (suspend)=\"mediaPlayerService.suspendEvent.next()\"\n            (timeupdate)=\"mediaPlayerService.timeUpdateEvent.next(player.currentTime)\"\n            (volumechange)=\"mediaPlayerService.volumeChangeEvent.next(player.volume)\"\n            (waiting)=\"mediaPlayerService.waitingEvent.next()\"\n            (click)=\"mediaPlayerService.mediaClickEvent.next($event)\">\n        </audio>\n    </div>\n\n    <div class=\"control-bar\"\n        (uxFocusWithin)=\"focused = true\"\n        (uxBlurWithin)=\"focused = false\">\n\n        <ux-media-player-timeline></ux-media-player-timeline>\n        <ux-media-player-controls>\n            <ng-content select=\"[uxMediaPlayerCustomControl]\"></ng-content>\n        </ux-media-player-controls>\n    </div>\n</div>",
                        providers: [MediaPlayerService],
                        host: {
                            '(keydown.Space)': 'mediaPlayerService.togglePlay(); $event.preventDefault()',
                            '[class.standard]': '!mediaPlayerService.fullscreen',
                            '[class.fullscreen]': 'mediaPlayerService.fullscreen',
                            '[class.quiet]': 'quietMode && type === "video" || mediaPlayerService.fullscreen',
                            '[class.hover]': 'hovering || focused',
                            '[class.video]': 'type === "video"',
                            '[class.audio]': 'type === "audio"',
                            '(mouseenter)': 'hovering = true',
                            '(mouseleave)': 'hovering = false',
                            '(document:webkitfullscreenchange)': 'mediaPlayerService.fullscreenChange()',
                            '(document:mozfullscreenchange)': 'mediaPlayerService.fullscreenChange()',
                            '(document:MSFullscreenChange)': 'mediaPlayerService.fullscreenChange()'
                        }
                    }] }
        ];
        /** @nocollapse */
        MediaPlayerComponent.ctorParameters = function () {
            return [
                { type: MediaPlayerService },
                { type: AudioService },
                { type: core.ElementRef }
            ];
        };
        MediaPlayerComponent.propDecorators = {
            _playerRef: [{ type: core.ViewChild, args: ['player',] }],
            crossorigin: [{ type: core.Input }],
            source: [{ type: core.Input }],
            type: [{ type: core.Input }],
            quietMode: [{ type: core.Input }]
        };
        return MediaPlayerComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DurationPipe = (function () {
        function DurationPipe() {
        }
        /**
         * @param {?} seconds
         * @return {?}
         */
        DurationPipe.prototype.transform = /**
         * @param {?} seconds
         * @return {?}
         */
            function (seconds) {
                var /** @type {?} */ minutes = Math.floor(seconds / 60);
                var /** @type {?} */ hours = Math.floor(minutes / 60);
                var /** @type {?} */ days = Math.floor(hours / 24);
                hours = hours - (days * 24);
                minutes = minutes - (days * 24 * 60) - (hours * 60);
                seconds = Math.floor(seconds - (days * 24 * 60 * 60) - (hours * 60 * 60) - (minutes * 60));
                if (hours > 0) {
                    return this.pad(hours) + ":" + this.pad(minutes) + ":" + this.pad(seconds);
                }
                else {
                    return this.pad(minutes) + ":" + this.pad(seconds);
                }
            };
        /**
         * @param {?} value
         * @return {?}
         */
        DurationPipe.prototype.pad = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (value < 10) {
                    return "0" + value;
                }
                return value.toString();
            };
        DurationPipe.decorators = [
            { type: core.Pipe, args: [{
                        name: 'duration'
                    },] }
        ];
        return DurationPipe;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var DurationPipeModule = (function () {
        function DurationPipeModule() {
        }
        DurationPipeModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [DurationPipe],
                        declarations: [DurationPipe]
                    },] }
        ];
        return DurationPipeModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FileSizePipe = (function () {
        function FileSizePipe() {
        }
        /**
         * @param {?} value
         * @return {?}
         */
        FileSizePipe.prototype.transform = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                // allow for async values
                if (!value) {
                    return value;
                }
                var /** @type {?} */ units = ['B', 'KB', 'MB', 'GB', 'TB'];
                // calculate the which unit bracket the values should be a part of
                var /** @type {?} */ idx = Math.floor(Math.log(value) / Math.log(1024));
                var /** @type {?} */ formattedValue = value / Math.pow(1024, idx);
                return formattedValue.toFixed(2) + " " + units[idx];
            };
        FileSizePipe.decorators = [
            { type: core.Pipe, args: [{
                        name: 'fileSize'
                    },] }
        ];
        return FileSizePipe;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FileSizePipeModule = (function () {
        function FileSizePipeModule() {
        }
        FileSizePipeModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [FileSizePipe],
                        declarations: [FileSizePipe]
                    },] }
        ];
        return FileSizePipeModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ DECLARATIONS$5 = [
        MediaPlayerComponent,
        MediaPlayerTimelineExtensionComponent,
        MediaPlayerBaseExtensionDirective,
        MediaPlayerControlsExtensionComponent,
        MediaPlayerCustomControlDirective
    ];
    var MediaPlayerModule = (function () {
        function MediaPlayerModule() {
        }
        MediaPlayerModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            FrameExtractionModule,
                            TooltipModule,
                            AudioServiceModule,
                            DurationPipeModule,
                            FileSizePipeModule,
                            SliderModule,
                            AccessibilityModule,
                            a11y.A11yModule,
                            ClickOutsideModule
                        ],
                        exports: DECLARATIONS$5,
                        declarations: DECLARATIONS$5
                    },] }
        ];
        return MediaPlayerModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var NavigationItemComponent = (function () {
        function NavigationItemComponent(_elementRef, _renderer, _parent, _router) {
            var _this = this;
            this._elementRef = _elementRef;
            this._renderer = _renderer;
            this._parent = _parent;
            this._router = _router;
            this.expanded = false;
            this.level = 1;
            this.indentWithoutArrow = true;
            this.level = _parent ? _parent.level + 1 : 1;
            this._navigationEnd = _router.events.pipe(filter.filter(function (event) { return event instanceof router.NavigationEnd; })).subscribe(function (event) {
                // Expand this component if it or a descendant is active.
                // Expand this component if it or a descendant is active.
                _this.expanded = _this.hasActiveLink(_this.link);
            });
        }
        Object.defineProperty(NavigationItemComponent.prototype, "active", {
            get: /**
             * @return {?}
             */ function () {
                if (this.link) {
                    return this._router.isActive(this.link, true);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NavigationItemComponent.prototype, "children", {
            get: /**
             * @return {?}
             */ function () {
                var _this = this;
                return this._children.filter(function (item) { return item !== _this; });
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NavigationItemComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                // Add classes to parent for styling
                var /** @type {?} */ parentListElement = this._elementRef.nativeElement.parentElement;
                if (parentListElement) {
                    var /** @type {?} */ levelClass = this.getLevelClass();
                    if (levelClass.length > 0) {
                        this._renderer.addClass(parentListElement, 'nav');
                        this._renderer.addClass(parentListElement, levelClass);
                    }
                }
            };
        /**
         * @return {?}
         */
        NavigationItemComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // Set 'indentWithoutArrow'
                this.setIndentWithoutArrow();
                // Update 'indentWithoutArrow' in response to changes to children
                this._childrenChanges = this._children.changes.subscribe(function () { return _this.setIndentWithoutArrow(); });
            };
        /**
         * @return {?}
         */
        NavigationItemComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._navigationEnd.unsubscribe();
                this._childrenChanges.unsubscribe();
            };
        /**
         * @param {?} link
         * @return {?}
         */
        NavigationItemComponent.prototype.hasActiveLink = /**
         * @param {?} link
         * @return {?}
         */
            function (link) {
                // If this component has a link, check if it is active.
                if (link && this._router.isActive(link, true)) {
                    return true;
                }
                // If this component has children, check if any of them, or their descendants, are active.
                return this.children.some(function (item) { return item.hasActiveLink(item.link); });
            };
        /**
         * @return {?}
         */
        NavigationItemComponent.prototype.getLevelClass = /**
         * @return {?}
         */
            function () {
                switch (this.level) {
                    case 2:
                        return 'nav-second-level';
                    case 3:
                        return 'nav-third-level';
                    case 4:
                        return 'nav-fourth-level';
                    case 5:
                        return 'nav-fifth-level';
                }
                return '';
            };
        /**
         * @return {?}
         */
        NavigationItemComponent.prototype.setIndentWithoutArrow = /**
         * @return {?}
         */
            function () {
                if (this.children.length > 0) {
                    // If this element has children it will be indented and will have an arrow
                    this.indentWithoutArrow = false;
                }
                else if (this._parent) {
                    // If this element has a parent, indent it if any of its siblings have children
                    this.indentWithoutArrow = !this._parent.children.every(function (item) { return item.children.length === 0; });
                }
                else {
                    // Top-level elements should be indented
                    this.indentWithoutArrow = true;
                }
            };
        NavigationItemComponent.decorators = [
            { type: core.Component, args: [{
                        selector: '[ux-navigation-item]',
                        template: "<a *ngIf=\"link\" [class.has-arrow]=\"children.length > 0\" [class.no-arrow]=\"indentWithoutArrow\" [routerLink]=\"link\">\n    <span>{{header}}</span>\n</a>\n<a *ngIf=\"!link\" (click)=\"expanded = !expanded\" [class.has-arrow]=\"children.length > 0\" [class.no-arrow]=\"indentWithoutArrow\">\n    <span>{{header}}</span>\n</a>\n<ng-content></ng-content>\n",
                        host: {
                            '[class.active]': 'active',
                            '[class.selected]': 'expanded',
                        }
                    }] }
        ];
        /** @nocollapse */
        NavigationItemComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Renderer2 },
                { type: NavigationItemComponent, decorators: [{ type: core.Optional }, { type: core.SkipSelf }] },
                { type: router.Router }
            ];
        };
        NavigationItemComponent.propDecorators = {
            header: [{ type: core.Input }],
            icon: [{ type: core.Input }],
            expanded: [{ type: core.Input }],
            link: [{ type: core.Input }],
            _children: [{ type: core.ContentChildren, args: [NavigationItemComponent, { descendants: true },] }]
        };
        return NavigationItemComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var NavigationService = (function () {
        function NavigationService() {
            this.autoCollapse = true;
        }
        /**
         * @param {?} source
         * @param {?} expanded
         * @return {?}
         */
        NavigationService.prototype.setExpanded = /**
         * @param {?} source
         * @param {?} expanded
         * @return {?}
         */
            function (source, expanded) {
                if (expanded && this.autoCollapse) {
                    this.collapseSiblings(source);
                }
            };
        /**
         * @param {?} source
         * @return {?}
         */
        NavigationService.prototype.collapseSiblings = /**
         * @param {?} source
         * @return {?}
         */
            function (source) {
                var /** @type {?} */ siblings = this.items;
                try {
                    for (var _a = __values(this.items), _b = _a.next(); !_b.done; _b = _a.next()) {
                        var item = _b.value;
                        var /** @type {?} */ parent_1 = this.getParent(source, item);
                        if (parent_1) {
                            siblings = parent_1.children;
                            break;
                        }
                    }
                }
                catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                }
                finally {
                    try {
                        if (_b && !_b.done && (_c = _a.return))
                            _c.call(_a);
                    }
                    finally {
                        if (e_1)
                            throw e_1.error;
                    }
                }
                try {
                    for (var siblings_1 = __values(siblings), siblings_1_1 = siblings_1.next(); !siblings_1_1.done; siblings_1_1 = siblings_1.next()) {
                        var item = siblings_1_1.value;
                        if (item !== source) {
                            this.collapseAll(item);
                        }
                    }
                }
                catch (e_2_1) {
                    e_2 = { error: e_2_1 };
                }
                finally {
                    try {
                        if (siblings_1_1 && !siblings_1_1.done && (_d = siblings_1.return))
                            _d.call(siblings_1);
                    }
                    finally {
                        if (e_2)
                            throw e_2.error;
                    }
                }
                var e_1, _c, e_2, _d;
            };
        /**
         * @param {?} item
         * @return {?}
         */
        NavigationService.prototype.collapseAll = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                item.expanded = false;
                if (item.children) {
                    try {
                        for (var _a = __values(item.children), _b = _a.next(); !_b.done; _b = _a.next()) {
                            var child = _b.value;
                            this.collapseAll(child);
                        }
                    }
                    catch (e_3_1) {
                        e_3 = { error: e_3_1 };
                    }
                    finally {
                        try {
                            if (_b && !_b.done && (_c = _a.return))
                                _c.call(_a);
                        }
                        finally {
                            if (e_3)
                                throw e_3.error;
                        }
                    }
                }
                var e_3, _c;
            };
        /**
         * @param {?} target
         * @param {?} item
         * @return {?}
         */
        NavigationService.prototype.getParent = /**
         * @param {?} target
         * @param {?} item
         * @return {?}
         */
            function (target, item) {
                if (item.children) {
                    try {
                        for (var _a = __values(item.children), _b = _a.next(); !_b.done; _b = _a.next()) {
                            var child = _b.value;
                            if (child === target) {
                                return item;
                            }
                        }
                    }
                    catch (e_4_1) {
                        e_4 = { error: e_4_1 };
                    }
                    finally {
                        try {
                            if (_b && !_b.done && (_c = _a.return))
                                _c.call(_a);
                        }
                        finally {
                            if (e_4)
                                throw e_4.error;
                        }
                    }
                }
                return null;
                var e_4, _c;
            };
        NavigationService.decorators = [
            { type: core.Injectable }
        ];
        return NavigationService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var NavigationLinkDirective = (function () {
        function NavigationLinkDirective(_router, _locationStrategy, _navigationService) {
            this._router = _router;
            this._locationStrategy = _locationStrategy;
            this._navigationService = _navigationService;
            this.ariaExpanded = 'undefined';
            this._expanded$ = new Subject.Subject();
            this._onDestroy = new Subject.Subject();
        }
        Object.defineProperty(NavigationLinkDirective.prototype, "expanded", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._expanded$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        NavigationLinkDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this._expanded$.pipe(operators.takeUntil(this._onDestroy), tick()).subscribe(function (expanded) {
                    if (_this.navigationItem.children && _this.navigationItem.children.length > 0) {
                        _this.ariaExpanded = "" + expanded;
                        _this._navigationService.setExpanded(_this.navigationItem, expanded);
                    }
                });
                this._router.events
                    .pipe(operators.filter(function (event) { return event instanceof router.NavigationEnd; }), operators.takeUntil(this._onDestroy))
                    .subscribe(this.updateNavigationState.bind(this));
                this.updateNavigationState();
                this.updateAttributes();
            };
        /**
         * @return {?}
         */
        NavigationLinkDirective.prototype.ngOnChanges = /**
         * @return {?}
         */
            function () {
                this.updateAttributes();
            };
        /**
         * @return {?}
         */
        NavigationLinkDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        NavigationLinkDirective.prototype.activated = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this.navigationItem.routerLink) {
                    var /** @type {?} */ commands = Array.isArray(this.navigationItem.routerLink) ? this.navigationItem.routerLink : [this.navigationItem.routerLink];
                    this._router.navigate(commands, this.navigationItem.routerExtras);
                }
                // Toggle expanded state (relevant only if it has children)
                this.navigationItem.expanded = !this.navigationItem.expanded;
                // Invoke the custom click handler if specified
                if (this.navigationItem.click) {
                    this.navigationItem.click(event, this.navigationItem);
                }
                return false;
            };
        /**
         * @return {?}
         */
        NavigationLinkDirective.prototype.updateNavigationState = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.isActive = this.isActiveItem(this.navigationItem);
                if (this.navigationItem.children) {
                    var /** @type {?} */ activeChild = this.navigationItem.children.find(function (child) { return _this.isActiveItem(child); });
                    if (activeChild) {
                        this.navigationItem.expanded = true;
                    }
                }
            };
        /**
         * @return {?}
         */
        NavigationLinkDirective.prototype.updateAttributes = /**
         * @return {?}
         */
            function () {
                this.href = this.getHref();
                this.role = (this.navigationItem.children && this.navigationItem.children.length > 0) ? 'button' : 'treeitem';
                this.indentChildren = this.navigationItem.children && this.navigationItem.children.some(function (item) { return item.children && item.children.length > 0; });
            };
        /**
         * @return {?}
         */
        NavigationLinkDirective.prototype.getHref = /**
         * @return {?}
         */
            function () {
                if (this.navigationItem.routerLink) {
                    var /** @type {?} */ commands = Array.isArray(this.navigationItem.routerLink) ? this.navigationItem.routerLink : [this.navigationItem.routerLink];
                    var /** @type {?} */ urlTree = this._router.createUrlTree(commands, this.navigationItem.routerExtras);
                    return this._locationStrategy.prepareExternalUrl(this._router.serializeUrl(urlTree));
                }
                return null;
            };
        /**
         * @param {?} item
         * @return {?}
         */
        NavigationLinkDirective.prototype.isActiveItem = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                if (item.routerLink) {
                    var /** @type {?} */ commands = Array.isArray(item.routerLink) ? item.routerLink : [item.routerLink];
                    var /** @type {?} */ urlTree = this._router.createUrlTree(commands, item.routerExtras);
                    return this._router.isActive(urlTree, true);
                }
                return false;
            };
        NavigationLinkDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxNavigationLink]',
                        exportAs: 'uxNavigationLink'
                    },] }
        ];
        /** @nocollapse */
        NavigationLinkDirective.ctorParameters = function () {
            return [
                { type: router.Router },
                { type: common.LocationStrategy },
                { type: NavigationService }
            ];
        };
        NavigationLinkDirective.propDecorators = {
            navigationItem: [{ type: core.Input }],
            expanded: [{ type: core.Input }],
            canExpand: [{ type: core.Input }],
            indent: [{ type: core.Input }, { type: core.HostBinding, args: ['class.indent',] }],
            href: [{ type: core.HostBinding, args: ['attr.href',] }],
            role: [{ type: core.HostBinding, args: ['attr.role',] }],
            ariaExpanded: [{ type: core.HostBinding, args: ['attr.aria-expanded',] }],
            activated: [{ type: core.HostListener, args: ['click', ['$event'],] }, { type: core.HostListener, args: ['keydown.enter', ['$event'],] }]
        };
        return NavigationLinkDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var NavigationComponent = (function () {
        function NavigationComponent(_navigationService) {
            this._navigationService = _navigationService;
            /**
             * Whether to present the menu as a hierarchical tree.
             */
            this.tree = true;
            this.hierarchyClasses = [
                '',
                'nav-second-level',
                'nav-third-level',
                'nav-fourth-level',
                'nav-fifth-level',
            ];
        }
        Object.defineProperty(NavigationComponent.prototype, "items", {
            get: /**
             * @return {?}
             */ function () {
                return this._navigationService.items;
            },
            /** The navigation items to populate the menu with. */
            set: /**
             * The navigation items to populate the menu with.
             * @param {?} items
             * @return {?}
             */ function (items) {
                this._navigationService.items = items;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NavigationComponent.prototype, "autoCollapse", {
            /** Whether to collapse other menu items when expanding a menu item. */
            set: /**
             * Whether to collapse other menu items when expanding a menu item.
             * @param {?} autoCollapse
             * @return {?}
             */ function (autoCollapse) {
                this._navigationService.autoCollapse = autoCollapse;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NavigationComponent.prototype, "depthLimit", {
            get: /**
             * @return {?}
             */ function () {
                return this.tree ? this.hierarchyClasses.length : 2;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} item
         * @param {?} event
         * @return {?}
         */
        NavigationComponent.prototype.itemClick = /**
         * @param {?} item
         * @param {?} event
         * @return {?}
         */
            function (item, event) {
                // Toggle expanded state (relevant only if it has children)
                item.expanded = !item.expanded;
                // Invoke the custom click handler if specified
                if (item.click) {
                    item.click(event, item);
                }
            };
        /**
         * Returns true if the sets of items needs to be indented to make room for one or more expander.
         */
        /**
         * Returns true if the sets of items needs to be indented to make room for one or more expander.
         * @param {?} items
         * @return {?}
         */
        NavigationComponent.prototype.needsIndent = /**
         * Returns true if the sets of items needs to be indented to make room for one or more expander.
         * @param {?} items
         * @return {?}
         */
            function (items) {
                return items && items.some(function (item) { return item.children && item.children.length > 0; });
            };
        NavigationComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-navigation',
                        template: "<nav class=\"ux-side-nav\" [class.tree]=\"tree\" role=\"navigation\">\n\n    <ol *ngIf=\"items\" role=\"tree\" class=\"nav\" uxTabbableList [hierarchy]=\"true\">\n\n        <ng-container *ngFor=\"let item of items; let rank = index\"\n            [ngTemplateOutlet]=\"navigationNode\"\n            [ngTemplateOutletContext]=\"{item: item, level: 1, rank: rank, indent: needsIndent(items)}\">\n        </ng-container>\n\n        <ng-template #navigationNode let-item=\"item\" let-parent=\"parent\" let-level=\"level\" let-rank=\"rank\" let-indent=\"indent\">\n\n            <li [attr.role]=\"(item.children && item.children.length > 0) ? 'treeitem' : 'none'\"\n                [attr.aria-expanded]=\"item.expanded\"\n                [class.selected]=\"item.expanded\"\n                [class.active]=\"navigationLink.isActive\">\n\n                <a uxNavigationLink\n                    #navigationLink=\"uxNavigationLink\"\n                    [navigationItem]=\"item\"\n                    [expanded]=\"item.expanded\"\n                    [canExpand]=\"level < depthLimit\"\n                    [indent]=\"indent\"\n                    uxTabbableListItem\n                    #tli=\"ux-tabbable-list-item\"\n                    [parent]=\"parent\"\n                    [rank]=\"rank\"\n                    [(expanded)]=\"item.expanded\">\n\n                    <span *ngIf=\"!navigationItemTemplate && item.children && item.children.length > 0 && level < depthLimit\"\n                        aria-hidden=\"true\"\n                        class=\"nav-expander\"\n                        (click)=\"item.expanded = !item.expanded; $event.stopPropagation(); $event.preventDefault()\">\n                    </span>\n                    <span *ngIf=\"!navigationItemTemplate && item.icon && !tree\" class=\"nav-icon hpe-icon\" [ngClass]=\"item.icon\"></span>\n                    <img *ngIf=\"!navigationItemTemplate && item.iconUrl && !tree\" class=\"nav-icon\" [src]=\"item.iconUrl\" alt=\"item.iconLabel\">\n                    <span *ngIf=\"!navigationItemTemplate\" class=\"nav-title\">{{item.title}}</span>\n\n                    <ng-container [ngTemplateOutlet]=\"navigationItemTemplate\"\n                        [ngTemplateOutletContext]=\"{item: item, level: level}\">\n                    </ng-container>\n\n                </a>\n\n                <ol *ngIf=\"item.children && item.expanded && level < depthLimit\"\n                    role=\"group\" class=\"nav\" [ngClass]=\"hierarchyClasses[level]\">\n\n                    <ng-container *ngFor=\"let child of item.children; let rank = index\"\n                        [ngTemplateOutlet]=\"navigationNode\"\n                        [ngTemplateOutletContext]=\"{item: child, parent: tli, level: level + 1, rank: rank, indent: navigationLink.indentChildren}\">\n                    </ng-container>\n\n                </ol>\n\n            </li>\n\n        </ng-template>\n\n    </ol>\n\n    <!-- Backward compatibility with the original ux-navigation -->\n    <ol *ngIf=\"!items\" role=\"tree\" class=\"nav\">\n        <ng-content></ng-content>\n    </ol>\n\n</nav>\n",
                        providers: [NavigationService]
                    }] }
        ];
        /** @nocollapse */
        NavigationComponent.ctorParameters = function () {
            return [
                { type: NavigationService }
            ];
        };
        NavigationComponent.propDecorators = {
            items: [{ type: core.Input }],
            tree: [{ type: core.Input }],
            autoCollapse: [{ type: core.Input }],
            navigationItemTemplate: [{ type: core.ContentChild, args: ['uxNavigationItem',] }]
        };
        return NavigationComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var NavigationModule = (function () {
        function NavigationModule() {
        }
        NavigationModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            AccessibilityModule,
                            common.CommonModule,
                            router.RouterModule
                        ],
                        exports: [
                            NavigationComponent,
                            NavigationItemComponent
                        ],
                        declarations: [
                            NavigationComponent,
                            NavigationItemComponent,
                            NavigationLinkDirective
                        ]
                    },] }
        ];
        return NavigationModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var NotificationService = (function () {
        function NotificationService(_colorService) {
            this._colorService = _colorService;
            // provide default options
            this.options = {
                duration: 4,
                height: 100,
                spacing: 10,
                backgroundColor: this._colorService.getColor('accent').toHex(),
                iconColor: this._colorService.getColor('accent').toHex()
            };
            this.direction = 'above';
            this.notifications$ = new BehaviorSubject.BehaviorSubject([]);
        }
        /**
         * @param {?} templateRef
         * @param {?=} options
         * @param {?=} data
         * @return {?}
         */
        NotificationService.prototype.show = /**
         * @param {?} templateRef
         * @param {?=} options
         * @param {?=} data
         * @return {?}
         */
            function (templateRef, options, data) {
                var _this = this;
                if (options === void 0) {
                    options = this.options;
                }
                if (data === void 0) {
                    data = {};
                }
                options = __assign({}, this.options, options);
                var /** @type {?} */ notificationRef = {
                    templateRef: templateRef,
                    duration: options.duration,
                    date: new Date(),
                    visible: true,
                    height: options.height,
                    spacing: options.spacing,
                    backgroundColor: options.backgroundColor,
                    iconColor: options.iconColor,
                    data: data
                };
                var /** @type {?} */ notifications = this.notifications$.getValue();
                if (this.direction === 'above') {
                    notifications.unshift(notificationRef);
                }
                else {
                    notifications.push(notificationRef);
                }
                this.notifications$.next(notifications);
                // remove notification after delay
                if (options.duration !== 0) {
                    setTimeout(function () { return _this.dismiss(notificationRef); }, options.duration * 1000);
                }
                return notificationRef;
            };
        /**
         * @return {?}
         */
        NotificationService.prototype.getHistory = /**
         * @return {?}
         */
            function () {
                return this.notifications$.getValue();
            };
        /**
         * @param {?} notificationRef
         * @return {?}
         */
        NotificationService.prototype.dismiss = /**
         * @param {?} notificationRef
         * @return {?}
         */
            function (notificationRef) {
                notificationRef.visible = false;
                this.notifications$.next(this.notifications$.getValue());
            };
        /**
         * @return {?}
         */
        NotificationService.prototype.dismissAll = /**
         * @return {?}
         */
            function () {
                this.notifications$.getValue().forEach(function (notificationRef) { return notificationRef.visible = false; });
                this.notifications$.next(this.notifications$.getValue());
            };
        NotificationService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        NotificationService.ctorParameters = function () {
            return [
                { type: ColorService }
            ];
        };
        return NotificationService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var NotificationListComponent = (function () {
        function NotificationListComponent(_notificationService) {
            this._notificationService = _notificationService;
            this.position = 'top-right';
            this.notifications$ = this._notificationService.notifications$.pipe(operators.map(function (notificationRefs) { return notificationRefs.filter(function (notificationRef) { return notificationRef.visible; }); }));
        }
        Object.defineProperty(NotificationListComponent.prototype, "direction", {
            set: /**
             * @param {?} direction
             * @return {?}
             */ function (direction) {
                this._notificationService.direction = direction;
            },
            enumerable: true,
            configurable: true
        });
        NotificationListComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-notification-list',
                        template: "<div class=\"notification\" *ngFor=\"let notificationRef of notifications$ | async; let idx = index\"\r\n    [style.top.px]=\"(notificationRef.height + notificationRef.spacing) * idx\"\r\n    [style.height.px]=\"notificationRef.height\"\r\n    [style.background-color]=\"notificationRef.backgroundColor\"\r\n    [@notificationState]>\r\n    <ng-container *ngTemplateOutlet=\"notificationRef.templateRef; context: { $implicit: notificationRef, data: notificationRef.data }\"></ng-container>\r\n</div>\r\n",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        animations: [
                            animations.trigger('notificationState', [
                                animations.state('in', animations.style({ transform: 'translateY(0)', opacity: 0.9 })),
                                animations.transition(':enter', [
                                    animations.style({ transform: 'translateY(-50px)', opacity: 0 }),
                                    animations.animate(500)
                                ]),
                                animations.transition(':leave', [
                                    animations.animate(500, animations.style({ transform: 'translateY(50px)', opacity: 0 }))
                                ])
                            ])
                        ]
                    }] }
        ];
        /** @nocollapse */
        NotificationListComponent.ctorParameters = function () {
            return [
                { type: NotificationService }
            ];
        };
        NotificationListComponent.propDecorators = {
            direction: [{ type: core.Input }],
            position: [{ type: core.Input }, { type: core.HostBinding, args: ['class',] }]
        };
        return NotificationListComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var NotificationModule = (function () {
        function NotificationModule() {
        }
        NotificationModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            ColorServiceModule
                        ],
                        exports: [
                            NotificationListComponent
                        ],
                        declarations: [
                            NotificationListComponent
                        ],
                        providers: [
                            NotificationService
                        ]
                    },] }
        ];
        return NotificationModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PageHeaderCustomMenuDirective = (function () {
        function PageHeaderCustomMenuDirective() {
        }
        PageHeaderCustomMenuDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxPageHeaderCustomMenu]'
                    },] }
        ];
        return PageHeaderCustomMenuDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PageHeaderService = (function () {
        function PageHeaderService(_router) {
            var _this = this;
            this._router = _router;
            this.items$ = new BehaviorSubject.BehaviorSubject([]);
            this.selected$ = new BehaviorSubject.BehaviorSubject(null);
            this.selectedRoot$ = new BehaviorSubject.BehaviorSubject(null);
            this.secondary$ = new BehaviorSubject.BehaviorSubject(false);
            this.activeIconMenu$ = new BehaviorSubject.BehaviorSubject(null);
            this.secondaryNavigationAutoselect = false;
            this._onDestroy = new Subject.Subject();
            this.selected$
                .pipe(operators.takeUntil(this._onDestroy), operators.map(function (selected) { return _this.getRoot(selected); }))
                .subscribe(function (root) { return _this.selectedRoot$.next(root); });
            this._router.events
                .pipe(operators.takeUntil(this._onDestroy), operators.filter(function (e) { return e instanceof router.NavigationEnd; }))
                .subscribe(this.updateItemsWithActiveRoute.bind(this));
        }
        /**
         * @return {?}
         */
        PageHeaderService.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @param {?} item
         * @return {?}
         */
        PageHeaderService.prototype.select = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                if (!item) {
                    return;
                }
                if (item.routerLink) {
                    // Trigger router navigation
                    var /** @type {?} */ routerLink = Array.isArray(item.routerLink) ? item.routerLink : [item.routerLink];
                    this._router.navigate(routerLink, item.routerExtras);
                }
                else if (this.secondaryNavigationAutoselect && item.children && item.children.length > 0) {
                    // Select the first child in secondaryNavigationAutoselect mode
                    this.select(item.children[0]);
                }
                else {
                    // if we are in secondary navigation mode and we click a parent - dont deselect the child
                    if (this.secondary$.getValue() === true && this.isParentOf(this.selected$.getValue(), item)) {
                        return;
                    }
                    // Otherwise select the given item
                    this.selected$.next(item);
                }
            };
        /**
         * @param {?} item
         * @return {?}
         */
        PageHeaderService.prototype.deselect = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                var _this = this;
                // deselect the current item
                item.selected = false;
                // iterate any children and deselect them
                if (item.children) {
                    item.children.forEach(function (_item) { return _this.deselect(_item); });
                }
            };
        /**
         * @return {?}
         */
        PageHeaderService.prototype.deselectAll = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.items$.getValue().forEach(function (item) { return _this.deselect(item); });
            };
        /**
         * @param {?} item
         * @param {?} selected
         * @return {?}
         */
        PageHeaderService.prototype.updateItem = /**
         * @param {?} item
         * @param {?} selected
         * @return {?}
         */
            function (item, selected) {
                // Item is selected if it is the selected item, or one of the selected item's ancestors.
                item.selected = item === selected || this.isParentOf(selected, item);
                if (item === selected) {
                    // call the select function if present
                    if (item.select) {
                        item.select.call(item, item);
                    }
                }
            };
        /**
         * @param {?=} items
         * @return {?}
         */
        PageHeaderService.prototype.setItems = /**
         * @param {?=} items
         * @return {?}
         */
            function (items) {
                var _this = this;
                if (items === void 0) {
                    items = [];
                }
                // identify all parent elements
                items.forEach(function (item) { return _this.setParent(item); });
                this.items$.next(items);
                // Set up the initally selected item
                // If nothing is set as selected, using the initial route
                var /** @type {?} */ initialSelectedItem = items.find(function (item) { return item.selected === true; });
                if (initialSelectedItem) {
                    this.select(initialSelectedItem);
                }
                else {
                    this.updateItemsWithActiveRoute();
                }
            };
        /**
         * @param {?} enabled
         * @return {?}
         */
        PageHeaderService.prototype.setSecondaryNavigation = /**
         * @param {?} enabled
         * @return {?}
         */
            function (enabled) {
                this.secondary$.next(enabled);
            };
        /**
         * @param {?} item
         * @return {?}
         */
        PageHeaderService.prototype.getRoot = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                return item && item.parent ? this.getRoot(item.parent) : item;
            };
        /**
         * @param {?} item
         * @param {?=} parent
         * @return {?}
         */
        PageHeaderService.prototype.setParent = /**
         * @param {?} item
         * @param {?=} parent
         * @return {?}
         */
            function (item, parent) {
                var _this = this;
                // set the parent field
                item.parent = parent;
                // call this function recursively on all children
                if (item.children) {
                    item.children.forEach(function (child) { return _this.setParent(child, item); });
                }
            };
        /**
         * @param {?} node
         * @param {?} parent
         * @return {?}
         */
        PageHeaderService.prototype.isParentOf = /**
         * @param {?} node
         * @param {?} parent
         * @return {?}
         */
            function (node, parent) {
                // if there are no parents return false
                if (!node || !node.parent) {
                    return false;
                }
                // if the parent is the match we are looking for return true
                if (node.parent === parent) {
                    return true;
                }
                // if there are potentially grandparents then check them too
                return this.isParentOf(node.parent, parent);
            };
        /**
         * @return {?}
         */
        PageHeaderService.prototype.updateItemsWithActiveRoute = /**
         * @return {?}
         */
            function () {
                var /** @type {?} */ activeItem = new PageHeaderActiveNavigationItem();
                try {
                    for (var _a = __values(this.items$.getValue()), _b = _a.next(); !_b.done; _b = _a.next()) {
                        var item = _b.value;
                        this.findActiveItem(item, activeItem);
                        if (activeItem.exact) {
                            break;
                        }
                    }
                }
                catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                }
                finally {
                    try {
                        if (_b && !_b.done && (_c = _a.return))
                            _c.call(_a);
                    }
                    finally {
                        if (e_1)
                            throw e_1.error;
                    }
                }
                if (activeItem.item) {
                    this.selected$.next(activeItem.item);
                }
                var e_1, _c;
            };
        /**
         * @param {?} item
         * @param {?} activeItem
         * @return {?}
         */
        PageHeaderService.prototype.findActiveItem = /**
         * @param {?} item
         * @param {?} activeItem
         * @return {?}
         */
            function (item, activeItem) {
                if (item.routerLink) {
                    var /** @type {?} */ routerLink = Array.isArray(item.routerLink) ? item.routerLink : [item.routerLink];
                    var /** @type {?} */ urlTree = this._router.createUrlTree(routerLink, item.routerExtras);
                    if (this._router.isActive(urlTree, true) && !activeItem.exact) {
                        // When the item route is an exact match, no need to look any further
                        activeItem.item = item;
                        activeItem.exact = true;
                        return;
                    }
                    if (this._router.isActive(urlTree, false)) {
                        // Store an inexact match and continue looking
                        activeItem.item = item;
                        activeItem.exact = false;
                    }
                }
                if (item.children) {
                    try {
                        for (var _a = __values(item.children), _b = _a.next(); !_b.done; _b = _a.next()) {
                            var childItem = _b.value;
                            this.findActiveItem(childItem, activeItem);
                            if (activeItem.exact) {
                                return;
                            }
                        }
                    }
                    catch (e_2_1) {
                        e_2 = { error: e_2_1 };
                    }
                    finally {
                        try {
                            if (_b && !_b.done && (_c = _a.return))
                                _c.call(_a);
                        }
                        finally {
                            if (e_2)
                                throw e_2.error;
                        }
                    }
                }
                var e_2, _c;
            };
        PageHeaderService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        PageHeaderService.ctorParameters = function () {
            return [
                { type: router.Router }
            ];
        };
        return PageHeaderService;
    }());
    var PageHeaderActiveNavigationItem = (function () {
        function PageHeaderActiveNavigationItem() {
        }
        return PageHeaderActiveNavigationItem;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PageHeaderIconMenuComponent = (function () {
        function PageHeaderIconMenuComponent(_service) {
            var _this = this;
            this._service = _service;
            this._subscription = _service.activeIconMenu$.subscribe(function (next) {
                // Close all but the most recently opened menu
                if (next !== _this.menu) {
                    _this._isOpen = false;
                }
            });
        }
        Object.defineProperty(PageHeaderIconMenuComponent.prototype, "isOpen", {
            get: /**
             * @return {?}
             */ function () {
                return this._isOpen;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._isOpen = value;
                if (value) {
                    this._service.activeIconMenu$.next(this.menu);
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        PageHeaderIconMenuComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @param {?} item
         * @return {?}
         */
        PageHeaderIconMenuComponent.prototype.select = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                if (item.select) {
                    item.select.call(item, item);
                }
            };
        /**
         * @param {?} item
         * @param {?} event
         * @return {?}
         */
        PageHeaderIconMenuComponent.prototype.keydownHandler = /**
         * @param {?} item
         * @param {?} event
         * @return {?}
         */
            function (item, event) {
                switch (event.key) {
                    case 'Enter':
                    case ' ':
                        this.select(item);
                        this.isOpen = false;
                        this.menuNavigationToggle.focus();
                        event.preventDefault();
                        event.stopPropagation();
                        break;
                }
            };
        PageHeaderIconMenuComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-page-header-icon-menu',
                        template: "<div class=\"page-header-icon-menu\"\n    dropdown\n    placement=\"bottom right\"\n    [(isOpen)]=\"isOpen\">\n\n    <a role=\"button\"\n        class=\"page-header-icon-menu-button\"\n        [attr.aria-label]=\"menu.label\"\n        aria-haspopup=\"true\"\n        tabindex=\"0\"\n        (click)=\"select(menu)\"\n        dropdownToggle\n        uxMenuNavigationToggle\n        #menuNavigationToggle=\"uxMenuNavigationToggle\"\n        [(menuOpen)]=\"isOpen\">\n\n        <i class=\"hpe-icon\" [ngClass]=\"menu.icon\"></i>\n        <span class=\"label label-primary\" *ngIf=\"menu?.badge\" aria-hidden=\"true\">{{ menu.badge }}</span>\n\n    </a>\n\n    <ul *dropdownMenu\n        class=\"dropdown-menu\"\n        role=\"menu\"\n        uxMenuNavigation\n        [toggleButton]=\"menuNavigationToggle\">\n\n        <li *ngFor=\"let dropdown of menu?.dropdown\"\n            role=\"none\"\n            [class.dropdown-header]=\"dropdown.header\"\n            [class.dropdown-divider]=\"dropdown.divider\">\n\n            <span class=\"font-bold\" *ngIf=\"dropdown.header\">{{ dropdown.title }}</span>\n\n            <a *ngIf=\"!dropdown.header\"\n                role=\"menuitem\"\n                class=\"dropdown-item\"\n                tabindex=\"-1\"\n                (click)=\"select(dropdown)\"\n                (keydown)=\"keydownHandler(dropdown, $event)\"\n                uxMenuNavigationItem>\n\n\n                <span class=\"dropdown-item-title\">\n                    <i class=\"hpe-icon hpe-fw\" [ngClass]=\"dropdown.icon\"></i>\n                    {{ dropdown.title }}\n                </span>\n                <span *ngIf=\"dropdown.subtitle\" class=\"dropdown-item-subtitle\">{{ dropdown.subtitle }}</span>\n\n            </a>\n        </li>\n\n    </ul>\n</div>"
                    }] }
        ];
        /** @nocollapse */
        PageHeaderIconMenuComponent.ctorParameters = function () {
            return [
                { type: PageHeaderService }
            ];
        };
        PageHeaderIconMenuComponent.propDecorators = {
            menu: [{ type: core.Input }],
            menuNavigationToggle: [{ type: core.ViewChild, args: ['menuNavigationToggle',] }]
        };
        return PageHeaderIconMenuComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PageHeaderNavigationDropdownItemComponent = (function () {
        function PageHeaderNavigationDropdownItemComponent(_pageHeaderService) {
            var _this = this;
            this._pageHeaderService = _pageHeaderService;
            this.dropdownOpen = false;
            this._hover$ = new Subject.Subject();
            // subscribe to stream with a debounce (a small debounce is all that is required)
            this._subscription = this._hover$.pipe(operators.debounceTime(1)).subscribe(function (visible) { return _this.dropdownOpen = visible; });
            // Close submenus when selected item changes
            this._subscription.add(_pageHeaderService.selected$.subscribe(function () {
                _this.dropdownOpen = false;
            }));
        }
        /**
         * @return {?}
         */
        PageHeaderNavigationDropdownItemComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @param {?} item
         * @return {?}
         */
        PageHeaderNavigationDropdownItemComponent.prototype.select = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                // clicking on an item with children then return
                if (item.children) {
                    return;
                }
                // emit the selected item in an event
                this._pageHeaderService.select(item);
            };
        /**
         * @return {?}
         */
        PageHeaderNavigationDropdownItemComponent.prototype.focus = /**
         * @return {?}
         */
            function () {
                this.button.nativeElement.focus();
            };
        /**
         * @return {?}
         */
        PageHeaderNavigationDropdownItemComponent.prototype.hoverStart = /**
         * @return {?}
         */
            function () {
                this._hover$.next(true);
            };
        /**
         * @return {?}
         */
        PageHeaderNavigationDropdownItemComponent.prototype.hoverLeave = /**
         * @return {?}
         */
            function () {
                this._hover$.next(false);
            };
        /**
         * @return {?}
         */
        PageHeaderNavigationDropdownItemComponent.prototype.close = /**
         * @return {?}
         */
            function () {
                this.dropdownOpen = false;
            };
        /**
         * @param {?} event
         * @param {?} item
         * @return {?}
         */
        PageHeaderNavigationDropdownItemComponent.prototype.keydownHandler = /**
         * @param {?} event
         * @param {?} item
         * @return {?}
         */
            function (event, item) {
                switch (event.key) {
                    case 'Enter':
                    case ' ':
                        this.select(item);
                        event.preventDefault();
                        event.stopPropagation();
                        break;
                }
            };
        PageHeaderNavigationDropdownItemComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-page-header-horizontal-navigation-dropdown-item',
                        exportAs: 'ux-page-header-horizontal-navigation-dropdown-item',
                        template: "<div *ngIf=\"item.children && item.children.length > 0\"\n    dropdown\n    #subMenu=\"bs-dropdown\"\n    [isOpen]=\"dropdownOpen\"\n    container=\"body\"\n    placement=\"right\"\n    (mouseenter)=\"hoverStart()\"\n    (mouseleave)=\"hoverLeave()\">\n\n    <a role=\"menuitem\"\n        class=\"dropdown-item\"\n        [class.selected]=\"item.selected\"\n        aria-haspopup=\"true\"\n        [attr.aria-expanded]=\"dropdownOpen\"\n        [attr.aria-selected]=\"item.selected\"\n        tabindex=\"-1\"\n        #button\n        dropdownToggle\n        uxMenuNavigationToggle\n        #menuNavigationToggle=\"uxMenuNavigationToggle\"\n        [(menuOpen)]=\"dropdownOpen\"\n        menuPosition=\"right\">\n\n        <span class=\"dropdown-item-title\">{{ item.title }}</span>\n        <span class=\"dropdown-item-icon hpe-icon hpe-next\"></span>\n\n    </a>\n\n    <ul *dropdownMenu\n        role=\"menu\"\n        class=\"dropdown-menu horizontal-navigation-dropdown-submenu\"\n        (mouseenter)=\"hoverStart()\"\n        (mouseleave)=\"hoverLeave()\"\n        uxMenuNavigation\n        #menuNavigation=\"uxMenuNavigation\"\n        [toggleButton]=\"menuNavigationToggle\"\n        toggleButtonPosition=\"left\">\n\n        <li *ngFor=\"let subItem of item.children\" role=\"none\">\n\n            <a role=\"menuitem\"\n                class=\"dropdown-item\"\n                [class.selected]=\"subItem.selected\"\n                [attr.aria-selected]=\"subItem.selected\"\n                tabindex=\"-1\"\n                (click)=\"select(subItem)\"\n                (keydown)=\"keydownHandler($event, subItem)\"\n                uxMenuNavigationItem>\n\n                <span class=\"dropdown-item-title\">{{ subItem.title }}</span>\n\n            </a>\n\n        </li>\n    </ul>\n\n</div>\n\n<div *ngIf=\"!item.children || item.children.length === 0\"\n    (mouseenter)=\"hoverStart()\"\n    (mouseleave)=\"hoverLeave()\">\n\n    <a role=\"menuitem\"\n        #button\n        class=\"dropdown-item\"\n        [class.selected]=\"item.selected\"\n        [attr.aria-selected]=\"item.selected\"\n        tabindex=\"-1\"\n        (click)=\"select(item)\"\n        (keydown)=\"keydownHandler($event, item)\">\n\n        <span class=\"dropdown-item-title\">{{ item.title }}</span>\n\n    </a>\n\n</div>"
                    }] }
        ];
        /** @nocollapse */
        PageHeaderNavigationDropdownItemComponent.ctorParameters = function () {
            return [
                { type: PageHeaderService }
            ];
        };
        PageHeaderNavigationDropdownItemComponent.propDecorators = {
            item: [{ type: core.Input }],
            button: [{ type: core.ViewChild, args: ['button',] }]
        };
        return PageHeaderNavigationDropdownItemComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PageHeaderNavigationItemComponent = (function () {
        function PageHeaderNavigationItemComponent(elementRef, _pageHeaderService) {
            this.elementRef = elementRef;
            this._pageHeaderService = _pageHeaderService;
            this.secondary$ = this._pageHeaderService.secondary$;
            this._onDestroy = new Subject.Subject();
        }
        /**
         * @return {?}
         */
        PageHeaderNavigationItemComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this._pageHeaderService.selected$.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (next) {
                    // Update selected state for this item
                    // Update selected state for this item
                    _this._pageHeaderService.updateItem(_this.item, next);
                    if (next && _this.isOpen) {
                        _this.isOpen = false;
                        // If menu was closed, keep focus on the toggle button
                        // If menu was closed, keep focus on the toggle button
                        _this.button.focus();
                    }
                });
                if (this.menu) {
                    this.menu.onHidden
                        .pipe(operators.takeUntil(this._onDestroy))
                        .subscribe(function () { return _this.dropdowns.forEach(function (dropdown$$1) { return dropdown$$1.close(); }); });
                }
            };
        /**
         * @return {?}
         */
        PageHeaderNavigationItemComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @return {?}
         */
        PageHeaderNavigationItemComponent.prototype.select = /**
         * @return {?}
         */
            function () {
                // if the item has children then do nothing at this stage
                if (this.item.children && this._pageHeaderService.secondary$.getValue() === false) {
                    return;
                }
                // otherwise select the current item
                this._pageHeaderService.select(this.item);
            };
        PageHeaderNavigationItemComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-page-header-horizontal-navigation-item',
                        template: "<div *ngIf=\"item.children && item.children.length > 0 && !(secondary$ | async)\"\n    dropdown\n    #menu=\"bs-dropdown\"\n    [(isOpen)]=\"isOpen\"\n    container=\"body\"\n    placement=\"bottom left\">\n\n    <button role=\"menuitem\"\n        class=\"horizontal-navigation-button\"\n        [class.selected]=\"item.selected\"\n        [class.open]=\"isOpen\"\n        aria-haspopup=\"true\"\n        [attr.aria-expanded]=\"isOpen\"\n        [attr.aria-selected]=\"item.selected\"\n        dropdownToggle\n        uxMenuNavigationToggle\n        #button=\"uxMenuNavigationToggle\"\n        [(menuOpen)]=\"isOpen\">\n\n        <span class=\"hpe-icon navigation-item-icon\" *ngIf=\"item.icon\" [ngClass]=\"item?.icon\"></span>\n        <span class=\"navigation-item-label\">{{ item?.title }}</span>\n        <span class=\"hpe-icon hpe-down\"></span>\n\n    </button>\n\n    <div *dropdownMenu\n        role=\"menu\"\n        class=\"dropdown-menu horizontal-navigation-dropdown-menu\"\n        uxMenuNavigation\n        [toggleButton]=\"button\"\n        toggleButtonPosition=\"top\">\n\n        <div *ngFor=\"let item of item?.children\" uxMenuNavigationItem (activated)=\"dropdownItem.focus()\">\n            <ux-page-header-horizontal-navigation-dropdown-item\n                #dropdownItem=\"ux-page-header-horizontal-navigation-dropdown-item\"\n                [item]=\"item\">\n            </ux-page-header-horizontal-navigation-dropdown-item>\n        </div>\n\n    </div>\n\n</div>\n\n<button *ngIf=\"!item.children || item.children.length === 0 || (secondary$ | async)\"\n    role=\"menuitem\"\n    class=\"horizontal-navigation-button\"\n    [class.selected]=\"item.selected\"\n    [attr.aria-selected]=\"item.selected\"\n    (click)=\"select()\">\n\n    <span class=\"hpe-icon navigation-item-icon\" *ngIf=\"item.icon\" [ngClass]=\"item?.icon\"></span>\n    <span class=\"navigation-item-label\">{{ item?.title }}</span>\n\n</button>"
                    }] }
        ];
        /** @nocollapse */
        PageHeaderNavigationItemComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: PageHeaderService }
            ];
        };
        PageHeaderNavigationItemComponent.propDecorators = {
            button: [{ type: core.ViewChild, args: ['button',] }],
            menu: [{ type: core.ViewChild, args: ['menu',] }],
            dropdowns: [{ type: core.ViewChildren, args: [PageHeaderNavigationDropdownItemComponent,] }],
            item: [{ type: core.Input }]
        };
        return PageHeaderNavigationItemComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PageHeaderNavigationSecondaryItemDirective = (function () {
        function PageHeaderNavigationSecondaryItemDirective(_pageHeaderService) {
            this._pageHeaderService = _pageHeaderService;
            this._onDestroy = new Subject.Subject();
        }
        /**
         * @return {?}
         */
        PageHeaderNavigationSecondaryItemDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this._pageHeaderService.selected$.pipe(operators.delay(0), operators.takeUntil(this._onDestroy)).subscribe(function (next) {
                    // Update selected state for this item
                    // Update selected state for this item
                    _this._pageHeaderService.updateItem(_this.item, next);
                });
            };
        /**
         * @return {?}
         */
        PageHeaderNavigationSecondaryItemDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        PageHeaderNavigationSecondaryItemDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxPageHeaderNavigationSecondaryItem]'
                    },] }
        ];
        /** @nocollapse */
        PageHeaderNavigationSecondaryItemDirective.ctorParameters = function () {
            return [
                { type: PageHeaderService }
            ];
        };
        PageHeaderNavigationSecondaryItemDirective.propDecorators = {
            item: [{ type: core.Input, args: ['uxPageHeaderNavigationSecondaryItem',] }]
        };
        return PageHeaderNavigationSecondaryItemDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PageHeaderNavigationComponent = (function () {
        function PageHeaderNavigationComponent(elementRef, resizeService, _pageHeaderService) {
            this._pageHeaderService = _pageHeaderService;
            this.items$ = this._pageHeaderService.items$;
            this.indicatorVisible = false;
            this.indicatorX = 0;
            this.indicatorWidth = 0;
            this._subscription = new Subscription.Subscription();
            this._subscription.add(resizeService.addResizeListener(elementRef.nativeElement).subscribe(this.updateSelectedIndicator.bind(this)));
            this._subscription.add(_pageHeaderService.selected$.pipe(operators.distinctUntilChanged()).subscribe(this.updateSelectedIndicator.bind(this)));
            this._subscription.add(_pageHeaderService.secondary$.pipe(operators.distinctUntilChanged()).subscribe(this.updateSelectedIndicator.bind(this)));
        }
        /**
         * @return {?}
         */
        PageHeaderNavigationComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                this.updateSelectedIndicator();
            };
        /**
         * @return {?}
         */
        PageHeaderNavigationComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @return {?}
         */
        PageHeaderNavigationComponent.prototype.updateSelectedIndicator = /**
         * @return {?}
         */
            function () {
                var _this = this;
                setTimeout(function () {
                    // find the selected item
                    var /** @type {?} */ selected = _this.menuItems.find(function (item) { return item.item.selected; });
                    // determine whether or not to show the indicator
                    // determine whether or not to show the indicator
                    _this.indicatorVisible = !!selected;
                    // set the width of the indicator to match the width of the navigation item
                    if (selected) {
                        var /** @type {?} */ styles = getComputedStyle(selected.elementRef.nativeElement);
                        _this.indicatorX = selected.elementRef.nativeElement.offsetLeft;
                        _this.indicatorWidth = parseInt(styles.getPropertyValue('width'));
                    }
                });
            };
        PageHeaderNavigationComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-page-header-horizontal-navigation',
                        template: "<ux-page-header-horizontal-navigation-item\r\n    *ngFor=\"let item of items$ | async\"\r\n    [item]=\"item\">\r\n</ux-page-header-horizontal-navigation-item>\r\n\r\n<div class=\"selected-indicator\"\r\n    [style.opacity]=\"indicatorVisible ? 1 : 0\"\r\n    [style.margin-left.px]=\"indicatorX\"\r\n    [style.width.px]=\"indicatorWidth\">\r\n</div>",
                        host: {
                            'role': 'menubar'
                        }
                    }] }
        ];
        /** @nocollapse */
        PageHeaderNavigationComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: ResizeService },
                { type: PageHeaderService }
            ];
        };
        PageHeaderNavigationComponent.propDecorators = {
            menuItems: [{ type: core.ViewChildren, args: [PageHeaderNavigationItemComponent,] }]
        };
        return PageHeaderNavigationComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PageHeaderComponent = (function () {
        function PageHeaderComponent(_colorService, _pageHeaderService) {
            this._colorService = _colorService;
            this._pageHeaderService = _pageHeaderService;
            this.alignment = 'center';
            this.condensed = false;
            this.backVisible = true;
            this.secondaryNavigationAlignment = 'center';
            this.crumbsStyle = 'standard';
            this.backClick = new core.EventEmitter();
            this.selected$ = this._pageHeaderService.selected$;
            this.selectedRoot$ = this._pageHeaderService.selectedRoot$;
            this._crumbs = [];
        }
        Object.defineProperty(PageHeaderComponent.prototype, "secondaryNavigationAutoselect", {
            get: /**
             * @return {?}
             */ function () {
                return this._pageHeaderService.secondaryNavigationAutoselect;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._pageHeaderService.secondaryNavigationAutoselect = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PageHeaderComponent.prototype, "items", {
            set: /**
             * @param {?} items
             * @return {?}
             */ function (items) {
                this._pageHeaderService.setItems(items);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PageHeaderComponent.prototype, "secondaryNavigation", {
            get: /**
             * @return {?}
             */ function () {
                return this._pageHeaderService.secondary$.getValue();
            },
            set: /**
             * @param {?} enabled
             * @return {?}
             */ function (enabled) {
                this._pageHeaderService.setSecondaryNavigation(enabled);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PageHeaderComponent.prototype, "crumbs", {
            get: /**
             * @return {?}
             */ function () {
                return this.condensed ? __spread(this._crumbs, [{ title: this.header }]) : this._crumbs;
            },
            set: /**
             * @param {?} crumbs
             * @return {?}
             */ function (crumbs) {
                this._crumbs = crumbs;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PageHeaderComponent.prototype, "logoBackground", {
            get: /**
             * @return {?}
             */ function () {
                return this._logoBackground;
            },
            set: /**
             * @param {?} color
             * @return {?}
             */ function (color) {
                this._logoBackground = this._colorService.resolve(color);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PageHeaderComponent.prototype, "logoForeground", {
            get: /**
             * @return {?}
             */ function () {
                return this._logoForeground;
            },
            set: /**
             * @param {?} color
             * @return {?}
             */ function (color) {
                this._logoForeground = this._colorService.resolve(color);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PageHeaderComponent.prototype, "familyBackground", {
            set: /**
             * @param {?} color
             * @return {?}
             */ function (color) {
                this.logoBackground = color;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PageHeaderComponent.prototype, "familyForeground", {
            set: /**
             * @param {?} color
             * @return {?}
             */ function (color) {
                this.logoForeground = color;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        PageHeaderComponent.prototype.goBack = /**
         * @return {?}
         */
            function () {
                this.backClick.emit();
            };
        /**
         * @param {?} item
         * @return {?}
         */
        PageHeaderComponent.prototype.select = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                this._pageHeaderService.select(item);
            };
        PageHeaderComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-page-header',
                        exportAs: 'ux-page-header',
                        template: "<div class=\"ux-page-header\" [class.page-header-condensed]=\"condensed\" role=\"banner\">\n\n    <div *ngIf=\"!condensed\" class=\"page-header-content\">\n\n        <!-- Logo/product acronym -->\n        <div class=\"page-header-logo-container\" role=\"presentation\" [style.backgroundColor]=\"logoBackground\" [style.color]=\"logoForeground\">\n            <img *ngIf=\"logo\" [attr.src]=\"logo\" [alt]=\"header\" class=\"page-header-logo\">\n            <h1 *ngIf=\"header && !logo\" class=\"page-header-acronym\">{{header}}</h1>\n        </div>\n\n        <!-- Sub-title -->\n        <div *ngIf=\"title || titleTemplate\" class=\"page-header-subtitle-container\">\n            <span *ngIf=\"title\" class=\"page-header-subtitle\">{{title}}</span>\n            <ng-container [ngTemplateOutlet]=\"titleTemplate\"></ng-container>\n        </div>\n\n        <div class=\"page-header-state-container\" role=\"navigation\">\n\n            <!-- Back button -->\n            <button *ngIf=\"backVisible === true\" class=\"page-header-back-button\" (click)=\"goBack()\" aria-label=\"Go Back\">\n                <span class=\"hpe-icon hpe-previous text-primary\"></span>\n            </button>\n\n            <!-- Breadcrumbs and header -->\n            <div class=\"page-header-title-container\">\n\n                <ux-breadcrumbs *ngIf=\"crumbs && crumbs.length > 0\"\n                    [class.ux-breadcrumbs-small]=\"crumbsStyle === 'small'\"\n                    [crumbs]=\"crumbs\"></ux-breadcrumbs>\n\n                <h1 class=\"page-header-title\">{{header}}</h1>\n\n            </div>\n\n        </div>\n\n        <!-- Primary navigation -->\n        <div class=\"page-header-navigation\" [ngClass]=\"alignment\" role=\"navigation\" aria-label=\"Primary Navigation\">\n            <ux-page-header-horizontal-navigation></ux-page-header-horizontal-navigation>\n        </div>\n\n        <!-- Icon menus -->\n        <div class=\"page-header-icon-menus\" role=\"toolbar\">\n            <ng-container *ngFor=\"let menu of customMenus\" [ngTemplateOutlet]=\"menu\"></ng-container>\n            <ux-page-header-icon-menu *ngFor=\"let menu of iconMenus\" [menu]=\"menu\"></ux-page-header-icon-menu>\n        </div>\n    </div>\n\n    <!-- Display This Section Optimized for Condensed Mode -->\n    <div class=\"page-header-condensed-content\" *ngIf=\"condensed\">\n\n        <div class=\"page-header-breadcrumbs\" role=\"navigation\">\n            <ux-breadcrumbs [crumbs]=\"crumbs\"></ux-breadcrumbs>\n        </div>\n\n        <div class=\"page-header-navigation\" [ngClass]=\"alignment\" role=\"navigation\" aria-label=\"Primary Navigation\">\n\n            <!-- The Top Navigation Options -->\n            <ux-page-header-horizontal-navigation></ux-page-header-horizontal-navigation>\n        </div>\n\n        <div class=\"page-header-icon-menus\" role=\"toolbar\">\n            <ng-container *ngFor=\"let menu of customMenus\" [ngTemplateOutlet]=\"menu\"></ng-container>\n            <ux-page-header-icon-menu *ngFor=\"let menu of iconMenus\" [menu]=\"menu\"></ux-page-header-icon-menu>\n        </div>\n\n    </div>\n\n</div>\n\n<div *ngIf=\"secondaryNavigation && ((selectedRoot$ | async) !== (selected$ | async))\"\n    class=\"page-header-secondary\" [ngClass]=\"secondaryNavigationAlignment\" role=\"navigation\">\n\n    <ul *ngIf=\"(selectedRoot$ | async)?.children; let children\"\n        class=\"nav nav-tabs\" role=\"tablist\" aria-label=\"Secondary Navigation\">\n\n        <li *ngFor=\"let child of children\"\n            [class.active]=\"child.selected\"\n            role=\"none\"\n            [uxPageHeaderNavigationSecondaryItem]=\"child\">\n\n            <a role=\"tab\"\n                [attr.aria-selected]=\"child.selected\"\n                tabindex=\"0\"\n                (click)=\"select(child)\"\n                (keydown.enter)=\"select(child)\">{{ child.title }}</a>\n\n        </li>\n\n    </ul>\n\n</div>\n",
                        providers: [PageHeaderService]
                    }] }
        ];
        /** @nocollapse */
        PageHeaderComponent.ctorParameters = function () {
            return [
                { type: ColorService },
                { type: PageHeaderService }
            ];
        };
        PageHeaderComponent.propDecorators = {
            logo: [{ type: core.Input }],
            header: [{ type: core.Input }],
            title: [{ type: core.Input }],
            alignment: [{ type: core.Input }],
            condensed: [{ type: core.Input }],
            iconMenus: [{ type: core.Input }],
            backVisible: [{ type: core.Input }],
            secondaryNavigationAlignment: [{ type: core.Input }],
            secondaryNavigationAutoselect: [{ type: core.Input }],
            items: [{ type: core.Input }],
            secondaryNavigation: [{ type: core.Input }],
            crumbs: [{ type: core.Input }],
            crumbsStyle: [{ type: core.Input }],
            logoBackground: [{ type: core.Input }],
            logoForeground: [{ type: core.Input }],
            familyBackground: [{ type: core.Input }],
            familyForeground: [{ type: core.Input }],
            backClick: [{ type: core.Output }],
            titleTemplate: [{ type: core.ContentChild, args: ['title',] }],
            customMenus: [{ type: core.ContentChildren, args: [PageHeaderCustomMenuDirective, { read: core.TemplateRef },] }]
        };
        return PageHeaderComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PageHeaderModule = (function () {
        function PageHeaderModule() {
        }
        PageHeaderModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            BreadcrumbsModule,
                            dropdown.BsDropdownModule.forRoot(),
                            ColorServiceModule,
                            common.CommonModule,
                            MenuNavigationModule,
                            ResizeModule,
                            router.RouterModule,
                        ],
                        exports: [
                            PageHeaderComponent,
                            PageHeaderCustomMenuDirective
                        ],
                        declarations: [
                            PageHeaderComponent,
                            PageHeaderIconMenuComponent,
                            PageHeaderCustomMenuDirective,
                            PageHeaderNavigationComponent,
                            PageHeaderNavigationItemComponent,
                            PageHeaderNavigationDropdownItemComponent,
                            PageHeaderNavigationSecondaryItemDirective
                        ]
                    },] }
        ];
        return PageHeaderModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ProgressBarComponent = (function () {
        function ProgressBarComponent() {
            this.value = 0;
            this.min = 0;
            this.max = 100;
            this.indeterminate = false;
        }
        Object.defineProperty(ProgressBarComponent.prototype, "valueNow", {
            /** When indeteminate we should omit the valuenow label */
            get: /**
             * When indeteminate we should omit the valuenow label
             * @return {?}
             */ function () {
                return this.indeterminate ? null : this.value;
            },
            enumerable: true,
            configurable: true
        });
        ProgressBarComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-progress-bar',
                        template: "<div *ngIf=\"!indeterminate\" class=\"progressbar-track\" [style.width.%]=\"((value - min) / (max - min)) * 100\" [style.backgroundColor]=\"barColor\">\n    <ng-container *ngTemplateOutlet=\"content\"></ng-container>\n</div>\n<div *ngIf=\"indeterminate\" class=\"progressbar-track indeterminate\" [style.backgroundColor]=\"barColor\">\n    <ng-container *ngTemplateOutlet=\"content\"></ng-container>\n</div>\n\n<!-- Workaround for Multiple ng-content tags issue: https://github.com/angular/angular/issues/22972 -->\n<ng-template #content><ng-content></ng-content></ng-template>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        host: {
                            role: 'progressbar'
                        }
                    }] }
        ];
        ProgressBarComponent.propDecorators = {
            value: [{ type: core.Input }],
            min: [{ type: core.Input }, { type: core.HostBinding, args: ['attr.aria-valuemin',] }],
            max: [{ type: core.Input }, { type: core.HostBinding, args: ['attr.aria-valuemax',] }],
            indeterminate: [{ type: core.Input }],
            trackColor: [{ type: core.Input }],
            barColor: [{ type: core.Input }],
            valueNow: [{ type: core.HostBinding, args: ['attr.aria-valuenow',] }]
        };
        return ProgressBarComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ProgressBarModule = (function () {
        function ProgressBarModule() {
        }
        ProgressBarModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule
                        ],
                        exports: [ProgressBarComponent],
                        declarations: [ProgressBarComponent]
                    },] }
        ];
        return ProgressBarModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ RADIOBUTTON_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return RadioButtonComponent; }),
        multi: true
    };
    var /** @type {?} */ uniqueRadioId = 0;
    var RadioButtonComponent = (function () {
        function RadioButtonComponent() {
            this._radioButtonId = "ux-radio-button-" + ++uniqueRadioId;
            this.id = this._radioButtonId;
            this.tabindex = 0;
            this.clickable = true;
            this.disabled = false;
            this.simplified = false;
            this.ariaLabel = '';
            this.ariaLabelledby = null;
            this.ariaDescribedby = null;
            this.valueChange = new core.EventEmitter();
            this._value = false;
            this.focused = false;
            this.onTouchedCallback = function () { };
            this.onChangeCallback = function () { };
        }
        Object.defineProperty(RadioButtonComponent.prototype, "value", {
            get: /**
             * @return {?}
             */ function () {
                return this._value;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._value = value;
                // invoke change event
                this.valueChange.emit(this._value);
                // call callback
                this.onChangeCallback(this._value);
                this.onTouchedCallback();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RadioButtonComponent.prototype, "inputId", {
            get: /**
             * @return {?}
             */ function () {
                return (this.id || this._radioButtonId) + "-input";
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        RadioButtonComponent.prototype.toggle = /**
         * @return {?}
         */
            function () {
                if (this.disabled || !this.clickable) {
                    return;
                }
                // toggle the checked state
                this.value = this.option;
                // call callback
                this.onChangeCallback(this.value);
            };
        // Functions required to update ng-model
        /**
         * @param {?} value
         * @return {?}
         */
        RadioButtonComponent.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (value !== this._value) {
                    this._value = value;
                }
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        RadioButtonComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onChangeCallback = fn;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        RadioButtonComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onTouchedCallback = fn;
            };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        RadioButtonComponent.prototype.setDisabledState = /**
         * @param {?} isDisabled
         * @return {?}
         */
            function (isDisabled) {
                this.disabled = isDisabled;
            };
        RadioButtonComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-radio-button',
                        template: "<label [attr.for]=\"inputId\" class=\"ux-radio-button\"\n       [class.ux-radio-button-checked]=\"value === option\"\n       [class.ux-radio-button-simplified]=\"simplified\"\n       [class.ux-radio-button-disabled]=\"disabled\"\n       [class.ux-radio-button-focused]=\"focused\">\n\n    <div class=\"ux-radio-button-container\">\n        <input class=\"ux-radio-button-input\"\n            type=\"radio\"\n            [id]=\"inputId\"\n            [checked]=\"value === option\"\n            [disabled]=\"disabled\"\n            [tabindex]=\"tabindex || value === option ? 0 : -1\"\n            [attr.name]=\"name\"\n            [required]=\"required\"\n            [attr.aria-label]=\"ariaLabel\"\n            [attr.aria-labelledby]=\"ariaLabelledby\"\n            [attr.aria-describedby]=\"ariaDescribedby\"\n            [attr.aria-checked]=\"value === option\"\n            (focus)=\"focused = true\"\n            (blur)=\"focused = false\"\n            (change)=\"toggle()\"\n            (click)=\"$event.stopPropagation()\">\n    </div>\n\n    <span class=\"ux-radio-button-label\">\n        <ng-content></ng-content>\n    </span>\n\n</label>",
                        providers: [RADIOBUTTON_VALUE_ACCESSOR]
                    }] }
        ];
        RadioButtonComponent.propDecorators = {
            id: [{ type: core.Input }],
            name: [{ type: core.Input }],
            required: [{ type: core.Input }],
            tabindex: [{ type: core.Input }],
            clickable: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            simplified: [{ type: core.Input }],
            option: [{ type: core.Input }],
            ariaLabel: [{ type: core.Input, args: ['aria-label',] }],
            ariaLabelledby: [{ type: core.Input, args: ['aria-labelledby',] }],
            ariaDescribedby: [{ type: core.Input, args: ['aria-describedby',] }],
            valueChange: [{ type: core.Output }],
            value: [{ type: core.Input }]
        };
        return RadioButtonComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var RadioButtonModule = (function () {
        function RadioButtonModule() {
        }
        RadioButtonModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [forms.FormsModule],
                        exports: [RadioButtonComponent],
                        declarations: [RadioButtonComponent]
                    },] }
        ];
        return RadioButtonModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ UNSET_FOCUS = { groupId: null, index: -1 };
    var SearchBuilderFocusService = (function () {
        function SearchBuilderFocusService() {
            this.focus$ = new BehaviorSubject.BehaviorSubject(UNSET_FOCUS);
        }
        /**
         * Set focus on a search builder component.
         * @param groupId The `id` of the group containing the component.
         * @param index The (zero-based) index of the component.
         */
        /**
         * Set focus on a search builder component.
         * @param {?} groupId The `id` of the group containing the component.
         * @param {?} index The (zero-based) index of the component.
         * @return {?}
         */
        SearchBuilderFocusService.prototype.setFocus = /**
         * Set focus on a search builder component.
         * @param {?} groupId The `id` of the group containing the component.
         * @param {?} index The (zero-based) index of the component.
         * @return {?}
         */
            function (groupId, index) {
                this.focus$.next({ groupId: groupId, index: index });
            };
        /**
         * Removes focus from all components. If focus is not on a search builder component, this does nothing.
         */
        /**
         * Removes focus from all components. If focus is not on a search builder component, this does nothing.
         * @return {?}
         */
        SearchBuilderFocusService.prototype.clearFocus = /**
         * Removes focus from all components. If focus is not on a search builder component, this does nothing.
         * @return {?}
         */
            function () {
                this.focus$.next(UNSET_FOCUS);
            };
        SearchBuilderFocusService.decorators = [
            { type: core.Injectable }
        ];
        return SearchBuilderFocusService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SearchBuilderService = (function () {
        function SearchBuilderService() {
            this.query = {};
            this.queryChange = new Subject.Subject();
            this.validationChange = new BehaviorSubject.BehaviorSubject(true);
            this._componentId = 0;
            this._components = [];
            this._validation = {};
        }
        /**
         * Add a component to the internal list of components
         */
        /**
         * Add a component to the internal list of components
         * @param {?} component
         * @return {?}
         */
        SearchBuilderService.prototype.registerComponent = /**
         * Add a component to the internal list of components
         * @param {?} component
         * @return {?}
         */
            function (component) {
                // ensure there are no components with a matching name
                if (this._components.find(function (cmp) { return cmp.name === component.name; })) {
                    throw new Error("Search builder components must have a unique name. The name " + component.name + " has already been used.");
                }
                // if unique then add the component to the list
                this._components.push(component);
            };
        /**
         * Bulk registration of components
         * (Just a helper method)
         */
        /**
         * Bulk registration of components
         * (Just a helper method)
         * @param {?} components
         * @return {?}
         */
        SearchBuilderService.prototype.registerComponents = /**
         * Bulk registration of components
         * (Just a helper method)
         * @param {?} components
         * @return {?}
         */
            function (components) {
                var _this = this;
                components.forEach(function (component) { return _this.registerComponent(component); });
            };
        /**
         * Get a registered component class
         */
        /**
         * Get a registered component class
         * @param {?} name
         * @return {?}
         */
        SearchBuilderService.prototype.getComponent = /**
         * Get a registered component class
         * @param {?} name
         * @return {?}
         */
            function (name) {
                // find the component
                var /** @type {?} */ component = this._components.find(function (cmp) { return cmp.name === name; });
                // if there is no match throw an exception
                if (!component) {
                    throw new Error("No search build component with the name " + name + " exists");
                }
                // ensure config is defined - at least to an empty object
                component.config = component.config || {};
                return component;
            };
        /**
         * Update the internal search query state
         * note that the query will be immutable
         */
        /**
         * Update the internal search query state
         * note that the query will be immutable
         * @param {?} query
         * @return {?}
         */
        SearchBuilderService.prototype.setQuery = /**
         * Update the internal search query state
         * note that the query will be immutable
         * @param {?} query
         * @return {?}
         */
            function (query) {
                this.query = Object.assign({}, query);
            };
        /**
         * Return the current query state
         */
        /**
         * Return the current query state
         * @return {?}
         */
        SearchBuilderService.prototype.getQuery = /**
         * Return the current query state
         * @return {?}
         */
            function () {
                return this.query;
            };
        /**
         * Trigger the observable to indicate the query has been updated
         */
        /**
         * Trigger the observable to indicate the query has been updated
         * @return {?}
         */
        SearchBuilderService.prototype.queryHasChanged = /**
         * Trigger the observable to indicate the query has been updated
         * @return {?}
         */
            function () {
                this.queryChange.next(this.query);
            };
        /**
         * Store the validation state of the query
         */
        /**
         * Store the validation state of the query
         * @param {?} id
         * @param {?} valid
         * @return {?}
         */
        SearchBuilderService.prototype.setValid = /**
         * Store the validation state of the query
         * @param {?} id
         * @param {?} valid
         * @return {?}
         */
            function (id, valid) {
                var _this = this;
                // store the state for this specific component
                this._validation[id] = valid;
                // evaluate the entire validation state
                this.validationChange.next(!Object.keys(this._validation).some(function (key) { return !_this._validation[key]; }));
            };
        /**
         * Generate a unique id for each component
         */
        /**
         * Generate a unique id for each component
         * @return {?}
         */
        SearchBuilderService.prototype.generateComponentId = /**
         * Generate a unique id for each component
         * @return {?}
         */
            function () {
                return this._componentId++;
            };
        SearchBuilderService.decorators = [
            { type: core.Injectable }
        ];
        return SearchBuilderService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SearchBuilderGroupService = (function () {
        function SearchBuilderGroupService(_searchBuilderService, _searchBuilderFocusService) {
            this._searchBuilderService = _searchBuilderService;
            this._searchBuilderFocusService = _searchBuilderFocusService;
        }
        /**
         * Initialise the group by defining an id
         */
        /**
         * Initialise the group by defining an id
         * @param {?} id
         * @return {?}
         */
        SearchBuilderGroupService.prototype.init = /**
         * Initialise the group by defining an id
         * @param {?} id
         * @return {?}
         */
            function (id) {
                var _this = this;
                // store the name of the group
                this._id = id;
                // create the entry in the query object if it doesn't exist
                if (!this._searchBuilderService.query[this._id]) {
                    // create the section
                    this._searchBuilderService.query[this._id] = [];
                    // emit the changes after the initial setup
                    setTimeout(function () { return _this._searchBuilderService.queryHasChanged(); });
                }
            };
        /**
         * Remove a field from the search builder query and return focus to the previous field.
         */
        /**
         * Remove a field from the search builder query and return focus to the previous field.
         * @param {?} index
         * @return {?}
         */
        SearchBuilderGroupService.prototype.removeAtIndex = /**
         * Remove a field from the search builder query and return focus to the previous field.
         * @param {?} index
         * @return {?}
         */
            function (index) {
                // get the query for this group
                var /** @type {?} */ query = this.getQuery();
                // remove the field from the array
                query.splice(index, 1);
                // Focus the previous item if available
                this._searchBuilderFocusService.setFocus(this._id, index <= 0 ? 0 : index - 1);
            };
        /**
         * Get the query for this specific search group
         */
        /**
         * Get the query for this specific search group
         * @return {?}
         */
        SearchBuilderGroupService.prototype.getQuery = /**
         * Get the query for this specific search group
         * @return {?}
         */
            function () {
                return this._searchBuilderService.query[this._id] ? this._searchBuilderService.query[this._id] : [];
            };
        SearchBuilderGroupService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        SearchBuilderGroupService.ctorParameters = function () {
            return [
                { type: SearchBuilderService },
                { type: SearchBuilderFocusService }
            ];
        };
        return SearchBuilderGroupService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SearchBuilderGroupComponent = (function () {
        function SearchBuilderGroupComponent(searchBuilderGroupService, _searchBuilderFocusService) {
            this.searchBuilderGroupService = searchBuilderGroupService;
            this._searchBuilderFocusService = _searchBuilderFocusService;
            this.operator = 'and';
            this.addText = 'Add a field';
            this.showPlaceholder = false;
            this.add = new core.EventEmitter();
            this.remove = new core.EventEmitter();
            this.focusIndex = -1;
            this._onDestroy = new Subject.Subject();
        }
        /**
         * @return {?}
         */
        SearchBuilderGroupComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // ensure we have a name otherwise throw an error
                if (!this.id) {
                    throw new Error('Search builder group must have an id attribute.');
                }
                // otherwise register the group
                this.searchBuilderGroupService.init(this.id);
                // Track focus for child components
                this._searchBuilderFocusService.focus$.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (focus) {
                    _this.focusIndex = (focus.groupId === _this.id) ? focus.index : -1;
                });
            };
        /**
         * @return {?}
         */
        SearchBuilderGroupComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SearchBuilderGroupComponent.prototype.addField = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.add.emit(event);
            };
        /**
         * @param {?} index
         * @param {?} field
         * @return {?}
         */
        SearchBuilderGroupComponent.prototype.removeFieldAtIndex = /**
         * @param {?} index
         * @param {?} field
         * @return {?}
         */
            function (index, field) {
                this.searchBuilderGroupService.removeAtIndex(index);
                this.remove.emit(field);
            };
        /**
         * @param {?} index
         * @return {?}
         */
        SearchBuilderGroupComponent.prototype.setFocus = /**
         * @param {?} index
         * @return {?}
         */
            function (index) {
                this._searchBuilderFocusService.setFocus(this.id, index);
            };
        /**
         * @return {?}
         */
        SearchBuilderGroupComponent.prototype.clearFocus = /**
         * @return {?}
         */
            function () {
                this._searchBuilderFocusService.clearFocus();
            };
        SearchBuilderGroupComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-search-builder-group',
                        template: "<h4 class=\"search-group-title\">{{ header }}</h4>\n\n<div class=\"search-group-content\">\n\n  <div class=\"search-group-operator search-group-operator-{{ operator }}\"\n    [class.hidden-operator]=\"searchBuilderGroupService.getQuery().length < 2\">{{ operator }}</div>\n\n  <div class=\"search-group-items\">\n\n    <div *ngFor=\"let field of searchBuilderGroupService.getQuery(); let i = index\"\n      class=\"search-group-item-container\"\n      [class.search-group-item-focus]=\"focusIndex === i\"\n      (uxFocusWithin)=\"setFocus(i)\"\n      (uxBlurWithin)=\"clearFocus()\">\n\n      <div class=\"search-group-item\">\n        <ng-container *uxSearchBuilderOutlet=\"field.type; context: field; groupId: id; index: i\"></ng-container>\n      </div>\n\n      <button type=\"button\"\n        aria-label=\"Remove field\"\n        class=\"search-group-item-remove\"\n        (click)=\"removeFieldAtIndex(i, field)\">\n\n        <span class=\"hpe-icon hpe-close\"></span>\n\n      </button>\n\n    </div>\n\n    <!-- Placeholder Item -->\n    <ng-container *ngIf=\"showPlaceholder\">\n\n      <!-- The Default Placeholder -->\n      <div class=\"search-group-item-container placeholder-item\" *ngIf=\"!placeholder\">\n\n        <div class=\"search-group-item\">\n          <label class=\"form-label\">New field</label>\n          <div class=\"form-control\"></div>\n        </div>\n\n      </div>\n\n      <!-- Allow a custom placeholder -->\n      <ng-container *ngTemplateOutlet=\"placeholder\"></ng-container>\n\n    </ng-container>\n\n  </div>\n\n  <button type=\"button\" class=\"search-builder-group-add-field\" (click)=\"addField($event)\">\n    <span class=\"search-builder-group-add-field-icon hpe-icon hpe-add\" aria-hidden=\"true\"></span>\n    <span class=\"search-builder-group-add-field-label\">{{ addText }}</span>\n  </button>\n\n</div>\n\n<hr class=\"search-builder-group-divider\">\n",
                        providers: [SearchBuilderGroupService]
                    }] }
        ];
        /** @nocollapse */
        SearchBuilderGroupComponent.ctorParameters = function () {
            return [
                { type: SearchBuilderGroupService },
                { type: SearchBuilderFocusService }
            ];
        };
        SearchBuilderGroupComponent.propDecorators = {
            id: [{ type: core.Input }],
            header: [{ type: core.Input }],
            operator: [{ type: core.Input }],
            addText: [{ type: core.Input }],
            placeholder: [{ type: core.Input }],
            showPlaceholder: [{ type: core.Input }],
            add: [{ type: core.Output }],
            remove: [{ type: core.Output }]
        };
        return SearchBuilderGroupComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SearchBuilderOutletDirective = (function () {
        function SearchBuilderOutletDirective(_viewContainerRef, _componentFactoryResolver, _searchBuilderService, _searchBuilderFocusService) {
            this._viewContainerRef = _viewContainerRef;
            this._componentFactoryResolver = _componentFactoryResolver;
            this._searchBuilderService = _searchBuilderService;
            this._searchBuilderFocusService = _searchBuilderFocusService;
            this._onDestroy = new Subject.Subject();
        }
        /**
         * @return {?}
         */
        SearchBuilderOutletDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // get the class from the type
                var /** @type {?} */ componentDefinition = this._searchBuilderService.getComponent(this.outlet);
                // create the component factory
                var /** @type {?} */ componentFactory = this._componentFactoryResolver.resolveComponentFactory(componentDefinition.component);
                // create the component instance
                this._componentRef = this._viewContainerRef.createComponent(componentFactory);
                // combine the predefined config with any dynmaic config
                var /** @type {?} */ config = Object.assign({}, componentDefinition.config, this.context.config || {});
                // set the context and config property on the component instance
                this._componentRef.instance.context = this.context;
                this._componentRef.instance.config = config;
                this._searchBuilderFocusService.focus$
                    .pipe(operators.distinctUntilChanged(), operators.delay(0), operators.takeUntil(this._onDestroy))
                    .subscribe(function (focus) {
                    _this._componentRef.instance.focus = (focus.groupId === _this.groupId && focus.index === _this.index);
                });
            };
        /**
         * @return {?}
         */
        SearchBuilderOutletDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        SearchBuilderOutletDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxSearchBuilderOutlet]'
                    },] }
        ];
        /** @nocollapse */
        SearchBuilderOutletDirective.ctorParameters = function () {
            return [
                { type: core.ViewContainerRef },
                { type: core.ComponentFactoryResolver },
                { type: SearchBuilderService },
                { type: SearchBuilderFocusService }
            ];
        };
        SearchBuilderOutletDirective.propDecorators = {
            outlet: [{ type: core.Input, args: ['uxSearchBuilderOutlet',] }],
            context: [{ type: core.Input, args: ['uxSearchBuilderOutletContext',] }],
            groupId: [{ type: core.Input, args: ['uxSearchBuilderOutletGroupId',] }],
            index: [{ type: core.Input, args: ['uxSearchBuilderOutletIndex',] }]
        };
        return SearchBuilderOutletDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SearchBuilderComponent = (function () {
        /**
         * Register the default search builder components
         */
        function SearchBuilderComponent(_searchBuilderService) {
            var _this = this;
            this._searchBuilderService = _searchBuilderService;
            this.queryChange = new core.EventEmitter();
            this.valid = new core.EventEmitter(true);
            // watch for any query changes
            this._querySubscription = _searchBuilderService.queryChange.subscribe(function (query) { return _this.queryChange.emit(query); });
            // watch for any changes to the validation
            this._validSubscription = _searchBuilderService.validationChange.pipe(operators.distinctUntilChanged()).subscribe(function (valid) { return _this.valid.emit(valid); });
        }
        Object.defineProperty(SearchBuilderComponent.prototype, "components", {
            set: /**
             * @param {?} components
             * @return {?}
             */ function (components) {
                this._searchBuilderService.registerComponents(components);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchBuilderComponent.prototype, "query", {
            get: /**
             * @return {?}
             */ function () {
                return this._searchBuilderService.getQuery();
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._searchBuilderService.setQuery(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Remove any subscriptions and cleanup
         */
        /**
         * Remove any subscriptions and cleanup
         * @return {?}
         */
        SearchBuilderComponent.prototype.ngOnDestroy = /**
         * Remove any subscriptions and cleanup
         * @return {?}
         */
            function () {
                this._querySubscription.unsubscribe();
                this._validSubscription.unsubscribe();
            };
        SearchBuilderComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-search-builder',
                        template: "<ng-content></ng-content>",
                        providers: [SearchBuilderService]
                    }] }
        ];
        /** @nocollapse */
        SearchBuilderComponent.ctorParameters = function () {
            return [
                { type: SearchBuilderService }
            ];
        };
        SearchBuilderComponent.propDecorators = {
            components: [{ type: core.Input }],
            query: [{ type: core.Input }],
            queryChange: [{ type: core.Output }],
            valid: [{ type: core.Output }]
        };
        return SearchBuilderComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ uniqueId$6 = 0;
    var /** @type {?} */ SELECT_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return SelectComponent; }),
        multi: true
    };
    var SelectComponent = (function () {
        function SelectComponent(_element, _document, _typeaheadKeyService) {
            this._element = _element;
            this._document = _document;
            this._typeaheadKeyService = _typeaheadKeyService;
            this.id = "ux-select-" + ++uniqueId$6;
            this.allowNull = false;
            this.disabled = false;
            this.dropDirection = 'down';
            this.maxHeight = '250px';
            this.multiple = false;
            this.pageSize = 20;
            this.valueChange = new core.EventEmitter();
            this.inputChange = new core.EventEmitter();
            this.dropdownOpenChange = new core.EventEmitter();
            this.propagateChange = function (_) { };
            this._value$ = new BehaviorSubject.BehaviorSubject(null);
            this._input$ = new BehaviorSubject.BehaviorSubject('');
            this._dropdownOpen = false;
            this._onDestroy = new Subject.Subject();
        }
        Object.defineProperty(SelectComponent.prototype, "value", {
            get: /**
             * @return {?}
             */ function () {
                return this._value$.value;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._value$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectComponent.prototype, "input", {
            get: /**
             * @return {?}
             */ function () {
                return this._input$.value;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._input$.next(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectComponent.prototype, "dropdownOpen", {
            get: /**
             * @return {?}
             */ function () {
                return this._dropdownOpen;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._dropdownOpen = value;
                this.dropdownOpenChange.emit(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        SelectComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // Emit change events
                this._value$.pipe(operators.takeUntil(this._onDestroy), operators.distinctUntilChanged()).subscribe(function (value) {
                    _this.valueChange.emit(value);
                    _this.propagateChange(value);
                });
                this._input$.pipe(operators.takeUntil(this._onDestroy), operators.distinctUntilChanged()).subscribe(function (value) {
                    _this.inputChange.emit(value);
                });
                // Changes to the input field
                this._input$.pipe(operators.takeUntil(this._onDestroy), operators.filter(function (value) { return _this.allowNull; }), operators.filter(function (value) { return !_this.multiple && value !== _this.getDisplay(_this.value); })).subscribe(function (value) { return _this.value = null; });
                // Set up filter from input
                this.filter$ = this._input$.pipe(operators.map(function (input) { return !_this.multiple && input === _this.getDisplay(_this.value) ? '' : input; }), operators.debounceTime(200));
                // Open the dropdown when filter is nonempty.
                this.filter$.pipe(operators.takeUntil(this._onDestroy), operators.filter(function (value) { return value && value.length > 0; })).subscribe(function () { return _this.dropdownOpen = true; });
                // Update the single-select input when the model changes
                this._value$.pipe(operators.takeUntil(this._onDestroy), operators.distinctUntilChanged(), operators.delay(0), operators.filter(function (value) { return value !== null && !_this.multiple; })).subscribe(function (value) {
                    _this.input = _this.getDisplay(value);
                });
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        SelectComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                if (changes["multiple"] && !changes["multiple"].firstChange && changes["multiple"].currentValue !== changes["multiple"].previousValue) {
                    this.input = '';
                }
            };
        /**
         * @return {?}
         */
        SelectComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @return {?}
         */
        SelectComponent.prototype.onfocus = /**
         * @return {?}
         */
            function () {
                if (this.singleInput) {
                    this.singleInput.nativeElement.focus();
                }
                else if (this.tagInput) {
                    this.tagInput.focus();
                }
            };
        /**
         * @param {?} obj
         * @return {?}
         */
        SelectComponent.prototype.writeValue = /**
         * @param {?} obj
         * @return {?}
         */
            function (obj) {
                if (obj !== undefined && obj !== this.value) {
                    this.value = obj;
                }
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        SelectComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.propagateChange = fn;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        SelectComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) { };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        SelectComponent.prototype.setDisabledState = /**
         * @param {?} isDisabled
         * @return {?}
         */
            function (isDisabled) {
                this.disabled = isDisabled;
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SelectComponent.prototype.inputClickHandler = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this.selectInputText();
                this.dropdownOpen = true;
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SelectComponent.prototype.inputBlurHandler = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                var _this = this;
                // If a click on the typeahead is in progress, just refocus the input.
                // This works around an issue in IE where clicking a scrollbar drops focus.
                if (this.singleTypeahead && this.singleTypeahead.clicking) {
                    this.singleInput.nativeElement.focus();
                    return;
                }
                // Close dropdown and reset text input if focus is lost
                setTimeout(function () {
                    if (!_this._element.nativeElement.contains(_this._document.activeElement)) {
                        _this.dropdownOpen = false;
                        if (!_this.multiple) {
                            _this.input = _this.getDisplay(_this.value);
                        }
                    }
                }, 200);
            };
        /**
         * Key handler for single select only. Multiple select key handling is in TagInputComponent.
         */
        /**
         * Key handler for single select only. Multiple select key handling is in TagInputComponent.
         * @param {?} event
         * @return {?}
         */
        SelectComponent.prototype.inputKeyHandler = /**
         * Key handler for single select only. Multiple select key handling is in TagInputComponent.
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // Standard keys for typeahead (up/down/esc)
                this._typeaheadKeyService.handleKey(event, this.singleTypeahead);
                switch (event.key) {
                    case 'Enter':
                        if (this._dropdownOpen) {
                            // Set the highlighted option as the value and close
                            this.value = this.singleTypeahead.highlighted;
                            this.dropdownOpen = false;
                        }
                        // Update the input field. If dropdown isn't open then reset it to the previous value.
                        this.input = this.getDisplay(this.value);
                        event.preventDefault();
                        break;
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SelectComponent.prototype.singleOptionSelected = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (event.option) {
                    this.value = event.option;
                    this.dropdownOpen = false;
                }
            };
        /**
         * Returns the display value of the given option.
         */
        /**
         * Returns the display value of the given option.
         * @param {?} option
         * @return {?}
         */
        SelectComponent.prototype.getDisplay = /**
         * Returns the display value of the given option.
         * @param {?} option
         * @return {?}
         */
            function (option) {
                if (option === null || option === undefined) {
                    return '';
                }
                if (typeof this.display === 'function') {
                    return this.display(option);
                }
                if (typeof this.display === 'string' && option.hasOwnProperty(this.display)) {
                    return option[(this.display)];
                }
                return option;
            };
        /**
         * @return {?}
         */
        SelectComponent.prototype.selectInputText = /**
         * @return {?}
         */
            function () {
                this.singleInput.nativeElement.select();
            };
        SelectComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-select',
                        template: "<ux-tag-input *ngIf=\"multiple\"\r\n    #tagInput=\"ux-tag-input\"\r\n    [id]=\"id + '-input'\"\r\n    [(tags)]=\"value\"\r\n    [(input)]=\"input\"\r\n    [addOnPaste]=\"false\"\r\n    [disabled]=\"disabled\"\r\n    [display]=\"display\"\r\n    [freeInput]=\"false\"\r\n    [placeholder]=\"placeholder\"\r\n    [showTypeaheadOnClick]=\"true\">\r\n\r\n    <ux-typeahead #multipleTypeahead\r\n        [id]=\"id + '-typeahead'\"\r\n        [options]=\"options\"\r\n        [filter]=\"filter$ | async\"\r\n        [(open)]=\"dropdownOpen\"\r\n        [display]=\"display\"\r\n        [key]=\"key\"\r\n        [disabledOptions]=\"value\"\r\n        [dropDirection]=\"dropDirection\"\r\n        [maxHeight]=\"maxHeight\"\r\n        [multiselectable]=\"true\"\r\n        [pageSize]=\"pageSize\"\r\n        [selectFirst]=\"true\"\r\n        [loadingTemplate]=\"loadingTemplate\"\r\n        [optionTemplate]=\"optionTemplate\"\r\n        [noOptionsTemplate]=\"noOptionsTemplate\">\r\n    </ux-typeahead>\r\n\r\n</ux-tag-input>\r\n\r\n<div *ngIf=\"!multiple\"\r\n    class=\"inner-addon right-addon\"\r\n    [class.disabled]=\"disabled\"\r\n    role=\"combobox\"\r\n    [attr.aria-expanded]=\"dropdownOpen\"\r\n    aria-haspopup=\"listbox\">\r\n\r\n    <i class=\"hpe-icon\"\r\n        [class.hpe-down]=\"dropDirection === 'down'\"\r\n        [class.hpe-up]=\"dropDirection === 'up'\"></i>\r\n\r\n    <input #singleInput type=\"text\" [attr.id]=\"id + '-input'\" class=\"form-control\"\r\n        [attr.aria-activedescendant]=\"highlightedElement?.id\"\r\n        aria-autocomplete=\"list\"\r\n        [attr.aria-controls]=\"singleTypeahead.id\"\r\n        aria-multiline=\"false\"\r\n        [(ngModel)]=\"input\"\r\n        [placeholder]=\"placeholder\"\r\n        [disabled]=\"disabled\"\r\n        (click)=\"inputClickHandler($event)\"\r\n        (blur)=\"inputBlurHandler($event)\"\r\n        (keydown)=\"inputKeyHandler($event)\">\r\n\r\n    <ux-typeahead #singleTypeahead\r\n        [id]=\"id + '-typeahead'\"\r\n        [options]=\"options\"\r\n        [filter]=\"filter$ | async\"\r\n        [(open)]=\"dropdownOpen\"\r\n        [display]=\"display\"\r\n        [key]=\"key\"\r\n        [dropDirection]=\"dropDirection\"\r\n        [maxHeight]=\"maxHeight\"\r\n        [multiselectable]=\"false\"\r\n        [openOnFilterChange]=\"false\"\r\n        [pageSize]=\"pageSize\"\r\n        [selectFirst]=\"true\"\r\n        [loadingTemplate]=\"loadingTemplate\"\r\n        [optionTemplate]=\"optionTemplate\"\r\n        [noOptionsTemplate]=\"noOptionsTemplate\"\r\n        (optionSelected)=\"singleOptionSelected($event)\"\r\n        (highlightedElementChange)=\"highlightedElement = $event\">\r\n    </ux-typeahead>\r\n\r\n</div>\r\n",
                        providers: [SELECT_VALUE_ACCESSOR],
                        host: {
                            'tabindex': '0'
                        }
                    }] }
        ];
        /** @nocollapse */
        SelectComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] },
                { type: TypeaheadKeyService }
            ];
        };
        SelectComponent.propDecorators = {
            id: [{ type: core.Input }, { type: core.HostBinding, args: ['attr.id',] }],
            value: [{ type: core.Input }],
            input: [{ type: core.Input }],
            dropdownOpen: [{ type: core.Input }],
            options: [{ type: core.Input }],
            display: [{ type: core.Input }],
            key: [{ type: core.Input }],
            allowNull: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            dropDirection: [{ type: core.Input }],
            maxHeight: [{ type: core.Input }],
            multiple: [{ type: core.Input }],
            pageSize: [{ type: core.Input }],
            placeholder: [{ type: core.Input }],
            loadingTemplate: [{ type: core.Input }],
            noOptionsTemplate: [{ type: core.Input }],
            optionTemplate: [{ type: core.Input }],
            valueChange: [{ type: core.Output }],
            inputChange: [{ type: core.Output }],
            dropdownOpenChange: [{ type: core.Output }],
            singleInput: [{ type: core.ViewChild, args: ['singleInput',] }],
            tagInput: [{ type: core.ViewChild, args: ['tagInput',] }],
            multipleTypeahead: [{ type: core.ViewChild, args: ['multipleTypeahead',] }],
            singleTypeahead: [{ type: core.ViewChild, args: ['singleTypeahead',] }],
            onfocus: [{ type: core.HostListener, args: ['focus',] }]
        };
        return SelectComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TagInputEvent = (function () {
        function TagInputEvent(tag) {
            this.tag = tag;
            this._defaultPrevented = false;
        }
        /**
         * @return {?}
         */
        TagInputEvent.prototype.preventDefault = /**
         * @return {?}
         */
            function () {
                this._defaultPrevented = true;
            };
        /**
         * @return {?}
         */
        TagInputEvent.prototype.defaultPrevented = /**
         * @return {?}
         */
            function () {
                return this._defaultPrevented;
            };
        return TagInputEvent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ uniqueId$7 = 0;
    var /** @type {?} */ TAGINPUT_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return TagInputComponent; }),
        multi: true
    };
    var /** @type {?} */ TAGINPUT_VALIDATOR = {
        provide: forms.NG_VALIDATORS,
        useExisting: core.forwardRef(function () { return TagInputComponent; }),
        multi: true
    };
    var TagInputComponent = (function () {
        function TagInputComponent(_element, _document, _typeaheadKeyService) {
            this._element = _element;
            this._document = _document;
            this._typeaheadKeyService = _typeaheadKeyService;
            this.id = "ux-tag-input-" + ++uniqueId$7;
            this.tagsChange = new core.EventEmitter();
            this.inputChange = new core.EventEmitter();
            this.addOnPaste = true;
            this.disabled = false;
            this.enforceTagLimits = false;
            this.freeInput = true;
            this.maxTags = Number.MAX_VALUE;
            this.minTags = 0;
            this.placeholder = '';
            this.showTypeaheadOnClick = false;
            this.tagDelimiters = '';
            this.tagClass = function () { return undefined; };
            this.validationErrors = {};
            /**
             * @deprecated
             * Workaround for EL-3224 - No longer needed
             */
            this.trackAriaDescendant = true;
            this.tagAdding = new core.EventEmitter();
            this.tagAdded = new core.EventEmitter();
            this.tagInvalidated = new core.EventEmitter();
            this.tagRemoving = new core.EventEmitter();
            this.tagRemoved = new core.EventEmitter();
            this.tagClick = new core.EventEmitter();
            this.selectedIndex = -1;
            this.tagApi = {
                getTagDisplay: this.getTagDisplay.bind(this),
                removeTagAt: this.removeTagAt.bind(this),
                canRemoveTagAt: this.canRemoveTagAt.bind(this)
            };
            this.valid = true;
            this.inputValid = true;
            this._input = '';
            this._tags = [];
            this._onChangeHandler = function () { };
            this._onTouchedHandler = function () { };
            this._onDestroy = new Subject.Subject();
        }
        Object.defineProperty(TagInputComponent.prototype, "tags", {
            get: /**
             * @return {?}
             */ function () {
                if (!this._tags) {
                    this._tags = [];
                }
                return this._tags;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._tags = value;
                this._onChangeHandler(this._tags);
                this.tagsChange.emit(this._tags);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TagInputComponent.prototype, "input", {
            get: /**
             * @return {?}
             */ function () {
                return this._input;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._input = value;
                this.inputChange.emit(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        TagInputComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                if (!this.tagTemplate) {
                    this.tagTemplate = this._defaultTagTemplate;
                }
            };
        /**
         * @return {?}
         */
        TagInputComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // Watch for optional child typeahead control
                this.connectTypeahead(this.typeaheadQuery.first);
                this.typeaheadQuery.changes.pipe(operators.takeUntil(this._onDestroy))
                    .subscribe(function (query) { return _this.connectTypeahead(query.first); });
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        TagInputComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                if (changes["disabled"]) {
                    if (changes["disabled"].currentValue) {
                        // Clear selection and close dropdown
                        this.selectedIndex = -1;
                        if (this.typeahead) {
                            this.typeahead.open = false;
                        }
                    }
                }
                // Update validation status
                this.validate();
            };
        /**
         * @return {?}
         */
        TagInputComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                if (this._subscription) {
                    this._subscription.unsubscribe();
                }
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @param {?} value
         * @return {?}
         */
        TagInputComponent.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                if (value) {
                    this.tags = value;
                }
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        TagInputComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this._onChangeHandler = fn;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        TagInputComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this._onTouchedHandler = fn;
            };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        TagInputComponent.prototype.setDisabledState = /**
         * @param {?} isDisabled
         * @return {?}
         */
            function (isDisabled) {
                this.disabled = isDisabled;
            };
        /**
         * Set focus on the input field.
         */
        /**
         * Set focus on the input field.
         * @return {?}
         */
        TagInputComponent.prototype.focus = /**
         * Set focus on the input field.
         * @return {?}
         */
            function () {
                if (this.tagInput) {
                    this.tagInput.nativeElement.focus();
                }
            };
        /**
         * Validate the value of the control (tags property).
         */
        /**
         * Validate the value of the control (tags property).
         * @return {?}
         */
        TagInputComponent.prototype.validate = /**
         * Validate the value of the control (tags property).
         * @return {?}
         */
            function () {
                this.valid = true;
                var /** @type {?} */ tagRangeError = null;
                if (this.tags && (this.tags.length < this.minTags || this.tags.length > this.maxTags)) {
                    tagRangeError = {
                        given: this.tags.length,
                        min: this.minTags,
                        max: this.maxTags
                    };
                    this.valid = false;
                }
                this.validationErrors['tagRangeError'] = tagRangeError;
            };
        /**
         * @param {?} event
         * @return {?}
         */
        TagInputComponent.prototype.keyHandler = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this.disabled) {
                    return;
                }
                // Get the input field cursor location
                var /** @type {?} */ inputCursorPos = this.tagInput.nativeElement.selectionStart;
                // Determine if the input field has any text selected
                var /** @type {?} */ hasSelection = this.tagInput.nativeElement.selectionStart !== this.tagInput.nativeElement.selectionEnd;
                // Determine if a tag has focus
                var /** @type {?} */ tagSelected = this.isValidTagIndex(this.selectedIndex);
                var /** @type {?} */ inputLength = this.input ? this.input.length : 0;
                // Check whether the arrow keys can move the selection. Otherwise the input field takes the event.
                var /** @type {?} */ canNavigateLeft = tagSelected || (inputCursorPos <= 0 && !hasSelection);
                var /** @type {?} */ canNavigateRight = tagSelected || (inputCursorPos >= inputLength && !hasSelection);
                // Forward key events to the typeahead component.
                this._typeaheadKeyService.handleKey(event, this.typeahead);
                switch (event.which) {
                    case keycodes.ENTER:
                        // Check if a typeahead option is highlighted
                        if (this.typeahead && this.typeahead.open && this.typeahead.highlighted) {
                            // Add the typeahead option as a tag, clear the input, and close the dropdown
                            this.commitTypeahead(this.typeahead.highlighted);
                            this.typeahead.open = false;
                        }
                        else {
                            // Validate and add the input text as a tag, if possible
                            this.commitInput();
                        }
                        event.preventDefault();
                        break;
                    case keycodes.BACKSPACE:
                        if (canNavigateLeft) {
                            this.backspace();
                            event.stopPropagation();
                            event.preventDefault();
                        }
                        break;
                    case keycodes.DELETE:
                        if (tagSelected) {
                            this.removeTagAt(this.selectedIndex);
                        }
                        break;
                    case keycodes.LEFT_ARROW:
                        if (canNavigateLeft) {
                            this.moveSelection(-1);
                            event.preventDefault();
                        }
                        break;
                    case keycodes.RIGHT_ARROW:
                        if (canNavigateRight) {
                            this.moveSelection(1);
                            event.preventDefault();
                        }
                        break;
                }
                // Check for keys in the tagDelimiters
                if (this.tagDelimiters && this.tagDelimiters.indexOf(this.getKeyChar(event)) >= 0) {
                    // Commit previous text
                    this.commitInput();
                    event.stopPropagation();
                    event.preventDefault();
                }
            };
        /**
         * @return {?}
         */
        TagInputComponent.prototype.focusOutHandler = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // If a click on the typeahead is in progress, don't do anything.
                // This works around an issue in IE where clicking a scrollbar drops focus.
                if (this.typeahead && this.typeahead.clicking) {
                    return;
                }
                // Close the dropdown on blur
                setTimeout(function () {
                    if (!_this._element.nativeElement.contains(_this._document.activeElement)) {
                        _this.selectedIndex = -1;
                        if (_this.typeahead) {
                            _this.typeahead.open = false;
                        }
                    }
                }, 200);
            };
        /**
         * @param {?} event
         * @param {?} tag
         * @param {?} index
         * @return {?}
         */
        TagInputComponent.prototype.tagClickHandler = /**
         * @param {?} event
         * @param {?} tag
         * @param {?} index
         * @return {?}
         */
            function (event, tag, index) {
                if (this.disabled) {
                    return;
                }
                // Send tagClick event
                var /** @type {?} */ tagClickEvent = new TagInputEvent(tag);
                this.tagClick.emit(tagClickEvent);
                // Prevent focus if preventDefault() was called
                if (tagClickEvent.defaultPrevented()) {
                    event.preventDefault();
                    return;
                }
                // Select the tag (for IE that doesn't propagate focus)
                this.selectTagAt(index);
            };
        /**
         * @return {?}
         */
        TagInputComponent.prototype.inputClickHandler = /**
         * @return {?}
         */
            function () {
                if (this.disabled) {
                    return;
                }
                if (this.typeahead && this.showTypeaheadOnClick) {
                    this.typeahead.open = true;
                }
            };
        /**
         * @return {?}
         */
        TagInputComponent.prototype.inputFocusHandler = /**
         * @return {?}
         */
            function () {
                if (this.disabled) {
                    return;
                }
                this.selectInput();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        TagInputComponent.prototype.inputPasteHandler = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this.disabled) {
                    return;
                }
                if (this.addOnPaste) {
                    // Get text from the clipboard
                    var /** @type {?} */ input = null;
                    if (event.clipboardData) {
                        input = event.clipboardData.getData('text/plain');
                    }
                    else if (((window)).clipboardData) {
                        // Internet Explorer only
                        input = ((window)).clipboardData.getData('Text');
                    }
                    // Commit the clipboard text directly
                    if (this.commit(input)) {
                        this.selectInput();
                        event.stopPropagation();
                        event.preventDefault();
                    }
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        TagInputComponent.prototype.typeaheadOptionSelectedHandler = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this.disabled) {
                    return;
                }
                // When the typeahead sends the optionSelected event, commit the object directly
                this.commitTypeahead(event.option);
            };
        /**
         * Commit the current input value and clear the input field if successful.
         */
        /**
         * Commit the current input value and clear the input field if successful.
         * @return {?}
         */
        TagInputComponent.prototype.commitInput = /**
         * Commit the current input value and clear the input field if successful.
         * @return {?}
         */
            function () {
                if (this.commit(this.input)) {
                    this.selectInput();
                    this.input = '';
                }
            };
        /**
         * Commit the given tag object and clear the input if successful.
         */
        /**
         * Commit the given tag object and clear the input if successful.
         * @param {?} tag
         * @return {?}
         */
        TagInputComponent.prototype.commitTypeahead = /**
         * Commit the given tag object and clear the input if successful.
         * @param {?} tag
         * @return {?}
         */
            function (tag) {
                if (this.addTag(tag)) {
                    this.selectInput();
                    this.input = '';
                }
            };
        /**
         * Commit the given string value as one or more tags, if validation passes. Returns true if the tag(s) were created.
         */
        /**
         * Commit the given string value as one or more tags, if validation passes. Returns true if the tag(s) were created.
         * @param {?} input
         * @return {?}
         */
        TagInputComponent.prototype.commit = /**
         * Commit the given string value as one or more tags, if validation passes. Returns true if the tag(s) were created.
         * @param {?} input
         * @return {?}
         */
            function (input) {
                if (input && this.freeInput) {
                    // Split the tags by the tagDelimiters if configured
                    var /** @type {?} */ newTags = this.splitTagInput(input);
                    // Check tag validation for all of the individual values
                    var /** @type {?} */ allValid = true;
                    try {
                        for (var newTags_1 = __values(newTags), newTags_1_1 = newTags_1.next(); !newTags_1_1.done; newTags_1_1 = newTags_1.next()) {
                            var newTag = newTags_1_1.value;
                            var /** @type {?} */ valid = this.validateTag(newTag);
                            if (!valid) {
                                allValid = false;
                            }
                        }
                    }
                    catch (e_1_1) {
                        e_1 = { error: e_1_1 };
                    }
                    finally {
                        try {
                            if (newTags_1_1 && !newTags_1_1.done && (_a = newTags_1.return))
                                _a.call(newTags_1);
                        }
                        finally {
                            if (e_1)
                                throw e_1.error;
                        }
                    }
                    // Add the tags if all are valid
                    if (allValid) {
                        try {
                            for (var newTags_2 = __values(newTags), newTags_2_1 = newTags_2.next(); !newTags_2_1.done; newTags_2_1 = newTags_2.next()) {
                                var newTag = newTags_2_1.value;
                                this.addTag(this.createTag(newTag));
                            }
                        }
                        catch (e_2_1) {
                            e_2 = { error: e_2_1 };
                        }
                        finally {
                            try {
                                if (newTags_2_1 && !newTags_2_1.done && (_b = newTags_2.return))
                                    _b.call(newTags_2);
                            }
                            finally {
                                if (e_2)
                                    throw e_2.error;
                            }
                        }
                        return true;
                    }
                }
                return false;
                var e_1, _a, e_2, _b;
            };
        /**
         * If no tag is selected, select the rightmost tag. If a tag is selected, remove it.
         */
        /**
         * If no tag is selected, select the rightmost tag. If a tag is selected, remove it.
         * @return {?}
         */
        TagInputComponent.prototype.backspace = /**
         * If no tag is selected, select the rightmost tag. If a tag is selected, remove it.
         * @return {?}
         */
            function () {
                if (this.disabled) {
                    return;
                }
                if (!this.isValidTagIndex(this.selectedIndex)) {
                    this.selectTagAt(this.tags.length - 1);
                }
                else {
                    this.removeTagAt(this.selectedIndex);
                }
            };
        /**
         * Move the highlighted option forwards or backwards in the list. Wraps at the limits.
         * @param delta Value to be added to the selected index, i.e. -1 to move backwards, +1 to move forwards.
         */
        /**
         * Move the highlighted option forwards or backwards in the list. Wraps at the limits.
         * @param {?} delta Value to be added to the selected index, i.e. -1 to move backwards, +1 to move forwards.
         * @return {?}
         */
        TagInputComponent.prototype.moveSelection = /**
         * Move the highlighted option forwards or backwards in the list. Wraps at the limits.
         * @param {?} delta Value to be added to the selected index, i.e. -1 to move backwards, +1 to move forwards.
         * @return {?}
         */
            function (delta) {
                if (this.disabled) {
                    return;
                }
                if (this.isValidSelectIndex(this.selectedIndex)) {
                    this.selectedIndex += delta;
                    // Do wrapping of selection when out of bounds
                    if (this.selectedIndex < 0) {
                        this.selectedIndex = this.tags.length;
                    }
                    else if (this.selectedIndex > this.tags.length) {
                        this.selectedIndex = 0;
                    }
                }
            };
        /**
         * Returns a value to display for the given tag. Uses display function/property name if set, otherwise assumes that the tag is a simple string.
         */
        /**
         * Returns a value to display for the given tag. Uses display function/property name if set, otherwise assumes that the tag is a simple string.
         * @param {?} tag
         * @return {?}
         */
        TagInputComponent.prototype.getTagDisplay = /**
         * Returns a value to display for the given tag. Uses display function/property name if set, otherwise assumes that the tag is a simple string.
         * @param {?} tag
         * @return {?}
         */
            function (tag) {
                if (typeof this.display === 'function') {
                    return this.display(tag);
                }
                if (typeof this.display === 'string') {
                    return tag[(this.display)];
                }
                return tag;
            };
        /**
         * Returns true if the given index is selected (tag index or input field).
         */
        /**
         * Returns true if the given index is selected (tag index or input field).
         * @param {?} index
         * @return {?}
         */
        TagInputComponent.prototype.isSelected = /**
         * Returns true if the given index is selected (tag index or input field).
         * @param {?} index
         * @return {?}
         */
            function (index) {
                return index === this.selectedIndex;
            };
        /**
         * Select the tag at the given index. Does nothing if disabled is true.
         */
        /**
         * Select the tag at the given index. Does nothing if disabled is true.
         * @param {?} tagIndex
         * @return {?}
         */
        TagInputComponent.prototype.selectTagAt = /**
         * Select the tag at the given index. Does nothing if disabled is true.
         * @param {?} tagIndex
         * @return {?}
         */
            function (tagIndex) {
                if (this.disabled) {
                    return;
                }
                if (this.isValidTagIndex(tagIndex)) {
                    this.selectedIndex = tagIndex;
                }
            };
        /**
         * Select the input field, giving it focus. Does nothing if disabled is true.
         */
        /**
         * Select the input field, giving it focus. Does nothing if disabled is true.
         * @return {?}
         */
        TagInputComponent.prototype.selectInput = /**
         * Select the input field, giving it focus. Does nothing if disabled is true.
         * @return {?}
         */
            function () {
                if (this.disabled) {
                    return;
                }
                this.selectedIndex = this.tags.length;
            };
        /**
         * Remove the tag at the given index. Does nothing if disabled is true or the minTags property prevents removal.
         */
        /**
         * Remove the tag at the given index. Does nothing if disabled is true or the minTags property prevents removal.
         * @param {?} tagIndex
         * @return {?}
         */
        TagInputComponent.prototype.removeTagAt = /**
         * Remove the tag at the given index. Does nothing if disabled is true or the minTags property prevents removal.
         * @param {?} tagIndex
         * @return {?}
         */
            function (tagIndex) {
                if (this.disabled || !this.canRemoveTagAt(tagIndex)) {
                    return;
                }
                // Check that the tagIndex is in range
                if (this.isValidTagIndex(tagIndex)) {
                    var /** @type {?} */ tag = this.tags[tagIndex];
                    var /** @type {?} */ tagRemovingEvent = new TagInputEvent(tag);
                    this.tagRemoving.emit(tagRemovingEvent);
                    if (!tagRemovingEvent.defaultPrevented()) {
                        // Select input first to avoid issues with dropping focus
                        this.selectInput();
                        // Remove the tag
                        this.tags.splice(tagIndex, 1);
                        // Set focus again since indices have changed
                        this.selectInput();
                        this.tagRemoved.emit(new TagInputEvent(tag));
                        this.validate();
                    }
                }
            };
        /**
         * Returns true if the tag at the given index can be removed.
         */
        /**
         * Returns true if the tag at the given index can be removed.
         * @param {?} tagIndex
         * @return {?}
         */
        TagInputComponent.prototype.canRemoveTagAt = /**
         * Returns true if the tag at the given index can be removed.
         * @param {?} tagIndex
         * @return {?}
         */
            function (tagIndex) {
                return this.tags.length > this.minTags || !this.enforceTagLimits;
            };
        /**
         * Returns true if the input field should be available.
         */
        /**
         * Returns true if the input field should be available.
         * @return {?}
         */
        TagInputComponent.prototype.isInputVisible = /**
         * Returns true if the input field should be available.
         * @return {?}
         */
            function () {
                return this.tags.length < this.maxTags || !this.enforceTagLimits;
            };
        /**
         * Returns true if any part of the control has focus.
         */
        /**
         * Returns true if any part of the control has focus.
         * @return {?}
         */
        TagInputComponent.prototype.hasFocus = /**
         * Returns true if any part of the control has focus.
         * @return {?}
         */
            function () {
                return this.isValidSelectIndex(this.selectedIndex);
            };
        /**
         * @param {?} typeahead
         * @return {?}
         */
        TagInputComponent.prototype.connectTypeahead = /**
         * @param {?} typeahead
         * @return {?}
         */
            function (typeahead) {
                var _this = this;
                if (this._subscription) {
                    this._subscription.unsubscribe();
                    this._subscription = null;
                }
                this.typeahead = typeahead;
                if (this.typeahead) {
                    // Set up event handler for selected options
                    this._subscription = this.typeahead.optionSelected.subscribe(this.typeaheadOptionSelectedHandler.bind(this));
                    // Set up event handler for the highlighted element
                    // Added a delay to move it out of the current change detection cycle
                    this._subscription.add(this.typeahead.highlightedElementChange.pipe(tick())
                        .subscribe(function (element) { return _this.highlightedElement = element; }));
                }
            };
        /**
         * Validate the given tagValue with the tagPattern, if set. Update validationErrors on validation failure.
         * @param {?} tagValue
         * @return {?}
         */
        TagInputComponent.prototype.validateTag = /**
         * Validate the given tagValue with the tagPattern, if set. Update validationErrors on validation failure.
         * @param {?} tagValue
         * @return {?}
         */
            function (tagValue) {
                var /** @type {?} */ inputPattern = null;
                this.inputValid = true;
                if (this.tagPattern && !this.tagPattern.test(tagValue)) {
                    inputPattern = {
                        given: tagValue,
                        pattern: this.tagPattern
                    };
                    this.inputValid = false;
                }
                this.validationErrors['inputPattern'] = inputPattern;
                return this.inputValid;
            };
        /**
         * Create a tag object for the given tagValue. If createTagHandler is specified, use it; otherwise if displayProperty is specified, create an object with the tagValue as the single named property; otherwise return the tagValue itself.
         * @param {?} tagValue
         * @return {?}
         */
        TagInputComponent.prototype.createTag = /**
         * Create a tag object for the given tagValue. If createTagHandler is specified, use it; otherwise if displayProperty is specified, create an object with the tagValue as the single named property; otherwise return the tagValue itself.
         * @param {?} tagValue
         * @return {?}
         */
            function (tagValue) {
                var /** @type {?} */ tag = null;
                if (this.createTagHandler && typeof this.createTagHandler === 'function') {
                    tag = this.createTagHandler(tagValue);
                }
                else if (typeof this.display === 'string') {
                    tag = {};
                    tag[(this.display)] = tagValue;
                }
                else {
                    tag = tagValue;
                }
                return tag;
            };
        /**
         * Add a tag object, calling the tagAdding and tagAdded events. Returns true if the tag was added to the tags array.
         * @param {?} tag
         * @return {?}
         */
        TagInputComponent.prototype.addTag = /**
         * Add a tag object, calling the tagAdding and tagAdded events. Returns true if the tag was added to the tags array.
         * @param {?} tag
         * @return {?}
         */
            function (tag) {
                if (tag) {
                    // Verify that the new tag can be displayed
                    var /** @type {?} */ displayValue = this.getTagDisplay(tag);
                    if (displayValue && typeof displayValue === 'string' && displayValue.length > 0) {
                        var /** @type {?} */ tagAddingEvent = new TagInputEvent(tag);
                        this.tagAdding.emit(tagAddingEvent);
                        if (!tagAddingEvent.defaultPrevented()) {
                            this.tags = this.tags || [];
                            this.tags.push(tag);
                            this.tagAdded.emit(new TagInputEvent(tag));
                            this.validate();
                            return true;
                        }
                    }
                }
                return false;
            };
        /**
         * Returns true if the given tagIndex is a valid tag index.
         * @param {?} tagIndex
         * @return {?}
         */
        TagInputComponent.prototype.isValidTagIndex = /**
         * Returns true if the given tagIndex is a valid tag index.
         * @param {?} tagIndex
         * @return {?}
         */
            function (tagIndex) {
                return tagIndex >= 0 && tagIndex < this.tags.length;
            };
        /**
         * Returns true if the given index is a valid selection index (tags or input field).
         * @param {?} index
         * @return {?}
         */
        TagInputComponent.prototype.isValidSelectIndex = /**
         * Returns true if the given index is a valid selection index (tags or input field).
         * @param {?} index
         * @return {?}
         */
            function (index) {
                return index >= 0 && index <= this.tags.length;
            };
        /**
         * Returns the character corresponding to the given key event, mainly for IE compatibility.
         * @param {?} event
         * @return {?}
         */
        TagInputComponent.prototype.getKeyChar = /**
         * Returns the character corresponding to the given key event, mainly for IE compatibility.
         * @param {?} event
         * @return {?}
         */
            function (event) {
                switch (event.which) {
                    case keycodes.SPACE:
                        return ' ';
                }
                return event.key;
            };
        /**
         * Returns an array of strings corresponding to the input string split by the tagDelimiters characters.
         * @param {?} input
         * @return {?}
         */
        TagInputComponent.prototype.splitTagInput = /**
         * Returns an array of strings corresponding to the input string split by the tagDelimiters characters.
         * @param {?} input
         * @return {?}
         */
            function (input) {
                var /** @type {?} */ tagValues = [input];
                if (this.tagDelimiters && typeof this.tagDelimiters === 'string') {
                    var /** @type {?} */ escapedDelimiters = this.tagDelimiters.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
                    var /** @type {?} */ delimiterRegex = new RegExp("[" + escapedDelimiters + "]", 'g');
                    tagValues = input.split(delimiterRegex).filter(function (s) { return s.length > 0; });
                }
                return tagValues;
            };
        TagInputComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-tag-input',
                        exportAs: 'ux-tag-input',
                        template: "<ol [attr.role]=\"typeahead ? 'combobox' : 'none'\" [attr.aria-haspopup]=\"typeahead ? 'listbox' : null\">\n    <li *ngFor=\"let tag of tags; let i = index\" class=\"ux-tag\"\n        [class.disabled]=\"disabled\"\n        [ngClass]=\"tagClass(tag, i, isSelected(i))\"\n        [attr.tabindex]=\"disabled ? null : 0\"\n        [focusIf]=\"isSelected(i)\"\n        (click)=\"tagClickHandler($event, tag, i)\"\n        (focus)=\"selectTagAt(i)\">\n\n        <ng-container [ngTemplateOutlet]=\"tagTemplate\"\n            [ngTemplateOutletContext]=\"{tag: tag, index: i, disabled: disabled, api: tagApi}\">\n        </ng-container>\n\n    </li>\n    <li *ngIf=\"isInputVisible()\" class=\"ux-tag-input\" role=\"none\">\n        <input #tagInput type=\"text\" [attr.id]=\"id\" class=\"ux-tag-input\"\n            [(ngModel)]=\"input\"\n            [class.invalid]=\"!inputValid\"\n            [attr.aria-activedescendant]=\"highlightedElement?.id\"\n            [attr.aria-autocomplete]=\"typeahead ? 'list' : 'none'\"\n            [attr.aria-controls]=\"typeahead?.id\"\n            aria-multiline=\"false\"\n            [placeholder]=\"disabled ? '' : (placeholder || '')\"\n            [disabled]=\"disabled\"\n            [focusIf]=\"isSelected(tags.length)\"\n            (click)=\"inputClickHandler()\"\n            (focus)=\"inputFocusHandler()\"\n            (paste)=\"inputPasteHandler($event)\">\n    </li>\n</ol>\n\n<ng-content #typeahead></ng-content>\n\n<ng-template #defaultTagTemplate let-tag=\"tag\" let-index=\"index\" let-disabled=\"disabled\" let-api=\"api\">\n    <span class=\"ux-tag-text\">{{api.getTagDisplay(tag)}}</span>\n    <button *ngIf=\"api.canRemoveTagAt(index)\"\n        type=\"button\"\n        class=\"ux-tag-remove\"\n        aria-label=\"Remove Item\"\n        [disabled]=\"disabled\"\n        (click)=\"api.removeTagAt(index); $event.stopPropagation();\">\n        <span class=\"hpe-icon hpe-close\"></span>\n    </button>\n</ng-template>",
                        providers: [TAGINPUT_VALUE_ACCESSOR, TAGINPUT_VALIDATOR],
                        host: {
                            '[class.disabled]': 'disabled',
                            '[class.focus]': 'hasFocus()',
                            '[class.invalid]': '!valid || !inputValid'
                        }
                    }] }
        ];
        /** @nocollapse */
        TagInputComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] },
                { type: TypeaheadKeyService }
            ];
        };
        TagInputComponent.propDecorators = {
            id: [{ type: core.Input }, { type: core.HostBinding, args: ['attr.id',] }],
            tags: [{ type: core.Input, args: ['tags',] }],
            tagsChange: [{ type: core.Output }],
            input: [{ type: core.Input, args: ['input',] }],
            inputChange: [{ type: core.Output }],
            display: [{ type: core.Input }],
            addOnPaste: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            enforceTagLimits: [{ type: core.Input }],
            freeInput: [{ type: core.Input }],
            maxTags: [{ type: core.Input }],
            minTags: [{ type: core.Input }],
            placeholder: [{ type: core.Input }],
            showTypeaheadOnClick: [{ type: core.Input }],
            tagDelimiters: [{ type: core.Input }],
            tagPattern: [{ type: core.Input }],
            tagTemplate: [{ type: core.Input }],
            tagClass: [{ type: core.Input }],
            validationErrors: [{ type: core.Input }],
            createTagHandler: [{ type: core.Input, args: ['createTag',] }],
            trackAriaDescendant: [{ type: core.Input }],
            tagAdding: [{ type: core.Output }],
            tagAdded: [{ type: core.Output }],
            tagInvalidated: [{ type: core.Output }],
            tagRemoving: [{ type: core.Output }],
            tagRemoved: [{ type: core.Output }],
            tagClick: [{ type: core.Output }],
            typeaheadQuery: [{ type: core.ContentChildren, args: [TypeaheadComponent,] }],
            tagInput: [{ type: core.ViewChild, args: ['tagInput',] }],
            _defaultTagTemplate: [{ type: core.ViewChild, args: ['defaultTagTemplate',] }],
            keyHandler: [{ type: core.HostListener, args: ['keydown', ['$event'],] }],
            focusOutHandler: [{ type: core.HostListener, args: ['focusout',] }]
        };
        return TagInputComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TagInputModule = (function () {
        function TagInputModule() {
        }
        TagInputModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            FocusIfModule,
                            TypeaheadModule
                        ],
                        exports: [TagInputComponent],
                        declarations: [TagInputComponent],
                        providers: [],
                    },] }
        ];
        return TagInputModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SelectModule = (function () {
        function SelectModule() {
        }
        SelectModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            forms.FormsModule,
                            InfiniteScrollModule,
                            TagInputModule,
                            TypeaheadModule
                        ],
                        exports: [SelectComponent],
                        declarations: [SelectComponent]
                    },] }
        ];
        return SelectModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var BaseSearchComponent = (function () {
        function BaseSearchComponent(_searchBuilderService) {
            this._searchBuilderService = _searchBuilderService;
            this._id = this._searchBuilderService.generateComponentId();
            this._valid = true;
        }
        Object.defineProperty(BaseSearchComponent.prototype, "id", {
            get: /**
             * @return {?}
             */ function () {
                return "ux-search-builder-search-component-" + this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseSearchComponent.prototype, "value", {
            /**
             * Get the current value of the component
             */
            get: /**
             * Get the current value of the component
             * @return {?}
             */ function () {
                return this.context.value;
            },
            /**
             * Set the current value of the component
             */
            set: /**
             * Set the current value of the component
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.context.value = value;
                this._searchBuilderService.queryHasChanged();
                // if value has been set perform validation
                this.validate();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseSearchComponent.prototype, "valid", {
            get: /**
             * @return {?}
             */ function () {
                return this._valid;
            },
            set: /**
             * @param {?} valid
             * @return {?}
             */ function (valid) {
                this._valid = valid;
                this._searchBuilderService.setValid(this._id, valid);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Make sure we clean up after ourselves
         */
        /**
         * Make sure we clean up after ourselves
         * @return {?}
         */
        BaseSearchComponent.prototype.ngOnDestroy = /**
         * Make sure we clean up after ourselves
         * @return {?}
         */
            function () {
                this.valid = true;
            };
        /**
         * Perform any required validation on the value
         */
        /**
         * Perform any required validation on the value
         * @return {?}
         */
        BaseSearchComponent.prototype.validate = /**
         * Perform any required validation on the value
         * @return {?}
         */
            function () {
                // if a custom validation function has been provided then use it
                this.valid = this.config.validation ? this.config.validation(this, this.value) : true;
            };
        BaseSearchComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-base-search',
                        template: ''
                    }] }
        ];
        /** @nocollapse */
        BaseSearchComponent.ctorParameters = function () {
            return [
                { type: SearchBuilderService }
            ];
        };
        return BaseSearchComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SearchDateRangeComponent = (function (_super) {
        __extends(SearchDateRangeComponent, _super);
        function SearchDateRangeComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 'date-range';
            return _this;
        }
        Object.defineProperty(SearchDateRangeComponent.prototype, "label", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.label;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchDateRangeComponent.prototype, "from", {
            get: /**
             * @return {?}
             */ function () {
                // if value does not exist the set it
                if (!this.value || !this.value.from) {
                    this.from = new Date();
                }
                // ensure that the from value is a date object
                if (this.value.from instanceof Date === false) {
                    this.value.from = new Date(this.value.from);
                }
                return this.value.from;
            },
            set: /**
             * @param {?} fromValue
             * @return {?}
             */ function (fromValue) {
                // create new object based on the current value
                var /** @type {?} */ value = Object.assign({}, this.value);
                // ensure that the from value is a date
                if (fromValue instanceof Date === false) {
                    fromValue = new Date(fromValue);
                }
                // set the latest value
                value.from = fromValue;
                // update the value object while ensuring immutability
                this.value = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchDateRangeComponent.prototype, "to", {
            get: /**
             * @return {?}
             */ function () {
                // if value does not exist the set it
                if (!this.value || !this.value.to) {
                    this.to = new Date();
                }
                // ensure that the to value is a date object
                if (this.value.to instanceof Date === false) {
                    this.value.to = new Date(this.value.to);
                }
                return this.value.to;
            },
            set: /**
             * @param {?} toValue
             * @return {?}
             */ function (toValue) {
                // create new object based on the current value
                var /** @type {?} */ value = Object.assign({}, this.value);
                // ensure that the to value is a date
                if (toValue instanceof Date === false) {
                    toValue = new Date(toValue);
                }
                // set the latest value
                value.to = toValue;
                // update the value object while ensuring immutability
                this.value = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchDateRangeComponent.prototype, "fromLabel", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.fromLabel || 'From';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchDateRangeComponent.prototype, "toLabel", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.toLabel || 'To';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchDateRangeComponent.prototype, "fromPlaceholder", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.fromPlaceholder;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchDateRangeComponent.prototype, "toPlaceholder", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.toPlaceholder;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Override the default validation
         */
        /**
         * Override the default validation
         * @return {?}
         */
        SearchDateRangeComponent.prototype.validate = /**
         * Override the default validation
         * @return {?}
         */
            function () {
                // check if there is a config validation function
                if (this.config.validation) {
                    return _super.prototype.validate.call(this);
                }
                // create copies of the dates so we can modify time value (to ignore it)
                var /** @type {?} */ from$$1 = new Date(this.value.from);
                var /** @type {?} */ to = new Date(this.value.to);
                // set the time to the same so we dont compare it
                from$$1.setHours(0, 0, 0, 0);
                to.setHours(0, 0, 0, 0);
                // valid if the from date is less than or equal to the to date
                this.valid = from$$1 <= to;
            };
        SearchDateRangeComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-search-date-range',
                        template: "<label class=\"form-label\" *ngIf=\"label\">{{ label }}</label>\n\n<div class=\"row\">\n    <div class=\"col-sm-12\">\n        <div class=\"form-inline\" [class.has-error]=\"!valid\">\n\n            <div class=\"form-group p-r-md\">\n                <label class=\"form-label m-r-xs\">{{ fromLabel }}</label>\n\n                <div class=\"input-group date m-nil\">\n                    <span class=\"input-group-addon p-r-xs\" tabindex=\"1\" (click)=\"fromPopover.show()\">\n                        <i class=\"hpe-icon hpe-calendar\" aria-hidden=\"true\"></i>\n                    </span>\n                    <input type=\"text\" #fromPopover=\"ux-popover\" [ngModel]=\"from | date:'dd MMMM yyyy'\"\n                        [uxPopover]=\"fromPopoverTemplate\" placement=\"bottom\" popoverClass=\"date-time-picker-popover\"\n                        class=\"form-control\" aria-label=\"Selected date\" [placeholder]=\"fromPlaceholder\" [focusIf]=\"focus\">\n                </div>\n            </div>\n\n            <div class=\"form-group p-r-xs\">\n                <label class=\"form-label m-r-xs\">{{ toLabel }}</label>\n\n                <div class=\"input-group date m-nil\">\n                    <span class=\"input-group-addon\" tabindex=\"1\" (click)=\"toPopover.show()\">\n                        <i class=\"hpe-icon hpe-calendar\" aria-hidden=\"true\"></i>\n                    </span>\n                    <input type=\"text\" #toPopover=\"ux-popover\" [ngModel]=\"to | date:'dd MMMM yyyy'\"\n                        [uxPopover]=\"toPopoverTemplate\" placement=\"bottom\" popoverClass=\"date-time-picker-popover\"\n                        class=\"form-control\" aria-label=\"Selected date\" [placeholder]=\"toPlaceholder\">\n                </div>\n            </div>\n\n        </div>\n    </div>\n</div>\n\n<ng-template #fromPopoverTemplate>\n    <ux-date-time-picker [(date)]=\"from\" [showTime]=\"false\"></ux-date-time-picker>\n</ng-template>\n\n<ng-template #toPopoverTemplate>\n    <ux-date-time-picker [(date)]=\"to\" [showTime]=\"false\"></ux-date-time-picker>\n</ng-template>"
                    }] }
        ];
        return SearchDateRangeComponent;
    }(BaseSearchComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SearchDateComponent = (function (_super) {
        __extends(SearchDateComponent, _super);
        function SearchDateComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 'date';
            return _this;
        }
        Object.defineProperty(SearchDateComponent.prototype, "label", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.label;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchDateComponent.prototype, "placeholder", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.placeholder || 'Enter date';
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        SearchDateComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                // by default set to the current date if not specified
                if (!this.value) {
                    this.value = new Date();
                }
            };
        SearchDateComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-search-date',
                        template: "<label class=\"form-label\" *ngIf=\"label\">{{ label }}</label>\n\n<div class=\"input-group date m-nil\">\n    <span class=\"input-group-addon\" tabindex=\"1\" (click)=\"popover.show()\">\n        <i class=\"hpe-icon hpe-calendar\" aria-hidden=\"true\"></i>\n    </span>\n    <input type=\"text\"\n        class=\"form-control\"\n        aria-label=\"Selected date\"\n        [placeholder]=\"placeholder\"\n        #popover=\"ux-popover\"\n        [ngModel]=\"value | date:'dd MMMM yyyy'\"\n        [uxPopover]=\"popoverTemplate\"\n        placement=\"bottom\"\n        popoverClass=\"date-time-picker-popover\"\n        [focusIf]=\"focus\">\n</div>\n\n<ng-template #popoverTemplate>\n    <ux-date-time-picker [(date)]=\"value\" [showTime]=\"false\"></ux-date-time-picker>\n</ng-template>"
                    }] }
        ];
        return SearchDateComponent;
    }(BaseSearchComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SearchSelectComponent = (function (_super) {
        __extends(SearchSelectComponent, _super);
        function SearchSelectComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 'select';
            return _this;
        }
        Object.defineProperty(SearchSelectComponent.prototype, "label", {
            /**
             * Provide defaults for undefined properties
             */
            get: /**
             * Provide defaults for undefined properties
             * @return {?}
             */ function () {
                return this.config.label;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchSelectComponent.prototype, "options", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.options || [];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchSelectComponent.prototype, "multiple", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.multiple || false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchSelectComponent.prototype, "placeholder", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.placeholder || 'Select item';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchSelectComponent.prototype, "dropDirection", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.dropDirection || 'down';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchSelectComponent.prototype, "allowNull", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.allowNull || false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchSelectComponent.prototype, "disabled", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.disabled || false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchSelectComponent.prototype, "maxHeight", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.maxHeight || '250px';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchSelectComponent.prototype, "pageSize", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.pageSize || 20;
            },
            enumerable: true,
            configurable: true
        });
        SearchSelectComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-search-select',
                        template: "<label class=\"form-label\" *ngIf=\"label\">{{ label }}</label>\n\n<ux-select [(value)]=\"value\"\n           [options]=\"options\"\n           [multiple]=\"multiple\"\n           [placeholder]=\"placeholder\"\n           [dropDirection]=\"dropDirection\"\n           [pageSize]=\"pageSize\"\n           [allowNull]=\"allowNull\"\n           [disabled]=\"disabled\"\n           [maxHeight]=\"maxHeight\"\n           [key]=\"config.key\"\n           [display]=\"config.display\"\n           [loadingTemplate]=\"config.loadingTemplate\"\n           [optionTemplate]=\"config.optionTemplate\"\n           [noOptionsTemplate]=\"config.noOptionsTemplate\"\n           [focusIf]=\"focus\">\n</ux-select>"
                    }] }
        ];
        return SearchSelectComponent;
    }(BaseSearchComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SearchTextComponent = (function (_super) {
        __extends(SearchTextComponent, _super);
        function SearchTextComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 'text';
            return _this;
        }
        Object.defineProperty(SearchTextComponent.prototype, "label", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.label;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SearchTextComponent.prototype, "placeholder", {
            get: /**
             * @return {?}
             */ function () {
                return this.config.placeholder || 'Enter text';
            },
            enumerable: true,
            configurable: true
        });
        SearchTextComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-search-text',
                        template: "<label *ngIf=\"label\" class=\"form-label\" [attr.for]=\"id\">{{ label }}</label>\n<input [attr.id]=\"id\" class=\"form-control\" [placeholder]=\"placeholder\" [(ngModel)]=\"value\" [focusIf]=\"focus\">"
                    }] }
        ];
        return SearchTextComponent;
    }(BaseSearchComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SearchBuilderModule = (function () {
        function SearchBuilderModule() {
        }
        SearchBuilderModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            AccessibilityModule,
                            common.CommonModule,
                            DateTimePickerModule,
                            FocusIfModule,
                            forms.FormsModule,
                            PopoverModule,
                            SelectModule,
                        ],
                        exports: [
                            SearchBuilderComponent,
                            SearchBuilderGroupComponent,
                            BaseSearchComponent
                        ],
                        declarations: [
                            SearchBuilderComponent,
                            SearchBuilderGroupComponent,
                            SearchTextComponent,
                            SearchDateComponent,
                            SearchDateRangeComponent,
                            SearchBuilderOutletDirective,
                            SearchSelectComponent,
                            BaseSearchComponent
                        ],
                        entryComponents: [
                            SearchTextComponent,
                            SearchDateComponent,
                            SearchDateRangeComponent,
                            SearchSelectComponent
                        ],
                        providers: [
                            SearchBuilderFocusService
                        ]
                    },] }
        ];
        return SearchBuilderModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SelectionStrategy = (function () {
        function SelectionStrategy(selectionService) {
            this.selectionService = selectionService;
        }
        /**
         * @param {?} selectionService
         * @return {?}
         */
        SelectionStrategy.prototype.setSelectionService = /**
         * @param {?} selectionService
         * @return {?}
         */
            function (selectionService) {
                this.selectionService = selectionService;
            };
        /**
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
        SelectionStrategy.prototype.mousedown = /**
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
            function (event, data) { };
        /**
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
        SelectionStrategy.prototype.click = /**
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
            function (event, data) { };
        /**
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
        SelectionStrategy.prototype.keydown = /**
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
            function (event, data) { };
        /**
         * Select the item - default behavior
         */
        /**
         * Select the item - default behavior
         * @param {...?} data
         * @return {?}
         */
        SelectionStrategy.prototype.select = /**
         * Select the item - default behavior
         * @param {...?} data
         * @return {?}
         */
            function () {
                var data = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    data[_i] = arguments[_i];
                }
                (_a = this.selectionService).select.apply(_a, __spread(data));
                var _a;
            };
        /**
         * Toggle the item's selected state - default behavior
         */
        /**
         * Toggle the item's selected state - default behavior
         * @param {...?} data
         * @return {?}
         */
        SelectionStrategy.prototype.toggle = /**
         * Toggle the item's selected state - default behavior
         * @param {...?} data
         * @return {?}
         */
            function () {
                var data = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    data[_i] = arguments[_i];
                }
                (_a = this.selectionService).toggle.apply(_a, __spread(data));
                var _a;
            };
        /**
         * Deselect the item - default behavior
         */
        /**
         * Deselect the item - default behavior
         * @param {...?} data
         * @return {?}
         */
        SelectionStrategy.prototype.deselect = /**
         * Deselect the item - default behavior
         * @param {...?} data
         * @return {?}
         */
            function () {
                var data = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    data[_i] = arguments[_i];
                }
                (_a = this.selectionService).deselect.apply(_a, __spread(data));
                var _a;
            };
        /**
         * Select all items - default behavior
         */
        /**
         * Select all items - default behavior
         * @return {?}
         */
        SelectionStrategy.prototype.selectAll = /**
         * Select all items - default behavior
         * @return {?}
         */
            function () {
                this.select.apply(this, __spread(this.selectionService.dataset));
            };
        /**
         * Deselect all items - default behavior
         */
        /**
         * Deselect all items - default behavior
         * @return {?}
         */
        SelectionStrategy.prototype.deselectAll = /**
         * Deselect all items - default behavior
         * @return {?}
         */
            function () {
                // call deselect on all items in the dataset
                this.selectionService.deselectAll();
            };
        /**
         * @return {?}
         */
        SelectionStrategy.prototype.destroy = /**
         * @return {?}
         */
            function () { };
        return SelectionStrategy;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var RowSelectionStrategy = (function (_super) {
        __extends(RowSelectionStrategy, _super);
        function RowSelectionStrategy() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._selection = { start: null, end: null };
            return _this;
        }
        /**
         * By default on shift click the browser will highlight
         * text. This looks bad and we don't want this to occur
         */
        /**
         * By default on shift click the browser will highlight
         * text. This looks bad and we don't want this to occur
         * @param {?} event
         * @return {?}
         */
        RowSelectionStrategy.prototype.mousedown = /**
         * By default on shift click the browser will highlight
         * text. This looks bad and we don't want this to occur
         * @param {?} event
         * @return {?}
         */
            function (event) {
                event.preventDefault();
            };
        /**
         * When a row is clicked we want to handle selection
         */
        /**
         * When a row is clicked we want to handle selection
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
        RowSelectionStrategy.prototype.click = /**
         * When a row is clicked we want to handle selection
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
            function (event, data) {
                // determine which modifier keys are pressed
                var ctrlKey = event.ctrlKey, shiftKey = event.shiftKey;
                // if the shift key is pressed we want to perform a multiple selection
                if (shiftKey) {
                    return this.multipleSelect(data);
                }
                // if the control key is pressed we want to perform an additive toggle selection
                if (ctrlKey) {
                    return this.toggle(data);
                }
                // perform a single selection where all other rows are deselected
                this.singleSelect(data);
            };
        /**
         * To support full keyboard control we need to support the following:
         * 1. Arrow keys to navigate up and down
         * 2. Spacebar to toggle selection
         * 3. Shift + Arrow keys to multiple select
         * 4. Ctrl + Arrow keys to allow retained selection and navigation
         */
        /**
         * To support full keyboard control we need to support the following:
         * 1. Arrow keys to navigate up and down
         * 2. Spacebar to toggle selection
         * 3. Shift + Arrow keys to multiple select
         * 4. Ctrl + Arrow keys to allow retained selection and navigation
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
        RowSelectionStrategy.prototype.keydown = /**
         * To support full keyboard control we need to support the following:
         * 1. Arrow keys to navigate up and down
         * 2. Spacebar to toggle selection
         * 3. Shift + Arrow keys to multiple select
         * 4. Ctrl + Arrow keys to allow retained selection and navigation
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
            function (event, data) {
                switch (event.which) {
                    case keycodes.UP_ARROW:
                    case keycodes.DOWN_ARROW:
                        event.preventDefault();
                        this.navigate(event, data);
                        break;
                    case keycodes.SPACE:
                        event.preventDefault();
                        this.selectionService.strategy.toggle(data, true);
                        break;
                }
            };
        /**
         * Override the standard toggle function to store or clear the
         * most recently selected item
         */
        /**
         * Override the standard toggle function to store or clear the
         * most recently selected item
         * @param {?} data
         * @param {?=} activate
         * @return {?}
         */
        RowSelectionStrategy.prototype.toggle = /**
         * Override the standard toggle function to store or clear the
         * most recently selected item
         * @param {?} data
         * @param {?=} activate
         * @return {?}
         */
            function (data, activate) {
                if (activate === void 0) {
                    activate = false;
                }
                _super.prototype.toggle.call(this, data);
                // store or clear the selection
                this.selectionService.isSelected(data) ? this.setSelectionStart(data) : this.clearSelection();
                // if we want to keep the item activated then activate
                if (activate) {
                    this.selectionService.activate(data);
                }
            };
        /**
         * Clear all other selected items and select only
         * the most recently selected item
         * @param {?} data
         * @return {?}
         */
        RowSelectionStrategy.prototype.singleSelect = /**
         * Clear all other selected items and select only
         * the most recently selected item
         * @param {?} data
         * @return {?}
         */
            function (data) {
                // deselect all other rows if neither modifier key is pressed
                this.deselectAll();
                // select the current row
                this.select(data);
                // store the current item as the selection start
                this.setSelectionStart(data);
            };
        /**
         * Handle multiple selection:
         * 1. If no start item selected - select it
         * 2. If a start item has been selected - select all in between
         * 3. If a start and end item have been selected clear the range and then select the new range
         */
        /**
         * Handle multiple selection:
         * 1. If no start item selected - select it
         * 2. If a start item has been selected - select all in between
         * 3. If a start and end item have been selected clear the range and then select the new range
         * @param {?} data
         * @return {?}
         */
        RowSelectionStrategy.prototype.multipleSelect = /**
         * Handle multiple selection:
         * 1. If no start item selected - select it
         * 2. If a start item has been selected - select all in between
         * 3. If a start and end item have been selected clear the range and then select the new range
         * @param {?} data
         * @return {?}
         */
            function (data) {
                // if no selection currently exists then perform initial selection
                if (!this._selection.start) {
                    // select the row
                    this.select(data);
                    // store the starting point
                    return this.setSelectionStart(data);
                }
                // if a multiple selection already took place - clear the previous selection
                if (this._selection.start && this._selection.end) {
                    this.deselect.apply(this, __spread(this.getSelectedItems()));
                }
                // set the new selection end point
                this.setSelectionEnd(data);
                // select all the items in the range
                this.select.apply(this, __spread(this.getSelectedItems()));
            };
        /**
         * Set the selection start point. If there was previously a
         * selection end point then clear it as this is a new selection
         * @param {?} data
         * @return {?}
         */
        RowSelectionStrategy.prototype.setSelectionStart = /**
         * Set the selection start point. If there was previously a
         * selection end point then clear it as this is a new selection
         * @param {?} data
         * @return {?}
         */
            function (data) {
                this._selection.start = data;
                this._selection.end = null;
                // activate the item
                this.selectionService.activate(data);
            };
        /**
         * Set the selection end point
         * @param {?} data
         * @return {?}
         */
        RowSelectionStrategy.prototype.setSelectionEnd = /**
         * Set the selection end point
         * @param {?} data
         * @return {?}
         */
            function (data) {
                this._selection.end = data;
                // activate the item
                this.selectionService.activate(data);
            };
        /**
         * Clear both start and end selection points
         */
        /**
         * Clear both start and end selection points
         * @param {?=} deactivate
         * @return {?}
         */
        RowSelectionStrategy.prototype.clearSelection = /**
         * Clear both start and end selection points
         * @param {?=} deactivate
         * @return {?}
         */
            function (deactivate) {
                if (deactivate === void 0) {
                    deactivate = true;
                }
                // reset the selected item
                this._selection = { start: null, end: null };
                // remove the current active item
                if (deactivate) {
                    this.selectionService.deactivate();
                }
            };
        /**
         * Determine all the items affected by the current selection.
         * Note that the end point may be above the start point so
         * we need to account for this.
         * @return {?}
         */
        RowSelectionStrategy.prototype.getSelectedItems = /**
         * Determine all the items affected by the current selection.
         * Note that the end point may be above the start point so
         * we need to account for this.
         * @return {?}
         */
            function () {
                // get the latest dataset
                var dataset = this.selectionService.dataset;
                // get the indexes of the start and end point
                var /** @type {?} */ startIdx = dataset.indexOf(this._selection.start);
                var /** @type {?} */ endIdx = dataset.indexOf(this._selection.end);
                // get the region of the array that is selected - note the endIdx may be before the startIdx so account for this
                return dataset.slice(Math.min(startIdx, endIdx), Math.max(startIdx, endIdx) + 1);
            };
        /**
         * Activate the sibling item when arrow keys are pressed
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
        RowSelectionStrategy.prototype.navigate = /**
         * Activate the sibling item when arrow keys are pressed
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
            function (event, data) {
                // determine which modifier keys are pressed
                var ctrlKey = event.ctrlKey, shiftKey = event.shiftKey;
                // if no modifier keys are pressed then deselect all and clear the selection
                if (!ctrlKey && !shiftKey) {
                    this.deselectAll();
                    this.clearSelection(false);
                }
                // activate the sibling - if the up arrow is pressed then navigate to the previous sibling
                var /** @type {?} */ sibling = this.selectionService.activateSibling(event.which === keycodes.UP_ARROW);
                // if the shift key is pressed then we also want to toggle the state if the item
                if (shiftKey && sibling) {
                    // if there is no current selection start then select the current row
                    if (!this._selection.start) {
                        this.multipleSelect(data);
                    }
                    this.multipleSelect(sibling);
                }
            };
        return RowSelectionStrategy;
    }(SelectionStrategy));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var RowAltSelectionStrategy = (function (_super) {
        __extends(RowAltSelectionStrategy, _super);
        function RowAltSelectionStrategy() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
        RowAltSelectionStrategy.prototype.keydown = /**
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
            function (event, data) {
                switch (event.which) {
                    case keycodes.UP_ARROW:
                    case keycodes.DOWN_ARROW:
                        event.preventDefault();
                        this.handleCursorKey(event, data);
                        break;
                    case keycodes.SPACE:
                        event.preventDefault();
                        this.selectionService.strategy.toggle(data);
                        break;
                }
            };
        /**
         * Select the sibling item when arrow keys are pressed
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
        RowAltSelectionStrategy.prototype.handleCursorKey = /**
         * Select the sibling item when arrow keys are pressed
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
            function (event, data) {
                // determine which modifier keys are pressed
                var ctrlKey = event.ctrlKey, shiftKey = event.shiftKey;
                // if no modifier keys are pressed then deselect all and clear the selection
                if (!ctrlKey && !shiftKey) {
                    this.deselectAll();
                    this.clearSelection(false);
                }
                if (ctrlKey) {
                    this.selectionService.activateSibling(event.which === keycodes.UP_ARROW);
                }
                else {
                    var /** @type {?} */ sibling = this.selectionService.getSibling(event.which === keycodes.UP_ARROW);
                    this.multipleSelect(sibling ? sibling : data);
                }
            };
        return RowAltSelectionStrategy;
    }(RowSelectionStrategy));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SimpleSelectionStrategy = (function (_super) {
        __extends(SimpleSelectionStrategy, _super);
        function SimpleSelectionStrategy() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * When the item is clicked simply toggle the current selected state
         */
        /**
         * When the item is clicked simply toggle the current selected state
         * @param {?} _event
         * @param {?} data
         * @return {?}
         */
        SimpleSelectionStrategy.prototype.click = /**
         * When the item is clicked simply toggle the current selected state
         * @param {?} _event
         * @param {?} data
         * @return {?}
         */
            function (_event, data) {
                this.toggle(data);
            };
        /**
         * Add basic keyboard support for navigating
         * and selecting/deselecting items
         */
        /**
         * Add basic keyboard support for navigating
         * and selecting/deselecting items
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
        SimpleSelectionStrategy.prototype.keydown = /**
         * Add basic keyboard support for navigating
         * and selecting/deselecting items
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
            function (event, data) {
                switch (event.which) {
                    case keycodes.UP_ARROW:
                        event.preventDefault();
                        return this.selectionService.activateSibling(true);
                    case keycodes.DOWN_ARROW:
                        event.preventDefault();
                        return this.selectionService.activateSibling(false);
                    case keycodes.SPACE:
                        event.preventDefault();
                        return this.toggle(data);
                }
            };
        /**
         * Override the standard toggle function to always activate the item
         */
        /**
         * Override the standard toggle function to always activate the item
         * @param {?} data
         * @return {?}
         */
        SimpleSelectionStrategy.prototype.toggle = /**
         * Override the standard toggle function to always activate the item
         * @param {?} data
         * @return {?}
         */
            function (data) {
                _super.prototype.toggle.call(this, data);
                this.selectionService.activate(data);
            };
        return SimpleSelectionStrategy;
    }(SelectionStrategy));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SelectionService = (function () {
        function SelectionService() {
            this.strategy = new SimpleSelectionStrategy(this);
            this.isEnabled = true;
            this.isClickEnabled = true;
            this.isKeyboardEnabled = true;
            this.focus$ = new BehaviorSubject.BehaviorSubject(null);
            this.active$ = new BehaviorSubject.BehaviorSubject(null);
            this.selection$ = new BehaviorSubject.BehaviorSubject([]);
            this._dataset = [];
            this._selection = new Set();
            this._strategyToDestroy = this.strategy;
        }
        Object.defineProperty(SelectionService.prototype, "dataset", {
            get: /**
             * @return {?}
             */ function () {
                return this._dataset;
            },
            set: /**
             * @param {?} dataset
             * @return {?}
             */ function (dataset) {
                this._dataset = dataset;
                if (this._dataset.indexOf(this._active) === -1) {
                    this.setFirstItemFocusable();
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        SelectionService.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                if (this._strategyToDestroy) {
                    this._strategyToDestroy.destroy();
                }
            };
        /**
         * If the item is not currently selected then add it
         * to the list of selected items
         */
        /**
         * If the item is not currently selected then add it
         * to the list of selected items
         * @param {...?} selections
         * @return {?}
         */
        SelectionService.prototype.select = /**
         * If the item is not currently selected then add it
         * to the list of selected items
         * @param {...?} selections
         * @return {?}
         */
            function () {
                var _this = this;
                var selections = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    selections[_i] = arguments[_i];
                }
                // add each selection to the set
                selections.forEach(function (selection) { return _this._selection.add(selection); });
                // propagate the changes
                this.selectionHasMutated();
            };
        /**
         * Remove an item from the list of selected items
         */
        /**
         * Remove an item from the list of selected items
         * @param {...?} selections
         * @return {?}
         */
        SelectionService.prototype.deselect = /**
         * Remove an item from the list of selected items
         * @param {...?} selections
         * @return {?}
         */
            function () {
                var _this = this;
                var selections = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    selections[_i] = arguments[_i];
                }
                // remove each item from the set
                selections.forEach(function (selection) { return _this._selection.delete(selection); });
                // propagate the changes
                this.selectionHasMutated();
            };
        /**
         * Remove all items from the list of selected items
         */
        /**
         * Remove all items from the list of selected items
         * @return {?}
         */
        SelectionService.prototype.deselectAll = /**
         * Remove all items from the list of selected items
         * @return {?}
         */
            function () {
                // remove all items in the array
                this.deselect.apply(this, __spread(this._dataset));
                // clear the set in case any items have been removed from the DOM but are still selected
                this._selection.clear();
            };
        /**
         * Toggle the selected state of any specified items
         */
        /**
         * Toggle the selected state of any specified items
         * @param {...?} selections
         * @return {?}
         */
        SelectionService.prototype.toggle = /**
         * Toggle the selected state of any specified items
         * @param {...?} selections
         * @return {?}
         */
            function () {
                var _this = this;
                var selections = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    selections[_i] = arguments[_i];
                }
                selections.forEach(function (selection) { return _this.isSelected(selection) ? _this.deselect(selection) : _this.select(selection); });
            };
        /**
         * Determine whether or not a specific item is currently selected
         */
        /**
         * Determine whether or not a specific item is currently selected
         * @param {?} data
         * @return {?}
         */
        SelectionService.prototype.isSelected = /**
         * Determine whether or not a specific item is currently selected
         * @param {?} data
         * @return {?}
         */
            function (data) {
                return this._selection.has(data);
            };
        /**
         * Return an observable specifically for notifying the subscriber
         * only when the selection state of a specific object has changed
         */
        /**
         * Return an observable specifically for notifying the subscriber
         * only when the selection state of a specific object has changed
         * @param {?} data
         * @return {?}
         */
        SelectionService.prototype.getSelectionState = /**
         * Return an observable specifically for notifying the subscriber
         * only when the selection state of a specific object has changed
         * @param {?} data
         * @return {?}
         */
            function (data) {
                var _this = this;
                return this.selection$.pipe(operators.map(function () { return _this.isSelected(data); }), operators.distinctUntilChanged());
            };
        /**
         * Define how selections should be performed.
         * This allows us to use an strategy pattern to handle the various keyboard
         * and mouse interactions while keeping each mode separated and
         * easily extensible if we want to add more modes in future!
         */
        /**
         * Define how selections should be performed.
         * This allows us to use an strategy pattern to handle the various keyboard
         * and mouse interactions while keeping each mode separated and
         * easily extensible if we want to add more modes in future!
         * @param {?} mode
         * @return {?}
         */
        SelectionService.prototype.setStrategy = /**
         * Define how selections should be performed.
         * This allows us to use an strategy pattern to handle the various keyboard
         * and mouse interactions while keeping each mode separated and
         * easily extensible if we want to add more modes in future!
         * @param {?} mode
         * @return {?}
         */
            function (mode) {
                if (this._strategyToDestroy) {
                    // Destroy previous strategy if it was created internally
                    this._strategyToDestroy.destroy();
                    this._strategyToDestroy = null;
                }
                if (mode instanceof SelectionStrategy) {
                    // Custom strategy - pass in the service instance
                    this.strategy = mode;
                    this.strategy.setSelectionService(this);
                }
                else {
                    switch (mode.toLowerCase().trim()) {
                        case 'simple':
                            this.strategy = this._strategyToDestroy = new SimpleSelectionStrategy(this);
                            break;
                        case 'row':
                            this.strategy = this._strategyToDestroy = new RowSelectionStrategy(this);
                            break;
                        case 'row-alt':
                            this.strategy = this._strategyToDestroy = new RowAltSelectionStrategy(this);
                            break;
                        default:
                            throw new Error("The selection mode '" + mode + "' does not exist. Valid modes are 'simple', 'row', or 'row-alt'.");
                    }
                }
            };
        /**
         * Set the current active item
         */
        /**
         * Set the current active item
         * @param {?} data
         * @return {?}
         */
        SelectionService.prototype.activate = /**
         * Set the current active item
         * @param {?} data
         * @return {?}
         */
            function (data) {
                this._active = data;
                this.active$.next(this._active);
            };
        /**
         * Deactive all items
         */
        /**
         * Deactive all items
         * @return {?}
         */
        SelectionService.prototype.deactivate = /**
         * Deactive all items
         * @return {?}
         */
            function () {
                this._active = null;
                this.active$.next(this._active);
            };
        /**
         * Return the next or previous sibling of the current active item.
         * @param previous If true, the previous sibling will be returned.
         */
        /**
         * Return the next or previous sibling of the current active item.
         * @param {?=} previous If true, the previous sibling will be returned.
         * @return {?}
         */
        SelectionService.prototype.getSibling = /**
         * Return the next or previous sibling of the current active item.
         * @param {?=} previous If true, the previous sibling will be returned.
         * @return {?}
         */
            function (previous) {
                if (previous === void 0) {
                    previous = false;
                }
                // check if there is a current active item
                if (!this._active) {
                    return;
                }
                // get the index of the current item
                var /** @type {?} */ idx = this.dataset.indexOf(this._active);
                var /** @type {?} */ target = this.dataset[previous ? idx - 1 : idx + 1];
                return target;
            };
        /**
         * Activate the sibling of the current active item.
         * If previous is set to true the previous sibling will be activated
         * rather than the next sibling. This function will also return the
         * data of the newly activated sibling
         */
        /**
         * Activate the sibling of the current active item.
         * If previous is set to true the previous sibling will be activated
         * rather than the next sibling. This function will also return the
         * data of the newly activated sibling
         * @param {?=} previous
         * @return {?}
         */
        SelectionService.prototype.activateSibling = /**
         * Activate the sibling of the current active item.
         * If previous is set to true the previous sibling will be activated
         * rather than the next sibling. This function will also return the
         * data of the newly activated sibling
         * @param {?=} previous
         * @return {?}
         */
            function (previous) {
                if (previous === void 0) {
                    previous = false;
                }
                var /** @type {?} */ target = this.getSibling(previous);
                // check if the target exists
                if (target) {
                    this.activate(target);
                }
                return target;
            };
        /**
         * @param {?} disabled
         * @return {?}
         */
        SelectionService.prototype.setDisabled = /**
         * @param {?} disabled
         * @return {?}
         */
            function (disabled) {
                // store the current disabled state
                this.isEnabled = !disabled;
                // clear any stateful data
                this._active = null;
                this.active$.next(this._active);
                this._selection.clear();
                // emit the selection change information
                this.selectionHasMutated();
            };
        /**
         * @return {?}
         */
        SelectionService.prototype.selectionHasMutated = /**
         * @return {?}
         */
            function () {
                this.selection$.next(Array.from(this._selection));
            };
        /**
         * @return {?}
         */
        SelectionService.prototype.setFirstItemFocusable = /**
         * @return {?}
         */
            function () {
                if (this._dataset.length > 0) {
                    this.focus$.next(this._dataset[0]);
                    this._active = this._dataset[0];
                }
                else {
                    this._active = null;
                }
            };
        SelectionService.decorators = [
            { type: core.Injectable }
        ];
        return SelectionService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SelectListItemComponent = (function () {
        function SelectListItemComponent(_selection, elementRef) {
            var _this = this;
            this._selection = _selection;
            this.tabindex = -1;
            this._onDestroy = new Subject.Subject();
            _selection.active$.pipe(operators.takeUntil(this._onDestroy), operators.filter(function (data) { return data === _this.data; })).subscribe(function (active) {
                _selection.focus$.next(active);
                elementRef.nativeElement.focus();
            });
            // make this item tabbable or not based on the focused element
            _selection.focus$.pipe(operators.takeUntil(this._onDestroy))
                .subscribe(function (focused) { return _this.tabindex = focused === _this.data ? 0 : -1; });
        }
        Object.defineProperty(SelectListItemComponent.prototype, "selected", {
            get: /**
             * @return {?}
             */ function () {
                return this._selection.isSelected(this.data);
            },
            set: /**
             * @param {?} isSelected
             * @return {?}
             */ function (isSelected) {
                isSelected ? this._selection.select(this.data) : this._selection.deselect(this.data);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        SelectListItemComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SelectListItemComponent.prototype.onMouseDown = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this._selection.strategy.mousedown(event, this.data);
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SelectListItemComponent.prototype.onClick = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this._selection.strategy.click(event, this.data);
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SelectListItemComponent.prototype.onKeydown = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                this._selection.strategy.keydown(event, this.data);
            };
        SelectListItemComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-select-list-item',
                        template: "<ng-content></ng-content>",
                        host: {
                            role: 'listitem'
                        }
                    }] }
        ];
        /** @nocollapse */
        SelectListItemComponent.ctorParameters = function () {
            return [
                { type: SelectionService },
                { type: core.ElementRef }
            ];
        };
        SelectListItemComponent.propDecorators = {
            data: [{ type: core.Input }],
            tabindex: [{ type: core.HostBinding, args: ['tabindex',] }],
            selected: [{ type: core.HostBinding, args: ['class.selected',] }, { type: core.HostBinding, args: ['attr.aria-selected',] }],
            onMouseDown: [{ type: core.HostListener, args: ['mousedown', ['$event'],] }],
            onClick: [{ type: core.HostListener, args: ['click', ['$event'],] }],
            onKeydown: [{ type: core.HostListener, args: ['keydown', ['$event'],] }]
        };
        return SelectListItemComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MultipleSelectListStrategy = (function (_super) {
        __extends(MultipleSelectListStrategy, _super);
        function MultipleSelectListStrategy() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /** Prevent the browser from highlighting text on shift click */
        /**
         * Prevent the browser from highlighting text on shift click
         * @param {?} event
         * @return {?}
         */
        MultipleSelectListStrategy.prototype.mousedown = /**
         * Prevent the browser from highlighting text on shift click
         * @param {?} event
         * @return {?}
         */
            function (event) {
                event.preventDefault();
            };
        /**
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
        MultipleSelectListStrategy.prototype.click = /**
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
            function (event, data) {
                // activate the clicked item
                this.selectionService.activate(data);
                // if the shift key is pressed we want to perform a multiple selection
                if (event.shiftKey) {
                    return this.multipleSelect(data);
                }
                // otherwise perform a single toggle selection
                if (this.selectionService.isSelected(data)) {
                    this.deselect(data);
                    this._lastSelection = null;
                }
                else {
                    this.select(data);
                    this._lastSelection = data;
                }
            };
        /**
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
        MultipleSelectListStrategy.prototype.keydown = /**
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
            function (event, data) {
                switch (event.which) {
                    case keycodes.UP_ARROW: {
                        event.preventDefault();
                        var /** @type {?} */ sibling = this.selectionService.activateSibling(true);
                        if (event.shiftKey) {
                            this.select(data, sibling);
                            this._lastSelection = sibling;
                        }
                        break;
                    }
                    case keycodes.DOWN_ARROW: {
                        event.preventDefault();
                        var /** @type {?} */ sibling = this.selectionService.activateSibling(false);
                        if (event.shiftKey) {
                            this.select(data, sibling);
                            this._lastSelection = sibling;
                        }
                        break;
                    }
                    case keycodes.SPACE:
                    case keycodes.ENTER:
                        event.preventDefault();
                        this.toggle(data);
                        this._lastSelection = this.selectionService.isSelected(data) ? data : null;
                        break;
                }
            };
        /**
         * @param {?} data
         * @return {?}
         */
        MultipleSelectListStrategy.prototype.multipleSelect = /**
         * @param {?} data
         * @return {?}
         */
            function (data) {
                // if there is no start item selected
                if (!this._lastSelection) {
                    this.select(data);
                    return this._lastSelection = data;
                }
                // if there already is a start item then find the items in the range
                this.select.apply(this, __spread(this.getSelectedItems(this._lastSelection, data)));
                // store the selection end point
                this._lastSelection = data;
            };
        /**
         * @param {?} start
         * @param {?} end
         * @return {?}
         */
        MultipleSelectListStrategy.prototype.getSelectedItems = /**
         * @param {?} start
         * @param {?} end
         * @return {?}
         */
            function (start, end) {
                // get the latest dataset
                var dataset = this.selectionService.dataset;
                // get the indexes of the start and end point
                var /** @type {?} */ startIdx = dataset.indexOf(start);
                var /** @type {?} */ endIdx = dataset.indexOf(end);
                // get the region of the array that is selected - note the endIdx may be before the startIdx so account for this
                return dataset.slice(Math.min(startIdx, endIdx), Math.max(startIdx, endIdx) + 1);
            };
        return MultipleSelectListStrategy;
    }(SelectionStrategy));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SingleSelectListStrategy = (function (_super) {
        __extends(SingleSelectListStrategy, _super);
        function SingleSelectListStrategy() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @param {?} _event
         * @param {?} data
         * @return {?}
         */
        SingleSelectListStrategy.prototype.click = /**
         * @param {?} _event
         * @param {?} data
         * @return {?}
         */
            function (_event, data) {
                if (!this.selectionService.isSelected(data)) {
                    // deselect all other items
                    this.deselectAll();
                }
                // activate the clicked item
                this.selectionService.activate(data);
                // toggle the selected state of the item
                this.toggle(data);
            };
        /**
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
        SingleSelectListStrategy.prototype.keydown = /**
         * @param {?} event
         * @param {?} data
         * @return {?}
         */
            function (event, data) {
                switch (event.which) {
                    case keycodes.UP_ARROW: {
                        event.preventDefault();
                        this.selectionService.activateSibling(true);
                        break;
                    }
                    case keycodes.DOWN_ARROW: {
                        event.preventDefault();
                        this.selectionService.activateSibling(false);
                        break;
                    }
                    case keycodes.SPACE:
                    case keycodes.ENTER:
                        event.preventDefault();
                        this.click(null, data);
                        break;
                }
            };
        return SingleSelectListStrategy;
    }(SelectionStrategy));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SelectListComponent = (function () {
        function SelectListComponent(_selection) {
            var _this = this;
            this._selection = _selection;
            this.selected = [];
            this.selectedChange = new core.EventEmitter();
            // set the selection strategy to single by default
            this._selection.setStrategy(new SingleSelectListStrategy());
            // emit the selection changes when they occur
            this._subscription = this._selection.selection$.subscribe(function (selection) { return _this.selectedChange.emit(selection); });
        }
        Object.defineProperty(SelectListComponent.prototype, "multiple", {
            set: /**
             * @param {?} multiple
             * @return {?}
             */ function (multiple) {
                this._selection.strategy.deselectAll();
                this._selection.setStrategy(multiple ? new MultipleSelectListStrategy() : new SingleSelectListStrategy());
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        SelectListComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // supply the initial item set
                this._selection.dataset = this.items.map(function (item) { return item.data; });
                // if the item set changes update the list
                this.items.changes.subscribe(function () { return _this._selection.dataset = _this.items.map(function (item) { return item.data; }); });
            };
        /**
         * @return {?}
         */
        SelectListComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._subscription.unsubscribe();
            };
        SelectListComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-select-list',
                        template: "<ng-content></ng-content>",
                        providers: [SelectionService],
                        host: {
                            role: 'list'
                        }
                    }] }
        ];
        /** @nocollapse */
        SelectListComponent.ctorParameters = function () {
            return [
                { type: SelectionService }
            ];
        };
        SelectListComponent.propDecorators = {
            multiple: [{ type: core.Input }],
            selected: [{ type: core.Input }],
            selectedChange: [{ type: core.Output }],
            items: [{ type: core.ContentChildren, args: [SelectListItemComponent,] }]
        };
        return SelectListComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SelectListModule = (function () {
        function SelectListModule() {
        }
        SelectListModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            SelectListComponent,
                            SelectListItemComponent
                        ],
                        exports: [
                            SelectListComponent,
                            SelectListItemComponent
                        ],
                    },] }
        ];
        return SelectListModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SidePanelCloseDirective = (function () {
        function SidePanelCloseDirective(_service) {
            this._service = _service;
        }
        /**
         * @return {?}
         */
        SidePanelCloseDirective.prototype.clickHandler = /**
         * @return {?}
         */
            function () {
                this._service.close();
            };
        SidePanelCloseDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxSidePanelClose]'
                    },] }
        ];
        /** @nocollapse */
        SidePanelCloseDirective.ctorParameters = function () {
            return [
                { type: SidePanelService }
            ];
        };
        SidePanelCloseDirective.propDecorators = {
            clickHandler: [{ type: core.HostListener, args: ['click',] }]
        };
        return SidePanelCloseDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ EXPORTS$1 = [
        SidePanelComponent,
        SidePanelCloseDirective
    ];
    var SidePanelModule = (function () {
        function SidePanelModule() {
        }
        SidePanelModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            a11y.A11yModule,
                            FocusIfModule
                        ],
                        exports: EXPORTS$1,
                        declarations: EXPORTS$1
                    },] }
        ];
        return SidePanelModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SparkComponent = (function () {
        function SparkComponent(_colorService) {
            this._colorService = _colorService;
            this.values = [];
            this.barHeight = 10;
            this._theme = 'primary';
            this._barColor = [];
        }
        Object.defineProperty(SparkComponent.prototype, "theme", {
            get: /**
             * @return {?}
             */ function () {
                return this._theme;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._theme = this._colorService.resolveColorName(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SparkComponent.prototype, "trackColor", {
            get: /**
             * @return {?}
             */ function () {
                return this._trackColor;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._trackColor = this._colorService.resolve(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SparkComponent.prototype, "barColor", {
            get: /**
             * @return {?}
             */ function () {
                return this._barColor;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                var _this = this;
                if (Array.isArray(value)) {
                    this._barColor = value.map(function (color) { return _this._colorService.resolve(color); });
                }
                else {
                    this._barColor = [this._colorService.resolve(value)];
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SparkComponent.prototype, "value", {
            get: /**
             * @return {?}
             */ function () {
                return this.values;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                // ensure 'value' is an array at this point
                var /** @type {?} */ values = Array.isArray(value) ? value : [value];
                // get the total value of all lines
                var /** @type {?} */ total = Math.max(values.reduce(function (previous, current) { return previous + current; }, 0), 100);
                // figure out the percentages for each spark line
                this.values = values.map(function (val) { return (val / total) * 100; });
            },
            enumerable: true,
            configurable: true
        });
        SparkComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-spark',
                        template: "<!-- Inline Spark Chart -->\n<div *ngIf=\"inlineLabel\" class=\"ux-spark-inline-label-container\">\n\n    <div class=\"ux-spark-inline-label-left\" [innerHtml]=\"inlineLabel\"></div>\n\n    <div class=\"ux-spark-line\">\n\n        <div class=\"ux-spark-top-container\" *ngIf=\"topLeftLabel || topRightLabel\">\n            <div class=\"ux-spark-label-top-left\" *ngIf=\"topLeftLabel\" [innerHtml]=\"topLeftLabel\"></div>\n            <div class=\"ux-spark-label-top-right\" *ngIf=\"topRightLabel\" [innerHtml]=\"topRightLabel\"></div>\n        </div>\n\n        <div class=\"ux-spark ux-inline ux-spark-theme-{{theme}}\" [style.height.px]=\"barHeight\" [style.backgroundColor]=\"trackColor\" [uxTooltip]=\"tooltip\">\n            <div class=\"ux-spark-bar\" *ngFor=\"let line of values; let idx = index;\" [style.width.%]=\"line\" [style.backgroundColor]=\"barColor[idx]\"></div>\n        </div>\n\n        <div class=\"ux-spark-bottom-container\" *ngIf=\"bottomLeftLabel || bottomRightLabel\">\n            <div class=\"ux-spark-label-bottom-left\" *ngIf=\"bottomLeftLabel\" [innerHtml]=\"bottomLeftLabel\"></div>\n            <div class=\"ux-spark-label-bottom-right\" *ngIf=\"bottomRightLabel\" [innerHtml]=\"bottomRightLabel\"></div>\n        </div>\n\n    </div>\n</div>\n\n<!-- End Inline Spark Chart -->\n\n\n<!-- Non Inline Spark Chart -->\n<div *ngIf=\"!inlineLabel\">\n\n    <div class=\"ux-spark-top-container\" *ngIf=\"topLeftLabel || topRightLabel\">\n        <div class=\"ux-spark-label-top-left\" *ngIf=\"topLeftLabel\" [innerHtml]=\"topLeftLabel\"></div>\n        <div class=\"ux-spark-label-top-right\" *ngIf=\"topRightLabel\" [innerHtml]=\"topRightLabel\"></div>\n    </div>\n\n    <div class=\"ux-spark ux-spark-theme-{{theme}}\" [class.ux-spark-multi-value]=\"values.length > 1\" [style.height.px]=\"barHeight\" [style.backgroundColor]=\"trackColor\"\n        [uxTooltip]=\"tooltip\">\n        <div class=\"ux-spark-bar\" *ngFor=\"let line of value; let idx = index;\" [style.width.%]=\"line\" [style.backgroundColor]=\"barColor[idx]\"></div>\n    </div>\n\n    <div class=\"ux-spark-bottom-container\" *ngIf=\"bottomLeftLabel || bottomRightLabel\">\n        <div class=\"ux-spark-label-bottom-left\" *ngIf=\"bottomLeftLabel\" [innerHtml]=\"bottomLeftLabel\"></div>\n        <div class=\"ux-spark-label-bottom-right\" *ngIf=\"bottomRightLabel\" [innerHtml]=\"bottomRightLabel\"></div>\n    </div>\n</div>\n\n<!-- End Non Inline Spark Chart -->",
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        SparkComponent.ctorParameters = function () {
            return [
                { type: ColorService }
            ];
        };
        SparkComponent.propDecorators = {
            barHeight: [{ type: core.Input }],
            inlineLabel: [{ type: core.Input }],
            topLeftLabel: [{ type: core.Input }],
            topRightLabel: [{ type: core.Input }],
            bottomLeftLabel: [{ type: core.Input }],
            bottomRightLabel: [{ type: core.Input }],
            tooltip: [{ type: core.Input }],
            theme: [{ type: core.Input }],
            trackColor: [{ type: core.Input }],
            barColor: [{ type: core.Input }],
            value: [{ type: core.Input }]
        };
        return SparkComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SparkModule = (function () {
        function SparkModule() {
        }
        SparkModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            ColorServiceModule,
                            TooltipModule
                        ],
                        exports: [SparkComponent],
                        declarations: [SparkComponent]
                    },] }
        ];
        return SparkModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ResizableTableService = (function () {
        function ResizableTableService() {
            /**
             * determine whether or not we are currently sizing
             */
            this.resizing = false;
            /**
             * store the percentage widths of all the columns
             */
            this.sizes = new ReplaySubject.ReplaySubject();
            /**
             * store the column sizes as an accessible object
             */
            this._sizes = new Map();
            /**
             * An observable to unsubscribe others automatically
             */
            this._onDestroy = new Subject.Subject();
        }
        /**
         * @return {?}
         */
        ResizableTableService.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /** a setter to define the table element */
        /**
         * a setter to define the table element
         * @param {?} table
         * @return {?}
         */
        ResizableTableService.prototype.setTable = /**
         * a setter to define the table element
         * @param {?} table
         * @return {?}
         */
            function (table) {
                this._table = table;
            };
        /** a setter to define the query list of columns */
        /**
         * a setter to define the query list of columns
         * @param {?} columns
         * @return {?}
         */
        ResizableTableService.prototype.setColumns = /**
         * a setter to define the query list of columns
         * @param {?} columns
         * @return {?}
         */
            function (columns) {
                var _this = this;
                // store a reference to the columns
                this._columns = columns;
                // set up the initial colums sizes
                this.setInitialWidths();
                // subscribe to future column changes
                this._columns.changes.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.setInitialWidths(); });
            };
        /** We want to convert all units sizes to pixels to prevent browser jitter */
        /**
         * We want to convert all units sizes to pixels to prevent browser jitter
         * @return {?}
         */
        ResizableTableService.prototype.startResizing = /**
         * We want to convert all units sizes to pixels to prevent browser jitter
         * @return {?}
         */
            function () {
                var _this = this;
                this.resizing = true;
                // convert all current percentages into pixel values
                this._sizes.forEach(function (value, key) { return _this._sizes.set(key, (_this._table.offsetWidth / 100) * value); });
                // emit the latest values
                this.sizes.next(this._sizes);
            };
        /** Restore values back to percentage values */
        /**
         * Restore values back to percentage values
         * @return {?}
         */
        ResizableTableService.prototype.endResizing = /**
         * Restore values back to percentage values
         * @return {?}
         */
            function () {
                var _this = this;
                this.resizing = false;
                // convert all values back to percentages
                this._sizes.forEach(function (value, key) { return _this._sizes.set(key, (value / _this._table.offsetWidth) * 100); });
                // emit the latest values
                this.sizes.next(this._sizes);
            };
        /** apply a resize event to a column */
        /**
         * apply a resize event to a column
         * @param {?} column
         * @param {?} value
         * @return {?}
         */
        ResizableTableService.prototype.resizeColumn = /**
         * apply a resize event to a column
         * @param {?} column
         * @param {?} value
         * @return {?}
         */
            function (column, value) {
                // get the sibling column that will also be resized
                var /** @type {?} */ sibling = this.getSiblingColumn(column);
                // if there is no sibling that can be resized then stop here
                if (!sibling) {
                    return;
                }
                // create a new object for the sizes
                var /** @type {?} */ sizes = new Map(this._sizes);
                // resize the column to the desired size
                this.setColumnWidth(column, this.getColumnWidth(column) + Math.round(value), sizes);
                this.setColumnWidth(sibling, this.getColumnWidth(sibling) - Math.round(value), sizes);
                // if the move is not possible then stop here
                if (!this.isWidthValid(column, this.getColumnWidth(column, sizes)) || !this.isWidthValid(sibling, this.getColumnWidth(sibling, sizes))) {
                    return;
                }
                // ensure that the column widths total exactly 100%
                this.verifyColumnWidths(sibling, sizes);
                // store the new sizes
                this._sizes = sizes;
                // emit the latest size values
                this.sizes.next(this._sizes);
            };
        /**
         * initially convert the default pixel widths of each column to percentages
         * @return {?}
         */
        ResizableTableService.prototype.setInitialWidths = /**
         * initially convert the default pixel widths of each column to percentages
         * @return {?}
         */
            function () {
                var _this = this;
                // get the table width so we don't have to keep accessing the dom
                var /** @type {?} */ width = this._table.offsetWidth;
                // create a new object containing all column widths
                this._sizes = new Map();
                // calculate the percentage size of each column
                this._columns.forEach(function (column) {
                    return _this.setColumnWidth(column, ((column.getColumnWidth() / width) * 100));
                });
                // emit the latest column sizes
                this.sizes.next(this._sizes);
            };
        /**
         * Get the percentage width of a specific column
         * @param {?} column
         * @param {?=} sizes
         * @return {?}
         */
        ResizableTableService.prototype.getColumnWidth = /**
         * Get the percentage width of a specific column
         * @param {?} column
         * @param {?=} sizes
         * @return {?}
         */
            function (column, sizes) {
                if (sizes === void 0) {
                    sizes = this._sizes;
                }
                return sizes.get(column);
            };
        /**
         * Set the percentage width for a specific column
         * @param {?} column
         * @param {?} width
         * @param {?=} sizes
         * @return {?}
         */
        ResizableTableService.prototype.setColumnWidth = /**
         * Set the percentage width for a specific column
         * @param {?} column
         * @param {?} width
         * @param {?=} sizes
         * @return {?}
         */
            function (column, width, sizes) {
                if (sizes === void 0) {
                    sizes = this._sizes;
                }
                sizes.set(column, width);
            };
        /**
         * Determine whether a column is above or below its minimum width
         * @param {?} column
         * @param {?} width
         * @return {?}
         */
        ResizableTableService.prototype.isWidthValid = /**
         * Determine whether a column is above or below its minimum width
         * @param {?} column
         * @param {?} width
         * @return {?}
         */
            function (column, width) {
                return width >= column.minWidth;
            };
        /**
         * Ensure that the total column widths is exactly 100%
         * @param {?} adjustableColumn
         * @param {?=} sizes
         * @return {?}
         */
        ResizableTableService.prototype.verifyColumnWidths = /**
         * Ensure that the total column widths is exactly 100%
         * @param {?} adjustableColumn
         * @param {?=} sizes
         * @return {?}
         */
            function (adjustableColumn, sizes) {
                if (sizes === void 0) {
                    sizes = this._sizes;
                }
                // get the total widths of all columns combined
                var /** @type {?} */ width = Array.from(sizes.values()).reduce(function (total, column) { return column + total; }, 0);
                // if the width does not total 100% exactly then adjust the column width
                if (width !== this._table.offsetWidth) {
                    this.setColumnWidth(adjustableColumn, this.getColumnWidth(adjustableColumn, sizes) + (this._table.offsetWidth - width), sizes);
                }
            };
        /**
         * Get a column at a given index
         * @param {?} index
         * @return {?}
         */
        ResizableTableService.prototype.getColumnAtIndex = /**
         * Get a column at a given index
         * @param {?} index
         * @return {?}
         */
            function (index) {
                return this._columns.toArray()[index];
            };
        /**
         * Get the next column in the sequence of columns
         * @param {?} column
         * @return {?}
         */
        ResizableTableService.prototype.getSiblingColumn = /**
         * Get the next column in the sequence of columns
         * @param {?} column
         * @return {?}
         */
            function (column) {
                // get the index of this column
                var /** @type {?} */ index = this._columns.toArray().indexOf(column);
                // find the first sibling that is not disabled
                for (var /** @type {?} */ idx = index + 1; idx < this._columns.length; idx++) {
                    var /** @type {?} */ sibling = this.getColumnAtIndex(idx);
                    if (!sibling.disabled) {
                        return sibling;
                    }
                }
                return null;
            };
        ResizableTableService.decorators = [
            { type: core.Injectable }
        ];
        return ResizableTableService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ResizableTableColumnComponent = (function () {
        function ResizableTableColumnComponent(table, _elementRef) {
            this.table = table;
            this._elementRef = _elementRef;
            this.disabled = false;
            /**
             * Ensure observables get destroyed correctly
             */
            this._onDestroy = new Subject.Subject();
        }
        Object.defineProperty(ResizableTableColumnComponent.prototype, "width", {
            /** The percentage width of the column */
            get: /**
             * The percentage width of the column
             * @return {?}
             */ function () {
                return this.table.resizing ? this._width + "px" : this._width + "%";
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ResizableTableColumnComponent.prototype, "minWidth", {
            get: /**
             * @return {?}
             */ function () {
                return this.disabled ? this._elementRef.nativeElement.offsetWidth : parseFloat(getComputedStyle(this._elementRef.nativeElement).minWidth);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ResizableTableColumnComponent.prototype.getColumnWidth = /**
         * @return {?}
         */
            function () {
                return this._elementRef.nativeElement.offsetWidth;
            };
        /**
         * @return {?}
         */
        ResizableTableColumnComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this.table.sizes.pipe(operators.map(function (sizes) { return sizes.get(_this); }), operators.distinctUntilChanged(), operators.takeUntil(this._onDestroy), tick() // prevents expression has changed error
                ).subscribe(function (width) { return _this._width = width; });
            };
        /**
         * @return {?}
         */
        ResizableTableColumnComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @return {?}
         */
        ResizableTableColumnComponent.prototype.dragstart = /**
         * @return {?}
         */
            function () {
                this.table.startResizing();
            };
        /**
         * @param {?} event
         * @param {?} handle
         * @return {?}
         */
        ResizableTableColumnComponent.prototype.drag = /**
         * @param {?} event
         * @param {?} handle
         * @return {?}
         */
            function (event, handle) {
                // get the current mouse position
                var /** @type {?} */ mouseX = event.pageX - pageXOffset;
                // position of the drag handle
                var _a = handle.getBoundingClientRect(), left = _a.left, width = _a.width;
                // determine how much the mouse has moved since the last update
                var /** @type {?} */ movement = mouseX - (left + (width / 2));
                // perform resizing
                this.table.resizeColumn(this, movement);
            };
        /**
         * @return {?}
         */
        ResizableTableColumnComponent.prototype.dragend = /**
         * @return {?}
         */
            function () {
                this.table.endResizing();
            };
        ResizableTableColumnComponent.decorators = [
            { type: core.Component, args: [{
                        selector: '[uxResizableTableColumn]',
                        template: "<ng-content></ng-content>\n\n<div #handle\n     uxDrag\n     class=\"ux-resizable-table-column-handle\"\n     *ngIf=\"!disabled\"\n     (onDragStart)=\"dragstart()\"\n     (onDrag)=\"drag($event, handle)\"\n     (onDragEnd)=\"dragend()\">\n</div>",
                        host: {
                            class: 'ux-resizable-table-column'
                        }
                    }] }
        ];
        /** @nocollapse */
        ResizableTableColumnComponent.ctorParameters = function () {
            return [
                { type: ResizableTableService },
                { type: core.ElementRef }
            ];
        };
        ResizableTableColumnComponent.propDecorators = {
            disabled: [{ type: core.Input }],
            width: [{ type: core.HostBinding, args: ['style.width',] }]
        };
        return ResizableTableColumnComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ResizableTableDirective = (function () {
        function ResizableTableDirective(_elementRef, _table) {
            this._elementRef = _elementRef;
            this._table = _table;
        }
        /**
         * @return {?}
         */
        ResizableTableDirective.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                this._table.setTable(this._elementRef.nativeElement);
                this._table.setColumns(this.columns);
            };
        ResizableTableDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxResizableTable]',
                        providers: [ResizableTableService],
                        host: {
                            class: 'ux-resizable-table'
                        }
                    },] }
        ];
        /** @nocollapse */
        ResizableTableDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: ResizableTableService }
            ];
        };
        ResizableTableDirective.propDecorators = {
            columns: [{ type: core.ContentChildren, args: [ResizableTableColumnComponent,] }]
        };
        return ResizableTableDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TableModule = (function () {
        function TableModule() {
        }
        TableModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            DragModule
                        ],
                        declarations: [
                            ResizableTableDirective,
                            ResizableTableColumnComponent
                        ],
                        exports: [
                            ResizableTableDirective,
                            ResizableTableColumnComponent
                        ]
                    },] }
        ];
        return TableModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TabsetService = (function () {
        function TabsetService() {
            this.tabs$ = new BehaviorSubject.BehaviorSubject([]);
            this.active$ = new BehaviorSubject.BehaviorSubject(null);
            this.focused$ = new BehaviorSubject.BehaviorSubject(false);
            this.highlighted$ = new BehaviorSubject.BehaviorSubject(null);
        }
        /**
         * @param {?} tab
         * @return {?}
         */
        TabsetService.prototype.add = /**
         * @param {?} tab
         * @return {?}
         */
            function (tab) {
                this.tabs$.next(__spread(this.tabs$.value, [tab]));
                // check if this is the only tab. If so select this by default
                if (!this.active$.value) {
                    this.select(tab);
                }
            };
        /**
         * @param {?} tab
         * @return {?}
         */
        TabsetService.prototype.remove = /**
         * @param {?} tab
         * @return {?}
         */
            function (tab) {
                // remove the tab
                this.tabs$.next(this.tabs$.value.filter(function (_tab) { return _tab !== tab; }));
            };
        /**
         * @param {?} tab
         * @return {?}
         */
        TabsetService.prototype.select = /**
         * @param {?} tab
         * @return {?}
         */
            function (tab) {
                if (!tab.disabled) {
                    this.active$.next(tab);
                    this.highlighted$.next(tab);
                }
            };
        /**
         * @param {?} index
         * @return {?}
         */
        TabsetService.prototype.selectAtIndex = /**
         * @param {?} index
         * @return {?}
         */
            function (index) {
                // if there are no tabs then do nothing
                if (this.tabs$.value.length === 0) {
                    return;
                }
                // check if the index is within the bounds
                if (index < 0) {
                    return this.selectAtIndex(this.tabs$.value.length - 1);
                }
                else if (index >= this.tabs$.value.length) {
                    return this.selectAtIndex(0);
                }
                var /** @type {?} */ target = this.tabs$.value[index];
                if (target) {
                    this.select(target);
                }
            };
        /**
         * @return {?}
         */
        TabsetService.prototype.selectNextTab = /**
         * @return {?}
         */
            function () {
                // find the currently selected index
                var /** @type {?} */ index = this.tabs$.value.indexOf(this.active$.value);
                // check the tabs after the active one to see if there are any selectable tabs
                var /** @type {?} */ tabs = this.tabs$.value.slice(index + 1);
                try {
                    // check if any of the tabs are not disabled
                    for (var tabs_1 = __values(tabs), tabs_1_1 = tabs_1.next(); !tabs_1_1.done; tabs_1_1 = tabs_1.next()) {
                        var tab = tabs_1_1.value;
                        if (!tab.disabled) {
                            return this.select(tab);
                        }
                    }
                }
                catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                }
                finally {
                    try {
                        if (tabs_1_1 && !tabs_1_1.done && (_a = tabs_1.return))
                            _a.call(tabs_1);
                    }
                    finally {
                        if (e_1)
                            throw e_1.error;
                    }
                }
                // if we reach here then no tab could be selected - select the first tab
                this.selectFirstTab();
                var e_1, _a;
            };
        /**
         * @return {?}
         */
        TabsetService.prototype.selectPreviousTab = /**
         * @return {?}
         */
            function () {
                // find the currently selected index
                var /** @type {?} */ index = this.tabs$.value.indexOf(this.active$.value);
                // check the tabs before the active one to see if there are any selectable tabs
                var /** @type {?} */ tabs = this.tabs$.value.slice(0, index);
                try {
                    // check if any of the tabs are not disabled
                    for (var _a = __values(tabs.reverse()), _b = _a.next(); !_b.done; _b = _a.next()) {
                        var tab = _b.value;
                        if (!tab.disabled) {
                            return this.select(tab);
                        }
                    }
                }
                catch (e_2_1) {
                    e_2 = { error: e_2_1 };
                }
                finally {
                    try {
                        if (_b && !_b.done && (_c = _a.return))
                            _c.call(_a);
                    }
                    finally {
                        if (e_2)
                            throw e_2.error;
                    }
                }
                // if we reach here then no previous tab could be selected - select the last tab
                this.selectLastTab();
                var e_2, _c;
            };
        /**
         * @return {?}
         */
        TabsetService.prototype.selectFirstTab = /**
         * @return {?}
         */
            function () {
                // find the index of the first non-disabled tab
                var /** @type {?} */ tabIndex = this.tabs$.value.findIndex(function (tab) { return !tab.disabled; });
                if (tabIndex !== -1) {
                    this.selectAtIndex(tabIndex);
                }
            };
        /**
         * @return {?}
         */
        TabsetService.prototype.selectLastTab = /**
         * @return {?}
         */
            function () {
                // find the index of the first non-disabled tab
                var /** @type {?} */ tabIndex = this.tabs$.value.slice().reverse().findIndex(function (tab) { return !tab.disabled; });
                if (tabIndex !== -1) {
                    this.selectAtIndex((this.tabs$.value.length - 1) - tabIndex);
                }
            };
        TabsetService.decorators = [
            { type: core.Injectable }
        ];
        return TabsetService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TabFocusDirective = (function () {
        function TabFocusDirective(_tabset, _elementRef) {
            this._tabset = _tabset;
            this._elementRef = _elementRef;
        }
        /**
         * @return {?}
         */
        TabFocusDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this._subscription = this._tabset.highlighted$.pipe(operators.filter(function () { return _this._tabset.focused$.value === true; }), operators.filter(function () { return _this._tabset.highlighted$.value === _this.uxTabFocus; })).subscribe(function () { return _this._elementRef.nativeElement.focus(); });
            };
        /**
         * @return {?}
         */
        TabFocusDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._subscription.unsubscribe();
            };
        TabFocusDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxTabFocus]'
                    },] }
        ];
        /** @nocollapse */
        TabFocusDirective.ctorParameters = function () {
            return [
                { type: TabsetService },
                { type: core.ElementRef }
            ];
        };
        TabFocusDirective.propDecorators = {
            uxTabFocus: [{ type: core.Input }]
        };
        return TabFocusDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ uniqueTabId = 0;
    var TabComponent = (function () {
        function TabComponent(_tabset) {
            var _this = this;
            this._tabset = _tabset;
            this.id = "ux-tab-" + ++uniqueTabId;
            this.disabled = false;
            this.select = new core.EventEmitter();
            this.deselect = new core.EventEmitter();
            this.active$ = this._tabset.active$.pipe(operators.map(function (active) { return active === _this; }));
            _tabset.add(this);
            this._subscription = this.active$.subscribe(function (active) { return active ? _this.select.emit() : _this.deselect.emit(); });
        }
        Object.defineProperty(TabComponent.prototype, "active", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                if (value) {
                    this._tabset.select(this);
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        TabComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._tabset.remove(this);
                this._subscription.unsubscribe();
            };
        TabComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-tab',
                        template: "<div role=\"tabpanel\"\n     class=\"tab-pane\"\n     [class.active]=\"active$ | async\"\n     [id]=\"id + '-panel'\"\n     [attr.aria-labelledby]=\"id\"\n     [attr.aria-hidden]=\"!(active$ | async)\">\n  <ng-content></ng-content>\n</div>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush
                    }] }
        ];
        /** @nocollapse */
        TabComponent.ctorParameters = function () {
            return [
                { type: TabsetService }
            ];
        };
        TabComponent.propDecorators = {
            id: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            heading: [{ type: core.Input }],
            customClass: [{ type: core.Input }],
            select: [{ type: core.Output }],
            deselect: [{ type: core.Output }],
            active: [{ type: core.Input }]
        };
        return TabComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TabHeadingDirective = (function () {
        function TabHeadingDirective(templateRef, tab) {
            tab.headingRef = templateRef;
        }
        TabHeadingDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxTabHeading]'
                    },] }
        ];
        /** @nocollapse */
        TabHeadingDirective.ctorParameters = function () {
            return [
                { type: core.TemplateRef },
                { type: TabComponent }
            ];
        };
        return TabHeadingDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TabsetComponent = (function () {
        function TabsetComponent(tabset) {
            this.tabset = tabset;
            this.minimal = true;
            this.stacked = 'none';
        }
        /**
         * Allow manual tab selected
         */
        /**
         * Allow manual tab selected
         * @param {?} tab
         * @return {?}
         */
        TabsetComponent.prototype.select = /**
         * Allow manual tab selected
         * @param {?} tab
         * @return {?}
         */
            function (tab) {
                this.tabset.select(tab);
            };
        /**
         * @param {?} event
         * @return {?}
         */
        TabsetComponent.prototype.selectPreviousTab = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // determine which arrow key is pressed
                var /** @type {?} */ arrowLeft = event.key === 'ArrowLeft' || event.keyCode === 37;
                var /** @type {?} */ arrowUp = event.key === 'ArrowUp' || event.keyCode === 38;
                // only perform action if the arrow key matches the orientation
                if (arrowLeft && this.stacked !== 'none' || arrowUp && this.stacked === 'none') {
                    return;
                }
                // perform selection
                this.tabset.selectPreviousTab();
                // prevent the browser from scrolling when arrow keys are pressed
                event.preventDefault();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        TabsetComponent.prototype.selectNextTab = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                // determine which arrow key is pressed
                var /** @type {?} */ arrowRight = event.key === 'ArrowRight' || event.keyCode === 39;
                var /** @type {?} */ arrowDown = event.key === 'ArrowDown' || event.keyCode === 40;
                // only perform action if the arrow key matches the orientation
                if (arrowRight && this.stacked !== 'none' || arrowDown && this.stacked === 'none') {
                    return;
                }
                // perform selection
                this.tabset.selectNextTab();
                // prevent the browser from scrolling when arrow keys are pressed
                event.preventDefault();
            };
        TabsetComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-tabset',
                        template: "<!-- Nav tabs -->\n<ul role=\"tablist\"\n    class=\"nav nav-tabs\"\n    [class.minimal-tab]=\"minimal\"\n    [attr.aria-label]=\"ariaLabel\"\n    [attr.aria-orientation]=\"stacked === 'none' ? 'horizontal' : 'vertical'\">\n\n\t<li role=\"presentation\" \n        class=\"nav-item\"\n        *ngFor=\"let tab of tabset.tabs$ | async; let index = index\"\n        [class.active]=\"tab.active$ | async\"\n        [class.disabled]=\"tab.disabled\"\n        [ngClass]=\"tab.customClass\">\n\n        <a class=\"nav-link\"\n            [id]=\"tab.id\"\n            role=\"tab\"\n            [uxTabFocus]=\"tab\"\n            [tabindex]=\"(tab.active$ | async) ? 0 : -1\"\n            [class.highlighted]=\"(tabset.focused$ | async) && (tabset.highlighted$ | async) === tab\"            \n            (mousedown)=\"tabset.select(tab)\"\n            (focus)=\"tabset.focused$.next(true)\"\n            (blur)=\"tabset.focused$.next(false)\"\n            (mousedown)=\"tabset.focused$.next(true)\"\n            (keydown.ArrowUp)=\"selectPreviousTab($event)\"\n            (keydown.ArrowLeft)=\"selectPreviousTab($event)\"\n            (keydown.ArrowRight)=\"selectNextTab($event)\"\n            (keydown.ArrowDown)=\"selectNextTab($event)\"\n            (keydown.Home)=\"tabset.selectFirstTab(); $event.preventDefault()\"\n            (keydown.End)=\"tabset.selectLastTab(); $event.preventDefault()\"\n            [attr.aria-controls]=\"tab.id\"\n            [attr.aria-selected]=\"tab.active$ | async\"\n            [attr.aria-disabled]=\"tab.disabled\">\n\n            <span *ngIf=\"!tab.headingRef\">{{ tab.heading }}</span>\n\n            <ng-container *ngIf=\"tab.headingRef\" [ngTemplateOutlet]=\"tab.headingRef\"></ng-container>\n        </a>\n\n\t</li>\n\n</ul>\n\n<!-- Tab panes -->\n<div class=\"tab-content\">\n\t<ng-content></ng-content>\n</div>",
                        changeDetection: core.ChangeDetectionStrategy.OnPush,
                        providers: [TabsetService],
                        host: {
                            '[class.tabs-left]': 'stacked === "left"',
                            '[class.tabs-right]': 'stacked === "right"',
                        }
                    }] }
        ];
        /** @nocollapse */
        TabsetComponent.ctorParameters = function () {
            return [
                { type: TabsetService }
            ];
        };
        TabsetComponent.propDecorators = {
            minimal: [{ type: core.Input }],
            stacked: [{ type: core.Input }],
            ariaLabel: [{ type: core.Input, args: ['aria-label',] }]
        };
        return TabsetComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TabsetModule = (function () {
        function TabsetModule() {
        }
        TabsetModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule
                        ],
                        exports: [TabsetComponent, TabComponent, TabHeadingDirective],
                        declarations: [TabsetComponent, TabComponent, TabHeadingDirective, TabFocusDirective],
                    },] }
        ];
        return TabsetModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TimelineComponent = (function () {
        function TimelineComponent() {
        }
        TimelineComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-timeline',
                        template: "<div class=\"timeline\">\r\n    <ng-content></ng-content>\r\n</div>\r\n"
                    }] }
        ];
        return TimelineComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ uniqueId$8 = 0;
    var TimelineEventComponent = (function () {
        function TimelineEventComponent() {
            this.id = "ux-timeline-event-" + uniqueId$8++;
        }
        TimelineEventComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-timeline-event',
                        template: "<div class=\"timeline-badge\" [ngClass]=\"badgeColor\" [attr.aria-describedby]=\"id\">\r\n    <span>{{ badgeTitle }}</span>\r\n</div>\r\n\r\n<div class=\"timeline-panel\" [id]=\"id\">\r\n    <ng-content></ng-content>\r\n</div>\r\n"
                    }] }
        ];
        TimelineEventComponent.propDecorators = {
            id: [{ type: core.Input }],
            badgeColor: [{ type: core.Input }],
            badgeTitle: [{ type: core.Input }]
        };
        return TimelineEventComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TimelineModule = (function () {
        function TimelineModule() {
        }
        TimelineModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule
                        ],
                        exports: [
                            TimelineComponent,
                            TimelineEventComponent
                        ],
                        declarations: [
                            TimelineComponent,
                            TimelineEventComponent
                        ]
                    },] }
        ];
        return TimelineModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ TOGGLESWITCH_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return ToggleSwitchComponent; }),
        multi: true
    };
    var /** @type {?} */ uniqueToggleSwitchId = 0;
    var ToggleSwitchComponent = (function () {
        function ToggleSwitchComponent() {
            this._toggleSwitchId = "ux-toggleswitch-" + ++uniqueToggleSwitchId;
            this.id = this._toggleSwitchId;
            this.tabindex = 0;
            this.clickable = true;
            this.disabled = false;
            this.ariaLabel = '';
            this.ariaLabelledby = null;
            this.valueChange = new core.EventEmitter();
            this._value = false;
            this.focused = false;
            this.onTouchedCallback = function () { };
            this.onChangeCallback = function () { };
        }
        Object.defineProperty(ToggleSwitchComponent.prototype, "value", {
            get: /**
             * @return {?}
             */ function () {
                return this._value;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._value = value;
                // Update value output
                this.valueChange.emit(value);
                // Notify ngModel
                this.onChangeCallback(value);
                this.onTouchedCallback();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ToggleSwitchComponent.prototype, "inputId", {
            get: /**
             * @return {?}
             */ function () {
                return (this.id || this._toggleSwitchId) + "-input";
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ToggleSwitchComponent.prototype.toggle = /**
         * @return {?}
         */
            function () {
                if (!this.disabled && this.clickable) {
                    this.value = !this.value;
                }
            };
        /**
         * @param {?} value
         * @return {?}
         */
        ToggleSwitchComponent.prototype.writeValue = /**
         * @param {?} value
         * @return {?}
         */
            function (value) {
                this.value = !!value;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        ToggleSwitchComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onChangeCallback = fn;
            };
        /**
         * @param {?} fn
         * @return {?}
         */
        ToggleSwitchComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) {
                this.onTouchedCallback = fn;
            };
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        ToggleSwitchComponent.prototype.setDisabledState = /**
         * @param {?} isDisabled
         * @return {?}
         */
            function (isDisabled) {
                this.disabled = isDisabled;
            };
        ToggleSwitchComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-toggleswitch',
                        template: "<label [attr.for]=\"inputId\"\n       class=\"ux-toggleswitch\"\n       [class.ux-toggleswitch-checked]=\"value\"\n       [class.ux-toggleswitch-disabled]=\"disabled\"\n       [class.ux-toggleswitch-focused]=\"focused\">\n\n    <input class=\"ux-toggleswitch-input\"\n           type=\"checkbox\"\n           role=\"switch\"\n           [id]=\"inputId\"\n           [checked]=\"value\"\n           [disabled]=\"disabled\"\n           [attr.name]=\"name\"\n           [tabindex]=\"tabindex\"\n           [attr.aria-label]=\"ariaLabel\"\n           [attr.aria-labelledby]=\"ariaLabelledby\"\n           [attr.aria-checked]=\"value\"\n           (focus)=\"focused = true\"\n           (blur)=\"focused = false\"\n           (change)=\"toggle()\"\n           (click)=\"$event.stopPropagation()\">\n\n    <div class=\"ux-toggleswitch-container\">\n        <div class=\"ux-toggleswitch-bg\"></div>\n        <div class=\"ux-toggleswitch-nub\"></div>\n    </div>\n\n    <span class=\"ux-toggleswitch-label\">\n        <ng-content></ng-content>\n    </span>\n</label>",
                        providers: [TOGGLESWITCH_VALUE_ACCESSOR]
                    }] }
        ];
        ToggleSwitchComponent.propDecorators = {
            id: [{ type: core.Input }],
            name: [{ type: core.Input }],
            tabindex: [{ type: core.Input }],
            clickable: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            ariaLabel: [{ type: core.Input, args: ['aria-label',] }],
            ariaLabelledby: [{ type: core.Input, args: ['aria-labelledby',] }],
            valueChange: [{ type: core.Output }],
            value: [{ type: core.Input }]
        };
        return ToggleSwitchComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ToggleSwitchModule = (function () {
        function ToggleSwitchModule() {
        }
        ToggleSwitchModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [forms.FormsModule],
                        exports: [ToggleSwitchComponent],
                        declarations: [ToggleSwitchComponent]
                    },] }
        ];
        return ToggleSwitchModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ToolbarSearchButtonDirective = (function () {
        function ToolbarSearchButtonDirective(_elementRef) {
            this._elementRef = _elementRef;
            this.clicked = new core.EventEmitter();
        }
        Object.defineProperty(ToolbarSearchButtonDirective.prototype, "width", {
            get: /**
             * @return {?}
             */ function () {
                return this._elementRef.nativeElement.offsetWidth;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ToolbarSearchButtonDirective.prototype.clickHandler = /**
         * @return {?}
         */
            function () {
                this.clicked.emit();
            };
        ToolbarSearchButtonDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxToolbarSearchButton]'
                    },] }
        ];
        /** @nocollapse */
        ToolbarSearchButtonDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef }
            ];
        };
        ToolbarSearchButtonDirective.propDecorators = {
            clicked: [{ type: core.Output }],
            clickHandler: [{ type: core.HostListener, args: ['click',] }]
        };
        return ToolbarSearchButtonDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ KEYS = {
        ENTER: 13,
        ESCAPE: 27
    };
    var ToolbarSearchFieldDirective = (function () {
        function ToolbarSearchFieldDirective(_elementRef, _ngModel) {
            this._elementRef = _elementRef;
            this._ngModel = _ngModel;
            this.cancel = new core.EventEmitter();
            this.submit = new core.EventEmitter();
        }
        Object.defineProperty(ToolbarSearchFieldDirective.prototype, "text", {
            get: /**
             * @return {?}
             */ function () {
                // Use ngModel if specified on the host; otherwise read the DOM
                if (this._ngModel) {
                    return this._ngModel.value;
                }
                return this._elementRef.nativeElement.value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ToolbarSearchFieldDirective.prototype.focus = /**
         * @return {?}
         */
            function () {
                var _this = this;
                setTimeout(function () {
                    _this._elementRef.nativeElement.focus();
                });
            };
        /**
         * @return {?}
         */
        ToolbarSearchFieldDirective.prototype.blur = /**
         * @return {?}
         */
            function () {
                var _this = this;
                setTimeout(function () {
                    _this._elementRef.nativeElement.blur();
                });
            };
        /**
         * @return {?}
         */
        ToolbarSearchFieldDirective.prototype.clear = /**
         * @return {?}
         */
            function () {
                // Use ngModel if specified on the host; otherwise use the DOM
                if (this._ngModel) {
                    this._ngModel.reset();
                }
                else {
                    this._elementRef.nativeElement.value = '';
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        ToolbarSearchFieldDirective.prototype.keydownHandler = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                var _this = this;
                setTimeout(function () {
                    if (event.keyCode === KEYS.ENTER) {
                        _this.submit.emit(_this.text);
                    }
                    else if (event.keyCode === KEYS.ESCAPE) {
                        _this._elementRef.nativeElement.blur();
                        _this.cancel.emit();
                    }
                });
            };
        ToolbarSearchFieldDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxToolbarSearchField]'
                    },] }
        ];
        /** @nocollapse */
        ToolbarSearchFieldDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: forms.NgModel, decorators: [{ type: core.Optional }] }
            ];
        };
        ToolbarSearchFieldDirective.propDecorators = {
            cancel: [{ type: core.Output }],
            submit: [{ type: core.Output }],
            keydownHandler: [{ type: core.HostListener, args: ['keydown', ['$event'],] }]
        };
        return ToolbarSearchFieldDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ToolbarSearchComponent = (function () {
        function ToolbarSearchComponent(_elementRef, _colorService, _document) {
            this._elementRef = _elementRef;
            this._colorService = _colorService;
            this._document = _document;
            this.direction = 'right';
            this.inverse = false;
            this.expandedChange = new core.EventEmitter();
            this.search = new core.EventEmitter();
            this._expanded = false;
            this.position = 'relative';
            this.backgroundColor = 'transparent';
        }
        Object.defineProperty(ToolbarSearchComponent.prototype, "expanded", {
            get: /**
             * @return {?}
             */ function () {
                return this._expanded;
            },
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this._expanded = value;
                this.expandedChange.emit(value);
                if (value) {
                    // Set focus on the input when expanded
                    this.field.focus();
                }
                else {
                    // Clear text when contracted
                    this.field.clear();
                    // Remove focus (works around an IE issue where the caret remains visible)
                    this.field.blur();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ToolbarSearchComponent.prototype, "background", {
            set: /**
             * @param {?} value
             * @return {?}
             */ function (value) {
                this.backgroundColor = this._colorService.resolve(value) || 'transparent';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ToolbarSearchComponent.prototype, "expandedAnimation", {
            get: /**
             * @return {?}
             */ function () {
                return {
                    value: this.expanded ? 'expanded' : 'collapsed',
                    params: {
                        initialWidth: this.button.width + 'px'
                    }
                };
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        ToolbarSearchComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // Subscribe to the submit event on the input field, triggering the search event
                this.field.submit.subscribe(function (text) { return _this.search.emit(text); });
                // Subscribe to cancel events coming from the input field
                this.field.cancel.subscribe(function () { return _this.expanded = false; });
                // Subscribe to the button click event
                this.button.clicked.subscribe(function () {
                    if (_this.expanded && _this.field.text) {
                        _this.search.emit(_this.field.text);
                    }
                    else {
                        _this.expanded = !_this.expanded;
                    }
                });
                // Create placeholder element to avoid changing layout when switching to position: absolute
                this.createPlaceholder();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        ToolbarSearchComponent.prototype.animationStart = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (event.toState === 'expanded') {
                    this.position = 'absolute';
                    this.enablePlaceholder(true);
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        ToolbarSearchComponent.prototype.animationDone = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (event.toState === 'collapsed') {
                    this.position = 'relative';
                    this.enablePlaceholder(false);
                }
            };
        /**
         * @return {?}
         */
        ToolbarSearchComponent.prototype.createPlaceholder = /**
         * @return {?}
         */
            function () {
                // Get width and height of the component
                var /** @type {?} */ styles = getComputedStyle(this._elementRef.nativeElement);
                // Create invisible div with the same dimensions
                this._placeholder = this._document.createElement('div');
                this._placeholder.style.display = 'none';
                this._placeholder.style.width = this.button.width + 'px';
                this._placeholder.style.height = styles.height;
                this._placeholder.style.visibility = 'hidden';
                // Add as a sibling
                this._elementRef.nativeElement.parentNode.insertBefore(this._placeholder, this._elementRef.nativeElement);
            };
        /**
         * @param {?} enabled
         * @return {?}
         */
        ToolbarSearchComponent.prototype.enablePlaceholder = /**
         * @param {?} enabled
         * @return {?}
         */
            function (enabled) {
                this._placeholder.style.display = (enabled ? 'inline-block' : 'none');
            };
        ToolbarSearchComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-toolbar-search',
                        template: "<ng-content></ng-content>",
                        animations: [
                            animations.trigger('expanded', [
                                animations.state('collapsed', animations.style({
                                    width: '{{initialWidth}}'
                                }), {
                                    params: { initialWidth: '30px' }
                                }),
                                animations.state('expanded', animations.style({
                                    width: '100%'
                                })),
                                animations.transition('collapsed <=> expanded', [animations.animate('0.3s ease-out')])
                            ])
                        ]
                    }] }
        ];
        /** @nocollapse */
        ToolbarSearchComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: ColorService },
                { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] }
            ];
        };
        ToolbarSearchComponent.propDecorators = {
            expanded: [{ type: core.HostBinding, args: ['class.expanded',] }, { type: core.Input }],
            direction: [{ type: core.Input }, { type: core.HostBinding, args: ['class',] }],
            inverse: [{ type: core.Input }, { type: core.HostBinding, args: ['class.inverse',] }],
            background: [{ type: core.Input }],
            expandedChange: [{ type: core.Output }],
            search: [{ type: core.Output }],
            expandedAnimation: [{ type: core.HostBinding, args: ['@expanded',] }],
            position: [{ type: core.HostBinding, args: ['style.position',] }],
            backgroundColor: [{ type: core.HostBinding, args: ['style.background-color',] }],
            field: [{ type: core.ContentChild, args: [ToolbarSearchFieldDirective,] }],
            button: [{ type: core.ContentChild, args: [ToolbarSearchButtonDirective,] }],
            animationStart: [{ type: core.HostListener, args: ['@expanded.start', ['$event'],] }],
            animationDone: [{ type: core.HostListener, args: ['@expanded.done', ['$event'],] }]
        };
        return ToolbarSearchComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ DECLARATIONS$6 = [
        ToolbarSearchComponent,
        ToolbarSearchFieldDirective,
        ToolbarSearchButtonDirective
    ];
    var ToolbarSearchModule = (function () {
        function ToolbarSearchModule() {
        }
        ToolbarSearchModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule
                        ],
                        exports: DECLARATIONS$6,
                        declarations: DECLARATIONS$6,
                        providers: [],
                    },] }
        ];
        return ToolbarSearchModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var VirtualScrollLoadingDirective = (function () {
        function VirtualScrollLoadingDirective() {
        }
        VirtualScrollLoadingDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxVirtualScrollLoading]'
                    },] }
        ];
        return VirtualScrollLoadingDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var VirtualScrollLoadButtonDirective = (function () {
        function VirtualScrollLoadButtonDirective() {
        }
        VirtualScrollLoadButtonDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxVirtualScrollLoadButton]'
                    },] }
        ];
        return VirtualScrollLoadButtonDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var VirtualScrollCellDirective = (function () {
        function VirtualScrollCellDirective() {
        }
        VirtualScrollCellDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxVirtualScrollCell]'
                    },] }
        ];
        return VirtualScrollCellDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var VirtualScrollComponent = (function () {
        function VirtualScrollComponent(_elementRef, resizeService) {
            var _this = this;
            this._elementRef = _elementRef;
            this.collection = Observable.Observable.create();
            this.loadOnScroll = true;
            this.loading = new core.EventEmitter();
            this.cells = new BehaviorSubject.BehaviorSubject([]);
            this.scrollTop = 0;
            this.isLoading = false;
            this.pageNumber = 0;
            this.data = [];
            this.loadingComplete = false;
            // watch for any future changes to size
            resizeService.addResizeListener(_elementRef.nativeElement).subscribe(function (event) { return _this._height = event.height; });
        }
        /**
         * @return {?}
         */
        VirtualScrollComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                if (!this.cellHeight) {
                    throw new Error('Virtual Scroll Component requires "cellHeight" property to be defined.');
                }
                // subscribe to the collection
                this.setupObservable();
                // load the first page of data
                this.loadNextPage();
            };
        /**
         * @return {?}
         */
        VirtualScrollComponent.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                // re-render cells now that we can display any loading indicator or loading button
                this.renderCells();
            };
        /**
         * @param {?} changes
         * @return {?}
         */
        VirtualScrollComponent.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                if (changes["collection"] && changes["collection"].currentValue !== changes["collection"].previousValue && !changes["collection"].isFirstChange()) {
                    this.setupObservable();
                    this.reset();
                }
            };
        /**
         * @return {?}
         */
        VirtualScrollComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._subscription.unsubscribe();
            };
        /**
         * @return {?}
         */
        VirtualScrollComponent.prototype.setupObservable = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // if there is a current subscription, unsubscribe
                if (this._subscription && this._subscription.unsubscribe) {
                    this._subscription.unsubscribe();
                }
                this._subscription = this.collection.subscribe(function (collection) {
                    (_a = _this.data).push.apply(_a, __spread(collection));
                    _this.renderCells();
                    _this.isLoading = false;
                    var _a;
                }, null, function () {
                    _this.loadingComplete = true;
                });
            };
        /**
         * @return {?}
         */
        VirtualScrollComponent.prototype.renderCells = /**
         * @return {?}
         */
            function () {
                this.cells.next(this.getVisibleCells());
                if (this.loadOnScroll && !this.isLoading && !this.loadingComplete) {
                    var /** @type {?} */ remainingScroll = this._elementRef.nativeElement.scrollHeight - (this._elementRef.nativeElement.scrollTop + this._elementRef.nativeElement.clientHeight);
                    // if the current cells take up less than the height of the component then load the next page
                    if (remainingScroll <= this._elementRef.nativeElement.clientHeight) {
                        this.loadNextPage();
                    }
                }
            };
        /**
         * @return {?}
         */
        VirtualScrollComponent.prototype.getVisibleCells = /**
         * @return {?}
         */
            function () {
                // store the initial element height
                if (!this._height) {
                    this._height = this._elementRef.nativeElement.offsetHeight;
                }
                // perform some calculations
                var /** @type {?} */ scrollTop = this._elementRef.nativeElement.scrollTop;
                var /** @type {?} */ startCell = Math.floor(scrollTop / this.cellHeight);
                var /** @type {?} */ endCell = Math.ceil(this._height / this.cellHeight) + 1;
                // update the scroll position
                this.scrollTop = scrollTop - (scrollTop % this.cellHeight);
                // return a sublist of items visible on the screen
                return this.data.slice(startCell, startCell + endCell);
            };
        /**
         * @return {?}
         */
        VirtualScrollComponent.prototype.getTotalHeight = /**
         * @return {?}
         */
            function () {
                return this.cellHeight * this.data.length;
            };
        /**
         * @return {?}
         */
        VirtualScrollComponent.prototype.loadNextPage = /**
         * @return {?}
         */
            function () {
                this.isLoading = true;
                this.loading.next(this.pageNumber);
                this.pageNumber++;
            };
        /**
         * @return {?}
         */
        VirtualScrollComponent.prototype.reset = /**
         * @return {?}
         */
            function () {
                // reset all values
                this.scrollTop = 0;
                this.data = [];
                this._height = undefined;
                this.pageNumber = 0;
                this.loadingComplete = false;
                // set scroll position
                this._elementRef.nativeElement.scrollTop = 0;
                // clear the current cells
                this.renderCells();
                // reload first page
                this.loadNextPage();
            };
        VirtualScrollComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ux-virtual-scroll',
                        template: "<div class=\"virtual-scroll-content-height\" [style.height.px]=\"getTotalHeight()\"></div>\n<div class=\"virtual-scroll-content\" [style.transform]=\"'translateY(' + scrollTop + 'px)'\">\n\n    <!-- Virtually Render Cells -->\n    <ng-container *ngFor=\"let cell of cells | async\">\n        <ng-container *ngTemplateOutlet=\"cellTemplate; context: { cell: cell }\"></ng-container>\n    </ng-container>\n\n    <!-- Loading Indicator -->\n    <ng-container *ngIf=\"loadingIndicatorTemplate && isLoading\" [ngTemplateOutlet]=\"loadingIndicatorTemplate\"></ng-container>\n\n    <!-- Loading Button -->\n    <div class=\"virtual-scroll-load-button\" *ngIf=\"loadButtonTemplate && !loadOnScroll && !loadingComplete && !isLoading\" (click)=\"loadNextPage()\">\n        <ng-container *ngTemplateOutlet=\"loadButtonTemplate\"></ng-container>\n    </div>\n    \n</div>"
                    }] }
        ];
        /** @nocollapse */
        VirtualScrollComponent.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: ResizeService }
            ];
        };
        VirtualScrollComponent.propDecorators = {
            collection: [{ type: core.Input }],
            cellHeight: [{ type: core.Input }],
            loadOnScroll: [{ type: core.Input }],
            loading: [{ type: core.Output }],
            cellTemplate: [{ type: core.ContentChild, args: [VirtualScrollCellDirective, { read: core.TemplateRef },] }],
            loadingIndicatorTemplate: [{ type: core.ContentChild, args: [VirtualScrollLoadingDirective, { read: core.TemplateRef },] }],
            loadButtonTemplate: [{ type: core.ContentChild, args: [VirtualScrollLoadButtonDirective, { read: core.TemplateRef },] }],
            renderCells: [{ type: core.HostListener, args: ['scroll',] }]
        };
        return VirtualScrollComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ DECLARATIONS$7 = [
        VirtualScrollComponent,
        VirtualScrollLoadingDirective,
        VirtualScrollLoadButtonDirective,
        VirtualScrollCellDirective
    ];
    var VirtualScrollModule = (function () {
        function VirtualScrollModule() {
        }
        VirtualScrollModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule,
                            ResizeModule
                        ],
                        exports: DECLARATIONS$7,
                        declarations: DECLARATIONS$7
                    },] }
        ];
        return VirtualScrollModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AutoGrowDirective = (function () {
        function AutoGrowDirective(_elementRef, _renderer) {
            this._elementRef = _elementRef;
            this._renderer = _renderer;
            // ensure this is a textarea or else throw error
            if (_elementRef.nativeElement.tagName.toLowerCase() !== 'textarea') {
                throw new Error('uxAutoGrow directive can only be used on <textarea> elements.');
            }
        }
        /**
         * @return {?}
         */
        AutoGrowDirective.prototype.ngAfterViewInit = /**
         * @return {?}
         */
            function () {
                this.update();
            };
        /**
         * @return {?}
         */
        AutoGrowDirective.prototype.update = /**
         * @return {?}
         */
            function () {
                // perform sizing
                this._renderer.setStyle(this._elementRef.nativeElement, 'overflowY', 'hidden');
                this._renderer.setStyle(this._elementRef.nativeElement, 'height', 'auto');
                // get the new total height and element height
                var scrollHeight = this._elementRef.nativeElement.scrollHeight;
                var maxHeight = getComputedStyle(this._elementRef.nativeElement).maxHeight;
                // determine what the maximum allowed height is
                var /** @type {?} */ maximum = !isNaN(parseFloat(maxHeight)) ? parseFloat(maxHeight) : Infinity;
                // if there is a max height specifed we want to show the scrollbars
                if (maximum < scrollHeight) {
                    this._renderer.setStyle(this._elementRef.nativeElement, 'overflowY', 'auto');
                    this._renderer.setStyle(this._elementRef.nativeElement, 'height', maximum + 'px');
                }
                else {
                    this._renderer.setStyle(this._elementRef.nativeElement, 'height', scrollHeight + 'px');
                }
            };
        AutoGrowDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxAutoGrow]'
                    },] }
        ];
        /** @nocollapse */
        AutoGrowDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Renderer2 }
            ];
        };
        AutoGrowDirective.propDecorators = {
            update: [{ type: core.HostListener, args: ['input',] }]
        };
        return AutoGrowDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var AutoGrowModule = (function () {
        function AutoGrowModule() {
        }
        AutoGrowModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [AutoGrowDirective],
                        declarations: [AutoGrowDirective]
                    },] }
        ];
        return AutoGrowModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FixedHeaderTableDirective = (function () {
        function FixedHeaderTableDirective(_elementRef, _renderer) {
            this._elementRef = _elementRef;
            this._renderer = _renderer;
            this.tablePaging = new core.EventEmitter();
        }
        /**
         * @return {?}
         */
        FixedHeaderTableDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                // add class to the table
                this._renderer.addClass(this._elementRef.nativeElement, 'ux-fixed-header-table');
                // locate the important elements
                this._tableHead = this._elementRef.nativeElement.querySelector('thead');
                this._tableBody = this._elementRef.nativeElement.querySelector('tbody');
                // bind to scroll events on the table body
                this._renderer.listen(this._tableBody, 'scroll', this.onScroll.bind(this));
                // resize the table header to account for scrollbar
                this.setLayout();
                // trigger the loading of the first page
                this.tablePaging.emit();
            };
        /**
         * Get the table element
         * Primarily used by column width directive
         */
        /**
         * Get the table element
         * Primarily used by column width directive
         * @return {?}
         */
        FixedHeaderTableDirective.prototype.getTable = /**
         * Get the table element
         * Primarily used by column width directive
         * @return {?}
         */
            function () {
                return this._elementRef.nativeElement;
            };
        /**
         * Handle scroll events
         * @return {?}
         */
        FixedHeaderTableDirective.prototype.onScroll = /**
         * Handle scroll events
         * @return {?}
         */
            function () {
                // determine if we are scrolled to the bottom and if so load the next page
                if (this._tableBody.scrollTop === (this._tableBody.scrollHeight - this._tableBody.offsetHeight)) {
                    this.tablePaging.emit();
                }
            };
        /**
         * Update the size of the table header to account for the scrollbar.
         * This is important to keep the columns aligned
         * @return {?}
         */
        FixedHeaderTableDirective.prototype.setLayout = /**
         * Update the size of the table header to account for the scrollbar.
         * This is important to keep the columns aligned
         * @return {?}
         */
            function () {
                // calculate the size of the scrollbar
                var /** @type {?} */ scrollbar = this._tableBody.offsetWidth - this._tableBody.clientWidth;
                // add padding to the header to account for this
                this._renderer.setStyle(this._tableHead, 'padding-right', scrollbar + 'px');
                // set the desired height of the table body
                this._renderer.setStyle(this._tableBody, 'height', typeof this.tableHeight === 'number' ? this.tableHeight + "px" : this.tableHeight);
            };
        FixedHeaderTableDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxFixedHeaderTable]'
                    },] }
        ];
        /** @nocollapse */
        FixedHeaderTableDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Renderer2 }
            ];
        };
        FixedHeaderTableDirective.propDecorators = {
            tableHeight: [{ type: core.Input }],
            tablePaging: [{ type: core.Output }]
        };
        return FixedHeaderTableDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FixedHeaderTableModule = (function () {
        function FixedHeaderTableModule() {
        }
        FixedHeaderTableModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [FixedHeaderTableDirective],
                        declarations: [FixedHeaderTableDirective]
                    },] }
        ];
        return FixedHeaderTableModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FloatLabelDirective = (function () {
        function FloatLabelDirective(_elementRef, _renderer) {
            this._elementRef = _elementRef;
            this._renderer = _renderer;
            this.mode = 'focus';
            this.raised = false;
            this._focused = false;
            this._eventHandles = [];
        }
        /**
         * @return {?}
         */
        FloatLabelDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this._eventHandles.push(this._renderer.listen(this.input, 'focus', this.inputFocus.bind(this)), this._renderer.listen(this.input, 'blur', this.inputBlur.bind(this)), this._renderer.listen(this.input, 'input', this.inputChange.bind(this)));
                // Check initial input value
                this.raised = this.hasText();
                // Ensure that the `for` attribute is set
                if (!this._elementRef.nativeElement.getAttribute('for') && this.input.getAttribute('id')) {
                    this._renderer.setAttribute(this._elementRef.nativeElement, 'for', this.input.getAttribute('id'));
                }
            };
        /**
         * @return {?}
         */
        FloatLabelDirective.prototype.ngOnChanges = /**
         * @return {?}
         */
            function () {
                if (!(this.mode === 'focus' && this._focused)) {
                    this.raised = this.hasText();
                }
            };
        /**
         * @return {?}
         */
        FloatLabelDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                // Unsubscribe event handles
                this._eventHandles.forEach(function (eventHandle) { return eventHandle(); });
            };
        /**
         * @return {?}
         */
        FloatLabelDirective.prototype.hasText = /**
         * @return {?}
         */
            function () {
                if (this.value === undefined) {
                    return !!this.input.value;
                }
                return !!this.value;
            };
        /**
         * @return {?}
         */
        FloatLabelDirective.prototype.inputFocus = /**
         * @return {?}
         */
            function () {
                if (this.mode === 'focus') {
                    this._focused = true;
                    this.raised = true;
                }
            };
        /**
         * @return {?}
         */
        FloatLabelDirective.prototype.inputBlur = /**
         * @return {?}
         */
            function () {
                if (this.mode === 'focus') {
                    this._focused = false;
                    this.raised = this.hasText();
                }
            };
        /**
         * @return {?}
         */
        FloatLabelDirective.prototype.inputChange = /**
         * @return {?}
         */
            function () {
                if (this.mode === 'input') {
                    this.raised = this.hasText();
                }
            };
        FloatLabelDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxFloatLabel]',
                        host: {
                            'class': 'ux-float-label'
                        }
                    },] }
        ];
        /** @nocollapse */
        FloatLabelDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Renderer2 }
            ];
        };
        FloatLabelDirective.propDecorators = {
            input: [{ type: core.Input, args: ['uxFloatLabel',] }],
            value: [{ type: core.Input }],
            mode: [{ type: core.Input }],
            raised: [{ type: core.HostBinding, args: ['class.ux-float-label-raised',] }]
        };
        return FloatLabelDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FloatLabelModule = (function () {
        function FloatLabelModule() {
        }
        FloatLabelModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [],
                        exports: [FloatLabelDirective],
                        declarations: [FloatLabelDirective],
                        providers: [],
                    },] }
        ];
        return FloatLabelModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var HelpCenterService = (function () {
        function HelpCenterService() {
            this.items = new BehaviorSubject.BehaviorSubject([]);
        }
        /**
         * @param {?} item
         * @return {?}
         */
        HelpCenterService.prototype.registerItem = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                // get the current items
                var /** @type {?} */ items = this.items.getValue();
                // add the new item to the list
                items.push(item);
                // update the observable
                this.items.next(items);
            };
        /**
         * @param {?} item
         * @return {?}
         */
        HelpCenterService.prototype.unregisterItem = /**
         * @param {?} item
         * @return {?}
         */
            function (item) {
                // get the current items
                var /** @type {?} */ items = this.items.getValue();
                // remove the item being unregistered
                items = items.filter(function (itm) { return itm !== item; });
                // update the observable
                this.items.next(items);
            };
        HelpCenterService.decorators = [
            { type: core.Injectable }
        ];
        return HelpCenterService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var HelpCenterItemDirective = (function () {
        function HelpCenterItemDirective(_helpCenterService) {
            this._helpCenterService = _helpCenterService;
        }
        /**
         * @return {?}
         */
        HelpCenterItemDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                // register the item in the service
                this._helpCenterService.registerItem(this.uxHelpCenterItem);
            };
        /**
         * @return {?}
         */
        HelpCenterItemDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                // remove this item when it is destroyed
                this._helpCenterService.unregisterItem(this.uxHelpCenterItem);
            };
        HelpCenterItemDirective.decorators = [
            { type: core.Directive, args: [{ selector: '[uxHelpCenterItem]' },] }
        ];
        /** @nocollapse */
        HelpCenterItemDirective.ctorParameters = function () {
            return [
                { type: HelpCenterService }
            ];
        };
        HelpCenterItemDirective.propDecorators = {
            uxHelpCenterItem: [{ type: core.Input }]
        };
        return HelpCenterItemDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var HelpCenterModule = (function () {
        function HelpCenterModule() {
        }
        HelpCenterModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [],
                        exports: [HelpCenterItemDirective],
                        declarations: [HelpCenterItemDirective],
                        providers: [HelpCenterService],
                    },] }
        ];
        return HelpCenterModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var HoverActionService = (function () {
        function HoverActionService() {
            this.active = new BehaviorSubject.BehaviorSubject(false);
            this._focused = false;
            this._hovered = false;
            this._actions = [];
        }
        /**
         * @param {?} action
         * @return {?}
         */
        HoverActionService.prototype.register = /**
         * @param {?} action
         * @return {?}
         */
            function (action) {
                this._actions.push(action);
            };
        /**
         * @param {?} action
         * @return {?}
         */
        HoverActionService.prototype.unregister = /**
         * @param {?} action
         * @return {?}
         */
            function (action) {
                this._actions = this._actions.filter(function (actn) { return actn !== action; });
            };
        /**
         * @param {?} container
         * @return {?}
         */
        HoverActionService.prototype.setContainer = /**
         * @param {?} container
         * @return {?}
         */
            function (container) {
                this._container = container;
            };
        /**
         * @param {?} focus
         * @return {?}
         */
        HoverActionService.prototype.setFocusState = /**
         * @param {?} focus
         * @return {?}
         */
            function (focus) {
                this._focused = focus;
                this.updateVisibility();
            };
        /**
         * @param {?} hover
         * @return {?}
         */
        HoverActionService.prototype.setHoverState = /**
         * @param {?} hover
         * @return {?}
         */
            function (hover) {
                this._hovered = hover;
                this.updateVisibility();
            };
        /**
         * @return {?}
         */
        HoverActionService.prototype.next = /**
         * @return {?}
         */
            function () {
                // if container has focus then focus the first hover action
                if (this.containerHasFocus()) {
                    this.focusActionAtIndex(0);
                    return this.updateVisibility();
                }
                // if a hover action has focus then focus the next action
                if (this.actionHasFocus()) {
                    var /** @type {?} */ index = this.getFocusedActionIndex() + 1;
                    this.focusActionAtIndex(index);
                    this.updateVisibility();
                }
            };
        /**
         * @return {?}
         */
        HoverActionService.prototype.previous = /**
         * @return {?}
         */
            function () {
                // if a hover action has focus then focus the previous action
                if (this.actionHasFocus()) {
                    var /** @type {?} */ index = this.getFocusedActionIndex() - 1;
                    if (index >= 0) {
                        this.focusActionAtIndex(index);
                    }
                    else {
                        this._container.focus();
                    }
                }
                this.updateVisibility();
            };
        /**
         * @return {?}
         */
        HoverActionService.prototype.updateVisibility = /**
         * @return {?}
         */
            function () {
                this.active.next(this._focused || this._hovered || this.actionHasFocus());
            };
        /**
         * @param {?} index
         * @return {?}
         */
        HoverActionService.prototype.focusActionAtIndex = /**
         * @param {?} index
         * @return {?}
         */
            function (index) {
                if (index >= 0 && index < this._actions.length) {
                    this._actions[index].focus();
                }
            };
        /**
         * @return {?}
         */
        HoverActionService.prototype.getFocusedActionIndex = /**
         * @return {?}
         */
            function () {
                var _this = this;
                return this._actions.findIndex(function (action) { return action === _this.getFocusedAction(); });
            };
        /**
         * @return {?}
         */
        HoverActionService.prototype.containerHasFocus = /**
         * @return {?}
         */
            function () {
                return this._focused;
            };
        /**
         * @return {?}
         */
        HoverActionService.prototype.actionHasFocus = /**
         * @return {?}
         */
            function () {
                return !!this.getFocusedAction();
            };
        /**
         * @return {?}
         */
        HoverActionService.prototype.getFocusedAction = /**
         * @return {?}
         */
            function () {
                return this._actions.find(function (action) { return action.focused; });
            };
        HoverActionService.decorators = [
            { type: core.Injectable }
        ];
        return HoverActionService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var HoverActionContainerDirective = (function () {
        function HoverActionContainerDirective(_elementRef, _hoverActionService) {
            var _this = this;
            this._elementRef = _elementRef;
            this._hoverActionService = _hoverActionService;
            this.tabindex = 0;
            this.active = false;
            // register the container element with the service
            this._hoverActionService.setContainer(this);
            // apply a class based on the active state of the container and it's actions
            this.active$ = this._hoverActionService.active.subscribe(function (active) { return _this.active = active; });
        }
        /**
         * @return {?}
         */
        HoverActionContainerDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.active$.unsubscribe();
            };
        /**
         * @return {?}
         */
        HoverActionContainerDirective.prototype.focus = /**
         * @return {?}
         */
            function () {
                this._elementRef.nativeElement.focus();
            };
        /**
         * @return {?}
         */
        HoverActionContainerDirective.prototype.onFocus = /**
         * @return {?}
         */
            function () {
                this._hoverActionService.setFocusState(true);
            };
        /**
         * @return {?}
         */
        HoverActionContainerDirective.prototype.onBlur = /**
         * @return {?}
         */
            function () {
                this._hoverActionService.setFocusState(false);
            };
        /**
         * @return {?}
         */
        HoverActionContainerDirective.prototype.onHover = /**
         * @return {?}
         */
            function () {
                this._hoverActionService.setHoverState(true);
            };
        /**
         * @return {?}
         */
        HoverActionContainerDirective.prototype.onLeave = /**
         * @return {?}
         */
            function () {
                this._hoverActionService.setHoverState(false);
            };
        /**
         * @return {?}
         */
        HoverActionContainerDirective.prototype.next = /**
         * @return {?}
         */
            function () {
                this._hoverActionService.next();
            };
        HoverActionContainerDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxHoverActionContainer]',
                        providers: [HoverActionService],
                        host: {
                            '[class.hover-action-container-active]': 'active',
                            '[tabindex]': 'tabindex'
                        }
                    },] }
        ];
        /** @nocollapse */
        HoverActionContainerDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: HoverActionService }
            ];
        };
        HoverActionContainerDirective.propDecorators = {
            tabindex: [{ type: core.Input }],
            focus: [{ type: core.HostListener, args: ['click',] }],
            onFocus: [{ type: core.HostListener, args: ['focus',] }],
            onBlur: [{ type: core.HostListener, args: ['blur',] }],
            onHover: [{ type: core.HostListener, args: ['mouseenter',] }],
            onLeave: [{ type: core.HostListener, args: ['mouseleave',] }],
            next: [{ type: core.HostListener, args: ['keydown.arrowright',] }]
        };
        return HoverActionContainerDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var HoverActionDirective = (function () {
        function HoverActionDirective(_elementRef, _hoverActionService) {
            var _this = this;
            this._elementRef = _elementRef;
            this._hoverActionService = _hoverActionService;
            this.tabindex = 1;
            this.active = false;
            this.focused = false;
            // register the action
            this._hoverActionService.register(this);
            // watch for changes to the activeness of the container
            this.active$ = this._hoverActionService.active.subscribe(function (active) { return _this.active = active; });
        }
        /**
         * @return {?}
         */
        HoverActionDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._hoverActionService.unregister(this);
                this.active$.unsubscribe();
            };
        /**
         * @return {?}
         */
        HoverActionDirective.prototype.focus = /**
         * @return {?}
         */
            function () {
                this._elementRef.nativeElement.focus();
            };
        /**
         * @return {?}
         */
        HoverActionDirective.prototype.onFocus = /**
         * @return {?}
         */
            function () {
                this.focused = true;
                this._hoverActionService.updateVisibility();
            };
        /**
         * @return {?}
         */
        HoverActionDirective.prototype.onBlur = /**
         * @return {?}
         */
            function () {
                this.focused = false;
                this._hoverActionService.updateVisibility();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        HoverActionDirective.prototype.previous = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                event.stopPropagation();
                this._hoverActionService.previous();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        HoverActionDirective.prototype.next = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                event.stopPropagation();
                this._hoverActionService.next();
            };
        HoverActionDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxHoverAction]',
                        host: {
                            '[class.hover-action-active]': 'active',
                            '[class.hover-action-focused]': 'focused',
                            '[tabindex]': 'tabindex'
                        }
                    },] }
        ];
        /** @nocollapse */
        HoverActionDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: HoverActionService }
            ];
        };
        HoverActionDirective.propDecorators = {
            tabindex: [{ type: core.Input }],
            onFocus: [{ type: core.HostListener, args: ['focus',] }],
            onBlur: [{ type: core.HostListener, args: ['blur',] }],
            previous: [{ type: core.HostListener, args: ['keydown.arrowleft', ['$event'],] }],
            next: [{ type: core.HostListener, args: ['keydown.arrowright', ['$event'],] }]
        };
        return HoverActionDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ DECLARATIONS$8 = [
        HoverActionDirective,
        HoverActionContainerDirective
    ];
    var HoverActionModule = (function () {
        function HoverActionModule() {
        }
        HoverActionModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: DECLARATIONS$8,
                        declarations: DECLARATIONS$8
                    },] }
        ];
        return HoverActionModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var LayoutSwitcherItemDirective = (function () {
        function LayoutSwitcherItemDirective(_templateRef, _viewContainerRef) {
            this._templateRef = _templateRef;
            this._viewContainerRef = _viewContainerRef;
        }
        /**
         * @return {?}
         */
        LayoutSwitcherItemDirective.prototype.getLayout = /**
         * @return {?}
         */
            function () {
                return this._templateRef;
            };
        /**
         * @return {?}
         */
        LayoutSwitcherItemDirective.prototype.getConfig = /**
         * @return {?}
         */
            function () {
                return this._config;
            };
        /**
         * @return {?}
         */
        LayoutSwitcherItemDirective.prototype.activate = /**
         * @return {?}
         */
            function () {
                this._embeddedView = this._viewContainerRef.createEmbeddedView(this._templateRef);
            };
        /**
         * @return {?}
         */
        LayoutSwitcherItemDirective.prototype.deactivate = /**
         * @return {?}
         */
            function () {
                var /** @type {?} */ index = this._viewContainerRef.indexOf(this._embeddedView);
                this._viewContainerRef.remove(index);
                this._embeddedView = null;
            };
        LayoutSwitcherItemDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxLayoutSwitcherItem]'
                    },] }
        ];
        /** @nocollapse */
        LayoutSwitcherItemDirective.ctorParameters = function () {
            return [
                { type: core.TemplateRef },
                { type: core.ViewContainerRef }
            ];
        };
        LayoutSwitcherItemDirective.propDecorators = {
            _config: [{ type: core.Input, args: ['uxLayoutSwitcherItem',] }]
        };
        return LayoutSwitcherItemDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var LayoutSwitcherDirective = (function () {
        function LayoutSwitcherDirective(_elementRef, resizeService, _viewContainerRef) {
            var _this = this;
            this._elementRef = _elementRef;
            this._viewContainerRef = _viewContainerRef;
            // watch for changes to the container size
            resizeService.addResizeListener(_elementRef.nativeElement).subscribe(function (event) {
                _this._width = event.width;
                // render the appropriate layout
                // render the appropriate layout
                _this.updateActiveLayout();
            });
        }
        /**
         * @param {?} changes
         * @return {?}
         */
        LayoutSwitcherDirective.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                // if the active group has changed then render the appropriate layout
                if (changes["group"].currentValue !== changes["group"].previousValue) {
                    this.updateActiveLayout();
                }
            };
        /**
         * @return {?}
         */
        LayoutSwitcherDirective.prototype.getActiveLayout = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // if there are currently no layouts then do nothing
                if (!this._layouts) {
                    return null;
                }
                // otherwise find layouts that match the active group and that meet the constraints
                return this._layouts.filter(function (layout) { return _this.group === layout.getConfig().group; }).find(function (layout) {
                    var /** @type {?} */ minWidth = layout.getConfig().minWidth || 0;
                    var /** @type {?} */ maxWidth = layout.getConfig().maxWidth || Infinity;
                    return _this._width >= minWidth && _this._width < maxWidth;
                });
            };
        /**
         * @return {?}
         */
        LayoutSwitcherDirective.prototype.updateActiveLayout = /**
         * @return {?}
         */
            function () {
                // get the layout that should be shown
                var /** @type {?} */ layout = this.getActiveLayout();
                // check if we are currently showing the layout
                if (this._activeLayout === layout) {
                    return;
                }
                // remove the current layout
                if (this._activeLayout) {
                    this._activeLayout.deactivate();
                }
                // store the new active layout
                this._activeLayout = layout;
                // if there is an active layout then activate
                if (this._activeLayout) {
                    this._activeLayout.activate();
                }
            };
        /**
         * @return {?}
         */
        LayoutSwitcherDirective.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                // store the initial current element width
                this._width = this._elementRef.nativeElement.offsetWidth;
                // render the appropriate layout - need a delay as Angular doesn't like changes like this in these lifecycle hooks
                requestAnimationFrame(this.updateActiveLayout.bind(this));
            };
        LayoutSwitcherDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxLayoutSwitcher]'
                    },] }
        ];
        /** @nocollapse */
        LayoutSwitcherDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: ResizeService },
                { type: core.ViewContainerRef }
            ];
        };
        LayoutSwitcherDirective.propDecorators = {
            group: [{ type: core.Input }],
            _layouts: [{ type: core.ContentChildren, args: [LayoutSwitcherItemDirective,] }]
        };
        return LayoutSwitcherDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ DECLARATIONS$9 = [
        LayoutSwitcherDirective,
        LayoutSwitcherItemDirective
    ];
    var LayoutSwitcherModule = (function () {
        function LayoutSwitcherModule() {
        }
        LayoutSwitcherModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            ResizeModule
                        ],
                        exports: DECLARATIONS$9,
                        declarations: DECLARATIONS$9,
                        providers: [],
                    },] }
        ];
        return LayoutSwitcherModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var OverflowDirective = (function () {
        function OverflowDirective(_elementRef) {
            this._elementRef = _elementRef;
            /**
             * Allow overflow to be within a range before emitting
             */
            this.tolerance = 0;
            /**
             * Emit when there is a change to the overflow state - horizontal or vertical
             */
            this.uxOverflowObserver = new core.EventEmitter();
            /**
             * Emit when there is a change to overflow on the horizontal axis
             */
            this.uxOverflowHorizontalObserver = new core.EventEmitter();
            /**
             * Emit when there is a change to overflow on the vertical axis
             */
            this.uxOverflowVerticalObserver = new core.EventEmitter();
            /**
             * Store the overflow state on both axis
             */
            this._state = { horizontalOverflow: false, verticalOverflow: false };
            /**
             * Unsubscribe from all the observables
             */
            this._onDestroy = new Subject.Subject();
        }
        /** Set up the trigger if specified */
        /**
         * Set up the trigger if specified
         * @return {?}
         */
        OverflowDirective.prototype.ngOnInit = /**
         * Set up the trigger if specified
         * @return {?}
         */
            function () {
                var _this = this;
                if (this.trigger) {
                    this.trigger.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.checkForOverflow(); });
                }
            };
        /** Perform an intial check for overflow */
        /**
         * Perform an intial check for overflow
         * @return {?}
         */
        OverflowDirective.prototype.ngAfterViewInit = /**
         * Perform an intial check for overflow
         * @return {?}
         */
            function () {
                var _this = this;
                requestAnimationFrame(function () { return _this.checkForOverflow(); });
            };
        /** Unsubscribe from the trigger */
        /**
         * Unsubscribe from the trigger
         * @return {?}
         */
        OverflowDirective.prototype.ngOnDestroy = /**
         * Unsubscribe from the trigger
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /** Programmatically trigger check for overflow */
        /**
         * Programmatically trigger check for overflow
         * @return {?}
         */
        OverflowDirective.prototype.checkForOverflow = /**
         * Programmatically trigger check for overflow
         * @return {?}
         */
            function () {
                var _a = this._elementRef.nativeElement, offsetWidth = _a.offsetWidth, offsetHeight = _a.offsetHeight, scrollWidth = _a.scrollWidth, scrollHeight = _a.scrollHeight;
                var /** @type {?} */ horizontalOverflow = (scrollWidth - offsetWidth) > this.tolerance;
                var /** @type {?} */ verticalOverflow = (scrollHeight - offsetHeight) > this.tolerance;
                if (horizontalOverflow !== this._state.horizontalOverflow) {
                    this.uxOverflowHorizontalObserver.emit(horizontalOverflow);
                }
                if (verticalOverflow !== this._state.verticalOverflow) {
                    this.uxOverflowVerticalObserver.emit(verticalOverflow);
                }
                if (horizontalOverflow !== this._state.horizontalOverflow || verticalOverflow !== this._state.verticalOverflow) {
                    this.uxOverflowObserver.emit((horizontalOverflow || verticalOverflow));
                }
                // store the state
                this._state = { horizontalOverflow: horizontalOverflow, verticalOverflow: verticalOverflow };
            };
        OverflowDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxOverflowObserver], [uxOverflowHorizontalObserver], [uxOverflowVerticalObserver]',
                        exportAs: 'ux-overflow-observer'
                    },] }
        ];
        /** @nocollapse */
        OverflowDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef }
            ];
        };
        OverflowDirective.propDecorators = {
            trigger: [{ type: core.Input }],
            tolerance: [{ type: core.Input }],
            uxOverflowObserver: [{ type: core.Output }],
            uxOverflowHorizontalObserver: [{ type: core.Output }],
            uxOverflowVerticalObserver: [{ type: core.Output }]
        };
        return OverflowDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ObserversModule = (function () {
        function ObserversModule() {
        }
        ObserversModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [OverflowDirective],
                        declarations: [OverflowDirective]
                    },] }
        ];
        return ObserversModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SelectionItemDirective = (function () {
        function SelectionItemDirective(_selectionService, _elementRef) {
            this._selectionService = _selectionService;
            this._elementRef = _elementRef;
            this.tabindex = null;
            this.selectedChange = new core.EventEmitter();
            this.active = false;
            this._selected = false;
            this._managedTabIndex = -1;
            this._onDestroy = new Subject.Subject();
        }
        Object.defineProperty(SelectionItemDirective.prototype, "selected", {
            get: /**
             * @return {?}
             */ function () {
                return this._selected;
            },
            set: /**
             * @param {?} selected
             * @return {?}
             */ function (selected) {
                selected ? this.select() : this.deselect();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectionItemDirective.prototype, "attrTabIndex", {
            get: /**
             * @return {?}
             */ function () {
                return (this.tabindex !== null) ? this.tabindex : this._managedTabIndex;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        SelectionItemDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // if there is no associated data then throw an error
                if (!this.uxSelectionItem) {
                    throw new Error('The uxSelectionItem directive must have data associated with it.');
                }
                // subscribe to selection changes on this item
                this._selectionService.getSelectionState(this.uxSelectionItem).pipe(operators.takeUntil(this._onDestroy)).subscribe(function (selected) {
                    // store the selected state
                    // store the selected state
                    _this._selected = selected;
                    // emit the selected state
                    // emit the selected state
                    _this.selectedChange.emit(selected);
                });
                this._selected = this._selectionService.isSelected(this.uxSelectionItem);
                this.selectedChange.emit(this._selected);
                // subscribe to changes to the active state
                this._selectionService.active$.pipe(operators.takeUntil(this._onDestroy), operators.map(function (active) { return active === _this.uxSelectionItem; })).subscribe(function (active) {
                    // store the focus state
                    // store the focus state
                    _this.active = active;
                    // if it is active then focus the element
                    if (active === true) {
                        _this._selectionService.focus$.next(_this.uxSelectionItem);
                        _this._elementRef.nativeElement.focus();
                    }
                });
                // Subscribe to changes to the focus target
                // This is mostly the same as active$, except that it has an initial value of the first item in the collection.
                this._selectionService.focus$.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (focusTarget) {
                    _this._managedTabIndex = (focusTarget === _this.uxSelectionItem) ? 0 : -1;
                });
            };
        /**
         * @return {?}
         */
        SelectionItemDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SelectionItemDirective.prototype.click = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this._selectionService.isEnabled && this._selectionService.isClickEnabled) {
                    this._selectionService.strategy.click(event, this.uxSelectionItem);
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SelectionItemDirective.prototype.mousedown = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this._selectionService.isEnabled && this._selectionService.isClickEnabled) {
                    this._selectionService.strategy.mousedown(event, this.uxSelectionItem);
                }
            };
        /**
         * @param {?} event
         * @return {?}
         */
        SelectionItemDirective.prototype.keydown = /**
         * @param {?} event
         * @return {?}
         */
            function (event) {
                if (this._selectionService.isEnabled && this._selectionService.isKeyboardEnabled) {
                    this._selectionService.strategy.keydown(event, this.uxSelectionItem);
                }
            };
        /**
         * @return {?}
         */
        SelectionItemDirective.prototype.focus = /**
         * @return {?}
         */
            function () {
                // If tabbed to from outside the component, activate.
                if (this._selectionService.active$.getValue() !== this.uxSelectionItem) {
                    this._selectionService.activate(this.uxSelectionItem);
                }
            };
        /**
         * Select this item using the current strategy
         */
        /**
         * Select this item using the current strategy
         * @return {?}
         */
        SelectionItemDirective.prototype.select = /**
         * Select this item using the current strategy
         * @return {?}
         */
            function () {
                if (this._selectionService.isEnabled) {
                    this._selectionService.strategy.select(this.uxSelectionItem);
                }
            };
        /**
         * Deselect this item using the current strategy
         */
        /**
         * Deselect this item using the current strategy
         * @return {?}
         */
        SelectionItemDirective.prototype.deselect = /**
         * Deselect this item using the current strategy
         * @return {?}
         */
            function () {
                if (this._selectionService.isEnabled) {
                    this._selectionService.strategy.deselect(this.uxSelectionItem);
                }
            };
        SelectionItemDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxSelectionItem]',
                        exportAs: 'ux-selection-item'
                    },] }
        ];
        /** @nocollapse */
        SelectionItemDirective.ctorParameters = function () {
            return [
                { type: SelectionService },
                { type: core.ElementRef }
            ];
        };
        SelectionItemDirective.propDecorators = {
            uxSelectionItem: [{ type: core.Input }],
            selected: [{ type: core.Input }, { type: core.HostBinding, args: ['class.ux-selection-selected',] }],
            tabindex: [{ type: core.Input }],
            selectedChange: [{ type: core.Output }],
            active: [{ type: core.HostBinding, args: ['class.ux-selection-focused',] }],
            attrTabIndex: [{ type: core.HostBinding, args: ['attr.tabindex',] }],
            click: [{ type: core.HostListener, args: ['click', ['$event'],] }],
            mousedown: [{ type: core.HostListener, args: ['mousedown', ['$event'],] }],
            keydown: [{ type: core.HostListener, args: ['keydown', ['$event'],] }],
            focus: [{ type: core.HostListener, args: ['focus',] }]
        };
        return SelectionItemDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SelectionDirective = (function () {
        function SelectionDirective(_selectionService, _cdRef) {
            var _this = this;
            this._selectionService = _selectionService;
            this._cdRef = _cdRef;
            this.tabindex = null;
            this.uxSelectionChange = new core.EventEmitter();
            this._onDestroy = new Subject.Subject();
            _selectionService.selection$.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (items) { return _this.uxSelectionChange.emit(items); });
        }
        Object.defineProperty(SelectionDirective.prototype, "uxSelection", {
            set: /**
             * @param {?} items
             * @return {?}
             */ function (items) {
                (_a = this._selectionService).select.apply(_a, __spread(items));
                var _a;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectionDirective.prototype, "disabled", {
            set: /**
             * @param {?} disabled
             * @return {?}
             */ function (disabled) {
                this._selectionService.setDisabled(disabled);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectionDirective.prototype, "mode", {
            set: /**
             * @param {?} mode
             * @return {?}
             */ function (mode) {
                this._selectionService.setStrategy(mode);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectionDirective.prototype, "clickSelection", {
            set: /**
             * @param {?} isClickEnabled
             * @return {?}
             */ function (isClickEnabled) {
                this._selectionService.isClickEnabled = isClickEnabled;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SelectionDirective.prototype, "keyboardSelection", {
            set: /**
             * @param {?} isKeyboardEnabled
             * @return {?}
             */ function (isKeyboardEnabled) {
                this._selectionService.isKeyboardEnabled = isKeyboardEnabled;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        SelectionDirective.prototype.ngAfterContentInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // provide the initial list of selection items
                this.update();
                // if the list changes then inform the service
                this.items.changes.pipe(operators.takeUntil(this._onDestroy)).subscribe(function () { return _this.update(); });
            };
        /**
         * @return {?}
         */
        SelectionDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * Update the dataset to reflect the latest selection items
         */
        /**
         * Update the dataset to reflect the latest selection items
         * @return {?}
         */
        SelectionDirective.prototype.update = /**
         * Update the dataset to reflect the latest selection items
         * @return {?}
         */
            function () {
                this._selectionService.dataset = this.items.map(function (item) { return item.uxSelectionItem; });
                // Make sure that a tab target has been defined so that the component can be tabbed to.
                if (this._selectionService.focus$.getValue() === null && this._selectionService.dataset.length > 0) {
                    this._selectionService.focus$.next(this._selectionService.dataset[0]);
                }
                // The above could trigger a change in the computed tabindex for selection items
                this._cdRef.detectChanges();
            };
        /**
         * Select all the items in the list
         */
        /**
         * Select all the items in the list
         * @return {?}
         */
        SelectionDirective.prototype.selectAll = /**
         * Select all the items in the list
         * @return {?}
         */
            function () {
                if (this._selectionService.isEnabled) {
                    this._selectionService.strategy.selectAll();
                }
            };
        /**
         * Deselect all currently selected items
         */
        /**
         * Deselect all currently selected items
         * @return {?}
         */
        SelectionDirective.prototype.deselectAll = /**
         * Deselect all currently selected items
         * @return {?}
         */
            function () {
                if (this._selectionService.isEnabled) {
                    this._selectionService.strategy.deselectAll();
                }
            };
        SelectionDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxSelection]',
                        exportAs: 'ux-selection',
                        providers: [SelectionService]
                    },] }
        ];
        /** @nocollapse */
        SelectionDirective.ctorParameters = function () {
            return [
                { type: SelectionService },
                { type: core.ChangeDetectorRef }
            ];
        };
        SelectionDirective.propDecorators = {
            uxSelection: [{ type: core.Input }],
            disabled: [{ type: core.Input }],
            mode: [{ type: core.Input }],
            clickSelection: [{ type: core.Input }],
            keyboardSelection: [{ type: core.Input }],
            tabindex: [{ type: core.Input }, { type: core.HostBinding, args: ['attr.tabindex',] }],
            uxSelectionChange: [{ type: core.Output }],
            items: [{ type: core.ContentChildren, args: [SelectionItemDirective,] }]
        };
        return SelectionDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SelectionModule = (function () {
        function SelectionModule() {
        }
        SelectionModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            common.CommonModule
                        ],
                        declarations: [SelectionDirective, SelectionItemDirective],
                        exports: [SelectionDirective, SelectionItemDirective]
                    },] }
        ];
        return SelectionModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TreeGridState = (function () {
        function TreeGridState(level, setSize, positionInSet) {
            this.level = level;
            this.setSize = setSize;
            this.positionInSet = positionInSet;
            this.loading$ = new BehaviorSubject.BehaviorSubject(false);
        }
        return TreeGridState;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TreeGridService = (function () {
        function TreeGridService(_changeDetector) {
            var _this = this;
            this._changeDetector = _changeDetector;
            /**
             * The raw table data
             */
            this.data$ = new BehaviorSubject.BehaviorSubject([]);
            /**
             * The flattened table data
             */
            this.rows$ = new BehaviorSubject.BehaviorSubject([]);
            /**
             * Ensure we destroy all observables correctly
             */
            this._onDestroy = new Subject.Subject();
            this.data$.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (data) { return _this.rows$.next(_this.getFlattenedTree(data)); });
        }
        /** Unsubscribe from all observables */
        /**
         * Unsubscribe from all observables
         * @return {?}
         */
        TreeGridService.prototype.ngOnDestroy = /**
         * Unsubscribe from all observables
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /** Set the expanded state of a row */
        /**
         * Set the expanded state of a row
         * @param {?} item
         * @param {?} expanded
         * @return {?}
         */
        TreeGridService.prototype.setExpanded = /**
         * Set the expanded state of a row
         * @param {?} item
         * @param {?} expanded
         * @return {?}
         */
            function (item, expanded) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                if (!expanded)
                                    return [3 /*break*/, 2];
                                return [4 /*yield*/, this.getChildren(item)];
                            case 1:
                                _a.sent();
                                this.insertChildren(item);
                                return [3 /*break*/, 3];
                            case 2:
                                this.removeChildren(item);
                                _a.label = 3;
                            case 3:
                                this._changeDetector.detectChanges();
                                return [2 /*return*/];
                        }
                    });
                });
            };
        /**
         * A function to flatten tree data
         * @param {?} data
         * @param {?=} parent
         * @return {?}
         */
        TreeGridService.prototype.getFlattenedTree = /**
         * A function to flatten tree data
         * @param {?} data
         * @param {?=} parent
         * @return {?}
         */
            function (data, parent) {
                var _this = this;
                // flatten the nodes at this level
                return data.reduce(function (previous, item, index) {
                    item.state = new TreeGridState(parent ? parent.state.level + 1 : 0, data.length, index + 1);
                    // Convert any child nodes
                    var /** @type {?} */ children = (item.children && item.expanded) ? _this.getFlattenedTree(item.children, item) : [];
                    // return the nodes in a flattened array
                    return __spread(previous, [item], children);
                }, []);
            };
        /**
         * Load any children dynamically
         * @param {?} item
         * @return {?}
         */
        TreeGridService.prototype.getChildren = /**
         * Load any children dynamically
         * @param {?} item
         * @return {?}
         */
            function (item) {
                return __awaiter(this, void 0, void 0, function () {
                    var _a;
                    return __generator(this, function (_b) {
                        switch (_b.label) {
                            case 0:
                                if (!(!item.children && this.loadChildren))
                                    return [3 /*break*/, 4];
                                item.state.loading$.next(true);
                                _b.label = 1;
                            case 1:
                                _b.trys.push([1, , 3, 4]);
                                _a = item;
                                return [4 /*yield*/, this.getNormalizedChildren(this.loadChildren(item))];
                            case 2:
                                _a.children = _b.sent();
                                return [3 /*break*/, 4];
                            case 3:
                                item.state.loading$.next(false);
                                return [7 /*endfinally*/];
                            case 4: return [2 /*return*/];
                        }
                    });
                });
            };
        /**
         * We want to support an array, a promise and an observable. This will return all types as a promise
         * @param {?} response
         * @return {?}
         */
        TreeGridService.prototype.getNormalizedChildren = /**
         * We want to support an array, a promise and an observable. This will return all types as a promise
         * @param {?} response
         * @return {?}
         */
            function (response) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                if (!(response instanceof Observable.Observable))
                                    return [3 /*break*/, 2];
                                return [4 /*yield*/, response.toPromise()];
                            case 1: return [2 /*return*/, _a.sent()];
                            case 2:
                                if (!(response instanceof Promise))
                                    return [3 /*break*/, 4];
                                return [4 /*yield*/, response];
                            case 3: return [2 /*return*/, _a.sent()];
                            case 4:
                                // if it is an array then make it an observable
                                return [2 /*return*/, response];
                        }
                    });
                });
            };
        /**
         * Insert the children into the flattened tree at the correct location
         * @param {?} parent
         * @return {?}
         */
        TreeGridService.prototype.insertChildren = /**
         * Insert the children into the flattened tree at the correct location
         * @param {?} parent
         * @return {?}
         */
            function (parent) {
                if (!parent.children) {
                    return;
                }
                var /** @type {?} */ row = this.rows$.getValue();
                var /** @type {?} */ index = row.indexOf(parent);
                if (index < 0) {
                    return;
                }
                // Skip duplicates - this could happen if an already expanded child has been inserted
                var /** @type {?} */ uniqueChildren = parent.children.filter(function (child) { return row.indexOf(child) === -1; });
                var /** @type {?} */ childRows = this.getFlattenedTree(uniqueChildren, parent);
                row.splice.apply(row, __spread([index + 1, 0], childRows));
            };
        /**
         * Remove all rows from the flattened tree
         * @param {?} parent
         * @return {?}
         */
        TreeGridService.prototype.removeChildren = /**
         * Remove all rows from the flattened tree
         * @param {?} parent
         * @return {?}
         */
            function (parent) {
                var /** @type {?} */ rows = this.rows$.getValue();
                var /** @type {?} */ index = rows.indexOf(parent);
                if (index < 0) {
                    return;
                }
                while (index + 1 < rows.length && rows[index + 1].state.level > parent.state.level) {
                    rows.splice(index + 1, 1);
                }
            };
        TreeGridService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        TreeGridService.ctorParameters = function () {
            return [
                { type: core.ChangeDetectorRef }
            ];
        };
        return TreeGridService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TreeGridRowDirective = (function () {
        function TreeGridRowDirective(_treeGridService) {
            var _this = this;
            this._treeGridService = _treeGridService;
            this.expandedChange = new core.EventEmitter();
            this.loading = false;
            this.isExpanded = false;
            this._expanded$ = new BehaviorSubject$1.BehaviorSubject(false);
            this._onDestroy = new Subject.Subject();
            this._expanded$.pipe(operators.skip(1), tick(), operators.distinctUntilChanged(), operators.takeUntil(this._onDestroy)).subscribe(function (expanded) {
                _this.expandedChange.emit(expanded);
                _this._treeGridService.setExpanded(_this.item, expanded);
                _this.isExpanded = expanded;
            });
        }
        Object.defineProperty(TreeGridRowDirective.prototype, "expanded", {
            get: /**
             * @return {?}
             */ function () {
                return this._expanded$.getValue();
            },
            set: /**
             * @param {?} expanded
             * @return {?}
             */ function (expanded) {
                this._expanded$.next(!!expanded);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        TreeGridRowDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                if (!this.item || !this.item.state) {
                    throw new Error('uxTreeGridRow should be configured with an object emitted by uxTreeGrid.rows.');
                }
                this.item.state.loading$.pipe(operators.takeUntil(this._onDestroy))
                    .subscribe(function (loading) { return _this.loading = loading; });
            };
        /**
         * @return {?}
         */
        TreeGridRowDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        /**
         * @param {?=} event
         * @return {?}
         */
        TreeGridRowDirective.prototype.collapse = /**
         * @param {?=} event
         * @return {?}
         */
            function (event) {
                this.expanded = false;
                if (event) {
                    event.preventDefault();
                }
            };
        /**
         * @param {?=} event
         * @return {?}
         */
        TreeGridRowDirective.prototype.expand = /**
         * @param {?=} event
         * @return {?}
         */
            function (event) {
                // take into account whether or not the item can expanded
                this.expanded = this.canExpand && true;
                if (event) {
                    event.preventDefault();
                }
            };
        /**
         * @return {?}
         */
        TreeGridRowDirective.prototype.toggle = /**
         * @return {?}
         */
            function () {
                this.expanded ? this.collapse() : this.expand();
            };
        TreeGridRowDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxTreeGridRow]',
                        exportAs: 'uxTreeGridRow',
                        host: {
                            '[class.treegrid-row]': 'true'
                        }
                    },] }
        ];
        /** @nocollapse */
        TreeGridRowDirective.ctorParameters = function () {
            return [
                { type: TreeGridService }
            ];
        };
        TreeGridRowDirective.propDecorators = {
            item: [{ type: core.Input, args: ['uxTreeGridRow',] }],
            canExpand: [{ type: core.Input }],
            expanded: [{ type: core.Input }],
            expandedChange: [{ type: core.Output }],
            loading: [{ type: core.HostBinding, args: ['class.treegrid-row-loading',] }],
            isExpanded: [{ type: core.HostBinding, args: ['class.treegrid-row-expanded',] }],
            collapse: [{ type: core.HostListener, args: ['keydown.ArrowLeft', ['$event'],] }],
            expand: [{ type: core.HostListener, args: ['keydown.ArrowRight', ['$event'],] }]
        };
        return TreeGridRowDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TreeGridIndentDirective = (function () {
        function TreeGridIndentDirective(_row) {
            this._row = _row;
        }
        Object.defineProperty(TreeGridIndentDirective.prototype, "indentation", {
            /** The padding value applied to each level */
            get: /**
             * The padding value applied to each level
             * @return {?}
             */ function () {
                return this._row && this._row.item ? 7 + (this._row.item.state.level * (this.uxTreeGridIndent || 25)) : 7;
            },
            enumerable: true,
            configurable: true
        });
        TreeGridIndentDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxTreeGridIndent]',
                    },] }
        ];
        /** @nocollapse */
        TreeGridIndentDirective.ctorParameters = function () {
            return [
                { type: TreeGridRowDirective }
            ];
        };
        TreeGridIndentDirective.propDecorators = {
            uxTreeGridIndent: [{ type: core.Input }],
            indentation: [{ type: core.HostBinding, args: ['style.padding-left.px',] }]
        };
        return TreeGridIndentDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TreeGridDirective = (function () {
        function TreeGridDirective(_treeGridService) {
            this._treeGridService = _treeGridService;
            this.rowsChange = new core.EventEmitter();
            this._onDestroy = new Subject.Subject();
        }
        Object.defineProperty(TreeGridDirective.prototype, "data", {
            set: /**
             * @param {?} data
             * @return {?}
             */ function (data) {
                this._treeGridService.data$.next(data);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TreeGridDirective.prototype, "loadChildren", {
            set: /**
             * @param {?} loadChildren
             * @return {?}
             */ function (loadChildren) {
                this._treeGridService.loadChildren = loadChildren;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        TreeGridDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this._treeGridService.rows$.pipe(operators.takeUntil(this._onDestroy)).subscribe(function (rows) { return _this.rowsChange.emit(rows); });
            };
        /**
         * @return {?}
         */
        TreeGridDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this._onDestroy.next();
                this._onDestroy.complete();
            };
        TreeGridDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[uxTreeGrid]',
                        providers: [TreeGridService],
                        host: {
                            class: 'treegrid'
                        }
                    },] }
        ];
        /** @nocollapse */
        TreeGridDirective.ctorParameters = function () {
            return [
                { type: TreeGridService }
            ];
        };
        TreeGridDirective.propDecorators = {
            data: [{ type: core.Input, args: ['uxTreeGrid',] }],
            loadChildren: [{ type: core.Input }],
            rows: [{ type: core.Input }],
            rowsChange: [{ type: core.Output }]
        };
        return TreeGridDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TreeGridModule = (function () {
        function TreeGridModule() {
        }
        TreeGridModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            TreeGridDirective,
                            TreeGridRowDirective,
                            TreeGridIndentDirective
                        ],
                        exports: [
                            TreeGridDirective,
                            TreeGridRowDirective,
                            TreeGridIndentDirective
                        ]
                    },] }
        ];
        return TreeGridModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ContactsNg1Component = (function (_super) {
        __extends(ContactsNg1Component, _super);
        function ContactsNg1Component(elementRef, injector) {
            var _this = _super.call(this, 'contactGroup', elementRef, injector) || this;
            _this.overflowClick = new core.EventEmitter();
            return _this;
        }
        ContactsNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'contact-group'
                    },] }
        ];
        /** @nocollapse */
        ContactsNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Injector }
            ];
        };
        ContactsNg1Component.propDecorators = {
            contacts: [{ type: core.Input }],
            organization: [{ type: core.Input }],
            size: [{ type: core.Input }],
            colors: [{ type: core.Input }],
            maxContacts: [{ type: core.Input }],
            overflowClick: [{ type: core.Output }]
        };
        return ContactsNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ExpandInputNg1Component = (function (_super) {
        __extends(ExpandInputNg1Component, _super);
        function ExpandInputNg1Component(elementRef, injector) {
            var _this = _super.call(this, 'expandInput', elementRef, injector) || this;
            _this.focus = new core.EventEmitter();
            return _this;
        }
        ExpandInputNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'expand-input'
                    },] }
        ];
        /** @nocollapse */
        ExpandInputNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Injector }
            ];
        };
        ExpandInputNg1Component.propDecorators = {
            elname: [{ type: core.Input }],
            placeHolder: [{ type: core.Input }],
            className: [{ type: core.Input }],
            clearTextIcon: [{ type: core.Input }],
            closeSearch: [{ type: core.Input }],
            expandAlways: [{ type: core.Input }],
            onEnter: [{ type: core.Input }],
            focus: [{ type: core.Output }]
        };
        return ExpandInputNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FloatingActionButtonNg1Component = (function (_super) {
        __extends(FloatingActionButtonNg1Component, _super);
        function FloatingActionButtonNg1Component(elementRef, injector) {
            var _this = _super.call(this, 'floatingActionButton', elementRef, injector) || this;
            _this.items = [];
            return _this;
        }
        FloatingActionButtonNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'floating-action-button'
                    },] }
        ];
        /** @nocollapse */
        FloatingActionButtonNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Injector }
            ];
        };
        FloatingActionButtonNg1Component.propDecorators = {
            items: [{ type: core.Input }],
            primary: [{ type: core.Input }],
            direction: [{ type: core.Input }],
            fabTooltip: [{ type: core.Input }],
            fabTooltipPlacement: [{ type: core.Input }]
        };
        return FloatingActionButtonNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var FlotNg1Component = (function (_super) {
        __extends(FlotNg1Component, _super);
        function FlotNg1Component(elementRef, injector) {
            var _this = _super.call(this, 'uxFlotNg1', elementRef, injector) || this;
            _this.onPlotClick = new core.EventEmitter();
            _this.onPlotHover = new core.EventEmitter();
            return _this;
        }
        FlotNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'flot'
                    },] }
        ];
        /** @nocollapse */
        FlotNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Injector }
            ];
        };
        FlotNg1Component.propDecorators = {
            dataset: [{ type: core.Input }],
            options: [{ type: core.Input }],
            callback: [{ type: core.Input }],
            donutLabels: [{ type: core.Input }],
            onPlotClick: [{ type: core.Output }],
            onPlotHover: [{ type: core.Output }]
        };
        return FlotNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var GridNg1Component = (function (_super) {
        __extends(GridNg1Component, _super);
        function GridNg1Component(elementRef, injector) {
            var _this = _super.call(this, 'grid', elementRef, injector) || this;
            _this.source = [];
            _this.columns = [];
            return _this;
        }
        GridNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'grid'
                    },] }
        ];
        /** @nocollapse */
        GridNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Injector }
            ];
        };
        GridNg1Component.propDecorators = {
            source: [{ type: core.Input }],
            columns: [{ type: core.Input }],
            options: [{ type: core.Input }],
            events: [{ type: core.Input }],
            plugins: [{ type: core.Input }]
        };
        return GridNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var HierarchyBarNg1Component = (function (_super) {
        __extends(HierarchyBarNg1Component, _super);
        function HierarchyBarNg1Component(elementRef, injector) {
            return _super.call(this, 'hierarchyBar', elementRef, injector) || this;
        }
        HierarchyBarNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'hierarchy-bar'
                    },] }
        ];
        /** @nocollapse */
        HierarchyBarNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Injector }
            ];
        };
        HierarchyBarNg1Component.propDecorators = {
            data: [{ type: core.Input }],
            options: [{ type: core.Input }],
            selectNode: [{ type: core.Input }],
            containerClass: [{ type: core.Input }]
        };
        return HierarchyBarNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var MarqueeWizardNg1Component = (function (_super) {
        __extends(MarqueeWizardNg1Component, _super);
        function MarqueeWizardNg1Component(elementRef, injector) {
            var _this = _super.call(this, 'marqueeWizard', elementRef, injector) || this;
            _this.wizardStepsChange = new core.EventEmitter();
            return _this;
        }
        MarqueeWizardNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'marquee-wizard'
                    },] }
        ];
        /** @nocollapse */
        MarqueeWizardNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Injector }
            ];
        };
        MarqueeWizardNg1Component.propDecorators = {
            wizardIcon: [{ type: core.Input }],
            wizardSteps: [{ type: core.Input }],
            buttonOptions: [{ type: core.Input }],
            onChanging: [{ type: core.Input }],
            onFinished: [{ type: core.Input }],
            onFinishing: [{ type: core.Input }],
            onCanceled: [{ type: core.Input }],
            isVisited: [{ type: core.Input }],
            sideInfo: [{ type: core.Input }],
            wizardStepsChange: [{ type: core.Output }]
        };
        return MarqueeWizardNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var NestedDonutNg1Component = (function (_super) {
        __extends(NestedDonutNg1Component, _super);
        function NestedDonutNg1Component(elementRef, injector) {
            return _super.call(this, 'uxNestedDonutNg1', elementRef, injector) || this;
        }
        NestedDonutNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'nested-donut'
                    },] }
        ];
        /** @nocollapse */
        NestedDonutNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Injector }
            ];
        };
        NestedDonutNg1Component.propDecorators = {
            dataset: [{ type: core.Input }],
            options: [{ type: core.Input }]
        };
        return NestedDonutNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var OrganizationChartNg1Component = (function (_super) {
        __extends(OrganizationChartNg1Component, _super);
        function OrganizationChartNg1Component(elementRef, injector) {
            var _this = _super.call(this, 'uxOrganizationChartNg1', elementRef, injector) || this;
            _this.dataChange = new core.EventEmitter();
            _this.optionsChange = new core.EventEmitter();
            return _this;
        }
        OrganizationChartNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'organization-chart'
                    },] }
        ];
        /** @nocollapse */
        OrganizationChartNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Injector }
            ];
        };
        OrganizationChartNg1Component.propDecorators = {
            data: [{ type: core.Input }],
            options: [{ type: core.Input }],
            dataChange: [{ type: core.Output }],
            optionsChange: [{ type: core.Output }]
        };
        return OrganizationChartNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PartitionMapNg1Component = (function (_super) {
        __extends(PartitionMapNg1Component, _super);
        function PartitionMapNg1Component(elementRef, injector) {
            return _super.call(this, 'uxPartitionMapNg1', elementRef, injector) || this;
        }
        PartitionMapNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'partition-map'
                    },] }
        ];
        /** @nocollapse */
        PartitionMapNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Injector }
            ];
        };
        PartitionMapNg1Component.propDecorators = {
            chartData: [{ type: core.Input }],
            chartOptions: [{ type: core.Input }],
            chartLoading: [{ type: core.Input }]
        };
        return PartitionMapNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PeityBarChartNg1Component = (function (_super) {
        __extends(PeityBarChartNg1Component, _super);
        function PeityBarChartNg1Component(elementRef, injector) {
            return _super.call(this, 'uxPeityBarChartNg1', elementRef, injector) || this;
        }
        PeityBarChartNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'bar-chart'
                    },] }
        ];
        /** @nocollapse */
        PeityBarChartNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Injector }
            ];
        };
        PeityBarChartNg1Component.propDecorators = {
            data: [{ type: core.Input }],
            options: [{ type: core.Input }]
        };
        return PeityBarChartNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PeityLineChartNg1Component = (function (_super) {
        __extends(PeityLineChartNg1Component, _super);
        function PeityLineChartNg1Component(elementRef, injector) {
            return _super.call(this, 'uxPeityLineChartNg1', elementRef, injector) || this;
        }
        PeityLineChartNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'line-chart'
                    },] }
        ];
        /** @nocollapse */
        PeityLineChartNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Injector }
            ];
        };
        PeityLineChartNg1Component.propDecorators = {
            data: [{ type: core.Input }],
            options: [{ type: core.Input }]
        };
        return PeityLineChartNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PeityPieChartNg1Component = (function (_super) {
        __extends(PeityPieChartNg1Component, _super);
        function PeityPieChartNg1Component(elementRef, injector) {
            return _super.call(this, 'uxPeityPieChartNg1', elementRef, injector) || this;
        }
        PeityPieChartNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'pie-chart'
                    },] }
        ];
        /** @nocollapse */
        PeityPieChartNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Injector }
            ];
        };
        PeityPieChartNg1Component.propDecorators = {
            data: [{ type: core.Input }],
            options: [{ type: core.Input }]
        };
        return PeityPieChartNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PeityUpdatingLineChartNg1Component = (function (_super) {
        __extends(PeityUpdatingLineChartNg1Component, _super);
        function PeityUpdatingLineChartNg1Component(elementRef, injector) {
            return _super.call(this, 'uxPeityUpdatingLineChartNg1', elementRef, injector) || this;
        }
        PeityUpdatingLineChartNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'updating-line-chart'
                    },] }
        ];
        /** @nocollapse */
        PeityUpdatingLineChartNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Injector }
            ];
        };
        PeityUpdatingLineChartNg1Component.propDecorators = {
            data: [{ type: core.Input }],
            options: [{ type: core.Input }],
            method: [{ type: core.Input }],
            updateinterval: [{ type: core.Input }]
        };
        return PeityUpdatingLineChartNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SankeyNg1Component = (function (_super) {
        __extends(SankeyNg1Component, _super);
        function SankeyNg1Component(elementRef, injector) {
            return _super.call(this, 'uxSankeyNg1', elementRef, injector) || this;
        }
        SankeyNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'sankey'
                    },] }
        ];
        /** @nocollapse */
        SankeyNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Injector }
            ];
        };
        SankeyNg1Component.propDecorators = {
            chartSize: [{ type: core.Input }],
            chartData: [{ type: core.Input }],
            options: [{ type: core.Input }],
            click: [{ type: core.Input }]
        };
        return SankeyNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SearchToolbarNg1Component = (function (_super) {
        __extends(SearchToolbarNg1Component, _super);
        function SearchToolbarNg1Component(elementRef, injector) {
            return _super.call(this, 'searchToolbar', elementRef, injector) || this;
        }
        SearchToolbarNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'search-toolbar'
                    },] }
        ];
        /** @nocollapse */
        SearchToolbarNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Injector }
            ];
        };
        SearchToolbarNg1Component.propDecorators = {
            searchTypeahead: [{ type: core.Input }],
            placeHolder: [{ type: core.Input }],
            closeSearch: [{ type: core.Input }],
            onSearch: [{ type: core.Input }],
            onFocus: [{ type: core.Input }]
        };
        return SearchToolbarNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SelectTableNg1Component = (function (_super) {
        __extends(SelectTableNg1Component, _super);
        function SelectTableNg1Component(elementRef, injector) {
            var _this = _super.call(this, 'selectTable', elementRef, injector) || this;
            _this.selectedChange = new core.EventEmitter();
            return _this;
        }
        SelectTableNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'select-table'
                    },] }
        ];
        /** @nocollapse */
        SelectTableNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Injector }
            ];
        };
        SelectTableNg1Component.propDecorators = {
            values: [{ type: core.Input }],
            multipleSelect: [{ type: core.Input }],
            selectKey: [{ type: core.Input }],
            selected: [{ type: core.Input }],
            searchText: [{ type: core.Input }],
            tableHeight: [{ type: core.Input }],
            template: [{ type: core.Input }],
            templateUrl: [{ type: core.Input }],
            selectHiddenItems: [{ type: core.Input }],
            selectedChange: [{ type: core.Output }]
        };
        return SelectTableNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ SLIDER_CHART_VALUE_ACCESSOR = {
        provide: forms.NG_VALUE_ACCESSOR,
        useExisting: core.forwardRef(function () { return SliderChartNg1Component; }),
        multi: true
    };
    var SliderChartNg1Component = (function (_super) {
        __extends(SliderChartNg1Component, _super);
        function SliderChartNg1Component(elementRef, injector) {
            var _this = _super.call(this, 'sliderChart', elementRef, injector) || this;
            _this.ngModelChange = new core.EventEmitter();
            return _this;
        }
        /**
         * @param {?} obj
         * @return {?}
         */
        SliderChartNg1Component.prototype.writeValue = /**
         * @param {?} obj
         * @return {?}
         */
            function (obj) { };
        /**
         * @param {?} fn
         * @return {?}
         */
        SliderChartNg1Component.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) { };
        /**
         * @param {?} fn
         * @return {?}
         */
        SliderChartNg1Component.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
            function (fn) { };
        SliderChartNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'slider-chart',
                        providers: [SLIDER_CHART_VALUE_ACCESSOR]
                    },] }
        ];
        /** @nocollapse */
        SliderChartNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Injector }
            ];
        };
        SliderChartNg1Component.propDecorators = {
            sliderOptions: [{ type: core.Input }],
            ngModel: [{ type: core.Input }],
            chartOptions: [{ type: core.Input }],
            chartData: [{ type: core.Input }],
            ngModelChange: [{ type: core.Output }]
        };
        return SliderChartNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SocialChartNg1Component = (function (_super) {
        __extends(SocialChartNg1Component, _super);
        function SocialChartNg1Component(elementRef, injector) {
            return _super.call(this, 'uxSocialChartNg1', elementRef, injector) || this;
        }
        SocialChartNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'social-chart'
                    },] }
        ];
        /** @nocollapse */
        SocialChartNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Injector }
            ];
        };
        SocialChartNg1Component.propDecorators = {
            data: [{ type: core.Input }],
            options: [{ type: core.Input }],
            width: [{ type: core.Input }],
            height: [{ type: core.Input }],
            api: [{ type: core.Input }],
            communities: [{ type: core.Input }],
            detailStyle: [{ type: core.Input }],
            popoverStyle: [{ type: core.Input }],
            nodeDetail: [{ type: core.Input }],
            edgeDetail: [{ type: core.Input }],
            nodePopover: [{ type: core.Input }],
            edgePopover: [{ type: core.Input }],
            forceAtlasDuration: [{ type: core.Input }],
            nodeSizeAttribute: [{ type: core.Input }],
            startMaximized: [{ type: core.Input }],
            startMaximised: [{ type: core.Input }],
            showMaximizeControl: [{ type: core.Input }],
            showMaximiseControl: [{ type: core.Input }],
            socialChartContainer: [{ type: core.Input }],
            fullscreenButtonPosition: [{ type: core.Input }],
            localStrings: [{ type: core.Input }],
            chartTitle: [{ type: core.Input }],
            titleDisplayTime: [{ type: core.Input }],
            edgeWeightInfluence: [{ type: core.Input }],
            minLabels: [{ type: core.Input }]
        };
        return SocialChartNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SortDirectionToggleNg1Component = (function (_super) {
        __extends(SortDirectionToggleNg1Component, _super);
        function SortDirectionToggleNg1Component(elementRef, injector) {
            return _super.call(this, 'sortDirectionToggle', elementRef, injector) || this;
        }
        SortDirectionToggleNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'sort-direction-toggle'
                    },] }
        ];
        /** @nocollapse */
        SortDirectionToggleNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Injector }
            ];
        };
        SortDirectionToggleNg1Component.propDecorators = {
            label: [{ type: core.Input }],
            sorters: [{ type: core.Input }],
            descend: [{ type: core.Input }]
        };
        return SortDirectionToggleNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TreeGridNg1Component = (function (_super) {
        __extends(TreeGridNg1Component, _super);
        function TreeGridNg1Component(elementRef, injector) {
            var _this = _super.call(this, 'treegrid', elementRef, injector) || this;
            _this.optionsChange = new core.EventEmitter();
            _this.selectedChange = new core.EventEmitter();
            _this.currentRowChange = new core.EventEmitter();
            _this.treeDataChange = new core.EventEmitter();
            return _this;
        }
        TreeGridNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'treegrid'
                    },] }
        ];
        /** @nocollapse */
        TreeGridNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Injector }
            ];
        };
        TreeGridNg1Component.propDecorators = {
            data: [{ type: core.Input }],
            columns: [{ type: core.Input }],
            treeData: [{ type: core.Input }],
            selected: [{ type: core.Input }],
            currentRow: [{ type: core.Input }],
            options: [{ type: core.Input }],
            optionsChange: [{ type: core.Output }],
            selectedChange: [{ type: core.Output }],
            currentRowChange: [{ type: core.Output }],
            treeDataChange: [{ type: core.Output }]
        };
        return TreeGridNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ThumbnailNg1Component = (function (_super) {
        __extends(ThumbnailNg1Component, _super);
        function ThumbnailNg1Component(elementRef, injector) {
            return _super.call(this, 'thumbnail', elementRef, injector) || this;
        }
        ThumbnailNg1Component.decorators = [
            { type: core.Directive, args: [{
                        selector: 'thumbnail'
                    },] }
        ];
        /** @nocollapse */
        ThumbnailNg1Component.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: core.Injector }
            ];
        };
        ThumbnailNg1Component.propDecorators = {
            url: [{ type: core.Input }],
            show: [{ type: core.Input }],
            width: [{ type: core.Input }],
            height: [{ type: core.Input }]
        };
        return ThumbnailNg1Component;
    }(_static.UpgradeComponent));

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var NavigationMenuService = (function () {
        function NavigationMenuService(_navigationMenuService) {
            this._navigationMenuService = _navigationMenuService;
        }
        /**
         * @return {?}
         */
        NavigationMenuService.prototype.show = /**
         * @return {?}
         */
            function () {
                this._navigationMenuService.show();
            };
        /**
         * @return {?}
         */
        NavigationMenuService.prototype.hide = /**
         * @return {?}
         */
            function () {
                this._navigationMenuService.hide();
            };
        /**
         * @return {?}
         */
        NavigationMenuService.prototype.visible = /**
         * @return {?}
         */
            function () {
                return this._navigationMenuService.visible();
            };
        /**
         * @return {?}
         */
        NavigationMenuService.prototype.collapseAtWidth = /**
         * @return {?}
         */
            function () {
                return this._navigationMenuService.collapseAtWidth();
            };
        /**
         * @param {?} width
         * @return {?}
         */
        NavigationMenuService.prototype.setCollapseAtWidth = /**
         * @param {?} width
         * @return {?}
         */
            function (width) {
                this._navigationMenuService.setCollapseAtWidth(width);
            };
        /**
         * @return {?}
         */
        NavigationMenuService.prototype.setDefaultCollapseAtWidth = /**
         * @return {?}
         */
            function () {
                this._navigationMenuService.setDefaultCollapseAtWidth();
            };
        NavigationMenuService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        NavigationMenuService.ctorParameters = function () {
            return [
                { type: undefined, decorators: [{ type: core.Inject, args: ['$navigationMenu',] }] }
            ];
        };
        return NavigationMenuService;
    }());
    /**
     * @param {?} injector
     * @return {?}
     */
    function navigationMenuServiceFactory(injector) {
        return injector.get('$navigationMenu');
    }
    var /** @type {?} */ navigationMenuServiceProvider = {
        provide: '$navigationMenu',
        useFactory: navigationMenuServiceFactory,
        deps: ['$injector']
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PdfService = (function () {
        function PdfService(_pdfService) {
            this._pdfService = _pdfService;
        }
        /**
         * @param {?} columns
         * @param {?} rows
         * @param {?=} options
         * @return {?}
         */
        PdfService.prototype.createTable = /**
         * @param {?} columns
         * @param {?} rows
         * @param {?=} options
         * @return {?}
         */
            function (columns, rows, options) {
                if (options === void 0) {
                    options = {};
                }
                return this._pdfService.createTable(columns, rows, options);
            };
        PdfService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        PdfService.ctorParameters = function () {
            return [
                { type: undefined, decorators: [{ type: core.Inject, args: ['$pdf',] }] }
            ];
        };
        return PdfService;
    }());
    /**
     * @param {?} injector
     * @return {?}
     */
    function pdfServiceFactory(injector) {
        return injector.get('$pdf');
    }
    var /** @type {?} */ pdfServiceProvider = {
        provide: '$pdf',
        useFactory: pdfServiceFactory,
        deps: ['$injector']
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var TimeAgoService = (function () {
        function TimeAgoService(_timeAgoService) {
            this._timeAgoService = _timeAgoService;
        }
        /**
         * @param {?} strings
         * @return {?}
         */
        TimeAgoService.prototype.setStrings = /**
         * @param {?} strings
         * @return {?}
         */
            function (strings) {
                this._timeAgoService.setStrings(strings);
            };
        /**
         * @param {?} past
         * @param {?} present
         * @return {?}
         */
        TimeAgoService.prototype.timeSince = /**
         * @param {?} past
         * @param {?} present
         * @return {?}
         */
            function (past, present) {
                return this._timeAgoService.timeSince(past, present);
            };
        /**
         * @param {?} moment
         * @return {?}
         */
        TimeAgoService.prototype.timeSinceNow = /**
         * @param {?} moment
         * @return {?}
         */
            function (moment) {
                return this._timeAgoService.timeSinceNow(moment);
            };
        TimeAgoService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        TimeAgoService.ctorParameters = function () {
            return [
                { type: undefined, decorators: [{ type: core.Inject, args: ['timeAgoService',] }] }
            ];
        };
        return TimeAgoService;
    }());
    /**
     * @param {?} injector
     * @return {?}
     */
    function timeAgoServiceFactory(injector) {
        return injector.get('timeAgoService');
    }
    var /** @type {?} */ timeAgoServiceProvider = {
        provide: 'timeAgoService',
        useFactory: timeAgoServiceFactory,
        deps: ['$injector']
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var /** @type {?} */ declarations = [
        ContactsNg1Component,
        ExpandInputNg1Component,
        FloatingActionButtonNg1Component,
        FlotNg1Component,
        GridNg1Component,
        HierarchyBarNg1Component,
        MarqueeWizardNg1Component,
        NestedDonutNg1Component,
        OrganizationChartNg1Component,
        PartitionMapNg1Component,
        PeityBarChartNg1Component,
        PeityLineChartNg1Component,
        PeityPieChartNg1Component,
        PeityUpdatingLineChartNg1Component,
        SankeyNg1Component,
        SearchToolbarNg1Component,
        SelectTableNg1Component,
        SliderChartNg1Component,
        SocialChartNg1Component,
        SortDirectionToggleNg1Component,
        TreeGridNg1Component,
        ThumbnailNg1Component,
    ];
    var HybridModule = (function () {
        function HybridModule() {
        }
        HybridModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [],
                        exports: declarations,
                        declarations: declarations,
                        providers: [
                            navigationMenuServiceProvider,
                            pdfServiceProvider,
                            timeAgoServiceProvider,
                            TimeAgoService,
                            PdfService,
                            NavigationMenuService,
                        ],
                    },] }
        ];
        return HybridModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var StringFilterPipe = (function () {
        function StringFilterPipe() {
        }
        /**
         * @param {?} items
         * @param {?} value
         * @return {?}
         */
        StringFilterPipe.prototype.transform = /**
         * @param {?} items
         * @param {?} value
         * @return {?}
         */
            function (items, value) {
                if (!items) {
                    return [];
                }
                return items.filter(function (it) { return it.toLowerCase().indexOf(value.toLowerCase()) >= 0; });
            };
        StringFilterPipe.decorators = [
            { type: core.Pipe, args: [{
                        name: 'stringFilter'
                    },] },
            { type: core.Injectable }
        ];
        return StringFilterPipe;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var StringFilterModule = (function () {
        function StringFilterModule() {
        }
        StringFilterModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [StringFilterPipe],
                        declarations: [StringFilterPipe]
                    },] }
        ];
        return StringFilterModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var CookieAdapter = (function () {
        function CookieAdapter() {
        }
        /**
         * @param {?} key
         * @return {?}
         */
        CookieAdapter.prototype.getItem = /**
         * @param {?} key
         * @return {?}
         */
            function (key) {
                if (document.cookie) {
                    // get all the cookies for this site
                    var /** @type {?} */ cookies = document.cookie.split(';');
                    // process the cookies into a from we can easily manage
                    var /** @type {?} */ match = cookies
                        .map(function (cookie) { return ({ key: cookie.split('=')[0].trim(), value: cookie.split('=')[1].trim() }); })
                        .find(function (cookie) { return cookie.key === key; });
                    return match ? match.value : null;
                }
                return null;
            };
        /**
         * @param {?} key
         * @param {?} value
         * @return {?}
         */
        CookieAdapter.prototype.setItem = /**
         * @param {?} key
         * @param {?} value
         * @return {?}
         */
            function (key, value) {
                document.cookie = key + "=" + value + "; path=/";
            };
        /**
         * @param {?} key
         * @return {?}
         */
        CookieAdapter.prototype.removeItem = /**
         * @param {?} key
         * @return {?}
         */
            function (key) {
                document.cookie.split(';').forEach(function (cookie) {
                    var /** @type {?} */ eqPos = cookie.indexOf('=');
                    var /** @type {?} */ name = eqPos > -1 ? cookie.substr(0, eqPos).trim() : cookie;
                    if (name === key) {
                        document.cookie = cookie.trim().replace(/=.*/, "=;expires=" + new Date().toUTCString() + ";path=/");
                    }
                });
            };
        /**
         * @return {?}
         */
        CookieAdapter.prototype.clear = /**
         * @return {?}
         */
            function () {
                var _this = this;
                // call remove item on each cookie
                document.cookie.split(';').map(function (cookie) { return cookie.split('=')[0].trim(); })
                    .forEach(function (cookie) { return _this.removeItem(cookie); });
            };
        /**
         * @return {?}
         */
        CookieAdapter.prototype.getSupported = /**
         * @return {?}
         */
            function () {
                // cookies are supported in all browsers
                return this;
            };
        return CookieAdapter;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var LocalStorageAdapter = (function () {
        function LocalStorageAdapter() {
        }
        /**
         * @param {?} key
         * @return {?}
         */
        LocalStorageAdapter.prototype.getItem = /**
         * @param {?} key
         * @return {?}
         */
            function (key) {
                return localStorage.getItem(key);
            };
        /**
         * @param {?} key
         * @param {?} value
         * @return {?}
         */
        LocalStorageAdapter.prototype.setItem = /**
         * @param {?} key
         * @param {?} value
         * @return {?}
         */
            function (key, value) {
                localStorage.setItem(key, value);
            };
        /**
         * @param {?} key
         * @return {?}
         */
        LocalStorageAdapter.prototype.removeItem = /**
         * @param {?} key
         * @return {?}
         */
            function (key) {
                localStorage.removeItem(key);
            };
        /**
         * @return {?}
         */
        LocalStorageAdapter.prototype.clear = /**
         * @return {?}
         */
            function () {
                localStorage.clear();
            };
        /**
         * @return {?}
         */
        LocalStorageAdapter.prototype.getSupported = /**
         * @return {?}
         */
            function () {
                // if local storage variable does not exist fall back to cookies
                if (!localStorage) {
                    return new CookieAdapter();
                }
                // try to make a test save to local storage to see if there are any exceptions
                try {
                    localStorage.setItem('ux-persistent-data-service', 'ux-persistent-data-service');
                    localStorage.removeItem('ux-persistent-data-service');
                    return this;
                }
                catch (err) {
                    return new CookieAdapter();
                }
            };
        return LocalStorageAdapter;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var SessionStorageAdapter = (function () {
        function SessionStorageAdapter() {
        }
        /**
         * @param {?} key
         * @return {?}
         */
        SessionStorageAdapter.prototype.getItem = /**
         * @param {?} key
         * @return {?}
         */
            function (key) {
                return sessionStorage.getItem(key);
            };
        /**
         * @param {?} key
         * @param {?} value
         * @return {?}
         */
        SessionStorageAdapter.prototype.setItem = /**
         * @param {?} key
         * @param {?} value
         * @return {?}
         */
            function (key, value) {
                sessionStorage.setItem(key, value);
            };
        /**
         * @param {?} key
         * @return {?}
         */
        SessionStorageAdapter.prototype.removeItem = /**
         * @param {?} key
         * @return {?}
         */
            function (key) {
                sessionStorage.removeItem(key);
            };
        /**
         * @return {?}
         */
        SessionStorageAdapter.prototype.clear = /**
         * @return {?}
         */
            function () {
                sessionStorage.clear();
            };
        /**
         * @return {?}
         */
        SessionStorageAdapter.prototype.getSupported = /**
         * @return {?}
         */
            function () {
                // if local storage variable does not exist fall back to cookies
                if (!sessionStorage) {
                    return new CookieAdapter();
                }
                // try to make a test save to local storage to see if there are any exceptions
                try {
                    sessionStorage.setItem('ux-persistent-data-service', 'ux-persistent-data-service');
                    sessionStorage.removeItem('ux-persistent-data-service');
                    return this;
                }
                catch (err) {
                    return new CookieAdapter();
                }
            };
        return SessionStorageAdapter;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PersistentDataService = (function () {
        function PersistentDataService() {
        }
        /**
         * Save the item in some form of persistent storage
         */
        /**
         * Save the item in some form of persistent storage
         * @param {?} key
         * @param {?} value
         * @param {?=} type
         * @return {?}
         */
        PersistentDataService.prototype.setItem = /**
         * Save the item in some form of persistent storage
         * @param {?} key
         * @param {?} value
         * @param {?=} type
         * @return {?}
         */
            function (key, value, type) {
                if (type === void 0) {
                    type = PersistentDataStorageType.LocalStorage;
                }
                this.getAdapter(type).setItem(key, value);
            };
        /**
         * Get a stored value from persistent storage
         */
        /**
         * Get a stored value from persistent storage
         * @param {?} key
         * @param {?=} type
         * @return {?}
         */
        PersistentDataService.prototype.getItem = /**
         * Get a stored value from persistent storage
         * @param {?} key
         * @param {?=} type
         * @return {?}
         */
            function (key, type) {
                if (type === void 0) {
                    type = PersistentDataStorageType.LocalStorage;
                }
                return this.getAdapter(type).getItem(key);
            };
        /**
         * Remove a stored value from persistent storage
         */
        /**
         * Remove a stored value from persistent storage
         * @param {?} key
         * @param {?=} type
         * @return {?}
         */
        PersistentDataService.prototype.removeItem = /**
         * Remove a stored value from persistent storage
         * @param {?} key
         * @param {?=} type
         * @return {?}
         */
            function (key, type) {
                if (type === void 0) {
                    type = PersistentDataStorageType.LocalStorage;
                }
                this.getAdapter(type).removeItem(key);
            };
        /**
         * Remove a stored value from persistent storage
         */
        /**
         * Remove a stored value from persistent storage
         * @param {?=} type
         * @return {?}
         */
        PersistentDataService.prototype.clear = /**
         * Remove a stored value from persistent storage
         * @param {?=} type
         * @return {?}
         */
            function (type) {
                if (type === void 0) {
                    type = PersistentDataStorageType.LocalStorage;
                }
                this.getAdapter(type).clear();
            };
        /**
         * Return the appropriate adapter based on the type requested
         * @param {?} type
         * @return {?}
         */
        PersistentDataService.prototype.getAdapter = /**
         * Return the appropriate adapter based on the type requested
         * @param {?} type
         * @return {?}
         */
            function (type) {
                switch (type) {
                    case PersistentDataStorageType.Cookie:
                        return new CookieAdapter();
                    case PersistentDataStorageType.LocalStorage:
                        var /** @type {?} */ localStorageAdapter = new LocalStorageAdapter();
                        return localStorageAdapter.getSupported();
                    case PersistentDataStorageType.SessionStorage:
                        var /** @type {?} */ sessionStorageAdapter = new SessionStorageAdapter();
                        return sessionStorageAdapter.getSupported();
                }
            };
        PersistentDataService.decorators = [
            { type: core.Injectable }
        ];
        return PersistentDataService;
    }());
    /** @enum {number} */
    var PersistentDataStorageType = {
        LocalStorage: 0,
        Cookie: 1,
        SessionStorage: 2,
    };
    PersistentDataStorageType[PersistentDataStorageType.LocalStorage] = "LocalStorage";
    PersistentDataStorageType[PersistentDataStorageType.Cookie] = "Cookie";
    PersistentDataStorageType[PersistentDataStorageType.SessionStorage] = "SessionStorage";

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var PersistentDataModule = (function () {
        function PersistentDataModule() {
        }
        PersistentDataModule.decorators = [
            { type: core.NgModule, args: [{
                        providers: [PersistentDataService],
                    },] }
        ];
        return PersistentDataModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * @abstract
     */
    var /**
     * @abstract
     */ StorageAdapter = (function () {
        function StorageAdapter() {
        }
        return StorageAdapter;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    exports.AccordionPanelHeadingDirective = AccordionPanelHeadingDirective;
    exports.AccordionPanelComponent = AccordionPanelComponent;
    exports.AccordionComponent = AccordionComponent;
    exports.AccordionModule = AccordionModule;
    exports.AccordionService = AccordionService;
    exports.BreadcrumbsComponent = BreadcrumbsComponent;
    exports.BreadcrumbsModule = BreadcrumbsModule;
    exports.CardTabsModule = CardTabsModule;
    exports.CardTabsService = CardTabsService;
    exports.CardTabsetComponent = CardTabsetComponent;
    exports.CardTabComponent = CardTabComponent;
    exports.CardTabContentDirective = CardTabContentDirective;
    exports.CheckboxModule = CheckboxModule;
    exports.CHECKBOX_VALUE_ACCESSOR = CHECKBOX_VALUE_ACCESSOR;
    exports.CheckboxComponent = CheckboxComponent;
    exports.ColorPickerComponent = ColorPickerComponent;
    exports.ColorPickerColor = ColorPickerColor;
    exports.ColorPickerModule = ColorPickerModule;
    exports.ColumnSortingModule = ColumnSortingModule;
    exports.ColumnSortingComponent = ColumnSortingComponent;
    exports.ColumnSortingDirective = ColumnSortingDirective;
    exports.ColumnSortingState = ColumnSortingState;
    exports.ConduitSubject = ConduitSubject;
    exports.ConduitZoneComponent = ConduitZoneComponent;
    exports.ConduitZone = ConduitZone;
    exports.ConduitComponent = ConduitComponent;
    exports.CONDUITS = CONDUITS;
    exports.Conduit = Conduit;
    exports.defaultConduitProps = defaultConduitProps;
    exports.DashboardModule = DashboardModule;
    exports.DashboardComponent = DashboardComponent;
    exports.DashboardService = DashboardService;
    exports.defaultOptions = defaultOptions;
    exports.ActionDirection = ActionDirection;
    exports.Rounding = Rounding;
    exports.DashboardDragHandleDirective = DashboardDragHandleDirective;
    exports.DashboardWidgetComponent = DashboardWidgetComponent;
    exports.DateTimePickerModule = DateTimePickerModule;
    exports.DateTimePickerComponent = DateTimePickerComponent;
    exports.DateTimePickerService = DateTimePickerService;
    exports.DatePickerMode = DatePickerMode;
    exports.ModeDirection = ModeDirection;
    exports.DatePickerHeaderEvent = DatePickerHeaderEvent;
    exports.DateTimePickerConfig = DateTimePickerConfig;
    exports.EboxModule = EboxModule;
    exports.EboxComponent = EboxComponent;
    exports.EboxHeaderDirective = EboxHeaderDirective;
    exports.EboxContentDirective = EboxContentDirective;
    exports.FacetsModule = FacetsModule;
    exports.FacetContainerComponent = FacetContainerComponent;
    exports.FacetSelect = FacetSelect;
    exports.FacetDeselect = FacetDeselect;
    exports.FacetDeselectAll = FacetDeselectAll;
    exports.FacetHeaderComponent = FacetHeaderComponent;
    exports.FacetBaseComponent = FacetBaseComponent;
    exports.FacetCheckListComponent = FacetCheckListComponent;
    exports.FacetTypeaheadListComponent = FacetTypeaheadListComponent;
    exports.FacetTypeaheadHighlight = FacetTypeaheadHighlight;
    exports.Facet = Facet;
    exports.FilterModule = FilterModule;
    exports.FilterContainerComponent = FilterContainerComponent;
    exports.FilterAddEvent = FilterAddEvent;
    exports.FilterRemoveEvent = FilterRemoveEvent;
    exports.FilterRemoveAllEvent = FilterRemoveAllEvent;
    exports.FilterBaseComponent = FilterBaseComponent;
    exports.FilterDropdownComponent = FilterDropdownComponent;
    exports.FilterDynamicComponent = FilterDynamicComponent;
    exports.FilterTypeaheadHighlight = FilterTypeaheadHighlight;
    exports.FlippableCardModule = FlippableCardModule;
    exports.FlippableCardComponent = FlippableCardComponent;
    exports.FlippableCardFrontDirective = FlippableCardFrontDirective;
    exports.FlippableCardBackDirective = FlippableCardBackDirective;
    exports.FloatingActionButtonsModule = FloatingActionButtonsModule;
    exports.FloatingActionButtonsComponent = FloatingActionButtonsComponent;
    exports.FloatingActionButtonComponent = FloatingActionButtonComponent;
    exports.HierarchyBarModule = HierarchyBarModule;
    exports.HierarchyBarService = HierarchyBarService;
    exports.HierarchyBarComponent = HierarchyBarComponent;
    exports.ItemDisplayPanelModule = ItemDisplayPanelModule;
    exports.ItemDisplayPanelContentDirective = ItemDisplayPanelContentDirective;
    exports.ItemDisplayPanelFooterDirective = ItemDisplayPanelFooterDirective;
    exports.ItemDisplayPanelComponent = ItemDisplayPanelComponent;
    exports.MarqueeWizardStepComponent = MarqueeWizardStepComponent;
    exports.MarqueeWizardComponent = MarqueeWizardComponent;
    exports.MarqueeWizardModule = MarqueeWizardModule;
    exports.MediaPlayerBaseExtensionDirective = MediaPlayerBaseExtensionDirective;
    exports.MediaPlayerControlsExtensionComponent = MediaPlayerControlsExtensionComponent;
    exports.MediaPlayerCustomControlDirective = MediaPlayerCustomControlDirective;
    exports.MediaPlayerTimelineExtensionComponent = MediaPlayerTimelineExtensionComponent;
    exports.MediaPlayerComponent = MediaPlayerComponent;
    exports.MediaPlayerModule = MediaPlayerModule;
    exports.NavigationModule = NavigationModule;
    exports.NavigationComponent = NavigationComponent;
    exports.NavigationService = NavigationService;
    exports.NavigationItemComponent = NavigationItemComponent;
    exports.NotificationModule = NotificationModule;
    exports.NotificationService = NotificationService;
    exports.NotificationListComponent = NotificationListComponent;
    exports.NumberPickerModule = NumberPickerModule;
    exports.NUMBER_PICKER_VALUE_ACCESSOR = NUMBER_PICKER_VALUE_ACCESSOR;
    exports.NumberPickerComponent = NumberPickerComponent;
    exports.PageHeaderModule = PageHeaderModule;
    exports.PageHeaderComponent = PageHeaderComponent;
    exports.PageHeaderNavigationComponent = PageHeaderNavigationComponent;
    exports.PageHeaderIconMenuComponent = PageHeaderIconMenuComponent;
    exports.PageHeaderCustomMenuDirective = PageHeaderCustomMenuDirective;
    exports.PopoverModule = PopoverModule;
    exports.PopoverComponent = PopoverComponent;
    exports.PopoverDirective = PopoverDirective;
    exports.ProgressBarModule = ProgressBarModule;
    exports.ProgressBarComponent = ProgressBarComponent;
    exports.RadioButtonModule = RadioButtonModule;
    exports.RADIOBUTTON_VALUE_ACCESSOR = RADIOBUTTON_VALUE_ACCESSOR;
    exports.RadioButtonComponent = RadioButtonComponent;
    exports.SearchBuilderFocusService = SearchBuilderFocusService;
    exports.SearchBuilderGroupComponent = SearchBuilderGroupComponent;
    exports.SearchBuilderGroupService = SearchBuilderGroupService;
    exports.SearchBuilderOutletDirective = SearchBuilderOutletDirective;
    exports.SearchBuilderComponent = SearchBuilderComponent;
    exports.SearchBuilderModule = SearchBuilderModule;
    exports.SearchBuilderService = SearchBuilderService;
    exports.BaseSearchComponent = BaseSearchComponent;
    exports.SearchDateRangeComponent = SearchDateRangeComponent;
    exports.SearchDateComponent = SearchDateComponent;
    exports.SearchSelectComponent = SearchSelectComponent;
    exports.SearchTextComponent = SearchTextComponent;
    exports.SelectListItemComponent = SelectListItemComponent;
    exports.SelectListComponent = SelectListComponent;
    exports.SelectListModule = SelectListModule;
    exports.SELECT_VALUE_ACCESSOR = SELECT_VALUE_ACCESSOR;
    exports.SelectComponent = SelectComponent;
    exports.SelectModule = SelectModule;
    exports.SidePanelComponent = SidePanelComponent;
    exports.SidePanelCloseDirective = SidePanelCloseDirective;
    exports.SidePanelModule = SidePanelModule;
    exports.SliderModule = SliderModule;
    exports.SliderComponent = SliderComponent;
    exports.SliderType = SliderType;
    exports.SliderStyle = SliderStyle;
    exports.SliderSize = SliderSize;
    exports.SliderCalloutTrigger = SliderCalloutTrigger;
    exports.SliderSnap = SliderSnap;
    exports.SliderTickType = SliderTickType;
    exports.SliderThumbEvent = SliderThumbEvent;
    exports.SliderThumb = SliderThumb;
    exports.SparkModule = SparkModule;
    exports.SparkComponent = SparkComponent;
    exports.SpinButtonModule = SpinButtonModule;
    exports.SPIN_BUTTON_VALUE_ACCESSOR = SPIN_BUTTON_VALUE_ACCESSOR;
    exports.SpinButtonComponent = SpinButtonComponent;
    exports.ResizableTableColumnComponent = ResizableTableColumnComponent;
    exports.ResizableTableDirective = ResizableTableDirective;
    exports.TableModule = TableModule;
    exports.TabsetModule = TabsetModule;
    exports.TabsetComponent = TabsetComponent;
    exports.TabsetService = TabsetService;
    exports.TabComponent = TabComponent;
    exports.TabHeadingDirective = TabHeadingDirective;
    exports.TabFocusDirective = TabFocusDirective;
    exports.TagInputEvent = TagInputEvent;
    exports.TagInputComponent = TagInputComponent;
    exports.TagInputModule = TagInputModule;
    exports.TimePickerModule = TimePickerModule;
    exports.TIME_PICKER_VALUE_ACCESSOR = TIME_PICKER_VALUE_ACCESSOR;
    exports.TimePickerComponent = TimePickerComponent;
    exports.TimeFormatPipe = TimeFormatPipe;
    exports.TimelineModule = TimelineModule;
    exports.TimelineComponent = TimelineComponent;
    exports.TimelineEventComponent = TimelineEventComponent;
    exports.ToggleSwitchModule = ToggleSwitchModule;
    exports.ToggleSwitchComponent = ToggleSwitchComponent;
    exports.ToolbarSearchModule = ToolbarSearchModule;
    exports.ToolbarSearchComponent = ToolbarSearchComponent;
    exports.ToolbarSearchFieldDirective = ToolbarSearchFieldDirective;
    exports.ToolbarSearchButtonDirective = ToolbarSearchButtonDirective;
    exports.TooltipModule = TooltipModule;
    exports.TooltipComponent = TooltipComponent;
    exports.TooltipDirective = TooltipDirective;
    exports.TooltipService = TooltipService;
    exports.TypeaheadOptionEvent = TypeaheadOptionEvent;
    exports.TypeaheadKeyService = TypeaheadKeyService;
    exports.TypeaheadComponent = TypeaheadComponent;
    exports.TypeaheadModule = TypeaheadModule;
    exports.VirtualScrollModule = VirtualScrollModule;
    exports.VirtualScrollComponent = VirtualScrollComponent;
    exports.VirtualScrollLoadingDirective = VirtualScrollLoadingDirective;
    exports.VirtualScrollLoadButtonDirective = VirtualScrollLoadButtonDirective;
    exports.VirtualScrollCellDirective = VirtualScrollCellDirective;
    exports.WizardModule = WizardModule;
    exports.WizardComponent = WizardComponent;
    exports.StepChangingEvent = StepChangingEvent;
    exports.WizardStepComponent = WizardStepComponent;
    exports.AccessibilityModule = AccessibilityModule;
    exports.FocusWithinDirective = FocusWithinDirective;
    exports.SplitterAccessibilityDirective = SplitterAccessibilityDirective;
    exports.TabbableListItemDirective = TabbableListItemDirective;
    exports.TabbableListDirective = TabbableListDirective;
    exports.TabbableListService = TabbableListService;
    exports.AutoGrowModule = AutoGrowModule;
    exports.AutoGrowDirective = AutoGrowDirective;
    exports.ClickOutsideModule = ClickOutsideModule;
    exports.ClickOutsideDirective = ClickOutsideDirective;
    exports.DragDirective = DragDirective;
    exports.DragModule = DragModule;
    exports.DragService = DragService;
    exports.DropDirective = DropDirective;
    exports.FixedHeaderTableModule = FixedHeaderTableModule;
    exports.FixedHeaderTableDirective = FixedHeaderTableDirective;
    exports.FloatLabelDirective = FloatLabelDirective;
    exports.FloatLabelModule = FloatLabelModule;
    exports.FocusIfDirective = FocusIfDirective;
    exports.FocusIfModule = FocusIfModule;
    exports.HelpCenterModule = HelpCenterModule;
    exports.HelpCenterService = HelpCenterService;
    exports.HelpCenterItemDirective = HelpCenterItemDirective;
    exports.HoverActionModule = HoverActionModule;
    exports.HoverActionContainerDirective = HoverActionContainerDirective;
    exports.HoverActionDirective = HoverActionDirective;
    exports.InfiniteScrollDirective = InfiniteScrollDirective;
    exports.InfiniteScrollLoadingEvent = InfiniteScrollLoadingEvent;
    exports.InfiniteScrollLoadedEvent = InfiniteScrollLoadedEvent;
    exports.InfiniteScrollLoadErrorEvent = InfiniteScrollLoadErrorEvent;
    exports.InfiniteScrollLoadButtonDirective = InfiniteScrollLoadButtonDirective;
    exports.InfiniteScrollLoadingDirective = InfiniteScrollLoadingDirective;
    exports.InfiniteScrollModule = InfiniteScrollModule;
    exports.LayoutSwitcherModule = LayoutSwitcherModule;
    exports.LayoutSwitcherDirective = LayoutSwitcherDirective;
    exports.LayoutSwitcherItemDirective = LayoutSwitcherItemDirective;
    exports.MenuNavigationItemDirective = MenuNavigationItemDirective;
    exports.MenuNavigationDirective = MenuNavigationDirective;
    exports.MenuNavigationModule = MenuNavigationModule;
    exports.ObserversModule = ObserversModule;
    exports.OverflowDirective = OverflowDirective;
    exports.ReorderableModule = ReorderableModule;
    exports.ReorderableDirective = ReorderableDirective;
    exports.ReorderableHandleDirective = ReorderableHandleDirective;
    exports.ReorderableModelDirective = ReorderableModelDirective;
    exports.ReorderableService = ReorderableService;
    exports.ReorderableGroup = ReorderableGroup;
    exports.ResizeService = ResizeService;
    exports.ResizeDirective = ResizeDirective;
    exports.ResizeModule = ResizeModule;
    exports.ScrollIntoViewIfModule = ScrollModule;
    exports.ScrollIntoViewIfDirective = ScrollIntoViewIfDirective;
    exports.ScrollIntoViewDirective = ScrollIntoViewDirective;
    exports.ScrollIntoViewService = ScrollIntoViewService;
    exports.ScrollModule = ScrollModule;
    exports.SelectionItemDirective = SelectionItemDirective;
    exports.SelectionDirective = SelectionDirective;
    exports.SelectionModule = SelectionModule;
    exports.SelectionService = SelectionService;
    exports.SelectionStrategy = SelectionStrategy;
    exports.TreeGridIndentDirective = TreeGridIndentDirective;
    exports.TreeGridState = TreeGridState;
    exports.TreeGridDirective = TreeGridDirective;
    exports.TreeGridModule = TreeGridModule;
    exports.ContactsNg1Component = ContactsNg1Component;
    exports.ExpandInputNg1Component = ExpandInputNg1Component;
    exports.FloatingActionButtonNg1Component = FloatingActionButtonNg1Component;
    exports.FlotNg1Component = FlotNg1Component;
    exports.GridNg1Component = GridNg1Component;
    exports.HierarchyBarNg1Component = HierarchyBarNg1Component;
    exports.MarqueeWizardNg1Component = MarqueeWizardNg1Component;
    exports.NestedDonutNg1Component = NestedDonutNg1Component;
    exports.OrganizationChartNg1Component = OrganizationChartNg1Component;
    exports.PartitionMapNg1Component = PartitionMapNg1Component;
    exports.PeityBarChartNg1Component = PeityBarChartNg1Component;
    exports.PeityLineChartNg1Component = PeityLineChartNg1Component;
    exports.PeityPieChartNg1Component = PeityPieChartNg1Component;
    exports.PeityUpdatingLineChartNg1Component = PeityUpdatingLineChartNg1Component;
    exports.SankeyNg1Component = SankeyNg1Component;
    exports.SearchToolbarNg1Component = SearchToolbarNg1Component;
    exports.SelectTableNg1Component = SelectTableNg1Component;
    exports.SLIDER_CHART_VALUE_ACCESSOR = SLIDER_CHART_VALUE_ACCESSOR;
    exports.SliderChartNg1Component = SliderChartNg1Component;
    exports.SocialChartNg1Component = SocialChartNg1Component;
    exports.SortDirectionToggleNg1Component = SortDirectionToggleNg1Component;
    exports.TreeGridNg1Component = TreeGridNg1Component;
    exports.ThumbnailNg1Component = ThumbnailNg1Component;
    exports.NavigationMenuService = NavigationMenuService;
    exports.navigationMenuServiceFactory = navigationMenuServiceFactory;
    exports.navigationMenuServiceProvider = navigationMenuServiceProvider;
    exports.PdfService = PdfService;
    exports.pdfServiceFactory = pdfServiceFactory;
    exports.pdfServiceProvider = pdfServiceProvider;
    exports.TimeAgoService = TimeAgoService;
    exports.timeAgoServiceFactory = timeAgoServiceFactory;
    exports.timeAgoServiceProvider = timeAgoServiceProvider;
    exports.HybridModule = HybridModule;
    exports.DurationPipeModule = DurationPipeModule;
    exports.DurationPipe = DurationPipe;
    exports.FileSizePipeModule = FileSizePipeModule;
    exports.FileSizePipe = FileSizePipe;
    exports.StringFilterPipe = StringFilterPipe;
    exports.StringFilterModule = StringFilterModule;
    exports.AudioServiceModule = AudioServiceModule;
    exports.AudioService = AudioService;
    exports.ColorServiceModule = ColorServiceModule;
    exports.ColorService = ColorService;
    exports.ThemeColor = ThemeColor;
    exports.colorSets = colorSets;
    exports.FrameExtractionModule = FrameExtractionModule;
    exports.FrameExtractionService = FrameExtractionService;
    exports.PersistentDataModule = PersistentDataModule;
    exports.PersistentDataService = PersistentDataService;
    exports.PersistentDataStorageType = PersistentDataStorageType;
    exports.StorageAdapter = StorageAdapter;
    exports.CookieAdapter = CookieAdapter;
    exports.LocalStorageAdapter = LocalStorageAdapter;
    exports.SessionStorageAdapter = SessionStorageAdapter;
    exports.ɵd = DayViewComponent;
    exports.ɵe = DayViewService;
    exports.ɵc = HeaderComponent;
    exports.ɵf = MonthViewComponent;
    exports.ɵg = MonthViewService;
    exports.ɵj = TimeViewComponent;
    exports.ɵh = YearViewComponent;
    exports.ɵi = YearViewService;
    exports.ɵm = FacetCheckListItemComponent;
    exports.ɵn = FacetTypeaheadListItemComponent;
    exports.ɵq = FloatingActionButtonsService;
    exports.ɵs = MarqueeWizardService;
    exports.ɵt = MediaPlayerService;
    exports.ɵu = NavigationLinkDirective;
    exports.ɵx = PageHeaderNavigationDropdownItemComponent;
    exports.ɵw = PageHeaderNavigationItemComponent;
    exports.ɵy = PageHeaderNavigationSecondaryItemDirective;
    exports.ɵv = PageHeaderService;
    exports.ɵr = SidePanelService;
    exports.ɵz = ResizableTableService;
    exports.ɵl = TypeaheadHighlightDirective;
    exports.ɵk = TypeaheadService;
    exports.ɵba = HoverActionService;
    exports.ɵp = MenuNavigationToggleDirective;
    exports.ɵo = MenuNavigationService;
    exports.ɵbb = TreeGridRowDirective;
    exports.ɵbc = TreeGridService;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXgtYXNwZWN0cy11eC1hc3BlY3RzLnVtZC5qcy5tYXAiLCJzb3VyY2VzIjpbIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2FjY29yZGlvbi9hY2NvcmRpb24tcGFuZWwvYWNjb3JkaW9uLXBhbmVsLWhlYWRpbmcuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvYWNjb3JkaW9uL2FjY29yZGlvbi5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvYWNjb3JkaW9uL2FjY29yZGlvbi1wYW5lbC9hY2NvcmRpb24tcGFuZWwuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvYWNjb3JkaW9uL2FjY29yZGlvbi5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9hY2NvcmRpb24vYWNjb3JkaW9uLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2JyZWFkY3J1bWJzL2JyZWFkY3J1bWJzLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2JyZWFkY3J1bWJzL2JyZWFkY3J1bWJzLm1vZHVsZS50cyIsbnVsbCwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvcmVzaXplL3Jlc2l6ZS5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvcmVzaXplL3Jlc2l6ZS5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9yZXNpemUvcmVzaXplLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2NhcmQtdGFicy9jYXJkLXRhYi9jYXJkLXRhYi1jb250ZW50LmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2NhcmQtdGFicy9jYXJkLXRhYnMuc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2NhcmQtdGFicy9jYXJkLXRhYi9jYXJkLXRhYi5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9jYXJkLXRhYnMvY2FyZC10YWJzZXQvY2FyZC10YWJzZXQuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvY2FyZC10YWJzL2NhcmQtdGFicy5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9jaGVja2JveC9jaGVja2JveC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9jaGVja2JveC9jaGVja2JveC5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvc2VydmljZXMvY29sb3IvY29sb3Iuc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2NvbG9yLXBpY2tlci9jb2xvci1waWNrZXIuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvYWNjZXNzaWJpbGl0eS9mb2N1cy13aXRoaW4vZm9jdXMtd2l0aGluLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL2FjY2Vzc2liaWxpdHkvc3BsaXR0ZXIvc3BsaXR0ZXItYWNjZXNzaWJpbGl0eS5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tbW9uL29wZXJhdG9ycy90aWNrLm9wZXJhdG9yLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvYWNjZXNzaWJpbGl0eS90YWJiYWJsZS1saXN0L3RhYmJhYmxlLWxpc3Quc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL2FjY2Vzc2liaWxpdHkvdGFiYmFibGUtbGlzdC90YWJiYWJsZS1saXN0LWl0ZW0uZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvYWNjZXNzaWJpbGl0eS90YWJiYWJsZS1saXN0L3RhYmJhYmxlLWxpc3QuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvYWNjZXNzaWJpbGl0eS9hY2Nlc3NpYmlsaXR5Lm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL251bWJlci1waWNrZXIvbnVtYmVyLXBpY2tlci5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9udW1iZXItcGlja2VyL251bWJlci1waWNrZXIubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdG9vbHRpcC90b29sdGlwLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3Rvb2x0aXAvdG9vbHRpcC5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdG9vbHRpcC90b29sdGlwLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3Rvb2x0aXAvdG9vbHRpcC5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9jb2xvci1waWNrZXIvY29sb3ItcGlja2VyLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2NvbHVtbi1zb3J0aW5nL2NvbHVtbi1zb3J0aW5nLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2NvbHVtbi1zb3J0aW5nL2NvbHVtbi1zb3J0aW5nLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2NvbHVtbi1zb3J0aW5nL2NvbHVtbi1zb3J0aW5nLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2NvbmR1aXQvY29uZHVpdC1zdWJqZWN0LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvY29uZHVpdC9jb25kdWl0LXV0aWxzLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvY29uZHVpdC9jb25kdWl0LXpvbmUuc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2NvbmR1aXQvY29uZHVpdC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9jb25kdWl0L2NvbmR1aXQtem9uZS5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9jb25kdWl0L2ludGVyZmFjZXMvY29uZHVpdC1wcm9wZXJ0aWVzLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvY29uZHVpdC9jb25kdWl0LmRlY29yYXRvci50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2Rhc2hib2FyZC9kYXNoYm9hcmQuc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2Rhc2hib2FyZC9kYXNoYm9hcmQuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZGFzaGJvYXJkL3dpZGdldC9kYXNoYm9hcmQtd2lkZ2V0LmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL2RyYWcvZHJhZy5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvZHJhZy9kcmFnLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL2RyYWcvZHJvcC5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9kcmFnL2RyYWcubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZGFzaGJvYXJkL2RyYWctaGFuZGxlL2RyYWctaGFuZGxlLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2Rhc2hib2FyZC9kYXNoYm9hcmQubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvc3Bpbi1idXR0b24vc3Bpbi1idXR0b24uY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvc3Bpbi1idXR0b24vc3Bpbi1idXR0b24ubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdGltZS1waWNrZXIvdGltZS1mb3JtYXQucGlwZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3RpbWUtcGlja2VyL3RpbWUtcGlja2VyLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3RpbWUtcGlja2VyL3RpbWUtcGlja2VyLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2RhdGUtdGltZS1waWNrZXIvZGF0ZS10aW1lLXBpY2tlci51dGlscy50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2RhdGUtdGltZS1waWNrZXIvZGF0ZS10aW1lLXBpY2tlci5jb25maWcudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9kYXRlLXRpbWUtcGlja2VyL2RhdGUtdGltZS1waWNrZXIuc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2RhdGUtdGltZS1waWNrZXIvZGF0ZS10aW1lLXBpY2tlci5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9kYXRlLXRpbWUtcGlja2VyL2RheS12aWV3L2RheS12aWV3LnNlcnZpY2UudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9kYXRlLXRpbWUtcGlja2VyL2RheS12aWV3L2RheS12aWV3LmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2RhdGUtdGltZS1waWNrZXIvaGVhZGVyL2hlYWRlci5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9kYXRlLXRpbWUtcGlja2VyL21vbnRoLXZpZXcvbW9udGgtdmlldy5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZGF0ZS10aW1lLXBpY2tlci9tb250aC12aWV3L21vbnRoLXZpZXcuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZGF0ZS10aW1lLXBpY2tlci90aW1lLXZpZXcvdGltZS12aWV3LmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2RhdGUtdGltZS1waWNrZXIveWVhci12aWV3L3llYXItdmlldy5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZGF0ZS10aW1lLXBpY2tlci95ZWFyLXZpZXcveWVhci12aWV3LmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL2ZvY3VzLWlmL2ZvY3VzLWlmLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL2ZvY3VzLWlmL2ZvY3VzLWlmLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2RhdGUtdGltZS1waWNrZXIvZGF0ZS10aW1lLXBpY2tlci5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9lYm94L2Vib3guY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZWJveC9lYm94Lm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3R5cGVhaGVhZC90eXBlYWhlYWQtZXZlbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy90eXBlYWhlYWQvdHlwZWFoZWFkLWtleS5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdHlwZWFoZWFkL3R5cGVhaGVhZC5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdHlwZWFoZWFkL3R5cGVhaGVhZC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9pbmZpbml0ZS1zY3JvbGwvaW5maW5pdGUtc2Nyb2xsLWxvYWQtYnV0dG9uLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL2luZmluaXRlLXNjcm9sbC9pbmZpbml0ZS1zY3JvbGwtbG9hZGluZy5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9pbmZpbml0ZS1zY3JvbGwvaW5maW5pdGUtc2Nyb2xsLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL2luZmluaXRlLXNjcm9sbC9pbmZpbml0ZS1zY3JvbGwubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvc2Nyb2xsL3Njcm9sbC1pbnRvLXZpZXcuc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL3Njcm9sbC9zY3JvbGwtaW50by12aWV3LWlmLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL3Njcm9sbC9zY3JvbGwtaW50by12aWV3LmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL3Njcm9sbC9zY3JvbGwubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdHlwZWFoZWFkL3R5cGVhaGVhZC1oaWdobGlnaHQuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdHlwZWFoZWFkL3R5cGVhaGVhZC5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9yZW9yZGVyYWJsZS9yZW9yZGVyYWJsZS1oYW5kbGUuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvcmVvcmRlcmFibGUvcmVvcmRlcmFibGUtbW9kZWwuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvcmVvcmRlcmFibGUvZHJhZ3VsYS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL3Jlb3JkZXJhYmxlL3Jlb3JkZXJhYmxlLnNlcnZpY2UudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9yZW9yZGVyYWJsZS9yZW9yZGVyYWJsZS5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9yZW9yZGVyYWJsZS9yZW9yZGVyYWJsZS5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9mYWNldHMvZmFjZXQtZXZlbnRzLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZmFjZXRzL2ZhY2V0LWNvbnRhaW5lci5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9mYWNldHMvYmFzZS9mYWNldC1iYXNlL2ZhY2V0LWJhc2UuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZmFjZXRzL2Jhc2UvZmFjZXQtaGVhZGVyL2ZhY2V0LWhlYWRlci5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9mYWNldHMvZmFjZXQtY2hlY2stbGlzdC9jaGVjay1saXN0LWl0ZW0vZmFjZXQtY2hlY2stbGlzdC1pdGVtLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2ZhY2V0cy9mYWNldC1jaGVjay1saXN0L2ZhY2V0LWNoZWNrLWxpc3QuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZmFjZXRzL2ZhY2V0LXR5cGVhaGVhZC1saXN0L3R5cGVhaGVhZC1saXN0LWl0ZW0vZmFjZXQtdHlwZWFoZWFkLWxpc3QtaXRlbS5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9mYWNldHMvZmFjZXQtdHlwZWFoZWFkLWxpc3QvZmFjZXQtdHlwZWFoZWFkLWxpc3QuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZmFjZXRzL2ZhY2V0cy5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9mYWNldHMvbW9kZWxzL2ZhY2V0LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvbWVudS1uYXZpZ2F0aW9uL21lbnUtbmF2aWdhdGlvbi5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvbWVudS1uYXZpZ2F0aW9uL21lbnUtbmF2aWdhdGlvbi1pdGVtLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL21lbnUtbmF2aWdhdGlvbi9tZW51LW5hdmlnYXRpb24uZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvbWVudS1uYXZpZ2F0aW9uL21lbnUtbmF2aWdhdGlvbi10b2dnbGUuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvbWVudS1uYXZpZ2F0aW9uL21lbnUtbmF2aWdhdGlvbi5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9maWx0ZXJzL2ZpbHRlci1jb250YWluZXIuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZmlsdGVycy9maWx0ZXItYmFzZS9maWx0ZXItYmFzZS5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9maWx0ZXJzL2ZpbHRlci1kcm9wZG93bi9maWx0ZXItZHJvcGRvd24uY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZmlsdGVycy9maWx0ZXItZHluYW1pYy9maWx0ZXItZHluYW1pYy5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9maWx0ZXJzL2ZpbHRlci5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9mbGlwcGFibGUtY2FyZC9mbGlwcGFibGUtY2FyZC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9mbGlwcGFibGUtY2FyZC9mbGlwcGFibGUtY2FyZC5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9mbG9hdGluZy1hY3Rpb24tYnV0dG9ucy9mbG9hdGluZy1hY3Rpb24tYnV0dG9ucy5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZmxvYXRpbmctYWN0aW9uLWJ1dHRvbnMvZmxvYXRpbmctYWN0aW9uLWJ1dHRvbnMuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvZmxvYXRpbmctYWN0aW9uLWJ1dHRvbnMvZmxvYXRpbmctYWN0aW9uLWJ1dHRvbi5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9mbG9hdGluZy1hY3Rpb24tYnV0dG9ucy9mbG9hdGluZy1hY3Rpb24tYnV0dG9ucy5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9oaWVyYXJjaHktYmFyL2hpZXJhcmNoeS1iYXIuc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2hpZXJhcmNoeS1iYXIvaGllcmFyY2h5LWJhci5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9jbGljay1vdXRzaWRlL2NsaWNrLW91dHNpZGUuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvY2xpY2stb3V0c2lkZS9jbGljay1vdXRzaWRlLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3BvcG92ZXIvcG9wb3Zlci5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9wb3BvdmVyL3BvcG92ZXIuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvcG9wb3Zlci9wb3BvdmVyLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2hpZXJhcmNoeS1iYXIvaGllcmFyY2h5LWJhci5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9zaWRlLXBhbmVsL3NpZGUtcGFuZWwuc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3NpZGUtcGFuZWwvc2lkZS1wYW5lbC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9pdGVtLWRpc3BsYXktcGFuZWwvaXRlbS1kaXNwbGF5LXBhbmVsLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL2l0ZW0tZGlzcGxheS1wYW5lbC9pdGVtLWRpc3BsYXktcGFuZWwubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvd2l6YXJkL3dpemFyZC1zdGVwLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3dpemFyZC93aXphcmQuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvd2l6YXJkL3dpemFyZC5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9tYXJxdWVlLXdpemFyZC9tYXJxdWVlLXdpemFyZC5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvbWFycXVlZS13aXphcmQvbWFycXVlZS13aXphcmQtc3RlcC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9tYXJxdWVlLXdpemFyZC9tYXJxdWVlLXdpemFyZC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9tYXJxdWVlLXdpemFyZC9tYXJxdWVlLXdpemFyZC5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvc2VydmljZXMvZnJhbWUtZXh0cmFjdGlvbi9mcmFtZS1leHRyYWN0aW9uLnNlcnZpY2UudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvc2VydmljZXMvZnJhbWUtZXh0cmFjdGlvbi9mcmFtZS1leHRyYWN0aW9uLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL21lZGlhLXBsYXllci9tZWRpYS1wbGF5ZXIuc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL21lZGlhLXBsYXllci9leHRlbnNpb25zL2Jhc2UtZXh0ZW5zaW9uLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9zZXJ2aWNlcy9jb2xvci9jb2xvci5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9zbGlkZXIvc2xpZGVyLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3NsaWRlci9zbGlkZXIubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvbWVkaWEtcGxheWVyL2V4dGVuc2lvbnMvY29udHJvbHMvY29udHJvbHMuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvbWVkaWEtcGxheWVyL2V4dGVuc2lvbnMvY29udHJvbHMvY3VzdG9tLWNvbnRyb2wvY3VzdG9tLWNvbnRyb2wuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvbWVkaWEtcGxheWVyL2V4dGVuc2lvbnMvdGltZWxpbmUvdGltZWxpbmUuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL3NlcnZpY2VzL2F1ZGlvL2F1ZGlvLnNlcnZpY2UudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvc2VydmljZXMvYXVkaW8vYXVkaW8ubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvbWVkaWEtcGxheWVyL21lZGlhLXBsYXllci5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvcGlwZXMvZHVyYXRpb24vZHVyYXRpb24ucGlwZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9waXBlcy9kdXJhdGlvbi9kdXJhdGlvbi5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvcGlwZXMvZmlsZS1zaXplL2ZpbGUtc2l6ZS5waXBlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL3BpcGVzL2ZpbGUtc2l6ZS9maWxlLXNpemUubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvbWVkaWEtcGxheWVyL21lZGlhLXBsYXllci5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9uYXZpZ2F0aW9uL25hdmlnYXRpb24taXRlbS9uYXZpZ2F0aW9uLWl0ZW0uY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvbmF2aWdhdGlvbi9uYXZpZ2F0aW9uLnNlcnZpY2UudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9uYXZpZ2F0aW9uL25hdmlnYXRpb24tbGluay9uYXZpZ2F0aW9uLWxpbmsuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvbmF2aWdhdGlvbi9uYXZpZ2F0aW9uLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL25hdmlnYXRpb24vbmF2aWdhdGlvbi5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9ub3RpZmljYXRpb24vbm90aWZpY2F0aW9uLnNlcnZpY2UudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9ub3RpZmljYXRpb24vbm90aWZpY2F0aW9uLWxpc3QuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvbm90aWZpY2F0aW9uL25vdGlmaWNhdGlvbi5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9wYWdlLWhlYWRlci9jdXN0b20tbWVudS9jdXN0b20tbWVudS5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9wYWdlLWhlYWRlci9wYWdlLWhlYWRlci5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvcGFnZS1oZWFkZXIvaWNvbi1tZW51L2ljb24tbWVudS5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9wYWdlLWhlYWRlci9uYXZpZ2F0aW9uL25hdmlnYXRpb24tZHJvcGRvd24taXRlbS9uYXZpZ2F0aW9uLWRyb3Bkb3duLWl0ZW0uY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvcGFnZS1oZWFkZXIvbmF2aWdhdGlvbi9uYXZpZ2F0aW9uLWl0ZW0vbmF2aWdhdGlvbi1pdGVtLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3BhZ2UtaGVhZGVyL25hdmlnYXRpb24vbmF2aWdhdGlvbi1zZWNvbmRhcnktaXRlbS9uYXZpZ2F0aW9uLXNlY29uZGFyeS1pdGVtLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3BhZ2UtaGVhZGVyL25hdmlnYXRpb24vbmF2aWdhdGlvbi5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9wYWdlLWhlYWRlci9wYWdlLWhlYWRlci5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9wYWdlLWhlYWRlci9wYWdlLWhlYWRlci5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9wcm9ncmVzcy1iYXIvcHJvZ3Jlc3MtYmFyLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3Byb2dyZXNzLWJhci9wcm9ncmVzcy1iYXIubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvcmFkaW9idXR0b24vcmFkaW9idXR0b24uY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvcmFkaW9idXR0b24vcmFkaW9idXR0b24ubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvc2VhcmNoLWJ1aWxkZXIvc2VhcmNoLWJ1aWxkZXItZm9jdXMuc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3NlYXJjaC1idWlsZGVyL3NlYXJjaC1idWlsZGVyLnNlcnZpY2UudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9zZWFyY2gtYnVpbGRlci9zZWFyY2gtYnVpbGRlci1ncm91cC9zZWFyY2gtYnVpbGRlci1ncm91cC5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvc2VhcmNoLWJ1aWxkZXIvc2VhcmNoLWJ1aWxkZXItZ3JvdXAvc2VhcmNoLWJ1aWxkZXItZ3JvdXAuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvc2VhcmNoLWJ1aWxkZXIvc2VhcmNoLWJ1aWxkZXItb3V0bGV0L3NlYXJjaC1idWlsZGVyLW91dGxldC5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9zZWFyY2gtYnVpbGRlci9zZWFyY2gtYnVpbGRlci5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9zZWxlY3Qvc2VsZWN0LmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3RhZy1pbnB1dC90YWctaW5wdXQtZXZlbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy90YWctaW5wdXQvdGFnLWlucHV0LmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3RhZy1pbnB1dC90YWctaW5wdXQubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvc2VsZWN0L3NlbGVjdC5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9zZWFyY2gtYnVpbGRlci9zZWFyY2gtY29tcG9uZW50cy9iYXNlLXNlYXJjaC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9zZWFyY2gtYnVpbGRlci9zZWFyY2gtY29tcG9uZW50cy9kYXRlLXJhbmdlL2RhdGUtcmFuZ2UuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvc2VhcmNoLWJ1aWxkZXIvc2VhcmNoLWNvbXBvbmVudHMvZGF0ZS9kYXRlLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3NlYXJjaC1idWlsZGVyL3NlYXJjaC1jb21wb25lbnRzL3NlbGVjdC9zZWxlY3QuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvc2VhcmNoLWJ1aWxkZXIvc2VhcmNoLWNvbXBvbmVudHMvdGV4dC90ZXh0LmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3NlYXJjaC1idWlsZGVyL3NlYXJjaC1idWlsZGVyLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL3NlbGVjdGlvbi9zdHJhdGVnaWVzL3NlbGVjdGlvbi5zdHJhdGVneS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL3NlbGVjdGlvbi9zdHJhdGVnaWVzL3Jvdy1zZWxlY3Rpb24uc3RyYXRlZ3kudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9zZWxlY3Rpb24vc3RyYXRlZ2llcy9yb3ctYWx0LXNlbGVjdGlvbi5zdHJhdGVneS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL3NlbGVjdGlvbi9zdHJhdGVnaWVzL3NpbXBsZS1zZWxlY3Rpb24uc3RyYXRlZ3kudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9zZWxlY3Rpb24vc2VsZWN0aW9uLnNlcnZpY2UudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9zZWxlY3QtbGlzdC9zZWxlY3QtbGlzdC1pdGVtL3NlbGVjdC1saXN0LWl0ZW0uY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvc2VsZWN0LWxpc3QvbXVsdGlwbGUtc2VsZWN0LWxpc3Quc3RyYXRlZ3kudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9zZWxlY3QtbGlzdC9zaW5nbGUtc2VsZWN0LWxpc3Quc3RyYXRlZ3kudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9zZWxlY3QtbGlzdC9zZWxlY3QtbGlzdC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9zZWxlY3QtbGlzdC9zZWxlY3QtbGlzdC5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy9zaWRlLXBhbmVsL3NpZGUtcGFuZWwtY2xvc2UuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvc2lkZS1wYW5lbC9zaWRlLXBhbmVsLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3NwYXJrL3NwYXJrLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3NwYXJrL3NwYXJrLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3RhYmxlL3RhYmxlLWNvbHVtbi1yZXNpemUvcmVzaXphYmxlLXRhYmxlLnNlcnZpY2UudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy90YWJsZS90YWJsZS1jb2x1bW4tcmVzaXplL3Jlc2l6YWJsZS10YWJsZS1jb2x1bW4uY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdGFibGUvdGFibGUtY29sdW1uLXJlc2l6ZS9yZXNpemFibGUtdGFibGUuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdGFibGUvdGFibGUubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdGFic2V0L3RhYnNldC5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdGFic2V0L3RhYi90YWItZm9jdXMuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdGFic2V0L3RhYi90YWIuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdGFic2V0L3RhYi90YWItaGVhZGluZy5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy90YWJzZXQvdGFic2V0LmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3RhYnNldC90YWJzZXQubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdGltZWxpbmUvdGltZWxpbmUuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdGltZWxpbmUvdGltZWxpbmUtZXZlbnQvdGltZWxpbmUtZXZlbnQuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdGltZWxpbmUvdGltZWxpbmUubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdG9nZ2xlc3dpdGNoL3RvZ2dsZXN3aXRjaC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy90b2dnbGVzd2l0Y2gvdG9nZ2xlc3dpdGNoLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9jb21wb25lbnRzL3Rvb2xiYXItc2VhcmNoL3Rvb2xiYXItc2VhcmNoLWJ1dHRvbi5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy90b29sYmFyLXNlYXJjaC90b29sYmFyLXNlYXJjaC1maWVsZC5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy90b29sYmFyLXNlYXJjaC90b29sYmFyLXNlYXJjaC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy90b29sYmFyLXNlYXJjaC90b29sYmFyLXNlYXJjaC5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy92aXJ0dWFsLXNjcm9sbC9kaXJlY3RpdmVzL3ZpcnR1YWwtc2Nyb2xsLWxvYWRpbmcuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdmlydHVhbC1zY3JvbGwvZGlyZWN0aXZlcy92aXJ0dWFsLXNjcm9sbC1sb2FkLWJ1dHRvbi5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvY29tcG9uZW50cy92aXJ0dWFsLXNjcm9sbC9kaXJlY3RpdmVzL3ZpcnR1YWwtc2Nyb2xsLWNlbGwuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdmlydHVhbC1zY3JvbGwvdmlydHVhbC1zY3JvbGwuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2NvbXBvbmVudHMvdmlydHVhbC1zY3JvbGwvdmlydHVhbC1zY3JvbGwubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvYXV0by1ncm93L2F1dG8tZ3Jvdy5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9hdXRvLWdyb3cvYXV0by1ncm93Lm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL2ZpeGVkLWhlYWRlci10YWJsZS9maXhlZC1oZWFkZXItdGFibGUuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvZml4ZWQtaGVhZGVyLXRhYmxlL2ZpeGVkLWhlYWRlci10YWJsZS5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9mbG9hdC1sYWJlbC9mbG9hdC1sYWJlbC5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9mbG9hdC1sYWJlbC9mbG9hdC1sYWJlbC5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9oZWxwLWNlbnRlci9oZWxwLWNlbnRlci5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvaGVscC1jZW50ZXIvaGVscC1jZW50ZXItaXRlbS5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9oZWxwLWNlbnRlci9oZWxwLWNlbnRlci5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9ob3Zlci1hY3Rpb24vaG92ZXItYWN0aW9uLnNlcnZpY2UudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9ob3Zlci1hY3Rpb24vaG92ZXItYWN0aW9uLWNvbnRhaW5lci5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9ob3Zlci1hY3Rpb24vaG92ZXItYWN0aW9uLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL2hvdmVyLWFjdGlvbi9ob3Zlci1hY3Rpb24ubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvbGF5b3V0LXN3aXRjaGVyL2xheW91dC1zd2l0Y2hlci1pdGVtLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL2xheW91dC1zd2l0Y2hlci9sYXlvdXQtc3dpdGNoZXIuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvbGF5b3V0LXN3aXRjaGVyL2xheW91dC1zd2l0Y2hlci5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9vYnNlcnZlcnMvb3ZlcmZsb3cvb3ZlcmZsb3ctb2JzZXJ2ZXIuZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvb2JzZXJ2ZXJzL29ic2VydmVycy5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9zZWxlY3Rpb24vc2VsZWN0aW9uLWl0ZW0uZGlyZWN0aXZlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2RpcmVjdGl2ZXMvc2VsZWN0aW9uL3NlbGVjdGlvbi5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy9zZWxlY3Rpb24vc2VsZWN0aW9uLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL3RyZWUtZ3JpZC90cmVlLWdyaWQtc3RhdGUuY2xhc3MudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy90cmVlLWdyaWQvdHJlZS1ncmlkLnNlcnZpY2UudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy90cmVlLWdyaWQvdHJlZS1ncmlkLXJvdy5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy90cmVlLWdyaWQvdHJlZS1ncmlkLWluZGVudC5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvZGlyZWN0aXZlcy90cmVlLWdyaWQvdHJlZS1ncmlkLmRpcmVjdGl2ZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9kaXJlY3RpdmVzL3RyZWUtZ3JpZC90cmVlLWdyaWQubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2h5YnJpZC9jb21wb25lbnRzL2NvbnRhY3RzL2NvbnRhY3RzLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9oeWJyaWQvY29tcG9uZW50cy9leHBhbmQtaW5wdXQvZXhwYW5kLWlucHV0LmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9oeWJyaWQvY29tcG9uZW50cy9mbG9hdGluZy1hY3Rpb24tYnV0dG9uL2Zsb2F0aW5nLWFjdGlvbi1idXR0b24uY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2h5YnJpZC9jb21wb25lbnRzL2Zsb3QvZmxvdC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvaHlicmlkL2NvbXBvbmVudHMvZ3JpZC9ncmlkLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9oeWJyaWQvY29tcG9uZW50cy9oaWVyYXJjaHktYmFyL2hpZXJhcmNoeS1iYXIuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2h5YnJpZC9jb21wb25lbnRzL21hcnF1ZWUtd2l6YXJkL21hcnF1ZWUtd2l6YXJkLmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9oeWJyaWQvY29tcG9uZW50cy9uZXN0ZWQtZG9udXQvbmVzdGVkLWRvbnV0LmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9oeWJyaWQvY29tcG9uZW50cy9vcmdhbml6YXRpb24tY2hhcnQvb3JnYW5pemF0aW9uLWNoYXJ0LmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9oeWJyaWQvY29tcG9uZW50cy9wYXJ0aXRpb24tbWFwL3BhcnRpdGlvbi1tYXAuY29tcG9uZW50LnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2h5YnJpZC9jb21wb25lbnRzL3BlaXR5LWNoYXJ0L3BlaXR5LWJhci1jaGFydC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvaHlicmlkL2NvbXBvbmVudHMvcGVpdHktY2hhcnQvcGVpdHktbGluZS1jaGFydC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvaHlicmlkL2NvbXBvbmVudHMvcGVpdHktY2hhcnQvcGVpdHktcGllLWNoYXJ0LmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9oeWJyaWQvY29tcG9uZW50cy9wZWl0eS1jaGFydC9wZWl0eS11cGRhdGluZy1saW5lLWNoYXJ0LmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9oeWJyaWQvY29tcG9uZW50cy9zYW5rZXktY2hhcnQvc2Fua2V5LmNvbXBvbmVudC50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9oeWJyaWQvY29tcG9uZW50cy9zZWFyY2gtdG9vbGJhci9zZWFyY2gtdG9vbGJhci5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvaHlicmlkL2NvbXBvbmVudHMvc2VsZWN0LXRhYmxlL3NlbGVjdC10YWJsZS5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvaHlicmlkL2NvbXBvbmVudHMvc2xpZGVyLWNoYXJ0L3NsaWRlci1jaGFydC5kaXJlY3RpdmUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvaHlicmlkL2NvbXBvbmVudHMvc29jaWFsLWNoYXJ0L3NvY2lhbC1jaGFydC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvaHlicmlkL2NvbXBvbmVudHMvc29ydC1kaXJlY3Rpb24tdG9nZ2xlL3NvcnQtZGlyZWN0aW9uLXRvZ2dsZS5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvaHlicmlkL2NvbXBvbmVudHMvdHJlZS1ncmlkL3RyZWUtZ3JpZC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvaHlicmlkL2NvbXBvbmVudHMvdGh1bWJuYWlsL3RodW1ibmFpbC5jb21wb25lbnQudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvaHlicmlkL3NlcnZpY2VzL25hdmlnYXRpb24tbWVudS9uYXZpZ2F0aW9uLW1lbnUuc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9oeWJyaWQvc2VydmljZXMvcGRmL3BkZi5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2h5YnJpZC9zZXJ2aWNlcy90aW1lLWFnby90aW1lLWFnby5zZXJ2aWNlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL2h5YnJpZC9oeWJyaWQubW9kdWxlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL3BpcGVzL3N0cmluZy1maWx0ZXIvc3RyaW5nLWZpbHRlci5waXBlLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL3BpcGVzL3N0cmluZy1maWx0ZXIvc3RyaW5nLWZpbHRlci5tb2R1bGUudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvc2VydmljZXMvcGVyc2lzdGVudC1kYXRhL2FkYXB0ZXJzL2Nvb2tpZS1hZGFwdGVyLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL3NlcnZpY2VzL3BlcnNpc3RlbnQtZGF0YS9hZGFwdGVycy9sb2NhbC1zdG9yYWdlLWFkYXB0ZXIudHMiLCJuZzovL0B1eC1hc3BlY3RzL3V4LWFzcGVjdHMvc2VydmljZXMvcGVyc2lzdGVudC1kYXRhL2FkYXB0ZXJzL3Nlc3Npb24tc3RvcmFnZS1hZGFwdGVyLnRzIiwibmc6Ly9AdXgtYXNwZWN0cy91eC1hc3BlY3RzL3NlcnZpY2VzL3BlcnNpc3RlbnQtZGF0YS9wZXJzaXN0ZW50LWRhdGEuc2VydmljZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9zZXJ2aWNlcy9wZXJzaXN0ZW50LWRhdGEvcGVyc2lzdGVudC1kYXRhLm1vZHVsZS50cyIsIm5nOi8vQHV4LWFzcGVjdHMvdXgtYXNwZWN0cy9zZXJ2aWNlcy9wZXJzaXN0ZW50LWRhdGEvYWRhcHRlcnMvc3RvcmFnZS1hZGFwdGVyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERpcmVjdGl2ZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICd1eC1hY2NvcmRpb24tcGFuZWwtaGVhZGVyJ1xufSlcbmV4cG9ydCBjbGFzcyBBY2NvcmRpb25QYW5lbEhlYWRpbmdEaXJlY3RpdmUge1xuXG59IiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBBY2NvcmRpb25TZXJ2aWNlIHtcblxuICAgIGNvbGxhcHNlT3RoZXJzOiBib29sZWFuID0gZmFsc2U7XG4gICAgY29sbGFwc2UgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gICAgY29sbGFwc2VBbGwoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuY29sbGFwc2UubmV4dCgpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgSG9zdEJpbmRpbmcsIElucHV0LCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEFjY29yZGlvblNlcnZpY2UgfSBmcm9tICcuLi9hY2NvcmRpb24uc2VydmljZSc7XG5cbmxldCB1bmlxdWVJZDogbnVtYmVyID0gMTtcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1hY2NvcmRpb24tcGFuZWwnLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9hY2NvcmRpb24tcGFuZWwuY29tcG9uZW50Lmh0bWwnLFxuICAgIGhvc3Q6IHtcbiAgICAgICAgJ2NsYXNzJzogJ3BhbmVsIHBhbmVsLWRlZmF1bHQnLFxuICAgICAgICAncm9sZSc6ICd0YWInXG4gICAgfVxufSlcbmV4cG9ydCBjbGFzcyBBY2NvcmRpb25QYW5lbENvbXBvbmVudCB7XG5cbiAgICBASW5wdXQoKSBwYW5lbElkOiBzdHJpbmcgPSBgdXgtYWNjb3JkaW9uLXBhbmVsLSR7dW5pcXVlSWQrK31gO1xuICAgIEBJbnB1dCgpIGhlYWRpbmdJZDogc3RyaW5nID0gYCR7dGhpcy5wYW5lbElkfS1oZWFkaW5nYDtcblxuICAgIEBJbnB1dCgpIGRpc2FibGVkOiBib29sZWFuID0gZmFsc2U7XG4gICAgQElucHV0KCkgaGVhZGluZzogc3RyaW5nO1xuICAgIEBJbnB1dCgpIEBIb3N0QmluZGluZygnY2xhc3MucGFuZWwtb3BlbicpIGV4cGFuZGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBAT3V0cHV0KCkgZXhwYW5kZWRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgYWNjb3JkaW9uOiBBY2NvcmRpb25TZXJ2aWNlKSB7XG4gICAgICAgIGFjY29yZGlvbi5jb2xsYXBzZS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5jb2xsYXBzZSgpKTtcbiAgICB9XG5cbiAgICB0b2dnbGUoKTogdm9pZCB7XG5cbiAgICAgICAgaWYgKHRoaXMuZXhwYW5kZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY29sbGFwc2UoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIGlmIHdlIHNob3VsZCBjb2xsYXBzZSBvdGhlcnNcbiAgICAgICAgaWYgKHRoaXMuYWNjb3JkaW9uLmNvbGxhcHNlT3RoZXJzKSB7XG4gICAgICAgICAgICB0aGlzLmFjY29yZGlvbi5jb2xsYXBzZUFsbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc3RvcmUgdGhlIG5ldyBleHBhbmRlZCBzdGF0ZVxuICAgICAgICB0aGlzLmV4cGFuZCgpO1xuICAgIH1cblxuICAgIGV4cGFuZCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQgPT09IGZhbHNlICYmIHRoaXMuZXhwYW5kZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLmV4cGFuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZXhwYW5kZWRDaGFuZ2UubmV4dCh0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbGxhcHNlKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCA9PT0gZmFsc2UgJiYgdGhpcy5leHBhbmRlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5leHBhbmRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5leHBhbmRlZENoYW5nZS5uZXh0KGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cblxufSIsImltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEFjY29yZGlvblNlcnZpY2UgfSBmcm9tICcuL2FjY29yZGlvbi5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1hY2NvcmRpb24nLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9hY2NvcmRpb24uY29tcG9uZW50Lmh0bWwnLFxuICAgIHByb3ZpZGVyczogWyBBY2NvcmRpb25TZXJ2aWNlIF0sXG4gICAgaG9zdDoge1xuICAgICAgICAnY2xhc3MnOiAncGFuZWwtZ3JvdXAnLFxuICAgICAgICAncm9sZSc6ICd0YWJsaXN0JyxcbiAgICAgICAgJ2FyaWEtbXVsdGlzZWxlY3RhYmxlJzogJ3RydWUnXG4gICAgfVxufSlcbmV4cG9ydCBjbGFzcyBBY2NvcmRpb25Db21wb25lbnQge1xuXG4gICAgQElucHV0KCkgc2V0IGNvbGxhcHNlT3RoZXJzKGNvbGxhcHNlT3RoZXJzOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuX2FjY29yZGlvbi5jb2xsYXBzZU90aGVycyA9IGNvbGxhcHNlT3RoZXJzO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX2FjY29yZGlvbjogQWNjb3JkaW9uU2VydmljZSkgeyB9XG59IiwiaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBBY2NvcmRpb25QYW5lbEhlYWRpbmdEaXJlY3RpdmUgfSBmcm9tICcuL2FjY29yZGlvbi1wYW5lbC9hY2NvcmRpb24tcGFuZWwtaGVhZGluZy5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgQWNjb3JkaW9uUGFuZWxDb21wb25lbnQgfSBmcm9tICcuL2FjY29yZGlvbi1wYW5lbC9hY2NvcmRpb24tcGFuZWwuY29tcG9uZW50JztcbmltcG9ydCB7IEFjY29yZGlvbkNvbXBvbmVudCB9IGZyb20gJy4vYWNjb3JkaW9uLmNvbXBvbmVudCc7XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGVcbiAgICBdLFxuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBBY2NvcmRpb25Db21wb25lbnQsXG4gICAgICAgIEFjY29yZGlvblBhbmVsQ29tcG9uZW50LFxuICAgICAgICBBY2NvcmRpb25QYW5lbEhlYWRpbmdEaXJlY3RpdmVcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgQWNjb3JkaW9uQ29tcG9uZW50LFxuICAgICAgICBBY2NvcmRpb25QYW5lbENvbXBvbmVudCxcbiAgICAgICAgQWNjb3JkaW9uUGFuZWxIZWFkaW5nRGlyZWN0aXZlXG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBBY2NvcmRpb25Nb2R1bGUgeyB9IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LWJyZWFkY3J1bWJzJyxcbiAgICB0ZW1wbGF0ZVVybDogJ2JyZWFkY3J1bWJzLmNvbXBvbmVudC5odG1sJ1xufSlcblxuZXhwb3J0IGNsYXNzIEJyZWFkY3J1bWJzQ29tcG9uZW50IHtcblxuICAgIEBJbnB1dCgpIGNydW1iczogQnJlYWRjcnVtYltdO1xuXG4gICAgY2xpY2tDcnVtYihldmVudDogTW91c2VFdmVudCwgY3J1bWI6IEJyZWFkY3J1bWIpIHtcbiAgICAgICAgaWYgKGNydW1iLm9uQ2xpY2spIHtcbiAgICAgICAgICAgIGNydW1iLm9uQ2xpY2suY2FsbChudWxsLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQnJlYWRjcnVtYiB7XG4gICAgdGl0bGU6IHN0cmluZztcbiAgICByb3V0ZXJMaW5rPzogc3RyaW5nO1xuICAgIGZyYWdtZW50Pzogc3RyaW5nO1xuICAgIHF1ZXJ5UGFyYW1zPzogYW55O1xuICAgIG9uQ2xpY2s/OiAoZXZlbnQ6IE1vdXNlRXZlbnQpID0+IHZvaWQ7XG59IiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQnJlYWRjcnVtYnNDb21wb25lbnQgfSBmcm9tICcuL2JyZWFkY3J1bWJzLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgUm91dGVyTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSwgXG4gICAgICAgIFJvdXRlck1vZHVsZVxuICAgIF0sXG4gICAgZXhwb3J0czogW0JyZWFkY3J1bWJzQ29tcG9uZW50XSxcbiAgICBkZWNsYXJhdGlvbnM6IFtCcmVhZGNydW1ic0NvbXBvbmVudF1cbn0pXG5leHBvcnQgY2xhc3MgQnJlYWRjcnVtYnNNb2R1bGUgeyB9XG4iLCIvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG50aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxyXG5MaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG5LSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXHJcbldBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXHJcbk1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG5TZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcclxuYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMClcclxuICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3BhcmFtKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IHlbb3BbMF0gJiAyID8gXCJyZXR1cm5cIiA6IG9wWzBdID8gXCJ0aHJvd1wiIDogXCJuZXh0XCJdKSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFswLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgZXhwb3J0cykge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX192YWx1ZXMobykge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZWFkKG8sIG4pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkKCkge1xyXG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyAgfVxyXG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0RlbGVnYXRvcihvKSB7XHJcbiAgICB2YXIgaSwgcDtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaWYgKG9bbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gKHAgPSAhcCkgPyB7IHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLCBkb25lOiBuID09PSBcInJldHVyblwiIH0gOiBmID8gZih2KSA6IHY7IH07IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl07XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWFrZVRlbXBsYXRlT2JqZWN0KGNvb2tlZCwgcmF3KSB7XHJcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgcmV0dXJuIGNvb2tlZDtcclxufTtcclxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSwgTmdab25lLCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCBSZXNpemVPYnNlcnZlciBmcm9tICdyZXNpemUtb2JzZXJ2ZXItcG9seWZpbGwnO1xuaW1wb3J0IHsgUmVwbGF5U3ViamVjdCB9IGZyb20gJ3J4anMvUmVwbGF5U3ViamVjdCc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBSZXNpemVTZXJ2aWNlIGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICAgIHByaXZhdGUgX29ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKHRoaXMuZWxlbWVudERpZFJlc2l6ZS5iaW5kKHRoaXMpKTtcbiAgICBwcml2YXRlIF90YXJnZXRzID0gbmV3IFdlYWtNYXA8SFRNTEVsZW1lbnQsIFJlcGxheVN1YmplY3Q8UmVzaXplRGltZW5zaW9ucz4+KCk7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF96b25lOiBOZ1pvbmUpIHt9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIH1cblxuICAgIGFkZFJlc2l6ZUxpc3RlbmVyKHRhcmdldDogSFRNTEVsZW1lbnQpOiBSZXBsYXlTdWJqZWN0PFJlc2l6ZURpbWVuc2lvbnM+IHtcbiAgICAgICAgdGhpcy5fem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB0aGlzLl9vYnNlcnZlci5vYnNlcnZlKHRhcmdldCkpO1xuXG4gICAgICAgIGlmICh0aGlzLl90YXJnZXRzLmhhcyh0YXJnZXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGFyZ2V0cy5nZXQodGFyZ2V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGVtaXR0ZXIgPSBuZXcgUmVwbGF5U3ViamVjdDxSZXNpemVEaW1lbnNpb25zPigpO1xuICAgICAgICAgICAgdGhpcy5fdGFyZ2V0cy5zZXQodGFyZ2V0LCBlbWl0dGVyKTtcbiAgICAgICAgICAgIHJldHVybiBlbWl0dGVyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVtb3ZlUmVzaXplTGlzdGVuZXIodGFyZ2V0OiBIVE1MRWxlbWVudCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9vYnNlcnZlci51bm9ic2VydmUodGFyZ2V0KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGVsZW1lbnREaWRSZXNpemUoZW50cmllczogUmVzaXplT2JzZXJ2ZXJFbnRyeVtdKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl90YXJnZXRzLmhhcyhlbnRyeS50YXJnZXQgYXMgSFRNTEVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVtaXR0ZXIgPSB0aGlzLl90YXJnZXRzLmdldChlbnRyeS50YXJnZXQgYXMgSFRNTEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICBlbWl0dGVyLm5leHQoeyB3aWR0aDogKGVudHJ5LnRhcmdldCBhcyBIVE1MRWxlbWVudCkub2Zmc2V0V2lkdGgsIGhlaWdodDogKGVudHJ5LnRhcmdldCBhcyBIVE1MRWxlbWVudCkub2Zmc2V0SGVpZ2h0IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlc2l6ZURpbWVuc2lvbnMge1xuICAgIHdpZHRoOiBudW1iZXI7XG4gICAgaGVpZ2h0OiBudW1iZXI7XG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIElucHV0LCBOZ1pvbmUsIE9uRGVzdHJveSwgT25Jbml0LCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGRlYm91bmNlVGltZSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IFJlc2l6ZURpbWVuc2lvbnMsIFJlc2l6ZVNlcnZpY2UgfSBmcm9tICcuL3Jlc2l6ZS5zZXJ2aWNlJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbdXhSZXNpemVdJyxcbiAgICBwcm92aWRlcnM6IFtSZXNpemVTZXJ2aWNlXVxufSlcbmV4cG9ydCBjbGFzcyBSZXNpemVEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG5cbiAgICBASW5wdXQoKSB0aHJvdHRsZTogbnVtYmVyID0gMDtcbiAgICBAT3V0cHV0KCkgdXhSZXNpemU6IEV2ZW50RW1pdHRlcjxSZXNpemVEaW1lbnNpb25zPiA9IG5ldyBFdmVudEVtaXR0ZXI8UmVzaXplRGltZW5zaW9ucz4oKTtcblxuICAgIHByaXZhdGUgX3N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZiwgcHJpdmF0ZSBfcmVzaXplU2VydmljZTogUmVzaXplU2VydmljZSwgcHJpdmF0ZSBfbmdab25lOiBOZ1pvbmUpIHsgfVxuXG4gICAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IHRoaXMuX3Jlc2l6ZVNlcnZpY2UuYWRkUmVzaXplTGlzdGVuZXIodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50KVxuICAgICAgICAgICAgLnBpcGUoZGVib3VuY2VUaW1lKHRoaXMudGhyb3R0bGUpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoZXZlbnQ6IFJlc2l6ZURpbWVuc2lvbnMpID0+IHRoaXMuX25nWm9uZS5ydW4oKCkgPT4gdGhpcy51eFJlc2l6ZS5lbWl0KGV2ZW50KSkpO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9yZXNpemVTZXJ2aWNlLnJlbW92ZVJlc2l6ZUxpc3RlbmVyKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCk7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBSZXNpemVEaXJlY3RpdmUgfSBmcm9tICcuL3Jlc2l6ZS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgUmVzaXplU2VydmljZSB9IGZyb20gJy4vcmVzaXplLnNlcnZpY2UnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGV4cG9ydHM6IFtSZXNpemVEaXJlY3RpdmVdLFxuICAgIGRlY2xhcmF0aW9uczogW1Jlc2l6ZURpcmVjdGl2ZV0sXG4gICAgcHJvdmlkZXJzOiBbUmVzaXplU2VydmljZV1cbn0pXG5leHBvcnQgY2xhc3MgUmVzaXplTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgRGlyZWN0aXZlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1t1eENhcmRUYWJDb250ZW50XSdcbn0pXG5leHBvcnQgY2xhc3MgQ2FyZFRhYkNvbnRlbnREaXJlY3RpdmUgeyB9XG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IGZpbHRlciB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IENhcmRUYWJDb21wb25lbnQgfSBmcm9tICcuL2NhcmQtdGFiL2NhcmQtdGFiLmNvbXBvbmVudCc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBDYXJkVGFic1NlcnZpY2UgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuXG4gIHRhYiQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PENhcmRUYWJDb21wb25lbnQ+KG51bGwpO1xuICB0YWJzJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8Q2FyZFRhYkNvbXBvbmVudFtdPihbXSk7XG4gIHBvc2l0aW9uJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8c3RyaW5nPigndG9wJyk7XG5cbiAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgY29uc3RydWN0b3IoKSB7XG5cbiAgICAvLyB3aGVuIGEgdGFiIGlzIGFkZGVkIG9yIHJlbW92ZWQgZW5zdXJlIHdlIGFsd2F5cyBzZWxlY3Qgb25lIGlmIGFueSBhcmUgYXZhaWxhYmxlXG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gdGhpcy50YWJzJC5waXBlKFxuICAgICAgZmlsdGVyKHRhYnMgPT4gIXRoaXMudGFiJC52YWx1ZSB8fCAhdGFicy5maW5kKHRhYiA9PiB0YWIgPT09IHRoaXMudGFiJC52YWx1ZSkpLFxuICAgICkuc3Vic2NyaWJlKHRhYnMgPT4gdGhpcy50YWIkLm5leHQodGFicy5sZW5ndGggPiAwID8gdGFic1swXSA6IG51bGwpKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIHRhYiB0byB0aGUgbGlzdCBvZiB0YWJzXG4gICAqL1xuICBhZGRUYWIodGFiOiBDYXJkVGFiQ29tcG9uZW50KTogdm9pZCB7XG4gICAgdGhpcy50YWJzJC5uZXh0KFsuLi50aGlzLnRhYnMkLnZhbHVlLCB0YWJdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSB0YWIgZnJvbSB0aGUgbGlzdFxuICAgKi9cbiAgcmVtb3ZlVGFiKHRhYjogQ2FyZFRhYkNvbXBvbmVudCk6IHZvaWQge1xuICAgIHRoaXMudGFicyQubmV4dCh0aGlzLnRhYnMkLnZhbHVlLmZpbHRlcihfdGFiID0+IF90YWIgIT09IHRhYikpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbGVjdCB0aGUgdGFiXG4gICAqL1xuICBzZWxlY3QodGFiOiBDYXJkVGFiQ29tcG9uZW50KTogdm9pZCB7XG4gICAgdGhpcy50YWIkLm5leHQodGFiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSB0YWIgY29udGVudFxuICAgKi9cbiAgc2V0UG9zaXRpb24ocG9zaXRpb246IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMucG9zaXRpb24kLm5leHQocG9zaXRpb24pO1xuICB9XG59XG4iLCJpbXBvcnQgeyBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgQ29tcG9uZW50LCBDb250ZW50Q2hpbGQsIE9uRGVzdHJveSwgVGVtcGxhdGVSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzL09ic2VydmFibGUnO1xuaW1wb3J0IHsgbWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgQ2FyZFRhYnNTZXJ2aWNlIH0gZnJvbSAnLi4vY2FyZC10YWJzLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ2FyZFRhYkNvbnRlbnREaXJlY3RpdmUgfSBmcm9tICcuL2NhcmQtdGFiLWNvbnRlbnQuZGlyZWN0aXZlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAndXgtY2FyZC10YWInLFxuICB0ZW1wbGF0ZVVybDogJy4vY2FyZC10YWIuY29tcG9uZW50Lmh0bWwnLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxufSlcbmV4cG9ydCBjbGFzcyBDYXJkVGFiQ29tcG9uZW50IGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICBhY3RpdmUkOiBPYnNlcnZhYmxlPGJvb2xlYW4+ID0gdGhpcy5fdGFiU2VydmljZS50YWIkLnBpcGUobWFwKHRhYiA9PiB0YWIgPT09IHRoaXMpKTtcbiAgQENvbnRlbnRDaGlsZChDYXJkVGFiQ29udGVudERpcmVjdGl2ZSwgeyByZWFkOiBUZW1wbGF0ZVJlZiB9KSBjb250ZW50OiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX3RhYlNlcnZpY2U6IENhcmRUYWJzU2VydmljZSkge1xuICAgIHRoaXMuX3RhYlNlcnZpY2UuYWRkVGFiKHRoaXMpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5fdGFiU2VydmljZS5yZW1vdmVUYWIodGhpcyk7XG4gIH1cblxufVxuIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBIb3N0QmluZGluZywgSW5wdXQsIFZpZXdDaGlsZCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUmVzaXplRGltZW5zaW9ucyB9IGZyb20gJy4uLy4uLy4uL2RpcmVjdGl2ZXMvcmVzaXplJztcbmltcG9ydCB7IENhcmRUYWJDb21wb25lbnQgfSBmcm9tICcuLi9jYXJkLXRhYi9jYXJkLXRhYi5jb21wb25lbnQnO1xuaW1wb3J0IHsgQ2FyZFRhYnNTZXJ2aWNlIH0gZnJvbSAnLi4vY2FyZC10YWJzLnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICd1eC1jYXJkLXRhYnNldCcsXG4gIHRlbXBsYXRlVXJsOiAnLi9jYXJkLXRhYnNldC5jb21wb25lbnQuaHRtbCcsXG4gIHByb3ZpZGVyczogW0NhcmRUYWJzU2VydmljZV1cbn0pXG5leHBvcnQgY2xhc3MgQ2FyZFRhYnNldENvbXBvbmVudCB7XG5cbiAgQEhvc3RCaW5kaW5nKCdjbGFzcycpXG4gIEBJbnB1dCgpIHNldCBwb3NpdGlvbihkaXJlY3Rpb246IHN0cmluZykge1xuICAgIHRoaXMudGFiU2VydmljZS5zZXRQb3NpdGlvbihkaXJlY3Rpb24pO1xuICB9XG5cbiAgZ2V0IHBvc2l0aW9uKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMudGFiU2VydmljZS5wb3NpdGlvbiQuZ2V0VmFsdWUoKTtcbiAgfVxuXG4gIEBWaWV3Q2hpbGQoJ3RhYmxpc3QnKSB0YWJsaXN0OiBFbGVtZW50UmVmO1xuXG4gIG9mZnNldDogbnVtYmVyID0gMDtcbiAgYm91bmRzOiBDYXJkVGFic0JvdW5kcyA9IHsgbG93ZXI6IDAsIHVwcGVyOiAwIH07XG5cbiAgcHJpdmF0ZSBfd2lkdGg6IG51bWJlcjtcbiAgcHJpdmF0ZSBfaW5uZXJXaWR0aDogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyB0YWJTZXJ2aWNlOiBDYXJkVGFic1NlcnZpY2UpIHt9XG5cbiAgc2VsZWN0KHRhYjogQ2FyZFRhYkNvbXBvbmVudCwgZWxlbWVudDogSFRNTEVsZW1lbnQpOiB2b2lkIHtcbiAgICAvLyBzZWxlY3QgdGhlIHRhYlxuICAgIHRoaXMudGFiU2VydmljZS5zZWxlY3QodGFiKTtcblxuICAgIC8vIGVuc3VyZSB0aGUgdGFiIGlzIG1vdmVkIGludG8gdmlldyBpZiByZXF1aXJlZFxuICAgIHRoaXMubW92ZUludG9WaWV3KGVsZW1lbnQpO1xuICB9XG5cbiAgcmVzaXplKGRpbWVuc2lvbnM6IFJlc2l6ZURpbWVuc2lvbnMpOiB2b2lkIHtcbiAgICB0aGlzLl93aWR0aCA9IGRpbWVuc2lvbnMud2lkdGg7XG4gICAgdGhpcy5faW5uZXJXaWR0aCA9IHRoaXMudGFibGlzdC5uYXRpdmVFbGVtZW50LnNjcm9sbFdpZHRoO1xuXG4gICAgdGhpcy5ib3VuZHMubG93ZXIgPSAwO1xuICAgIHRoaXMuYm91bmRzLnVwcGVyID0gLSh0aGlzLl9pbm5lcldpZHRoIC0gdGhpcy5fd2lkdGgpO1xuICB9XG5cbiAgcHJldmlvdXMoKTogdm9pZCB7XG4gICAgdGhpcy5vZmZzZXQgKz0gdGhpcy5fd2lkdGg7XG5cbiAgICAvLyBlbnN1cmUgaXQgcmVtYWlucyB3aXRoaW4gdGhlIGFsbG93ZWQgYm91bmRzXG4gICAgdGhpcy5vZmZzZXQgPSBNYXRoLm1pbih0aGlzLm9mZnNldCwgdGhpcy5ib3VuZHMubG93ZXIpO1xuICB9XG5cbiAgbmV4dCgpOiB2b2lkIHtcbiAgICB0aGlzLm9mZnNldCAtPSB0aGlzLl93aWR0aDtcblxuICAgIC8vIGVuc3VyZSBpdCByZW1haW5zIHdpdGhpbiB0aGUgYWxsb3dlZCBib3VuZHNcbiAgICB0aGlzLm9mZnNldCA9IE1hdGgubWF4KHRoaXMub2Zmc2V0LCB0aGlzLmJvdW5kcy51cHBlcik7XG4gIH1cblxuICBwcml2YXRlIG1vdmVJbnRvVmlldyhlbGVtZW50OiBIVE1MRWxlbWVudCk6IHZvaWQge1xuXG4gICAgLy8gaWYgd2UgZG9udCBoYXZlIHRoZSBkaW1lbnNpb25zIHdlIGNhbnQgY2hlY2tcbiAgICBpZiAoIXRoaXMuX3dpZHRoIHx8ICF0aGlzLl9pbm5lcldpZHRoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gZ2V0IHRoZSBjdXJyZW50IGVsZW1lbnQgYm91bmRzXG4gICAgY29uc3QgeyBvZmZzZXRMZWZ0LCBvZmZzZXRXaWR0aCB9ID0gZWxlbWVudDtcbiAgICBjb25zdCB7IG1hcmdpbkxlZnQsIG1hcmdpblJpZ2h0IH0gPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuXG4gICAgLy8gY2FsY3VsYXRlIHRoZSB2aXNpYmxlIGFyZWFcbiAgICBjb25zdCB2aWV3cG9ydFN0YXJ0ID0gTWF0aC5hYnModGhpcy5vZmZzZXQpO1xuICAgIGNvbnN0IHZpZXdwb3J0RW5kID0gdmlld3BvcnRTdGFydCArIHRoaXMuX3dpZHRoO1xuICAgIGNvbnN0IGNhcmRXaWR0aCA9IHBhcnNlRmxvYXQobWFyZ2luTGVmdCkgKyBvZmZzZXRXaWR0aCArIHBhcnNlRmxvYXQobWFyZ2luUmlnaHQpO1xuXG4gICAgLy8gaWYgd2UgbmVlZCB0byBtb3ZlIHRvIHRoZSBsZWZ0IC0gZmlndXJlIG91dCBob3cgbXVjaFxuICAgIGlmIChvZmZzZXRMZWZ0IDwgdmlld3BvcnRTdGFydCkge1xuICAgICAgdGhpcy5vZmZzZXQgLT0gKG9mZnNldExlZnQgLSBwYXJzZUZsb2F0KG1hcmdpbkxlZnQpKSAtIHZpZXdwb3J0U3RhcnQ7XG4gICAgfVxuICAgIFxuICAgIC8vIGlmIHdlIG5lZWQgdG8gbW92ZSB0byB0aGUgcmlnaHQgLSBmaWd1cmUgb3V0IGhvdyBtdWNoXG4gICAgaWYgKChvZmZzZXRMZWZ0ICsgY2FyZFdpZHRoKSA+IHZpZXdwb3J0RW5kKSB7XG4gICAgICB0aGlzLm9mZnNldCAtPSAob2Zmc2V0TGVmdCArIGNhcmRXaWR0aCkgLSB2aWV3cG9ydEVuZDtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBDYXJkVGFic0JvdW5kcyB7XG4gIGxvd2VyOiBudW1iZXI7XG4gIHVwcGVyOiBudW1iZXI7XG59XG4iLCJpbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xyXG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBSZXNpemVNb2R1bGUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL3Jlc2l6ZS9pbmRleCc7XHJcbmltcG9ydCB7IENhcmRUYWJDb250ZW50RGlyZWN0aXZlIH0gZnJvbSAnLi9jYXJkLXRhYi9jYXJkLXRhYi1jb250ZW50LmRpcmVjdGl2ZSc7XHJcbmltcG9ydCB7IENhcmRUYWJDb21wb25lbnQgfSBmcm9tICcuL2NhcmQtdGFiL2NhcmQtdGFiLmNvbXBvbmVudCc7XHJcbmltcG9ydCB7IENhcmRUYWJzZXRDb21wb25lbnQgfSBmcm9tICcuL2NhcmQtdGFic2V0L2NhcmQtdGFic2V0LmNvbXBvbmVudCc7XHJcblxyXG5ATmdNb2R1bGUoe1xyXG4gIGltcG9ydHM6IFtcclxuICAgIENvbW1vbk1vZHVsZSxcclxuICAgIFJlc2l6ZU1vZHVsZVxyXG4gIF0sXHJcbiAgZGVjbGFyYXRpb25zOiBbQ2FyZFRhYnNldENvbXBvbmVudCwgQ2FyZFRhYkNvbXBvbmVudCwgQ2FyZFRhYkNvbnRlbnREaXJlY3RpdmVdLFxyXG4gIGV4cG9ydHM6IFtDYXJkVGFic2V0Q29tcG9uZW50LCBDYXJkVGFiQ29tcG9uZW50LCBDYXJkVGFiQ29udGVudERpcmVjdGl2ZV1cclxufSlcclxuZXhwb3J0IGNsYXNzIENhcmRUYWJzTW9kdWxlIHsgfVxyXG4iLCJpbXBvcnQgeyBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE91dHB1dCwgZm9yd2FyZFJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29udHJvbFZhbHVlQWNjZXNzb3IsIE5HX1ZBTFVFX0FDQ0VTU09SIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5leHBvcnQgY29uc3QgQ0hFQ0tCT1hfVkFMVUVfQUNDRVNTT1I6IGFueSA9IHtcbiAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBDaGVja2JveENvbXBvbmVudCksXG4gICAgbXVsdGk6IHRydWVcbn07XG5cbmxldCB1bmlxdWVDaGVja2JveElkID0gMDtcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1jaGVja2JveCcsXG4gICAgdGVtcGxhdGVVcmw6ICcuL2NoZWNrYm94LmNvbXBvbmVudC5odG1sJyxcbiAgICBwcm92aWRlcnM6IFtDSEVDS0JPWF9WQUxVRV9BQ0NFU1NPUl1cbn0pXG5leHBvcnQgY2xhc3MgQ2hlY2tib3hDb21wb25lbnQgaW1wbGVtZW50cyBDb250cm9sVmFsdWVBY2Nlc3NvciB7XG5cbiAgICBwcml2YXRlIF9jaGVja2JveElkOiBzdHJpbmcgPSBgdXgtY2hlY2tib3gtJHsrK3VuaXF1ZUNoZWNrYm94SWR9YDtcblxuICAgIEBJbnB1dCgpIGlkOiBzdHJpbmcgPSB0aGlzLl9jaGVja2JveElkO1xuICAgIEBJbnB1dCgpIG5hbWU6IHN0cmluZyB8IG51bGw7XG4gICAgQElucHV0KCkgcmVxdWlyZWQ6IGJvb2xlYW47XG4gICAgQElucHV0KCkgdGFiaW5kZXg6IG51bWJlciA9IDA7XG4gICAgQElucHV0KCkgY2xpY2thYmxlOiBib29sZWFuID0gdHJ1ZTtcbiAgICBASW5wdXQoKSBzaW1wbGlmaWVkOiBib29sZWFuID0gZmFsc2U7XG4gICAgQElucHV0KCkgaW5kZXRlcm1pbmF0ZVZhbHVlOiBhbnkgPSAtMTtcbiAgICBASW5wdXQoKSBkaXNhYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIEBJbnB1dCgnYXJpYS1sYWJlbCcpIGFyaWFMYWJlbDogc3RyaW5nID0gJyc7XG4gICAgQElucHV0KCdhcmlhLWxhYmVsbGVkYnknKSBhcmlhTGFiZWxsZWRieTogc3RyaW5nID0gbnVsbDtcblxuICAgIEBPdXRwdXQoKSB2YWx1ZUNoYW5nZTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuICAgIEBJbnB1dCgpXG4gICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgfVxuXG4gICAgc2V0IHZhbHVlKHZhbHVlOiBhbnkpIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcblxuICAgICAgICAvLyBkZXRlcm1pbmUgaWYgaXQgaXMgaW4gdGhlIGluZGV0ZXJtaW5hdGUgc3RhdGVcbiAgICAgICAgdGhpcy5pbmRldGVybWluYXRlID0gdGhpcy5fdmFsdWUgPT09IHRoaXMuaW5kZXRlcm1pbmF0ZVZhbHVlO1xuXG4gICAgICAgIC8vIGRldGVybWluZSB0aGUgY2hlY2tlZCBzdGF0ZVxuICAgICAgICB0aGlzLmFyaWFDaGVja2VkID0gdGhpcy5pbmRldGVybWluYXRlID8gJ21peGVkJyA6IHRoaXMuX3ZhbHVlO1xuXG4gICAgICAgIC8vIGludm9rZSBjaGFuZ2UgZXZlbnRcbiAgICAgICAgdGhpcy52YWx1ZUNoYW5nZS5lbWl0KHRoaXMuX3ZhbHVlKTtcblxuICAgICAgICAvLyBjYWxsIGNhbGxiYWNrXG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjayh0aGlzLl92YWx1ZSk7XG4gICAgICAgIHRoaXMub25Ub3VjaGVkQ2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICBnZXQgaW5wdXRJZCgpOiBzdHJpbmcgeyBcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuaWQgfHwgdGhpcy5fY2hlY2tib3hJZH0taW5wdXRgO1xuICAgIH1cblxuICAgIHByaXZhdGUgX3ZhbHVlOiBhbnkgPSBmYWxzZTtcblxuICAgIGluZGV0ZXJtaW5hdGU6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBhcmlhQ2hlY2tlZDogYm9vbGVhbiB8IHN0cmluZztcbiAgICBmb2N1c2VkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBvblRvdWNoZWRDYWxsYmFjazogKCkgPT4gdm9pZCA9ICgpID0+IHsgfTtcbiAgICBvbkNoYW5nZUNhbGxiYWNrOiAoXzogYW55KSA9PiB2b2lkID0gKCkgPT4geyB9O1xuXG4gICAgdG9nZ2xlKCk6IHZvaWQge1xuXG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkIHx8ICF0aGlzLmNsaWNrYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMudmFsdWUgPT09IHRoaXMuaW5kZXRlcm1pbmF0ZVZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRvZ2dsZSB0aGUgY2hlY2tlZCBzdGF0ZVxuICAgICAgICB0aGlzLnZhbHVlID0gIXRoaXMudmFsdWU7XG4gICAgfVxuXG4gICAgLy8gRnVuY3Rpb25zIHJlcXVpcmVkIHRvIHVwZGF0ZSBuZ01vZGVsXG5cbiAgICB3cml0ZVZhbHVlKHZhbHVlOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLl92YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm46IGFueSk6IHZvaWQge1xuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2sgPSBmbjtcbiAgICB9XG5cbiAgICByZWdpc3Rlck9uVG91Y2hlZChmbjogYW55KTogdm9pZCB7XG4gICAgICAgIHRoaXMub25Ub3VjaGVkQ2FsbGJhY2sgPSBmbjtcbiAgICB9XG5cbiAgICBzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQ6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGlzRGlzYWJsZWQ7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7Rm9ybXNNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuaW1wb3J0IHsgQ2hlY2tib3hDb21wb25lbnQgfSBmcm9tICcuL2NoZWNrYm94LmNvbXBvbmVudCc7XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW0Zvcm1zTW9kdWxlXSxcbiAgICBleHBvcnRzOiBbQ2hlY2tib3hDb21wb25lbnRdLFxuICAgIGRlY2xhcmF0aW9uczogW0NoZWNrYm94Q29tcG9uZW50XVxufSlcbmV4cG9ydCBjbGFzcyBDaGVja2JveE1vZHVsZSB7IH1cbiIsImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbG9yQ2xhc3NTZXQsIENvbG9yVmFsdWVTZXQgfSBmcm9tICcuL2NvbG9yLnNlcnZpY2UnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgQ29sb3JTZXJ2aWNlIHtcblxuICAgIHByaXZhdGUgX2h0bWw6IHN0cmluZztcbiAgICBwcml2YXRlIF9lbGVtZW50OiBIVE1MRWxlbWVudDtcbiAgICBwcml2YXRlIF9jb2xvcnM6IFRoZW1lQ29sb3JzO1xuICAgIHByaXZhdGUgX2NvbG9yU2V0OiBhbnkgPSBjb2xvclNldHMua2VwcGVsO1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jb2xvclNldC5jb2xvckNsYXNzU2V0KSB7XG4gICAgICAgICAgICB0aGlzLnNldENvbG9ycygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIHRoaXMuX2NvbG9yU2V0LmNvbG9yVmFsdWVTZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb2xvcnNba2V5XSA9IHRoaXMuZ2V0Q29sb3JWYWx1ZUJ5SGV4KHRoaXMuX2NvbG9yU2V0LmNvbG9yVmFsdWVTZXRba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHNldENvbG9ycygpIHtcblxuICAgICAgICB0aGlzLl9odG1sID0gJyc7XG5cbiAgICAgICAgZm9yIChsZXQga2V5IGluIHRoaXMuX2NvbG9yU2V0LmNvbG9yQ2xhc3NTZXQpIHtcbiAgICAgICAgICAgIHRoaXMuX2h0bWwgKz0gJzxkaXYgY2xhc3M9XCInICsgdGhpcy5fY29sb3JTZXQuY29sb3JDbGFzc1NldFtrZXldICsgJy1jb2xvclwiPjwvZGl2Pic7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9lbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NOYW1lID0gJ2NvbG9yLWNoYXJ0JztcbiAgICAgICAgdGhpcy5fZWxlbWVudC5pbm5lckhUTUwgPSB0aGlzLl9odG1sO1xuXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5fZWxlbWVudCk7XG5cbiAgICAgICAgdGhpcy5fY29sb3JzID0ge307XG5cbiAgICAgICAgZm9yIChsZXQga2V5IGluIHRoaXMuX2NvbG9yU2V0LmNvbG9yQ2xhc3NTZXQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbG9yc1trZXldID0gdGhpcy5nZXRDb2xvclZhbHVlKHRoaXMuX2NvbG9yU2V0LmNvbG9yQ2xhc3NTZXRba2V5XSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5fZWxlbWVudCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRDb2xvclZhbHVlQnlIZXgoY29sb3I6IHN0cmluZyk6IFRoZW1lQ29sb3Ige1xuICAgICAgICBjb25zdCBoZXggPSBjb2xvci5yZXBsYWNlKCcjJywgJycpO1xuXG4gICAgICAgIGNvbnN0IHIgPSBwYXJzZUludChoZXguc3Vic3RyaW5nKDAsIDIpLCAxNikudG9TdHJpbmcoKTtcbiAgICAgICAgY29uc3QgZyA9IHBhcnNlSW50KGhleC5zdWJzdHJpbmcoMiwgNCksIDE2KS50b1N0cmluZygpO1xuICAgICAgICBjb25zdCBiID0gcGFyc2VJbnQoaGV4LnN1YnN0cmluZyg0LCA2KSwgMTYpLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBUaGVtZUNvbG9yKHIsIGcsIGIsICcxJyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRDb2xvclZhbHVlKGNvbG9yOiBDb2xvcklkZW50aWZpZXIpOiBUaGVtZUNvbG9yIHtcblxuICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLl9lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy4nICsgdGhpcy5fY29sb3JTZXQuY29sb3JDbGFzc1NldFtjb2xvcl0gKyAnLWNvbG9yJyk7XG5cbiAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2xvcicpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY29sb3JWYWx1ZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRhcmdldCkuYmFja2dyb3VuZENvbG9yO1xuXG4gICAgICAgIGNvbnN0IHJnYmEgPSBjb2xvclZhbHVlLm1hdGNoKC9ecmdiYT9cXCgoXFxkKyksXFxzKihcXGQrKSxcXHMqKFxcZCspKD86LFxccyooXFxkKyg/OlxcLlxcZCspPykpP1xcKSQvKTtcblxuICAgICAgICByZXR1cm4gbmV3IFRoZW1lQ29sb3IocmdiYVsxXSwgcmdiYVsyXSwgcmdiYVszXSwgcmdiYVs0XSk7XG4gICAgfVxuXG4gICAgZ2V0Q29sb3IoY29sb3I6IENvbG9ySWRlbnRpZmllcik6IFRoZW1lQ29sb3Ige1xuICAgICAgICBjb25zdCB0aGVtZUNvbG9yID0gdGhpcy5fY29sb3JzW3RoaXMucmVzb2x2ZUNvbG9yTmFtZShjb2xvcildO1xuICAgICAgICBpZiAoIXRoZW1lQ29sb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29sb3Igbm90IGZvdW5kOiAnICsgY29sb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBUaGVtZUNvbG9yKHRoZW1lQ29sb3IuZ2V0UmVkKCksIHRoZW1lQ29sb3IuZ2V0R3JlZW4oKSwgdGhlbWVDb2xvci5nZXRCbHVlKCksIHRoZW1lQ29sb3IuZ2V0QWxwaGEoKSk7XG4gICAgfVxuXG4gICAgZ2V0Q29sb3JTZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2xvclNldDtcbiAgICB9XG5cbiAgICBzZXRDb2xvclNldChjb2xvclNldDogQ29sb3JTZXQpIHtcbiAgICAgICAgdGhpcy5fY29sb3JTZXQgPSBjb2xvclNldDtcbiAgICAgICAgdGhpcy5fY29sb3JzID0ge307XG5cbiAgICAgICAgaWYgKHRoaXMuX2NvbG9yU2V0LmNvbG9yQ2xhc3NTZXQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q29sb3JzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgaW4gdGhpcy5fY29sb3JTZXQuY29sb3JWYWx1ZVNldCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbG9yc1trZXldID0gdGhpcy5nZXRDb2xvclZhbHVlQnlIZXgodGhpcy5fY29sb3JTZXQuY29sb3JWYWx1ZVNldFtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlc29sdmUodmFsdWU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvbG9yTmFtZSA9IHRoaXMucmVzb2x2ZUNvbG9yTmFtZSh2YWx1ZSk7XG5cbiAgICAgICAgZm9yIChsZXQgY29sb3IgaW4gdGhpcy5fY29sb3JzKSB7XG4gICAgICAgICAgICBpZiAoY29sb3JOYW1lID09PSBjb2xvci50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29sb3IoY29sb3JOYW1lKS50b1JnYmEoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXNvbHZlQ29sb3JOYW1lKHZhbHVlOiBzdHJpbmcgPSAnJyk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKC9cXHMrL2csICctJykudG9Mb3dlckNhc2UoKTtcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBUaGVtZUNvbG9yIHtcblxuICAgIHByaXZhdGUgX3I6IHN0cmluZztcbiAgICBwcml2YXRlIF9nOiBzdHJpbmc7XG4gICAgcHJpdmF0ZSBfYjogc3RyaW5nO1xuICAgIHByaXZhdGUgX2E6IHN0cmluZztcblxuICAgIGNvbnN0cnVjdG9yKHI6IHN0cmluZywgZzogc3RyaW5nLCBiOiBzdHJpbmcsIGE6IHN0cmluZykge1xuICAgICAgICB0aGlzLl9yID0gcjtcbiAgICAgICAgdGhpcy5fZyA9IGc7XG4gICAgICAgIHRoaXMuX2IgPSBiO1xuICAgICAgICB0aGlzLl9hID0gYSA9PT0gdW5kZWZpbmVkID8gJzEnIDogYTtcbiAgICB9XG5cbiAgICBzdGF0aWMgcGFyc2UodmFsdWU6IHN0cmluZyk6IFRoZW1lQ29sb3Ige1xuICAgICAgICBsZXQgciwgZywgYiwgYSA9ICcxJztcblxuICAgICAgICBjb25zdCByZ2JhUGF0dGVybiA9IC9ecmdiYT9cXCgoXFxkKyksXFxzKihcXGQrKSxcXHMqKFxcZCspKD86LFxccyooXFxkKyg/OlxcLlxcZCspPykpP1xcKSQvO1xuICAgICAgICBjb25zdCBzaG9ydEhleFBhdHRlcm4gPSAvXiM/KFthLWZcXGRdKShbYS1mXFxkXSkoW2EtZlxcZF0pJC9pO1xuICAgICAgICBjb25zdCBsb25nSGV4UGF0dGVybiA9IC9eIz8oW2EtZlxcZF17Mn0pKFthLWZcXGRdezJ9KShbYS1mXFxkXXsyfSkkL2k7XG5cbiAgICAgICAgY29uc3QgcmdiYU1hdGNoID0gdmFsdWUubWF0Y2gocmdiYVBhdHRlcm4pO1xuICAgICAgICBjb25zdCBzaG9ydEhleE1hdGNoID0gdmFsdWUubWF0Y2goc2hvcnRIZXhQYXR0ZXJuKTtcbiAgICAgICAgY29uc3QgbG9uZ0hleE1hdGNoID0gdmFsdWUubWF0Y2gobG9uZ0hleFBhdHRlcm4pO1xuXG4gICAgICAgIGlmIChyZ2JhTWF0Y2gpIHtcbiAgICAgICAgICAgIHIgPSByZ2JhTWF0Y2hbMV07XG4gICAgICAgICAgICBnID0gcmdiYU1hdGNoWzJdO1xuICAgICAgICAgICAgYiA9IHJnYmFNYXRjaFszXTtcbiAgICAgICAgICAgIGEgPSByZ2JhTWF0Y2hbNF0gPyByZ2JhTWF0Y2hbNF0gOiAnMSc7XG4gICAgICAgIH0gZWxzZSBpZiAobG9uZ0hleE1hdGNoKSB7XG4gICAgICAgICAgICByID0gcGFyc2VJbnQobG9uZ0hleE1hdGNoWzFdLCAxNikudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGcgPSBwYXJzZUludChsb25nSGV4TWF0Y2hbMl0sIDE2KS50b1N0cmluZygpO1xuICAgICAgICAgICAgYiA9IHBhcnNlSW50KGxvbmdIZXhNYXRjaFszXSwgMTYpLnRvU3RyaW5nKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2hvcnRIZXhNYXRjaCkge1xuICAgICAgICAgICAgciA9IHBhcnNlSW50KHNob3J0SGV4TWF0Y2hbMV0gKyBzaG9ydEhleE1hdGNoWzFdLCAxNikudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGcgPSBwYXJzZUludChzaG9ydEhleE1hdGNoWzJdICsgc2hvcnRIZXhNYXRjaFsyXSwgMTYpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBiID0gcGFyc2VJbnQoc2hvcnRIZXhNYXRjaFszXSArIHNob3J0SGV4TWF0Y2hbM10sIDE2KS50b1N0cmluZygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcGFyc2UgY29sb3IgLSAke3ZhbHVlfSBpcyBub3QgYSB2YWxpZCBjb2xvci5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFRoZW1lQ29sb3IociwgZywgYiwgYSk7XG4gICAgfVxuXG4gICAgdG9IZXgoKSB7XG4gICAgICAgIGxldCByZWQgPSBwYXJzZUludCh0aGlzLl9yKS50b1N0cmluZygxNik7XG4gICAgICAgIGxldCBncmVlbiA9IHBhcnNlSW50KHRoaXMuX2cpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgbGV0IGJsdWUgPSBwYXJzZUludCh0aGlzLl9iKS50b1N0cmluZygxNik7XG5cbiAgICAgICAgaWYgKHJlZC5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICByZWQgPSAnMCcgKyByZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyZWVuLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIGdyZWVuID0gJzAnICsgZ3JlZW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJsdWUubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgYmx1ZSA9ICcwJyArIGJsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJyMnICsgcmVkICsgZ3JlZW4gKyBibHVlO1xuICAgIH1cblxuICAgIHRvUmdiKCkge1xuICAgICAgICByZXR1cm4gJ3JnYignICsgdGhpcy5fciArICcsICcgKyB0aGlzLl9nICsgJywgJyArIHRoaXMuX2IgKyAnKSc7XG4gICAgfVxuXG4gICAgdG9SZ2JhKCkge1xuICAgICAgICByZXR1cm4gJ3JnYmEoJyArIHRoaXMuX3IgKyAnLCAnICsgdGhpcy5fZyArICcsICcgKyB0aGlzLl9iICsgJywgJyArIHRoaXMuX2EgKyAnKSc7XG4gICAgfVxuXG4gICAgZ2V0UmVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcjtcbiAgICB9XG5cbiAgICBnZXRHcmVlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2c7XG4gICAgfVxuXG4gICAgZ2V0Qmx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2I7XG4gICAgfVxuXG4gICAgZ2V0QWxwaGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hO1xuICAgIH1cblxuICAgIHNldFJlZChyZWQ6IHN0cmluZykge1xuICAgICAgICB0aGlzLl9yID0gcmVkO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBzZXRHcmVlbihncmVlbjogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuX2cgPSBncmVlbjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgc2V0Qmx1ZShibHVlOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5fYiA9IGJsdWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHNldEFscGhhKGFscGhhOiBzdHJpbmcgfCBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5fYSA9IGFscGhhLnRvU3RyaW5nKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cblxuZXhwb3J0IGNvbnN0IGNvbG9yU2V0cyA9IHtcbiAgICBrZXBwZWw6IHtcbiAgICAgICAgY29sb3JDbGFzc1NldDoge1xuICAgICAgICAgICAgJ3ByaW1hcnknOiAncHJpbWFyeScsXG4gICAgICAgICAgICAnYWNjZW50JzogJ2FjY2VudCcsXG4gICAgICAgICAgICAnc2Vjb25kYXJ5JzogJ3NlY29uZGFyeScsXG4gICAgICAgICAgICAnYWx0ZXJuYXRlMSc6ICdhbHRlcm5hdGUxJyxcbiAgICAgICAgICAgICdhbHRlcm5hdGUyJzogJ2FsdGVybmF0ZTInLFxuICAgICAgICAgICAgJ2FsdGVybmF0ZTMnOiAnYWx0ZXJuYXRlMycsXG4gICAgICAgICAgICAndmlicmFudDEnOiAndmlicmFudDEnLFxuICAgICAgICAgICAgJ3ZpYnJhbnQyJzogJ3ZpYnJhbnQyJyxcbiAgICAgICAgICAgICdncmV5MSc6ICdncmV5MScsXG4gICAgICAgICAgICAnZ3JleTInOiAnZ3JleTInLFxuICAgICAgICAgICAgJ2dyZXkzJzogJ2dyZXkzJyxcbiAgICAgICAgICAgICdncmV5NCc6ICdncmV5NCcsXG4gICAgICAgICAgICAnZ3JleTUnOiAnZ3JleTUnLFxuICAgICAgICAgICAgJ2dyZXk2JzogJ2dyZXk2JyxcbiAgICAgICAgICAgICdncmV5Nyc6ICdncmV5NycsXG4gICAgICAgICAgICAnZ3JleTgnOiAnZ3JleTgnLFxuICAgICAgICAgICAgJ2NoYXJ0MSc6ICdjaGFydDEnLFxuICAgICAgICAgICAgJ2NoYXJ0Mic6ICdjaGFydDInLFxuICAgICAgICAgICAgJ2NoYXJ0Myc6ICdjaGFydDMnLFxuICAgICAgICAgICAgJ2NoYXJ0NCc6ICdjaGFydDQnLFxuICAgICAgICAgICAgJ2NoYXJ0NSc6ICdjaGFydDUnLFxuICAgICAgICAgICAgJ2NoYXJ0Nic6ICdjaGFydDYnLFxuICAgICAgICAgICAgJ29rJzogJ29rJyxcbiAgICAgICAgICAgICd3YXJuaW5nJzogJ3dhcm5pbmcnLFxuICAgICAgICAgICAgJ2NyaXRpY2FsJzogJ2NyaXRpY2FsJyxcbiAgICAgICAgICAgICdwYXJ0aXRpb24xJzogJ3BhcnRpdGlvbjEnLFxuICAgICAgICAgICAgJ3BhcnRpdGlvbjknOiAncGFydGl0aW9uOScsXG4gICAgICAgICAgICAncGFydGl0aW9uMTAnOiAncGFydGl0aW9uMTAnLFxuICAgICAgICAgICAgJ3BhcnRpdGlvbjExJzogJ3BhcnRpdGlvbjExJyxcbiAgICAgICAgICAgICdwYXJ0aXRpb24xMic6ICdwYXJ0aXRpb24xMicsXG4gICAgICAgICAgICAncGFydGl0aW9uMTMnOiAncGFydGl0aW9uMTMnLFxuICAgICAgICAgICAgJ3BhcnRpdGlvbjE0JzogJ3BhcnRpdGlvbjE0JyxcbiAgICAgICAgICAgICdzb2NpYWwtY2hhcnQtbm9kZSc6ICdzb2NpYWwtY2hhcnQtbm9kZScsXG4gICAgICAgICAgICAnc29jaWFsLWNoYXJ0LWVkZ2UnOiAnc29jaWFsLWNoYXJ0LWVkZ2UnXG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1pY3JvRm9jdXM6IHtcbiAgICAgICAgJ2NvbG9yVmFsdWVTZXQnOiB7XG4gICAgICAgICAgICAnY2VydWxlYW4nOiAnIzE2NjhjMScsXG4gICAgICAgICAgICAnYXF1YSc6ICcjMjljZWZmJyxcbiAgICAgICAgICAgICdhcXVhbWFyaW5lJzogJyMyZmQ2YzMnLFxuICAgICAgICAgICAgJ2Z1Y2hzaWEnOiAnI2M2MTc5ZCcsXG4gICAgICAgICAgICAnaW5kaWdvJzogJyM3NDI1YWQnLFxuICAgICAgICAgICAgJ2RhcmstYmx1ZSc6ICcjMjMxY2E1JyxcbiAgICAgICAgICAgICd3aGl0ZSc6ICcjZmZmZmZmJyxcbiAgICAgICAgICAgICdzbGlnaHRseS1ncmF5JzogJyNmNWY3ZjgnLFxuICAgICAgICAgICAgJ2JyaWdodC1ncmF5JzogJyNmMWYyZjMnLFxuICAgICAgICAgICAgJ2dyYXknOiAnI2RjZGVkZicsXG4gICAgICAgICAgICAnc2lsdmVyJzogJyNiZGJlYzAnLFxuICAgICAgICAgICAgJ2RpbS1ncmF5JzogJyM2NTY2NjgnLFxuICAgICAgICAgICAgJ2RhcmstZ3JheSc6ICcjMzIzNDM1JyxcbiAgICAgICAgICAgICdibGFjayc6ICcjMDAwMDAwJyxcbiAgICAgICAgICAgICdjcmltc29uLW5lZ2F0aXZlJzogJyNlNTAwNGMnLFxuICAgICAgICAgICAgJ2Fwcmljb3QnOiAnI2Y0OGIzNCcsXG4gICAgICAgICAgICAneWVsbG93JzogJyNmY2RiMWYnLFxuICAgICAgICAgICAgJ2dyZWVuLXBvc2l0aXZlJzogJyMxYWFjNjAnLFxuICAgICAgICAgICAgJ3VsdHJhbWFyaW5lJzogJyMzOTM5YzYnLFxuICAgICAgICAgICAgJ3NreWJsdWUnOiAnIzAwYWJmMycsXG4gICAgICAgICAgICAncGFsZS1hcXVhJzogJyM0M2U0ZmYnLFxuICAgICAgICAgICAgJ3BhbGUtZ3JlZW4nOiAnIzFmZmJiYScsXG4gICAgICAgICAgICAnbGltZSc6ICcjNzVkYTRkJyxcbiAgICAgICAgICAgICdvcmFuZ2UnOiAnI2ZmY2UwMCcsXG4gICAgICAgICAgICAnbWFnZW50YSc6ICcjZWIyM2MyJyxcbiAgICAgICAgICAgICdwYWxlLXB1cnBsZSc6ICcjYmE0N2UyJyxcbiAgICAgICAgICAgICdkYXJrLXVsdHJhbWFyaW5lJzogJyMyNzE3ODInLFxuICAgICAgICAgICAgJ3N0ZWVsYmx1ZSc6ICcjMDE0MjcyJyxcbiAgICAgICAgICAgICdhcmN0aWMtYmx1ZSc6ICcjMGI4ZWFjJyxcbiAgICAgICAgICAgICdlbWVyYWxkJzogJyMwMGE5ODknLFxuICAgICAgICAgICAgJ29saXZlJzogJyM1YmJhMzYnLFxuICAgICAgICAgICAgJ2dvbGRlbnJvZCc6ICcjZmZiMDAwJyxcbiAgICAgICAgICAgICdwdXJwbGUnOiAnIzliMWU4MycsXG4gICAgICAgICAgICAncGFsZS1lZ2dwbGFudCc6ICcjNTIxNmFjJyxcbiAgICAgICAgICAgICdyZWQnOiAnI2ZmNDU0ZicsXG4gICAgICAgICAgICAncGFsZS1hbWJlcic6ICcjZmZiMjRkJyxcbiAgICAgICAgICAgICdwYWxlLWxlbW9uJzogJyNmZGUxNTknLFxuICAgICAgICAgICAgJ3BhbGUtZW1lcmFsZCc6ICcjMzNjMTgwJyxcbiAgICAgICAgICAgICdwbHVtJzogJyNiMjE2NDYnLFxuICAgICAgICAgICAgJ2NvcHBlcic6ICcjZTU3ODI4JyxcbiAgICAgICAgICAgICdhbWJlcic6ICcjZmZjMDAyJyxcbiAgICAgICAgICAgICdsZWFmLWdyZWVuJzogJyMxMThjNGYnLFxuICAgICAgICAgICAgJ2ZvcmVzdC1ncmVlbic6ICcjMDA2NDVhJyxcbiAgICAgICAgICAgICdwcmltYXJ5JzogJyMwMDczZTcnLFxuICAgICAgICAgICAgJ2FjY2VudCc6ICcjNzQyNWFkJyxcbiAgICAgICAgICAgICdzZWNvbmRhcnknOiAnI2ZmZmZmZicsXG4gICAgICAgICAgICAnYWx0ZXJuYXRlMSc6ICcjMjljZWZmJyxcbiAgICAgICAgICAgICdhbHRlcm5hdGUyJzogJyMyZmQ2YzMnLFxuICAgICAgICAgICAgJ2FsdGVybmF0ZTMnOiAnI2M2MTc5ZCcsXG4gICAgICAgICAgICAndmlicmFudDEnOiAnIzQzZTRmZicsXG4gICAgICAgICAgICAndmlicmFudDInOiAnI2ZmY2UwMCcsXG4gICAgICAgICAgICAnZ3JleTEnOiAnIzAwMDAwMCcsXG4gICAgICAgICAgICAnZ3JleTInOiAnIzMyMzQzNScsXG4gICAgICAgICAgICAnZ3JleTMnOiAnIzY1NjY2OCcsXG4gICAgICAgICAgICAnZ3JleTQnOiAnI2JkYmVjMCcsXG4gICAgICAgICAgICAnZ3JleTUnOiAnI2RjZGVkZicsXG4gICAgICAgICAgICAnZ3JleTYnOiAnI2YxZjJmMycsXG4gICAgICAgICAgICAnZ3JleTcnOiAnI2Y1ZjdmOCcsXG4gICAgICAgICAgICAnZ3JleTgnOiAnI2ZmZmZmZicsXG4gICAgICAgICAgICAnY2hhcnQxJzogJyMzOTM5YzYnLFxuICAgICAgICAgICAgJ2NoYXJ0Mic6ICcjMDBhYmYzJyxcbiAgICAgICAgICAgICdjaGFydDMnOiAnIzc1ZGE0ZCcsXG4gICAgICAgICAgICAnY2hhcnQ0JzogJyNmZmNlMDAnLFxuICAgICAgICAgICAgJ2NoYXJ0NSc6ICcjZWIyM2MyJyxcbiAgICAgICAgICAgICdjaGFydDYnOiAnI2JhNDdlMicsXG4gICAgICAgICAgICAnb2snOiAnIzFhYWM2MCcsXG4gICAgICAgICAgICAnd2FybmluZyc6ICcjZjQ4YjM0JyxcbiAgICAgICAgICAgICdjcml0aWNhbCc6ICdlNTAwNGMnLFxuICAgICAgICAgICAgJ3BhcnRpdGlvbjEnOiAnIzc0MjVhZCcsXG4gICAgICAgICAgICAncGFydGl0aW9uOSc6ICcjNTIxNmFjJyxcbiAgICAgICAgICAgICdwYXJ0aXRpb24xMCc6ICcjNWJiYTM2JyxcbiAgICAgICAgICAgICdwYXJ0aXRpb24xMSc6ICcjMDE0MjcyJyxcbiAgICAgICAgICAgICdwYXJ0aXRpb24xMic6ICcjZmZiMDAwJyxcbiAgICAgICAgICAgICdwYXJ0aXRpb24xMyc6ICcjYmRiZWMwJyxcbiAgICAgICAgICAgICdwYXJ0aXRpb24xNCc6ICcjMjcxNzgyJyxcbiAgICAgICAgICAgICdzb2NpYWwtY2hhcnQtbm9kZSc6ICcjZmYwMGZmJyxcbiAgICAgICAgICAgICdzb2NpYWwtY2hhcnQtZWRnZSc6ICcjZmYwMGZmJ1xuICAgICAgICB9XG4gICAgfVxufTtcblxuZXhwb3J0IGludGVyZmFjZSBUaGVtZUNvbG9ycyB7XG4gICAgW25hbWU6IHN0cmluZ106IFRoZW1lQ29sb3I7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29sb3JTZXQge1xuICAgIGNvbG9yQ2xhc3NTZXQ/OiBDb2xvckNsYXNzU2V0O1xuICAgIGNvbG9yVmFsdWVTZXQ/OiBDb2xvclZhbHVlU2V0O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvbG9yQ2xhc3NTZXQge1xuICAgIFtuYW1lOiBzdHJpbmddOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29sb3JWYWx1ZVNldCB7XG4gICAgW25hbWU6IHN0cmluZ106IHN0cmluZztcbn1cblxuZXhwb3J0IHR5cGUgQ29sb3JJZGVudGlmaWVyID0gc3RyaW5nO1xuIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIEhvc3RCaW5kaW5nLCBJbnB1dCwgT25EZXN0cm95LCBPbkluaXQsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcy9CZWhhdmlvclN1YmplY3QnO1xuaW1wb3J0IHsgY29tYmluZUxhdGVzdCB9IGZyb20gJ3J4anMvb2JzZXJ2YWJsZS9jb21iaW5lTGF0ZXN0JztcbmltcG9ydCB7IHBhaXJ3aXNlLCB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcbmltcG9ydCB7IFRoZW1lQ29sb3IgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9jb2xvci9jb2xvci5zZXJ2aWNlJztcblxuLy8gVmFsdWVzIGNvcnJlc3BvbmRpbmcgdG8gc3R5bGVzaGVldFxuY29uc3QgQlVUVE9OX01BUkdJTiA9IDg7XG5jb25zdCBCVVRUT05fV0lEVEhTID0ge1xuICAgICdzbSc6IDI2LFxuICAgICdtZCc6IDMyLFxuICAgICdsZyc6IDQwXG59O1xuXG5sZXQgdW5pcXVlSWQgPSAwO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LWNvbG9yLXBpY2tlcicsXG4gICAgZXhwb3J0QXM6ICd1eC1jb2xvci1waWNrZXInLFxuICAgIHRlbXBsYXRlVXJsOiAnY29sb3ItcGlja2VyLmNvbXBvbmVudC5odG1sJ1xufSlcbmV4cG9ydCBjbGFzcyBDb2xvclBpY2tlckNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcblxuICAgIEBJbnB1dCgpXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLmlkJylcbiAgICBpZDogc3RyaW5nID0gYHV4LWNvbG9yLXBpY2tlci0ke3VuaXF1ZUlkKyt9YDtcblxuICAgIEBJbnB1dCgnY29sb3JzJylcbiAgICBzZXQgaW5wdXRDb2xvcnMoY29sb3JzOiBDb2xvclBpY2tlcklucHV0Q29sb3JzW10gfCBDb2xvclBpY2tlcklucHV0Q29sb3JzW11bXSkge1xuXG4gICAgICAgIGxldCBub3JtYWxpemVkQ29sb3JzOiBDb2xvclBpY2tlcklucHV0Q29sb3JzW11bXTtcblxuICAgICAgICAvLyBJZiBpdCdzIGEgMWQgYXJyYXksIGNvbnZlcnQgaXQgdG8gMmRcbiAgICAgICAgaWYgKGNvbG9ycy5sZW5ndGggPT09IDAgfHwgIUFycmF5LmlzQXJyYXkoY29sb3JzWzBdKSkge1xuICAgICAgICAgICAgbm9ybWFsaXplZENvbG9ycyA9IFs8Q29sb3JQaWNrZXJJbnB1dENvbG9yc1tdPmNvbG9yc107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub3JtYWxpemVkQ29sb3JzID0gPENvbG9yUGlja2VySW5wdXRDb2xvcnNbXVtdPmNvbG9ycztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbnZlcnQgYW55IHN0cmluZyBjb2xvcnMgdG8gQ29sb3JQaWNrZXJDb2xvclxuICAgICAgICB0aGlzLmNvbG9ycyA9IG5vcm1hbGl6ZWRDb2xvcnMubWFwKHJvdyA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcm93Lm1hcChjb2xvciA9PiBjb2xvciBpbnN0YW5jZW9mIENvbG9yUGlja2VyQ29sb3IgPyBjb2xvciA6IG5ldyBDb2xvclBpY2tlckNvbG9yKGNvbG9yLCBjb2xvcikpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBASW5wdXQoKVxuICAgIHNldCBzZWxlY3RlZChzZWxlY3RlZDogQ29sb3JQaWNrZXJDb2xvcikge1xuICAgICAgICB0aGlzLnNlbGVjdGVkJC5uZXh0KHNlbGVjdGVkKTtcbiAgICB9XG5cbiAgICBASW5wdXQoKVxuICAgIHNldCBjb2x1bW5zKGNvbHVtbnM6IG51bWJlcikge1xuICAgICAgICB0aGlzLmNvbHVtbnMkLm5leHQoY29sdW1ucyk7XG4gICAgfVxuXG4gICAgQElucHV0KClcbiAgICBidXR0b25TdHlsZTogQ29sb3JQaWNrZXJCdXR0b25TdHlsZSA9ICdjaXJjbGUnO1xuXG4gICAgQElucHV0KClcbiAgICBzZXQgYnV0dG9uU2l6ZShidXR0b25TaXplOiBDb2xvclBpY2tlckJ1dHRvblNpemUpIHtcbiAgICAgICAgdGhpcy5idXR0b25TaXplJC5uZXh0KGJ1dHRvblNpemUpO1xuICAgIH1cblxuICAgIEBJbnB1dCgpXG4gICAgc2hvd1Rvb2x0aXBzOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBASW5wdXQoKVxuICAgIHNob3dJbnB1dDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgQElucHV0KClcbiAgICBpbnB1dE1vZGU6IENvbG9yUGlja2VySW5wdXRNb2RlID0gJ2hleCc7XG5cbiAgICBAT3V0cHV0KClcbiAgICBzZWxlY3RlZENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8Q29sb3JQaWNrZXJDb2xvcj4oKTtcblxuICAgIEBPdXRwdXQoKVxuICAgIGlucHV0U3VibWl0ID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuXG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS53aWR0aCcpXG4gICAgY3NzV2lkdGggPSAnYXV0byc7XG5cbiAgICBjb2xvcnM6IENvbG9yUGlja2VyQ29sb3JbXVtdID0gW107XG4gICAgc2VsZWN0ZWQkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxDb2xvclBpY2tlckNvbG9yPihudWxsKTtcbiAgICBjb2x1bW5zJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8bnVtYmVyPigtMSk7XG4gICAgYnV0dG9uU2l6ZSQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PENvbG9yUGlja2VyQnV0dG9uU2l6ZT4oJ21kJyk7XG4gICAgaW5wdXRQYXR0ZXJucyA9IHtcbiAgICAgICAgJ2hleCc6IC9eIyg/OltcXGRhLWZBLUZdezN9KXsxLDJ9JC8sXG4gICAgICAgICdyZ2JhJzogL14oPzpyZ2JcXChcXGR7MSwzfSxcXHMqXFxkezEsM30sXFxzKlxcZHsxLDN9XFwpKXwoPzpyZ2JhXFwoXFxkezEsM30sXFxzKlxcZHsxLDN9LFxccypcXGR7MSwzfSxcXHMqXFxkKFxcLlxcZCspP1xcKSkkL1xuICAgIH07XG5cbiAgICBwcml2YXRlIF9vbkRlc3Ryb3kgPSBuZXcgU3ViamVjdCgpO1xuXG4gICAgbmdPbkluaXQoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gU2tpcCBlbWl0dGluZyB0aGUgaW5pdGlhbCBzZWxlY3RlZENoYW5nZVxuICAgICAgICB0aGlzLnNlbGVjdGVkJC5waXBlKHBhaXJ3aXNlKCksIHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUoKFtwcmV2LCBjdXJyXSkgPT4ge1xuICAgICAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkQ2hhbmdlLmVtaXQoY3Vycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFNldCB0aGUgd2lkdGggYmFzZWQgb24gY29sdW1uIGNvdW50IGFuZCBidXR0b24gc2l6ZVxuICAgICAgICBjb21iaW5lTGF0ZXN0KHRoaXMuY29sdW1ucyQsIHRoaXMuYnV0dG9uU2l6ZSQpXG4gICAgICAgICAgICAucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKFtjb2x1bW5zLCBidXR0b25TaXplXSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjb2x1bW5zID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB3ID0gY29sdW1ucyAqIChCVVRUT05fV0lEVEhTW2J1dHRvblNpemVdICsgKDIgKiBCVVRUT05fTUFSR0lOKSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3NzV2lkdGggPSBgJHt3fXB4YDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNzc1dpZHRoID0gJ2F1dG8nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kubmV4dCgpO1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kuY29tcGxldGUoKTtcbiAgICB9XG5cbiAgICB1cGRhdGVDb2xvclZhbHVlKGlucHV0OiBzdHJpbmcsIG1vZGU6IENvbG9yUGlja2VySW5wdXRNb2RlKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmlucHV0UGF0dGVybnNbbW9kZV0udGVzdChpbnB1dCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQkLm5leHQobmV3IENvbG9yUGlja2VyQ29sb3IoJ0N1c3RvbScsIGlucHV0LCBtb2RlKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0b2dnbGVDb2xvckVudHJ5VHlwZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5pbnB1dE1vZGUgPSAodGhpcy5pbnB1dE1vZGUgPT09ICdoZXgnKSA/ICdyZ2JhJyA6ICdoZXgnO1xuICAgIH1cbn1cblxuZXhwb3J0IHR5cGUgQ29sb3JQaWNrZXJJbnB1dENvbG9ycyA9IENvbG9yUGlja2VyQ29sb3IgfCBzdHJpbmc7XG5leHBvcnQgdHlwZSBDb2xvclBpY2tlckJ1dHRvblN0eWxlID0gJ3NxdWFyZScgfCAnY2lyY2xlJztcbmV4cG9ydCB0eXBlIENvbG9yUGlja2VyQnV0dG9uU2l6ZSA9ICdzbScgfCAnbWQnIHwgJ2xnJztcbmV4cG9ydCB0eXBlIENvbG9yUGlja2VySW5wdXRNb2RlID0gJ2hleCcgfCAncmdiYSc7XG5cbi8qKlxuICogVHlwZSByZXByZXNlbnRpbmcgYSBjb2xvciwgaW5jbHVkaW5nIGl0cyBkZXNjcmlwdGl2ZSBuYW1lLlxuICovXG5leHBvcnQgY2xhc3MgQ29sb3JQaWNrZXJDb2xvciB7XG5cbiAgICAvKipcbiAgICAgKiBIdW1hbi1yZWFkYWJsZSBuYW1lIG9mIHRoZSBjb2xvci5cbiAgICAgKi9cbiAgICBuYW1lOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBIZXggdmFsdWUgb2YgdGhlIGNvbG9yLCBlLmcuIGAjZmZmZmZmYC5cbiAgICAgKi9cbiAgICBnZXQgaGV4KCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcmlnaW5hbEhleFZhbHVlID8gdGhpcy5fb3JpZ2luYWxIZXhWYWx1ZSA6IHRoaXMuX2NvbG9yLnRvSGV4KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUkdCQSB2YWx1ZSBvZiB0aGUgY29sb3IsIGUuZy4gYHJnYmEoMjU1LCAyNTUsIDI1NSwgMSlgLlxuICAgICAqL1xuICAgIGdldCByZ2JhKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcmlnaW5hbFJnYmFWYWx1ZSA/IHRoaXMuX29yaWdpbmFsUmdiYVZhbHVlIDogdGhpcy5fY29sb3IudG9SZ2JhKCk7XG4gICAgfVxuXG4gICAgZ2V0IHIoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHRoaXMuX2NvbG9yLmdldFJlZCgpKTtcbiAgICB9XG5cbiAgICBnZXQgZygpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQodGhpcy5fY29sb3IuZ2V0R3JlZW4oKSk7XG4gICAgfVxuXG4gICAgZ2V0IGIoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHRoaXMuX2NvbG9yLmdldEJsdWUoKSk7XG4gICAgfVxuXG4gICAgZ2V0IGEoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodGhpcy5fY29sb3IuZ2V0QWxwaGEoKSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfY29sb3I6IFRoZW1lQ29sb3I7XG4gICAgcHJpdmF0ZSBfb3JpZ2luYWxIZXhWYWx1ZTogc3RyaW5nO1xuICAgIHByaXZhdGUgX29yaWdpbmFsUmdiYVZhbHVlOiBzdHJpbmc7XG5cbiAgICBjb25zdHJ1Y3RvcihuYW1lOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcsIGlucHV0TW9kZT86IENvbG9yUGlja2VySW5wdXRNb2RlKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuX2NvbG9yID0gVGhlbWVDb2xvci5wYXJzZSh2YWx1ZSk7XG5cbiAgICAgICAgLy8gUHJlc2VydmUgdGhlIGZvcm1hdCBlbnRlcmVkIGJ5IHRoZSB1c2VyIGlmIGl0J3MgdmFsaWRcbiAgICAgICAgaWYgKGlucHV0TW9kZSA9PT0gJ2hleCcpIHtcbiAgICAgICAgICAgIHRoaXMuX29yaWdpbmFsSGV4VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dE1vZGUgPT09ICdyZ2JhJykge1xuICAgICAgICAgICAgdGhpcy5fb3JpZ2luYWxSZ2JhVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRvU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2xvci50b1JnYmEoKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgRm9jdXNNb25pdG9yIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2ExMXknO1xuaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIE5nWm9uZSwgT25EZXN0cm95LCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbdXhGb2N1c1dpdGhpbl0sW3V4Qmx1cldpdGhpbl0nLFxufSlcbmV4cG9ydCBjbGFzcyBGb2N1c1dpdGhpbkRpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG5cbiAgICBAT3V0cHV0KCkgdXhGb2N1c1dpdGhpbiA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcbiAgICBAT3V0cHV0KCkgdXhCbHVyV2l0aGluID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZiwgcHJpdmF0ZSBfZm9jdXNNb25pdG9yOiBGb2N1c01vbml0b3IsIG5nWm9uZTogTmdab25lKSB7XG4gICAgICAgIF9mb2N1c01vbml0b3IubW9uaXRvcih0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsIHRydWUpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKG9yaWdpbiA9PiBuZ1pvbmUucnVuKCgpID0+IG9yaWdpbiA/IHRoaXMudXhGb2N1c1dpdGhpbi5lbWl0KCkgOiB0aGlzLnV4Qmx1cldpdGhpbi5lbWl0KCkpKTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fZm9jdXNNb25pdG9yLnN0b3BNb25pdG9yaW5nKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCk7XG4gICAgfVxufSIsImltcG9ydCB7IGlzUGxhdGZvcm1Ccm93c2VyIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IEFmdGVyVmlld0luaXQsIENvbnRlbnRDaGlsZHJlbiwgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIEhvc3RMaXN0ZW5lciwgSW5qZWN0LCBPbkRlc3Ryb3ksIE91dHB1dCwgUExBVEZPUk1fSUQsIFF1ZXJ5TGlzdCwgUmVuZGVyZXIyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTcGxpdEFyZWFEaXJlY3RpdmUsIFNwbGl0Q29tcG9uZW50IH0gZnJvbSAnYW5ndWxhci1zcGxpdCc7XG5pbXBvcnQgeyB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdzcGxpdCdcbn0pXG5leHBvcnQgY2xhc3MgU3BsaXR0ZXJBY2Nlc3NpYmlsaXR5RGlyZWN0aXZlIGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCwgT25EZXN0cm95IHtcblxuICAgIC8qKiBFbWl0IGFuIGV2ZW50IHdoZW5ldmVyIHRoZSBndXR0ZXIgaXMgbW92ZWQgdXNpbmcgdGhlIGtleWJvYXJkICovXG4gICAgQE91dHB1dCgpIGd1dHRlcktleWRvd24gPSBuZXcgRXZlbnRFbWl0dGVyPEtleWJvYXJkRXZlbnQ+KCk7XG5cbiAgICAvKiogRmluZCBhbGwgdGhlIHNwbGl0IGFyZWFzICovXG4gICAgQENvbnRlbnRDaGlsZHJlbihTcGxpdEFyZWFEaXJlY3RpdmUpIGFyZWFzOiBRdWVyeUxpc3Q8U3BsaXRBcmVhRGlyZWN0aXZlPjtcblxuICAgIC8qKiBTdG9yZSBhbGwgdGhlIGd1dHRlciBlbGVtZW50cyAqL1xuICAgIHByaXZhdGUgX2d1dHRlcnM6IEhUTUxFbGVtZW50W10gPSBbXTtcblxuICAgIC8qKiBXYXRjaCBmb3IgZ3V0dGVycyBiZWluZyBhZGRlZCBvciByZW1vdmVkICovXG4gICAgcHJpdmF0ZSBfb2JzZXJ2ZXI6IE11dGF0aW9uT2JzZXJ2ZXI7XG5cbiAgICAvKiogVGVhcmRvd24gb3VyIG9ic2VydmFibGVzIG9uIGRlc3Ryb3kgKi9cbiAgICBwcml2YXRlIF9vbkRlc3Ryb3kgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+LFxuICAgICAgICBwcml2YXRlIF9yZW5kZXJlcjogUmVuZGVyZXIyLFxuICAgICAgICBASW5qZWN0KFBMQVRGT1JNX0lEKSBwcml2YXRlIF9wbGF0Zm9ybTogc3RyaW5nLFxuICAgICAgICBwcml2YXRlIF9zcGxpdHRlcjogU3BsaXRDb21wb25lbnRcbiAgICApIHtcbiAgICAgICAgLy8gdXBkYXRlIGFyaWEgdmFsdWVzIHdoZW4gdGhlIGEgZ3V0dGVyIGlzIGRyYWdnZWRcbiAgICAgICAgX3NwbGl0dGVyLmRyYWdQcm9ncmVzc1xuICAgICAgICAgICAgLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMudXBkYXRlR3V0dGVyQXR0cmlidXRlcygpKTtcbiAgICB9XG5cbiAgICAvKiogT25jZSBpbml0aWFsaXNlZCBtYWtlIHRoZSBndXR0ZXJzIGFjY2Vzc2libGUgKi9cbiAgICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgICAgIC8vIGZpbmQgdGhlIGd1dHRlcnNcbiAgICAgICAgdGhpcy5vbkd1dHRlckNoYW5nZSgpO1xuXG4gICAgICAgIC8vIGlmIHRoZSBudW1iZXIgb2Ygc3BsaXQgYXJlYXMgY2hhbmdlIHRoZW4gdXBkYXRlIHRoZSBndXR0ZXJzIGFuZCBhcHBseSBhcmlhIHByb3BlcnRpZXNcbiAgICAgICAgdGhpcy5hcmVhcy5jaGFuZ2VzLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZSgoKSA9PiB0aGlzLm9uR3V0dGVyQ2hhbmdlKCkpO1xuXG4gICAgICAgIC8vIHdlIGNhbid0IGtub3cgd2hlbiBhZGRpdGlvbmFsIHNwbGl0LWd1dHRlcnMgYXBwZWFyIHVzaW5nIENvbnRlbnRDaGlsZHJlbiBhcyB0aGUgZGlyZWN0aXZlIGNsYXNzIGlzIG5vdCBleHBvcnRlZCBhbmQgc2VsZWN0b3IgZG9lc24ndCB3b3JrIC0gdXNlIG11dGF0aW9uIG9ic2VydmVyIGluc3RlYWRcbiAgICAgICAgaWYgKGlzUGxhdGZvcm1Ccm93c2VyKHRoaXMuX3BsYXRmb3JtKSkge1xuXG4gICAgICAgICAgICAvLyBjcmVhdGUgdGhlIG11dGF0aW9uIG9ic2VydmVyXG4gICAgICAgICAgICB0aGlzLl9vYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKCgpID0+IHRoaXMub25HdXR0ZXJDaGFuZ2UoKSk7XG5cbiAgICAgICAgICAgIC8vIGJlZ2luIG9ic2VydmluZyB0aGUgY2hpbGQgbm9kZXNcbiAgICAgICAgICAgIHRoaXMuX29ic2VydmVyLm9ic2VydmUodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCB7IGNoaWxkTGlzdDogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBEZXN0cm95IGFsbCBvYnNlcnZhYmxlcyBhbmQgb2JzZXJ2ZXJzICovXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG5cbiAgICAgICAgaWYgKHRoaXMuX29ic2VydmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9vYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kubmV4dCgpO1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kuY29tcGxldGUoKTtcbiAgICB9XG5cbiAgICAvKiogV2Ugc2hvdWxkIGZvY3VzIHRoZSBndXR0ZXIgd2hlbiBpdCBpcyBjbGlja2VkICovXG4gICAgQEhvc3RMaXN0ZW5lcignY2xpY2snLCBbJyRldmVudCddKVxuICAgIG9uQ2xpY2soZXZlbnQ6IE1vdXNlRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuaXNTcGxpdHRlckd1dHRlcihldmVudC50YXJnZXQgYXMgSFRNTEVsZW1lbnQpKSB7XG4gICAgICAgICAgICAoZXZlbnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50KS5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEZpbmQgYWxsIHRoZSBndXR0ZXJzIGFuZCBzZXQgdGhlaXIgYXR0cmlidXRlcyAqL1xuICAgIHByaXZhdGUgb25HdXR0ZXJDaGFuZ2UoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2d1dHRlcnMgPSB0aGlzLmdldEd1dHRlcnMoKTtcbiAgICAgICAgdGhpcy5zZXRHdXR0ZXJBdHRyaWJ1dGVzKCk7XG4gICAgfVxuXG4gICAgLyoqIEdldCBhbGwgdGhlIGd1dHRlciBlbGVtZW50cyAqL1xuICAgIHByaXZhdGUgZ2V0R3V0dGVycygpOiBIVE1MRWxlbWVudFtdIHtcbiAgICAgICAgLy8gVGhpcyBmdW5jdGlvbiB1c2VzIERPTSBhY2Nlc3NpbmcgcHJvcGVydGllcyAtIHdoaWNoIHdvbid0IHdvcmsgaWYgc2VydmVyIHNpZGUgcmVuZGVyZWRcbiAgICAgICAgaWYgKGlzUGxhdGZvcm1Ccm93c2VyKHRoaXMuX3BsYXRmb3JtKSkge1xuICAgICAgICAgICAgY29uc3QgZ3V0dGVyczogSFRNTEVsZW1lbnRbXSA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuY2hpbGRyZW4uaXRlbShpZHgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNTcGxpdHRlckd1dHRlcihub2RlIGFzIEhUTUxFbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICBndXR0ZXJzLnB1c2gobm9kZSBhcyBIVE1MRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZ3V0dGVycztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICAvKiogU2V0IHRoZSBhcHByb3ByaWF0ZSBhdHRyaWJ1dGVzIG9uIHRoZSBndXR0ZXIgZWxlbWVudHMgKi9cbiAgICBwcml2YXRlIHNldEd1dHRlckF0dHJpYnV0ZXMoKTogdm9pZCB7XG4gICAgICAgIC8vIGFwcGx5IGF0dHJpYnV0ZSB0byBldmVyeSBndXR0ZXJcbiAgICAgICAgdGhpcy5fZ3V0dGVycy5mb3JFYWNoKGd1dHRlciA9PiB7XG4gICAgICAgICAgICAvLyBhcHBseSB0aGUgc2VwYXJhdG9yIHJvbGVcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEF0dHJpYnV0ZShndXR0ZXIsICdyb2xlJywgJ3NlcGFyYXRvcicpO1xuXG4gICAgICAgICAgICAvLyBtYWtlIHRoZSBndXR0ZXJzIHRhYmJhYmxlXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRBdHRyaWJ1dGUoZ3V0dGVyLCAndGFiaW5kZXgnLCAnMCcpO1xuXG4gICAgICAgICAgICAvLyBzZXQgdGhlIHZhbHVlIG5vdyBhcmlhIHByb3BlcnR5XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUd1dHRlckF0dHJpYnV0ZXMoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqIEFwcGx5IHRoZSBhcmlhIGF0dHJpYnV0ZSB2YWx1ZXMgKi9cbiAgICBwcml2YXRlIHVwZGF0ZUd1dHRlckF0dHJpYnV0ZXMoKTogdm9pZCB7XG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgdmFsdWUgbm93IHByb3BlcnRpZXMgb2YgZWFjaCBndXR0ZXJcbiAgICAgICAgdGhpcy5fZ3V0dGVycy5mb3JFYWNoKChndXR0ZXIsIGlkeCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXRHdXR0ZXJWYWx1ZU5vdyhndXR0ZXIsIGlkeCk7XG4gICAgICAgICAgICB0aGlzLnNldEd1dHRlclZhbHVlTWluKGd1dHRlciwgaWR4KTtcbiAgICAgICAgICAgIHRoaXMuc2V0R3V0dGVyVmFsdWVNYXgoZ3V0dGVyLCBpZHgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKiogQXBwbHkgdGhlIHZhbHVlIG5vdyBhcmlhIGF0dHJpYnV0ZSAqL1xuICAgIHByaXZhdGUgc2V0R3V0dGVyVmFsdWVOb3coZ3V0dGVyOiBIVE1MRWxlbWVudCwgaW5kZXg6IG51bWJlcik6IHZvaWQge1xuICAgICAgICAvLyBnZXQgdGhlIG1hdGNoaW5nIHNwbGl0IGFyZWFcbiAgICAgICAgY29uc3QgYXJlYSA9IHRoaXMuX3NwbGl0dGVyLmRpc3BsYXllZEFyZWFzW2luZGV4XTtcblxuICAgICAgICAvLyBpbmRpY2F0ZSB0aGUgc2l6ZVxuICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRBdHRyaWJ1dGUoZ3V0dGVyLCAnYXJpYS12YWx1ZW5vdycsIGAke01hdGgucm91bmQoYXJlYS5zaXplICogMTAwKX1gKTtcbiAgICB9XG5cbiAgICAvKiogQXBwbHkgdGhlIHZhbHVlIG1pbiBhcmlhIGF0dHJpYnV0ZSAqL1xuICAgIHByaXZhdGUgc2V0R3V0dGVyVmFsdWVNaW4oZ3V0dGVyOiBIVE1MRWxlbWVudCwgaW5kZXg6IG51bWJlcik6IHZvaWQge1xuICAgICAgICAvLyBnZXQgdGhlIG1hdGNoaW5nIHNwbGl0IGFyZWFcbiAgICAgICAgY29uc3QgYXJlYSA9IHRoaXMuYXJlYXMudG9BcnJheSgpW2luZGV4XTtcblxuICAgICAgICAvLyBpbmRpY2F0ZSB0aGUgbWluaW11bSBzaXplXG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEF0dHJpYnV0ZShndXR0ZXIsICdhcmlhLXZhbHVlbWluJywgYCR7TWF0aC5yb3VuZChhcmVhLm1pblNpemUgKiAxMDApfWApO1xuICAgIH1cblxuICAgIC8qKiBBcHBseSB0aGUgdmFsdWUgbWF4IGFyaWEgYXR0cmlidXRlICovXG4gICAgcHJpdmF0ZSBzZXRHdXR0ZXJWYWx1ZU1heChndXR0ZXI6IEhUTUxFbGVtZW50LCBpbmRleDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIC8vIGdldCBldmVyeSBvdGhlciBzcGxpdHRlciBhcmVhXG4gICAgICAgIGNvbnN0IGF2YWlsYWJsZVNpemUgPSB0aGlzLmFyZWFzXG4gICAgICAgICAgICAuZmlsdGVyKChfYXJlYSwgaWR4KSA9PiBpbmRleCAhPT0gaWR4KVxuICAgICAgICAgICAgLnJlZHVjZTxudW1iZXI+KCh0b3RhbCwgYXJlYSkgPT4gdG90YWwgKyBhcmVhLm1pblNpemUsIDApO1xuXG4gICAgICAgIC8vIGluZGljYXRlIHRoZSBtaW5pbXVtIHNpemVcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0QXR0cmlidXRlKGd1dHRlciwgJ2FyaWEtdmFsdWVtYXgnLCBgJHsxMDAgLSBNYXRoLnJvdW5kKGF2YWlsYWJsZVNpemUgKiAxMDApfWApO1xuICAgIH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ2tleWRvd24nLCBbJyRldmVudCddKVxuICAgIG9uS2V5ZG93bihldmVudDogS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5pc1NwbGl0dGVyR3V0dGVyKGV2ZW50LnRhcmdldCBhcyBIVE1MRWxlbWVudCkpIHtcbiAgICAgICAgICAgIHRoaXMuZ3V0dGVyS2V5ZG93bi5lbWl0KGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ2tleWRvd24uQXJyb3dEb3duJywgWyckZXZlbnQnXSlcbiAgICBASG9zdExpc3RlbmVyKCdrZXlkb3duLkFycm93UmlnaHQnLCBbJyRldmVudCddKVxuICAgIG9uSW5jcmVhc2VLZXkoZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgLy8gb25seSBwZXJmb3JtIGEgbW92ZSBpZiBhIGd1dHRlciBpcyBmb2N1c2VkXG4gICAgICAgIGlmICh0aGlzLmlzU3BsaXR0ZXJHdXR0ZXIoZXZlbnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50KSkge1xuICAgICAgICAgICAgdGhpcy5zZXRHdXR0ZXJQb3NpdGlvbihldmVudC50YXJnZXQgYXMgSFRNTEVsZW1lbnQsIC0wLjAxKTtcblxuICAgICAgICAgICAgLy8gc3RvcCB0aGUgYnJvd3NlciBmcm9tIHNjcm9sbGluZ1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ2tleWRvd24uQXJyb3dVcCcsIFsnJGV2ZW50J10pXG4gICAgQEhvc3RMaXN0ZW5lcigna2V5ZG93bi5BcnJvd0xlZnQnLCBbJyRldmVudCddKVxuICAgIG9uRGVjcmVhc2VLZXkoZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgLy8gb25seSBwZXJmb3JtIGEgbW92ZSBpZiBhIGd1dHRlciBpcyBmb2N1c2VkXG4gICAgICAgIGlmICh0aGlzLmlzU3BsaXR0ZXJHdXR0ZXIoZXZlbnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50KSkge1xuICAgICAgICAgICAgdGhpcy5zZXRHdXR0ZXJQb3NpdGlvbihldmVudC50YXJnZXQgYXMgSFRNTEVsZW1lbnQsIDAuMDEpO1xuXG4gICAgICAgICAgICAvLyBzdG9wIHRoZSBicm93c2VyIGZyb20gc2Nyb2xsaW5nXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcigna2V5ZG93bi5Ib21lJywgWyckZXZlbnQnXSlcbiAgICBvbkhvbWVLZXkoZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuaXNTcGxpdHRlckd1dHRlcihldmVudC50YXJnZXQgYXMgSFRNTEVsZW1lbnQpKSB7XG4gICAgICAgICAgICAvLyBnZXQgdGhlIGFmZmVjdGVkIHBhbmVsc1xuICAgICAgICAgICAgY29uc3QgYXJlYXMgPSB0aGlzLmdldEFyZWFzRnJvbUd1dHRlcihldmVudC50YXJnZXQgYXMgSFRNTEVsZW1lbnQpO1xuXG4gICAgICAgICAgICAvLyBzZXQgdGhlIHByZXZpb3VzIGFyZWEgdG8gaXQncyBtaW5pbXVtIHNpemVcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gYXJlYXMucHJldmlvdXMuc2l6ZSAtIGFyZWFzLnByZXZpb3VzLmNvbXAubWluU2l6ZTtcblxuICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSBzaXplcyBhY2NvcmRpbmdseVxuICAgICAgICAgICAgdGhpcy5zZXRHdXR0ZXJQb3NpdGlvbihldmVudC50YXJnZXQgYXMgSFRNTEVsZW1lbnQsIGRlbHRhKTtcblxuICAgICAgICAgICAgLy8gc3RvcCB0aGUgYnJvd3NlciBmcm9tIHNjcm9sbGluZ1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ2tleWRvd24uRW5kJywgWyckZXZlbnQnXSlcbiAgICBvbkVuZEtleShldmVudDogS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5pc1NwbGl0dGVyR3V0dGVyKGV2ZW50LnRhcmdldCBhcyBIVE1MRWxlbWVudCkpIHtcbiAgICAgICAgICAgIC8vIGdldCB0aGUgYWZmZWN0ZWQgcGFuZWxzXG4gICAgICAgICAgICBjb25zdCBhcmVhcyA9IHRoaXMuZ2V0QXJlYXNGcm9tR3V0dGVyKGV2ZW50LnRhcmdldCBhcyBIVE1MRWxlbWVudCk7XG5cbiAgICAgICAgICAgIC8vIHNldCB0aGUgbmV4dCBhcmVhIHRvIGl0J3MgbWluaW11bSBzaXplXG4gICAgICAgICAgICBjb25zdCBkZWx0YSA9IGFyZWFzLm5leHQuc2l6ZSAtIGFyZWFzLm5leHQuY29tcC5taW5TaXplO1xuXG4gICAgICAgICAgICAvLyB1cGRhdGUgdGhlIHNpemVzIGFjY29yZGluZ2x5XG4gICAgICAgICAgICB0aGlzLnNldEd1dHRlclBvc2l0aW9uKGV2ZW50LnRhcmdldCBhcyBIVE1MRWxlbWVudCwgLWRlbHRhKTtcblxuICAgICAgICAgICAgLy8gc3RvcCB0aGUgYnJvd3NlciBmcm9tIHNjcm9sbGluZ1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBEZXRlcm1pbmUgaWYgYW4gZWxlbWVudCBpcyBhIGd1dHRlciAqL1xuICAgIHByaXZhdGUgaXNTcGxpdHRlckd1dHRlcihlbGVtZW50OiBIVE1MRWxlbWVudCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gZWxlbWVudC50YWdOYW1lID09PSAnU1BMSVQtR1VUVEVSJztcbiAgICB9XG5cbiAgICAvKiogVXBkYXRlIHRoZSBndXR0ZXIgcG9zaXRpb24gKi9cbiAgICBwcml2YXRlIHNldEd1dHRlclBvc2l0aW9uKGd1dHRlcjogSFRNTEVsZW1lbnQsIGRlbHRhOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgLy8gZ2V0IHRoZSBhZmZlY3RlZCBwYW5lbHNcbiAgICAgICAgY29uc3QgYXJlYXMgPSB0aGlzLmdldEFyZWFzRnJvbUd1dHRlcihndXR0ZXIpO1xuXG4gICAgICAgIC8vIGVuc3VyZSB3ZSBjYW4gcGVyZm9ybSB0aGUgcmVzaXplXG4gICAgICAgIGlmIChhcmVhcy5wcmV2aW91cy5zaXplIC0gZGVsdGEgPCBhcmVhcy5wcmV2aW91cy5jb21wLm1pblNpemUgfHwgYXJlYXMubmV4dC5zaXplICsgZGVsdGEgPCBhcmVhcy5uZXh0LmNvbXAubWluU2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcGVyZm9ybSB0aGUgcmVzaXplXG4gICAgICAgIGFyZWFzLnByZXZpb3VzLnNpemUgLT0gZGVsdGE7XG4gICAgICAgIGFyZWFzLm5leHQuc2l6ZSArPSBkZWx0YTtcblxuICAgICAgICAvLyB1cGRhdGUgdGhlIHNwbGl0dGVyIC0gdGhpcyBpcyBhIHByaXZhdGUgbWV0aG9kIGJ1dCB3ZSBuZWVkIHRvIGNhbGwgaXRcbiAgICAgICAgKHRoaXMuX3NwbGl0dGVyIGFzIGFueSkucmVmcmVzaFN0eWxlU2l6ZXMoKTtcblxuICAgICAgICAvLyB1cGRhdGUgdGhlIGd1dHRlciBhcmlhIHZhbHVlc1xuICAgICAgICB0aGlzLnVwZGF0ZUd1dHRlckF0dHJpYnV0ZXMoKTtcbiAgICB9XG5cbiAgICAvKiogR2V0IHRoZSBzcGxpdCBhcmVhcyBhc3NvY2lhdGVkIHdpdGggYSBnaXZlbiBndXR0ZXIgKi9cbiAgICBwcml2YXRlIGdldEFyZWFzRnJvbUd1dHRlcihndXR0ZXI6IEhUTUxFbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fZ3V0dGVycy5pbmRleE9mKGd1dHRlcik7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHByZXZpb3VzOiB0aGlzLl9zcGxpdHRlci5kaXNwbGF5ZWRBcmVhc1tpbmRleF0sXG4gICAgICAgICAgICBuZXh0OiB0aGlzLl9zcGxpdHRlci5kaXNwbGF5ZWRBcmVhc1tpbmRleCArIDFdXG4gICAgICAgIH07XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMvT2JzZXJ2YWJsZSc7XG5cbi8qKlxuICogVGhpcyBpcyBhIHNpbXBsZSBSeEpTIG9wZXJhdG9yIHRvIGFsbG93IHVzIHRvIGF2b2lkIHRoZVxuICogXCJleHByZXNzaW9uIGhhcyBjaGFuZ2VkIGFmdGVyIGl0IHdhcyBjaGVja2VkIGlzc3VlXCJcbiAqIGJ5IG1ha2luZyB0aGUgc3Vic2NyaXB0aW9uIGFzeW5jaHJvbm91cy4gV2UgY291bGQganVzdCB1c2UgYVxuICogZGVsYXkgb3BlcmF0b3IgYnV0IHRoaXMgdXNlcyBhIHRpbWVvdXQgd2hpY2ggaXMgc2lnbmlmaWNhbnRseVxuICogc2xvd2VyIHRoYW4gdXNpbmcgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLlxuICovXG5leHBvcnQgY29uc3QgdGljayA9IDxUPigpID0+IChzb3VyY2U6IE9ic2VydmFibGU8VD4pID0+IG5ldyBPYnNlcnZhYmxlPFQ+KChzdWJzY3JpYmVyKSA9PiB7XG4gICAgc291cmNlLnN1YnNjcmliZSh7XG4gICAgICAgIG5leHQodmFsdWU6IFQpIHsgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHN1YnNjcmliZXIubmV4dCh2YWx1ZSkpOyB9LFxuICAgICAgICBlcnJvcihlcnI6IGFueSkgeyBzdWJzY3JpYmVyLmVycm9yKGVycik7IH0sXG4gICAgICAgIGNvbXBsZXRlKCkgeyBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7IH0sXG4gICAgfSk7XG59KTsiLCJpbXBvcnQgeyBGb2N1c0tleU1hbmFnZXIgfSBmcm9tICdAYW5ndWxhci9jZGsvYTExeSc7XG5pbXBvcnQgeyBJbmplY3RhYmxlLCBPbkRlc3Ryb3ksIFF1ZXJ5TGlzdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XG5pbXBvcnQgeyBUYWJiYWJsZUxpc3RJdGVtRGlyZWN0aXZlIH0gZnJvbSAnLi90YWJiYWJsZS1saXN0LWl0ZW0uZGlyZWN0aXZlJztcbmltcG9ydCB7IFVQX0FSUk9XLCBSSUdIVF9BUlJPVywgRE9XTl9BUlJPVywgTEVGVF9BUlJPVyB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9rZXljb2Rlcyc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBUYWJiYWJsZUxpc3RTZXJ2aWNlIGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICAgIGhpZXJhcmNoeTogYm9vbGVhbiA9IGZhbHNlO1xuICAgIGFsbG93QWx0TW9kaWZpZXI6IGJvb2xlYW4gPSB0cnVlO1xuICAgIGFsbG93Q3RybE1vZGlmaWVyOiBib29sZWFuID0gdHJ1ZTtcbiAgICBmb2N1c0tleU1hbmFnZXI6IEZvY3VzS2V5TWFuYWdlcjxUYWJiYWJsZUxpc3RJdGVtRGlyZWN0aXZlPjtcblxuICAgIHByaXZhdGUgX2l0ZW1zOiBRdWVyeUxpc3Q8VGFiYmFibGVMaXN0SXRlbURpcmVjdGl2ZT47XG4gICAgcHJpdmF0ZSBfZGlyZWN0aW9uOiAnaG9yaXpvbnRhbCcgfCAndmVydGljYWwnO1xuICAgIHByaXZhdGUgX29uRGVzdHJveSA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fb25EZXN0cm95Lm5leHQoKTtcbiAgICAgICAgdGhpcy5fb25EZXN0cm95LmNvbXBsZXRlKCk7XG4gICAgfVxuXG4gICAgaW5pdGlhbGl6ZShpdGVtczogUXVlcnlMaXN0PFRhYmJhYmxlTGlzdEl0ZW1EaXJlY3RpdmU+LCBkaXJlY3Rpb246ICdob3Jpem9udGFsJyB8ICd2ZXJ0aWNhbCcsIHdyYXA6IGJvb2xlYW4pOiB2b2lkIHtcblxuICAgICAgICAvLyBzdG9yZSB0aGUgaXRlbXNcbiAgICAgICAgdGhpcy5faXRlbXMgPSBpdGVtcztcblxuICAgICAgICAvLyBjcmVhdGUgdGhlIG5ldyBmb2N1cyBrZXkgbWFuYWdlclxuICAgICAgICB0aGlzLmZvY3VzS2V5TWFuYWdlciA9IG5ldyBGb2N1c0tleU1hbmFnZXIoaXRlbXMpO1xuXG4gICAgICAgIC8vIHNldCB0aGUgZGlyZWN0aW9uIG9mIHRoZSBsaXN0XG4gICAgICAgIGRpcmVjdGlvbiA9PT0gJ3ZlcnRpY2FsJyA/IHRoaXMuZm9jdXNLZXlNYW5hZ2VyLndpdGhWZXJ0aWNhbE9yaWVudGF0aW9uKCkgOiB0aGlzLmZvY3VzS2V5TWFuYWdlci53aXRoSG9yaXpvbnRhbE9yaWVudGF0aW9uKCdsdHInKTtcbiAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuXG4gICAgICAgIC8vIGVuYWJsZSB3cmFwcGluZyBpZiByZXF1aXJlZFxuICAgICAgICBpZiAod3JhcCkge1xuICAgICAgICAgICAgdGhpcy5mb2N1c0tleU1hbmFnZXIud2l0aFdyYXAoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgbGlzdCBpcyB0YWJiYWJsZVxuICAgICAgICB0aGlzLnNldEZpcnN0SXRlbVRhYmJhYmxlKCk7XG5cbiAgICAgICAgLy8gY2FsbCB0aGUgaW5pdCBmdW5jdGlvbiBvbiBlYWNoIGl0ZW1cbiAgICAgICAgdGhpcy5faXRlbXMuZm9yRWFjaChpdGVtID0+IGl0ZW0ub25Jbml0KCkpO1xuXG4gICAgICAgIC8vIGlmIHRoZSBsaXN0IGNoYW5nZXMgd2UgbmVlZCB0byBlbnN1cmUgdGhlcmUgaXMgYWx3YXlzIGF0IGxlYXN0IG9uZSB0YWJiYWJsZSBpdGVtXG4gICAgICAgIHRoaXMuX2l0ZW1zLmNoYW5nZXMucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSkuc3Vic2NyaWJlKCgpID0+IHtcblxuICAgICAgICAgICAgLy8gY2FsbCB0aGUgb24gaW5pdCBmdW5jdGlvbiBvbiBhbnkgbmV3IGl0ZW1zXG4gICAgICAgICAgICB0aGlzLl9pdGVtcy5maWx0ZXIoaXRlbSA9PiAhaXRlbS5pbml0aWFsaXplZCkuZm9yRWFjaChpdGVtID0+IGl0ZW0ub25Jbml0KCkpO1xuXG4gICAgICAgICAgICAvLyBlbnN1cmUgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIGl0ZW0gdGFiYmFibGUgYXQgYWxsIHRpbWVzXG4gICAgICAgICAgICB0aGlzLmVuc3VyZVRhYmJhYmxlSXRlbSgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhY3RpdmF0ZShpdGVtOiBUYWJiYWJsZUxpc3RJdGVtRGlyZWN0aXZlKTogdm9pZCB7XG5cbiAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgdGhlIGl0ZW0gaW5kZXhcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9pdGVtcy50b0FycmF5KCkuaW5kZXhPZihpdGVtKTtcblxuICAgICAgICAvLyBhY3RpdmUgdGhlIGl0ZW0gaWYgaXQgaXMgbm90IGFscmVhZHkgYWN0aXZlXG4gICAgICAgIGlmICh0aGlzLmZvY3VzS2V5TWFuYWdlci5hY3RpdmVJdGVtSW5kZXggIT09IGluZGV4KSB7XG4gICAgICAgICAgICB0aGlzLmZvY3VzS2V5TWFuYWdlci5zZXRBY3RpdmVJdGVtKGluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlzSXRlbUFjdGl2ZShpdGVtOiBUYWJiYWJsZUxpc3RJdGVtRGlyZWN0aXZlKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvY3VzS2V5TWFuYWdlci5hY3RpdmVJdGVtLmlkID09PSBpdGVtLmlkO1xuICAgIH1cblxuICAgIHNldEZpcnN0SXRlbVRhYmJhYmxlKCk6IHZvaWQge1xuICAgICAgICAvLyBkZWxheSB0byBwcmV2ZW50IGV4cHJlc3Npb24gY2hhbmdlZCBhZnRlciBjaGVjayBlcnJvclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pdGVtcy5maXJzdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2l0ZW1zLmZpcnN0LnRhYmluZGV4ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZW5zdXJlVGFiYmFibGVJdGVtKCk6IHZvaWQge1xuICAgICAgICAvLyBjaGVjayB0byBzZWUgaWYgYW55IGl0ZW0gaXMgdGFiYmFibGVcbiAgICAgICAgY29uc3QgYWN0aXZlID0gdGhpcy5faXRlbXMuZmluZChpdGVtID0+IGl0ZW0udGFiaW5kZXggPT09IDApO1xuXG4gICAgICAgIGlmICghYWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLnNldEZpcnN0SXRlbVRhYmJhYmxlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb2N1c1RhYmJhYmxlSXRlbSgpOiB2b2lkIHtcblxuICAgICAgICBpZiAoIXRoaXMuX2l0ZW1zKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaW5kIHRoZSBpdGVtIGluIHRoZSBsaXN0IHdpdGggYSB0YWIgaW5kZXhcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9pdGVtcy50b0FycmF5KCkuZmluZEluZGV4KGl0ZW0gPT4gaXRlbS50YWJpbmRleCA9PT0gMCk7XG5cbiAgICAgICAgLy8gaWYgYW4gaXRlbSB3YXMgZm91bmQgdGhlbiBmb2N1cyBpdFxuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmZvY3VzS2V5TWFuYWdlci5zZXRBY3RpdmVJdGVtKGluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgb25LZXlkb3duKHNvdXJjZTogVGFiYmFibGVMaXN0SXRlbURpcmVjdGl2ZSwgZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiBhbnkge1xuXG4gICAgICAgIC8vIHByZXZlbnQgYW55dGhpbmcgaGFwcGVuaW5nIHdoZW4gbW9kaWZpZXIga2V5cyBhcmUgcHJlc3NlZCBpZiB0aGV5IGhhdmUgYmVlbiBkaXNhYmxlZFxuICAgICAgICBpZiAoIXRoaXMuYWxsb3dBbHRNb2RpZmllciAmJiBldmVudC5hbHRLZXkgfHwgIXRoaXMuYWxsb3dDdHJsTW9kaWZpZXIgJiYgZXZlbnQuY3RybEtleSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5mb2N1c0tleU1hbmFnZXIub25LZXlkb3duKGV2ZW50KTtcblxuICAgICAgICBpZiAodGhpcy5oaWVyYXJjaHkpIHtcblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICh0aGlzLl9kaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJyAmJiBldmVudC5rZXlDb2RlID09PSBET1dOX0FSUk9XKSB8fFxuICAgICAgICAgICAgICAgICh0aGlzLl9kaXJlY3Rpb24gPT09ICd2ZXJ0aWNhbCcgJiYgZXZlbnQua2V5Q29kZSA9PT0gUklHSFRfQVJST1cpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBzb3VyY2Uua2V5Ym9hcmRFeHBhbmRlZCQubmV4dCh0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgKHRoaXMuX2RpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnICYmIGV2ZW50LmtleUNvZGUgPT09IFVQX0FSUk9XKSB8fFxuICAgICAgICAgICAgICAgICh0aGlzLl9kaXJlY3Rpb24gPT09ICd2ZXJ0aWNhbCcgJiYgZXZlbnQua2V5Q29kZSA9PT0gTEVGVF9BUlJPVylcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuY2hpbGRyZW4ubGVuZ3RoID4gMCAmJiBzb3VyY2UuZXhwYW5kZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlLmtleWJvYXJkRXhwYW5kZWQkLm5leHQoZmFsc2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlLnBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2UucGFyZW50LmtleWJvYXJkRXhwYW5kZWQkLm5leHQoZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNvcnRJdGVtc0J5SGllcmFyY2h5KGxpc3Q6IFF1ZXJ5TGlzdDxUYWJiYWJsZUxpc3RJdGVtRGlyZWN0aXZlPik6IFRhYmJhYmxlTGlzdEl0ZW1EaXJlY3RpdmVbXSB7XG5cbiAgICAgICAgY29uc3QgdG9wTGV2ZWw6IFRhYmJhYmxlTGlzdEl0ZW1EaXJlY3RpdmVbXSA9IFtdO1xuXG4gICAgICAgIC8vIFBvcHVsYXRpbmcgY2hpbGRyZW4gLSBjbGVhciBwcmV2aW91c2x5IGdlbmVyYXRlZCBjb2xsZWN0aW9uXG4gICAgICAgIGxpc3QuZm9yRWFjaChpdGVtID0+IGl0ZW0uY2hpbGRyZW4gPSBbXSk7XG5cbiAgICAgICAgLy8gUG9wdWxhdGluZyBjaGlsZHJlbiAtIG1hcCBmcm9tIGNoaWxkIC0+IHBhcmVudCByZWxhdGlvbnNoaXBcbiAgICAgICAgbGlzdC5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgaWYgKGl0ZW0ucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgaXRlbS5wYXJlbnQuY2hpbGRyZW4ucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9wTGV2ZWwucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gRmxhdHRlbiB0aGUgdHJlZSB0byBwcm9kdWNlIHRoZSBjdXJzb3Iga2V5IG9yZGVyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuZmxhdHRlbkhpZXJhcmNoeSh0b3BMZXZlbCk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBwcml2YXRlIGZsYXR0ZW5IaWVyYXJjaHkoaXRlbXM6IFRhYmJhYmxlTGlzdEl0ZW1EaXJlY3RpdmVbXSk6IFRhYmJhYmxlTGlzdEl0ZW1EaXJlY3RpdmVbXSB7XG4gICAgICAgIGNvbnN0IGZsYXRMaXN0OiBUYWJiYWJsZUxpc3RJdGVtRGlyZWN0aXZlW10gPSBbXTtcbiAgICAgICAgaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgIGl0ZW0uY2hpbGRyZW4uc29ydCgoYSwgYikgPT4gYS5yYW5rIC0gYi5yYW5rKTtcbiAgICAgICAgICAgIGNvbnN0IGRlc2NlbmRhbnRzID0gdGhpcy5mbGF0dGVuSGllcmFyY2h5KGl0ZW0uY2hpbGRyZW4pO1xuICAgICAgICAgICAgZmxhdExpc3QucHVzaChpdGVtLCAuLi5kZXNjZW5kYW50cyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmxhdExpc3Q7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgRm9jdXNhYmxlT3B0aW9uIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2ExMXknO1xuaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIEhvc3RCaW5kaW5nLCBIb3N0TGlzdGVuZXIsIElucHV0LCBPbkRlc3Ryb3ksIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgbWFwLCB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcbmltcG9ydCB7IHRpY2sgfSBmcm9tICcuLi8uLi8uLi9jb21tb24vaW5kZXgnO1xuaW1wb3J0IHsgVGFiYmFibGVMaXN0U2VydmljZSB9IGZyb20gJy4vdGFiYmFibGUtbGlzdC5zZXJ2aWNlJztcblxubGV0IG5leHRJZCA9IDA7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3V4VGFiYmFibGVMaXN0SXRlbV0nLFxuICAgIGV4cG9ydEFzOiAndXgtdGFiYmFibGUtbGlzdC1pdGVtJ1xufSlcbmV4cG9ydCBjbGFzcyBUYWJiYWJsZUxpc3RJdGVtRGlyZWN0aXZlIGltcGxlbWVudHMgRm9jdXNhYmxlT3B0aW9uLCBPbkRlc3Ryb3kge1xuXG4gICAgQElucHV0KCkgcGFyZW50OiBUYWJiYWJsZUxpc3RJdGVtRGlyZWN0aXZlO1xuXG4gICAgQElucHV0KCkgcmFuazogbnVtYmVyID0gMDtcblxuICAgIEBJbnB1dCgpIGRpc2FibGVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBASW5wdXQoKSBleHBhbmRlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgQE91dHB1dCgpIGV4cGFuZGVkQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG4gICAgQEhvc3RCaW5kaW5nKCkgdGFiaW5kZXg6IG51bWJlciA9IC0xO1xuXG4gICAgaWQ6IG51bWJlciA9IG5leHRJZCsrO1xuXG4gICAgaW5pdGlhbGl6ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIGNoaWxkcmVuOiBUYWJiYWJsZUxpc3RJdGVtRGlyZWN0aXZlW10gPSBbXTtcblxuICAgIGtleWJvYXJkRXhwYW5kZWQkID0gbmV3IFN1YmplY3Q8Ym9vbGVhbj4oKTtcblxuICAgIHByaXZhdGUgX29uRGVzdHJveSA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF90YWJiYWJsZUxpc3Q6IFRhYmJhYmxlTGlzdFNlcnZpY2UsIHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYpIHtcblxuICAgICAgICB0aGlzLmtleWJvYXJkRXhwYW5kZWQkLnBpcGUodGljaygpLCB0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSkuc3Vic2NyaWJlKGV4cGFuZGVkID0+IHtcblxuICAgICAgICAgICAgLy8gRW1pdCBldmVudCB3aGljaCBtYXkgYWx0ZXIgdGhlIERPTVxuICAgICAgICAgICAgdGhpcy5leHBhbmRlZENoYW5nZS5lbWl0KGV4cGFuZGVkKTtcblxuICAgICAgICAgICAgLy8gQWN0aXZhdGUgdGhlIGFwcHJvcHJpYXRlIGl0ZW1cbiAgICAgICAgICAgIGlmIChleHBhbmRlZCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGFiYmFibGVMaXN0LmFjdGl2YXRlKHRoaXMuY2hpbGRyZW5bMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGFiYmFibGVMaXN0LmFjdGl2YXRlKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBvbkluaXQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuX3RhYmJhYmxlTGlzdC5mb2N1c0tleU1hbmFnZXIuY2hhbmdlXG4gICAgICAgICAgICAucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSwgbWFwKCgpID0+IHRoaXMuX3RhYmJhYmxlTGlzdC5pc0l0ZW1BY3RpdmUodGhpcykpKVxuICAgICAgICAgICAgLnN1YnNjcmliZShhY3RpdmUgPT4gdGhpcy50YWJpbmRleCA9IGFjdGl2ZSA/IDAgOiAtMSk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBpcyB0aGUgY3VycmVudGx5IGZvY3VzZWQgaXRlbSAtIGlmIHNvIHdlIG5lZWQgdG8gbWFrZSBhbm90aGVyIGl0ZW0gdGFiYmFibGVcbiAgICAgICAgaWYgKHRoaXMudGFiaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3RhYmJhYmxlTGlzdC5zZXRGaXJzdEl0ZW1UYWJiYWJsZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fb25EZXN0cm95Lm5leHQoKTtcbiAgICAgICAgdGhpcy5fb25EZXN0cm95LmNvbXBsZXRlKCk7XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcignZm9jdXMnKVxuICAgIGZvY3VzKCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGFwcGx5IGZvY3VzIHRvIHRoZSBlbGVtZW50XG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuXG4gICAgICAgIC8vIGVuc3VyZSB0aGUgZm9jdXMga2V5IG1hbmFnZXIgdXBkYXRlcyB0aGUgYWN0aXZlIGl0ZW0gY29ycmVjdGx5XG4gICAgICAgIHRoaXMuX3RhYmJhYmxlTGlzdC5hY3RpdmF0ZSh0aGlzKTtcbiAgICB9XG5cbiAgICBASG9zdExpc3RlbmVyKCdrZXlkb3duJywgWyckZXZlbnQnXSlcbiAgICBvbktleWRvd24oZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fdGFiYmFibGVMaXN0Lm9uS2V5ZG93bih0aGlzLCBldmVudCk7XG4gICAgfVxufSIsImltcG9ydCB7IEZvY3VzS2V5TWFuYWdlciB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9hMTF5JztcbmltcG9ydCB7IEFmdGVyQ29udGVudEluaXQsIENvbnRlbnRDaGlsZHJlbiwgRGlyZWN0aXZlLCBJbnB1dCwgT25EZXN0cm95LCBRdWVyeUxpc3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFRhYmJhYmxlTGlzdEl0ZW1EaXJlY3RpdmUgfSBmcm9tICcuL3RhYmJhYmxlLWxpc3QtaXRlbS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgVGFiYmFibGVMaXN0U2VydmljZSB9IGZyb20gJy4vdGFiYmFibGUtbGlzdC5zZXJ2aWNlJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbdXhUYWJiYWJsZUxpc3RdJyxcbiAgICBleHBvcnRBczogJ3V4LXRhYmJhYmxlLWxpc3QnLFxuICAgIHByb3ZpZGVyczogW1RhYmJhYmxlTGlzdFNlcnZpY2VdXG59KVxuZXhwb3J0IGNsYXNzIFRhYmJhYmxlTGlzdERpcmVjdGl2ZSBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQsIE9uRGVzdHJveSB7XG5cbiAgICAvKiogRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIHVwL2Rvd24gYXJyb3dzIHNob3VsZCBiZSB1c2VkIG9yIHRoZSBsZWZ0L3JpZ2h0IGFycm93cyAqL1xuICAgIEBJbnB1dCgpIGRpcmVjdGlvbjogJ2hvcml6b250YWwnIHwgJ3ZlcnRpY2FsJyA9ICd2ZXJ0aWNhbCc7XG5cbiAgICAvKiogSW5kaWNhdGUgd2hldGhlciBvciBub3QgZm9jdXMgc2hvdWxkIGxvb3AgYmFjayB0byB0aGUgZmlyc3QgZWxlbWVudCBhZnRlciB0aGUgbGFzdCAqL1xuICAgIEBJbnB1dCgpIHdyYXA6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgLyoqIEluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoZSBmaXJzdCBpdGVtIHNob3VsZCByZWNlaXZlIGZvY3VzIG9uIHNob3cgLSB1c2VmdWwgZm9yIG1vZGFscyBhbmQgcG9wb3ZlcnMgKi9cbiAgICBASW5wdXQoKSBmb2N1c09uU2hvdzogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqIEluZGljYXRlIHdoZXRoZXIgb3Igbm90IGZvY3VzIHNob3VsZCBiZSByZXR1cm5lZCB0byB0aGUgcHJldmlvdXMgZWxlbWVudCAob25seSBhcHBsaWNhYmxlIHdoZW4gdXNpbmcgZm9jdXNPblNob3cpICovXG4gICAgQElucHV0KCkgcmV0dXJuRm9jdXM6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKiBFbmFibGluZyBoYW5kbGluZyBvZiBoaWVyYXJjaGljYWwgbGlzdHMgdmlhIHVzZSBvZiB0aGUgYFRhYmJhYmxlTGlzdEl0ZW1EaXJlY3RpdmUucGFyZW50YCBwcm9wZXJ0eS4gKi9cbiAgICBASW5wdXQoKSBzZXQgaGllcmFyY2h5KHZhbHVlOiBib29sZWFuKSB7IHRoaXMuX3RhYmJhYmxlTGlzdC5oaWVyYXJjaHkgPSB2YWx1ZTsgfVxuXG4gICAgLyoqIFByZXZlbnQga2V5Ym9hcmQgaW50ZXJhY3Rpb24gd2hlbiBhbHQgbW9kaWZpZXIga2V5IGlzIHByZXNzZWQgKi9cbiAgICBASW5wdXQoKSBzZXQgYWxsb3dBbHRNb2RpZmllcih2YWx1ZTogYm9vbGVhbikgeyB0aGlzLl90YWJiYWJsZUxpc3QuYWxsb3dBbHRNb2RpZmllciA9IHZhbHVlOyB9XG5cbiAgICAvKiogUHJldmVudCBrZXlib2FyZCBpbnRlcmFjdGlvbiB3aGVuIGN0cmwgbW9kaWZpZXIga2V5IGlzIHByZXNzZWQgKi9cbiAgICBASW5wdXQoKSBzZXQgYWxsb3dDdHJsTW9kaWZpZXIodmFsdWU6IGJvb2xlYW4pIHsgdGhpcy5fdGFiYmFibGVMaXN0LmFsbG93Q3RybE1vZGlmaWVyID0gdmFsdWU7IH1cblxuICAgIC8qKiBGaW5kIGFsbCB0YWJiYWJsZSBsaXN0IGl0ZW1zICovXG4gICAgQENvbnRlbnRDaGlsZHJlbihUYWJiYWJsZUxpc3RJdGVtRGlyZWN0aXZlLCB7IGRlc2NlbmRhbnRzOiB0cnVlIH0pIGl0ZW1zOiBRdWVyeUxpc3Q8VGFiYmFibGVMaXN0SXRlbURpcmVjdGl2ZT47XG5cbiAgICBwcml2YXRlIF9mb2N1c2VkRWxlbWVudDogSFRNTEVsZW1lbnQ7XG4gICAgcHJpdmF0ZSBfb3JkZXJlZEl0ZW1zOiBRdWVyeUxpc3Q8VGFiYmFibGVMaXN0SXRlbURpcmVjdGl2ZT47XG5cbiAgICBnZXQgZm9jdXNLZXlNYW5hZ2VyKCk6IEZvY3VzS2V5TWFuYWdlcjxUYWJiYWJsZUxpc3RJdGVtRGlyZWN0aXZlPiB7XG4gICAgICAgIHJldHVybiB0aGlzLl90YWJiYWJsZUxpc3QuZm9jdXNLZXlNYW5hZ2VyO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX3RhYmJhYmxlTGlzdDogVGFiYmFibGVMaXN0U2VydmljZSkgeyB9XG5cbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gc3RvcmUgdGhlIGN1cnJlbnRseSBmb2N1c2VkIGVsZW1lbnRcbiAgICAgICAgdGhpcy5fZm9jdXNlZEVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGFzIEhUTUxFbGVtZW50O1xuXG4gICAgICAgIGlmICh0aGlzLl90YWJiYWJsZUxpc3QuaGllcmFyY2h5KSB7XG5cbiAgICAgICAgICAgIC8vIFNvcnQgaXRlbXMgaW4gYSBoaWVyYXJjaHlcbiAgICAgICAgICAgIHRoaXMuX29yZGVyZWRJdGVtcyA9IG5ldyBRdWVyeUxpc3Q8VGFiYmFibGVMaXN0SXRlbURpcmVjdGl2ZT4oKTtcbiAgICAgICAgICAgIHRoaXMuX29yZGVyZWRJdGVtcy5yZXNldCh0aGlzLl90YWJiYWJsZUxpc3Quc29ydEl0ZW1zQnlIaWVyYXJjaHkodGhpcy5pdGVtcykpO1xuXG4gICAgICAgICAgICAvLyBFbnN1cmUgdGhhdCB0aGUgY2hpbGQgaXRlbXMgcmVtYWluIHNvcnRlZFxuICAgICAgICAgICAgdGhpcy5pdGVtcy5jaGFuZ2VzLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb3JkZXJlZEl0ZW1zLnJlc2V0KHRoaXMuX3RhYmJhYmxlTGlzdC5zb3J0SXRlbXNCeUhpZXJhcmNoeSh0aGlzLml0ZW1zKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fb3JkZXJlZEl0ZW1zLm5vdGlmeU9uQ2hhbmdlcygpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgLy8gSXRlbXMgYXJlIGFscmVhZHkgaW4gb3JkZXJcbiAgICAgICAgICAgIHRoaXMuX29yZGVyZWRJdGVtcyA9IHRoaXMuaXRlbXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXQgdXAgdGhlIGZvY3VzIG1vbml0b3JpbmdcbiAgICAgICAgdGhpcy5fdGFiYmFibGVMaXN0LmluaXRpYWxpemUodGhpcy5fb3JkZXJlZEl0ZW1zLCB0aGlzLmRpcmVjdGlvbiwgdGhpcy53cmFwKTtcblxuICAgICAgICAvLyBmb2N1cyB0aGUgZmlyc3QgZWxlbWVudCBpZiBzcGVjaWZpZWRcbiAgICAgICAgaWYgKHRoaXMuZm9jdXNPblNob3cpIHtcbiAgICAgICAgICAgIHRoaXMuX3RhYmJhYmxlTGlzdC5mb2N1c0tleU1hbmFnZXIuc2V0Rmlyc3RJdGVtQWN0aXZlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMucmV0dXJuRm9jdXMgJiYgdGhpcy5fZm9jdXNlZEVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLl9mb2N1c2VkRWxlbWVudC5mb2N1cygpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvY3VzKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5fdGFiYmFibGVMaXN0LmZvY3VzS2V5TWFuYWdlciAmJiB0aGlzLl90YWJiYWJsZUxpc3QuZm9jdXNLZXlNYW5hZ2VyLmFjdGl2ZUl0ZW0pIHtcbiAgICAgICAgICAgIHRoaXMuX3RhYmJhYmxlTGlzdC5mb2N1c0tleU1hbmFnZXIuYWN0aXZlSXRlbS5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9jdXNUYWJiYWJsZUl0ZW0oKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3RhYmJhYmxlTGlzdC5mb2N1c1RhYmJhYmxlSXRlbSgpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IEExMXlNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jZGsvYTExeSc7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRm9jdXNXaXRoaW5EaXJlY3RpdmUgfSBmcm9tICcuL2ZvY3VzLXdpdGhpbi9mb2N1cy13aXRoaW4uZGlyZWN0aXZlJztcbmltcG9ydCB7IFNwbGl0dGVyQWNjZXNzaWJpbGl0eURpcmVjdGl2ZSB9IGZyb20gJy4vc3BsaXR0ZXIvc3BsaXR0ZXItYWNjZXNzaWJpbGl0eS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgVGFiYmFibGVMaXN0SXRlbURpcmVjdGl2ZSB9IGZyb20gJy4vdGFiYmFibGUtbGlzdC90YWJiYWJsZS1saXN0LWl0ZW0uZGlyZWN0aXZlJztcbmltcG9ydCB7IFRhYmJhYmxlTGlzdERpcmVjdGl2ZSB9IGZyb20gJy4vdGFiYmFibGUtbGlzdC90YWJiYWJsZS1saXN0LmRpcmVjdGl2ZSc7XG5cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIEZvY3VzV2l0aGluRGlyZWN0aXZlLFxuICAgICAgICBUYWJiYWJsZUxpc3REaXJlY3RpdmUsXG4gICAgICAgIFRhYmJhYmxlTGlzdEl0ZW1EaXJlY3RpdmUsXG4gICAgICAgIFNwbGl0dGVyQWNjZXNzaWJpbGl0eURpcmVjdGl2ZVxuICAgIF0sXG4gICAgaW1wb3J0czogW1xuICAgICAgICBBMTF5TW9kdWxlXG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIEZvY3VzV2l0aGluRGlyZWN0aXZlLFxuICAgICAgICBUYWJiYWJsZUxpc3REaXJlY3RpdmUsXG4gICAgICAgIFRhYmJhYmxlTGlzdEl0ZW1EaXJlY3RpdmUsXG4gICAgICAgIFNwbGl0dGVyQWNjZXNzaWJpbGl0eURpcmVjdGl2ZVxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgQWNjZXNzaWJpbGl0eU1vZHVsZSB7fSIsImltcG9ydCB7IENvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBmb3J3YXJkUmVmLCBJbnB1dCwgT3V0cHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb250cm9sVmFsdWVBY2Nlc3NvciwgTkdfVkFMVUVfQUNDRVNTT1IgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmV4cG9ydCBjb25zdCBOVU1CRVJfUElDS0VSX1ZBTFVFX0FDQ0VTU09SOiBhbnkgPSB7XG4gICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTnVtYmVyUGlja2VyQ29tcG9uZW50KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1udW1iZXItcGlja2VyJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vbnVtYmVyLXBpY2tlci5jb21wb25lbnQuaHRtbCcsXG4gICAgcHJvdmlkZXJzOiBbTlVNQkVSX1BJQ0tFUl9WQUxVRV9BQ0NFU1NPUl0sXG4gICAgaG9zdDoge1xuICAgICAgICAnW2NsYXNzLmhhcy1lcnJvcl0nOiAnIWlzVmFsaWQoKSdcbiAgICB9XG59KVxuZXhwb3J0IGNsYXNzIE51bWJlclBpY2tlckNvbXBvbmVudCBpbXBsZW1lbnRzIENvbnRyb2xWYWx1ZUFjY2Vzc29yIHtcblxuICAgIHByaXZhdGUgX21pbjogbnVtYmVyID0gLUluZmluaXR5O1xuICAgIHByaXZhdGUgX21heDogbnVtYmVyID0gSW5maW5pdHk7XG4gICAgcHJpdmF0ZSBfc3RlcDogbnVtYmVyID0gMTtcbiAgICBwcml2YXRlIF9kaXNhYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIHByaXZhdGUgX3ZhbHVlOiBudW1iZXIgPSAwO1xuICAgIHByaXZhdGUgX3Byb3BhZ2F0ZUNoYW5nZSA9IChfOiBhbnkpID0+IHsgfTtcblxuICAgIEBJbnB1dCgpIHZhbGlkOiBib29sZWFuID0gdHJ1ZTtcbiAgICBAT3V0cHV0KCkgdmFsdWVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPG51bWJlcj4oKTtcblxuICAgIEBJbnB1dCgndmFsdWUnKVxuICAgIGdldCB2YWx1ZSgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgfVxuICAgIHNldCB2YWx1ZSh2YWx1ZTogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMudmFsdWVDaGFuZ2UuZW1pdCh2YWx1ZSk7XG4gICAgICAgIHRoaXMuX3Byb3BhZ2F0ZUNoYW5nZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgQElucHV0KClcbiAgICBnZXQgbWluKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9taW47XG4gICAgfVxuICAgIHNldCBtaW4odmFsdWUpIHtcbiAgICAgICAgdGhpcy5fbWluID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHBhcnNlRmxvYXQodmFsdWUpIDogdmFsdWU7XG4gICAgfVxuXG4gICAgQElucHV0KClcbiAgICBnZXQgbWF4KCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXg7XG4gICAgfVxuICAgIHNldCBtYXgodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fbWF4ID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHBhcnNlRmxvYXQodmFsdWUpIDogdmFsdWU7XG4gICAgfVxuXG4gICAgQElucHV0KClcbiAgICBnZXQgc3RlcCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RlcDtcbiAgICB9XG4gICAgc2V0IHN0ZXAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fc3RlcCA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyBwYXJzZUZsb2F0KHZhbHVlKSA6IHZhbHVlO1xuICAgIH1cblxuICAgIEBJbnB1dCgpXG4gICAgZ2V0IGRpc2FibGVkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlzYWJsZWQ7XG4gICAgfVxuICAgIHNldCBkaXNhYmxlZCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9kaXNhYmxlZCA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gJ3RydWUnIHx8IHZhbHVlID09PSAnZGlzYWJsZWQnKSB8fCB2YWx1ZSA9PT0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpbmNyZW1lbnQoZXZlbnQ6IE1vdXNlRXZlbnQgfCBLZXlib2FyZEV2ZW50KTogdm9pZCB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gTWF0aC5tYXgoTWF0aC5taW4odGhpcy52YWx1ZSArIHRoaXMuc3RlcCwgdGhpcy5tYXgpLCB0aGlzLm1pbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZWNyZW1lbnQoZXZlbnQ6IE1vdXNlRXZlbnQgfCBLZXlib2FyZEV2ZW50KTogdm9pZCB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gTWF0aC5taW4oTWF0aC5tYXgodGhpcy52YWx1ZSAtIHRoaXMuc3RlcCwgdGhpcy5taW4pLCB0aGlzLm1heCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpc1ZhbGlkKCk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSA8IHRoaXMubWluIHx8IHRoaXMudmFsdWUgPiB0aGlzLm1heCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudmFsaWQ7XG4gICAgfVxuXG4gICAgb25TY3JvbGwoZXZlbnQ6IFdoZWVsRXZlbnQpOiB2b2lkIHtcblxuICAgICAgICBsZXQgc2Nyb2xsVmFsdWUgPSBldmVudC5kZWx0YVkgfHwgZXZlbnQud2hlZWxEZWx0YTtcblxuICAgICAgICBpZiAoc2Nyb2xsVmFsdWUgPCAwKSB7XG4gICAgICAgICAgICB0aGlzLmluY3JlbWVudChldmVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlY3JlbWVudChldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB3cml0ZVZhbHVlKHZhbHVlOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZWdpc3Rlck9uQ2hhbmdlKGZuOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fcHJvcGFnYXRlQ2hhbmdlID0gZm47XG4gICAgfVxuXG4gICAgcmVnaXN0ZXJPblRvdWNoZWQoZm46IGFueSk6IHZvaWQgeyB9XG5cbiAgICBzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQ6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGlzRGlzYWJsZWQ7XG4gICAgfVxuXG59IiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZvcm1zTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcblxuaW1wb3J0IHsgTnVtYmVyUGlja2VyQ29tcG9uZW50IH0gZnJvbSAnLi9udW1iZXItcGlja2VyLmNvbXBvbmVudCc7XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlXG4gICAgXSxcbiAgICBleHBvcnRzOiBbTnVtYmVyUGlja2VyQ29tcG9uZW50XSxcbiAgICBkZWNsYXJhdGlvbnM6IFtOdW1iZXJQaWNrZXJDb21wb25lbnRdXG59KVxuZXhwb3J0IGNsYXNzIE51bWJlclBpY2tlck1vZHVsZSB7IH1cbiIsImltcG9ydCB7IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDaGFuZ2VEZXRlY3RvclJlZiwgQ29tcG9uZW50LCBUZW1wbGF0ZVJlZiwgT25EZXN0cm95IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBBbmNob3JQbGFjZW1lbnQgfSBmcm9tICcuL3Rvb2x0aXAuZGlyZWN0aXZlJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzL1N1YmplY3QnO1xuXG5sZXQgdW5pcXVlVG9vbHRpcElkID0gMDtcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAndXgtdG9vbHRpcCcsXG4gIHRlbXBsYXRlVXJsOiAnLi90b29sdGlwLmNvbXBvbmVudC5odG1sJyxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgVG9vbHRpcENvbXBvbmVudCBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG5cbiAgLyoqIERlZmluZSBhIHVuaXF1ZSBpZCBmb3IgZWFjaCB0b29sdGlwICovXG4gIGlkOiBzdHJpbmcgPSBgdXgtdG9vbHRpcC0keysrdW5pcXVlVG9vbHRpcElkfWA7XG5cbiAgLyoqIERlZmluZSB0aGUgdG9vbHRpcCByb2xlICovXG4gIHJvbGU6IHN0cmluZyA9ICd0b29sdGlwJztcblxuICAvKiogVGhlIGNvbnRlbnQgb2YgdGhlIHRvb2x0aXAsIGVpdGhlciBhIHN0cmluZyBvciBhIFRlbXBsYXRlUmVmIGZvciBmdXJ0aGVyIGN1c3RvbWl6YXRpb24gKi9cbiAgY29udGVudDogc3RyaW5nIHwgVGVtcGxhdGVSZWY8YW55PjtcblxuICAvKiogQWxsb3cgdGhlIHVzZXIgdG8gc3VwcGx5IGEgY29udGV4dCBmb3IgdGhlIHRvb2x0aXAgVGVtcGxhdGVSZWYgKi9cbiAgY29udGV4dDogYW55O1xuXG4gIC8qKiBUaGUgcG9zaXRpb24gdGhlIHRvb2x0aXAgc2hvdWxkIGRpc3BsYXkgcmVsYXRpdmUgdG8gdGhlIGFzc29jaWF0ZWQgZWxlbWVudCAqL1xuICBwbGFjZW1lbnQ6IEFuY2hvclBsYWNlbWVudDtcblxuICAvKiogQWxsb3cgYSBjdXN0b20gY2xhc3MgdG8gYmUgYWRkZWQgdG8gdGhlIHRvb2x0aXAgdG8gYWxsb3cgY3VzdG9tIHN0eWxpbmcgKi9cbiAgY3VzdG9tQ2xhc3M6IHN0cmluZyA9ICcnO1xuXG4gIC8qKiBJbmRpY2F0ZXMgd2hldGhlciBvciBub3QgdGhlIGNvbnRlbnQgaXMgYSBzdHJpbmcgb3IgYSBUZW1wbGF0ZVJlZiAqL1xuICBpc1RlbXBsYXRlUmVmOiBib29sZWFuID0gZmFsc2U7XG5cbiAgLyoqIEVtaXQgd2hlbiB0aGUgdG9vbHRpcCBuZWVkIHRvIHVwZGF0ZSBpdCdzIHBvc2l0aW9uICovXG4gIHJlcG9zaXRpb24kID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgX2NoYW5nZURldGVjdG9yUmVmOiBDaGFuZ2VEZXRlY3RvclJlZikge31cblxuICAvKiogQ2xlYW51cCBhZnRlciB0aGUgY29tcG9uZW50IGlzIGRlc3Ryb3llZCAqL1xuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLnJlcG9zaXRpb24kLmNvbXBsZXRlKCk7XG4gIH1cblxuICAvKiogSW5mb3JtIHRoZSBwYXJlbnQgZGlyZWN0aXZlIHRoYXQgaXQgbmVlZHMgdG8gcmVjYWx1bGF0ZSB0aGUgcG9zaXRpb24gKi9cbiAgcmVwb3NpdGlvbigpOiB2b2lkIHtcbiAgICB0aGlzLnJlcG9zaXRpb24kLm5leHQoKTtcbiAgfVxuXG4gIC8qKiBUaGlzIHdpbGwgdXBkYXRlIHRoZSBjb250ZW50IG9mIHRoZSB0b29sdGlwIGFuZCB0cmlnZ2VyIGNoYW5nZSBkZXRlY3Rpb24gKi9cbiAgc2V0Q29udGVudChjb250ZW50OiBzdHJpbmcgfCBUZW1wbGF0ZVJlZjxhbnk+KTogdm9pZCB7XG4gICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICB0aGlzLmlzVGVtcGxhdGVSZWYgPSBjb250ZW50IGluc3RhbmNlb2YgVGVtcGxhdGVSZWY7XG4gICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gIH1cblxuICAvKiogVGhpcyB3aWxsIHVwZGF0ZSB0aGUgdG9vbHRpcCBwbGFjZW1lbnQgYW5kIHRyaWdnZXIgY2hhbmdlIGRldGVjdGlvbiAqL1xuICBzZXRQbGFjZW1lbnQocGxhY2VtZW50OiBBbmNob3JQbGFjZW1lbnQpIHtcblxuICAgIGlmICghcGxhY2VtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5wbGFjZW1lbnQgPSBwbGFjZW1lbnQ7XG4gICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gIH1cblxuICAvKiogVGhpcyB3aWxsIHNldCBhIGN1c3RvbSBjbGFzcyBvbiB0aGUgdG9vbHRpcCBhbmQgdHJpZ2dlciBjaGFuZ2UgZGV0ZWN0aW9uICovXG4gIHNldENsYXNzKGN1c3RvbUNsYXNzOiBzdHJpbmcpOiB2b2lkIHtcblxuICAgIGlmICghY3VzdG9tQ2xhc3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmN1c3RvbUNsYXNzID0gY3VzdG9tQ2xhc3M7XG4gICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gIH1cblxuICAvKiogVXBkYXRlcyB0aGUgY29udGV4dCB1c2VkIGJ5IHRoZSBUZW1wbGF0ZVJlZiAqL1xuICBzZXRDb250ZXh0KGNvbnRleHQ6IGFueSk6IHZvaWQge1xuXG4gICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgfVxuXG4gIC8qKiBTcGVjaWZ5IHRoZSB0b29sdGlwIHJvbGUgYXR0cmlidXRlICovXG4gIHNldFJvbGUocm9sZTogc3RyaW5nKTogdm9pZCB7XG5cbiAgICBpZiAoIXJvbGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnJvbGUgPSByb2xlO1xuICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICB9XG59IiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVG9vbHRpcENvbXBvbmVudCB9IGZyb20gJy4vdG9vbHRpcC5jb21wb25lbnQnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBUb29sdGlwU2VydmljZSB7XG4gICAgc2hvd24kID0gbmV3IFN1YmplY3Q8VG9vbHRpcENvbXBvbmVudD4oKTtcbn0iLCJpbXBvcnQgeyBPcmlnaW5Db25uZWN0aW9uUG9zaXRpb24sIE92ZXJsYXksIE92ZXJsYXlDb25uZWN0aW9uUG9zaXRpb24sIE92ZXJsYXlSZWYsIFNjcm9sbERpc3BhdGNoZXIgfSBmcm9tICdAYW5ndWxhci9jZGsvb3ZlcmxheSc7XG5pbXBvcnQgeyBDb21wb25lbnRQb3J0YWwgfSBmcm9tICdAYW5ndWxhci9jZGsvcG9ydGFsJztcbmltcG9ydCB7IENoYW5nZURldGVjdG9yUmVmLCBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE9uQ2hhbmdlcywgT25EZXN0cm95LCBPbkluaXQsIE91dHB1dCwgUmVuZGVyZXIyLCBTaW1wbGVDaGFuZ2VzLCBUZW1wbGF0ZVJlZiwgVmlld0NvbnRhaW5lclJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XG5pbXBvcnQgeyBmcm9tRXZlbnQgfSBmcm9tICdyeGpzL29ic2VydmFibGUvZnJvbUV2ZW50JztcbmltcG9ydCB7IGZpbHRlciwgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgVG9vbHRpcENvbXBvbmVudCB9IGZyb20gJy4vdG9vbHRpcC5jb21wb25lbnQnO1xuaW1wb3J0IHsgVG9vbHRpcFNlcnZpY2UgfSBmcm9tICcuL3Rvb2x0aXAuc2VydmljZSc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3V4VG9vbHRpcF0nLFxuICAgIGV4cG9ydEFzOiAndXgtdG9vbHRpcCdcbn0pXG5leHBvcnQgY2xhc3MgVG9vbHRpcERpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCwgT25DaGFuZ2VzLCBPbkRlc3Ryb3kge1xuXG4gICAgLyoqIENvbnRhaW5zIHRoZSBjb250ZW50IG9mIHRoZSB0b29sdGlwIG9yIGEgVGVtcGxhdGVSZWYgZm9yIG1vcmUgZGV0YWlsZWQgY29udGVudCAqL1xuICAgIEBJbnB1dCgndXhUb29sdGlwJykgY29udGVudDogc3RyaW5nIHwgVGVtcGxhdGVSZWY8YW55PjtcblxuICAgIC8qKiBBbGxvdyB0aGUgdG9vbHRpcCB0byBiZSBjb25kaXRpb25hbGx5IGRpc2FibGVkICovXG4gICAgQElucHV0KCd0b29sdGlwRGlzYWJsZWQnKSBkaXNhYmxlZDogYm9vbGVhbjtcblxuICAgIC8qKiBBbGwgdGhlIHVzZXIgdG8gYWRkIGEgY3VzdG9tIGNsYXNzIHRvIHRoZSB0b29sdGlwICovXG4gICAgQElucHV0KCd0b29sdGlwQ2xhc3MnKSBjdXN0b21DbGFzczogc3RyaW5nID0gJyc7XG5cbiAgICAvKiogQWxsIHRoZSB1c2VyIHRvIGFkZCBhIHJvbGUgdG8gdGhlIHRvb2x0aXAgLSBkZWZhdWx0IGlzIHRvb2x0aXAgKi9cbiAgICBASW5wdXQoJ3Rvb2x0aXBSb2xlJykgcm9sZTogc3RyaW5nID0gJ3Rvb2x0aXAnO1xuXG4gICAgLyoqIFByb3ZpZGUgdGhlIFRlbXBsYXRlUmVmIGEgY29udGV4dCBvYmplY3QgKi9cbiAgICBASW5wdXQoJ3Rvb2x0aXBDb250ZXh0JykgY29udGV4dDogYW55ID0ge307XG5cbiAgICAvKiogRGVsYXkgdGhlIHNob3dpbmcgb2YgdGhlIHRvb2x0aXAgYnkgYSBudW1iZXIgb2YgbWlsaXNlY29uZHMgKi9cbiAgICBASW5wdXQoJ3Rvb2x0aXBEZWxheScpIGRlbGF5OiBudW1iZXIgPSAwO1xuXG4gICAgLyoqIFByb2dyYW1tYXRpY2FsbHkgc2hvdyBhbmQgaGlkZSB0aGUgdG9vbHRpcCAqL1xuICAgIEBJbnB1dCgpIGlzT3BlbjogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqIEN1c3RvbWl6ZSBob3cgdGhlIHRvb2x0aXAgc2hvdWxkIGJlIHBvc2l0aW9uZWQgcmVsYXRpdmUgdG8gdGhlIGVsZW1lbnQgKi9cbiAgICBASW5wdXQoKSBwbGFjZW1lbnQ6IEFuY2hvclBsYWNlbWVudCA9ICd0b3AnO1xuXG4gICAgLyoqIFNwZWNpZnkgd2hpY2ggZXZlbnRzIHNob3VsZCBzaG93IHRoZSB0b29sdGlwICovXG4gICAgQElucHV0KCkgc2hvd1RyaWdnZXJzOiBzdHJpbmdbXSA9IFsnbW91c2VlbnRlcicsICdmb2N1cyddO1xuXG4gICAgLyoqIFNwZWNpZnkgd2hpY2ggZXZlbnRzIHNob3VsZCBoaWRlIHRoZSB0b29sdGlwICovXG4gICAgQElucHV0KCkgaGlkZVRyaWdnZXJzOiBzdHJpbmdbXSA9IFsnbW91c2VsZWF2ZScsICdibHVyJ107XG5cbiAgICAvKiogRW1pdHMgYW4gZXZlbnQgd2hlbiB0aGUgdG9vbHRpcCBpcyBzaG93biAqL1xuICAgIEBPdXRwdXQoKSBzaG93biA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcblxuICAgIC8qKiBFbWl0cyBhIGV2ZW50IHdoZW4gdGhlIHRvb2x0aXAgaXMgaGlkZGVuICovXG4gICAgQE91dHB1dCgpIGhpZGRlbiA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcblxuICAgIC8qKiBBbGxvdyB0d28gd2F5IGJpbmRpbmcgdG8gdHJhY2sgdGhlIHZpc2liaWxpdHkgb2YgdGhlIHRvb2x0aXAgKi9cbiAgICBAT3V0cHV0KCkgaXNPcGVuQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG4gICAgLyoqIEtlZXAgdHJhY2sgb2YgdGhlIHRvb2x0aXAgdmlzaWJpbGl0eSAqL1xuICAgIGlzVmlzaWJsZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqIEEgcmVmZXJlbmNlIHRvIHRoZSBDREsgcG9ydGFsIGNvbnRhaW5pbmcgdGhlIG92ZXJsYXkgKi9cbiAgICBwcm90ZWN0ZWQgX3BvcnRhbDogQ29tcG9uZW50UG9ydGFsPFRvb2x0aXBDb21wb25lbnQ+O1xuXG4gICAgLyoqIEEgcmVmZXJlbmNlIHRvIHRoZSBvdmVybGF5IHRoZSB0b29sdGlwIHdpbGwgYmUgaW5zZXJ0ZWQgaW50byAqL1xuICAgIHByb3RlY3RlZCBfb3ZlcmxheVJlZjogT3ZlcmxheVJlZjtcblxuICAgIC8qKiBBIHJlZmVyZW5jZSB0byB0aGUgaW5zdGFuY2Ugb2YgdGhlIHRvb2x0aXAgY29tcG9uZW50IHdoZW4gY3JlYXRlZCAqL1xuICAgIHByb3RlY3RlZCBfaW5zdGFuY2U6IFRvb2x0aXBDb21wb25lbnQ7XG5cbiAgICAvKiogVGhpcyB3aWxsIGVtaXQgd2hlbiB0aGUgZGlyZWN0aXZlIGlzIGRlc3Ryb3llZCBhbGxvd2luZyB1cyB0byB1bnN1YnNjcmliZSBhbGwgc3Vic2NyaXB0aW9ucyBhdXRvbWF0aWNhbGx5ICovXG4gICAgcHJvdGVjdGVkIF9vbkRlc3Ryb3kgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gICAgLyoqIFN0b3JlIHRoZSB0aW1lb3V0IGludGVydmFsIGZvciBjYW5jZWxhdGlvbiAqL1xuICAgIHByaXZhdGUgX3Nob3dUaW1lb3V0SWQ6IG51bWJlcjtcblxuICAgIC8qKiBJbnRlcm5hbGx5IHN0b3JlIHRoZSB0eXBlIG9mIHRoaXMgY29tcG9uZW50IC0gdXN1YWwgZm9yIGRpc3RpbmN0aW9ucyB3aGVuIGV4dGVuZGluZyB0aGlzIGNsYXNzICovXG4gICAgcHJvdGVjdGVkIF90eXBlOiBzdHJpbmcgPSAndG9vbHRpcCc7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJvdGVjdGVkIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgICAgICBwcm90ZWN0ZWQgX3ZpZXdDb250YWluZXJSZWY6IFZpZXdDb250YWluZXJSZWYsXG4gICAgICAgIHByb3RlY3RlZCBfb3ZlcmxheTogT3ZlcmxheSxcbiAgICAgICAgcHJvdGVjdGVkIF9zY3JvbGxEaXNwYXRjaGVyOiBTY3JvbGxEaXNwYXRjaGVyLFxuICAgICAgICBwcml2YXRlIF9jaGFuZ2VEZXRlY3RvclJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgICAgIHByaXZhdGUgX3JlbmRlcmVyOiBSZW5kZXJlcjIsXG4gICAgICAgIHByaXZhdGUgX3Rvb2x0aXBTZXJ2aWNlOiBUb29sdGlwU2VydmljZVxuICAgICkgeyB9XG5cbiAgICAvKiogU2V0IHVwIHRoZSB0cmlnZ2VycyBhbmQgYmluZCB0byB0aGUgc2hvdy9oaWRlIGV2ZW50cyB0byBrZWVwIHZpc2liaWxpdHkgaW4gc3luYyAqL1xuICAgIG5nT25Jbml0KCk6IHZvaWQge1xuXG4gICAgICAgIC8vIHNldCB1cCBzaG93IGFuZCBoaWRlIGV2ZW50IHRyaWdnZXJzXG4gICAgICAgIGZyb21FdmVudCh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdjbGljaycpLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZSh0aGlzLm9uQ2xpY2suYmluZCh0aGlzKSk7XG4gICAgICAgIGZyb21FdmVudCh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdtb3VzZWVudGVyJykucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSkuc3Vic2NyaWJlKHRoaXMub25Nb3VzZUVudGVyLmJpbmQodGhpcykpO1xuICAgICAgICBmcm9tRXZlbnQodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnbW91c2VsZWF2ZScpLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZSh0aGlzLm9uTW91c2VMZWF2ZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgZnJvbUV2ZW50KHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2ZvY3VzJykucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSkuc3Vic2NyaWJlKHRoaXMub25Gb2N1cy5iaW5kKHRoaXMpKTtcbiAgICAgICAgZnJvbUV2ZW50KHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2JsdXInKS5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUodGhpcy5vbkJsdXIuYmluZCh0aGlzKSk7XG5cbiAgICAgICAgLy8gd2hlbiBhbnkgb3RoZXIgdG9vbHRpcHMgb3BlbiBoaWRlIHRoaXMgb25lXG4gICAgICAgIHRoaXMuX3Rvb2x0aXBTZXJ2aWNlLnNob3duJC5waXBlKFxuICAgICAgICAgICAgZmlsdGVyKCgpID0+IHRoaXMuX3R5cGUgPT09ICd0b29sdGlwJyksXG4gICAgICAgICAgICBmaWx0ZXIodG9vbHRpcCA9PiB0b29sdGlwICE9PSB0aGlzLl9pbnN0YW5jZSksXG4gICAgICAgICAgICB0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KVxuICAgICAgICApLnN1YnNjcmliZSh0aGlzLmhpZGUuYmluZCh0aGlzKSk7XG5cbiAgICAgICAgLy8gaWYgdGhlIHRvb2x0aXAgc2hvdWxkIGJlIGluaXRpYWxseSB2aXNpYmxlIHRoZW4gb3BlbiBpdFxuICAgICAgICBpZiAodGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2UgbmVlZCB0byBzZW5kIGlucHV0IGNoYW5nZXMgdG8gdGhlIHRvb2x0aXAgY29tcG9uZW50XG4gICAgICogV2UgY2FuJ3QgdXNlIHNldHRlcnMgYXMgdGhleSBtYXkgdHJpZ2dlciBiZWZvcmUgdG9vbHRpcCBpbml0aWFsaXNlZCBhbmQgY2FuJ3QgcmVzZW5kIG9uY2UgaW5pdGlhbGlzZWRcbiAgICAgKiovXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xuXG4gICAgICAgIC8vIHdlIGNhbiBpZ25vcmUgdGhlIGZpcnN0IGNoYW5nZSBhcyBpdCdzIGhhbmRsZWQgaW4gbmdPbkluaXRcbiAgICAgICAgaWYgKGNoYW5nZXMuaXNPcGVuICYmICFjaGFuZ2VzLmlzT3Blbi5maXJzdENoYW5nZSAmJiBjaGFuZ2VzLmlzT3Blbi5jdXJyZW50VmFsdWUgIT09IHRoaXMuaXNWaXNpYmxlKSB7XG4gICAgICAgICAgICBjaGFuZ2VzLmlzT3Blbi5jdXJyZW50VmFsdWUgPyB0aGlzLnNob3coKSA6IHRoaXMuaGlkZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZGVzdHJveSB0aGUgb3ZlcmxheSByZWYgc28gYSBuZXcgY29ycmVjdGx5IHBvc2l0aW9uZWQgaW5zdGFuY2Ugd2lsbCBiZSBjcmVhdGVkIG5leHQgdGltZVxuICAgICAgICBpZiAoY2hhbmdlcy5wbGFjZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveU92ZXJsYXkoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9pbnN0YW5jZSAmJiBjaGFuZ2VzLnBsYWNlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5faW5zdGFuY2Uuc2V0UGxhY2VtZW50KGNoYW5nZXMucGxhY2VtZW50LmN1cnJlbnRWYWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5faW5zdGFuY2UgJiYgY2hhbmdlcy5jb250ZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZS5zZXRDb250ZW50KGNoYW5nZXMuY29udGVudC5jdXJyZW50VmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2luc3RhbmNlICYmIGNoYW5nZXMuY3VzdG9tQ2xhc3MpIHtcbiAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlLnNldENsYXNzKGNoYW5nZXMuY3VzdG9tQ2xhc3MuY3VycmVudFZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9pbnN0YW5jZSAmJiBjaGFuZ2VzLmNvbnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlLnNldENvbnRleHQoY2hhbmdlcy5jb250ZXh0LmN1cnJlbnRWYWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5faW5zdGFuY2UgJiYgY2hhbmdlcy5yb2xlKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZS5zZXRDb250ZXh0KGNoYW5nZXMucm9sZS5jdXJyZW50VmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEVuc3VyZSB3ZSBjbGVhbiB1cCBhZnRlciBvdXJzZWx2ZXMgKi9cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcblxuICAgICAgICAvLyBlbnN1cmUgd2UgY2xvc2UgdGhlIHRvb2x0aXAgd2hlbiB0aGUgaG9zdCBpcyBkZXN0cm95ZWRcbiAgICAgICAgaWYgKHRoaXMuX292ZXJsYXlSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlSZWYuZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5faW5zdGFuY2UgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZW1pdCB0aGlzIGV2ZW50IHRvIGF1dG9tYXRpY2FsbHkgdW5zdWJzY3JpYmUgZnJvbSBhbGwgc3Vic2NyaXB0aW9uc1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kubmV4dCgpO1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kuY29tcGxldGUoKTtcbiAgICB9XG5cbiAgICAvKiogTWFrZSB0aGUgdG9vbHRpcCBvcGVuICovXG4gICAgc2hvdygpOiB2b2lkIHtcblxuICAgICAgICAvLyBpZiB0aGUgdG9vbHRpcCBpcyBkaXNhYmxlZCB0aGVuIGRvIG5vdGhpbmdcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQgfHwgdGhpcy5pc1Zpc2libGUgfHwgdGhpcy5fc2hvd1RpbWVvdXRJZCB8fCAhdGhpcy5jb250ZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkZWxheSB0aGUgc2hvdyBieSB0aGUgZGVsYXkgYW1vdW50XG4gICAgICAgIHRoaXMuX3Nob3dUaW1lb3V0SWQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG5cbiAgICAgICAgICAgIC8vIGNyZWF0ZSB0aGUgdG9vbHRpcCBhbmQgZ2V0IHRoZSBvdmVybGF5IHJlZlxuICAgICAgICAgICAgY29uc3Qgb3ZlcmxheVJlZiA9IHRoaXMuY3JlYXRlT3ZlcmxheSgpO1xuXG4gICAgICAgICAgICAvLyBjcmVhdGUgdGhlIHBvcnRhbCB0byBjcmVhdGUgdGhlIHRvb2x0aXAgY29tcG9uZW50XG4gICAgICAgICAgICB0aGlzLl9wb3J0YWwgPSB0aGlzLmNyZWF0ZVBvcnRhbCgpO1xuICAgICAgICAgICAgdGhpcy5faW5zdGFuY2UgPSB0aGlzLmNyZWF0ZUluc3RhbmNlKG92ZXJsYXlSZWYpO1xuXG4gICAgICAgICAgICAvLyB3YXRjaCBmb3IgYW55IGNoYW5nZXMgdG8gdGhlIGNvbnRlbnRcbiAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlLnJlcG9zaXRpb24kLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZSh0aGlzLnJlcG9zaXRpb24uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgICAgIC8vIHN0b3JlIHRoZSB2aXNpYmxlIHN0YXRlXG4gICAgICAgICAgICB0aGlzLmlzVmlzaWJsZSA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIGVuc3VyZSB0aGUgb3ZlcmxheSBoYXMgdGhlIGNvcnJlY3QgaW5pdGlhbCBwb3NpdGlvblxuICAgICAgICAgICAgdGhpcy5yZXBvc2l0aW9uKCk7XG5cbiAgICAgICAgICAgIC8vIGVtaXQgdGhlIHNob3cgZXZlbnRzXG4gICAgICAgICAgICB0aGlzLnNob3duLmVtaXQoKTtcbiAgICAgICAgICAgIHRoaXMuaXNPcGVuQ2hhbmdlLm5leHQodHJ1ZSk7XG5cbiAgICAgICAgICAgIC8vIGNsZWFyIHRoZSBpbnRlcnZhbCBpZFxuICAgICAgICAgICAgdGhpcy5fc2hvd1RpbWVvdXRJZCA9IG51bGw7XG5cbiAgICAgICAgICAgIC8vIGVtaXQgdGhlIHNob3cgZXZlbnQgdG8gY2xvc2UgYW55IG90aGVyIHRvb2x0aXBzXG4gICAgICAgICAgICB0aGlzLl90b29sdGlwU2VydmljZS5zaG93biQubmV4dCh0aGlzLl9pbnN0YW5jZSk7XG5cbiAgICAgICAgICAgIC8vIGVuc3VyZSBjaGFuZ2UgZGV0ZWN0aW9uIGlzIHJ1blxuICAgICAgICAgICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3JSZWYuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICB9LCB0aGlzLmRlbGF5KTtcblxuICAgIH1cblxuICAgIC8qKiBJZiBhIHRvb2x0aXAgZXhpc3RzIGFuZCBpcyB2aXNpYmxlLCBoaWRlIGl0ICovXG4gICAgaGlkZSgpIHtcblxuICAgICAgICAvLyBpZiB3ZSBhcmUgd2FpdGluZyB0byBzaG93IGEgdG9vbHRpcCB0aGVuIGNhbmNlbCB0aGUgcGVuZGluZyB0aW1lb3V0XG4gICAgICAgIGlmICh0aGlzLl9zaG93VGltZW91dElkKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fc2hvd1RpbWVvdXRJZCk7XG4gICAgICAgICAgICB0aGlzLl9zaG93VGltZW91dElkID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9vdmVybGF5UmVmICYmIHRoaXMuX292ZXJsYXlSZWYuaGFzQXR0YWNoZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5fb3ZlcmxheVJlZi5kZXRhY2goKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0QXJpYURlc2NyaWJlZEJ5KG51bGwpO1xuICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IG51bGw7XG5cbiAgICAgICAgLy8gc3RvcmUgdGhlIHZpc2libGUgc3RhdGVcbiAgICAgICAgdGhpcy5pc1Zpc2libGUgPSBmYWxzZTtcblxuICAgICAgICAvLyBlbWl0IHRoZSBoaWRlIGV2ZW50c1xuICAgICAgICB0aGlzLmhpZGRlbi5lbWl0KCk7XG4gICAgICAgIHRoaXMuaXNPcGVuQ2hhbmdlLm5leHQoZmFsc2UpO1xuXG4gICAgICAgIC8vIGVuc3VyZSBjaGFuZ2UgZGV0ZWN0aW9uIGlzIHJ1blxuICAgICAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgfVxuXG4gICAgLyoqIFRvZ2dsZSB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgdG9vbHRpcCAqL1xuICAgIHRvZ2dsZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5pc1Zpc2libGUgPyB0aGlzLmhpZGUoKSA6IHRoaXMuc2hvdygpO1xuICAgIH1cblxuICAgIC8qKiBSZWNhbGN1bGF0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIHBvcG92ZXIgKi9cbiAgICByZXBvc2l0aW9uKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5pc1Zpc2libGUgJiYgdGhpcy5fb3ZlcmxheVJlZikge1xuICAgICAgICAgICAgdGhpcy5fb3ZlcmxheVJlZi51cGRhdGVQb3NpdGlvbigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIENyZWF0ZSBhbiBpbnN0YW5jZSBmcm9tIHRoZSBvdmVybGF5IHJlZiAtIGFsbG93cyBvdmVycmlkaW5nIGFuZCBhZGRpdGlvbmFsIGxvZ2ljIGhlcmUgKi9cbiAgICBwcm90ZWN0ZWQgY3JlYXRlSW5zdGFuY2Uob3ZlcmxheVJlZjogT3ZlcmxheVJlZik6IFRvb2x0aXBDb21wb25lbnQge1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IG92ZXJsYXlSZWYuYXR0YWNoKHRoaXMuX3BvcnRhbCkuaW5zdGFuY2UgYXMgVG9vbHRpcENvbXBvbmVudDtcblxuICAgICAgICAvLyBzdXBwbHkgdGhlIHRvb2x0aXAgd2l0aCB0aGUgY29ycmVjdCBwcm9wZXJ0aWVzXG4gICAgICAgIGluc3RhbmNlLnNldENvbnRlbnQodGhpcy5jb250ZW50KTtcbiAgICAgICAgaW5zdGFuY2Uuc2V0UGxhY2VtZW50KHRoaXMucGxhY2VtZW50KTtcbiAgICAgICAgaW5zdGFuY2Uuc2V0Q2xhc3ModGhpcy5jdXN0b21DbGFzcyk7XG4gICAgICAgIGluc3RhbmNlLnNldENvbnRleHQodGhpcy5jb250ZXh0KTtcbiAgICAgICAgaW5zdGFuY2Uuc2V0Um9sZSh0aGlzLnJvbGUpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgYXJpYS1kZXNjcmliZWRieSBhdHRyaWJ1dGVcbiAgICAgICAgdGhpcy5zZXRBcmlhRGVzY3JpYmVkQnkoaW5zdGFuY2UuaWQpO1xuXG4gICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9XG5cbiAgICAvKiogQ3JlYXRlIHRoZSBjb21wb25lbnQgcG9ydGFsIC0gYWxsb3dzIG92ZXJyaWRpbmcgdG8gYWxsb3cgb3RoZXIgcG9ydGFscyBlZy4gcG9wb3ZlcnMgKi9cbiAgICBwcm90ZWN0ZWQgY3JlYXRlUG9ydGFsKCk6IENvbXBvbmVudFBvcnRhbDxhbnk+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvcnRhbCB8fCBuZXcgQ29tcG9uZW50UG9ydGFsKFRvb2x0aXBDb21wb25lbnQsIHRoaXMuX3ZpZXdDb250YWluZXJSZWYpO1xuICAgIH1cblxuICAgIC8qKiBDcmVhdGUgdGhlIG92ZXJsYXkgYW5kIHNldCB1cCB0aGUgc2Nyb2xsIGhhbmRsaW5nIGJlaGF2aW9yICovXG4gICAgcHJpdmF0ZSBjcmVhdGVPdmVybGF5KCk6IE92ZXJsYXlSZWYge1xuXG4gICAgICAgIC8vIGlmIHRoZSB0b29sdGlwIGhhcyBhbHJlYWR5IGJlZW4gY3JlYXRlZCB0aGVuIGp1c3QgcmV0dXJuIHRoZSBleGlzdGluZyBpbnN0YW5jZVxuICAgICAgICBpZiAodGhpcy5fb3ZlcmxheVJlZikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX292ZXJsYXlSZWY7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25maWd1cmUgdGhlIHRvb2x0aXBcbiAgICAgICAgY29uc3Qgc3RyYXRlZ3kgPSB0aGlzLl9vdmVybGF5LnBvc2l0aW9uKClcbiAgICAgICAgICAgIC5jb25uZWN0ZWRUbyh0aGlzLl9lbGVtZW50UmVmLCB0aGlzLmdldE9yaWdpbigpLCB0aGlzLmdldE92ZXJsYXlQb3NpdGlvbigpKTtcblxuICAgICAgICAvLyBjb3JyZWN0bHkgaGFuZGxlIHNjcm9sbGluZ1xuICAgICAgICBjb25zdCBzY3JvbGxhYmxlQW5jZXN0b3JzID0gdGhpcy5fc2Nyb2xsRGlzcGF0Y2hlclxuICAgICAgICAgICAgLmdldEFuY2VzdG9yU2Nyb2xsQ29udGFpbmVycyh0aGlzLl9lbGVtZW50UmVmKTtcblxuICAgICAgICBzdHJhdGVneS53aXRoU2Nyb2xsYWJsZUNvbnRhaW5lcnMoc2Nyb2xsYWJsZUFuY2VzdG9ycyk7XG5cbiAgICAgICAgdGhpcy5fb3ZlcmxheVJlZiA9IHRoaXMuX292ZXJsYXkuY3JlYXRlKHtcbiAgICAgICAgICAgIHBvc2l0aW9uU3RyYXRlZ3k6IHN0cmF0ZWd5LFxuICAgICAgICAgICAgcGFuZWxDbGFzczogJ3V4LW92ZXJsYXktcGFuZScsXG4gICAgICAgICAgICBzY3JvbGxTdHJhdGVneTogdGhpcy5fb3ZlcmxheS5zY3JvbGxTdHJhdGVnaWVzLnJlcG9zaXRpb24oeyBzY3JvbGxUaHJvdHRsZTogMCB9KSxcbiAgICAgICAgICAgIGhhc0JhY2tkcm9wOiBmYWxzZVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fb3ZlcmxheVJlZjtcbiAgICB9XG5cbiAgICAvKiogUmVjcmVhdGUgdGhlIG92ZXJsYXkgcmVmIHVzaW5nIHRoZSB1cGRhdGVkIG9yaWdpbiBhbmQgb3ZlcmxheSBwb3NpdGlvbnMgKi9cbiAgICBwcml2YXRlIGRlc3Ryb3lPdmVybGF5KCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGRlc3Ryb3kgdGhlIGV4aXN0aW5nIG92ZXJsYXlcbiAgICAgICAgaWYgKHRoaXMuX292ZXJsYXlSZWYgJiYgdGhpcy5fb3ZlcmxheVJlZi5oYXNBdHRhY2hlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5UmVmLmRldGFjaCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX292ZXJsYXlSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlSZWYuZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5fb3ZlcmxheVJlZiA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmlzVmlzaWJsZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKiBHZXQgdGhlIG9yaWdpbiBwb3NpdGlvbiBiYXNlZCBvbiB0aGUgc3BlY2lmaWVkIHRvb2x0aXAgcGxhY2VtZW50ICovXG4gICAgcHJpdmF0ZSBnZXRPcmlnaW4oKTogT3JpZ2luQ29ubmVjdGlvblBvc2l0aW9uIHtcblxuICAgICAgICAvLyBlbnN1cmUgcGxhY2VtZW50IGlzIGRlZmluZWRcbiAgICAgICAgdGhpcy5wbGFjZW1lbnQgPSB0aGlzLnBsYWNlbWVudCB8fCAndG9wJztcblxuICAgICAgICBpZiAodGhpcy5wbGFjZW1lbnQgPT0gJ3RvcCcgfHwgdGhpcy5wbGFjZW1lbnQgPT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG9yaWdpblg6ICdjZW50ZXInLCBvcmlnaW5ZOiB0aGlzLnBsYWNlbWVudCB9O1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMucGxhY2VtZW50ID09ICdsZWZ0Jykge1xuICAgICAgICAgICAgcmV0dXJuIHsgb3JpZ2luWDogJ3N0YXJ0Jywgb3JpZ2luWTogJ2NlbnRlcicgfTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnBsYWNlbWVudCA9PSAncmlnaHQnKSB7XG4gICAgICAgICAgICByZXR1cm4geyBvcmlnaW5YOiAnZW5kJywgb3JpZ2luWTogJ2NlbnRlcicgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBDYWxjdWxhdGUgdGhlIG92ZXJsYXkgcG9zaXRpb24gYmFzZWQgb24gdGhlIHNwZWNpZmllZCB0b29sdGlwIHBsYWNlbWVudCAqL1xuICAgIHByaXZhdGUgZ2V0T3ZlcmxheVBvc2l0aW9uKCk6IE92ZXJsYXlDb25uZWN0aW9uUG9zaXRpb24ge1xuXG4gICAgICAgIC8vIGVuc3VyZSBwbGFjZW1lbnQgaXMgZGVmaW5lZFxuICAgICAgICB0aGlzLnBsYWNlbWVudCA9IHRoaXMucGxhY2VtZW50IHx8ICd0b3AnO1xuXG4gICAgICAgIGlmICh0aGlzLnBsYWNlbWVudCA9PSAndG9wJykge1xuICAgICAgICAgICAgcmV0dXJuIHsgb3ZlcmxheVg6ICdjZW50ZXInLCBvdmVybGF5WTogJ2JvdHRvbScgfTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnBsYWNlbWVudCA9PSAnYm90dG9tJykge1xuICAgICAgICAgICAgcmV0dXJuIHsgb3ZlcmxheVg6ICdjZW50ZXInLCBvdmVybGF5WTogJ3RvcCcgfTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnBsYWNlbWVudCA9PSAnbGVmdCcpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG92ZXJsYXlYOiAnZW5kJywgb3ZlcmxheVk6ICdjZW50ZXInIH07XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5wbGFjZW1lbnQgPT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgcmV0dXJuIHsgb3ZlcmxheVg6ICdzdGFydCcsIG92ZXJsYXlZOiAnY2VudGVyJyB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2ltcGxlIHV0aWxpdHkgbWV0aG9kIC0gYmVjYXVzZSBJRSBkb2Vzbid0IHN1cHBvcnQgYXJyYXkuaW5jbHVkZXNcbiAgICAgKiBBbmQgaXQgaXNuJ3QgaW5jbHVkZWQgaW4gdGhlIGNvcmUtanMvZXM2IHBvbHlmaWxscyB3aGljaCBhcmUgdGhlXG4gICAgICogb25seSBvbmVzIHJlcXVpcmVkIGJ5IEFuZ3VsYXIgYW5kIGd1YXJhbnRlZWQgdG8gYmUgdGhlcmVcbiAgICAgKiovXG4gICAgcHJvdGVjdGVkIGluY2x1ZGVzPFQ+KGFycmF5OiBBcnJheTxUPiwgdmFsdWU6IFQpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJyYXkpICYmICEhYXJyYXkuZmluZChpdGVtID0+IGl0ZW0gPT09IHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKiogSGFuZGxlIHRoZSBjbGljayBldmVudCAtIHNob3cgb3IgaGlkZSBhY2NvcmRpbmdseSAqL1xuICAgIHByb3RlY3RlZCBvbkNsaWNrKGV2ZW50OiBNb3VzZUV2ZW50KTogdm9pZCB7XG5cbiAgICAgICAgLy8gaWYgaXRzIG5vdCB2aXNpYmxlIGFuZCBjbGljayBpcyBhIHNob3cgdHJpZ2dlciBvcGVuIGl0XG4gICAgICAgIGlmICghdGhpcy5pc1Zpc2libGUgJiYgdGhpcy5pbmNsdWRlcyh0aGlzLnNob3dUcmlnZ2VycywgJ2NsaWNrJykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNob3coKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIGl0cyB2aXNpYmxlIGFuZCBjbGljayBpcyBhIGhpZGUgdHJpZ2dlciBjbG9zZSBpdFxuICAgICAgICBpZiAodGhpcy5pc1Zpc2libGUgJiYgdGhpcy5pbmNsdWRlcyh0aGlzLmhpZGVUcmlnZ2VycywgJ2NsaWNrJykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhpZGUoKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLyoqIEhhbmRsZSB0aGUgbW91c2UgZW50ZXIgZXZlbnQgLSBzaG93IG9yIGhpZGUgYWNjb3JkaW5nbHkgKi9cbiAgICBwcm90ZWN0ZWQgb25Nb3VzZUVudGVyKGV2ZW50OiBNb3VzZUV2ZW50KTogdm9pZCB7XG5cbiAgICAgICAgLy8gdGhpcyBpcyBhbiBzaG93IG9ubHkgdHJpZ2dlciAtIGlmIGFscmVhZHkgb3BlbiBvciBpdCBpc24ndCBhIHRyaWdnZXIgZG8gbm90aGluZ1xuICAgICAgICBpZiAodGhpcy5pc1Zpc2libGUgfHwgIXRoaXMuaW5jbHVkZXModGhpcy5zaG93VHJpZ2dlcnMsICdtb3VzZWVudGVyJykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG90aGVyd2lzZSBvcGVuIHRoZSB0b29sdGlwXG4gICAgICAgIHRoaXMuc2hvdygpO1xuICAgIH1cblxuICAgIC8qKiBIYW5kbGUgdGhlIG1vdXNlIGxlYXZlIGV2ZW50IC0gc2hvdyBvciBoaWRlIGFjY29yZGluZ2x5ICovXG4gICAgcHJvdGVjdGVkIG9uTW91c2VMZWF2ZShldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xuXG4gICAgICAgIC8vIHRoaXMgaXMgYW4gaGlkZSBvbmx5IHRyaWdnZXIgLSBpZiBub3Qgb3BlbiBvciBpdCBpc24ndCBhIHRyaWdnZXIgZG8gbm90aGluZ1xuICAgICAgICBpZiAoIXRoaXMuaXNWaXNpYmxlIHx8ICF0aGlzLmluY2x1ZGVzKHRoaXMuaGlkZVRyaWdnZXJzLCAnbW91c2VsZWF2ZScpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvdGhlcndpc2UgY2xvc2UgdGhlIHRvb2x0aXBcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgfVxuXG4gICAgLyoqIEhhbmRsZSB0aGUgZm9jdXMgZXZlbnQgLSBzaG93IG9yIGhpZGUgYWNjb3JkaW5nbHkgKi9cbiAgICBwcm90ZWN0ZWQgb25Gb2N1cyhldmVudDogRXZlbnQpOiB2b2lkIHtcblxuICAgICAgICAvLyB0aGlzIGlzIGFuIHNob3cgb25seSB0cmlnZ2VyIC0gaWYgYWxyZWFkeSBvcGVuIG9yIGl0IGlzbid0IGEgdHJpZ2dlciBkbyBub3RoaW5nXG4gICAgICAgIGlmICh0aGlzLmlzVmlzaWJsZSB8fCAhdGhpcy5pbmNsdWRlcyh0aGlzLnNob3dUcmlnZ2VycywgJ2ZvY3VzJykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG90aGVyd2lzZSBvcGVuIHRoZSB0b29sdGlwXG4gICAgICAgIHRoaXMuc2hvdygpO1xuICAgIH1cblxuICAgIC8qKiBIYW5kbGUgdGhlIGJsdXIgZXZlbnQgLSBzaG93IG9yIGhpZGUgYWNjb3JkaW5nbHkgKi9cbiAgICBwcm90ZWN0ZWQgb25CbHVyKGV2ZW50OiBFdmVudCk6IHZvaWQge1xuXG4gICAgICAgIC8vIHRoaXMgaXMgYW4gaGlkZSBvbmx5IHRyaWdnZXIgLSBpZiBub3Qgb3BlbiBvciBpdCBpc24ndCBhIHRyaWdnZXIgZG8gbm90aGluZ1xuICAgICAgICBpZiAoIXRoaXMuaXNWaXNpYmxlIHx8ICF0aGlzLmluY2x1ZGVzKHRoaXMuaGlkZVRyaWdnZXJzLCAnYmx1cicpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvdGhlcndpc2UgY2xvc2UgdGhlIHRvb2x0aXBcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgfVxuXG4gICAgLyoqIERldGVybWluZSBpZiB0aGUgdHJpZ2dlciBlbGVtZW50IGlzIGZvY3VzZWQgKi9cbiAgICBwcml2YXRlIGlzRm9jdXNlZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgICB9XG5cbiAgICAvKiogUHJvZ3JhbW1hdGljYWxseSB1cGRhdGUgdGhlIGFyaWEtZGVzY3JpYmVkYnkgcHJvcGVydHkgKi9cbiAgICBwcm90ZWN0ZWQgc2V0QXJpYURlc2NyaWJlZEJ5KGlkOiBzdHJpbmcgfCBudWxsKTogdm9pZCB7XG4gICAgICAgIGlmIChpZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIucmVtb3ZlQXR0cmlidXRlKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2FyaWEtZGVzY3JpYmVkYnknKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldEF0dHJpYnV0ZSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdhcmlhLWRlc2NyaWJlZGJ5JywgaWQpO1xuICAgICAgICB9XG4gICAgfVxuXG59XG5cbmV4cG9ydCB0eXBlIEFuY2hvclBsYWNlbWVudCA9ICd0b3AnIHwgJ3JpZ2h0JyB8ICdib3R0b20nIHwgJ2xlZnQnOyIsImltcG9ydCB7IE92ZXJsYXlNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jZGsvb3ZlcmxheSc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFRvb2x0aXBDb21wb25lbnQgfSBmcm9tICcuL3Rvb2x0aXAuY29tcG9uZW50JztcbmltcG9ydCB7IFRvb2x0aXBEaXJlY3RpdmUgfSBmcm9tICcuL3Rvb2x0aXAuZGlyZWN0aXZlJztcbmltcG9ydCB7IE9ic2VydmVyc01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9vYnNlcnZlcnMnO1xuaW1wb3J0IHsgVG9vbHRpcFNlcnZpY2UgfSBmcm9tICcuL3Rvb2x0aXAuc2VydmljZSc7XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtcbiAgICBDb21tb25Nb2R1bGUsXG4gICAgT3ZlcmxheU1vZHVsZSxcbiAgICBPYnNlcnZlcnNNb2R1bGVcbiAgXSxcbiAgZXhwb3J0czogW1Rvb2x0aXBEaXJlY3RpdmVdLFxuICBkZWNsYXJhdGlvbnM6IFtUb29sdGlwQ29tcG9uZW50LCBUb29sdGlwRGlyZWN0aXZlXSxcbiAgcHJvdmlkZXJzOiBbVG9vbHRpcFNlcnZpY2VdLFxuICBlbnRyeUNvbXBvbmVudHM6IFtUb29sdGlwQ29tcG9uZW50XVxufSlcbmV4cG9ydCBjbGFzcyBUb29sdGlwTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGb3Jtc01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IEFjY2Vzc2liaWxpdHlNb2R1bGUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL2FjY2Vzc2liaWxpdHkvaW5kZXgnO1xuaW1wb3J0IHsgTnVtYmVyUGlja2VyTW9kdWxlIH0gZnJvbSAnLi4vbnVtYmVyLXBpY2tlci9pbmRleCc7XG5pbXBvcnQgeyBUb29sdGlwTW9kdWxlIH0gZnJvbSAnLi4vdG9vbHRpcC9pbmRleCc7XG5pbXBvcnQgeyBDb2xvclBpY2tlckNvbXBvbmVudCB9IGZyb20gJy4vY29sb3ItcGlja2VyLmNvbXBvbmVudCc7XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW1xuICAgICAgICBBY2Nlc3NpYmlsaXR5TW9kdWxlLFxuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIEZvcm1zTW9kdWxlLFxuICAgICAgICBOdW1iZXJQaWNrZXJNb2R1bGUsXG4gICAgICAgIFRvb2x0aXBNb2R1bGUsXG4gICAgXSxcbiAgICBleHBvcnRzOiBbQ29sb3JQaWNrZXJDb21wb25lbnRdLFxuICAgIGRlY2xhcmF0aW9uczogW0NvbG9yUGlja2VyQ29tcG9uZW50XSxcbiAgICBwcm92aWRlcnM6IFtdLFxufSlcbmV4cG9ydCBjbGFzcyBDb2xvclBpY2tlck1vZHVsZSB7IH1cbiIsImltcG9ydCB7IERpcmVjdGl2ZSwgSW5wdXQsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3V4Q29sdW1uU29ydGluZ10nXG59KVxuZXhwb3J0IGNsYXNzIENvbHVtblNvcnRpbmdEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuXG4gICAgQElucHV0KCkgc2luZ2xlU29ydDogYm9vbGVhbjtcbiAgICBldmVudHMgPSBuZXcgU3ViamVjdDxDb2x1bW5Tb3J0aW5nT3JkZXJbXT4oKTtcbiAgICBvcmRlcjogQ29sdW1uU29ydGluZ09yZGVyW10gPSBbXTtcblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLmV2ZW50cy5jb21wbGV0ZSgpO1xuICAgIH1cblxuICAgIHRvZ2dsZUNvbHVtbihzb3J0aW5nOiBDb2x1bW5Tb3J0aW5nT3JkZXIpOiBDb2x1bW5Tb3J0aW5nT3JkZXJbXSB7XG5cbiAgICAgICAgLy8gYXBwbHkgc29ydGluZyBiYXNlZCBvbiB0aGUgc2luZ2xlIG9yIG11bHRpcGxlIHNvcnRcbiAgICAgICAgdGhpcy5vcmRlciA9IHRoaXMuc2luZ2xlU29ydCA/IHRoaXMudG9nZ2xlU2luZ2xlQ29sdW1uKHNvcnRpbmcpIDogdGhpcy50b2dnbGVNdWx0aXBsZUNvbHVtbihzb3J0aW5nKTtcblxuICAgICAgICAvLyBlbWl0IHRoZSBsYXRlc3Qgb3JkZXJcbiAgICAgICAgdGhpcy5ldmVudHMubmV4dCh0aGlzLm9yZGVyKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5vcmRlcjtcbiAgICB9XG5cbiAgICBwcml2YXRlIHRvZ2dsZVNpbmdsZUNvbHVtbihzb3J0aW5nOiBDb2x1bW5Tb3J0aW5nT3JkZXIpOiBDb2x1bW5Tb3J0aW5nT3JkZXJbXSB7XG4gICAgICAgIHJldHVybiBzb3J0aW5nLnN0YXRlID09PSBDb2x1bW5Tb3J0aW5nU3RhdGUuTm9Tb3J0ID8gW10gOiBbeyBrZXk6IHNvcnRpbmcua2V5LCBzdGF0ZTogc29ydGluZy5zdGF0ZSB9XTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHRvZ2dsZU11bHRpcGxlQ29sdW1uKHNvcnRpbmc6IENvbHVtblNvcnRpbmdPcmRlcik6IENvbHVtblNvcnRpbmdPcmRlcltdIHtcbiAgICAgICAgLy8gcmVvcmRlciBjb2x1bW5zIGhlcmVcbiAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5vcmRlci5maW5kSW5kZXgoY29sdW1uID0+IGNvbHVtbi5rZXkgPT09IHNvcnRpbmcua2V5KTtcblxuICAgICAgICAvLyBpZiB3YXNudCBwcmV2aW91c2x5IHNlbGVjdGVkIGFkZCB0byBsaXN0XG4gICAgICAgIGlmIChpZHggPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gWy4uLnRoaXMub3JkZXIsIHsga2V5OiBzb3J0aW5nLmtleSwgc3RhdGU6IHNvcnRpbmcuc3RhdGUgfV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB3ZSBhcmUgc29ydGluZyBpdCBjaGFuZ2UgdGhlIHNvcnRpbmcgb3JkZXJcbiAgICAgICAgaWYgKHNvcnRpbmcuc3RhdGUgPT09IENvbHVtblNvcnRpbmdTdGF0ZS5Bc2NlbmRpbmcgfHwgc29ydGluZy5zdGF0ZSA9PT0gQ29sdW1uU29ydGluZ1N0YXRlLkRlc2NlbmRpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBbLi4udGhpcy5vcmRlci5maWx0ZXIoX2NvbHVtbiA9PiBfY29sdW1uLmtleSAhPT0gc29ydGluZy5rZXkpLCB7IGtleTogc29ydGluZy5rZXksIHN0YXRlOiBzb3J0aW5nLnN0YXRlIH1dO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIHJlbW92ZSB0aGUgaXRlbVxuICAgICAgICByZXR1cm4gdGhpcy5vcmRlci5maWx0ZXIoX2NvbHVtbiA9PiBfY29sdW1uLmtleSAhPT0gc29ydGluZy5rZXkpO1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb2x1bW5Tb3J0aW5nT3JkZXIge1xuICAgIGtleTogc3RyaW5nO1xuICAgIHN0YXRlOiBDb2x1bW5Tb3J0aW5nU3RhdGU7XG59XG5cbmV4cG9ydCBlbnVtIENvbHVtblNvcnRpbmdTdGF0ZSB7XG4gICAgQXNjZW5kaW5nID0gJ2FzY2VuZGluZycsXG4gICAgRGVzY2VuZGluZyA9ICdkZXNjZW5kaW5nJyxcbiAgICBOb1NvcnQgPSAnbm9uZSdcbn0iLCJpbXBvcnQgeyBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE9uRGVzdHJveSwgT3V0cHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcbmltcG9ydCB7IENvbHVtblNvcnRpbmdEaXJlY3RpdmUsIENvbHVtblNvcnRpbmdPcmRlciwgQ29sdW1uU29ydGluZ1N0YXRlIH0gZnJvbSAnLi9jb2x1bW4tc29ydGluZy5kaXJlY3RpdmUnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LWNvbHVtbi1zb3J0aW5nJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vY29sdW1uLXNvcnRpbmcuY29tcG9uZW50Lmh0bWwnLFxuICAgIGV4cG9ydEFzOiAndXgtY29sdW1uLXNvcnRpbmcnXG59KVxuZXhwb3J0IGNsYXNzIENvbHVtblNvcnRpbmdDb21wb25lbnQgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuXG4gICAgQElucHV0KCkgc3RhdGU6IENvbHVtblNvcnRpbmdTdGF0ZTtcbiAgICBASW5wdXQoKSBrZXk6IHN0cmluZztcbiAgICBAT3V0cHV0KCkgc3RhdGVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPENvbHVtblNvcnRpbmdTdGF0ZT4oKTtcblxuICAgIG9yZGVyOiBudW1iZXI7XG4gICAgY29sdW1uU29ydGluZ1N0YXRlID0gQ29sdW1uU29ydGluZ1N0YXRlO1xuXG4gICAgcHJpdmF0ZSBfb25EZXN0cm95ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX2NvbHVtblNvcnRlcjogQ29sdW1uU29ydGluZ0RpcmVjdGl2ZSkge1xuICAgICAgICB0aGlzLl9jb2x1bW5Tb3J0ZXIuZXZlbnRzLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZShldmVudCA9PiB7XG5cbiAgICAgICAgICAgIC8vIGlmIHdlIGFyZSBzb3J0aW5nIHRoaXMgY29sdW1uIHRoZW4gZmluZCB0aGUgbWF0Y2hpbmcgZGF0YVxuICAgICAgICAgICAgY29uc3QgY29sdW1uSWR4ID0gZXZlbnQuZmluZEluZGV4KF9jb2x1bW4gPT4gX2NvbHVtbi5rZXkgPT09IHRoaXMua2V5KTtcblxuICAgICAgICAgICAgLy8gaWYgd2UgYXJlIG5vdCBzb3J0aW5nIHRoaXMgY29sdW1uIHRoZW4gbWFyayBpdCBhcyBOb1NvcnRcbiAgICAgICAgICAgIGlmIChjb2x1bW5JZHggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IENvbHVtblNvcnRpbmdTdGF0ZS5Ob1NvcnQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG9ubHkgc3RvcmUgdGhlIG51bWJlciBpZiB3ZSBoYXZlIDIgb3IgbW9yZSBjb2x1bW5zIGJlaW5nIHNvcnRlZFxuICAgICAgICAgICAgdGhpcy5vcmRlciA9IGV2ZW50Lmxlbmd0aCA8IDIgfHwgY29sdW1uSWR4ID09PSAtMSA/IG51bGwgOiBjb2x1bW5JZHggKyAxO1xuXG4gICAgICAgICAgICAvLyBFbWl0IHRoZSBsYXRlc3QgY2hhbmdlXG4gICAgICAgICAgICB0aGlzLnN0YXRlQ2hhbmdlLmVtaXQodGhpcy5zdGF0ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kubmV4dCgpO1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kuY29tcGxldGUoKTtcbiAgICB9XG5cbiAgICBjaGFuZ2VTdGF0ZSgpOiBDb2x1bW5Tb3J0aW5nT3JkZXJbXSB7XG5cbiAgICAgICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG5cbiAgICAgICAgICAgIGNhc2UgQ29sdW1uU29ydGluZ1N0YXRlLkFzY2VuZGluZzpcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gQ29sdW1uU29ydGluZ1N0YXRlLkRlc2NlbmRpbmc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgQ29sdW1uU29ydGluZ1N0YXRlLkRlc2NlbmRpbmc6XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IENvbHVtblNvcnRpbmdTdGF0ZS5Ob1NvcnQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IENvbHVtblNvcnRpbmdTdGF0ZS5Bc2NlbmRpbmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpbmZvcm0gcGFyZW50XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2x1bW5Tb3J0ZXIudG9nZ2xlQ29sdW1uKHsga2V5OiB0aGlzLmtleSwgc3RhdGU6IHRoaXMuc3RhdGUgfSk7XG4gICAgfVxufSIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IENvbHVtblNvcnRpbmdDb21wb25lbnQgfSBmcm9tICcuL2NvbHVtbi1zb3J0aW5nLmNvbXBvbmVudCc7XG5cbmltcG9ydCB7IENvbHVtblNvcnRpbmdEaXJlY3RpdmUgfSBmcm9tICcuL2NvbHVtbi1zb3J0aW5nLmRpcmVjdGl2ZSc7XG5cbkBOZ01vZHVsZSh7XG4gICAgZXhwb3J0czogW0NvbHVtblNvcnRpbmdDb21wb25lbnQsIENvbHVtblNvcnRpbmdEaXJlY3RpdmVdLFxuICAgIGRlY2xhcmF0aW9uczogW0NvbHVtblNvcnRpbmdDb21wb25lbnQsIENvbHVtblNvcnRpbmdEaXJlY3RpdmVdXG59KVxuZXhwb3J0IGNsYXNzIENvbHVtblNvcnRpbmdNb2R1bGUgeyB9IiwiaW1wb3J0IHsgZGlzdGluY3RVbnRpbENoYW5nZWQsIGZpbHRlciwgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XG5pbXBvcnQgeyBDb25kdWl0Wm9uZSB9IGZyb20gJy4vY29uZHVpdC16b25lLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ29uZHVpdEV2ZW50IH0gZnJvbSAnLi9pbnRlcmZhY2VzL2NvbmR1aXQtZXZlbnQnO1xuaW1wb3J0IHsgQ29uZHVpdE1ldGFkYXRhIH0gZnJvbSAnLi9pbnRlcmZhY2VzL2NvbmR1aXQtbWV0YWRhdGEnO1xuXG5leHBvcnQgY2xhc3MgQ29uZHVpdFN1YmplY3Qge1xuXG4gICAgcHJpdmF0ZSBfc3ViamVjdDogU3ViamVjdDxhbnk+O1xuICAgIHByaXZhdGUgX29uRGVzdHJveSA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgY29uZHVpdDogQ29uZHVpdE1ldGFkYXRhLCBwcml2YXRlIF96b25lOiBDb25kdWl0Wm9uZSwgcHVibGljIHpvbmVJZDogc3RyaW5nKSB7XG5cbiAgICAgICAgLy8gc3RvcmUgdGhlIHRhcmdldCBzdWJqZWN0IG9iamVjdFxuICAgICAgICB0aGlzLl9zdWJqZWN0ID0gY29uZHVpdC5zdWJqZWN0O1xuXG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSBhbnkgY29uZHVpdHMgdGhhdCBoYXZlIHN1cHBsaWVkIGFuIGluaXRpYWwgdmFsdWVcbiAgICAgICAgdGhpcy5nZXRJbml0aWFsVmFsdWUoKTtcblxuICAgICAgICAvLyBzdWJzY3JpYmUgdG8gY2hhbmdlcyB0byB0aGUgc291cmNlIHN1YmplY3RcbiAgICAgICAgdGhpcy5fc3ViamVjdC5waXBlKGRpc3RpbmN0VW50aWxDaGFuZ2VkKGNvbmR1aXQuY2hhbmdlRGV0ZWN0aW9uKSwgdGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKHRoaXMub25PdXRwdXQuYmluZCh0aGlzKSk7XG5cbiAgICAgICAgLy8gc3Vic2NyaWJlIHRvIHRoZSB6b25lIGV2ZW50cyBhbmQgcm9vdCB6b25lIGV2ZW50c1xuICAgICAgICBfem9uZS5nZXRFdmVudHMoKS5waXBlKGZpbHRlcihldmVudCA9PiBldmVudC5jb25kdWl0LmlkID09PSBjb25kdWl0LmlkKSwgdGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZSh0aGlzLm9uSW5wdXQuYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgLyoqIENoZWNrIGFsbCBhbGxvdyBpbnB1dHMgdG8gc2VlIGlmIHRoZXJlIGlzIGEgdmFsdWUgd2Ugc2hvdWxkIGluaXRpYWxseSBzZXQgdGhlIGNvbmR1aXQgdG8gKi9cbiAgICBnZXRJbml0aWFsVmFsdWUoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gaWYgd2UgZG8gbm90IGFjY2VwdCBpbnB1dHMgdGhlbiBkbyBub3RoaW5nXG4gICAgICAgIGlmICh0aGlzLmNvbmR1aXQuYWNjZXB0c0lucHV0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmV0dXJuIGFsbCBzdWJqZWN0cyB0aGF0IGFyZSAxKSBOb3QgaXRzZWxmIDIpIEluIGEgem9uZSB0aGF0IGlzIGxpc3RlZCBpbiBhY2NlcHRzSW5wdXQgMykgSGF2ZSBhIGN1cnJlbnRWYWx1ZSBzZXRcbiAgICAgICAgY29uc3Qgc3ViamVjdHMgPSB0aGlzLl96b25lLmdldFN1YmplY3RzKCkuZmlsdGVyKHN1YmplY3QgPT4ge1xuXG4gICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGl0c2VsZiBvciBpZiBpdCBoYXMgbm90IHZhbHVlIHRvIGdpdmUgdXMgdGhlbiBkbyBub3RoaW5nXG4gICAgICAgICAgICBpZiAoc3ViamVjdCA9PT0gdGhpcyB8fCBzdWJqZWN0LmNvbmR1aXQuaWQgIT09IHRoaXMuY29uZHVpdC5pZCB8fCAhc3ViamVjdC5jb25kdWl0Lmhhc093blByb3BlcnR5KCdjdXJyZW50VmFsdWUnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgYWNjZXB0c0lucHV0IGlzIHRydWUgdGhlbiB3ZSByZXR1cm4gZXZlcnkgdGltZVxuICAgICAgICAgICAgaWYgKHRoaXMuY29uZHVpdC5hY2NlcHRzSW5wdXQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5jb25kdWl0LmFjY2VwdHNJbnB1dCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb25kdWl0LmFjY2VwdHNJbnB1dC5pbmRleE9mKHN1YmplY3Quem9uZUlkKSAhPT0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGlmIHRoZXJlIGFyZSBubyBtYXRjaGVzIHRoZW4gZG8gbm90aGluZ1xuICAgICAgICBpZiAoc3ViamVjdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvdGhlcndpc2Ugc29ydCBieSB0aGUgbGFzdCBtb2RpZmllZCBmaWVsZFxuICAgICAgICBzdWJqZWN0cy5zb3J0KChzdWJqZWN0T25lLCBzdWJqZWN0VHdvKSA9PiBzdWJqZWN0T25lLmNvbmR1aXQubGFzdE1vZGlmaWVkLmdldFRpbWUoKSA8IHN1YmplY3RUd28uY29uZHVpdC5sYXN0TW9kaWZpZWQuZ2V0VGltZSgpID8gMSA6IC0xKTtcblxuICAgICAgICAvLyBnZXQgdGhlIG1vc3QgcmVjZW50IHZhbHVlXG4gICAgICAgIHRoaXMuX3N1YmplY3QubmV4dChzdWJqZWN0c1swXS5jb25kdWl0LmN1cnJlbnRWYWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqIFRoaXMgd2lsbCBiZSB0cmlnZ2VyZWQgd2hlbiBhIGNvbmR1aXRzIHZhbHVlIGhhcyBjaGFuZ2VkICovXG4gICAgb25JbnB1dChldmVudDogQ29uZHVpdEV2ZW50KTogdm9pZCB7XG4gICAgICAgIC8vIGlmIHdlIGRvbnQgYWNjZXB0IGlucHV0IG9yIHdlIGVtaXR0ZWQgdGhpcyB2YWx1ZSB0aGVuIGRvIG5vdGhpbmdcbiAgICAgICAgaWYgKHRoaXMuY29uZHVpdC5hY2NlcHRzSW5wdXQgPT09IGZhbHNlIHx8IGV2ZW50LmNvbmR1aXQgPT09IHRoaXMuY29uZHVpdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlIGNvbmR1aXQgcHJvZHVjZXMgb3V0cHV0IC0gaWYgbm90IHdlIG9ubHkgZG8gc29tZXRoaW5nIGlmIHdlIGFyZSBpbiB0aGUgc2FtZSB6b25lXG4gICAgICAgIGlmIChldmVudC5jb25kdWl0LnByb2R1Y2VzT3V0cHV0ID09PSBmYWxzZSAmJiBldmVudC56b25lSWQgIT09IHRoaXMuem9uZUlkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBpZiB3ZSBvbmx5IGFjY2VwdCBpbnB1dHMgZnJvbSBzcGVjaWZpYyB6b25lc1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLmNvbmR1aXQuYWNjZXB0c0lucHV0KSkge1xuICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIGV2ZW50IGNhbWUgZnJvbSBhbiBhY2NlcHRhYmxlIHpvbmVcbiAgICAgICAgICAgIGlmICghdGhpcy5jb25kdWl0LmFjY2VwdHNJbnB1dC5maW5kKHpvbmUgPT4gem9uZSA9PT0gZXZlbnQuem9uZUlkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHJlcXVpcmVkIHRyYW5zZm9ybSB0aGUgdmFsdWVcbiAgICAgICAgY29uc3Qgb3V0cHV0VmFsdWUgPSB0aGlzLmNvbmR1aXQubWFwID8gdGhpcy5jb25kdWl0Lm1hcChldmVudC52YWx1ZSkgOiBldmVudC52YWx1ZTtcblxuICAgICAgICAvLyB1cGRhdGUgdGhlIHN1YmplY3RcbiAgICAgICAgdGhpcy5fc3ViamVjdC5uZXh0KG91dHB1dFZhbHVlKTtcbiAgICB9XG5cbiAgICAvKiogVGhpcyB3aWxsIGJlIGZpcmVkIHdoZW4gdGhpcyBjb25kdWl0IGVtaXRzIGEgbmV3IHZhbHVlICovXG4gICAgb25PdXRwdXQodmFsdWU6IGFueSk6IHZvaWQge1xuXG4gICAgICAgIC8vIHN0b3JlIHRoZSBtb3N0IHJlY2VudCB2YWx1ZSBhbmQgd2hlbiBpdCB3YXMgbW9kaWZpZWQgLSBjYW4gYmUgdXNlZCBmb3IgYW55IG5ldyBjb25kdWl0cyB0byBsb29rdXAgYSB2YWx1ZVxuICAgICAgICB0aGlzLmNvbmR1aXQuY3VycmVudFZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuY29uZHVpdC5sYXN0TW9kaWZpZWQgPSBuZXcgRGF0ZSgpO1xuXG4gICAgICAgIC8vIGNoZWNrIGlmIHRoaXMgc2hvdWxkIHByb2R1Y2Ugb3V0cHV0XG4gICAgICAgIGlmICh0aGlzLmNvbmR1aXQucHJvZHVjZXNPdXRwdXQpIHtcbiAgICAgICAgICAgIHRoaXMuX3pvbmUuZW1pdCh7IGNvbmR1aXQ6IHRoaXMuY29uZHVpdCwgem9uZUlkOiB0aGlzLnpvbmVJZCwgdmFsdWUgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogVW5zdWJzY3JpYmUgb25jZSB0aGlzIHN1YmplY3QgaXMgZGVzdHJveWVkICovXG4gICAgZGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fb25EZXN0cm95Lm5leHQoKTtcbiAgICAgICAgdGhpcy5fb25EZXN0cm95LmNvbXBsZXRlKCk7XG4gICAgfVxufVxuIiwiLyoqIFRoaXMgdXRpbGl0eSBpcyB0byBlbnN1cmUgYSBhbGwgZnVuY3Rpb25zIHdpdGggdGhlIHNwZWNpZmllZCBuYW1lIGFyZSBjYWxsZWQgaW4gYWxsIHN1cGVyIGNsYXNzZXMgKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZva2VTdXBlckZ1bmN0aW9uKHRhcmdldDogb2JqZWN0LCBmdW5jdGlvbk5hbWU6IHN0cmluZyk6IHZvaWQge1xuICAgIC8vIGdldCBhbGwgaW5zdGFuY2VzIG9mIHRoZSBmdW5jdGlvblxuICAgIGNvbnN0IGZ1bmN0aW9uTGlzdDogRnVuY3Rpb25bXSA9IFtdO1xuXG4gICAgLy8gc3RvcmUgdGhlIGN1cnJlbnQgcHJvdG90eXBlIHdlIGFyZSBjaGVja2luZ1xuICAgIGxldCBwcm90b3R5cGU6IGFueSA9IHRhcmdldDtcblxuICAgIC8vIGxvb2sgdGhyb3VnaCBldmVyeSBiYXNlIGNsYXNzIGFuZCBjaGVjayBpdFxuICAgIGRvIHtcbiAgICAgICAgaWYgKHByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShmdW5jdGlvbk5hbWUpKSB7XG4gICAgICAgICAgICBmdW5jdGlvbkxpc3QucHVzaChwcm90b3R5cGVbZnVuY3Rpb25OYW1lXSk7XG4gICAgICAgIH1cblxuICAgICAgICBwcm90b3R5cGUgPSBwcm90b3R5cGUuX19wcm90b19fO1xuICAgIH0gd2hpbGUgKHByb3RvdHlwZS5fX3Byb3RvX18pO1xuXG4gICAgLy8gYXVnbWVudCB0aGUgdG9wIGxldmVsIGZ1bmN0aW9uIHRvIGNhbGwgYWxsIHRoZSBmdW5jdGlvbnNcbiAgICB0YXJnZXRbZnVuY3Rpb25OYW1lXSA9IGZ1bmN0aW9uICguLi5hcmdzOiBhbnlbXSkge1xuICAgICAgICBmdW5jdGlvbkxpc3QuZm9yRWFjaChmdW5jID0+IGZ1bmMuY2FsbCh0YXJnZXQsIC4uLmFyZ3MpKTtcbiAgICB9O1xufVxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSwgT25EZXN0cm95IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcbmltcG9ydCB7IENvbmR1aXRTdWJqZWN0IH0gZnJvbSAnLi9jb25kdWl0LXN1YmplY3QnO1xuaW1wb3J0IHsgQ29uZHVpdEV2ZW50IH0gZnJvbSAnLi9pbnRlcmZhY2VzL2NvbmR1aXQtZXZlbnQnO1xuaW1wb3J0IHsgQ29uZHVpdE1ldGFkYXRhIH0gZnJvbSAnLi9pbnRlcmZhY2VzL2NvbmR1aXQtbWV0YWRhdGEnO1xuaW1wb3J0IHsgQ29uZHVpdFByb3BlcnRpZXMgfSBmcm9tICcuL2ludGVyZmFjZXMvY29uZHVpdC1wcm9wZXJ0aWVzJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIENvbmR1aXRab25lIGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICAgIC8qKiBDcmVhdGUgYSBnbG9iYWwgc3ViamVjdCBzdG9yZSAqL1xuICAgIHN0YXRpYyBzdWJqZWN0czogQ29uZHVpdFN1YmplY3RbXSA9IFtdO1xuXG4gICAgLyoqIEV4cG9zZSBhbiBldmVudCBzdHJlYW0gb2YgbmV3IHZhbHVlcyAqL1xuICAgIHN0YXRpYyBldmVudHMgPSBuZXcgU3ViamVjdDxDb25kdWl0RXZlbnQ+KCk7XG5cbiAgICAvKiogU3RvcmUgdGhlIHpvbmUgbmFtZSAqL1xuICAgIHByaXZhdGUgX3pvbmVJZDogc3RyaW5nO1xuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIC8vIGZpbmQgYWxsIGNvbmR1aXQgc3ViamVjdHMgdGhhdCBhcmUgcGFydCBvZiB0aGlzIHpvbmVcbiAgICAgICAgQ29uZHVpdFpvbmUuc3ViamVjdHMuZmlsdGVyKF9zdWJqZWN0ID0+IF9zdWJqZWN0LnpvbmVJZCA9PT0gdGhpcy5fem9uZUlkKVxuICAgICAgICAgICAgLmZvckVhY2goX3N1YmplY3QgPT4gdGhpcy51bnJlZ2lzdGVyQ29uZHVpdChfc3ViamVjdC5jb25kdWl0KSk7XG4gICAgfVxuXG4gICAgLyoqIFN0b3JlIHJlZmVyZW5jZSB0byB0aGUgcmVwb3NpdG9yeSBhbmQgYmVnaW4gd2F0Y2hpbmcgZm9yIGFuZCBlbWl0dGluZyBjaGFuZ2VzICovXG4gICAgcmVnaXN0ZXJDb25kdWl0KGNvbmR1aXQ6IENvbmR1aXRNZXRhZGF0YSk6IHZvaWQge1xuICAgICAgICBDb25kdWl0Wm9uZS5zdWJqZWN0cy5wdXNoKG5ldyBDb25kdWl0U3ViamVjdChjb25kdWl0LCB0aGlzLCB0aGlzLl96b25lSWQpKTtcbiAgICB9XG5cbiAgICAvKiogRGVzdHJveSBhIGNvbmR1aXQgKi9cbiAgICB1bnJlZ2lzdGVyQ29uZHVpdChjb25kdWl0OiBDb25kdWl0TWV0YWRhdGEpOiB2b2lkIHtcbiAgICAgICAgY29uc3Qgc3ViamVjdCA9IHRoaXMuZ2V0Q29uZHVpdFN1YmplY3QoY29uZHVpdC5zdWJqZWN0KTtcblxuICAgICAgICBpZiAoc3ViamVjdCkge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBzdWJqZWN0IGZyb20gdGhlIGludGVybmFsIGxpc3Qgb2YgY29uZHVpdCBzdWJqZWN0c1xuICAgICAgICAgICAgQ29uZHVpdFpvbmUuc3ViamVjdHMgPSBDb25kdWl0Wm9uZS5zdWJqZWN0cy5maWx0ZXIoX3N1YmplY3QgPT4gX3N1YmplY3QgIT09IHN1YmplY3QpO1xuXG4gICAgICAgICAgICAvLyBwZXJmb3JtIGFsbCB1bnN1YnNjcmlwdGlvbnNcbiAgICAgICAgICAgIHN1YmplY3QuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIFByb3ZpZGUgdGhlIHpvbmUgd2l0aCBhbiBJRCAqL1xuICAgIHNldFpvbmVJZCh6b25lSWQ6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICB0aGlzLl96b25lSWQgPSB6b25lSWQ7XG4gICAgfVxuXG4gICAgLyoqIEVtaXQgYSB2YWx1ZSB0byBhbGwgem9uZXMgZm9yIGNoZWNraW5nICovXG4gICAgZW1pdChldmVudDogQ29uZHVpdEV2ZW50KTogdm9pZCB7XG4gICAgICAgIENvbmR1aXRab25lLmV2ZW50cy5uZXh0KGV2ZW50KTtcbiAgICB9XG5cbiAgICAvKiogUmV0cmlldmUgYSBjb25kdWl0IHN1YnNqZWN0IG9iamVjdCBmcm9tIHRoZSByeGpzIHN1YmplY3QgKi9cbiAgICBnZXRDb25kdWl0U3ViamVjdChzdWJqZWN0OiBTdWJqZWN0PGFueT4pOiBDb25kdWl0U3ViamVjdCB8IG51bGwge1xuICAgICAgICByZXR1cm4gQ29uZHVpdFpvbmUuc3ViamVjdHMuZmluZChfc3ViamVjdCA9PiBfc3ViamVjdC5jb25kdWl0LnN1YmplY3QgPT09IHN1YmplY3QpO1xuICAgIH1cblxuICAgIC8qKiBHZXQgYWxsIHN1YmplY3RzIGZyb20gYWxsIHpvbmVzICovXG4gICAgZ2V0U3ViamVjdHMoKTogQ29uZHVpdFN1YmplY3RbXSB7XG4gICAgICAgIHJldHVybiBDb25kdWl0Wm9uZS5zdWJqZWN0cztcbiAgICB9XG5cbiAgICAvKiogQWx0ZXIgdGhlIHByb3BlcnRpZXMgb2YgYSBjb25kdWl0IGR5bmFtaWNhbGx5ICovXG4gICAgc2V0Q29uZHVpdFByb3BlcnRpZXMoc3ViamVjdDogU3ViamVjdDxhbnk+LCBwcm9wZXJ0aWVzOiBQYXJ0aWFsPENvbmR1aXRQcm9wZXJ0aWVzPik6IHZvaWQge1xuXG4gICAgICAgIC8vIGZpbmQgdGhlIGNvbmR1aXQgd2l0aCB0aGUgbWF0Y2hpbmcgc3ViamVjdFxuICAgICAgICBjb25zdCBjb25kdWl0U3ViamVjdCA9IHRoaXMuZ2V0U3ViamVjdHMoKS5maW5kKF9jb25kdWl0ID0+IF9jb25kdWl0LmNvbmR1aXQuc3ViamVjdCA9PT0gc3ViamVjdCk7XG5cbiAgICAgICAgLy8gaWYgYSBtYXRjaCB3YXMgZm91bmQgdXBkYXRlIHRoZSBwcm9wZXJ0aWVzXG4gICAgICAgIGlmIChjb25kdWl0U3ViamVjdCkge1xuXG4gICAgICAgICAgICAvLyB1cGRhdGUgZWFjaCBzcGVjaWZpZWQgcHJvcGVydHlcbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgY29uZHVpdFN1YmplY3QuY29uZHVpdFtwcm9wXSA9IHByb3BlcnRpZXNbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogUHJvZ3JhbW1hdGljYWxseSBjcmVhdGUgYSBjb25kdWl0IGF0IHJ1bnRpbWUgKi9cbiAgICBjcmVhdGVDb25kdWl0KHN1YmplY3Q6IFN1YmplY3Q8YW55PiwgcHJvcGVydGllczogQ29uZHVpdFByb3BlcnRpZXMpOiB2b2lkIHtcblxuICAgICAgICAvLyByZWdpc3RlciB0aGUgY29uZHVpdCB3aXRoIHRoZSB6b25lXG4gICAgICAgIHRoaXMucmVnaXN0ZXJDb25kdWl0KHsgLi4ucHJvcGVydGllcywgc3ViamVjdCB9KTtcbiAgICB9XG5cbiAgICAvKiogUmVnaXN0ZXIgYWxsIGNvbmR1aXRzIGluIGEgY29tcG9uZW50ICovXG4gICAgcmVnaXN0ZXJDb25kdWl0cyhjb21wb25lbnQ6IGFueSk6IHZvaWQge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjb21wb25lbnQuX2NvbmR1aXRzKSkge1xuICAgICAgICAgICAgY29tcG9uZW50Ll9jb25kdWl0cy5mb3JFYWNoKChjb25kdWl0OiBDb25kdWl0TWV0YWRhdGEpID0+IHRoaXMucmVnaXN0ZXJDb25kdWl0KHsgLi4uY29uZHVpdCwgc3ViamVjdDogY29tcG9uZW50W2NvbmR1aXQucHJvcGVydHlLZXldIH0pKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBSZWdpc3RlciBhbGwgY29uZHVpdHMgaW4gYSBjb21wb25lbnQgKi9cbiAgICB1bnJlZ2lzdGVyQ29uZHVpdHMoY29tcG9uZW50OiBhbnkpOiB2b2lkIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29tcG9uZW50Ll9jb25kdWl0cykpIHtcbiAgICAgICAgICAgIGNvbXBvbmVudC5fY29uZHVpdHMuZm9yRWFjaCgoY29uZHVpdDogQ29uZHVpdE1ldGFkYXRhKSA9PiB0aGlzLnVucmVnaXN0ZXJDb25kdWl0KGNvbmR1aXQpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBSZXR1cm4gdGhlIGdsb2JhbCBldmVudCBzdHJlYW0gKi9cbiAgICBnZXRFdmVudHMoKTogU3ViamVjdDxDb25kdWl0RXZlbnQ+IHtcbiAgICAgICAgcmV0dXJuIENvbmR1aXRab25lLmV2ZW50cztcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBPbkRlc3Ryb3ksIE9uSW5pdCwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzL1N1YmplY3QnO1xuaW1wb3J0IHsgaW52b2tlU3VwZXJGdW5jdGlvbiB9IGZyb20gJy4vY29uZHVpdC11dGlscyc7XG5pbXBvcnQgeyBDb25kdWl0Wm9uZSB9IGZyb20gJy4vY29uZHVpdC16b25lLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ29uZHVpdFByb3BlcnRpZXMgfSBmcm9tICcuL2ludGVyZmFjZXMvY29uZHVpdC1wcm9wZXJ0aWVzJztcblxuZXhwb3J0IGNsYXNzIENvbmR1aXRDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG5cbiAgICBjb25zdHJ1Y3RvcihAT3B0aW9uYWwoKSBwcm90ZWN0ZWQgX3pvbmU6IENvbmR1aXRab25lKSB7XG4gICAgICAgIC8vIHdlIHdhbnQgdG8gZW5zdXJlIHRoZXNlIGZ1bmN0aW9ucyBnZXQgY2FsbGVkIGV2ZW4gaWYgYSBjbGFzcyBvdmVycmlkZXMgdGhlbVxuICAgICAgICBpbnZva2VTdXBlckZ1bmN0aW9uKHRoaXMsICduZ09uSW5pdCcpO1xuICAgICAgICBpbnZva2VTdXBlckZ1bmN0aW9uKHRoaXMsICduZ09uRGVzdHJveScpO1xuICAgIH1cblxuICAgIC8qKiBXZSBuZWVkIHRvIHJlZ2lzdGVyIHRoZSBjb25kdWl0cyB3aXRoIHRoZSB6b25lIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBpbml0aWFsaXNlZCAqL1xuICAgIG5nT25Jbml0KCk6IHZvaWQge1xuICAgICAgICAvLyByZWdpc3RlciB0aGUgY29uZHVpdCBpbiB0aGUgem9uZSBhbmQgZW5zdXJlIGl0IGdldHMgdGhlIGNvcnJlY3QgaW5zdGFuY2Ugb2YgdGhlIHRhcmdldFxuICAgICAgICB0aGlzLl96b25lLnJlZ2lzdGVyQ29uZHVpdHModGhpcyk7XG4gICAgfVxuXG4gICAgLyoqIFdlIG5lZWQgdG8gdW5yZWdpc3RlciB0aGUgY29uZHVpdHMgd2hlbiB0aGUgY29tcG9uZW50IGlzIGRlc3Ryb3llZCAqL1xuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl96b25lLnVucmVnaXN0ZXJDb25kdWl0cyh0aGlzKTtcbiAgICB9XG5cbiAgICAvKiogQWx0ZXIgdGhlIHByb3BlcnRpZXMgb2YgYSBjb25kdWl0IGR5bmFtaWNhbGx5ICovXG4gICAgc2V0Q29uZHVpdFByb3BlcnRpZXMoc3ViamVjdDogU3ViamVjdDxhbnk+LCBwcm9wZXJ0aWVzOiBQYXJ0aWFsPENvbmR1aXRQcm9wZXJ0aWVzPik6IHZvaWQge1xuICAgICAgICB0aGlzLl96b25lLnNldENvbmR1aXRQcm9wZXJ0aWVzKHN1YmplY3QsIHByb3BlcnRpZXMpO1xuICAgIH1cblxuICAgIC8qKiBQcm9ncmFtbWF0aWNhbGx5IGNyZWF0ZSBhIGNvbmR1aXQgYXQgcnVudGltZSAqL1xuICAgIGNyZWF0ZUNvbmR1aXQoc3ViamVjdDogU3ViamVjdDxhbnk+LCBwcm9wZXJ0aWVzOiBDb25kdWl0UHJvcGVydGllcyk6IHZvaWQge1xuICAgICAgICB0aGlzLl96b25lLmNyZWF0ZUNvbmR1aXQoc3ViamVjdCwgcHJvcGVydGllcyk7XG4gICAgfVxuXG59XG4iLCJpbXBvcnQgeyBPbkluaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbmR1aXRDb21wb25lbnQgfSBmcm9tICcuL2NvbmR1aXQuY29tcG9uZW50JztcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIENvbmR1aXRab25lQ29tcG9uZW50IGV4dGVuZHMgQ29uZHVpdENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gICAgYWJzdHJhY3Qgem9uZUlkOiBzdHJpbmc7XG5cbiAgICBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fem9uZS5zZXRab25lSWQodGhpcy56b25lSWQpO1xuICAgIH1cbn1cbiIsImV4cG9ydCBpbnRlcmZhY2UgQ29uZHVpdFByb3BlcnRpZXMge1xuICAgIGlkOiBudW1iZXIgfCBzdHJpbmc7XG4gICAgYWNjZXB0c0lucHV0PzogYm9vbGVhbiB8IHN0cmluZ1tdO1xuICAgIHByb2R1Y2VzT3V0cHV0PzogYm9vbGVhbjtcbiAgICBjaGFuZ2VEZXRlY3Rpb24/OiAoeDogYW55LCB5OiBhbnkpID0+IGJvb2xlYW47XG4gICAgbWFwPzogYW55O1xufVxuXG5leHBvcnQgY29uc3QgZGVmYXVsdENvbmR1aXRQcm9wczogUGFydGlhbDxDb25kdWl0UHJvcGVydGllcz4gPSB7XG4gICAgYWNjZXB0c0lucHV0OiB0cnVlLFxuICAgIHByb2R1Y2VzT3V0cHV0OiB0cnVlLFxufTtcbiIsImltcG9ydCB7IENvbmR1aXRNZXRhZGF0YSB9IGZyb20gJy4vaW50ZXJmYWNlcy9jb25kdWl0LW1ldGFkYXRhJztcbmltcG9ydCB7IENvbmR1aXRQcm9wZXJ0aWVzLCBkZWZhdWx0Q29uZHVpdFByb3BzIH0gZnJvbSAnLi9pbnRlcmZhY2VzL2NvbmR1aXQtcHJvcGVydGllcyc7XG5cbi8qKiBFeHBvc2UgdGhlIHByb3BlcnR5IHRoYXQgY29uZHVpdHMgd2lsbCBiZSBzdG9yZWQgaW4gKi9cbmV4cG9ydCBjb25zdCBDT05EVUlUUyA9ICdfY29uZHVpdHMnO1xuXG4vKiogQ3JlYXRlIHRoZSBjb25kdWl0IHByb3BlcnR5IGRlY29yYXRvciAqL1xuZXhwb3J0IGZ1bmN0aW9uIENvbmR1aXQocHJvcGVydGllczogQ29uZHVpdFByb3BlcnRpZXMgfCBGdW5jdGlvbik6IFByb3BlcnR5RGVjb3JhdG9yIHtcbiAgICByZXR1cm4gKHRhcmdldDogT2JqZWN0LCBwcm9wZXJ0eUtleTogc3RyaW5nKSA9PiB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0aWVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzID0gcHJvcGVydGllcy5jYWxsKG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhlIHRhcmdldCBkb2VzIG5vdCBhbHJlYWR5IGhhdmUgYSBjb25kdWl0IGxpc3QgdGhlbiBjcmVhdGUgb25lXG4gICAgICAgIGlmICghdGFyZ2V0Lmhhc093blByb3BlcnR5KENPTkRVSVRTKSkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgQ09ORFVJVFMsIHsgdmFsdWU6IFtdIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIHRoZSBjb25kdWl0IHRvIHRoZSBsaXN0IGVuc3VyaW5nIGFsbCByZXF1aXJlZCBwcm9wZXJ0aWVzIGFyZSBwcm92aWRlZFxuICAgICAgICB0YXJnZXRbQ09ORFVJVFNdLnB1c2goeyAuLi5kZWZhdWx0Q29uZHVpdFByb3BzLCAuLi5wcm9wZXJ0aWVzLCB0YXJnZXQsIHByb3BlcnR5S2V5IH0gYXMgQ29uZHVpdE1ldGFkYXRhKTtcbiAgICB9O1xufVxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcy9CZWhhdmlvclN1YmplY3QnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMvT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBkZWxheSwgZGlzdGluY3RVbnRpbENoYW5nZWQsIGZpbHRlciwgbWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XG5pbXBvcnQgeyBEYXNoYm9hcmRPcHRpb25zIH0gZnJvbSAnLi9kYXNoYm9hcmQuY29tcG9uZW50JztcbmltcG9ydCB7IERhc2hib2FyZFdpZGdldENvbXBvbmVudCB9IGZyb20gJy4vd2lkZ2V0L2Rhc2hib2FyZC13aWRnZXQuY29tcG9uZW50JztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIERhc2hib2FyZFNlcnZpY2Uge1xuXG4gICAgcHJpdmF0ZSBfd2lkZ2V0T3JpZ2luOiB7IGNvbHVtbj86IG51bWJlciwgcm93PzogbnVtYmVyLCBjb2x1bW5TcGFuPzogbnVtYmVyLCByb3dTcGFuPzogbnVtYmVyIH07XG4gICAgcHJpdmF0ZSBfYWN0aW9uV2lkZ2V0OiBEYXNoYm9hcmRBY3Rpb247XG4gICAgcHJpdmF0ZSBfcm93SGVpZ2h0OiBudW1iZXIgPSAwO1xuICAgIHByaXZhdGUgX2NhY2hlOiBEYXNoYm9hcmRDYWNoZVtdO1xuICAgIHByaXZhdGUgX21vdXNlRXZlbnQ6IE1vdXNlRXZlbnQ7XG5cbiAgICB3aWRnZXRzJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8RGFzaGJvYXJkV2lkZ2V0Q29tcG9uZW50W10+KFtdKTtcbiAgICBvcHRpb25zJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8RGFzaGJvYXJkT3B0aW9ucz4oZGVmYXVsdE9wdGlvbnMpO1xuICAgIGRpbWVuc2lvbnMkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxEYXNoYm9hcmREaW1lbnNpb25zPih7fSk7XG4gICAgaGVpZ2h0JDogT2JzZXJ2YWJsZTxudW1iZXI+ID0gdGhpcy5kaW1lbnNpb25zJC5waXBlKGRlbGF5KDApLCBtYXAoKGRpbWVuc2lvbnM6IERhc2hib2FyZERpbWVuc2lvbnMpID0+IGRpbWVuc2lvbnMuaGVpZ2h0KSwgZGlzdGluY3RVbnRpbENoYW5nZWQoKSk7XG4gICAgcGxhY2Vob2xkZXIkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxEYXNoYm9hcmRQbGFjZWhvbGRlcj4oeyB2aXNpYmxlOiBmYWxzZSwgeDogMCwgeTogMCwgd2lkdGg6IDAsIGhlaWdodDogMCB9KTtcbiAgICBsYXlvdXQkID0gbmV3IFN1YmplY3Q8RGFzaGJvYXJkTGF5b3V0RGF0YVtdPigpO1xuICAgIHN0YWNrZWQkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPihmYWxzZSk7XG5cbiAgICBnZXQgb3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucyQuZ2V0VmFsdWUoKTtcbiAgICB9XG5cbiAgICBnZXQgd2lkZ2V0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lkZ2V0cyQuZ2V0VmFsdWUoKTtcbiAgICB9XG5cbiAgICBnZXQgc3RhY2tlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhY2tlZCQuZ2V0VmFsdWUoKTtcbiAgICB9XG5cbiAgICBnZXQgZGltZW5zaW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGltZW5zaW9ucyQuZ2V0VmFsdWUoKTtcbiAgICB9XG5cbiAgICBnZXQgY29sdW1uV2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpbWVuc2lvbnMud2lkdGggLyB0aGlzLm9wdGlvbnMuY29sdW1ucztcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5sYXlvdXQkLnN1YnNjcmliZSh0aGlzLnNldExheW91dERhdGEuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuc3RhY2tlZCQucGlwZShmaWx0ZXIoc3RhY2tlZCA9PiBzdGFja2VkID09PSB0cnVlKSkuc3Vic2NyaWJlKHRoaXMudXBkYXRlV2hlblN0YWNrZWQuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMud2lkZ2V0cyQucGlwZShkZWxheSgwKSkuc3Vic2NyaWJlKCgpID0+IHRoaXMucmVuZGVyRGFzaGJvYXJkKCkpO1xuICAgICAgICB0aGlzLmRpbWVuc2lvbnMkLnBpcGUoZGVsYXkoMCkpLnN1YnNjcmliZSgoKSA9PiB0aGlzLnJlbmRlckRhc2hib2FyZCgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSB3aWRnZXQgdG8gdGhlIGRhc2hib2FyZFxuICAgICAqIEBwYXJhbSB3aWRnZXQgVGhlIHdpZGdldCBjb21wb25lbnQgdG8gYWRkIHRvIHRoZSBkYXNoYm9hcmRcbiAgICAgKi9cbiAgICBhZGRXaWRnZXQod2lkZ2V0OiBEYXNoYm9hcmRXaWRnZXRDb21wb25lbnQpOiB2b2lkIHtcbiAgICAgICAgdGhpcy53aWRnZXRzJC5uZXh0KFsuLi50aGlzLndpZGdldHMkLmdldFZhbHVlKCksIHdpZGdldF0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIHdpZGdldCBmcm9tIHRoZSBkYXNoYm9hcmRcbiAgICAgKiBAcGFyYW0gd2lkZ2V0IFRoZSB3aWRnZXQgdG8gcmVtb3ZlXG4gICAgICovXG4gICAgcmVtb3ZlV2lkZ2V0KHdpZGdldDogRGFzaGJvYXJkV2lkZ2V0Q29tcG9uZW50KTogdm9pZCB7XG4gICAgICAgIHRoaXMud2lkZ2V0cyQubmV4dCh0aGlzLndpZGdldHMkLmdldFZhbHVlKCkuZmlsdGVyKF93aWRnZXQgPT4gX3dpZGdldCAhPT0gd2lkZ2V0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGUgdGhhdCB0aGUgZGFzaGJvYXJkIGVsZW1lbnQgaGFzIGJlZW4gcmVzaXplZFxuICAgICAqIEBwYXJhbSB3aWR0aCBUaGUgd2lkdGggb2YgdGhlIGRhc2hib2FyZCBlbGVtZW50IGluIHB4XG4gICAgICogQHBhcmFtIGhlaWdodCBUaGUgaGVpZ2h0IG9mIHRoZSBkYXNoYm9hcmQgZWxlbWVudCBpbiBweFxuICAgICAqL1xuICAgIHNldERpbWVuc2lvbnMod2lkdGg6IG51bWJlciA9IHRoaXMuZGltZW5zaW9ucy53aWR0aCwgaGVpZ2h0OiBudW1iZXIgPSB0aGlzLmRpbWVuc2lvbnMuaGVpZ2h0KTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmRpbWVuc2lvbnMud2lkdGggIT09IHdpZHRoIHx8IHRoaXMuZGltZW5zaW9ucy5oZWlnaHQgIT09IGhlaWdodCkge1xuICAgICAgICAgICAgdGhpcy5kaW1lbnNpb25zJC5uZXh0KHsgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb2R1Y2UgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSByZXF1aXJlZCBsYXlvdXQgZGF0YS5cbiAgICAgKiBUaGlzIGNhbiBiZSB1c2VmdWwgZm9yIGV4cG9ydGluZy9zYXZpbmcgYSBsYXlvdXRcbiAgICAgKi9cbiAgICBnZXRMYXlvdXREYXRhKCk6IERhc2hib2FyZExheW91dERhdGFbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpZGdldHMubWFwKHdpZGdldCA9PiB7XG4gICAgICAgICAgICByZXR1cm4geyBpZDogd2lkZ2V0LmlkLCBjb2w6IHdpZGdldC5nZXRDb2x1bW4oKSwgcm93OiB3aWRnZXQuZ2V0Um93KCksIGNvbFNwYW46IHdpZGdldC5nZXRDb2x1bW5TcGFuKCksIHJvd1NwYW46IHdpZGdldC5nZXRSb3dTcGFuKCkgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUG9zaXRpb24gd2lkZ2V0cyBwcm9ncmFtYXRpY2FsbHlcbiAgICAgKi9cbiAgICBzZXRMYXlvdXREYXRhKHdpZGdldHM6IERhc2hib2FyZExheW91dERhdGFbXSk6IHZvaWQge1xuXG4gICAgICAgIC8vIGl0ZXJhdGUgdGhyb3VnaCBlYWNoIHdpZGdldCBkYXRhIGFuZCBmaW5kIGEgbWF0Y2hcbiAgICAgICAgd2lkZ2V0cy5mb3JFYWNoKHdpZGdldCA9PiB7XG5cbiAgICAgICAgICAgIC8vIGZpbmQgdGhlIG1hdGNoaW5nIHdpZGdldFxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy53aWRnZXRzLmZpbmQoX3dpZGdldCA9PiBfd2lkZ2V0LmlkID09PSB3aWRnZXQuaWQpO1xuXG4gICAgICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnNldENvbHVtbih3aWRnZXQuY29sKTtcbiAgICAgICAgICAgICAgICB0YXJnZXQuc2V0Um93KHdpZGdldC5yb3cpO1xuICAgICAgICAgICAgICAgIHRhcmdldC5zZXRDb2x1bW5TcGFuKHdpZGdldC5jb2xTcGFuKTtcbiAgICAgICAgICAgICAgICB0YXJnZXQuc2V0Um93U3Bhbih3aWRnZXQucm93U3Bhbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgcG9zaXRpb25zIGFuZCBzaXplcyBvZiB0aGUgd2lkZ2V0c1xuICAgICAqL1xuICAgIHJlbmRlckRhc2hib2FyZCgpOiB2b2lkIHtcblxuICAgICAgICAvLyBnZXQgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIGRhc2hib2FyZFxuICAgICAgICB0aGlzLl9yb3dIZWlnaHQgPSB0aGlzLm9wdGlvbnMucm93SGVpZ2h0IHx8IHRoaXMuY29sdW1uV2lkdGg7XG5cbiAgICAgICAgLy8gZW5zdXJlIHRoZSBjb2x1bW4gd2lkdGggaXMgbm90IGJlbG93IHRoZSBtaW4gd2lkdGhzXG4gICAgICAgIHRoaXMuc3RhY2tlZCQubmV4dCh0aGlzLmNvbHVtbldpZHRoIDwgdGhpcy5vcHRpb25zLm1pbldpZHRoKTtcblxuICAgICAgICAvLyBlbnN1cmUgdGhlIHJvdyBoZWlnaHQgaXMgbm90IGJlbG93IHRoZSBtaW4gd2lkdGhzXG4gICAgICAgIGlmICh0aGlzLl9yb3dIZWlnaHQgPCB0aGlzLm9wdGlvbnMubWluV2lkdGgpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jvd0hlaWdodCA9IHRoaXMub3B0aW9ucy5taW5XaWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0RGFzaGJvYXJkTGF5b3V0KCk7XG5cbiAgICAgICAgLy8gaXRlcmF0ZSB0aHJvdWdoIGVhY2ggd2lkZ2V0IGFuZCBzZXQgdGhlIHNpemUgLSBleGNlcHQgdGhlIG9uZSBiZWluZyByZXNpemVkXG4gICAgICAgIHRoaXMud2lkZ2V0cy5maWx0ZXIod2lkZ2V0ID0+ICF0aGlzLl9hY3Rpb25XaWRnZXQgfHwgd2lkZ2V0ICE9PSB0aGlzLl9hY3Rpb25XaWRnZXQud2lkZ2V0KVxuICAgICAgICAgICAgLmZvckVhY2god2lkZ2V0ID0+IHdpZGdldC5yZW5kZXIoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIHdoZXJlIHdpZGdldHMgc2hvdWxkIGJlIHBvc2l0aW9uZWQgYmFzZWQgb24gdGhlaXIgcG9zaXRpb25zLCB3aWR0aCBhbmQgdGhlIHNpemUgb2YgdGhlIGNvbnRhaW5lclxuICAgICAqL1xuICAgIHNldERhc2hib2FyZExheW91dCgpOiB2b2lkIHtcblxuICAgICAgICAvLyBmaW5kIGFueSB3aWRnZXRzIHRoYXQgZG8gbm90IGN1cnJlbnRseSBoYXZlIGEgcG9zaXRpb24gc2V0XG4gICAgICAgIHRoaXMud2lkZ2V0cy5maWx0ZXIod2lkZ2V0ID0+IHdpZGdldC5nZXRDb2x1bW4oKSA9PT0gdW5kZWZpbmVkIHx8IHdpZGdldC5nZXRSb3coKSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgLmZvckVhY2god2lkZ2V0ID0+IHRoaXMuc2V0V2lkZ2V0UG9zaXRpb24od2lkZ2V0KSk7XG5cbiAgICAgICAgdGhpcy5zZXREYXNoYm9hcmRIZWlnaHQoKTtcbiAgICB9XG5cbiAgICB1cGRhdGVXaGVuU3RhY2tlZCgpOiB2b2lkIHtcblxuICAgICAgICAvLyBpdGVyYXRlIHRocm91Z2ggZWFjaCB3aWRnZXQgc2V0IGl0J3Mgc3RhY2tlZCBzdGF0ZSBhbmRcbiAgICAgICAgdGhpcy5nZXRXaWRnZXRzQnlPcmRlcigpLmZvckVhY2goKHdpZGdldCwgaWR4KSA9PiB7XG4gICAgICAgICAgICB3aWRnZXQuc2V0Q29sdW1uKDApO1xuICAgICAgICAgICAgd2lkZ2V0LnNldFJvdyhpZHgpO1xuICAgICAgICB9KTtcblxuICAgIH1cblxuICAgIGdldFdpZGdldHNCeU9yZGVyKCk6IERhc2hib2FyZFdpZGdldENvbXBvbmVudFtdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lkZ2V0cy5zb3J0KCh3MSwgdzIpID0+IHtcblxuICAgICAgICAgICAgY29uc3QgdzFQb3NpdGlvbiA9IHcxLmdldENvbHVtbigpICogdzEuZ2V0Um93KCk7XG4gICAgICAgICAgICBjb25zdCB3MlBvc2l0aW9uID0gdzIuZ2V0Q29sdW1uKCkgKiB3Mi5nZXRSb3coKTtcblxuICAgICAgICAgICAgaWYgKHcxUG9zaXRpb24gPCB3MlBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodzFQb3NpdGlvbiA+IHcyUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmQgYSBwb3NpdGlvbiB0aGF0IGEgd2lkZ2V0IGNhbiBmaXQgaW4gdGhlIGRhc2hib2FyZFxuICAgICAqIEBwYXJhbSB3aWRnZXQgVGhlIHdpZGdldCB0byB0cnkgYW5kIHBvc2l0aW9uXG4gICAgICovXG4gICAgc2V0V2lkZ2V0UG9zaXRpb24od2lkZ2V0OiBEYXNoYm9hcmRXaWRnZXRDb21wb25lbnQpOiB2b2lkIHtcblxuICAgICAgICAvLyBmaW5kIGEgcG9zaXRpb24gZm9yIHRoZSB3aWRnZXRcbiAgICAgICAgbGV0IHBvc2l0aW9uID0gMDtcbiAgICAgICAgbGV0IHN1Y2Nlc3MgPSBmYWxzZTtcblxuICAgICAgICAvLyByZXBlYXQgdW50aWwgYSBzcGFjZSBpcyBmb3VuZFxuICAgICAgICB3aGlsZSAoIXN1Y2Nlc3MpIHtcblxuICAgICAgICAgICAgLy8gZ2V0IGEgcG9zaXRpb24gdG8gdHJ5XG4gICAgICAgICAgICBjb25zdCBjb2x1bW4gPSBwb3NpdGlvbiAlIHRoaXMub3B0aW9ucy5jb2x1bW5zO1xuICAgICAgICAgICAgY29uc3Qgcm93ID0gTWF0aC5mbG9vcihwb3NpdGlvbiAvIHRoaXMub3B0aW9ucy5jb2x1bW5zKTtcblxuICAgICAgICAgICAgLy8gY2hlY2sgdGhlIGN1cnJlbnQgcG9zaXRpb25cbiAgICAgICAgICAgIGlmICh0aGlzLmdldFBvc2l0aW9uQXZhaWxhYmxlKGNvbHVtbiwgcm93LCB3aWRnZXQuZ2V0Q29sdW1uU3BhbigpLCB3aWRnZXQuZ2V0Um93U3BhbigpKSkge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHdpZGdldC5zZXRDb2x1bW4oY29sdW1uKTtcbiAgICAgICAgICAgICAgICB3aWRnZXQuc2V0Um93KHJvdyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY29sdW1uID09PSAwICYmIHdpZGdldC5jb2xTcGFuID4gdGhpcy5vcHRpb25zLmNvbHVtbnMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Rhc2hib2FyZCB3aWRnZXRzIGhhdmUgYSBjb2xTcGFuIGdyZWF0ZXIgdGhhbiB0aGUgbWF4IG51bWJlciBvZiBkYXNoYm9hcmQgY29sdW1ucyEnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcG9zaXRpb24rKztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgcG9zaXRpb24gaW4gdGhlIGRhc2hib2FyZCBpcyB2YWNhbnQgb3Igbm90XG4gICAgICovXG4gICAgZ2V0UG9zaXRpb25BdmFpbGFibGUoY29sdW1uOiBudW1iZXIsIHJvdzogbnVtYmVyLCBjb2x1bW5TcGFuOiBudW1iZXIsIHJvd1NwYW46IG51bWJlciwgaWdub3JlV2lkZ2V0PzogRGFzaGJvYXJkV2lkZ2V0Q29tcG9uZW50KTogYm9vbGVhbiB7XG5cbiAgICAgICAgLy8gZ2V0IGEgbGlzdCBvZiBncmlkIHNwYWNlcyB0aGF0IGFyZSBwb3B1bGF0ZWRcbiAgICAgICAgY29uc3Qgc3BhY2VzID0gdGhpcy5nZXRPY2N1cGllZFNwYWNlcygpO1xuXG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZSBibG9jayB3b3VsZCBzdGlsbCBiZSBpbiBib3VuZHNcbiAgICAgICAgaWYgKGNvbHVtbiArIGNvbHVtblNwYW4gPiB0aGlzLm9wdGlvbnMuY29sdW1ucykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hlY2sgZWFjaCByZXF1aXJlZCBwb3NpdGlvblxuICAgICAgICBmb3IgKGxldCB4ID0gY29sdW1uOyB4IDwgY29sdW1uICsgY29sdW1uU3BhbjsgeCsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gcm93OyB5IDwgcm93ICsgcm93U3BhbjsgeSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNwYWNlcy5maW5kKGJsb2NrID0+IGJsb2NrLmNvbHVtbiA9PT0geCAmJiBibG9jay5yb3cgPT09IHkgJiYgYmxvY2sud2lkZ2V0ICE9PSBpZ25vcmVXaWRnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBnZXRPY2N1cGllZFNwYWNlcygpOiBEYXNoYm9hcmRTcGFjZVtdIHtcblxuICAgICAgICAvLyBmaW5kIGFsbCBzcGFjZXMgdGhhdCBhcmUgY3VycmVudGx5IG9jY3VwaWVkXG4gICAgICAgIHJldHVybiB0aGlzLndpZGdldHMuZmlsdGVyKHdpZGdldCA9PiB3aWRnZXQuZ2V0Q29sdW1uKCkgIT09IHVuZGVmaW5lZCAmJiB3aWRnZXQuZ2V0Um93KCkgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIC5yZWR1Y2UoKHZhbHVlLCB3aWRnZXQpID0+IHtcblxuICAgICAgICAgICAgICAgIHRoaXMuZm9yRWFjaEJsb2NrKHdpZGdldCwgKGNvbHVtbiwgcm93KSA9PiB2YWx1ZS5wdXNoKHsgd2lkZ2V0OiB3aWRnZXQsIGNvbHVtbjogY29sdW1uLCByb3c6IHJvdyB9KSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9LCBbXSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQmVnaW4gcmVzaXppbmcgYSB3aWRnZXRcbiAgICAgKiBAcGFyYW0gYWN0aW9uIFRoZSB0aGUgd2lkZ2V0IHRvIHJlc2l6ZVxuICAgICAqL1xuICAgIG9uUmVzaXplU3RhcnQoYWN0aW9uOiBEYXNoYm9hcmRBY3Rpb24pOiB2b2lkIHtcblxuICAgICAgICAvLyBzdG9yZSB0aGUgbW91c2UgZXZlbnRcbiAgICAgICAgdGhpcy5fbW91c2VFdmVudCA9IGFjdGlvbi5ldmVudDtcbiAgICAgICAgdGhpcy5fYWN0aW9uV2lkZ2V0ID0gYWN0aW9uO1xuXG4gICAgICAgIC8vIGJyaW5nIHRoZSB3aWRnZXQgdG8gdGhlIGZvbnRcbiAgICAgICAgdGhpcy5icmluZ1RvRnJvbnQoYWN0aW9uLndpZGdldCk7XG4gICAgfVxuXG4gICAgb25SZXNpemVEcmFnKGFjdGlvbjogRGFzaGJvYXJkQWN0aW9uKTogdm9pZCB7XG5cbiAgICAgICAgY29uc3QgbW91c2VQb3NYID0gdGhpcy5fbW91c2VFdmVudC5wYWdlWCAtIHBhZ2VYT2Zmc2V0O1xuICAgICAgICBjb25zdCBtb3VzZVBvc1kgPSB0aGlzLl9tb3VzZUV2ZW50LnBhZ2VZIC0gcGFnZVlPZmZzZXQ7XG5cbiAgICAgICAgLy8gaWYgdGhlcmUgd2FzIG5vIG1vdmVtZW50IHRoZW4gZG8gbm90aGluZ1xuICAgICAgICBpZiAoYWN0aW9uLmV2ZW50LnggPT09IG1vdXNlUG9zWCAmJiBhY3Rpb24uZXZlbnQueSA9PT0gbW91c2VQb3NZKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1cGRhdGUgdGhlIHN0b3JlZCBtb3VzZSBldmVudFxuICAgICAgICB0aGlzLl9tb3VzZUV2ZW50ID0gYWN0aW9uLmV2ZW50O1xuXG4gICAgICAgIC8vIGdldCBoYW5kbGUgZm9yIGRpcmVjdGlvblxuICAgICAgICBjb25zdCB7IGhhbmRsZSB9ID0gYWN0aW9uO1xuXG4gICAgICAgIC8vIGdldCB0aGUgYm91bmRzIG9mIHRoZSBoYW5kbGVcbiAgICAgICAgY29uc3QgYm91bmRzID0gaGFuZGxlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgIC8vIGdldCB0aGUgY2VudGVyIG9mIHRoZSBoYW5kbGVcbiAgICAgICAgY29uc3QgY2VudGVyWCA9IGJvdW5kcy5sZWZ0ICsgKGJvdW5kcy53aWR0aCAvIDIpO1xuICAgICAgICBjb25zdCBjZW50ZXJZID0gYm91bmRzLnRvcCArIChib3VuZHMuaGVpZ2h0IC8gMik7XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBjdXJyZW50IG1vdXNlIHBvc2l0aW9uXG4gICAgICAgIGNvbnN0IG1vdXNlWCA9IG1vdXNlUG9zWCAtIGNlbnRlclg7XG4gICAgICAgIGNvbnN0IG1vdXNlWSA9IG1vdXNlUG9zWSAtIGNlbnRlclk7XG5cbiAgICAgICAgLy8gc3RvcmUgdGhlIG5ldyBwcm9wb3NlZCBkaW1lbnNpb25zIGZvciB0aGUgd2lkZ2V0XG4gICAgICAgIGNvbnN0IGRpbWVuc2lvbnM6IERhc2hib2FyZFdpZGdldERpbWVuc2lvbnMgPSB7XG4gICAgICAgICAgICB4OiBhY3Rpb24ud2lkZ2V0LngsXG4gICAgICAgICAgICB5OiBhY3Rpb24ud2lkZ2V0LnksXG4gICAgICAgICAgICB3aWR0aDogYWN0aW9uLndpZGdldC53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogYWN0aW9uLndpZGdldC5oZWlnaHRcbiAgICAgICAgfTtcblxuICAgICAgICAvLyB1cGRhdGUgd2lkZ2V0IGJhc2VkIG9uIHRoZSBoYW5kbGUgYmVpbmcgZHJhZ2dlZFxuICAgICAgICBzd2l0Y2ggKGFjdGlvbi5kaXJlY3Rpb24pIHtcblxuICAgICAgICAgICAgY2FzZSBBY3Rpb25EaXJlY3Rpb24uUmlnaHQ6XG4gICAgICAgICAgICAgICAgZGltZW5zaW9ucy53aWR0aCArPSBtb3VzZVg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgQWN0aW9uRGlyZWN0aW9uLkxlZnQ6XG4gICAgICAgICAgICAgICAgZGltZW5zaW9ucy54ICs9IG1vdXNlWDtcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zLndpZHRoIC09IG1vdXNlWDtcblxuICAgICAgICAgICAgICAgIGlmIChkaW1lbnNpb25zLndpZHRoIDwgdGhpcy5vcHRpb25zLm1pbldpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpZmZlcmVuY2UgPSB0aGlzLm9wdGlvbnMubWluV2lkdGggLSBkaW1lbnNpb25zLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb25zLnggLT0gZGlmZmVyZW5jZTtcbiAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9ucy53aWR0aCArPSBkaWZmZXJlbmNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIEFjdGlvbkRpcmVjdGlvbi5Cb3R0b206XG4gICAgICAgICAgICAgICAgZGltZW5zaW9ucy5oZWlnaHQgKz0gbW91c2VZO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIEFjdGlvbkRpcmVjdGlvbi5Ub3A6XG4gICAgICAgICAgICAgICAgZGltZW5zaW9ucy55ICs9IG1vdXNlWTtcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zLmhlaWdodCAtPSBtb3VzZVk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZGltZW5zaW9ucy5oZWlnaHQgPCB0aGlzLm9wdGlvbnMubWluSGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpZmZlcmVuY2UgPSB0aGlzLm9wdGlvbnMubWluSGVpZ2h0IC0gZGltZW5zaW9ucy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMueSAtPSBkaWZmZXJlbmNlO1xuICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb25zLmhlaWdodCArPSBkaWZmZXJlbmNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgLy8gU3VwcG9ydCByZXNpemluZyBvbiBtdWx0aXBsZSBheGlzIHNpbXVsdGFuZW91c2x5XG4gICAgICAgICAgICBjYXNlIEFjdGlvbkRpcmVjdGlvbi5Ub3BMZWZ0OlxuXG4gICAgICAgICAgICAgICAgZGltZW5zaW9ucy54ICs9IG1vdXNlWDtcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zLndpZHRoIC09IG1vdXNlWDtcblxuICAgICAgICAgICAgICAgIGlmIChkaW1lbnNpb25zLndpZHRoIDwgdGhpcy5vcHRpb25zLm1pbldpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpZmZlcmVuY2UgPSB0aGlzLm9wdGlvbnMubWluV2lkdGggLSBkaW1lbnNpb25zLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb25zLnggLT0gZGlmZmVyZW5jZTtcbiAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9ucy53aWR0aCArPSBkaWZmZXJlbmNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMueSArPSBtb3VzZVk7XG4gICAgICAgICAgICAgICAgZGltZW5zaW9ucy5oZWlnaHQgLT0gbW91c2VZO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRpbWVuc2lvbnMuaGVpZ2h0IDwgdGhpcy5vcHRpb25zLm1pbkhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaWZmZXJlbmNlID0gdGhpcy5vcHRpb25zLm1pbkhlaWdodCAtIGRpbWVuc2lvbnMuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb25zLnkgLT0gZGlmZmVyZW5jZTtcbiAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9ucy5oZWlnaHQgKz0gZGlmZmVyZW5jZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgQWN0aW9uRGlyZWN0aW9uLlRvcFJpZ2h0OlxuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMud2lkdGggKz0gbW91c2VYO1xuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMueSArPSBtb3VzZVk7XG4gICAgICAgICAgICAgICAgZGltZW5zaW9ucy5oZWlnaHQgLT0gbW91c2VZO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRpbWVuc2lvbnMuaGVpZ2h0IDwgdGhpcy5vcHRpb25zLm1pbkhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaWZmZXJlbmNlID0gdGhpcy5vcHRpb25zLm1pbkhlaWdodCAtIGRpbWVuc2lvbnMuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb25zLnkgLT0gZGlmZmVyZW5jZTtcbiAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9ucy5oZWlnaHQgKz0gZGlmZmVyZW5jZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgQWN0aW9uRGlyZWN0aW9uLkJvdHRvbUxlZnQ6XG4gICAgICAgICAgICAgICAgZGltZW5zaW9ucy5oZWlnaHQgKz0gbW91c2VZO1xuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMueCArPSBtb3VzZVg7XG4gICAgICAgICAgICAgICAgZGltZW5zaW9ucy53aWR0aCAtPSBtb3VzZVg7XG5cbiAgICAgICAgICAgICAgICBpZiAoZGltZW5zaW9ucy53aWR0aCA8IHRoaXMub3B0aW9ucy5taW5XaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaWZmZXJlbmNlID0gdGhpcy5vcHRpb25zLm1pbldpZHRoIC0gZGltZW5zaW9ucy53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9ucy54IC09IGRpZmZlcmVuY2U7XG4gICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMud2lkdGggKz0gZGlmZmVyZW5jZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgQWN0aW9uRGlyZWN0aW9uLkJvdHRvbVJpZ2h0OlxuICAgICAgICAgICAgICAgIGRpbWVuc2lvbnMuaGVpZ2h0ICs9IG1vdXNlWTtcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zLndpZHRoICs9IG1vdXNlWDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGN1cnJlbnRXaWR0aCA9IGFjdGlvbi53aWRnZXQueCArIGFjdGlvbi53aWRnZXQud2lkdGg7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRIZWlnaHQgPSBhY3Rpb24ud2lkZ2V0LnkgKyBhY3Rpb24ud2lkZ2V0LmhlaWdodDtcblxuICAgICAgICAvLyBlbnN1cmUgdmFsdWVzIGFyZSB3aXRoaW4gdGhlIGRhc2hib2FyZCBib3VuZHNcbiAgICAgICAgaWYgKGRpbWVuc2lvbnMueCA8IDApIHtcbiAgICAgICAgICAgIGRpbWVuc2lvbnMueCA9IDA7XG4gICAgICAgICAgICBkaW1lbnNpb25zLndpZHRoID0gY3VycmVudFdpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRpbWVuc2lvbnMueSA8IDApIHtcbiAgICAgICAgICAgIGRpbWVuc2lvbnMueSA9IDA7XG4gICAgICAgICAgICBkaW1lbnNpb25zLmhlaWdodCA9IGN1cnJlbnRIZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKGRpbWVuc2lvbnMueCArIGRpbWVuc2lvbnMud2lkdGgpID4gdGhpcy5kaW1lbnNpb25zLndpZHRoKSB7XG4gICAgICAgICAgICBkaW1lbnNpb25zLndpZHRoID0gdGhpcy5kaW1lbnNpb25zLndpZHRoIC0gZGltZW5zaW9ucy54O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhlIHByb3Bvc2VkIHdpZHRoIGlzIHNtYWxsZXIgdGhhbiBhbGxvd2VkIHRoZW4gcmVzZXQgd2lkdGggdG8gbWluaW11bSBhbmQgaWdub3JlIHggY2hhbmdlc1xuICAgICAgICBpZiAoZGltZW5zaW9ucy53aWR0aCA8IHRoaXMub3B0aW9ucy5taW5XaWR0aCkge1xuICAgICAgICAgICAgZGltZW5zaW9ucy54ID0gYWN0aW9uLndpZGdldC54O1xuICAgICAgICAgICAgZGltZW5zaW9ucy53aWR0aCA9IHRoaXMub3B0aW9ucy5taW5XaWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoZSBwcm9wb3NlZCBoZWlnaHQgaXMgc21hbGxlciB0aGFuIGFsbG93ZWQgdGhlbiByZXNldCBoZWlnaHQgdG8gbWluaW11bSBhbmQgaWdub3JlIHkgY2hhbmdlc1xuICAgICAgICBpZiAoZGltZW5zaW9ucy5oZWlnaHQgPCB0aGlzLm9wdGlvbnMubWluSGVpZ2h0KSB7XG4gICAgICAgICAgICBkaW1lbnNpb25zLnkgPSBhY3Rpb24ud2lkZ2V0Lnk7XG4gICAgICAgICAgICBkaW1lbnNpb25zLmhlaWdodCA9IHRoaXMub3B0aW9ucy5taW5IZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1cGRhdGUgdGhlIHdpZGdldCBhY3R1YWwgdmFsdWVzXG4gICAgICAgIGFjdGlvbi53aWRnZXQuc2V0Qm91bmRzKGRpbWVuc2lvbnMueCwgZGltZW5zaW9ucy55LCBkaW1lbnNpb25zLndpZHRoLCBkaW1lbnNpb25zLmhlaWdodCk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHBsYWNlaG9sZGVyIHBvc2l0aW9uIGFuZCB2YWx1ZVxuICAgICAgICB0aGlzLnNldFBsYWNlaG9sZGVyQm91bmRzKHRydWUsIGRpbWVuc2lvbnMueCwgZGltZW5zaW9ucy55LCBkaW1lbnNpb25zLndpZHRoLCBkaW1lbnNpb25zLmhlaWdodCk7XG5cbiAgICAgICAgLy8gc2hvdyB0aGUgd2lkZ2V0IHBvc2l0aW9ucyBpZiB0aGUgY3VycmVudCBwb3NpdGlvbnMgYW5kIHNpemVzIHdlcmUgdG8gcGVyc2lzdFxuICAgICAgICB0aGlzLnVwZGF0ZVdpZGdldFBvc2l0aW9ucyhhY3Rpb24ud2lkZ2V0KTtcbiAgICB9XG5cbiAgICBvblJlc2l6ZUVuZCgpOiB2b2lkIHtcblxuICAgICAgICBjb25zdCBwbGFjZWhvbGRlciA9IHRoaXMucGxhY2Vob2xkZXIkLmdldFZhbHVlKCk7XG5cbiAgICAgICAgLy8gY29tbWl0IHJlc2l6ZSBjaGFuZ2VzXG4gICAgICAgIHRoaXMuY29tbWl0V2lkZ2V0Q2hhbmdlcygpO1xuXG4gICAgICAgIC8vIGhpZGUgcGxhY2Vob2xkZXJcbiAgICAgICAgcGxhY2Vob2xkZXIudmlzaWJsZSA9IGZhbHNlO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgcGxhY2Vob2xkZXJcbiAgICAgICAgdGhpcy5wbGFjZWhvbGRlciQubmV4dChwbGFjZWhvbGRlcik7XG5cbiAgICAgICAgdGhpcy5fYWN0aW9uV2lkZ2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbW91c2VFdmVudCA9IG51bGw7XG5cbiAgICAgICAgLy8gZW5zdXJlIGFueSB2YWNhbnQgdXBwZXIgc3BhY2VzIGFyZSBmaWxsZWQgd2hlcmUgcmVxdWlyZWRcbiAgICAgICAgdGhpcy5zaGlmdFdpZGdldHNVcCgpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSBkYXNoYm9hcmQgaGVpZ2h0XG4gICAgICAgIHRoaXMuc2V0RGFzaGJvYXJkSGVpZ2h0KCk7XG5cbiAgICAgICAgLy8gZW1pdCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgbGF5b3V0XG4gICAgICAgIHRoaXMubGF5b3V0JC5uZXh0KHRoaXMuZ2V0TGF5b3V0RGF0YSgpKTtcbiAgICB9XG5cbiAgICBvbkRyYWdTdGFydChhY3Rpb246IERhc2hib2FyZEFjdGlvbik6IHZvaWQge1xuICAgICAgICB0aGlzLm9uUmVzaXplU3RhcnQoYWN0aW9uKTtcblxuICAgICAgICAvLyBzdG9yZSB0aGUgc3RhcnRpbmcgcGxhY2Vob2xkZXIgcG9zaXRpb25cbiAgICAgICAgdGhpcy5zZXRXaWRnZXRPcmlnaW4oKTtcblxuICAgICAgICB0aGlzLmNhY2hlV2lkZ2V0cygpO1xuICAgIH1cblxuICAgIG9uRHJhZ0VuZCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5vblJlc2l6ZUVuZCgpO1xuXG4gICAgICAgIHRoaXMuX3dpZGdldE9yaWdpbiA9IHt9O1xuICAgIH1cblxuICAgIG9uRHJhZyhhY3Rpb246IERhc2hib2FyZEFjdGlvbik6IHZvaWQge1xuXG4gICAgICAgIC8vIGlmIHRoZXJlIHdhcyBubyBtb3ZlbWVudCB0aGVuIGRvIG5vdGhpbmdcbiAgICAgICAgaWYgKGFjdGlvbi5ldmVudC5wYWdlWCA9PT0gdGhpcy5fbW91c2VFdmVudC5wYWdlWCAmJiBhY3Rpb24uZXZlbnQucGFnZVkgPT09IHRoaXMuX21vdXNlRXZlbnQucGFnZVkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdldCB0aGUgY3VycmVudCBtb3VzZSBwb3NpdGlvblxuICAgICAgICBjb25zdCBtb3VzZVggPSBhY3Rpb24uZXZlbnQucGFnZVggLSB0aGlzLl9tb3VzZUV2ZW50LnBhZ2VYO1xuICAgICAgICBjb25zdCBtb3VzZVkgPSBhY3Rpb24uZXZlbnQucGFnZVkgLSB0aGlzLl9tb3VzZUV2ZW50LnBhZ2VZO1xuXG4gICAgICAgIC8vIHN0b3JlIHRoZSBsYXRlc3QgZXZlbnRcbiAgICAgICAgdGhpcy5fbW91c2VFdmVudCA9IGFjdGlvbi5ldmVudDtcblxuICAgICAgICBjb25zdCBkaW1lbnNpb25zOiBEYXNoYm9hcmRXaWRnZXREaW1lbnNpb25zID0ge1xuICAgICAgICAgICAgeDogYWN0aW9uLndpZGdldC54ICsgbW91c2VYLFxuICAgICAgICAgICAgeTogYWN0aW9uLndpZGdldC55ICsgbW91c2VZLFxuICAgICAgICAgICAgd2lkdGg6IGFjdGlvbi53aWRnZXQud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGFjdGlvbi53aWRnZXQuaGVpZ2h0XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5yZXN0b3JlV2lkZ2V0cyh0cnVlKTtcblxuICAgICAgICAvLyB1cGRhdGUgd2lkZ2V0IHBvc2l0aW9uXG4gICAgICAgIGFjdGlvbi53aWRnZXQuc2V0Qm91bmRzKGRpbWVuc2lvbnMueCwgZGltZW5zaW9ucy55LCBkaW1lbnNpb25zLndpZHRoLCBkaW1lbnNpb25zLmhlaWdodCk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHBsYWNlaG9sZGVyIHBvc2l0aW9uIGFuZCB2YWx1ZVxuICAgICAgICB0aGlzLnNldFBsYWNlaG9sZGVyQm91bmRzKHRydWUsIGRpbWVuc2lvbnMueCwgZGltZW5zaW9ucy55LCBkaW1lbnNpb25zLndpZHRoLCBkaW1lbnNpb25zLmhlaWdodCk7XG5cbiAgICAgICAgLy8gc2hvdyB0aGUgd2lkZ2V0IHBvc2l0aW9ucyBpZiB0aGUgY3VycmVudCBwb3NpdGlvbnMgYW5kIHNpemVzIHdlcmUgdG8gcGVyc2lzdFxuICAgICAgICB0aGlzLnNoaWZ0V2lkZ2V0cygpO1xuXG4gICAgICAgIHRoaXMuc2V0RGFzaGJvYXJkSGVpZ2h0KCk7XG4gICAgfVxuXG4gICAgZ2V0Um93SGVpZ2h0KCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yb3dIZWlnaHQ7XG4gICAgfVxuXG4gICAgY2FjaGVXaWRnZXRzKCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9jYWNoZSA9IHRoaXMud2lkZ2V0cy5tYXAod2lkZ2V0ID0+ICh7IGlkOiB3aWRnZXQuaWQsIGNvbHVtbjogd2lkZ2V0LmdldENvbHVtbigpLCByb3c6IHdpZGdldC5nZXRSb3coKSB9KSk7XG4gICAgfVxuXG4gICAgcmVzdG9yZVdpZGdldHMoaWdub3JlQWN0aW9uV2lkZ2V0OiBib29sZWFuID0gZmFsc2UpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fY2FjaGUuZmlsdGVyKHdpZGdldCA9PiAhaWdub3JlQWN0aW9uV2lkZ2V0IHx8IHdpZGdldC5pZCAhPT0gdGhpcy5fYWN0aW9uV2lkZ2V0LndpZGdldC5pZCkuZm9yRWFjaCh3aWRnZXQgPT4ge1xuXG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IHRoaXMud2lkZ2V0cy5maW5kKHdndCA9PiB3Z3QuaWQgPT09IHdpZGdldC5pZCk7XG5cbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIG1hdGNoLnNldENvbHVtbih3aWRnZXQuY29sdW1uKTtcbiAgICAgICAgICAgICAgICBtYXRjaC5zZXRSb3cod2lkZ2V0LnJvdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZW4gZHJhZ2dpbmcgYW55IHdpZGdldHMgdGhhdCBuZWVkIHRvIGJlIG1vdmVkIHNob3VsZCBiZSBtb3ZlZCB0byBhbiBhcHByb3ByaWF0ZSBwb3NpdGlvblxuICAgICAqL1xuICAgIHNoaWZ0V2lkZ2V0cygpOiB2b2lkIHtcblxuICAgICAgICBsZXQgd2lkZ2V0c1RvTW92ZTogRGFzaGJvYXJkV2lkZ2V0Q29tcG9uZW50W10gPSBbXTtcblxuICAgICAgICBjb25zdCBwbGFjZWhvbGRlciA9IHRoaXMucGxhY2Vob2xkZXIkLmdldFZhbHVlKCk7XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgYXJlIGFueSB3aWRnZXRzIHVuZGVyIHRoZSBwbGFjZWhvbGRlclxuICAgICAgICBmb3IgKGxldCByb3cgPSBwbGFjZWhvbGRlci5yb3c7IHJvdyA8IHBsYWNlaG9sZGVyLnJvdyArIHBsYWNlaG9sZGVyLnJvd1NwYW47IHJvdysrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBjb2x1bW4gPSBwbGFjZWhvbGRlci5jb2x1bW47IGNvbHVtbiA8IHBsYWNlaG9sZGVyLmNvbHVtbiArIHBsYWNlaG9sZGVyLmNvbHVtblNwYW47IGNvbHVtbisrKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBzdG9yZSByZWZlcmVuY2UgdG8gYW55IHdpZGdldHMgdGhhdCBuZWVkIG1vdmVkXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRPY2N1cGllZFNwYWNlcygpXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoc3BhY2UgPT4gc3BhY2UuY29sdW1uID09PSBjb2x1bW4gJiYgc3BhY2Uucm93ID09PSByb3cgJiYgc3BhY2Uud2lkZ2V0ICE9PSB0aGlzLl9hY3Rpb25XaWRnZXQud2lkZ2V0KVxuICAgICAgICAgICAgICAgICAgICAuZm9yRWFjaChzcGFjZSA9PiB3aWRnZXRzVG9Nb3ZlLnB1c2goc3BhY2Uud2lkZ2V0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmUgYW55IGR1cGxpY2F0ZXNcbiAgICAgICAgd2lkZ2V0c1RvTW92ZSA9IHdpZGdldHNUb01vdmUuZmlsdGVyKCh3aWRnZXQsIGlkeCwgYXJyYXkpID0+IGFycmF5LmluZGV4T2Yod2lkZ2V0KSA9PT0gaWR4KTtcblxuICAgICAgICAvLyBpZiBubyB3aWRnZXRzIG5lZWQgbW92ZWQgdGhlbiB3ZSBjYW4gc3RvcCBoZXJlXG4gICAgICAgIGlmICh3aWRnZXRzVG9Nb3ZlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlIGEgZHVwbGljYXRlIHdlIGNhbiB1c2UgdG8ga2VlcCB0cmFjayBvZiB3aGljaCBoYXZlIGJlZW4gbW92ZWRcbiAgICAgICAgY29uc3QgdW5tb3ZlZFdpZGdldHMgPSB3aWRnZXRzVG9Nb3ZlLnNsaWNlKCk7XG5cbiAgICAgICAgLy8gYXR0ZW1wdCB0byBtb3ZlIGFueSB3aWRnZXRzIHRvIHRoZSBwcmV2aW91cyB3aWRnZXQgcG9zaXRpb25cbiAgICAgICAgd2lkZ2V0c1RvTW92ZS5mb3JFYWNoKHdpZGdldCA9PiB7XG5cbiAgICAgICAgICAgIC8vIGdldCBhIGdyaWQgb2ZmIGFsbCBvY2N1cGllZCBzcGFjZXMgLSB0YWtpbmcgaW50byBhY2NvdW50IHRoZSBwbGFjZWhvbGRlciBhbmQgaWdub3Jpbmcgd2lkZ2V0cyB0aGF0IG5lZWQgbW92ZWRcbiAgICAgICAgICAgIGNvbnN0IGdyaWQgPSB0aGlzLmdldE9jY3VwaWVkU3BhY2VzKCkuZmlsdGVyKHNwYWNlID0+ICF1bm1vdmVkV2lkZ2V0cy5maW5kKHdndCA9PiB3Z3QgPT09IHNwYWNlLndpZGdldCkpO1xuXG4gICAgICAgICAgICAvLyBpdGVyYXRlIGVhY2ggZnJlZSBibG9ja1xuICAgICAgICAgICAgZm9yIChsZXQgcm93ID0gdGhpcy5fd2lkZ2V0T3JpZ2luLnJvdzsgcm93IDwgdGhpcy5fd2lkZ2V0T3JpZ2luLnJvdyArIHRoaXMuX3dpZGdldE9yaWdpbi5yb3dTcGFuOyByb3crKykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGNvbHVtbiA9IHRoaXMuX3dpZGdldE9yaWdpbi5jb2x1bW47IGNvbHVtbiA8IHRoaXMuX3dpZGdldE9yaWdpbi5jb2x1bW4gKyB0aGlzLl93aWRnZXRPcmlnaW4uY29sdW1uU3BhbjsgY29sdW1uKyspIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBkZXRlcm1pbmUgaWYgdGhlIGJsb2NrIGNhbiBmaXQgaW4gdGhpcyBzcGFjZVxuICAgICAgICAgICAgICAgICAgICBsZXQgcmVxdWlyZWRTcGFjZXMgPSB0aGlzLmdldFJlcXVpcmVkU3BhY2VzRnJvbVBvaW50KHdpZGdldCwgY29sdW1uLCByb3cpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHdpZGdldCB3b3VsZCBmaXQgaW4gc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgbGV0IGF2YWlsYWJsZSA9IHJlcXVpcmVkU3BhY2VzLmV2ZXJ5KHNwYWNlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhZ3JpZC5maW5kKGdyaWRTcGFjZSA9PiBncmlkU3BhY2UuY29sdW1uID09PSBzcGFjZS5jb2x1bW4gJiYgZ3JpZFNwYWNlLnJvdyA9PT0gc3BhY2Uucm93KSAmJiBzcGFjZS5jb2x1bW4gPCB0aGlzLmdldENvbHVtbkNvdW50KCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChhdmFpbGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZGdldC5zZXRDb2x1bW4oY29sdW1uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZGdldC5zZXRSb3cocm93KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVubW92ZWRXaWRnZXRzLnNwbGljZSh1bm1vdmVkV2lkZ2V0cy5maW5kSW5kZXgod2d0ID0+IHdndCA9PT0gd2lkZ2V0KSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHdlIGdldCB0byBoZXJlIHRoZW4gd2UgY2FuJ3Qgc2ltcGx5IHN3YXAgdGhlIHBvc2l0aW9ucyAtIG5leHQgdHJ5IG1vdmluZyByaWdodFxuICAgICAgICAgICAgaWYgKHRoaXMuY2FuV2lkZ2V0TW92ZVJpZ2h0KHdpZGdldCwgdHJ1ZSkpIHtcblxuICAgICAgICAgICAgICAgIC8vIGFmdGVyIHRoZSBzaGlmdCBjaGVjayBpZiBwbGFjZWhvbGRlciBwb3NpdGlvbiBpcyBzdGlsbCB2YWxpZFxuICAgICAgICAgICAgICAgIHRoaXMudmFsaWRhdGVQbGFjZWhvbGRlclBvc2l0aW9uKEFjdGlvbkRpcmVjdGlvbi5SaWdodCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBuZXh0IHRyeSBtb3ZpbmcgbGVmdFxuICAgICAgICAgICAgaWYgKHRoaXMuY2FuV2lkZ2V0TW92ZUxlZnQod2lkZ2V0LCB0cnVlKSkge1xuXG4gICAgICAgICAgICAgICAgLy8gYWZ0ZXIgdGhlIHNoaWZ0IGNoZWNrIGlmIHBsYWNlaG9sZGVyIHBvc2l0aW9uIGlzIHN0aWxsIHZhbGlkXG4gICAgICAgICAgICAgICAgdGhpcy52YWxpZGF0ZVBsYWNlaG9sZGVyUG9zaXRpb24oQWN0aW9uRGlyZWN0aW9uLkxlZnQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIHRoZSBkaXN0YW5jZSB0aGF0IHRoZSB3aWRnZXQgbmVlZHMgdG8gYmUgbW92ZWQgZG93blxuICAgICAgICAgICAgbGV0IGRpc3RhbmNlID0gKHRoaXMuX2FjdGlvbldpZGdldC53aWRnZXQuZ2V0Um93KCkgLSB3aWRnZXQuZ2V0Um93KCkpICsgdGhpcy5fYWN0aW9uV2lkZ2V0LndpZGdldC5nZXRSb3dTcGFuKCk7XG5cbiAgICAgICAgICAgIC8vIGFzIGEgbGFzdCByZXNvcnQgbW92ZSB0aGUgd2lkZ2V0IGRvd253YXJkc1xuICAgICAgICAgICAgdGhpcy5tb3ZlV2lkZ2V0RG93bih3aWRnZXQsIGRpc3RhbmNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWZ0ZXIgc2hpZnRzIGhhdmUgdGFrZW4gcGxhY2Ugd2Ugc2hvdWxkIHZlcmlmeSB0aGUgcGxhY2UgaG9sZGVyIHBvc2l0aW9uIGlzIHN0aWxsIHZhbGlkXG4gICAgICogQHBhcmFtIHNoaWZ0RGlyZWN0aW9uIC0gdGhlIHBvc2l0aW9uIHdpZGdldHMgd2VyZSBzaGlmdGVkXG4gICAgICovXG4gICAgdmFsaWRhdGVQbGFjZWhvbGRlclBvc2l0aW9uKHNoaWZ0RGlyZWN0aW9uOiBBY3Rpb25EaXJlY3Rpb24pIHtcblxuICAgICAgICBjb25zdCBwbGFjZWhvbGRlciA9IHRoaXMucGxhY2Vob2xkZXIkLmdldFZhbHVlKCk7XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlIHBsYWNlaG9sZGVyIGlzIG92ZXIgYSB3aWRnZXRcbiAgICAgICAgaWYgKHRoaXMuZ2V0V2lkZ2V0c0F0UG9zaXRpb24ocGxhY2Vob2xkZXIuY29sdW1uLCBwbGFjZWhvbGRlci5yb3csIHRydWUpLmxlbmd0aCA+IDApIHtcblxuICAgICAgICAgICAgLy8gbW92ZSB0aGUgcGxhY2Vob2xkZXIgdGhlIG9wcG9zaXRlIGRpcmVjdGlvblxuICAgICAgICAgICAgc3dpdGNoIChzaGlmdERpcmVjdGlvbikge1xuXG4gICAgICAgICAgICAgICAgY2FzZSBBY3Rpb25EaXJlY3Rpb24uTGVmdDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRQbGFjZWhvbGRlckJvdW5kcyhwbGFjZWhvbGRlci52aXNpYmxlLCBwbGFjZWhvbGRlci54ICsgdGhpcy5nZXRDb2x1bW5XaWR0aCgpLCBwbGFjZWhvbGRlci55LCBwbGFjZWhvbGRlci53aWR0aCwgcGxhY2Vob2xkZXIuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIEFjdGlvbkRpcmVjdGlvbi5SaWdodDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRQbGFjZWhvbGRlckJvdW5kcyhwbGFjZWhvbGRlci52aXNpYmxlLCBwbGFjZWhvbGRlci54IC0gdGhpcy5nZXRDb2x1bW5XaWR0aCgpLCBwbGFjZWhvbGRlci55LCBwbGFjZWhvbGRlci53aWR0aCwgcGxhY2Vob2xkZXIuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHZhbGlkYXRlIHRoaXMgbmV3IHBvc2l0aW9uIGFnYWluXG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlUGxhY2Vob2xkZXJQb3NpdGlvbihzaGlmdERpcmVjdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgaWYgYSB3aWRnZXQgY2FuIGJlIG1vdmVkIGxlZnQgLSBvciBpZiBpdCBjYW4gbW92ZSB0aGUgd2lkZ2V0cyB0byB0aGUgcmlnaHQgdG8gbWFrZSBzcGFjZSBmb3IgdGhlIHdpZGdldFxuICAgICAqL1xuICAgIGNhbldpZGdldE1vdmVMZWZ0KHdpZGdldDogRGFzaGJvYXJkV2lkZ2V0Q29tcG9uZW50LCBwZXJmb3JtTW92ZTogYm9vbGVhbiA9IGZhbHNlKTogYm9vbGVhbiB7XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlIHdpZGdldCBpcyB0aGUgYWN0aW9uIHdpZGdldCBvciBvY2N1cGllcyB0aGUgZmlyc3QgY29sdW1uXG4gICAgICAgIGlmICh3aWRnZXQgPT09IHRoaXMuX2FjdGlvbldpZGdldC53aWRnZXQgfHwgd2lkZ2V0LmdldENvbHVtbigpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaW5kIHRoZSBwb3NpdGlvbnMgcmVxdWlyZWRcbiAgICAgICAgY29uc3QgdGFyZ2V0U3BhY2VzID0gdGhpcy5nZXRPY2N1cGllZFNwYWNlcygpLmZpbHRlcihzcGFjZSA9PiBzcGFjZS53aWRnZXQgPT09IHdpZGdldCkubWFwKHNwYWNlID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7IGNvbHVtbjogc3BhY2UuY29sdW1uIC0gd2lkZ2V0LmdldENvbHVtblNwYW4oKSwgcm93OiBzcGFjZS5yb3csIHdpZGdldDogc3BhY2Uud2lkZ2V0IH07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZXJlIGFyZSB3aWRnZXQgaW4gdGhlIHJlcXVpcmVkIHBvc2l0aW9ucyBhbmQgaWYgc28sIGNhbiB0aGV5IG1vdmUgcmlnaHQ/XG4gICAgICAgIGNvbnN0IG1vdmVhYmxlID0gdGFyZ2V0U3BhY2VzLmV2ZXJ5KHNwYWNlID0+IHRoaXMuZ2V0V2lkZ2V0c0F0UG9zaXRpb24oc3BhY2UuY29sdW1uLCBzcGFjZS5yb3cpLmZpbHRlcih3Z3QgPT4gd2d0ICE9PSBzcGFjZS53aWRnZXQpLmV2ZXJ5KHdndCA9PiB0aGlzLmNhbldpZGdldE1vdmVMZWZ0KHdndCkpKTtcblxuICAgICAgICBpZiAocGVyZm9ybU1vdmUgJiYgbW92ZWFibGUpIHtcblxuICAgICAgICAgICAgLy8gbW92ZSBhbGwgd2lkZ2V0cyB0byB0aGUgcmlnaHRcbiAgICAgICAgICAgIHRhcmdldFNwYWNlcy5mb3JFYWNoKHNwYWNlID0+IHRoaXMuZ2V0V2lkZ2V0c0F0UG9zaXRpb24oc3BhY2UuY29sdW1uLCBzcGFjZS5yb3cpLmZpbHRlcih3Z3QgPT4gd2d0ICE9PSBzcGFjZS53aWRnZXQpLmZvckVhY2god2d0ID0+IHRoaXMuY2FuV2lkZ2V0TW92ZUxlZnQod2d0LCB0cnVlKSkpO1xuXG4gICAgICAgICAgICAvLyBtb3ZlIGN1cnJlbnQgd2lkZ2V0IHRvIHRoZSByaWdodFxuICAgICAgICAgICAgd2lkZ2V0LnNldENvbHVtbih3aWRnZXQuZ2V0Q29sdW1uKCkgLSAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtb3ZlYWJsZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgaWYgYSB3aWRnZXQgY2FuIGJlIG1vdmVkIHJpZ2h0IC0gb3IgaWYgaXQgY2FuIG1vdmUgdGhlIHdpZGdldHMgdG8gdGhlIHJpZ2h0IHRvIG1ha2Ugc3BhY2UgZm9yIHRoZSB3aWRnZXRcbiAgICAgKi9cbiAgICBjYW5XaWRnZXRNb3ZlUmlnaHQod2lkZ2V0OiBEYXNoYm9hcmRXaWRnZXRDb21wb25lbnQsIHBlcmZvcm1Nb3ZlOiBib29sZWFuID0gZmFsc2UpOiBib29sZWFuIHtcblxuICAgICAgICAvLyBjaGVjayBpZiB0aGUgd2lkZ2V0IGlzIHRoZSBkcmFnZ2luZyB3aWRnZXQgb3IgdGhlIHdpZGdldCBvY2N1cGllcyB0aGUgZmluYWwgY29sdW1uXG4gICAgICAgIGlmICh3aWRnZXQgPT09IHRoaXMuX2FjdGlvbldpZGdldC53aWRnZXQgfHwgd2lkZ2V0LmdldENvbHVtbigpICsgd2lkZ2V0LmdldENvbHVtblNwYW4oKSA9PT0gdGhpcy5vcHRpb25zLmNvbHVtbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbmQgdGhlIHBvc2l0aW9ucyByZXF1aXJlZFxuICAgICAgICBjb25zdCB0YXJnZXRTcGFjZXMgPSB0aGlzLmdldE9jY3VwaWVkU3BhY2VzKCkuZmlsdGVyKHNwYWNlID0+IHNwYWNlLndpZGdldCA9PT0gd2lkZ2V0KS5tYXAoc3BhY2UgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHsgY29sdW1uOiBzcGFjZS5jb2x1bW4gKyB3aWRnZXQuZ2V0Q29sdW1uU3BhbigpLCByb3c6IHNwYWNlLnJvdywgd2lkZ2V0OiBzcGFjZS53aWRnZXQgfTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgYXJlIHdpZGdldCBpbiB0aGUgcmVxdWlyZWQgcG9zaXRpb25zIGFuZCBpZiBzbywgY2FuIHRoZXkgbW92ZSByaWdodD9cbiAgICAgICAgY29uc3QgbW92ZWFibGUgPSB0YXJnZXRTcGFjZXMuZXZlcnkoc3BhY2UgPT4gdGhpcy5nZXRXaWRnZXRzQXRQb3NpdGlvbihzcGFjZS5jb2x1bW4sIHNwYWNlLnJvdykuZmlsdGVyKHdndCA9PiB3Z3QgIT09IHNwYWNlLndpZGdldCkuZXZlcnkod2d0ID0+IHRoaXMuY2FuV2lkZ2V0TW92ZVJpZ2h0KHdndCkpKTtcblxuICAgICAgICBpZiAocGVyZm9ybU1vdmUgJiYgbW92ZWFibGUpIHtcblxuICAgICAgICAgICAgLy8gbW92ZSBhbGwgd2lkZ2V0cyB0byB0aGUgcmlnaHRcbiAgICAgICAgICAgIHRhcmdldFNwYWNlcy5mb3JFYWNoKHNwYWNlID0+IHRoaXMuZ2V0V2lkZ2V0c0F0UG9zaXRpb24oc3BhY2UuY29sdW1uLCBzcGFjZS5yb3cpLmZpbHRlcih3Z3QgPT4gd2d0ICE9PSBzcGFjZS53aWRnZXQpLmZvckVhY2god2d0ID0+IHRoaXMuY2FuV2lkZ2V0TW92ZVJpZ2h0KHdndCwgdHJ1ZSkpKTtcblxuICAgICAgICAgICAgLy8gbW92ZSBjdXJyZW50IHdpZGdldCB0byB0aGUgcmlnaHRcbiAgICAgICAgICAgIHdpZGdldC5zZXRDb2x1bW4od2lkZ2V0LmdldENvbHVtbigpICsgMSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbW92ZWFibGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RvcmUgdGhlIGluaXRpYWwgcG9zaXRpb24gb2YgdGhlIHdpZGdldCBiZWluZyBkcmFnZ2VkXG4gICAgICovXG4gICAgc2V0V2lkZ2V0T3JpZ2luKCk6IHZvaWQge1xuICAgICAgICB0aGlzLl93aWRnZXRPcmlnaW4gPSB7XG4gICAgICAgICAgICBjb2x1bW46IHRoaXMuX2FjdGlvbldpZGdldC53aWRnZXQuZ2V0Q29sdW1uKCksXG4gICAgICAgICAgICByb3c6IHRoaXMuX2FjdGlvbldpZGdldC53aWRnZXQuZ2V0Um93KCksXG4gICAgICAgICAgICBjb2x1bW5TcGFuOiB0aGlzLl9hY3Rpb25XaWRnZXQud2lkZ2V0LmdldENvbHVtblNwYW4oKSxcbiAgICAgICAgICAgIHJvd1NwYW46IHRoaXMuX2FjdGlvbldpZGdldC53aWRnZXQuZ2V0Um93U3BhbigpXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIGFsbCB0aGUgcmVxdWlyZWQgcG9zaXRpb25zIGlzIGEgd2lkZ2V0IHdhcyB0byBiZSBwb3NpdGlvbmVkIGF0IGEgcGFydGljdWxhciBwb2ludFxuICAgICAqL1xuICAgIGdldFJlcXVpcmVkU3BhY2VzRnJvbVBvaW50KHdpZGdldDogRGFzaGJvYXJkV2lkZ2V0Q29tcG9uZW50LCBjb2x1bW46IG51bWJlciwgcm93OiBudW1iZXIpOiBEYXNoYm9hcmRTcGFjZVtdIHtcbiAgICAgICAgY29uc3Qgc3BhY2VzOiBEYXNoYm9hcmRTcGFjZVtdID0gW107XG5cbiAgICAgICAgZm9yIChsZXQgeSA9IHJvdzsgeSA8IHJvdyArIHdpZGdldC5nZXRSb3dTcGFuKCk7IHkrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IGNvbHVtbjsgeCA8IGNvbHVtbiArIHdpZGdldC5nZXRDb2x1bW5TcGFuKCk7IHgrKykge1xuICAgICAgICAgICAgICAgIHNwYWNlcy5wdXNoKHsgY29sdW1uOiB4LCByb3c6IHksIHdpZGdldDogd2lkZ2V0IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNwYWNlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQb3NpdGlvbiB3aWRnZXRzIGJhc2VkIG9uIHRoZSBwb3NpdGlvbiBvZiB0aGUgcGxhY2Vob2xkZXIgLSB0aGlzIGlzIHRlbXBvcmFyeSB1bnRpbCBjb25maXJtZWRcbiAgICAgKi9cbiAgICB1cGRhdGVXaWRnZXRQb3NpdGlvbnMod2lkZ2V0OiBEYXNoYm9hcmRXaWRnZXRDb21wb25lbnQpIHtcblxuICAgICAgICBjb25zdCBwbGFjZWhvbGRlciA9IHRoaXMucGxhY2Vob2xkZXIkLmdldFZhbHVlKCk7XG5cbiAgICAgICAgLy8gY2hlY2sgYWxsIHNwYWNlcyB0aGUgcGxhY2Vob2xkZXIgd2lsbCBvY2N1cHkgYW5kIG1vdmUgYW55IHdpZGdldCBjdXJyZW50bHkgaW4gdGhlbSBkb3duXG4gICAgICAgIGZvciAobGV0IGNvbHVtbiA9IHBsYWNlaG9sZGVyLmNvbHVtbjsgY29sdW1uIDwgcGxhY2Vob2xkZXIuY29sdW1uICsgcGxhY2Vob2xkZXIuY29sdW1uU3BhbjsgY29sdW1uKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHJvdyA9IHBsYWNlaG9sZGVyLnJvdzsgcm93IDwgcGxhY2Vob2xkZXIucm93ICsgcGxhY2Vob2xkZXIucm93U3Bhbjsgcm93KyspIHtcblxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0V2lkZ2V0c0F0UG9zaXRpb24oY29sdW1uLCByb3csIHRydWUpXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIod2d0ID0+IHdndCAhPT0gd2lkZ2V0KVxuICAgICAgICAgICAgICAgICAgICAuZm9yRWFjaCh3Z3QgPT4gdGhpcy5tb3ZlV2lkZ2V0RG93bih3Z3QpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgaGVpZ2h0IG9mIHRoZSBkYXNoYm9hcmRcbiAgICAgICAgdGhpcy5zZXREYXNoYm9hcmRIZWlnaHQoKTtcblxuICAgICAgICAvLyBpZiB3ZSBhcmVudCBkcmFnZ2luZyB0aGUgdG9wIGhhbmRsZSB0aGVuIGZpbGwgc3BhY2VzXG4gICAgICAgIGlmICh0aGlzLl9hY3Rpb25XaWRnZXQuZGlyZWN0aW9uICE9PSBBY3Rpb25EaXJlY3Rpb24uVG9wICYmXG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25XaWRnZXQuZGlyZWN0aW9uICE9PSBBY3Rpb25EaXJlY3Rpb24uVG9wTGVmdCAmJlxuICAgICAgICAgICAgdGhpcy5fYWN0aW9uV2lkZ2V0LmRpcmVjdGlvbiAhPT0gQWN0aW9uRGlyZWN0aW9uLlRvcFJpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLnNoaWZ0V2lkZ2V0c1VwKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgaWYgYSB3aWRnZXQgaXMgb2NjdXB5aW5nIGEgc3BlY2lmaWMgcm93IGFuZCBjb2x1bW5cbiAgICAgKiBAcGFyYW0gY29sdW1uIFRoZSBjb2x1bW5zIHRvIGNoZWNrIGlmIG9jY3VwaWVkXG4gICAgICogQHBhcmFtIHJvdyBUaGUgcm93IHRvIGNoZWNrIGlmIG9jY3VwaWVkXG4gICAgICogQHBhcmFtIGlnbm9yZVJlc2l6aW5nIFdoZXRoZXIgb3Igbm90IHRvIGlnbm9yZSB0aGUgd2lkZ2V0IGN1cnJlbnRseSBiZWluZyByZXNpemVkXG4gICAgICovXG4gICAgZ2V0V2lkZ2V0c0F0UG9zaXRpb24oY29sdW1uOiBudW1iZXIsIHJvdzogbnVtYmVyLCBpZ25vcmVSZXNpemluZzogYm9vbGVhbiA9IGZhbHNlKTogRGFzaGJvYXJkV2lkZ2V0Q29tcG9uZW50W10ge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRPY2N1cGllZFNwYWNlcygpXG4gICAgICAgICAgICAuZmlsdGVyKHNwYWNlID0+IHNwYWNlLmNvbHVtbiA9PT0gY29sdW1uICYmIHNwYWNlLnJvdyA9PT0gcm93KVxuICAgICAgICAgICAgLmZpbHRlcihzcGFjZSA9PiBzcGFjZS53aWRnZXQgIT09IHRoaXMuX2FjdGlvbldpZGdldC53aWRnZXQgfHwgIWlnbm9yZVJlc2l6aW5nKVxuICAgICAgICAgICAgLm1hcChzcGFjZSA9PiBzcGFjZS53aWRnZXQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgcGxhY2Vob2xkZXIgdmlzaWJpbGl0eSwgcG9zaXRpb24gYW5kIHNpemVcbiAgICAgKi9cbiAgICBzZXRQbGFjZWhvbGRlckJvdW5kcyh2aXNpYmxlOiBib29sZWFuLCB4OiBudW1iZXIsIHk6IG51bWJlciwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIpOiB2b2lkIHtcblxuICAgICAgICBjb25zdCBwbGFjZWhvbGRlciA9IHRoaXMucGxhY2Vob2xkZXIkLmdldFZhbHVlKCk7XG5cbiAgICAgICAgY29uc3Qgcm91bmRpbmcgPSB0aGlzLl9hY3Rpb25XaWRnZXQuZGlyZWN0aW9uID09PSBBY3Rpb25EaXJlY3Rpb24uTGVmdCB8fFxuICAgICAgICAgICAgdGhpcy5fYWN0aW9uV2lkZ2V0LmRpcmVjdGlvbiA9PT0gQWN0aW9uRGlyZWN0aW9uLlRvcCA/IFJvdW5kaW5nLlJvdW5kRG93bkJlbG93SGFsZiA6IFJvdW5kaW5nLlJvdW5kVXBPdmVySGFsZjtcblxuICAgICAgICBwbGFjZWhvbGRlci52aXNpYmxlID0gdmlzaWJsZTtcblxuICAgICAgICBwbGFjZWhvbGRlci5jb2x1bW4gPSB0aGlzLmdldFBsYWNlaG9sZGVyQ29sdW1uKHgsIHdpZHRoKTtcbiAgICAgICAgcGxhY2Vob2xkZXIucm93ID0gdGhpcy5nZXRQbGFjZWhvbGRlclJvdyh5LCBoZWlnaHQpO1xuICAgICAgICBwbGFjZWhvbGRlci5jb2x1bW5TcGFuID0gdGhpcy5nZXRQbGFjZWhvbGRlckNvbHVtblNwYW4od2lkdGgpO1xuICAgICAgICBwbGFjZWhvbGRlci5yb3dTcGFuID0gdGhpcy5nZXRQbGFjZWhvbGRlclJvd1NwYW4oaGVpZ2h0KTtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIG1heGltdW0gbnVtYmVyIG9mIHJvd3NcbiAgICAgICAgY29uc3Qgcm93Q291bnQgPSB0aGlzLndpZGdldHMuZmlsdGVyKHdpZGdldCA9PiB3aWRnZXQgIT09IHRoaXMuX2FjdGlvbldpZGdldC53aWRnZXQpXG4gICAgICAgICAgICAucmVkdWNlKChwcmV2aW91cywgd2lkZ2V0KSA9PiBNYXRoLm1heCh3aWRnZXQuZ2V0Um93KCkgKyB3aWRnZXQuZ2V0Um93U3BhbigpLCBwcmV2aW91cyksIDApO1xuXG4gICAgICAgIC8vIGNvbnN0cmFpbiBtYXhpbXVtIHBsYWNlaG9sZGVyIHJvd1xuICAgICAgICBwbGFjZWhvbGRlci5yb3cgPSBNYXRoLm1pbihwbGFjZWhvbGRlci5yb3csIHJvd0NvdW50KTtcblxuICAgICAgICBwbGFjZWhvbGRlci54ID0gKHBsYWNlaG9sZGVyLmNvbHVtbiAqIHRoaXMuZ2V0Q29sdW1uV2lkdGgoKSkgKyB0aGlzLm9wdGlvbnMucGFkZGluZztcbiAgICAgICAgcGxhY2Vob2xkZXIueSA9IChwbGFjZWhvbGRlci5yb3cgKiB0aGlzLl9yb3dIZWlnaHQpICsgdGhpcy5vcHRpb25zLnBhZGRpbmc7XG4gICAgICAgIHBsYWNlaG9sZGVyLndpZHRoID0gKHBsYWNlaG9sZGVyLmNvbHVtblNwYW4gKiB0aGlzLmdldENvbHVtbldpZHRoKCkpIC0gKHRoaXMub3B0aW9ucy5wYWRkaW5nICogMik7XG4gICAgICAgIHBsYWNlaG9sZGVyLmhlaWdodCA9IChwbGFjZWhvbGRlci5yb3dTcGFuICogdGhpcy5fcm93SGVpZ2h0KSAtICh0aGlzLm9wdGlvbnMucGFkZGluZyAqIDIpO1xuXG4gICAgICAgIC8vIHNldCB0aGUgdmFsdWVzIG9mIHRoZSB3aWRnZXQgdG8gbWF0Y2ggdGhlIHZhbHVlcyBvZiB0aGUgcGxhY2Vob2xkZXIgLSBob3dldmVyIGRvIG5vdCByZW5kZXIgdGhlIGNoYW5nZXNcbiAgICAgICAgdGhpcy5fYWN0aW9uV2lkZ2V0LndpZGdldC5zZXRDb2x1bW4ocGxhY2Vob2xkZXIuY29sdW1uLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuX2FjdGlvbldpZGdldC53aWRnZXQuc2V0Um93KHBsYWNlaG9sZGVyLnJvdywgZmFsc2UpO1xuICAgICAgICB0aGlzLl9hY3Rpb25XaWRnZXQud2lkZ2V0LnNldENvbHVtblNwYW4ocGxhY2Vob2xkZXIuY29sdW1uU3BhbiwgZmFsc2UpO1xuICAgICAgICB0aGlzLl9hY3Rpb25XaWRnZXQud2lkZ2V0LnNldFJvd1NwYW4ocGxhY2Vob2xkZXIucm93U3BhbiwgZmFsc2UpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgcGxhY2Vob2xkZXJcbiAgICAgICAgdGhpcy5wbGFjZWhvbGRlciQubmV4dChwbGFjZWhvbGRlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBwbGFjZWhvbGRlciBjb2x1bW4gcG9zaXRpb25cbiAgICAgKi9cbiAgICBnZXRQbGFjZWhvbGRlckNvbHVtbih4OiBudW1iZXIsIHdpZHRoOiBudW1iZXIpOiBudW1iZXIge1xuXG4gICAgICAgIGNvbnN0IGNvbHVtbiA9IHRoaXMuZ2V0Q29sdW1uRnJvbVB4KHgsIHRoaXMuX2FjdGlvbldpZGdldC5kaXJlY3Rpb24gPT09IEFjdGlvbkRpcmVjdGlvbi5Nb3ZlID8gUm91bmRpbmcuUm91bmRVcE92ZXJIYWxmIDogUm91bmRpbmcuUm91bmREb3duKTtcbiAgICAgICAgY29uc3QgY29sdW1uU3BhbiA9IE1hdGguZmxvb3Iod2lkdGggLyB0aGlzLmdldENvbHVtbldpZHRoKCkpO1xuICAgICAgICBjb25zdCB1cHBlckxpbWl0ID0gdGhpcy5nZXRDb2x1bW5Db3VudCgpIC0gY29sdW1uU3BhbjtcblxuICAgICAgICAvLyBpZiB3ZSBhcmVudCBkcmFnZ2luZyBsZWZ0IHRoZW4ganVzdCByZXR1cm4gdGhlIGNvbHVtblxuICAgICAgICBpZiAodGhpcy5fYWN0aW9uV2lkZ2V0LmRpcmVjdGlvbiAhPT0gQWN0aW9uRGlyZWN0aW9uLkxlZnQgJiZcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvbldpZGdldC5kaXJlY3Rpb24gIT09IEFjdGlvbkRpcmVjdGlvbi5Ub3BMZWZ0ICYmXG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25XaWRnZXQuZGlyZWN0aW9uICE9PSBBY3Rpb25EaXJlY3Rpb24uQm90dG9tTGVmdCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKGNvbHVtbiwgdXBwZXJMaW1pdCksIDApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2V0IGFueSBvdmVyZmxvd1xuICAgICAgICBjb25zdCBvdmVyZmxvdyA9IHdpZHRoICUgdGhpcy5nZXRDb2x1bW5XaWR0aCgpO1xuXG4gICAgICAgIHJldHVybiAoeCA8PSAwIHx8IG92ZXJmbG93ID09PSAwIHx8IGNvbHVtblNwYW4gPT09IDAgfHwgb3ZlcmZsb3cgPiAodGhpcy5nZXRDb2x1bW5XaWR0aCgpIC8gMikpID9cbiAgICAgICAgICAgIE1hdGgubWF4KE1hdGgubWluKGNvbHVtbiwgdXBwZXJMaW1pdCksIDApIDpcbiAgICAgICAgICAgIE1hdGgubWF4KE1hdGgubWluKGNvbHVtbiArIDEsIHVwcGVyTGltaXQpLCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGNvbHVtbiBzcGFuIG9mIHRoZSBwbGFjZWhvbGRlclxuICAgICAqL1xuICAgIGdldFBsYWNlaG9sZGVyQ29sdW1uU3Bhbih3aWR0aDogbnVtYmVyKTogbnVtYmVyIHtcblxuICAgICAgICBjb25zdCBjb2x1bW5TcGFuID0gdGhpcy5nZXRDb2x1bW5Gcm9tUHgod2lkdGgpO1xuXG4gICAgICAgIC8vIGlmIHdlIGFyZW50IGRyYWdnaW5nIHJpZ2h0IG9yIGxlZnQgdGhlbiBqdXN0IHJldHVybiB0aGUgY29sdW1uIHNwYW5cbiAgICAgICAgaWYgKHRoaXMuX2FjdGlvbldpZGdldC5kaXJlY3Rpb24gIT09IEFjdGlvbkRpcmVjdGlvbi5SaWdodCAmJlxuICAgICAgICAgICAgdGhpcy5fYWN0aW9uV2lkZ2V0LmRpcmVjdGlvbiAhPT0gQWN0aW9uRGlyZWN0aW9uLlRvcFJpZ2h0ICYmXG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25XaWRnZXQuZGlyZWN0aW9uICE9PSBBY3Rpb25EaXJlY3Rpb24uQm90dG9tUmlnaHQgJiZcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvbldpZGdldC5kaXJlY3Rpb24gIT09IEFjdGlvbkRpcmVjdGlvbi5MZWZ0ICYmXG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25XaWRnZXQuZGlyZWN0aW9uICE9PSBBY3Rpb25EaXJlY3Rpb24uVG9wTGVmdCAmJlxuICAgICAgICAgICAgdGhpcy5fYWN0aW9uV2lkZ2V0LmRpcmVjdGlvbiAhPT0gQWN0aW9uRGlyZWN0aW9uLkJvdHRvbUxlZnQpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heChjb2x1bW5TcGFuLCAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdldCB0aGUgY3VycmVudCBjb2x1bW4gc3BhbiBhbmQgYW55IG92ZXJmbG93XG4gICAgICAgIGNvbnN0IG92ZXJmbG93ID0gd2lkdGggJSB0aGlzLmdldENvbHVtbldpZHRoKCk7XG5cbiAgICAgICAgcmV0dXJuIChjb2x1bW5TcGFuID4gMCAmJiBvdmVyZmxvdyA+ICh0aGlzLmdldENvbHVtbldpZHRoKCkgLyAyKSkgPyBNYXRoLm1heChjb2x1bW5TcGFuICsgMSwgMSkgOiBNYXRoLm1heChjb2x1bW5TcGFuLCAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHJvdyBwb3NpdGlvbiBvZiB0aGUgcGxhY2Vob2xkZXJcbiAgICAgKi9cbiAgICBnZXRQbGFjZWhvbGRlclJvdyh5OiBudW1iZXIsIGhlaWdodDogbnVtYmVyKTogbnVtYmVyIHtcblxuICAgICAgICBjb25zdCByb3cgPSB0aGlzLmdldFJvd0Zyb21QeCh5LCB0aGlzLl9hY3Rpb25XaWRnZXQuZGlyZWN0aW9uID09PSBBY3Rpb25EaXJlY3Rpb24uTW92ZSA/IFJvdW5kaW5nLlJvdW5kVXBPdmVySGFsZiA6IFJvdW5kaW5nLlJvdW5kRG93bik7XG4gICAgICAgIGNvbnN0IHJvd1NwYW4gPSBNYXRoLmNlaWwoaGVpZ2h0IC8gdGhpcy5fcm93SGVpZ2h0KTtcblxuICAgICAgICAvLyBpZiB3ZSBhcmVudCBkcmFnZ2luZyB1cCB0aGVuIGp1c3QgcmV0dXJuIHRoZSByb3dcbiAgICAgICAgaWYgKHRoaXMuX2FjdGlvbldpZGdldC5kaXJlY3Rpb24gIT09IEFjdGlvbkRpcmVjdGlvbi5Ub3AgJiZcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvbldpZGdldC5kaXJlY3Rpb24gIT09IEFjdGlvbkRpcmVjdGlvbi5Ub3BMZWZ0ICYmXG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25XaWRnZXQuZGlyZWN0aW9uICE9PSBBY3Rpb25EaXJlY3Rpb24uVG9wUmlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heChyb3csIDApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2V0IGFueSBvdmVyZmxvd1xuICAgICAgICBsZXQgb3ZlcmZsb3cgPSBoZWlnaHQgPCB0aGlzLl9yb3dIZWlnaHQgPyAwIDogaGVpZ2h0ICUgdGhpcy5fcm93SGVpZ2h0O1xuXG4gICAgICAgIHJldHVybiAoeSA8PSAwIHx8IHJvd1NwYW4gPT09IDAgfHwgb3ZlcmZsb3cgPT09IDAgfHwgb3ZlcmZsb3cgPiAodGhpcy5fcm93SGVpZ2h0IC8gMikpID8gTWF0aC5tYXgocm93LCAwKSA6IE1hdGgubWF4KHJvdyArIDEsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcm93IHNwYW4gb2YgdGhlIHBsYWNlaG9sZGVyXG4gICAgICovXG4gICAgZ2V0UGxhY2Vob2xkZXJSb3dTcGFuKGhlaWdodDogbnVtYmVyKTogbnVtYmVyIHtcblxuICAgICAgICBjb25zdCByb3dTcGFuID0gdGhpcy5nZXRSb3dGcm9tUHgoaGVpZ2h0KTtcblxuICAgICAgICAvLyBpZiB3ZSBhcmVudCBkcmFnZ2luZyB1cCBvciBkb3duIHRoZW4ganVzdCByZXR1cm4gdGhlIGNvbHVtbiBzcGFuXG4gICAgICAgIGlmICh0aGlzLl9hY3Rpb25XaWRnZXQuZGlyZWN0aW9uICE9PSBBY3Rpb25EaXJlY3Rpb24uVG9wICYmXG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25XaWRnZXQuZGlyZWN0aW9uICE9PSBBY3Rpb25EaXJlY3Rpb24uVG9wTGVmdCAmJlxuICAgICAgICAgICAgdGhpcy5fYWN0aW9uV2lkZ2V0LmRpcmVjdGlvbiAhPT0gQWN0aW9uRGlyZWN0aW9uLlRvcFJpZ2h0ICYmXG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25XaWRnZXQuZGlyZWN0aW9uICE9PSBBY3Rpb25EaXJlY3Rpb24uQm90dG9tICYmXG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25XaWRnZXQuZGlyZWN0aW9uICE9PSBBY3Rpb25EaXJlY3Rpb24uQm90dG9tTGVmdCAmJlxuICAgICAgICAgICAgdGhpcy5fYWN0aW9uV2lkZ2V0LmRpcmVjdGlvbiAhPT0gQWN0aW9uRGlyZWN0aW9uLkJvdHRvbVJpZ2h0KSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgocm93U3BhbiwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgdGhlIGN1cnJlbnQgY29sdW1uIHNwYW4gYW5kIGFueSBvdmVyZmxvd1xuICAgICAgICBjb25zdCBvdmVyZmxvdyA9IGhlaWdodCAlIHRoaXMuX3Jvd0hlaWdodDtcblxuICAgICAgICByZXR1cm4gKG92ZXJmbG93ID4gKHRoaXMuX3Jvd0hlaWdodCAvIDIpKSA/IE1hdGgubWF4KHJvd1NwYW4gKyAxLCAxKSA6IE1hdGgubWF4KHJvd1NwYW4sIDEpO1xuICAgIH1cblxuICAgIGdldENvbHVtbkZyb21QeCh4OiBudW1iZXIsIHJvdW5kaW5nOiBSb3VuZGluZyA9IFJvdW5kaW5nLlJvdW5kRG93bik6IG51bWJlciB7XG5cbiAgICAgICAgY29uc3QgY29sdW1uID0gTWF0aC5mbG9vcih4IC8gTWF0aC5mbG9vcih0aGlzLmdldENvbHVtbldpZHRoKCkpKTtcbiAgICAgICAgY29uc3Qgb3ZlcmZsb3cgPSAoeCAlIE1hdGguZmxvb3IodGhpcy5nZXRDb2x1bW5XaWR0aCgpKSk7XG4gICAgICAgIGNvbnN0IGhhbGYgPSB0aGlzLmdldENvbHVtbldpZHRoKCkgLyAyO1xuXG4gICAgICAgIHN3aXRjaCAocm91bmRpbmcpIHtcblxuICAgICAgICAgICAgY2FzZSBSb3VuZGluZy5Sb3VuZERvd246XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbHVtbjtcblxuICAgICAgICAgICAgY2FzZSBSb3VuZGluZy5Sb3VuZERvd25CZWxvd0hhbGY6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG92ZXJmbG93IDwgaGFsZiA/IGNvbHVtbiA6IGNvbHVtbiArIDE7XG5cbiAgICAgICAgICAgIGNhc2UgUm91bmRpbmcuUm91bmRVcE92ZXJIYWxmOlxuICAgICAgICAgICAgICAgIHJldHVybiBvdmVyZmxvdyA+IGhhbGYgPyBjb2x1bW4gKyAxIDogY29sdW1uO1xuXG4gICAgICAgICAgICBjYXNlIFJvdW5kaW5nLlJvdW5kVXA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG92ZXJmbG93ID4gMCA/IGNvbHVtbiArIDEgOiBjb2x1bW47XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGdldFJvd0Zyb21QeCh5OiBudW1iZXIsIHJvdW5kaW5nOiBSb3VuZGluZyA9IFJvdW5kaW5nLlJvdW5kRG93bik6IG51bWJlciB7XG5cbiAgICAgICAgY29uc3Qgcm93ID0gTWF0aC5mbG9vcih5IC8gTWF0aC5mbG9vcih0aGlzLl9yb3dIZWlnaHQpKTtcbiAgICAgICAgY29uc3Qgb3ZlcmZsb3cgPSAoeSAlIE1hdGguZmxvb3IodGhpcy5fcm93SGVpZ2h0KSk7XG4gICAgICAgIGNvbnN0IGhhbGYgPSB0aGlzLl9yb3dIZWlnaHQgLyAyO1xuXG4gICAgICAgIHN3aXRjaCAocm91bmRpbmcpIHtcblxuICAgICAgICAgICAgY2FzZSBSb3VuZGluZy5Sb3VuZERvd246XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJvdztcblxuICAgICAgICAgICAgY2FzZSBSb3VuZGluZy5Sb3VuZERvd25CZWxvd0hhbGY6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG92ZXJmbG93IDwgaGFsZiA/IHJvdyA6IHJvdyArIDE7XG5cbiAgICAgICAgICAgIGNhc2UgUm91bmRpbmcuUm91bmRVcE92ZXJIYWxmOlxuICAgICAgICAgICAgICAgIHJldHVybiBvdmVyZmxvdyA+IGhhbGYgPyByb3cgKyAxIDogcm93O1xuXG4gICAgICAgICAgICBjYXNlIFJvdW5kaW5nLlJvdW5kVXA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG92ZXJmbG93ID4gMCA/IHJvdyArIDEgOiByb3c7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb21taXRXaWRnZXRDaGFuZ2VzKCk6IHZvaWQge1xuXG4gICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gdGhpcy5wbGFjZWhvbGRlciQuZ2V0VmFsdWUoKTtcblxuICAgICAgICAvLyBjaGVjayB0aGF0IHdlIGhhdmUgYWxsIHRoZSB2YWx1ZXMgd2UgbmVlZFxuICAgICAgICBpZiAocGxhY2Vob2xkZXIuY29sdW1uID09PSB1bmRlZmluZWQgfHwgcGxhY2Vob2xkZXIucm93ID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyLmNvbHVtblNwYW4gPT09IHVuZGVmaW5lZCB8fCBwbGFjZWhvbGRlci5yb3dTcGFuID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9hY3Rpb25XaWRnZXQpIHtcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvbldpZGdldC53aWRnZXQuc2V0Q29sdW1uKHBsYWNlaG9sZGVyLmNvbHVtbik7XG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25XaWRnZXQud2lkZ2V0LnNldFJvdyhwbGFjZWhvbGRlci5yb3cpO1xuICAgICAgICAgICAgdGhpcy5fYWN0aW9uV2lkZ2V0LndpZGdldC5zZXRDb2x1bW5TcGFuKHBsYWNlaG9sZGVyLmNvbHVtblNwYW4pO1xuICAgICAgICAgICAgdGhpcy5fYWN0aW9uV2lkZ2V0LndpZGdldC5zZXRSb3dTcGFuKHBsYWNlaG9sZGVyLnJvd1NwYW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVzZXQgYWxsIHBsYWNlaG9sZGVyIHZhbHVlc1xuICAgICAgICBwbGFjZWhvbGRlci5jb2x1bW4gPSB1bmRlZmluZWQ7XG4gICAgICAgIHBsYWNlaG9sZGVyLnJvdyA9IHVuZGVmaW5lZDtcbiAgICAgICAgcGxhY2Vob2xkZXIuY29sdW1uU3BhbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgcGxhY2Vob2xkZXIucm93U3BhbiA9IHVuZGVmaW5lZDtcblxuICAgICAgICAvLyBlbWl0IHRoZSBuZXcgcGxhY2Vob2xkZXIgdmFsdWVzXG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXIkLm5leHQocGxhY2Vob2xkZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCBjb2x1bW4gd2lkdGhcbiAgICAgKi9cbiAgICBnZXRDb2x1bW5XaWR0aCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcih0aGlzLmNvbHVtbldpZHRoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIG51bWJlciBvZiByb3dzIHBvcHVsYXRlZCB3aXRoIHdpZGdldHNcbiAgICAgKi9cbiAgICBnZXRSb3dDb3VudCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy53aWRnZXRzLnJlZHVjZSgocHJldmlvdXMsIHdpZGdldCkgPT4gTWF0aC5tYXgod2lkZ2V0LmdldFJvdygpICsgd2lkZ2V0LmdldFJvd1NwYW4oKSwgcHJldmlvdXMpLCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGhlaWdodCBvZiB0aGUgZGFzaGJvYXJkIGNvbnRhaW5lciBlbGVtZW50XG4gICAgICovXG4gICAgc2V0RGFzaGJvYXJkSGVpZ2h0KCk6IHZvaWQge1xuXG4gICAgICAgIC8vIHNpemUgdGhlIGRhc2hib2FyZCBjb250YWluZXIgdG8gZW5zdXJlIGFsbCByb3dzIGZpdFxuICAgICAgICBsZXQgcm93Q291bnQgPSB0aGlzLmdldFJvd0NvdW50KCk7XG5cbiAgICAgICAgLy8gaWYgd2Ugc2hvdWxkIHNob3cgYW4gZW1wdHkgcm93IGluY3JlbWVudCB0aGUgcm93IGNvdW50IGJ5IDFcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lbXB0eVJvdykge1xuICAgICAgICAgICAgcm93Q291bnQrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0RGltZW5zaW9ucyh1bmRlZmluZWQsIHJvd0NvdW50ICogdGhpcy5fcm93SGVpZ2h0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPcmRlcnMgdGhlIHotaW5kZXggb2YgYWxsIHdpZGdldHMgdG8gbW92ZSB0aGUgYWN0aXZlIG9uZSB0byB0aGUgZnJvbnRcbiAgICAgKiBAcGFyYW0gd2lkZ2V0IFRoZSB3aWRnZXQgdGhhdCBzaG91bGQgYmUgYnJvdWdodCB0byB0aGUgZnJvbnRcbiAgICAgKi9cbiAgICBicmluZ1RvRnJvbnQod2lkZ2V0OiBEYXNoYm9hcmRXaWRnZXRDb21wb25lbnQpOiB2b2lkIHtcbiAgICAgICAgdGhpcy53aWRnZXRzLmZvckVhY2goX3dpZGdldCA9PiBfd2lkZ2V0ID09PSB3aWRnZXQgPyBfd2lkZ2V0LmJyaW5nVG9Gcm9udCgpIDogX3dpZGdldC5zZW5kVG9CYWNrKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vdmUgYSB3aWRnZXQgZG93biAtIGlmIHdpZGdldHMgYXJlIGluIHRoZSBwb3NpdGlvbiBiZWxvdywgdGhlbiBtb3ZlIHRoZW0gZG93biBmdXJ0aGVyXG4gICAgICogQHBhcmFtIHdpZGdldCBUaGUgd2lkZ2V0IHRvIG1vdmUgZG93bndhcmRzXG4gICAgICovXG4gICAgbW92ZVdpZGdldERvd24od2lkZ2V0OiBEYXNoYm9hcmRXaWRnZXRDb21wb25lbnQsIGRpc3RhbmNlOiBudW1iZXIgPSAxKTogdm9pZCB7XG5cbiAgICAgICAgLy8gbW92ZSB0aGUgd2lkZ2V0IGRvd24gb25lIHBvc2l0aW9uXG4gICAgICAgIHdpZGdldC5zZXRSb3cod2lkZ2V0LmdldFJvdygpICsgZGlzdGFuY2UpO1xuXG4gICAgICAgIC8vIGNoZWNrIGV2ZXJ5IHNwYWNlIHRoZSB3aWRnZXQgb2NjdXBpZXMgZm9yIGNvbGxpc2lvbnNcbiAgICAgICAgdGhpcy5mb3JFYWNoQmxvY2sod2lkZ2V0LCAoY29sdW1uLCByb3cpID0+XG4gICAgICAgICAgICB0aGlzLmdldFdpZGdldHNBdFBvc2l0aW9uKGNvbHVtbiwgcm93LCB0cnVlKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIod2d0ID0+IHdndCAhPT0gd2lkZ2V0KVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKHdndCA9PiB0aGlzLm1vdmVXaWRnZXREb3duKHdndCwgZGlzdGFuY2UpKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2lkZ2V0cyBzaG91bGQgbm90IGJlIGFsbG93ZWQgdG8gaGF2ZSBhIHZhY2FudCBzcGFjZSBhYm92ZSB0aGVtIC0gaWYgdGhlcmUgaXMgb25lIHRoZXkgc2hvdWxkIG1vdmUgdXB3YXJkcyB0byBmaWxsIGl0XG4gICAgICovXG4gICAgc2hpZnRXaWRnZXRzVXAoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gY2hlY2sgd2hldGhlciBvciBub3QgY2hhbmdlcyBoYXZlIGJlZW4gbWFkZSAtIGlmIHNvIHdlIG5lZWQgdG8gcmVwZWF0IHVudGlsIHN0YWJsZVxuICAgICAgICBsZXQgc3RhYmxlID0gdHJ1ZTtcblxuICAgICAgICAvLyBpdGVyYXRlIGVhY2ggd2lkZ2V0IGFuZFxuICAgICAgICB0aGlzLndpZGdldHMuZm9yRWFjaCh3aWRnZXQgPT4ge1xuXG4gICAgICAgICAgICAvLyBpZiB3aWRnZXQgaXMgYWxyZWFkeSBvbiB0aGUgdG9wIHJvdyB0aGVuIGRvIG5vdGhpbmdcbiAgICAgICAgICAgIGlmICh3aWRnZXQuZ2V0Um93KCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHdlIGFyZSBjdXJyZW50bHkgZHJhZ2dpbmcgYW5kIHRoaXMgaXMgdGhlIGRyYWdnaW5nIHdpZGdldCB0aGVuIHNraXBcbiAgICAgICAgICAgIGlmICh0aGlzLl9hY3Rpb25XaWRnZXQgJiYgdGhpcy5fYWN0aW9uV2lkZ2V0LndpZGdldCA9PT0gd2lkZ2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5nZXRQb3NpdGlvbkF2YWlsYWJsZSh3aWRnZXQuZ2V0Q29sdW1uKCksIHdpZGdldC5nZXRSb3coKSAtIDEsIHdpZGdldC5nZXRDb2x1bW5TcGFuKCksIDEpKSB7XG4gICAgICAgICAgICAgICAgd2lkZ2V0LnNldFJvdyh3aWRnZXQuZ2V0Um93KCkgLSAxKTtcbiAgICAgICAgICAgICAgICBzdGFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gaWYgY2hhbmdlcyBvY2N1cnJlZCB0aGVuIHdlIHNob3VsZCByZXBlYXQgdGhlIHByb2Nlc3NcbiAgICAgICAgaWYgKCFzdGFibGUpIHtcbiAgICAgICAgICAgIHRoaXMuc2hpZnRXaWRnZXRzVXAoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGUgb3ZlciBlYWNoIHNwYWNlIGEgd2lkZ2V0IG9jY3VwaWVkXG4gICAgICogQHBhcmFtIHdpZGdldCBUaGUgd2lkZ2V0IHRvIGRldGVybWluZSBzcGFjZXNcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBmb3IgZWFjaCBzcGFjZSwgc2hvdWxkIGV4cGVjdCBhIGNvbHVtbiBhbmQgcm93IGFyZ3VtZW50IHdpdGh0IGhlIGNvbnRleHQgYmVpbmcgdGhlIHdpZGdldFxuICAgICAqL1xuICAgIGZvckVhY2hCbG9jayh3aWRnZXQ6IERhc2hib2FyZFdpZGdldENvbXBvbmVudCwgY2FsbGJhY2s6IChjb2x1bW46IG51bWJlciwgcm93OiBudW1iZXIpID0+IHZvaWQpOiB2b2lkIHtcbiAgICAgICAgZm9yIChsZXQgcm93ID0gd2lkZ2V0LmdldFJvdygpOyByb3cgPCB3aWRnZXQuZ2V0Um93KCkgKyB3aWRnZXQuZ2V0Um93U3BhbigpOyByb3crKykge1xuICAgICAgICAgICAgZm9yIChsZXQgY29sdW1uID0gd2lkZ2V0LmdldENvbHVtbigpOyBjb2x1bW4gPCB3aWRnZXQuZ2V0Q29sdW1uKCkgKyB3aWRnZXQuZ2V0Q29sdW1uU3BhbigpOyBjb2x1bW4rKykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwod2lkZ2V0LCBjb2x1bW4sIHJvdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgY29sdW1ucyBhdmFpbGFibGVcbiAgICAgKi9cbiAgICBnZXRDb2x1bW5Db3VudCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFja2VkID8gMSA6IHRoaXMub3B0aW9ucy5jb2x1bW5zO1xuICAgIH1cbn1cblxuZXhwb3J0IGNvbnN0IGRlZmF1bHRPcHRpb25zOiBEYXNoYm9hcmRPcHRpb25zID0geyBjb2x1bW5zOiA1LCBwYWRkaW5nOiA1LCBtaW5XaWR0aDogMTAwLCBtaW5IZWlnaHQ6IDEwMCwgZW1wdHlSb3c6IHRydWUgfTtcblxuZXhwb3J0IGludGVyZmFjZSBEYXNoYm9hcmREaW1lbnNpb25zIHtcbiAgICB3aWR0aD86IG51bWJlcjtcbiAgICBoZWlnaHQ/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGFzaGJvYXJkV2lkZ2V0RGltZW5zaW9ucyB7XG4gICAgeDogbnVtYmVyO1xuICAgIHk6IG51bWJlcjtcbiAgICB3aWR0aDogbnVtYmVyO1xuICAgIGhlaWdodDogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERhc2hib2FyZEFjdGlvbiB7XG4gICAgd2lkZ2V0OiBEYXNoYm9hcmRXaWRnZXRDb21wb25lbnQ7XG4gICAgZGlyZWN0aW9uOiBBY3Rpb25EaXJlY3Rpb247XG4gICAgZXZlbnQ6IE1vdXNlRXZlbnQ7XG4gICAgaGFuZGxlPzogSFRNTEVsZW1lbnQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGFzaGJvYXJkU3BhY2Uge1xuICAgIHdpZGdldDogRGFzaGJvYXJkV2lkZ2V0Q29tcG9uZW50O1xuICAgIGNvbHVtbjogbnVtYmVyO1xuICAgIHJvdzogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERhc2hib2FyZFBsYWNlaG9sZGVyIHtcbiAgICB2aXNpYmxlOiBib29sZWFuO1xuICAgIHg6IG51bWJlcjtcbiAgICB5OiBudW1iZXI7XG4gICAgd2lkdGg6IG51bWJlcjtcbiAgICBoZWlnaHQ6IG51bWJlcjtcbiAgICBjb2x1bW4/OiBudW1iZXI7XG4gICAgcm93PzogbnVtYmVyO1xuICAgIGNvbHVtblNwYW4/OiBudW1iZXI7XG4gICAgcm93U3Bhbj86IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEYXNoYm9hcmRDYWNoZSB7XG4gICAgaWQ6IHN0cmluZztcbiAgICBjb2x1bW46IG51bWJlcjtcbiAgICByb3c6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEYXNoYm9hcmRMYXlvdXREYXRhIHtcbiAgICBpZDogc3RyaW5nO1xuICAgIGNvbDogbnVtYmVyO1xuICAgIHJvdzogbnVtYmVyO1xuICAgIGNvbFNwYW46IG51bWJlcjtcbiAgICByb3dTcGFuOiBudW1iZXI7XG59XG5cbmV4cG9ydCBlbnVtIEFjdGlvbkRpcmVjdGlvbiB7XG4gICAgVG9wID0gMCxcbiAgICBUb3BSaWdodCA9IDEsXG4gICAgUmlnaHQgPSAyLFxuICAgIEJvdHRvbVJpZ2h0ID0gMyxcbiAgICBCb3R0b20gPSA0LFxuICAgIEJvdHRvbUxlZnQgPSA1LFxuICAgIExlZnQgPSA2LFxuICAgIFRvcExlZnQgPSA3LFxuICAgIE1vdmUgPSA4XG59XG5cbmV4cG9ydCBlbnVtIFJvdW5kaW5nIHtcbiAgICBSb3VuZERvd24sXG4gICAgUm91bmREb3duQmVsb3dIYWxmLFxuICAgIFJvdW5kVXAsXG4gICAgUm91bmRVcE92ZXJIYWxmXG59IiwiaW1wb3J0IHsgQWZ0ZXJWaWV3SW5pdCwgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENvbXBvbmVudCwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT3V0cHV0LCBWaWV3Q2hpbGQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFJlc2l6ZURpbWVuc2lvbnMgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL3Jlc2l6ZS9yZXNpemUuc2VydmljZSc7XG5pbXBvcnQgeyBEYXNoYm9hcmRMYXlvdXREYXRhLCBEYXNoYm9hcmRTZXJ2aWNlLCBkZWZhdWx0T3B0aW9ucyB9IGZyb20gJy4vZGFzaGJvYXJkLnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LWRhc2hib2FyZCcsXG4gICAgdGVtcGxhdGVVcmw6ICcuL2Rhc2hib2FyZC5jb21wb25lbnQuaHRtbCcsXG4gICAgcHJvdmlkZXJzOiBbRGFzaGJvYXJkU2VydmljZV0sXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgRGFzaGJvYXJkQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCB7XG5cbiAgICBASW5wdXQoKSBzZXQgbGF5b3V0KGxheW91dDogRGFzaGJvYXJkTGF5b3V0RGF0YVtdKSB7XG4gICAgICAgIGlmIChsYXlvdXQpIHtcbiAgICAgICAgICAgIHRoaXMuZGFzaGJvYXJkU2VydmljZS5sYXlvdXQkLm5leHQobGF5b3V0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIEBJbnB1dCgpIHNldCBvcHRpb25zKG9wdGlvbnM6IERhc2hib2FyZE9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5kYXNoYm9hcmRTZXJ2aWNlLm9wdGlvbnMkLm5leHQoeyAuLi5kZWZhdWx0T3B0aW9ucywgLi4ub3B0aW9ucyB9KTtcbiAgICB9XG5cbiAgICBAT3V0cHV0KCkgbGF5b3V0Q2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxEYXNoYm9hcmRMYXlvdXREYXRhW10+KCk7XG5cbiAgICBAVmlld0NoaWxkKCdkYXNoYm9hcmQnKSBkYXNoYm9hcmRFbGVtZW50OiBFbGVtZW50UmVmO1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGRhc2hib2FyZFNlcnZpY2U6IERhc2hib2FyZFNlcnZpY2UpIHtcbiAgICAgICAgZGFzaGJvYXJkU2VydmljZS5sYXlvdXQkLnN1YnNjcmliZShsYXlvdXQgPT4gdGhpcy5sYXlvdXRDaGFuZ2UuZW1pdChsYXlvdXQpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGluaXRpYWwgZGltZW5zaW9uc1xuICAgICAqL1xuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5kYXNoYm9hcmRTZXJ2aWNlLnNldERpbWVuc2lvbnModGhpcy5kYXNoYm9hcmRFbGVtZW50Lm5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGgsIHRoaXMuZGFzaGJvYXJkRWxlbWVudC5uYXRpdmVFbGVtZW50Lm9mZnNldEhlaWdodCk7XG4gICAgfVxuXG4gICAgb25SZXNpemUoZXZlbnQ6IFJlc2l6ZURpbWVuc2lvbnMpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5kYXNoYm9hcmRTZXJ2aWNlLnNldERpbWVuc2lvbnMoZXZlbnQud2lkdGgsIGV2ZW50LmhlaWdodCk7XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIERhc2hib2FyZE9wdGlvbnMge1xuICAgIGNvbHVtbnM/OiBudW1iZXI7XG4gICAgcGFkZGluZz86IG51bWJlcjtcbiAgICBtaW5XaWR0aD86IG51bWJlcjtcbiAgICBtaW5IZWlnaHQ/OiBudW1iZXI7XG4gICAgcm93SGVpZ2h0PzogbnVtYmVyO1xuICAgIGVtcHR5Um93PzogYm9vbGVhbjtcbn0iLCJpbXBvcnQgeyBDb21wb25lbnQsIElucHV0LCBPbkluaXQsIE9uRGVzdHJveSwgSG9zdEJpbmRpbmcsIEFmdGVyVmlld0luaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IERhc2hib2FyZFNlcnZpY2UsIEFjdGlvbkRpcmVjdGlvbiB9IGZyb20gJy4uL2Rhc2hib2FyZC5zZXJ2aWNlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1kYXNoYm9hcmQtd2lkZ2V0JyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vZGFzaGJvYXJkLXdpZGdldC5jb21wb25lbnQuaHRtbCdcbn0pXG5leHBvcnQgY2xhc3MgRGFzaGJvYXJkV2lkZ2V0Q29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBBZnRlclZpZXdJbml0LCBPbkRlc3Ryb3kge1xuXG4gICAgQElucHV0KCkgaWQ6IHN0cmluZztcbiAgICBASW5wdXQoKSBjb2w6IG51bWJlcjtcbiAgICBASW5wdXQoKSByb3c6IG51bWJlcjtcbiAgICBASW5wdXQoKSBjb2xTcGFuOiBudW1iZXIgPSAxO1xuICAgIEBJbnB1dCgpIHJvd1NwYW46IG51bWJlciA9IDE7XG4gICAgQElucHV0KCkgcmVzaXphYmxlOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBASG9zdEJpbmRpbmcoJ3N0eWxlLmxlZnQucHgnKSB4OiBudW1iZXIgPSAwO1xuICAgIEBIb3N0QmluZGluZygnc3R5bGUudG9wLnB4JykgeTogbnVtYmVyID0gMDtcbiAgICBASG9zdEJpbmRpbmcoJ3N0eWxlLndpZHRoLnB4Jykgd2lkdGg6IG51bWJlciA9IDEwMDtcbiAgICBASG9zdEJpbmRpbmcoJ3N0eWxlLmhlaWdodC5weCcpIGhlaWdodDogbnVtYmVyID0gMTAwO1xuICAgIEBIb3N0QmluZGluZygnc3R5bGUucGFkZGluZy5weCcpIHBhZGRpbmc6IG51bWJlciA9IDA7XG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS56LWluZGV4JykgekluZGV4OiBudW1iZXIgPSAwO1xuXG4gICAgcHJpdmF0ZSBfY29sdW1uOiBTdGFja2FibGVWYWx1ZSA9IHsgcmVndWxhcjogdW5kZWZpbmVkLCBzdGFja2VkOiB1bmRlZmluZWQgfTtcbiAgICBwcml2YXRlIF9yb3c6IFN0YWNrYWJsZVZhbHVlID0geyByZWd1bGFyOiB1bmRlZmluZWQsIHN0YWNrZWQ6IHVuZGVmaW5lZCB9O1xuICAgIHByaXZhdGUgX2NvbHVtblNwYW46IFN0YWNrYWJsZVZhbHVlID0geyByZWd1bGFyOiAxLCBzdGFja2VkOiAxIH07XG4gICAgcHJpdmF0ZSBfcm93U3BhbjogU3RhY2thYmxlVmFsdWUgPSB7IHJlZ3VsYXI6IDEsIHN0YWNrZWQ6IDEgfTtcbiAgICBwcml2YXRlIF9zdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBkYXNoYm9hcmRTZXJ2aWNlOiBEYXNoYm9hcmRTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IGRhc2hib2FyZFNlcnZpY2Uub3B0aW9ucyQuc3Vic2NyaWJlKCgpID0+IHRoaXMudXBkYXRlKCkpO1xuICAgIH1cblxuICAgIG5nT25Jbml0KCk6IHZvaWQge1xuXG4gICAgICAgIHRoaXMuX2NvbHVtblNwYW4ucmVndWxhciA9IHRoaXMuY29sU3BhbjtcbiAgICAgICAgdGhpcy5fcm93U3Bhbi5yZWd1bGFyID0gdGhpcy5yb3dTcGFuO1xuXG4gICAgICAgIGlmICghdGhpcy5pZCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdEYXNoYm9hcmQgV2lkZ2V0IGlzIG1pc3NpbmcgYW4gSUQuJyk7XG5cbiAgICAgICAgICAgIC8vIHNldCByYW5kb20gaWQgLSBrZWVwcyB0aGluZ3Mgd29ya2luZyBidXQgcHJldmVudHMgZXhwb3J0aW5nIG9mIHBvc2l0aW9uc1xuICAgICAgICAgICAgdGhpcy5pZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwMCkudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkIHtcbiAgICAgICAgLy8gYWRkIHRoZSB3aWRnZXQgdG8gdGhlIGRhc2hib2FyZFxuICAgICAgICB0aGlzLmRhc2hib2FyZFNlcnZpY2UuYWRkV2lkZ2V0KHRoaXMpO1xuXG4gICAgICAgIC8vIGFwcGx5IHRoZSBjdXJyZW50IG9wdGlvbnNcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZiBjb21wb25lbnQgaXMgcmVtb3ZlZCwgdGhlbiB1bnJlZ2lzdGVyIGl0IGZyb20gdGhlIHNlcnZpY2VcbiAgICAgKi9cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuZGFzaGJvYXJkU2VydmljZS5yZW1vdmVXaWRnZXQodGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhlIGN1cnJlbnQgZGFzaGJvYXJkIG9wdGlvbnNcbiAgICAgKi9cbiAgICB1cGRhdGUoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBjdXJyZW50IG9wdGlvbnMgYXQgdGhlIHRpbWUgXG4gICAgICAgIGNvbnN0IHsgcGFkZGluZywgY29sdW1ucyB9ID0gdGhpcy5kYXNoYm9hcmRTZXJ2aWNlLm9wdGlvbnM7XG5cbiAgICAgICAgdGhpcy5wYWRkaW5nID0gcGFkZGluZztcbiAgICAgICAgdGhpcy5fY29sdW1uU3Bhbi5zdGFja2VkID0gY29sdW1ucztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGFjdHVhbCBwb3NpdGlvbiBhbmQgc2l6ZSB2YWx1ZXNcbiAgICAgKi9cbiAgICByZW5kZXIoKTogdm9pZCB7XG4gICAgICAgIHRoaXMueCA9IHRoaXMuZ2V0Q29sdW1uKCkgKiB0aGlzLmRhc2hib2FyZFNlcnZpY2UuZ2V0Q29sdW1uV2lkdGgoKTtcbiAgICAgICAgdGhpcy55ID0gdGhpcy5nZXRSb3coKSAqIHRoaXMuZGFzaGJvYXJkU2VydmljZS5nZXRSb3dIZWlnaHQoKTtcbiAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMuZ2V0Q29sdW1uU3BhbigpICogdGhpcy5kYXNoYm9hcmRTZXJ2aWNlLmdldENvbHVtbldpZHRoKCk7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5nZXRSb3dTcGFuKCkgKiB0aGlzLmRhc2hib2FyZFNlcnZpY2UuZ2V0Um93SGVpZ2h0KCk7XG4gICAgfVxuXG4gICAgZ2V0Q29sdW1uKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFN0YWNrYWJsZVZhbHVlKHRoaXMuX2NvbHVtbik7XG4gICAgfVxuXG4gICAgZ2V0Um93KCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFN0YWNrYWJsZVZhbHVlKHRoaXMuX3Jvdyk7XG4gICAgfVxuXG4gICAgc2V0Q29sdW1uKGNvbHVtbjogbnVtYmVyLCByZW5kZXI6IGJvb2xlYW4gPSB0cnVlKTogdm9pZCB7XG4gICAgICAgIHRoaXMuc2V0U3RhY2thYmxlVmFsdWUodGhpcy5fY29sdW1uLCBjb2x1bW4pO1xuXG4gICAgICAgIGlmIChyZW5kZXIpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRSb3cocm93OiBudW1iZXIsIHJlbmRlcjogYm9vbGVhbiA9IHRydWUpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zZXRTdGFja2FibGVWYWx1ZSh0aGlzLl9yb3csIHJvdyk7XG5cbiAgICAgICAgaWYgKHJlbmRlcikge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldENvbHVtblNwYW4oKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RhY2thYmxlVmFsdWUodGhpcy5fY29sdW1uU3Bhbik7XG4gICAgfVxuXG4gICAgZ2V0Um93U3BhbigpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTdGFja2FibGVWYWx1ZSh0aGlzLl9yb3dTcGFuKTtcbiAgICB9XG5cbiAgICBzZXRDb2x1bW5TcGFuKGNvbHVtblNwYW46IG51bWJlciwgcmVuZGVyOiBib29sZWFuID0gdHJ1ZSk6IHZvaWQge1xuICAgICAgICB0aGlzLnNldFN0YWNrYWJsZVZhbHVlKHRoaXMuX2NvbHVtblNwYW4sIGNvbHVtblNwYW4pO1xuXG4gICAgICAgIGlmIChyZW5kZXIpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRSb3dTcGFuKHJvd1NwYW46IG51bWJlciwgcmVuZGVyOiBib29sZWFuID0gdHJ1ZSk6IHZvaWQge1xuICAgICAgICB0aGlzLnNldFN0YWNrYWJsZVZhbHVlKHRoaXMuX3Jvd1NwYW4sIHJvd1NwYW4pO1xuXG4gICAgICAgIGlmIChyZW5kZXIpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBicmluZ1RvRnJvbnQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuekluZGV4ID0gMTtcbiAgICB9XG5cbiAgICBzZW5kVG9CYWNrKCk6IHZvaWQge1xuICAgICAgICB0aGlzLnpJbmRleCA9IDA7XG4gICAgfVxuXG4gICAgc2V0Qm91bmRzKHg6IG51bWJlciwgeTogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcik6IHZvaWQge1xuICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICB0aGlzLnkgPSB5O1xuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH1cblxuICAgIGRyYWdzdGFydChoYW5kbGU6IEhUTUxFbGVtZW50LCBldmVudDogTW91c2VFdmVudCwgZGlyZWN0aW9uOiBBY3Rpb25EaXJlY3Rpb24pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5kYXNoYm9hcmRTZXJ2aWNlLm9uUmVzaXplU3RhcnQoeyB3aWRnZXQ6IHRoaXMsIGRpcmVjdGlvbjogZGlyZWN0aW9uLCBldmVudDogZXZlbnQsIGhhbmRsZTogaGFuZGxlIH0pO1xuICAgIH1cblxuICAgIGRyYWcoaGFuZGxlOiBIVE1MRWxlbWVudCwgZXZlbnQ6IE1vdXNlRXZlbnQsIGRpcmVjdGlvbjogQWN0aW9uRGlyZWN0aW9uKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZGFzaGJvYXJkU2VydmljZS5vblJlc2l6ZURyYWcoeyB3aWRnZXQ6IHRoaXMsIGRpcmVjdGlvbjogZGlyZWN0aW9uLCBldmVudDogZXZlbnQsIGhhbmRsZTogaGFuZGxlIH0pO1xuICAgIH1cblxuICAgIGRyYWdlbmQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZGFzaGJvYXJkU2VydmljZS5vblJlc2l6ZUVuZCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFsbG93cyBhdXRvbWF0aWMgc2V0dGluZyBvZiBzdGFja2FibGUgdmFsdWVcbiAgICAgKiBAcGFyYW0gcHJvcGVydHkgVGhlIGN1cnJlbnQgU3RhY2thYmxlVmFsdWUgb2JqZWN0XG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQgaW4gdGhlIGFwcHJvcHJpYXRlIGZpZWxkXG4gICAgICovXG4gICAgcHJpdmF0ZSBzZXRTdGFja2FibGVWYWx1ZShwcm9wZXJ0eTogU3RhY2thYmxlVmFsdWUsIHZhbHVlOiBudW1iZXIpOiB2b2lkIHtcblxuICAgICAgICBpZiAodGhpcy5kYXNoYm9hcmRTZXJ2aWNlLnN0YWNrZWQpIHtcbiAgICAgICAgICAgIHByb3BlcnR5LnN0YWNrZWQgPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb3BlcnR5LnJlZ3VsYXIgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgYXBwcm9wcmlhdGUgdmFsdWUgZnJvbSBhIHN0YWNrYWJsZSB2YWx1ZVxuICAgICAqIEBwYXJhbSBwcm9wZXJ0eSBUaGUgU3RhY2thYmxlIHZhbHVlIG9iamVjdFxuICAgICAqL1xuICAgIHByaXZhdGUgZ2V0U3RhY2thYmxlVmFsdWUocHJvcGVydHk6IFN0YWNrYWJsZVZhbHVlKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGFzaGJvYXJkU2VydmljZS5zdGFja2VkID8gcHJvcGVydHkuc3RhY2tlZCA6IHByb3BlcnR5LnJlZ3VsYXI7XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN0YWNrYWJsZVZhbHVlIHtcbiAgICByZWd1bGFyOiBudW1iZXI7XG4gICAgc3RhY2tlZDogbnVtYmVyO1xufSIsImltcG9ydCB7IEluamVjdGFibGUsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBEcmFnU2VydmljZSBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG5cbiAgICAvKiogRW1pdCB3aGVuIGRyYWdnaW5nIGJlZ2lucyAqL1xuICAgIG9uRHJhZ1N0YXJ0ID0gbmV3IFN1YmplY3Q8VXhEcmFnRXZlbnQ+KCk7XG5cbiAgICAvKiogRW1pdCB3aGVuIGRyYWdnaW5nIG1vdmVzICovXG4gICAgb25EcmFnID0gbmV3IFN1YmplY3Q8VXhEcmFnRXZlbnQ+KCk7XG5cbiAgICAvKiogRW1pdCB3aGVuIGRyYWdnaW5nIGVuZHMgKi9cbiAgICBvbkRyYWdFbmQgPSBuZXcgU3ViamVjdDxVeERyYWdFdmVudD4oKTtcblxuICAgIC8qKiBFbWl0IHdoZW4gdGhlIHVzZXIgaXMgZHJhZ2dpbmcgb3ZlciB0aGUgZHJvcCBhcmVhICovXG4gICAgb25Ecm9wRW50ZXIgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gICAgLyoqIEVtaXQgd2hlbiB0aGUgdXNlciBpcyBkcmFnZ2luZyBvdXQgb2YgdGhlIGRyb3AgYXJlYSAqL1xuICAgIG9uRHJvcExlYXZlID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICAgIC8qKiBFbWl0IHdoZW4gYSBkcm9wIG9jY3VycyAqL1xuICAgIG9uRHJvcCA9IG5ldyBTdWJqZWN0PGFueT4oKTtcblxuICAgIC8qKiBEZXN0cm95IGFsbCBvYnNlcnZhYmxlcyAqL1xuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLm9uRHJhZ1N0YXJ0LmNvbXBsZXRlKCk7XG4gICAgICAgIHRoaXMub25EcmFnLmNvbXBsZXRlKCk7XG4gICAgICAgIHRoaXMub25EcmFnRW5kLmNvbXBsZXRlKCk7XG4gICAgICAgIHRoaXMub25Ecm9wLmNvbXBsZXRlKCk7XG4gICAgICAgIHRoaXMub25Ecm9wRW50ZXIuY29tcGxldGUoKTtcbiAgICAgICAgdGhpcy5vbkRyb3BMZWF2ZS5jb21wbGV0ZSgpO1xuICAgIH1cblxufVxuXG5leHBvcnQgdHlwZSBVeERyYWdFdmVudCA9IHsgZ3JvdXA/OiBzdHJpbmcsIGV2ZW50PzogTW91c2VFdmVudCwgZGF0YT86IGFueSB9OyIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgTmdab25lLCBPbkRlc3Ryb3ksIE91dHB1dCwgUmVuZGVyZXIyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBmcm9tRXZlbnQgfSBmcm9tICdyeGpzL29ic2VydmFibGUvZnJvbUV2ZW50JztcbmltcG9ydCB7IGZpbHRlciwgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XG5pbXBvcnQgeyBEcmFnU2VydmljZSB9IGZyb20gJy4vZHJhZy5zZXJ2aWNlJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbdXhEcmFnXSdcbn0pXG5leHBvcnQgY2xhc3MgRHJhZ0RpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG5cbiAgICAvKiogRGV0ZW1pbmUgaWYgd2Ugc2hvdWxkIHNob3cgYSBjbG9uZSB3aGVuIGRyYWdnaW5nICovXG4gICAgQElucHV0KCkgY2xvbmU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKiBEZWZpbmUgdGhlIGdyb3VwIHRoZSBkcmFnIGV2ZW50IGJlbG9uZ3MgdG8gKi9cbiAgICBASW5wdXQoKSBncm91cDogc3RyaW5nO1xuXG4gICAgLyoqIEFzc29jaWF0ZSBzb21lIGRhdGEgd2l0aCB0aGUgZHJhZyBldmVudCAqL1xuICAgIEBJbnB1dCgpIG1vZGVsOiBhbnk7XG5cbiAgICAvKiogQWxsb3cgdGhlIGRyYWdnaW5nIHRvIGJlIGVuYWJsZWQvZGlzYWJsZWQgKi9cbiAgICBASW5wdXQoKSBkcmFnZ2FibGU6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgLyoqIEVtaXQgYW4gZXZlbnQgd2hlbiBkcmFnZ2luZyBzdGFydHMgKi9cbiAgICBAT3V0cHV0KCkgb25EcmFnU3RhcnQgPSBuZXcgRXZlbnRFbWl0dGVyPE1vdXNlRXZlbnQ+KCk7XG5cbiAgICAvKiogRW1pdCBhbiBldmVudCB3aGVuIHRoZSBtb3VzZSBtb3ZlcyB3aGlsZSBkcmFnZ2luZyAqL1xuICAgIEBPdXRwdXQoKSBvbkRyYWcgPSBuZXcgRXZlbnRFbWl0dGVyPE1vdXNlRXZlbnQ+KCk7XG5cbiAgICAvKiogRW1pdCBhbiBldmVudCB3aGVuIHRoZSBkcmFnZ2luZyBmaW5pc2hlcyAqL1xuICAgIEBPdXRwdXQoKSBvbkRyYWdFbmQgPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG5cbiAgICAvKiogRW1pdCB3aGVuIHRoZSB1c2VyIGRyb3BzIGFuIGl0ZW0gaW4gYSBkcm9wIGFyZWEgKi9cbiAgICBAT3V0cHV0KCkgb25Ecm9wID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgICAvKiogRW1pdCB3aGVuIHRoZSB1c2VyIGRyYWdzIG92ZXIgYSBkcm9wIGFyZWEgKi9cbiAgICBAT3V0cHV0KCkgb25Ecm9wRW50ZXIgPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG5cbiAgICAvKiogRW1pdCB3aGVuIHRoZSB1c2VyIGRyYWdzIG91dCBvZiBhIGRyb3AgYXJlYSAqL1xuICAgIEBPdXRwdXQoKSBvbkRyb3BMZWF2ZSA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcblxuICAgIC8qKiBTdG9yZSB0aGUgZWxlbWVudCB3ZSBoYXZlIGNsb25lZCAqL1xuICAgIHByaXZhdGUgX2Nsb25lOiBFbGVtZW50O1xuXG4gICAgLyoqIFN0b3JlIHRoZSBkcmFnZ2luZyBzdGF0ZSAqL1xuICAgIHByaXZhdGUgX2lzRHJhZ2dpbmc6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKiBTdG9yZSB0aGUgbW91c2Ugb2Zmc2V0IGZvciB0aGUgY2xvbmVkIGVsZW1lbnQgcG9zaXRpb24gKi9cbiAgICBwcml2YXRlIF9vZmZzZXQ6IHsgeDogbnVtYmVyLCB5OiBudW1iZXIgfTtcblxuICAgIC8qKiBDcmVhdGUgYW4gb2JzZXJ2YWJsZSBmcm9tIHRoZSBtb3VzZSBkb3duIGV2ZW50ICovXG4gICAgcHJpdmF0ZSBfbW91c2Vkb3duJCA9IGZyb21FdmVudDxNb3VzZUV2ZW50Pih0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdtb3VzZWRvd24nKTtcblxuICAgIC8qKiBDcmVhdGUgYW4gb2JzZXJ2YWJsZSBmcm9tIHRoZSBtb3VzZSBtb3ZlIGV2ZW50ICovXG4gICAgcHJpdmF0ZSBfbW91c2Vtb3ZlJCA9IGZyb21FdmVudDxNb3VzZUV2ZW50Pihkb2N1bWVudCwgJ21vdXNlbW92ZScpO1xuXG4gICAgLyoqIENyZWF0ZSBhbiBvYnNlcnZhYmxlIGZyb20gdGhlIG1vdXNlIHVwIGV2ZW50ICovXG4gICAgcHJpdmF0ZSBfbW91c2V1cCQgPSBmcm9tRXZlbnQ8TW91c2VFdmVudD4oZG9jdW1lbnQsICdtb3VzZXVwJyk7XG5cbiAgICAvKiogVXNlIGFuIG9ic2VydmFibGUgdG8gdW5zdWJzY3JpYmUgZnJvbSBhbGwgc3Vic2NyaXB0aW9ucyAqL1xuICAgIHByb3RlY3RlZCBfb25EZXN0cm95ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIHByaXZhdGUgX25nWm9uZTogTmdab25lLCBwcml2YXRlIF9yZW5kZXJlcjogUmVuZGVyZXIyLCBwcml2YXRlIF9kcmFnOiBEcmFnU2VydmljZSkge1xuXG4gICAgICAgIC8vIGVuc3VyZSBhbGwgbW91c2UgZG93biBldmVudHMgb24gdGhlIG9iamVjdCBhcmUgY2FwdHVyZWRcbiAgICAgICAgdGhpcy5fbW91c2Vkb3duJC5waXBlKGZpbHRlcigoKSA9PiB0aGlzLmRyYWdnYWJsZSksIHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUodGhpcy5kcmFnU3RhcnQuYmluZCh0aGlzKSk7XG5cbiAgICAgICAgLy8gZW1pdCB0aGUgb3V0cHV0cyB3aGVuIGRyYWcgZXZlbnRzIG9jY3VyXG4gICAgICAgIF9kcmFnLm9uRHJhZ1N0YXJ0LnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSksIGZpbHRlcigoKSA9PiB0aGlzLl9pc0RyYWdnaW5nKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoZHJhZ0V2ZW50ID0+IHRoaXMub25EcmFnU3RhcnQuZW1pdChkcmFnRXZlbnQuZXZlbnQpKTtcblxuICAgICAgICBfZHJhZy5vbkRyYWcucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSwgZmlsdGVyKCgpID0+IHRoaXMuX2lzRHJhZ2dpbmcpKVxuICAgICAgICAgICAgLnN1YnNjcmliZShkcmFnRXZlbnQgPT4gdGhpcy5vbkRyYWcuZW1pdChkcmFnRXZlbnQuZXZlbnQpKTtcblxuICAgICAgICBfZHJhZy5vbkRyYWdFbmQucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSwgZmlsdGVyKCgpID0+IHRoaXMuX2lzRHJhZ2dpbmcpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLm9uRHJhZ0VuZC5lbWl0KCkpO1xuXG4gICAgICAgIF9kcmFnLm9uRHJvcC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpLCBmaWx0ZXIoKCkgPT4gdGhpcy5faXNEcmFnZ2luZykpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKGV2ZW50ID0+IHRoaXMub25Ecm9wLmVtaXQoZXZlbnQpKTtcblxuICAgICAgICBfZHJhZy5vbkRyb3BFbnRlci5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpLCBmaWx0ZXIoKCkgPT4gdGhpcy5faXNEcmFnZ2luZykpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMub25Ecm9wRW50ZXIuZW1pdCgpKTtcblxuICAgICAgICBfZHJhZy5vbkRyb3BMZWF2ZS5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpLCBmaWx0ZXIoKCkgPT4gdGhpcy5faXNEcmFnZ2luZykpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMub25Ecm9wTGVhdmUuZW1pdCgpKTtcbiAgICB9XG5cbiAgICAvKiogRW1pdCBldmVudHMgYW5kIGNyZWF0ZSBjbG9uZSB3aGVuIGRyYWcgc3RhcnRzICovXG4gICAgZHJhZ1N0YXJ0KGV2ZW50OiBNb3VzZUV2ZW50KTogdm9pZCB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgaWYgKHRoaXMuY2xvbmUpIHtcbiAgICAgICAgICAgIC8vIGNsb25lIHRoZSBub2RlXG4gICAgICAgICAgICB0aGlzLmNsb25lTm9kZShldmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhcHBseSBhIGNsYXNzIHRvIHRoZSBlbGVtZW50IGJlaW5nIGRyYWdnZWRcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAndXgtZHJhZy1kcmFnZ2luZycpO1xuXG4gICAgICAgIC8vIHN0b3JlIHRoZSBkcmFnZ2luZyBzdGF0ZVxuICAgICAgICB0aGlzLl9pc0RyYWdnaW5nID0gdHJ1ZTtcblxuICAgICAgICAvLyBlbWl0IHRoZSBkcmFnIHN0YXJ0IGV2ZW50XG4gICAgICAgIHRoaXMuX25nWm9uZS5ydW4oKCkgPT4gdGhpcy5fZHJhZy5vbkRyYWdTdGFydC5uZXh0KHsgZXZlbnQsIGdyb3VwOiB0aGlzLmdyb3VwLCBkYXRhOiB0aGlzLm1vZGVsIH0pKTtcblxuICAgICAgICB0aGlzLl9tb3VzZW1vdmUkLnBpcGUodGFrZVVudGlsKHRoaXMuX21vdXNldXAkKSwgdGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKHRoaXMuZHJhZ01vdmUuYmluZCh0aGlzKSwgbnVsbCwgdGhpcy5kcmFnRW5kLmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIC8qKiBFbWl0IGV2ZW50IGFuZCB1cGRhdGUgY2xvbmUgcG9zaXRpb24gd2hlbiBkcmFnZ2luZyBtb3ZlcyAqL1xuICAgIGRyYWdNb3ZlKGV2ZW50OiBNb3VzZUV2ZW50KTogdm9pZCB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2Nsb25lKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZU5vZGVQb3NpdGlvbihldmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBlbWl0IHRoZSBkcmFnIHN0YXJ0IGV2ZW50XG4gICAgICAgIHRoaXMuX25nWm9uZS5ydW4oKCkgPT4gdGhpcy5fZHJhZy5vbkRyYWcubmV4dCh7IGV2ZW50LCBncm91cDogdGhpcy5ncm91cCwgZGF0YTogdGhpcy5tb2RlbCB9KSk7XG4gICAgfVxuXG4gICAgLyoqIEVtaXQgZXZlbnQgYW5kIGRlc3Ryb3kgY2xvbmUgd2hlbiBkcmFnZ2luZyBlbmRzICovXG4gICAgZHJhZ0VuZCgpOiB2b2lkIHtcbiAgICAgICAgLy8gaWYgdGhlcmUgd2FzIGEgY2xvbmUsIHJlbW92ZSBpdFxuICAgICAgICBpZiAodGhpcy5fY2xvbmUpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnJlbW92ZUNoaWxkKGRvY3VtZW50LmJvZHksIHRoaXMuX2Nsb25lKTtcbiAgICAgICAgICAgIHRoaXMuX2Nsb25lID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbW92ZSB0aGUgZHJhZ2dpbmcgY2xhc3NcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIucmVtb3ZlQ2xhc3ModGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAndXgtZHJhZy1kcmFnZ2luZycpO1xuXG4gICAgICAgIC8vIGVtaXQgdGhlIG9uIGRyYWcgZW5kIG91dHB1dFxuICAgICAgICB0aGlzLl9uZ1pvbmUucnVuKCgpID0+IHRoaXMuX2RyYWcub25EcmFnRW5kLm5leHQoeyBncm91cDogdGhpcy5ncm91cCwgZGF0YTogdGhpcy5tb2RlbCB9KSk7XG5cbiAgICAgICAgLy8gc3RvcmUgdGhlIGRyYWdnaW5nIHN0YXRlXG4gICAgICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKiogQ3JlYXRlIGFuIGV4YWN0IGNsb25lIG9mIGFuIGVsZW1lbnQgKi9cbiAgICBjbG9uZU5vZGUoZXZlbnQ6IE1vdXNlRXZlbnQpOiB2b2lkIHtcblxuICAgICAgICAvLyBkdXBsaWNhdGUgdGhlIG5vZGVcbiAgICAgICAgdGhpcy5fY2xvbmUgPSB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuY2xvbmVOb2RlKHRydWUpO1xuXG4gICAgICAgIC8vIHN0b3JlIHRoZSBwb3NpdGlvbiB3aXRoaW4gdGhlIGRyYWdnYWJsZSBlbGVtZW50XG4gICAgICAgIGNvbnN0IHsgdG9wLCBsZWZ0LCB3aWR0aCB9ID0gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB0aGlzLl9vZmZzZXQgPSB7IHg6IGV2ZW50LmNsaWVudFggLSBsZWZ0LCB5OiBldmVudC5jbGllbnRZIC0gdG9wIH07XG5cbiAgICAgICAgLy8gaW5saW5lIGFsbCBzdHlsZXMgc28gaXQgbG9va3MgaWRlbnRpY2FsIHJlZ2FyZGxlc3Mgb2YgaXRzIHBvc2l0aW9uIGluIHRoZSBET01cbiAgICAgICAgdGhpcy5pbmxpbmVTdHlsZXModGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCB0aGlzLl9jbG9uZSk7XG5cbiAgICAgICAgLy8gSUUgZG9lc24ndCBhbHdheXMgY2FsY3VsYXRlIHRoZSBjb3JyZWN0IHdpZHRoIHZhbHVlIHVzaW5nIGdldENvbXB1dGVkU3R5bGVzLi4uIHVzZSBib3VuZGluZyBjbGllbnQgdmFsdWUgaW5zdGVhZFxuICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRTdHlsZSh0aGlzLl9jbG9uZSwgJ3dpZHRoJywgd2lkdGggKyAncHgnKTtcblxuICAgICAgICAvLyBlbnN1cmUgd2UgY2FuIGVhc2lseSBwb3NpdGlvbiB0aGUgbm9kZSBhbiBpdCBpcyBhYm92ZSBhbGwgb3RoZXIgZWxlbWVudHNcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0QXR0cmlidXRlKHRoaXMuX2Nsb25lLCAnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRTdHlsZSh0aGlzLl9jbG9uZSwgJ3Bvc2l0aW9uJywgJ2Fic29sdXRlJyk7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldFN0eWxlKHRoaXMuX2Nsb25lLCAnei1pbmRleCcsICc5OTk5OScpO1xuXG4gICAgICAgIC8vIGFwcGx5IGEgY2xhc3MgdG8gYWxsb3cgY3VzdG9tIHN0eWxpbmdcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5fY2xvbmUsICd1eC1kcmFnLWRyYWdnaW5nLWNsb25lJyk7XG5cbiAgICAgICAgLy8gaW5zZXJ0IHRoZSBjbG9uZWQgZWxlbWVudFxuICAgICAgICB0aGlzLl9yZW5kZXJlci5hcHBlbmRDaGlsZChkb2N1bWVudC5ib2R5LCB0aGlzLl9jbG9uZSk7XG5cbiAgICAgICAgLy8gc2V0IHRoZSBjbG9uZWQgZWxlbWVudCBpbml0aWFsIHBvc2l0aW9uXG4gICAgICAgIHRoaXMudXBkYXRlTm9kZVBvc2l0aW9uKGV2ZW50KTtcbiAgICB9XG5cbiAgICAvKiogUG9zaXRpb24gdGhlIGNsb25lIHJlbGF0aXZlIHRvIHRoZSBtb3VzZSAqL1xuICAgIHVwZGF0ZU5vZGVQb3NpdGlvbihldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5zZXRTdHlsZSh0aGlzLl9jbG9uZSwgJ2xlZnQnLCAoZXZlbnQucGFnZVggLSB0aGlzLl9vZmZzZXQueCkgKyAncHgnKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0U3R5bGUodGhpcy5fY2xvbmUsICd0b3AnLCAoZXZlbnQucGFnZVkgLSB0aGlzLl9vZmZzZXQueSkgKyAncHgnKTtcbiAgICB9XG5cbiAgICAvKiogSW5saW5lIGFsbCBzdHlsZXMgdG8gZW5zdXJlIHN0eWxpbmcgaXMgY29uc2lzdGVudCByZWdhcmRsZXNzIG9mIGl0cyBwb3NpdGlvbiBpbiB0aGUgZG9tICovXG4gICAgaW5saW5lU3R5bGVzKHNvdXJjZTogRWxlbWVudCwgdGFyZ2V0OiBFbGVtZW50KTogdm9pZCB7XG4gICAgICAgIC8vIGdldCBhbGwgdGhlIGNvbXB1dGVkIHN0eWxlcyBmcm9tIHRoZSBzb3VyY2UgZWxlbWVudFxuICAgICAgICBjb25zdCBzdHlsZXMgPSBnZXRDb21wdXRlZFN0eWxlKHNvdXJjZSk7XG5cbiAgICAgICAgLy8gaW5saW5lIGV2ZXJ5IHNwZWNpZmllZCBzdHlsZVxuICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBzdHlsZXMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgY29uc3Qgc3R5bGUgPSBzdHlsZXMuaXRlbShpZHgpO1xuXG4gICAgICAgICAgICBpZiAoc3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldFN0eWxlKHRhcmdldCwgc3R5bGVzW2lkeF0sIHN0eWxlc1tzdHlsZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZW5zdXJlIHdlIGRvbnQgY2FwdHVyZSBhbnkgbW92ZSBldmVudHNcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0U3R5bGUodGFyZ2V0LCAncG9pbnRlci1ldmVudHMnLCAnbm9uZScpO1xuXG4gICAgICAgIC8vIGRvIHRoZSBzYW1lIGZvciBhbGwgdGhlIGNoaWxkIGVsZW1lbnRzXG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHNvdXJjZS5jaGlsZHJlbi5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgICB0aGlzLmlubGluZVN0eWxlcyhzb3VyY2UuY2hpbGRyZW5baWR4XSwgdGFyZ2V0LmNoaWxkcmVuW2lkeF0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIFVuc3Vic2NyaWJlIGZyb20gYWxsIHN1YnNjcmlwdGlvbnMgKi9cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fb25EZXN0cm95Lm5leHQoKTtcbiAgICAgICAgdGhpcy5fb25EZXN0cm95LmNvbXBsZXRlKCk7XG4gICAgfVxufSIsImltcG9ydCB7IERpcmVjdGl2ZSwgRXZlbnRFbWl0dGVyLCBIb3N0TGlzdGVuZXIsIElucHV0LCBPbkRlc3Ryb3ksIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgZmlsdGVyLCB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcbmltcG9ydCB7IERyYWdTZXJ2aWNlLCBVeERyYWdFdmVudCB9IGZyb20gJy4vZHJhZy5zZXJ2aWNlJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbdXhEcm9wXScsXG4gICAgaG9zdDoge1xuICAgICAgICAnW2NsYXNzLnV4LWRyb3AtaG92ZXJdJzogJ2lzTW91c2VPdmVyICYmIGlzRHJhZ2dpbmcnXG4gICAgfVxufSlcbmV4cG9ydCBjbGFzcyBEcm9wRGlyZWN0aXZlIGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICAgIC8qKiBEZWZpbmUgYSBzcGVjaWZpYyBncm91cCBvZiBkcmFnZ2VkIGl0ZW1zIHRvIGxpc3RlbiB0byAqL1xuICAgIEBJbnB1dCgpIGdyb3VwOiBzdHJpbmcgfCBzdHJpbmdbXTtcblxuICAgIC8qKiBFbWl0IHRoZSBtb2RlbCBvZiB0aGUgaXRlbSBkcm9wcGVkICovXG4gICAgQE91dHB1dCgpIG9uRHJvcCA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gICAgLyoqIERldGVybWluZSB3aGV0aGVyIG9yIG5vdCB0aGUgbW91c2UgaXMgd2l0aGluIHRoZSBkcm9wIHJlZ2lvbiAqL1xuICAgIGlzTW91c2VPdmVyOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKiogRGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IHdlIGFyZSBjdXJyZW50bHkgZHJhZ2dpbmcgYW4gaXRlbSAqL1xuICAgIGlzRHJhZ2dpbmc6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qKiBTdG9yZSB0aGUgZ3JvdXAgb2YgdGhlIGRyYWdnZWQgaXRlbSAqL1xuICAgIHByaXZhdGUgX2dyb3VwOiBzdHJpbmc7XG5cbiAgICAvKiogRW5zdXJlIHdlIGRlc3Ryb3kgYWxsIHN1YnNjcmlwdGlvbnMgKi9cbiAgICBwcml2YXRlIF9vbkRlc3Ryb3kgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfZHJhZ1NlcnZpY2U6IERyYWdTZXJ2aWNlKSB7XG4gICAgICAgIC8vIHN1YnNjcmliZSB0byBkcmFnIGV2ZW50c1xuICAgICAgICBfZHJhZ1NlcnZpY2Uub25EcmFnU3RhcnQucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSwgZmlsdGVyKGV2ZW50ID0+IHRoaXMuaXNHcm91cEFsbG93ZWQoZXZlbnQuZ3JvdXApKSkuc3Vic2NyaWJlKHRoaXMub25EcmFnU3RhcnQuYmluZCh0aGlzKSk7XG4gICAgICAgIF9kcmFnU2VydmljZS5vbkRyYWdFbmQucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSwgZmlsdGVyKGV2ZW50ID0+IHRoaXMuaXNHcm91cEFsbG93ZWQoZXZlbnQuZ3JvdXApKSkuc3Vic2NyaWJlKHRoaXMub25EcmFnRW5kLmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kubmV4dCgpO1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kuY29tcGxldGUoKTtcbiAgICB9XG5cbiAgICAvKiogVXBkYXRlIHRoZSBtb3VzZSBvdmVyIHN0YXRlICovXG4gICAgQEhvc3RMaXN0ZW5lcignbW91c2VlbnRlcicpXG4gICAgb25Nb3VzZU92ZXIoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmlzR3JvdXBBbGxvd2VkKHRoaXMuX2dyb3VwKSkge1xuICAgICAgICAgICAgdGhpcy5pc01vdXNlT3ZlciA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIGVtaXQgdGhhdCB3ZSBhcmUgb3ZlciBhIGRyb3AgYXJlYVxuICAgICAgICAgICAgdGhpcy5fZHJhZ1NlcnZpY2Uub25Ecm9wRW50ZXIubmV4dCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIFVwZGF0ZSB0aGUgbW91c2Ugb3ZlciBzdGF0ZSAqL1xuICAgIEBIb3N0TGlzdGVuZXIoJ21vdXNlbGVhdmUnKVxuICAgIG9uTW91c2VMZWF2ZSgpOiB2b2lkIHtcblxuICAgICAgICAvLyBhbHdheXMgZW5zdXJlIHRoaXMgdmFsdWUgaXMgcmVzZXRcbiAgICAgICAgdGhpcy5pc01vdXNlT3ZlciA9IGZhbHNlO1xuXG4gICAgICAgIC8vIG9ubHkgZW1pdCB0aGUgZHJvcGQgbGVhdmUgZXZlbnQgd2hlbiBhcHByb3ByaWF0ZVxuICAgICAgICBpZiAodGhpcy5pc0dyb3VwQWxsb3dlZCh0aGlzLl9ncm91cCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2RyYWdTZXJ2aWNlLm9uRHJvcExlYXZlLm5leHQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBVcGRhdGUgdGhlIGRyYWdnaW5nIHN0YXRlICovXG4gICAgb25EcmFnU3RhcnQoZXZlbnQ6IFV4RHJhZ0V2ZW50KTogdm9pZCB7XG4gICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgIHRoaXMuX2dyb3VwID0gZXZlbnQuZ3JvdXA7XG4gICAgfVxuXG4gICAgLyoqIFVwZGF0ZSB0aGUgZHJhZ2dpbmcgc3RhdGUgKi9cbiAgICBvbkRyYWdFbmQoZXZlbnQ6IFV4RHJhZ0V2ZW50KTogdm9pZCB7XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBkcmFnZ2luZyBzdGF0ZVxuICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcblxuICAgICAgICAvLyBjbGVhciB0aGUgY2FjaGVkIGdyb3VwXG4gICAgICAgIHRoaXMuX2dyb3VwID0gbnVsbDtcblxuICAgICAgICAvLyBpZiB0aGUgbW91c2UgaXMgb3ZlciBhbmQgaXQgaXMgaW4gYW4gYWxsb3dlZCBncm91cCBlbWl0IHRoZSBkb3AgZXZlbnRcbiAgICAgICAgaWYgKHRoaXMuaXNNb3VzZU92ZXIgJiYgdGhpcy5pc0dyb3VwQWxsb3dlZChldmVudC5ncm91cCkpIHtcbiAgICAgICAgICAgIHRoaXMub25Ecm9wLmVtaXQoZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICB0aGlzLl9kcmFnU2VydmljZS5vbkRyb3AubmV4dChldmVudC5kYXRhKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBEZXRlcm1pbmUgd2hldGhlciBvciBub3QgdGhlIGV2ZW50IGlzIHBhcnQgb2YgdGhlIHNwZWNpZmllZCBncm91cHMgKi9cbiAgICBwcml2YXRlIGlzR3JvdXBBbGxvd2VkKGdyb3VwOiBzdHJpbmcpOiBib29sZWFuIHtcblxuICAgICAgICAvLyBpZiBubyBncm91cCBzcGVjaWZpZWQgYWxsb3cgYWxsIGdyb3Vwc1xuICAgICAgICBpZiAoIXRoaXMuZ3JvdXApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgaXQgaXMgYW4gYXJyYXkgdGhlbiBlbnN1cmUgaXQgaXMgYWxsb3dlZFxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLmdyb3VwKSkge1xuICAgICAgICAgICAgcmV0dXJuICEhdGhpcy5ncm91cC5maW5kKF9ncm91cCA9PiBfZ3JvdXAgPT09IGdyb3VwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmdyb3VwID09PSBncm91cDtcbiAgICB9XG59IiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IERyYWdEaXJlY3RpdmUgfSBmcm9tICcuL2RyYWcuZGlyZWN0aXZlJztcbmltcG9ydCB7IERyYWdTZXJ2aWNlIH0gZnJvbSAnLi9kcmFnLnNlcnZpY2UnO1xuaW1wb3J0IHsgRHJvcERpcmVjdGl2ZSB9IGZyb20gJy4vZHJvcC5kaXJlY3RpdmUnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGV4cG9ydHM6ICAgICAgW0RyYWdEaXJlY3RpdmUsIERyb3BEaXJlY3RpdmVdLFxuICAgIGRlY2xhcmF0aW9uczogW0RyYWdEaXJlY3RpdmUsIERyb3BEaXJlY3RpdmVdLFxuICAgIHByb3ZpZGVyczogICAgW0RyYWdTZXJ2aWNlXVxufSlcbmV4cG9ydCBjbGFzcyBEcmFnTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBOZ1pvbmUsIFJlbmRlcmVyMiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgRHJhZ0RpcmVjdGl2ZSB9IGZyb20gJy4uLy4uLy4uL2RpcmVjdGl2ZXMvZHJhZy9kcmFnLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBEcmFnU2VydmljZSB9IGZyb20gJy4uLy4uLy4uL2RpcmVjdGl2ZXMvZHJhZy9pbmRleCc7XG5pbXBvcnQgeyBBY3Rpb25EaXJlY3Rpb24sIERhc2hib2FyZFNlcnZpY2UgfSBmcm9tICcuLi9kYXNoYm9hcmQuc2VydmljZSc7XG5pbXBvcnQgeyBEYXNoYm9hcmRXaWRnZXRDb21wb25lbnQgfSBmcm9tICcuLi93aWRnZXQvZGFzaGJvYXJkLXdpZGdldC5jb21wb25lbnQnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1t1eERhc2hib2FyZFdpZGdldERyYWdIYW5kbGVdLCBbdXgtZGFzaGJvYXJkLXdpZGdldC1kcmFnLWhhbmRsZV0nXG59KVxuZXhwb3J0IGNsYXNzIERhc2hib2FyZERyYWdIYW5kbGVEaXJlY3RpdmUgZXh0ZW5kcyBEcmFnRGlyZWN0aXZlIHtcblxuICAgIGNvbnN0cnVjdG9yKHdpZGdldDogRGFzaGJvYXJkV2lkZ2V0Q29tcG9uZW50LCBkYXNoYm9hcmRTZXJ2aWNlOiBEYXNoYm9hcmRTZXJ2aWNlLCBlbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgICAgICBuZ1pvbmU6IE5nWm9uZSwgcmVuZGVyZXI6IFJlbmRlcmVyMiwgZHJhZzogRHJhZ1NlcnZpY2UpIHtcblxuICAgICAgICBzdXBlcihlbGVtZW50UmVmLCBuZ1pvbmUsIHJlbmRlcmVyLCBkcmFnKTtcblxuICAgICAgICB0aGlzLm9uRHJhZ1N0YXJ0LnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKChldmVudDogTW91c2VFdmVudCkgPT4gZGFzaGJvYXJkU2VydmljZS5vbkRyYWdTdGFydCh7IHdpZGdldDogd2lkZ2V0LCBkaXJlY3Rpb246IEFjdGlvbkRpcmVjdGlvbi5Nb3ZlLCBldmVudDogZXZlbnQgfSkpO1xuXG4gICAgICAgIHRoaXMub25EcmFnLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKChldmVudDogTW91c2VFdmVudCkgPT4gZGFzaGJvYXJkU2VydmljZS5vbkRyYWcoeyB3aWRnZXQ6IHdpZGdldCwgZGlyZWN0aW9uOiBBY3Rpb25EaXJlY3Rpb24uTW92ZSwgZXZlbnQ6IGV2ZW50IH0pKTtcblxuICAgICAgICB0aGlzLm9uRHJhZ0VuZC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiBkYXNoYm9hcmRTZXJ2aWNlLm9uRHJhZ0VuZCgpKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBEYXNoYm9hcmRDb21wb25lbnQgfSBmcm9tICcuL2Rhc2hib2FyZC5jb21wb25lbnQnO1xuaW1wb3J0IHsgRGFzaGJvYXJkV2lkZ2V0Q29tcG9uZW50IH0gZnJvbSAnLi93aWRnZXQvZGFzaGJvYXJkLXdpZGdldC5jb21wb25lbnQnO1xuaW1wb3J0IHsgRGFzaGJvYXJkU2VydmljZSB9IGZyb20gJy4vZGFzaGJvYXJkLnNlcnZpY2UnO1xuaW1wb3J0IHsgRGFzaGJvYXJkRHJhZ0hhbmRsZURpcmVjdGl2ZSB9IGZyb20gJy4vZHJhZy1oYW5kbGUvZHJhZy1oYW5kbGUuZGlyZWN0aXZlJztcbmltcG9ydCB7IFJlc2l6ZU1vZHVsZSB9IGZyb20gJy4uLy4uL2RpcmVjdGl2ZXMvcmVzaXplL2luZGV4JztcbmltcG9ydCB7IERyYWdNb2R1bGUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL2RyYWcvaW5kZXgnO1xuXG5jb25zdCBERUNMQVJBVElPTlM6IGFueVtdID0gW1xuICAgIERhc2hib2FyZENvbXBvbmVudCxcbiAgICBEYXNoYm9hcmRXaWRnZXRDb21wb25lbnQsXG4gICAgRGFzaGJvYXJkRHJhZ0hhbmRsZURpcmVjdGl2ZVxuXTtcblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgUmVzaXplTW9kdWxlLFxuICAgICAgICBEcmFnTW9kdWxlXG4gICAgXSxcbiAgICBleHBvcnRzOiBERUNMQVJBVElPTlMsXG4gICAgZGVjbGFyYXRpb25zOiBERUNMQVJBVElPTlMsXG4gICAgcHJvdmlkZXJzOiBbRGFzaGJvYXJkU2VydmljZV0sXG59KVxuZXhwb3J0IGNsYXNzIERhc2hib2FyZE1vZHVsZSB7IH1cbiIsImltcG9ydCB7IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE91dHB1dCwgVmlld0VuY2Fwc3VsYXRpb24sIGZvcndhcmRSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBOR19WQUxVRV9BQ0NFU1NPUiB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuZXhwb3J0IGNvbnN0IFNQSU5fQlVUVE9OX1ZBTFVFX0FDQ0VTU09SOiBhbnkgPSB7XG4gICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gU3BpbkJ1dHRvbkNvbXBvbmVudCksXG4gICAgbXVsdGk6IHRydWVcbn07XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtc3Bpbi1idXR0b24nLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9zcGluLWJ1dHRvbi5jb21wb25lbnQuaHRtbCcsXG4gICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICBwcm92aWRlcnM6IFtTUElOX0JVVFRPTl9WQUxVRV9BQ0NFU1NPUl1cbn0pXG5leHBvcnQgY2xhc3MgU3BpbkJ1dHRvbkNvbXBvbmVudCBpbXBsZW1lbnRzIENvbnRyb2xWYWx1ZUFjY2Vzc29yIHtcblxuICAgIEBJbnB1dCgpIHNldCB2YWx1ZSh2YWx1ZTogYW55KSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjayh2YWx1ZSk7XG4gICAgICAgIHRoaXMub25Ub3VjaGVkQ2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICBnZXQgdmFsdWUoKTogYW55IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgIH1cblxuICAgIEBJbnB1dCgpIHR5cGU6IHN0cmluZyA9ICd0ZXh0JztcbiAgICBASW5wdXQoKSBtaW46IG51bWJlcjtcbiAgICBASW5wdXQoKSBtYXg6IG51bWJlcjtcbiAgICBASW5wdXQoKSBwbGFjZWhvbGRlcjogc3RyaW5nID0gJyc7XG4gICAgQElucHV0KCkgZGlzYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBASW5wdXQoKSBzcGlubmVyczogYm9vbGVhbiA9IHRydWU7XG4gICAgQElucHV0KCkgcmVhZE9ubHk6IGJvb2xlYW4gPSB0cnVlO1xuICAgIEBJbnB1dCgpIHNjcm9sbGluZzogYm9vbGVhbiA9IHRydWU7XG4gICAgQElucHV0KCkgYXJyb3drZXlzOiBib29sZWFuID0gdHJ1ZTtcblxuICAgIEBJbnB1dCgpIGluY3JlbWVudEFyaWFMYWJlbDogc3RyaW5nO1xuICAgIEBJbnB1dCgpIGlucHV0QXJpYUxhYmVsOiBzdHJpbmc7XG4gICAgQElucHV0KCkgZGVjcmVtZW50QXJpYUxhYmVsOiBzdHJpbmc7XG5cbiAgICBAT3V0cHV0KCkgdmFsdWVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuICAgIEBPdXRwdXQoKSBpbmNyZW1lbnQgPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG4gICAgQE91dHB1dCgpIGRlY3JlbWVudCA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcblxuICAgIG9uVG91Y2hlZENhbGxiYWNrOiAoKSA9PiB2b2lkID0gKCkgPT4geyB9O1xuICAgIG9uQ2hhbmdlQ2FsbGJhY2s6IChfOiBhbnkpID0+IHZvaWQgPSAoKSA9PiB7IH07XG5cbiAgICBwcml2YXRlIF92YWx1ZTogYW55O1xuXG4gICAgc2Nyb2xsKGV2ZW50OiBXaGVlbEV2ZW50KTogdm9pZCB7XG5cbiAgICAgICAgaWYgKCF0aGlzLnNjcm9sbGluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50LmRlbHRhWSA+IDApIHtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlckRlY3JlbWVudCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VySW5jcmVtZW50KCk7XG4gICAgICAgIH1cblxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cblxuICAgIHRyaWdnZXJJbmNyZW1lbnQoKTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5pbmNyZW1lbnQuZW1pdCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdHJpZ2dlckRlY3JlbWVudCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKCF0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmRlY3JlbWVudC5lbWl0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB3cml0ZVZhbHVlKHZhbHVlOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm46IChfOiBhbnkpID0+IHZvaWQpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrID0gZm47XG4gICAgfVxuXG4gICAgcmVnaXN0ZXJPblRvdWNoZWQoZm46ICgpID0+IHZvaWQpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5vblRvdWNoZWRDYWxsYmFjayA9IGZuO1xuICAgIH1cblxuICAgIHNldERpc2FibGVkU3RhdGUoaXNEaXNhYmxlZDogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gaXNEaXNhYmxlZDtcbiAgICB9XG5cbn0iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IEZvcm1zTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgU3BpbkJ1dHRvbkNvbXBvbmVudCB9IGZyb20gJy4vc3Bpbi1idXR0b24uY29tcG9uZW50JztcblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGVcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtTcGluQnV0dG9uQ29tcG9uZW50XSxcbiAgICBkZWNsYXJhdGlvbnM6IFtTcGluQnV0dG9uQ29tcG9uZW50XVxufSlcbmV4cG9ydCBjbGFzcyBTcGluQnV0dG9uTW9kdWxlIHsgfSIsImltcG9ydCB7IFBpcGUsIFBpcGVUcmFuc2Zvcm0gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQFBpcGUoe1xuICAgIG5hbWU6ICd0aW1lRm9ybWF0J1xufSlcbmV4cG9ydCBjbGFzcyBUaW1lRm9ybWF0UGlwZSBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0ge1xuICAgIHRyYW5zZm9ybSh2YWx1ZTogbnVtYmVyLCBwYWQ6IGJvb2xlYW4pOiBzdHJpbmcgfCBudW1iZXIge1xuICAgICAgICByZXR1cm4gdmFsdWUgPCAxMCAmJiBwYWQgPyAnMCcgKyB2YWx1ZSA6IHZhbHVlO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgZm9yd2FyZFJlZiwgSW5wdXQsIE9uRGVzdHJveSwgT3V0cHV0LCBWaWV3RW5jYXBzdWxhdGlvbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29udHJvbFZhbHVlQWNjZXNzb3IsIE5HX1ZBTFVFX0FDQ0VTU09SIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcy9CZWhhdmlvclN1YmplY3QnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMvT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBkaXN0aW5jdFVudGlsQ2hhbmdlZCwgbWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcy9TdWJzY3JpcHRpb24nO1xuXG5leHBvcnQgY29uc3QgVElNRV9QSUNLRVJfVkFMVUVfQUNDRVNTT1I6IGFueSA9IHtcbiAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBUaW1lUGlja2VyQ29tcG9uZW50KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC10aW1lLXBpY2tlcicsXG4gICAgdGVtcGxhdGVVcmw6ICcuL3RpbWUtcGlja2VyLmNvbXBvbmVudC5odG1sJyxcbiAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgIHByb3ZpZGVyczogW1RJTUVfUElDS0VSX1ZBTFVFX0FDQ0VTU09SXSxcbiAgICBob3N0OiB7XG4gICAgICAgICdhcmlhLWxhYmVsJzogJ1RpbWUgUGlja2VyJ1xuICAgIH1cbn0pXG5leHBvcnQgY2xhc3MgVGltZVBpY2tlckNvbXBvbmVudCBpbXBsZW1lbnRzIENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBPbkRlc3Ryb3kge1xuXG4gICAgQElucHV0KCkgYXJyb3drZXlzOiBib29sZWFuID0gdHJ1ZTtcbiAgICBASW5wdXQoKSBtb3VzZXdoZWVsOiBib29sZWFuID0gdHJ1ZTtcbiAgICBASW5wdXQoKSBkaXNhYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIEBJbnB1dCgpIHJlYWRPbmx5OiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBASW5wdXQoKSBzaG93TWVyaWRpYW46IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBASW5wdXQoKSBzaG93SG91cnM6IGJvb2xlYW4gPSB0cnVlO1xuICAgIEBJbnB1dCgpIHNob3dNaW51dGVzOiBib29sZWFuID0gdHJ1ZTtcbiAgICBASW5wdXQoKSBzaG93U2Vjb25kczogYm9vbGVhbiA9IGZhbHNlO1xuICAgIEBJbnB1dCgpIHNob3dTcGlubmVyczogYm9vbGVhbiA9IHRydWU7XG5cbiAgICBASW5wdXQoKSBob3VyU3RlcDogbnVtYmVyID0gMTtcbiAgICBASW5wdXQoKSBtaW51dGVTdGVwOiBudW1iZXIgPSAxO1xuICAgIEBJbnB1dCgpIHNlY29uZFN0ZXA6IG51bWJlciA9IDE7XG5cbiAgICBASW5wdXQoKSBtaW46IERhdGU7XG4gICAgQElucHV0KCkgbWF4OiBEYXRlO1xuICAgIEBJbnB1dCgpIG1lcmlkaWFuczogc3RyaW5nW10gPSBbJ0FNJywgJ1BNJ107XG5cbiAgICBASW5wdXQoKSBzZXQgdmFsdWUodmFsdWU6IERhdGUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSQubmV4dChuZXcgRGF0ZSh2YWx1ZSkpO1xuICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlLmVtaXQodGhpcy52YWx1ZSQudmFsdWUpO1xuXG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjayh0aGlzLnZhbHVlJC52YWx1ZSk7XG4gICAgICAgIHRoaXMub25Ub3VjaGVkQ2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICBnZXQgdmFsdWUoKTogRGF0ZSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnZhbHVlJC52YWx1ZSk7XG4gICAgfVxuXG4gICAgQE91dHB1dCgpIHZhbHVlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxEYXRlPigpO1xuICAgIEBPdXRwdXQoKSBpc1ZhbGlkID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG4gICAgb25Ub3VjaGVkQ2FsbGJhY2s6ICgpID0+IHZvaWQgPSAoKSA9PiB7IH07XG4gICAgb25DaGFuZ2VDYWxsYmFjazogKF86IERhdGUpID0+IHZvaWQgPSAoKSA9PiB7IH07XG5cbiAgICB2YWx1ZSQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PERhdGU+KG5ldyBEYXRlKCkpO1xuXG4gICAgLy8gY3JlYXRlIG9ic2VydmFibGVzIHRoYXQgYXJlIGRlcml2ZWQgZnJvbSB0aGUgbGF0ZXN0IHZhbHVlXG4gICAgaG91ciQ6IE9ic2VydmFibGU8bnVtYmVyPiA9IHRoaXMudmFsdWUkLnBpcGUobWFwKGRhdGUgPT4gZGF0ZS5nZXRIb3VycygpKSwgbWFwKGhvdXIgPT4gdGhpcy5zaG93TWVyaWRpYW4gPyB0aGlzLmdldE1lcmlkaWFuVGltZShob3VyKSA6IGhvdXIpKTtcbiAgICBtaW51dGUkOiBPYnNlcnZhYmxlPG51bWJlcj4gPSB0aGlzLnZhbHVlJC5waXBlKG1hcChkYXRlID0+IGRhdGUuZ2V0TWludXRlcygpKSk7XG4gICAgc2Vjb25kJDogT2JzZXJ2YWJsZTxudW1iZXI+ID0gdGhpcy52YWx1ZSQucGlwZShtYXAoZGF0ZSA9PiBkYXRlLmdldFNlY29uZHMoKSkpO1xuICAgIG1lcmlkaWFuJDogT2JzZXJ2YWJsZTxzdHJpbmc+ID0gdGhpcy52YWx1ZSQucGlwZShtYXAoZGF0ZSA9PiBkYXRlLmdldEhvdXJzKCkgPCAxMiA/IHRoaXMubWVyaWRpYW5zWzBdIDogdGhpcy5tZXJpZGlhbnNbMV0pKTtcbiAgICB2YWxpZCQ6IE9ic2VydmFibGU8Ym9vbGVhbj4gPSB0aGlzLnZhbHVlJC5waXBlKG1hcChkYXRlID0+IHRoaXMuY2hlY2tWYWxpZGl0eShkYXRlKSkpO1xuXG4gICAgcHJpdmF0ZSBfbWVyaWRpYW46IHN0cmluZyA9IHRoaXMubWVyaWRpYW5zWzBdO1xuICAgIHByaXZhdGUgX3N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IHRoaXMudmFsaWQkLnBpcGUoZGlzdGluY3RVbnRpbENoYW5nZWQoKSkuc3Vic2NyaWJlKHZhbGlkID0+IHRoaXMuaXNWYWxpZC5lbWl0KHZhbGlkKSk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cblxuICAgIHdyaXRlVmFsdWUodmFsdWU6IERhdGUpOiB2b2lkIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm46IChfOiBEYXRlKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjayA9IGZuO1xuICAgIH1cblxuICAgIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiAoKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgICAgIHRoaXMub25Ub3VjaGVkQ2FsbGJhY2sgPSBmbjtcbiAgICB9XG5cbiAgICBzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQ6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGlzRGlzYWJsZWQ7XG4gICAgfVxuXG4gICAgZ2V0TWVyaWRpYW5UaW1lKGhvdXI6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiBob3VyID4gMTIgPyBob3VyIC0gMTIgOiBob3VyO1xuICAgIH1cblxuICAgIHNldEhvdXIoaG91cjogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGRhdGUgPSB0aGlzLnZhbHVlO1xuICAgICAgICBkYXRlLnNldEhvdXJzKGhvdXIgPyBob3VyIDogMCk7XG5cbiAgICAgICAgdGhpcy52YWx1ZSA9IGRhdGU7XG4gICAgfVxuXG4gICAgc2V0TWludXRlKG1pbnV0ZTogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGRhdGUgPSB0aGlzLnZhbHVlO1xuICAgICAgICBkYXRlLnNldE1pbnV0ZXMobWludXRlID8gbWludXRlIDogMCk7XG5cbiAgICAgICAgdGhpcy52YWx1ZSA9IGRhdGU7XG4gICAgfVxuXG4gICAgc2V0U2Vjb25kcyhzZWNvbmRzOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgZGF0ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgIGRhdGUuc2V0U2Vjb25kcyhzZWNvbmRzID8gc2Vjb25kcyA6IDApO1xuXG4gICAgICAgIHRoaXMudmFsdWUgPSBkYXRlO1xuICAgIH1cblxuICAgIGluY3JlbWVudEhvdXIoYXJyb3drZXk6IGJvb2xlYW4gPSBmYWxzZSk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCB8fCBhcnJvd2tleSAmJiAhdGhpcy5hcnJvd2tleXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0SG91cih0aGlzLnZhbHVlLmdldEhvdXJzKCkgKyB0aGlzLmhvdXJTdGVwKTtcbiAgICB9XG5cbiAgICBkZWNyZW1lbnRIb3VyKGFycm93a2V5OiBib29sZWFuID0gZmFsc2UpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQgfHwgYXJyb3drZXkgJiYgIXRoaXMuYXJyb3drZXlzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldEhvdXIodGhpcy52YWx1ZS5nZXRIb3VycygpIC0gdGhpcy5ob3VyU3RlcCk7XG4gICAgfVxuXG4gICAgaW5jcmVtZW50TWludXRlKGFycm93a2V5OiBib29sZWFuID0gZmFsc2UpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQgfHwgYXJyb3drZXkgJiYgIXRoaXMuYXJyb3drZXlzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldE1pbnV0ZSh0aGlzLnZhbHVlLmdldE1pbnV0ZXMoKSArIHRoaXMubWludXRlU3RlcCk7XG4gICAgfVxuXG4gICAgZGVjcmVtZW50TWludXRlKGFycm93a2V5OiBib29sZWFuID0gZmFsc2UpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQgfHwgYXJyb3drZXkgJiYgIXRoaXMuYXJyb3drZXlzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldE1pbnV0ZSh0aGlzLnZhbHVlLmdldE1pbnV0ZXMoKSAtIHRoaXMubWludXRlU3RlcCk7XG4gICAgfVxuXG4gICAgaW5jcmVtZW50U2Vjb25kKGFycm93a2V5OiBib29sZWFuID0gZmFsc2UpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQgfHwgYXJyb3drZXkgJiYgIXRoaXMuYXJyb3drZXlzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldFNlY29uZHModGhpcy52YWx1ZS5nZXRTZWNvbmRzKCkgKyB0aGlzLnNlY29uZFN0ZXApO1xuICAgIH1cblxuICAgIGRlY3JlbWVudFNlY29uZChhcnJvd2tleTogYm9vbGVhbiA9IGZhbHNlKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkIHx8IGFycm93a2V5ICYmICF0aGlzLmFycm93a2V5cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXRTZWNvbmRzKHRoaXMudmFsdWUuZ2V0U2Vjb25kcygpIC0gdGhpcy5zZWNvbmRTdGVwKTtcbiAgICB9XG5cbiAgICBzZWxlY3RNZXJpZGlhbihtZXJpZGlhbjogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX21lcmlkaWFuID0gbWVyaWRpYW47XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBjdXJyZW50IHRpbWVcbiAgICAgICAgY29uc3QgaG91ciA9IHRoaXMudmFsdWUuZ2V0SG91cnMoKTtcblxuICAgICAgICAvLyBpZiB3ZSBoYXZlIHNlbGVjdGVkIEFNXG4gICAgICAgIGlmIChtZXJpZGlhbiA9PT0gdGhpcy5tZXJpZGlhbnNbMF0pIHtcbiAgICAgICAgICAgIGlmIChob3VyID49IDEyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRIb3VyKGhvdXIgLSAxMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB3ZSBoYXZlIHNlbGVjdGVkIFBNXG4gICAgICAgIGlmIChtZXJpZGlhbiA9PT0gdGhpcy5tZXJpZGlhbnNbMV0pIHtcbiAgICAgICAgICAgIGlmIChob3VyIDwgMTIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEhvdXIoaG91ciArIDEyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNoZWNrVmFsaWRpdHkoZGF0ZTogRGF0ZSk6IGJvb2xlYW4ge1xuICAgICAgICBsZXQgdmFsaWQgPSB0cnVlO1xuXG4gICAgICAgIGlmICh0aGlzLm1pbiAmJiBkYXRlLmdldFRpbWUoKSA8PSB0aGlzLm1pbi5nZXRUaW1lKCkpIHtcbiAgICAgICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5tYXggJiYgZGF0ZS5nZXRUaW1lKCkgPj0gdGhpcy5tYXguZ2V0VGltZSgpKSB7XG4gICAgICAgICAgICB2YWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbGlkO1xuICAgIH1cblxuICAgIGhvdXJDaGFuZ2UodmFsdWU6IHN0cmluZyk6IHZvaWQge1xuXG4gICAgICAgIC8vIGNvbnZlcnQgdGhlIHN0cmluZyB0byBhIG51bWJlclxuICAgICAgICBsZXQgaG91ciA9IHBhcnNlSW50KHZhbHVlKTtcbiAgICAgICAgbGV0IGN1cnJlbnRIb3VyID0gdGhpcy52YWx1ZS5nZXRIb3VycygpO1xuXG4gICAgICAgIC8vIGlmIHRoZSB2YWx1ZSBoYXNuJ3QgY2hhbmdlZCwgZG8gbm90aGluZ1xuICAgICAgICBpZiAoaG91ciA9PT0gY3VycmVudEhvdXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVuc3VyZSB0aGUgaG91cnMgaXMgdmFsaWRcbiAgICAgICAgaWYgKCFpc05hTihob3VyKSkge1xuICAgICAgICAgICAgaWYgKGhvdXIgPCAwKSB7XG4gICAgICAgICAgICAgICAgaG91ciA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChob3VyID4gKHRoaXMuc2hvd01lcmlkaWFuID8gMTIgOiAyMykpIHtcbiAgICAgICAgICAgICAgICBob3VyID0gdGhpcy5zaG93TWVyaWRpYW4gPyAxMiA6IDIzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaG91ciA9IGlzTmFOKGhvdXIpID8gY3VycmVudEhvdXIgOiBob3VyO1xuXG4gICAgICAgIC8vIGlmIHRoZSBudW1iZXIgaXMgaW52YWxpZCB0aGVuIHJlc3RvcmUgaXQgdG8gdGhlIHByZXZpb3VzIHZhbHVlXG4gICAgICAgIGlmICh0aGlzLl9tZXJpZGlhbiA9PT0gdGhpcy5tZXJpZGlhbnNbMF0pIHtcbiAgICAgICAgICAgIGlmIChob3VyID49IDEyKSB7XG4gICAgICAgICAgICAgICAgaG91ciAtPSAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHdlIGhhdmUgc2VsZWN0ZWQgUE1cbiAgICAgICAgaWYgKHRoaXMuX21lcmlkaWFuID09PSB0aGlzLm1lcmlkaWFuc1sxXSkge1xuICAgICAgICAgICAgaWYgKGhvdXIgPCAxMikge1xuICAgICAgICAgICAgICAgIGhvdXIgKz0gMTI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldEhvdXIoaG91cik7XG4gICAgfVxuXG4gICAgbWludXRlQ2hhbmdlKHZhbHVlOiBzdHJpbmcpOiB2b2lkIHtcblxuICAgICAgICAvLyBjb252ZXJ0IHRoZSBzdHJpbmcgdG8gYSBudW1iZXJcbiAgICAgICAgbGV0IG1pbnV0ZSA9IHBhcnNlSW50KHZhbHVlKTtcbiAgICAgICAgbGV0IGN1cnJlbnRNaW51dGUgPSB0aGlzLnZhbHVlLmdldE1pbnV0ZXMoKTtcblxuICAgICAgICAvLyBpZiB0aGUgdmFsdWUgaGFzbid0IGNoYW5nZWQsIGRvIG5vdGhpbmdcbiAgICAgICAgaWYgKG1pbnV0ZSA9PT0gY3VycmVudE1pbnV0ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZW5zdXJlIHRoZSBob3VycyBpcyB2YWxpZFxuICAgICAgICBpZiAoIWlzTmFOKG1pbnV0ZSkpIHtcbiAgICAgICAgICAgIGlmIChtaW51dGUgPCAwKSB7XG4gICAgICAgICAgICAgICAgbWludXRlID0gNTk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtaW51dGUgPiA1OSkge1xuICAgICAgICAgICAgICAgIG1pbnV0ZSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aGUgbnVtYmVyIGlzIGludmFsaWQgdGhlbiByZXN0b3JlIGl0IHRvIHRoZSBwcmV2aW91cyB2YWx1ZVxuICAgICAgICB0aGlzLnNldE1pbnV0ZShpc05hTihtaW51dGUpID8gY3VycmVudE1pbnV0ZSA6IG1pbnV0ZSk7XG4gICAgfVxuXG4gICAgc2Vjb25kQ2hhbmdlKHZhbHVlOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgLy8gY29udmVydCB0aGUgc3RyaW5nIHRvIGEgbnVtYmVyXG4gICAgICAgIGxldCBzZWNvbmQgPSBwYXJzZUludCh2YWx1ZSk7XG4gICAgICAgIGxldCBjdXJyZW50U2Vjb25kID0gdGhpcy52YWx1ZS5nZXRTZWNvbmRzKCk7XG5cbiAgICAgICAgLy8gaWYgdGhlIHZhbHVlIGhhc24ndCBjaGFuZ2VkLCBkbyBub3RoaW5nXG4gICAgICAgIGlmIChzZWNvbmQgPT09IGN1cnJlbnRTZWNvbmQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVuc3VyZSB0aGUgaG91cnMgaXMgdmFsaWRcbiAgICAgICAgaWYgKCFpc05hTihzZWNvbmQpKSB7XG4gICAgICAgICAgICBpZiAoc2Vjb25kIDwgMCkge1xuICAgICAgICAgICAgICAgIHNlY29uZCA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzZWNvbmQgPiA1OSkge1xuICAgICAgICAgICAgICAgIHNlY29uZCA9IDU5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhlIG51bWJlciBpcyBpbnZhbGlkIHRoZW4gcmVzdG9yZSBpdCB0byB0aGUgcHJldmlvdXMgdmFsdWVcbiAgICAgICAgdGhpcy5zZXRTZWNvbmRzKGlzTmFOKHNlY29uZCkgPyBjdXJyZW50U2Vjb25kIDogc2Vjb25kKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGb3Jtc01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IFNwaW5CdXR0b25Nb2R1bGUgfSBmcm9tICcuLi9zcGluLWJ1dHRvbi9pbmRleCc7XG5pbXBvcnQgeyBUaW1lRm9ybWF0UGlwZSB9IGZyb20gJy4vdGltZS1mb3JtYXQucGlwZSc7XG5pbXBvcnQgeyBUaW1lUGlja2VyQ29tcG9uZW50IH0gZnJvbSAnLi90aW1lLXBpY2tlci5jb21wb25lbnQnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgU3BpbkJ1dHRvbk1vZHVsZVxuICAgIF0sXG4gICAgZXhwb3J0czogW1RpbWVQaWNrZXJDb21wb25lbnRdLFxuICAgIGRlY2xhcmF0aW9uczogW1RpbWVQaWNrZXJDb21wb25lbnQsIFRpbWVGb3JtYXRQaXBlXSxcbn0pXG5leHBvcnQgY2xhc3MgVGltZVBpY2tlck1vZHVsZSB7IH0iLCJpbXBvcnQgeyBEYXRlVGltZVBpY2tlclRpbWV6b25lIH0gZnJvbSAnLi9kYXRlLXRpbWUtcGlja2VyLnNlcnZpY2UnO1xuXG5cbi8qKlxuICogQ29udmVydCBhIHNpbmdsZSBkaW1lbnNpb24gYXJyYXkgdG8gYSBkb3VibGUgZGltZW5zaW9uIGFycmF5XG4gKiBAcGFyYW0gaXRlbXMgdGhlIHNpbmdsZSBkaW1lbnNpb24gYXJyYXkgdG8gY29udmVydFxuICogQHBhcmFtIGNvbHVtbnMgdGhlIG51bWJlciBvZiBpdGVtcyBlYWNoIGFycmF5IHNob3VsZCBoYXZlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBncmlkaWZ5PFQ+KGl0ZW1zOiBUW10sIGNvbHVtbnM6IG51bWJlcik6IFRbXVtdIHtcblxuICAgIC8vIGNyZWF0ZSBhIGNvcHkgb2YgYXJyYXkgc28gbm90IHRvIGVmZmVjdCB0aGUgb3JpZ2luYWxcbiAgICBpdGVtcyA9IGl0ZW1zLnNsaWNlKDApO1xuXG4gICAgY29uc3QgZ3JpZDogVFtdW10gPSBbXTtcblxuICAgIHdoaWxlIChpdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgZ3JpZC5wdXNoKGl0ZW1zLnNwbGljZSgwLCBjb2x1bW5zKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdyaWQ7XG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIGFycmF5IG9mIG51bWJlcnMgYmV0d2VlbiB0d28gbGltaXRzXG4gKiBAcGFyYW0gc3RhcnQgdGhlIGxvd2VyIGxpbWl0XG4gKiBAcGFyYW0gZW5kIHRoZSB1cHBlciBsaW1pdFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZ2Uoc3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIpOiBudW1iZXJbXSB7XG4gICAgY29uc3QgbGlzdDogbnVtYmVyW10gPSBbXTtcblxuICAgIGZvciAobGV0IGlkeCA9IHN0YXJ0OyBpZHggPD0gZW5kOyBpZHgrKykge1xuICAgICAgICBsaXN0LnB1c2goaWR4KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGlzdDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gYXJyYXkgb2YgZGF0ZXMgYmV0d2VlbiB0d28gcG9pbnRzXG4gKiBAcGFyYW0gc3RhcnQgdGhlIGRhdGUgdG8gc3RhcnQgdGhlIGFycmF5XG4gKiBAcGFyYW0gZW5kIHRoZSBkYXRlIHRvIGVuZCB0aGUgYXJyYXlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRhdGVSYW5nZShzdGFydDogRGF0ZSwgZW5kOiBEYXRlKTogRGF0ZVtdIHtcblxuICAgIGxldCBkYXRlczogRGF0ZVtdID0gW107XG5cbiAgICAvLyBsb29wIHRocm91Z2ggYWxsIHRoZSBkYXlzIGJldHdlZW4gdGhlIGRhdGUgcmFuZ2VcbiAgICB3aGlsZSAoc3RhcnQgPD0gZW5kKSB7XG5cbiAgICAgICAgLy8gYWRkIHRoZSBkYXRlIHRvIHRoZSBhcnJheVxuICAgICAgICBkYXRlcy5wdXNoKG5ldyBEYXRlKHN0YXJ0KSk7XG5cbiAgICAgICAgLy8gbW92ZSB0byB0aGUgbmV4dCBkYXlcbiAgICAgICAgc3RhcnQuc2V0RGF0ZShzdGFydC5nZXREYXRlKCkgKyAxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0ZXM7XG59XG5cbi8qKlxuICogQ29tcGFyZSB0d28gZGF0ZXMgdG8gc2VlIGlmIHRoZXkgYXJlIG9uIHRoZSBzYW1lIGRheVxuICogQHBhcmFtIGRheTEgdGhlIGZpcnN0IGRhdGUgdG8gY29tcGFyZVxuICogQHBhcmFtIGRheTIgdGhlIHNlY29uZCBkYXRlIHRvIGNvbXBhcmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmVEYXlzKGRheTE6IERhdGUsIGRheTI6IERhdGUpOiBib29sZWFuIHtcbiAgICByZXR1cm4gZGF5MS5nZXREYXRlKCkgPT09IGRheTIuZ2V0RGF0ZSgpICYmXG4gICAgICAgIGRheTEuZ2V0TW9udGgoKSA9PT0gZGF5Mi5nZXRNb250aCgpICYmXG4gICAgICAgIGRheTEuZ2V0RnVsbFllYXIoKSA9PT0gZGF5Mi5nZXRGdWxsWWVhcigpO1xufVxuXG4vKipcbiAqIERhdGUgY29tcGFyaXNvbiBmb3IgdXNlIHByaW1hcmlseSB3aXRoIGRpc3RpbmN0VW50aWxDaGFuZ2VkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkYXRlQ29tcGFyYXRvcihkYXRlT25lOiBEYXRlLCBkYXRlVHdvOiBEYXRlKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGRhdGVPbmUuZ2V0VGltZSgpID09PSBkYXRlVHdvLmdldFRpbWUoKTtcbn1cblxuLyoqXG4gKiBUaW1lem9uZSBjb21wYXJpc29uIGZvciB1c2UgcHJpbWFyaWx5IHdpdGggZGlzdGluY3RVbnRpbENoYW5nZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRpbWV6b25lQ29tcGFyYXRvcih6b25lT25lOiBEYXRlVGltZVBpY2tlclRpbWV6b25lLCB6b25lVHdvOiBEYXRlVGltZVBpY2tlclRpbWV6b25lKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHpvbmVPbmUubmFtZSA9PT0gem9uZVR3by5uYW1lICYmIHpvbmVPbmUub2Zmc2V0ID09PSB6b25lVHdvLm9mZnNldDtcbn1cblxuLyoqXG4gKiBFeHBvcnQgYW4gYXJyYXkgb2YgYWxsIHRoZSBhdmFpbGFibGUgbW9udGhzXG4gKi9cbmV4cG9ydCBjb25zdCBtb250aHMgPSBbJ0phbnVhcnknLCAnRmVicnVhcnknLCAnTWFyY2gnLCAnQXByaWwnLCAnTWF5JywgJ0p1bmUnLCAnSnVseScsICdBdWd1c3QnLCAnU2VwdGVtYmVyJywgJ09jdG9iZXInLCAnTm92ZW1iZXInLCAnRGVjZW1iZXInXTtcbmV4cG9ydCBjb25zdCBtb250aHNTaG9ydCA9IG1vbnRocy5tYXAobW9udGggPT4gbW9udGguc3Vic3RyaW5nKDAsIDMpKTtcblxuLyoqXG4gKiBFeHBvcnQgYW4gYXJyYXkgb2YgYWxsIHRoZSBhdmFpbGFibGUgZGF5cyBvZiB0aGUgd2Vla1xuICovXG5leHBvcnQgY29uc3Qgd2Vla2RheXMgPSBbJ01vbmRheScsICdUdWVzZGF5JywgJ1dlZG5lc2RheScsICdUaHVyc2RheScsICdGcmlkYXknLCAnU2F0dXJkYXknLCAnU3VuZGF5J107XG5leHBvcnQgY29uc3Qgd2Vla2RheXNTaG9ydCA9IHdlZWtkYXlzLm1hcCh3ZWVrZGF5ID0+IHdlZWtkYXkuc3Vic3RyaW5nKDAsIDMpKTsiLCIvKipcbiAqIEFkZCBhIGNvbmZpZyBzZXJ2aWNlIHRvIGFsbG93IGFuIGFwcGxpY2F0aW9uXG4gKiB0byBjdXN0b21pemUgdGhlIGRhdGUgdGltZSBwaWNrZXIgZGVmYXVsdCBzZXR0aW5nc1xuICogYWNyb3NzIHRoZSBlbnRpcmUgYXBwbGljYXRpb25cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyB3ZWVrZGF5c1Nob3J0IH0gZnJvbSAnLi9kYXRlLXRpbWUtcGlja2VyLnV0aWxzJztcbmltcG9ydCB7IERhdGVUaW1lUGlja2VyVGltZXpvbmUgfSBmcm9tICcuL2RhdGUtdGltZS1waWNrZXIuc2VydmljZSc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBEYXRlVGltZVBpY2tlckNvbmZpZyB7XG5cbiAgICBzaG93RGF0ZTogYm9vbGVhbiA9IHRydWU7XG4gICAgc2hvd1RpbWU6IGJvb2xlYW4gPSB0cnVlO1xuICAgIHNob3dUaW1lem9uZTogYm9vbGVhbiA9IHRydWU7XG4gICAgc2hvd1NlY29uZHM6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBzaG93TWVyaWRpYW46IGJvb2xlYW4gPSB0cnVlO1xuICAgIHNob3dTcGlubmVyczogYm9vbGVhbiA9IHRydWU7XG4gICAgd2Vla2RheXM6IHN0cmluZ1tdID0gd2Vla2RheXNTaG9ydDtcbiAgICBub3dCdG5UZXh0OiBzdHJpbmcgPSAnVG9kYXknO1xuXG4gICAgdGltZXpvbmVzOiBEYXRlVGltZVBpY2tlclRpbWV6b25lW10gPSBbXG4gICAgICAgIHsgbmFtZTogJ0dNVC0xMScsIG9mZnNldDogNjYwIH0sXG4gICAgICAgIHsgbmFtZTogJ0dNVC0xMCcsIG9mZnNldDogNjAwIH0sXG4gICAgICAgIHsgbmFtZTogJ0dNVC05Jywgb2Zmc2V0OiA1NDAgfSxcbiAgICAgICAgeyBuYW1lOiAnR01ULTgnLCBvZmZzZXQ6IDQ4MCB9LFxuICAgICAgICB7IG5hbWU6ICdHTVQtNycsIG9mZnNldDogNDIwIH0sXG4gICAgICAgIHsgbmFtZTogJ0dNVC02Jywgb2Zmc2V0OiAzNjAgfSxcbiAgICAgICAgeyBuYW1lOiAnR01ULTUnLCBvZmZzZXQ6IDMwMCB9LFxuICAgICAgICB7IG5hbWU6ICdHTVQtNCcsIG9mZnNldDogMjQwIH0sXG4gICAgICAgIHsgbmFtZTogJ0dNVC0zJywgb2Zmc2V0OiAxODAgfSxcbiAgICAgICAgeyBuYW1lOiAnR01ULTInLCBvZmZzZXQ6IDEyMCB9LFxuICAgICAgICB7IG5hbWU6ICdHTVQtMScsIG9mZnNldDogNjAgfSxcbiAgICAgICAgeyBuYW1lOiAnR01UJywgb2Zmc2V0OiAwIH0sXG4gICAgICAgIHsgbmFtZTogJ0dNVCsxJywgb2Zmc2V0OiAtNjAgfSxcbiAgICAgICAgeyBuYW1lOiAnR01UKzInLCBvZmZzZXQ6IC0xMjAgfSxcbiAgICAgICAgeyBuYW1lOiAnR01UKzMnLCBvZmZzZXQ6IC0xODAgfSxcbiAgICAgICAgeyBuYW1lOiAnR01UKzQnLCBvZmZzZXQ6IC0yNDAgfSxcbiAgICAgICAgeyBuYW1lOiAnR01UKzUnLCBvZmZzZXQ6IC0zMDAgfSxcbiAgICAgICAgeyBuYW1lOiAnR01UKzYnLCBvZmZzZXQ6IC0zNjAgfSxcbiAgICAgICAgeyBuYW1lOiAnR01UKzcnLCBvZmZzZXQ6IC00MjAgfSxcbiAgICAgICAgeyBuYW1lOiAnR01UKzgnLCBvZmZzZXQ6IC00ODAgfSxcbiAgICAgICAgeyBuYW1lOiAnR01UKzknLCBvZmZzZXQ6IC01NDAgfSxcbiAgICAgICAgeyBuYW1lOiAnR01UKzEwJywgb2Zmc2V0OiAtNjAwIH0sXG4gICAgICAgIHsgbmFtZTogJ0dNVCsxMScsIG9mZnNldDogLTY2MCB9LFxuICAgICAgICB7IG5hbWU6ICdHTVQrMTInLCBvZmZzZXQ6IC03MjAgfVxuICAgIF07XG59IiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcy9CZWhhdmlvclN1YmplY3QnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBkaXN0aW5jdFVudGlsQ2hhbmdlZCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IERhdGVUaW1lUGlja2VyQ29uZmlnIH0gZnJvbSAnLi9kYXRlLXRpbWUtcGlja2VyLmNvbmZpZyc7XG5pbXBvcnQgeyBkYXRlQ29tcGFyYXRvciB9IGZyb20gJy4vZGF0ZS10aW1lLXBpY2tlci51dGlscyc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBEYXRlVGltZVBpY2tlclNlcnZpY2Uge1xuXG4gICAgbW9kZSQ6IEJlaGF2aW9yU3ViamVjdDxEYXRlUGlja2VyTW9kZT4gPSBuZXcgQmVoYXZpb3JTdWJqZWN0PERhdGVQaWNrZXJNb2RlPihEYXRlUGlja2VyTW9kZS5EYXkpO1xuICAgIGRhdGUkOiBCZWhhdmlvclN1YmplY3Q8RGF0ZT4gPSBuZXcgQmVoYXZpb3JTdWJqZWN0PERhdGU+KG5ldyBEYXRlKCkpO1xuICAgIHRpbWV6b25lJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8RGF0ZVRpbWVQaWNrZXJUaW1lem9uZT4odGhpcy5nZXRDdXJyZW50VGltZXpvbmUoKSk7XG4gICAgc2VsZWN0ZWQkOiBCZWhhdmlvclN1YmplY3Q8RGF0ZT4gPSBuZXcgQmVoYXZpb3JTdWJqZWN0PERhdGU+KG5ldyBEYXRlKCkpO1xuXG4gICAgLy8gdGhlIG1vbnRoIGFuZCB5ZWFyIHRvIGRpc3BsYXkgaW4gdGhlIHZpZXdwb3J0XG4gICAgbW9udGgkOiBCZWhhdmlvclN1YmplY3Q8bnVtYmVyPiA9IG5ldyBCZWhhdmlvclN1YmplY3Q8bnVtYmVyPihuZXcgRGF0ZSgpLmdldE1vbnRoKCkpO1xuICAgIHllYXIkOiBCZWhhdmlvclN1YmplY3Q8bnVtYmVyPiA9IG5ldyBCZWhhdmlvclN1YmplY3Q8bnVtYmVyPihuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCkpO1xuXG4gICAgc2hvd0RhdGUkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPih0aGlzLl9jb25maWcuc2hvd0RhdGUpO1xuICAgIHNob3dUaW1lJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4odGhpcy5fY29uZmlnLnNob3dUaW1lKTtcbiAgICBzaG93VGltZXpvbmUkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPih0aGlzLl9jb25maWcuc2hvd1RpbWV6b25lKTtcbiAgICBzaG93U2Vjb25kcyQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+KHRoaXMuX2NvbmZpZy5zaG93U2Vjb25kcyk7XG4gICAgc2hvd01lcmlkaWFuJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4odGhpcy5fY29uZmlnLnNob3dNZXJpZGlhbik7XG4gICAgc2hvd1NwaW5uZXJzJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4odGhpcy5fY29uZmlnLnNob3dTcGlubmVycyk7XG4gICAgd2Vla2RheXMkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxzdHJpbmdbXT4odGhpcy5fY29uZmlnLndlZWtkYXlzKTtcbiAgICBub3dCdG5UZXh0JCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8c3RyaW5nPih0aGlzLl9jb25maWcubm93QnRuVGV4dCk7XG4gICAgdGltZXpvbmVzJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8RGF0ZVRpbWVQaWNrZXJUaW1lem9uZVtdPih0aGlzLl9jb25maWcudGltZXpvbmVzKTtcblxuICAgIGhlYWRlciQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PHN0cmluZz4obnVsbCk7XG4gICAgaGVhZGVyRXZlbnQkID0gbmV3IFN1YmplY3Q8RGF0ZVBpY2tlckhlYWRlckV2ZW50PigpO1xuICAgIG1vZGVEaXJlY3Rpb246IE1vZGVEaXJlY3Rpb24gPSBNb2RlRGlyZWN0aW9uLk5vbmU7XG5cbiAgICBwcml2YXRlIF9zdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX2NvbmZpZzogRGF0ZVRpbWVQaWNrZXJDb25maWcpIHtcblxuICAgICAgICAvLyB3aGVuIHRoZSBhY3RpdmUgZGF0ZSBjaGFuZ2VzIHNldCB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGRhdGVcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gdGhpcy5zZWxlY3RlZCQucGlwZShkaXN0aW5jdFVudGlsQ2hhbmdlZChkYXRlQ29tcGFyYXRvcikpLnN1YnNjcmliZShkYXRlID0+IHtcblxuICAgICAgICAgICAgLy8gdGhlIG1vbnRoIGFuZCB5ZWFyIGRpc3BsYXllZCBpbiB0aGUgdmlld3BvcnQgc2hvdWxkIHJlZmxlY3QgdGhlIG5ld2x5IHNlbGVjdGVkIGl0ZW1zXG4gICAgICAgICAgICB0aGlzLnNldFZpZXdwb3J0TW9udGgoZGF0ZS5nZXRNb250aCgpKTtcbiAgICAgICAgICAgIHRoaXMuc2V0Vmlld3BvcnRZZWFyKGRhdGUuZ2V0RnVsbFllYXIoKSk7XG5cbiAgICAgICAgICAgIC8vIGVtaXQgdGhlIG5ldyBkYXRlIHRvIHRoZSBjb21wb25lbnQgaG9zdFxuICAgICAgICAgICAgdGhpcy5kYXRlJC5uZXh0KGRhdGUpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuXG4gICAgc2V0Vmlld3BvcnRNb250aChtb250aDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGlmIChtb250aCA8IDApIHtcbiAgICAgICAgICAgIHRoaXMubW9udGgkLm5leHQoMTEpO1xuICAgICAgICAgICAgdGhpcy55ZWFyJC5uZXh0KHRoaXMueWVhciQudmFsdWUgLSAxKTtcbiAgICAgICAgfSBlbHNlIGlmIChtb250aCA+IDExKSB7XG4gICAgICAgICAgICB0aGlzLm1vbnRoJC5uZXh0KDApO1xuICAgICAgICAgICAgdGhpcy55ZWFyJC5uZXh0KHRoaXMueWVhciQudmFsdWUgKyAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubW9udGgkLm5leHQobW9udGgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0Vmlld3BvcnRZZWFyKHllYXI6IG51bWJlcik6IHZvaWQge1xuICAgICAgICB0aGlzLnllYXIkLm5leHQoeWVhcik7XG4gICAgfVxuXG4gICAgc2V0RGF0ZShkYXk6IG51bWJlciwgbW9udGg6IG51bWJlciwgeWVhcjogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh0aGlzLnNlbGVjdGVkJC52YWx1ZSk7XG5cbiAgICAgICAgZGF0ZS5zZXREYXRlKGRheSk7XG4gICAgICAgIGRhdGUuc2V0TW9udGgobW9udGgpO1xuICAgICAgICBkYXRlLnNldEZ1bGxZZWFyKHllYXIpO1xuXG4gICAgICAgIHRoaXMuc2VsZWN0ZWQkLm5leHQoZGF0ZSk7XG4gICAgfVxuXG4gICAgc2V0RGF0ZVRvTm93KCk6IHZvaWQge1xuICAgICAgICB0aGlzLnNlbGVjdGVkJC5uZXh0KG5ldyBEYXRlKCkpO1xuICAgIH1cblxuICAgIHNldFZpZXdwb3J0TW9kZShtb2RlOiBEYXRlUGlja2VyTW9kZSk6IHZvaWQge1xuICAgICAgICB0aGlzLm1vZGUkLm5leHQobW9kZSk7XG4gICAgfVxuXG4gICAgZ29Ub0NoaWxkTW9kZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5tb2RlRGlyZWN0aW9uID0gTW9kZURpcmVjdGlvbi5EZXNjZW5kO1xuXG4gICAgICAgIHN3aXRjaCAodGhpcy5tb2RlJC52YWx1ZSkge1xuXG4gICAgICAgICAgICBjYXNlIERhdGVQaWNrZXJNb2RlLlllYXI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0Vmlld3BvcnRNb2RlKERhdGVQaWNrZXJNb2RlLk1vbnRoKTtcblxuICAgICAgICAgICAgY2FzZSBEYXRlUGlja2VyTW9kZS5Nb250aDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRWaWV3cG9ydE1vZGUoRGF0ZVBpY2tlck1vZGUuRGF5KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdvVG9QYXJlbnRNb2RlKCk6IHZvaWQge1xuICAgICAgICB0aGlzLm1vZGVEaXJlY3Rpb24gPSBNb2RlRGlyZWN0aW9uLkFzY2VuZDtcblxuICAgICAgICBzd2l0Y2ggKHRoaXMubW9kZSQudmFsdWUpIHtcblxuICAgICAgICAgICAgY2FzZSBEYXRlUGlja2VyTW9kZS5EYXk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0Vmlld3BvcnRNb2RlKERhdGVQaWNrZXJNb2RlLk1vbnRoKTtcblxuICAgICAgICAgICAgY2FzZSBEYXRlUGlja2VyTW9kZS5Nb250aDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRWaWV3cG9ydE1vZGUoRGF0ZVBpY2tlck1vZGUuWWVhcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnb1RvTmV4dCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5oZWFkZXJFdmVudCQubmV4dChEYXRlUGlja2VySGVhZGVyRXZlbnQuTmV4dCk7XG4gICAgfVxuXG4gICAgZ29Ub1ByZXZpb3VzKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmhlYWRlckV2ZW50JC5uZXh0KERhdGVQaWNrZXJIZWFkZXJFdmVudC5QcmV2aW91cyk7XG4gICAgfVxuXG4gICAgc2V0SGVhZGVyKGhlYWRlcjogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHRoaXMuaGVhZGVyJC5uZXh0KGhlYWRlcik7XG4gICAgfVxuXG4gICAgZ2V0Q3VycmVudFRpbWV6b25lKCk6IERhdGVUaW1lUGlja2VyVGltZXpvbmUge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBuZXcgRGF0ZSgpLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25maWcudGltZXpvbmVzLmZpbmQodGltZXpvbmUgPT4gdGltZXpvbmUub2Zmc2V0ID09PSBvZmZzZXQpO1xuICAgIH1cblxuICAgIHNldFRpbWV6b25lKHRpbWV6b25lOiBEYXRlVGltZVBpY2tlclRpbWV6b25lKTogdm9pZCB7XG4gICAgICAgIHRoaXMudGltZXpvbmUkLm5leHQodGltZXpvbmUpO1xuICAgIH1cbn1cblxuZXhwb3J0IGVudW0gRGF0ZVBpY2tlck1vZGUge1xuICAgIERheSxcbiAgICBNb250aCxcbiAgICBZZWFyXG59XG5cbmV4cG9ydCBlbnVtIE1vZGVEaXJlY3Rpb24ge1xuICAgIE5vbmUsXG4gICAgQXNjZW5kLFxuICAgIERlc2NlbmRcbn1cblxuZXhwb3J0IGVudW0gRGF0ZVBpY2tlckhlYWRlckV2ZW50IHtcbiAgICBQcmV2aW91cyxcbiAgICBOZXh0XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF0ZVRpbWVQaWNrZXJUaW1lem9uZSB7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIG9mZnNldDogbnVtYmVyO1xufSIsImltcG9ydCB7IENvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT25EZXN0cm95LCBPdXRwdXQsIENoYW5nZURldGVjdGlvblN0cmF0ZWd5IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBkaXN0aW5jdFVudGlsQ2hhbmdlZCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IERhdGVQaWNrZXJNb2RlLCBEYXRlVGltZVBpY2tlclNlcnZpY2UsIERhdGVUaW1lUGlja2VyVGltZXpvbmUgfSBmcm9tICcuL2RhdGUtdGltZS1waWNrZXIuc2VydmljZSc7XG5pbXBvcnQgeyBkYXRlQ29tcGFyYXRvciwgdGltZXpvbmVDb21wYXJhdG9yIH0gZnJvbSAnLi9kYXRlLXRpbWUtcGlja2VyLnV0aWxzJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAndXgtZGF0ZS10aW1lLXBpY2tlcicsXG4gIHRlbXBsYXRlVXJsOiAnLi9kYXRlLXRpbWUtcGlja2VyLmNvbXBvbmVudC5odG1sJyxcbiAgcHJvdmlkZXJzOiBbRGF0ZVRpbWVQaWNrZXJTZXJ2aWNlXSxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuXG4gIHByaXZhdGUgX3RpbWV6b25lOiBEYXRlVGltZVBpY2tlclRpbWV6b25lO1xuXG4gIEBJbnB1dCgpIHNldCBzaG93RGF0ZSh2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuZGF0ZXBpY2tlci5zaG93RGF0ZSQubmV4dCh2YWx1ZSk7XG4gIH1cblxuICBASW5wdXQoKSBzZXQgc2hvd1RpbWUodmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLmRhdGVwaWNrZXIuc2hvd1RpbWUkLm5leHQodmFsdWUpO1xuICB9XG5cbiAgQElucHV0KCkgc2V0IHNob3dUaW1lem9uZSh2YWx1ZTogYm9vbGVhbikge1xuICAgIHRoaXMuZGF0ZXBpY2tlci5zaG93VGltZXpvbmUkLm5leHQodmFsdWUpO1xuICB9XG5cbiAgQElucHV0KCkgc2V0IHNob3dTZWNvbmRzKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5kYXRlcGlja2VyLnNob3dTZWNvbmRzJC5uZXh0KHZhbHVlKTtcbiAgfVxuXG4gIEBJbnB1dCgpIHNldCBzaG93TWVyaWRpYW4odmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLmRhdGVwaWNrZXIuc2hvd01lcmlkaWFuJC5uZXh0KHZhbHVlKTtcbiAgfVxuXG4gIEBJbnB1dCgpIHNldCBzaG93U3Bpbm5lcnModmFsdWU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLmRhdGVwaWNrZXIuc2hvd1NwaW5uZXJzJC5uZXh0KHZhbHVlKTtcbiAgfVxuXG4gIEBJbnB1dCgpIHNldCB3ZWVrZGF5cyh2YWx1ZTogc3RyaW5nW10pIHtcbiAgICB0aGlzLmRhdGVwaWNrZXIud2Vla2RheXMkLm5leHQodmFsdWUpO1xuICB9XG5cbiAgQElucHV0KCkgc2V0IG5vd0J0blRleHQodmFsdWU6IHN0cmluZykge1xuICAgIHRoaXMuZGF0ZXBpY2tlci5ub3dCdG5UZXh0JC5uZXh0KHZhbHVlKTtcbiAgfVxuXG4gIEBJbnB1dCgpIHNldCB0aW1lem9uZXModmFsdWU6IERhdGVUaW1lUGlja2VyVGltZXpvbmVbXSkge1xuICAgIHRoaXMuZGF0ZXBpY2tlci50aW1lem9uZXMkLm5leHQodmFsdWUpO1xuICB9XG5cblxuICBAT3V0cHV0KCkgZGF0ZUNoYW5nZTogRXZlbnRFbWl0dGVyPERhdGU+ID0gbmV3IEV2ZW50RW1pdHRlcjxEYXRlPigpO1xuICBAT3V0cHV0KCkgdGltZXpvbmVDaGFuZ2U6IEV2ZW50RW1pdHRlcjxEYXRlVGltZVBpY2tlclRpbWV6b25lPiA9IG5ldyBFdmVudEVtaXR0ZXI8RGF0ZVRpbWVQaWNrZXJUaW1lem9uZT4oKTtcblxuICBASW5wdXQoKVxuICBzZXQgZGF0ZSh2YWx1ZTogRGF0ZSkge1xuICAgIGlmICghZGF0ZUNvbXBhcmF0b3IodmFsdWUsIHRoaXMuZGF0ZXBpY2tlci5zZWxlY3RlZCQudmFsdWUpKSB7XG4gICAgICB0aGlzLmRhdGVwaWNrZXIuc2VsZWN0ZWQkLm5leHQobmV3IERhdGUodmFsdWUpKTtcbiAgICB9XG4gIH1cblxuICBASW5wdXQoKVxuICBzZXQgdGltZXpvbmUodmFsdWU6IERhdGVUaW1lUGlja2VyVGltZXpvbmUpIHtcbiAgICB0aGlzLmRhdGVwaWNrZXIudGltZXpvbmUkLm5leHQodmFsdWUpO1xuICB9XG5cbiAgLy8gZXhwb3NlIGVudW0gdG8gdmlld1xuICBEYXRlUGlja2VyTW9kZSA9IERhdGVQaWNrZXJNb2RlO1xuXG4gIHByaXZhdGUgX3N1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24oKTtcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgZGF0ZXBpY2tlcjogRGF0ZVRpbWVQaWNrZXJTZXJ2aWNlKSB7XG4gICAgY29uc3QgdmFsdWVDaGFuZ2UgPSBkYXRlcGlja2VyLnNlbGVjdGVkJC5waXBlKGRpc3RpbmN0VW50aWxDaGFuZ2VkKGRhdGVDb21wYXJhdG9yKSlcbiAgICAgIC5zdWJzY3JpYmUoZGF0ZSA9PiB0aGlzLmRhdGVDaGFuZ2UuZW1pdChkYXRlKSk7XG5cbiAgICBjb25zdCB0aW1lem9uZUNoYW5nZSA9IGRhdGVwaWNrZXIudGltZXpvbmUkLnBpcGUoZGlzdGluY3RVbnRpbENoYW5nZWQodGltZXpvbmVDb21wYXJhdG9yKSlcbiAgICAgIC5zdWJzY3JpYmUoKHRpbWV6b25lOiBEYXRlVGltZVBpY2tlclRpbWV6b25lKSA9PiB0aGlzLnRpbWV6b25lQ2hhbmdlLmVtaXQodGltZXpvbmUpKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoYW5nZSB0aGUgZGF0ZSB0byB0aGUgY3VycmVudCBkYXRlIGFuZCB0aW1lXG4gICAqL1xuICBzZXRUb05vdygpOiB2b2lkIHtcblxuICAgIC8vIHNldCB0aGUgZGF0ZSB0byB0aGUgY3VycmVudCBtb21lbnRcbiAgICB0aGlzLmRhdGVwaWNrZXIuc2V0RGF0ZVRvTm93KCk7XG4gIH1cbn0iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IGNvbWJpbmVMYXRlc3QgfSBmcm9tICdyeGpzL29ic2VydmFibGUvY29tYmluZUxhdGVzdCc7XG5pbXBvcnQgeyBEYXRlVGltZVBpY2tlclNlcnZpY2UsIE1vZGVEaXJlY3Rpb24gfSBmcm9tICcuLi9kYXRlLXRpbWUtcGlja2VyLnNlcnZpY2UnO1xuaW1wb3J0IHsgY29tcGFyZURheXMsIGRhdGVSYW5nZSwgZ3JpZGlmeSwgbW9udGhzIH0gZnJvbSAnLi4vZGF0ZS10aW1lLXBpY2tlci51dGlscyc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBEYXlWaWV3U2VydmljZSBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG5cbiAgICBncmlkJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8RGF5Vmlld0l0ZW1bXVtdPihbW11dKTtcbiAgICBmb2N1c2VkJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8Rm9jdXNlZERheUl0ZW0+KG51bGwpO1xuXG4gICAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9kYXRlcGlja2VyOiBEYXRlVGltZVBpY2tlclNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gY29tYmluZUxhdGVzdChfZGF0ZXBpY2tlci5tb250aCQsIF9kYXRlcGlja2VyLnllYXIkKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoW21vbnRoLCB5ZWFyXSkgPT4gdGhpcy5jcmVhdGVEYXlHcmlkKG1vbnRoLCB5ZWFyKSk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cblxuICAgIHNldEZvY3VzKGRheTogbnVtYmVyLCBtb250aDogbnVtYmVyLCB5ZWFyOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5mb2N1c2VkJC5uZXh0KHsgZGF5OiBkYXksIG1vbnRoOiBtb250aCwgeWVhcjogeWVhciB9KTtcblxuICAgICAgICAvLyB1cGRhdGUgdGhlIGRhdGUgcGlja2VyIHRvIHNob3cgdGhlIHJlcXVpcmVkIG1vbnRoIGFuZCB5ZWFyXG4gICAgICAgIHRoaXMuX2RhdGVwaWNrZXIuc2V0Vmlld3BvcnRNb250aChtb250aCk7XG4gICAgICAgIHRoaXMuX2RhdGVwaWNrZXIuc2V0Vmlld3BvcnRZZWFyKHllYXIpO1xuICAgIH1cblxuICAgIHByaXZhdGUgY3JlYXRlRGF5R3JpZChtb250aDogbnVtYmVyLCB5ZWFyOiBudW1iZXIpOiB2b2lkIHtcblxuICAgICAgICAvLyB1cGRhdGUgdGhlIGhlYWRlclxuICAgICAgICB0aGlzLl9kYXRlcGlja2VyLnNldEhlYWRlcihtb250aHNbbW9udGhdICsgJyAnICsgeWVhcik7XG5cbiAgICAgICAgLy8gZmluZCB0aGUgbG93ZXIgYW5kIHVwcGVyIGJvdW5kYXJpZXNcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgMSk7XG4gICAgICAgIGNvbnN0IGVuZCA9IG5ldyBEYXRlKHllYXIsIG1vbnRoICsgMSwgMCk7XG5cbiAgICAgICAgLy8gd2UgYWx3YXlzIHdhbnQgdG8gc2hvdyBmcm9tIHRoZSBzdW5kYXkgLSB0aGlzIG1heSBpbmNsdWRlIHNob3dpbmcgc29tZSBkYXRlcyBmcm9tIHRoZSBwcmV2aW91cyBtb250aFxuICAgICAgICBzdGFydC5zZXREYXRlKHN0YXJ0LmdldERhdGUoKSAtIHN0YXJ0LmdldERheSgpKTtcblxuICAgICAgICAvLyB3ZSBhbHNvIHdhbnQgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIHJhbmdlIGVuZHMgb24gYSBzYXR1cmRheVxuICAgICAgICBlbmQuc2V0RGF0ZShlbmQuZ2V0RGF0ZSgpICsgKDYgLSBlbmQuZ2V0RGF5KCkpKTtcblxuICAgICAgICAvLyBjcmVhdGUgYW4gYXJyYXkgb2YgYWxsIHRoZSBkYXlzIHRvIGRpc3BsYXlcbiAgICAgICAgY29uc3QgZGF0ZXM6IERheVZpZXdJdGVtW10gPSBkYXRlUmFuZ2Uoc3RhcnQsIGVuZCkubWFwKGRhdGUgPT4gKHtcbiAgICAgICAgICAgIGRheTogZGF0ZS5nZXREYXRlKCksXG4gICAgICAgICAgICBtb250aDogZGF0ZS5nZXRNb250aCgpLFxuICAgICAgICAgICAgeWVhcjogZGF0ZS5nZXRGdWxsWWVhcigpLFxuICAgICAgICAgICAgZGF0ZTogZGF0ZSxcbiAgICAgICAgICAgIGlzVG9kYXk6IHRoaXMuaXNUb2RheShkYXRlKSxcbiAgICAgICAgICAgIGlzQWN0aXZlOiB0aGlzLmlzQWN0aXZlKGRhdGUpLFxuICAgICAgICAgICAgaXNDdXJyZW50TW9udGg6IGRhdGUuZ2V0TW9udGgoKSA9PT0gbW9udGhcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIC8vIHR1cm4gdGhlIGRhdGVzIGludG8gYSBncmlkXG4gICAgICAgIGNvbnN0IGl0ZW1zOiBEYXlWaWV3SXRlbVtdW10gPSBncmlkaWZ5KGRhdGVzLCA3KTtcblxuICAgICAgICB0aGlzLmdyaWQkLm5leHQoaXRlbXMpO1xuXG4gICAgICAgIC8vIGlmIG5vIGl0ZW0gaGFzIHlldCBiZWVuIGZvY3VzZWQgdGhlbiBmb2N1cyB0aGUgZmlyc3QgZGF5IG9mIHRoZSBtb250aFxuICAgICAgICBpZiAoKHRoaXMuX2RhdGVwaWNrZXIubW9kZURpcmVjdGlvbiA9PT0gTW9kZURpcmVjdGlvbi5Ob25lIHx8IHRoaXMuX2RhdGVwaWNrZXIubW9kZURpcmVjdGlvbiA9PT0gTW9kZURpcmVjdGlvbi5EZXNjZW5kKSAmJiB0aGlzLmZvY3VzZWQkLnZhbHVlID09PSBudWxsKSB7XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBzZWxlY3RlZCBpdGVtIGlzIHZpc2libGVcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkRGF5ID0gZGF0ZXMuZmluZChkYXkgPT4gZGF5LmlzQ3VycmVudE1vbnRoICYmIGRheS5pc0FjdGl2ZSk7XG5cbiAgICAgICAgICAgIGlmIChzZWxlY3RlZERheSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Rm9jdXMoc2VsZWN0ZWREYXkuZGF5LCBzZWxlY3RlZERheS5tb250aCwgc2VsZWN0ZWREYXkueWVhcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgLy8gZmluZCB0aGUgZmlyc3QgZGF5IG9mIHRoZSBtb250aFxuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0ID0gZGF0ZXMuZmluZChkYXRlID0+IGRhdGUuZGF5ID09PSAxKTtcbiAgICBcbiAgICAgICAgICAgICAgICAvLyBmb2N1cyB0aGUgZGF0ZVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0Rm9jdXMoZmlyc3QuZGF5LCBmaXJzdC5tb250aCwgZmlyc3QueWVhcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgKiBEZXRlcm1pbmUgd2hldGhlciBvciBub3QgYSBzcGVjaWZpYyBkYXRlIGlzIHRvZGF5XG4gICAqIEBwYXJhbSBkYXRlIFRoZSBkYXRlIHRvIGNoZWNrXG4gICAqL1xuICAgIHByaXZhdGUgaXNUb2RheShkYXRlOiBEYXRlKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBjb21wYXJlRGF5cyhuZXcgRGF0ZSgpLCBkYXRlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IGEgc3BlY2lmaWMgZGF0ZSBpcyB0aGUgc2VsZWN0ZWQgb25lXG4gICAgICogQHBhcmFtIGRhdGUgdGhlIGRhdGUgdG8gY2hlY2tcbiAgICAgKi9cbiAgICBwcml2YXRlIGlzQWN0aXZlKGRhdGU6IERhdGUpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGNvbXBhcmVEYXlzKHRoaXMuX2RhdGVwaWNrZXIuc2VsZWN0ZWQkLnZhbHVlLCBkYXRlKTtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF5Vmlld0l0ZW0ge1xuICAgIGRheTogbnVtYmVyO1xuICAgIG1vbnRoOiBudW1iZXI7XG4gICAgeWVhcjogbnVtYmVyO1xuICAgIGRhdGU6IERhdGU7XG4gICAgaXNUb2RheTogYm9vbGVhbjtcbiAgICBpc0FjdGl2ZTogYm9vbGVhbjtcbiAgICBpc0N1cnJlbnRNb250aDogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGb2N1c2VkRGF5SXRlbSB7XG4gICAgZGF5OiBudW1iZXI7XG4gICAgbW9udGg6IG51bWJlcjtcbiAgICB5ZWFyOiBudW1iZXI7XG59IiwiaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENvbXBvbmVudCwgT25EZXN0cm95IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBEYXRlUGlja2VySGVhZGVyRXZlbnQsIERhdGVUaW1lUGlja2VyU2VydmljZSB9IGZyb20gJy4uL2RhdGUtdGltZS1waWNrZXIuc2VydmljZSc7XG5pbXBvcnQgeyBEYXlWaWV3SXRlbSwgRGF5Vmlld1NlcnZpY2UgfSBmcm9tICcuL2RheS12aWV3LnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICd1eC1kYXRlLXRpbWUtcGlja2VyLWRheS12aWV3JyxcbiAgdGVtcGxhdGVVcmw6ICcuL2RheS12aWV3LmNvbXBvbmVudC5odG1sJyxcbiAgcHJvdmlkZXJzOiBbRGF5Vmlld1NlcnZpY2VdLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxufSlcbmV4cG9ydCBjbGFzcyBEYXlWaWV3Q29tcG9uZW50IGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICBwcml2YXRlIF9zdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgZGF0ZVBpY2tlcjogRGF0ZVRpbWVQaWNrZXJTZXJ2aWNlLCBwdWJsaWMgZGF5U2VydmljZTogRGF5Vmlld1NlcnZpY2UpIHtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb24gPSBkYXRlUGlja2VyLmhlYWRlckV2ZW50JFxuICAgICAgLnN1YnNjcmliZShldmVudCA9PiBldmVudCA9PT0gRGF0ZVBpY2tlckhlYWRlckV2ZW50Lk5leHQgPyB0aGlzLm5leHQoKSA6IHRoaXMucHJldmlvdXMoKSk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBOYXZpZ2F0ZSB0byB0aGUgcHJldmlvdXMgcGFnZSBvZiBkYXRlc1xuICAgKi9cbiAgcHJldmlvdXMoKTogdm9pZCB7XG4gICAgdGhpcy5kYXRlUGlja2VyLnNldFZpZXdwb3J0TW9udGgodGhpcy5kYXRlUGlja2VyLm1vbnRoJC52YWx1ZSAtIDEpO1xuICB9XG5cbiAgLyoqXG4gICAqIE5hdmlnYXRlIHRvIHRoZSBuZXh0IHBhZ2Ugb2YgZGF0ZXNcbiAgICovXG4gIG5leHQoKTogdm9pZCB7XG4gICAgdGhpcy5kYXRlUGlja2VyLnNldFZpZXdwb3J0TW9udGgodGhpcy5kYXRlUGlja2VyLm1vbnRoJC52YWx1ZSArIDEpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbGVjdCBhIHBhcnRpY3VsYXIgZGF0ZVxuICAgKiBAcGFyYW0gZGF0ZSB0aGUgZGF0ZSB0byBzZWxlY3RcbiAgICovXG4gIHNlbGVjdChkYXRlOiBEYXRlKTogdm9pZCB7XG4gICAgLy8gdXBkYXRlIHRoZSBjdXJyZW50IGRhdGUgb2JqZWN0XG4gICAgdGhpcy5kYXRlUGlja2VyLnNldERhdGUoZGF0ZS5nZXREYXRlKCksIGRhdGUuZ2V0TW9udGgoKSwgZGF0ZS5nZXRGdWxsWWVhcigpKTtcblxuICAgIC8vIGZvY3VzIHRoZSBuZXdseSBzZWxlY3RlZCBkYXRlXG4gICAgdGhpcy5kYXlTZXJ2aWNlLnNldEZvY3VzKGRhdGUuZ2V0RGF0ZSgpLCBkYXRlLmdldE1vbnRoKCksIGRhdGUuZ2V0RnVsbFllYXIoKSk7XG4gIH1cblxuICB0cmFja1dlZWtCeUZuKGluZGV4OiBudW1iZXIpOiBudW1iZXIge1xuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIHRyYWNrRGF5QnlGbihpbmRleDogbnVtYmVyLCBpdGVtOiBEYXlWaWV3SXRlbSk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGAkeyBpdGVtLmRheSB9ICR7IGl0ZW0ubW9udGggfSAkeyBpdGVtLnllYXIgfWA7XG4gIH1cblxuICBmb2N1c0RhdGUoaXRlbTogRGF5Vmlld0l0ZW0sIGRheU9mZnNldDogbnVtYmVyKTogdm9pZCB7XG5cbiAgICAvLyBkZXRlcm1pbmUgdGhlIGRhdGUgb2YgdGhlIGRheVxuICAgIGNvbnN0IHRhcmdldCA9IG5ldyBEYXRlKGl0ZW0uZGF0ZS5zZXREYXRlKGl0ZW0uZGF0ZS5nZXREYXRlKCkgKyBkYXlPZmZzZXQpKTtcblxuICAgIC8vIGlkZW50aWZ5IHdoaWNoIGRhdGUgc2hvdWxkIGJlIGZvY3VzZWRcbiAgICB0aGlzLmRheVNlcnZpY2Uuc2V0Rm9jdXModGFyZ2V0LmdldERhdGUoKSwgdGFyZ2V0LmdldE1vbnRoKCksIHRhcmdldC5nZXRGdWxsWWVhcigpKTtcbiAgfVxuXG4gIGdldFRhYmJhYmxlKGl0ZW06IERheVZpZXdJdGVtKTogYm9vbGVhbiB7XG4gICAgY29uc3QgZm9jdXNlZCA9IHRoaXMuZGF5U2VydmljZS5mb2N1c2VkJC52YWx1ZTtcbiAgICBjb25zdCBncmlkID0gdGhpcy5kYXlTZXJ2aWNlLmdyaWQkLnZhbHVlO1xuXG4gICAgLy8gaWYgdGhlcmUgaXMgYSBmb2N1c2VkIG1vbnRoIGNoZWNrIGlmIHRoaXMgaXMgaXRcbiAgICBpZiAoZm9jdXNlZCkge1xuXG4gICAgICAvLyBjaGVjayBpZiB0aGUgZm9jdXNlZCBkYXkgaXMgdmlzaWJsZVxuICAgICAgY29uc3QgaXNGb2N1c2VkRGF5VmlzaWJsZSA9ICEhZ3JpZC5maW5kKHJvdyA9PiAhIXJvdy5maW5kKF9pdGVtID0+IF9pdGVtLmRheSA9PT0gZm9jdXNlZC5kYXkgJiYgX2l0ZW0ubW9udGggPT09IGZvY3VzZWQubW9udGggJiYgX2l0ZW0ueWVhciA9PT0gZm9jdXNlZC55ZWFyKSk7XG5cbiAgICAgIGlmIChpc0ZvY3VzZWREYXlWaXNpYmxlKSB7XG4gICAgICAgIHJldHVybiBmb2N1c2VkLmRheSA9PT0gaXRlbS5kYXkgJiYgZm9jdXNlZC5tb250aCA9PT0gaXRlbS5tb250aCAmJiBmb2N1c2VkLnllYXIgPT09IGl0ZW0ueWVhcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiB0aGVyZSBpcyBubyBmb2N1c2FibGUgZGF5IHRoZW4gY2hlY2sgaWYgdGhlcmUgaXMgYSBzZWxlY3RlZCBkYXlcbiAgICBjb25zdCBpc1NlbGVjdGVkRGF5VmlzaWJsZSA9ICEhZ3JpZC5maW5kKHJvdyA9PiAhIXJvdy5maW5kKGRheSA9PiBkYXkuaXNBY3RpdmUpKTtcblxuICAgIGlmIChpc1NlbGVjdGVkRGF5VmlzaWJsZSkge1xuICAgICAgICByZXR1cm4gaXRlbS5pc0FjdGl2ZTtcbiAgICB9XG5cbiAgICAvLyBvdGhlcndpc2UgbWFrZSB0aGUgZmlyc3QgZGF5IHRhYmJhYmxlXG4gICAgcmV0dXJuIGl0ZW0uZGF5ID09PSAxO1xuICB9XG5cbn0iLCJpbXBvcnQgeyBDb21wb25lbnQsIENoYW5nZURldGVjdGlvblN0cmF0ZWd5IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcy9PYnNlcnZhYmxlJztcbmltcG9ydCB7IG1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IERhdGVQaWNrZXJNb2RlLCBEYXRlVGltZVBpY2tlclNlcnZpY2UgfSBmcm9tICcuLi9kYXRlLXRpbWUtcGlja2VyLnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LWRhdGUtdGltZS1waWNrZXItaGVhZGVyJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vaGVhZGVyLmNvbXBvbmVudC5odG1sJyxcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxufSlcbmV4cG9ydCBjbGFzcyBIZWFkZXJDb21wb25lbnQge1xuXG4gICAgY2FuQXNjZW5kJDogT2JzZXJ2YWJsZTxib29sZWFuPiA9IHRoaXMuZGF0ZXBpY2tlci5tb2RlJC5waXBlKG1hcChtb2RlID0+IG1vZGUgIT09IERhdGVQaWNrZXJNb2RlLlllYXIpKTtcbiAgICBcbiAgICBtb2RlJDogT2JzZXJ2YWJsZTxzdHJpbmc+ID0gdGhpcy5kYXRlcGlja2VyLm1vZGUkLnBpcGUobWFwKG1vZGUgPT4ge1xuICAgICAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgICAgICAgIGNhc2UgRGF0ZVBpY2tlck1vZGUuRGF5OlxuICAgICAgICAgICAgICAgIHJldHVybiAnRGF5JztcbiAgICAgICAgICAgIGNhc2UgRGF0ZVBpY2tlck1vZGUuTW9udGg6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdNb250aCc7XG4gICAgICAgICAgICBjYXNlIERhdGVQaWNrZXJNb2RlLlllYXI6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdZZWFyJztcbiAgICAgICAgfVxuICAgIH0pKTtcblxuICAgIGhlYWRlckFyaWEkOiBPYnNlcnZhYmxlPHN0cmluZz4gPSB0aGlzLmRhdGVwaWNrZXIubW9kZSQucGlwZShtYXAobW9kZSA9PiB7XG4gICAgICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgICAgICAgY2FzZSBEYXRlUGlja2VyTW9kZS5EYXk6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdTd2l0Y2ggdG8gc2hvdyBtb250aHMgaW4gdGhlIHllYXInO1xuICAgICAgICAgICAgY2FzZSBEYXRlUGlja2VyTW9kZS5Nb250aDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1N3aXRjaCB0byBzaG93IHllYXJzIGluIHRoZSBkZWNhZGUnO1xuICAgICAgICAgICAgY2FzZSBEYXRlUGlja2VyTW9kZS5ZZWFyOlxuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgIH0pKTtcblxuICAgIHByZXZpb3VzQXJpYSQ6IE9ic2VydmFibGU8c3RyaW5nPiA9IHRoaXMuZGF0ZXBpY2tlci5tb2RlJC5waXBlKG1hcChtb2RlID0+IHtcbiAgICAgICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICAgICAgICBjYXNlIERhdGVQaWNrZXJNb2RlLkRheTpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1ByZXZpb3VzIG1vbnRoJztcbiAgICAgICAgICAgIGNhc2UgRGF0ZVBpY2tlck1vZGUuTW9udGg6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdQcmV2aW91cyB5ZWFyJztcbiAgICAgICAgICAgIGNhc2UgRGF0ZVBpY2tlck1vZGUuWWVhcjpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1ByZXZpb3VzIGRlY2FkZSc7XG4gICAgICAgIH1cbiAgICB9KSk7XG5cbiAgICBuZXh0QXJpYSQ6IE9ic2VydmFibGU8c3RyaW5nPiA9IHRoaXMuZGF0ZXBpY2tlci5tb2RlJC5waXBlKG1hcChtb2RlID0+IHtcbiAgICAgICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICAgICAgICBjYXNlIERhdGVQaWNrZXJNb2RlLkRheTpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ05leHQgbW9udGgnO1xuICAgICAgICAgICAgY2FzZSBEYXRlUGlja2VyTW9kZS5Nb250aDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ05leHQgeWVhcic7XG4gICAgICAgICAgICBjYXNlIERhdGVQaWNrZXJNb2RlLlllYXI6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdOZXh0IGRlY2FkZSc7XG4gICAgICAgIH1cbiAgICB9KSk7XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZGF0ZXBpY2tlcjogRGF0ZVRpbWVQaWNrZXJTZXJ2aWNlKSB7IH1cblxuICAgIHByZXZpb3VzKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmRhdGVwaWNrZXIuZ29Ub1ByZXZpb3VzKCk7XG4gICAgfVxuXG4gICAgYXNjZW5kKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmRhdGVwaWNrZXIuZ29Ub1BhcmVudE1vZGUoKTtcbiAgICB9XG5cbiAgICBuZXh0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLmRhdGVwaWNrZXIuZ29Ub05leHQoKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgSW5qZWN0YWJsZSwgT25EZXN0cm95IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QgfSBmcm9tICdyeGpzL0JlaGF2aW9yU3ViamVjdCc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBEYXRlVGltZVBpY2tlclNlcnZpY2UsIE1vZGVEaXJlY3Rpb24gfSBmcm9tICcuLi9kYXRlLXRpbWUtcGlja2VyLnNlcnZpY2UnO1xuaW1wb3J0IHsgZ3JpZGlmeSwgbW9udGhzU2hvcnQsIHJhbmdlIH0gZnJvbSAnLi4vZGF0ZS10aW1lLXBpY2tlci51dGlscyc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBNb250aFZpZXdTZXJ2aWNlIGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICAgIGdyaWQkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxNb250aFZpZXdJdGVtW11bXT4oW1tdXSk7XG4gICAgZm9jdXNlZCQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PEZvY3VzZWRNb250aEl0ZW0+KG51bGwpO1xuXG4gICAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9kYXRlcGlja2VyOiBEYXRlVGltZVBpY2tlclNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gX2RhdGVwaWNrZXIueWVhciQuc3Vic2NyaWJlKHllYXIgPT4gdGhpcy5jcmVhdGVNb250aEdyaWQoeWVhcikpO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG5cbiAgICBzZXRGb2N1cyhtb250aDogbnVtYmVyLCB5ZWFyOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5mb2N1c2VkJC5uZXh0KHsgbW9udGg6IG1vbnRoLCB5ZWFyOiB5ZWFyIH0pO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgdmlld3BvcnQgdG8gZW5zdXJlIGZvY3VzZWQgbW9udGggaXMgdmlzaWJsZVxuICAgICAgICB0aGlzLl9kYXRlcGlja2VyLnNldFZpZXdwb3J0WWVhcih5ZWFyKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGNyZWF0ZU1vbnRoR3JpZCh5ZWFyOiBudW1iZXIpOiB2b2lkIHtcblxuICAgICAgICAvLyB1cGRhdGUgdGhlIGhlYWRlclxuICAgICAgICB0aGlzLl9kYXRlcGlja2VyLnNldEhlYWRlcih5ZWFyLnRvU3RyaW5nKCkpO1xuXG4gICAgICAgIC8vIGdldCB0aGUgY3VycmVudCB5ZWFyIGFuZCBtb250aFxuICAgICAgICBjb25zdCBjdXJyZW50TW9udGggPSBuZXcgRGF0ZSgpLmdldE1vbnRoKCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRZZWFyID0gbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpO1xuXG4gICAgICAgIC8vIGdldCB0aGUgY3VycmVudGx5IHNlbGVjdGVkIG1vbnRoXG4gICAgICAgIGNvbnN0IGFjdGl2ZU1vbnRoID0gdGhpcy5fZGF0ZXBpY2tlci5zZWxlY3RlZCQudmFsdWUuZ2V0TW9udGgoKTtcbiAgICAgICAgY29uc3QgYWN0aXZlWWVhciA9IHRoaXMuX2RhdGVwaWNrZXIuc2VsZWN0ZWQkLnZhbHVlLmdldEZ1bGxZZWFyKCk7XG5cbiAgICAgICAgLy8gY3JlYXRlIGEgNHgzIGdyaWQgb2YgbW9udGggbnVtYmVyc1xuICAgICAgICBjb25zdCBtb250aHM6IE1vbnRoVmlld0l0ZW1bXSA9IHJhbmdlKDAsIDExKS5tYXAobW9udGggPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBtb250aHNTaG9ydFttb250aF0sXG4gICAgICAgICAgICAgICAgbW9udGg6IG1vbnRoLFxuICAgICAgICAgICAgICAgIHllYXI6IHllYXIsXG4gICAgICAgICAgICAgICAgaXNDdXJyZW50TW9udGg6IHllYXIgPT09IGN1cnJlbnRZZWFyICYmIG1vbnRoID09PSBjdXJyZW50TW9udGgsXG4gICAgICAgICAgICAgICAgaXNBY3RpdmVNb250aDogeWVhciA9PT0gYWN0aXZlWWVhciAmJiBtb250aCA9PT0gYWN0aXZlTW9udGhcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIG1hcCB0aGVzZSB0byB0aGUgYXBwcm9wcmlhdGUgZm9ybWF0XG4gICAgICAgIGNvbnN0IGl0ZW1zOiBNb250aFZpZXdJdGVtW11bXSA9IGdyaWRpZnkobW9udGhzLCA0KTtcblxuICAgICAgICAvLyB1cGRhdGUgdGhlIGdyaWRcbiAgICAgICAgdGhpcy5ncmlkJC5uZXh0KGl0ZW1zKTtcblxuICAgICAgICAvLyBpZiB0aGVyZSBpcyBubyBmb2N1c2VkIG1vbnRoIHNlbGVjdCB0aGUgZmlyc3Qgb25lXG4gICAgICAgIGlmICh0aGlzLl9kYXRlcGlja2VyLm1vZGVEaXJlY3Rpb24gPT09IE1vZGVEaXJlY3Rpb24uRGVzY2VuZCAmJiB0aGlzLmZvY3VzZWQkLnZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBzZWxlY3RlZCBtb250aCBpcyBpbiB2aWV3XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RlZE1vbnRoID0gbW9udGhzLmZpbmQobW9udGggPT4gbW9udGguaXNBY3RpdmVNb250aCk7XG5cbiAgICAgICAgICAgIHRoaXMuc2V0Rm9jdXMoc2VsZWN0ZWRNb250aCA/IHNlbGVjdGVkTW9udGgubW9udGggOiAwLCB5ZWFyKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBNb250aFZpZXdJdGVtIHtcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgbW9udGg6IG51bWJlcjtcbiAgICB5ZWFyOiBudW1iZXI7XG4gICAgaXNDdXJyZW50TW9udGg6IGJvb2xlYW47XG4gICAgaXNBY3RpdmVNb250aDogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGb2N1c2VkTW9udGhJdGVtIHtcbiAgICBtb250aDogbnVtYmVyO1xuICAgIHllYXI6IG51bWJlcjtcbn0iLCJpbXBvcnQgeyBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgQ29tcG9uZW50LCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IERhdGVQaWNrZXJIZWFkZXJFdmVudCwgRGF0ZVRpbWVQaWNrZXJTZXJ2aWNlIH0gZnJvbSAnLi4vZGF0ZS10aW1lLXBpY2tlci5zZXJ2aWNlJztcbmltcG9ydCB7IE1vbnRoVmlld0l0ZW0sIE1vbnRoVmlld1NlcnZpY2UgfSBmcm9tICcuL21vbnRoLXZpZXcuc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtZGF0ZS10aW1lLXBpY2tlci1tb250aC12aWV3JyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vbW9udGgtdmlldy5jb21wb25lbnQuaHRtbCcsXG4gICAgcHJvdmlkZXJzOiBbTW9udGhWaWV3U2VydmljZV0sXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgTW9udGhWaWV3Q29tcG9uZW50IGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICAgIHByaXZhdGUgX3N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfZGF0ZVBpY2tlcjogRGF0ZVRpbWVQaWNrZXJTZXJ2aWNlLCBwdWJsaWMgbW9udGhTZXJ2aWNlOiBNb250aFZpZXdTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IF9kYXRlUGlja2VyLmhlYWRlckV2ZW50JFxuICAgICAgICAgICAgLnN1YnNjcmliZShldmVudCA9PiBldmVudCA9PT0gRGF0ZVBpY2tlckhlYWRlckV2ZW50Lk5leHQgPyB0aGlzLm5leHQoKSA6IHRoaXMucHJldmlvdXMoKSk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdvIHRvIHRoZSBwcmV2aW91cyB5ZWFyXG4gICAgICovXG4gICAgcHJldmlvdXMoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2RhdGVQaWNrZXIuc2V0Vmlld3BvcnRZZWFyKHRoaXMuX2RhdGVQaWNrZXIueWVhciQudmFsdWUgLSAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHbyB0byB0aGUgbmV4dCB5ZWFyXG4gICAgICovXG4gICAgbmV4dCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fZGF0ZVBpY2tlci5zZXRWaWV3cG9ydFllYXIodGhpcy5fZGF0ZVBpY2tlci55ZWFyJC52YWx1ZSArIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbGVjdCBhIG1vbnRoIGluIHRoZSBjYWxlbmRhclxuICAgICAqIEBwYXJhbSBtb250aCB0aGUgaW5kZXggb2YgdGhlIG1vbnRoIHRvIHNlbGVjdFxuICAgICAqL1xuICAgIHNlbGVjdChtb250aDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2RhdGVQaWNrZXIuc2V0Vmlld3BvcnRNb250aChtb250aCk7XG5cbiAgICAgICAgLy8gc2hvdyB0aGUgZGF5IHBpY2tlclxuICAgICAgICB0aGlzLl9kYXRlUGlja2VyLmdvVG9DaGlsZE1vZGUoKTtcbiAgICB9XG5cbiAgICBmb2N1c01vbnRoKGl0ZW06IE1vbnRoVmlld0l0ZW0sIG1vbnRoT2Zmc2V0OiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgbGV0IHRhcmdldE1vbnRoID0gaXRlbS5tb250aCArIG1vbnRoT2Zmc2V0O1xuICAgICAgICBsZXQgdGFyZ2V0WWVhciA9IGl0ZW0ueWVhcjtcblxuICAgICAgICBpZiAodGFyZ2V0TW9udGggPCAwKSB7XG4gICAgICAgICAgICB0YXJnZXRNb250aCArPSAxMjtcbiAgICAgICAgICAgIHRhcmdldFllYXIgLT0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0YXJnZXRNb250aCA+PSAxMikge1xuICAgICAgICAgICAgdGFyZ2V0TW9udGggLT0gMTI7XG4gICAgICAgICAgICB0YXJnZXRZZWFyICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1vbnRoU2VydmljZS5zZXRGb2N1cyh0YXJnZXRNb250aCwgdGFyZ2V0WWVhcik7XG4gICAgfVxuXG4gICAgdHJhY2tSb3dCeUZuKGluZGV4OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuXG4gICAgdHJhY2tNb250aEJ5Rm4oaW5kZXg6IG51bWJlciwgaXRlbTogTW9udGhWaWV3SXRlbSk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBgJHtpdGVtLm1vbnRofSAke2l0ZW0ueWVhcn1gO1xuICAgIH1cblxuICAgIGdldFRhYmJhYmxlKGl0ZW06IE1vbnRoVmlld0l0ZW0pOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgZm9jdXNlZCA9IHRoaXMubW9udGhTZXJ2aWNlLmZvY3VzZWQkLnZhbHVlO1xuICAgICAgICBjb25zdCBncmlkID0gdGhpcy5tb250aFNlcnZpY2UuZ3JpZCQudmFsdWU7XG5cbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgYSBmb2N1c2VkIG1vbnRoIGNoZWNrIGlmIHRoaXMgaXMgaXRcbiAgICAgICAgaWYgKGZvY3VzZWQpIHtcblxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIGZvY3VzZWQgbW9udGggaXMgdmlzaWJsZVxuICAgICAgICAgICAgY29uc3QgaXNGb2N1c2VkTW9udGhWaXNpYmxlID0gISFncmlkLmZpbmQocm93ID0+ICEhcm93LmZpbmQoX2l0ZW0gPT4gX2l0ZW0ubW9udGggPT09IGZvY3VzZWQubW9udGggJiYgX2l0ZW0ueWVhciA9PT0gZm9jdXNlZC55ZWFyKSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChpc0ZvY3VzZWRNb250aFZpc2libGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9jdXNlZC5tb250aCA9PT0gaXRlbS5tb250aCAmJiBmb2N1c2VkLnllYXIgPT09IGl0ZW0ueWVhcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIGZvY3VzYWJsZSBtb250aCB0aGVuIGNoZWNrIGlmIHRoZXJlIGlzIGEgc2VsZWN0ZWQgbW9udGhcbiAgICAgICAgY29uc3QgaXNTZWxlY3RlZE1vbnRoVmlzaWJsZSA9ICEhZ3JpZC5maW5kKHJvdyA9PiAhIXJvdy5maW5kKG1vbnRoID0+IG1vbnRoLmlzQWN0aXZlTW9udGgpKTtcblxuICAgICAgICBpZiAoaXNTZWxlY3RlZE1vbnRoVmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0uaXNBY3RpdmVNb250aDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG90aGVyd2lzZSBtYWtlIHRoZSBmaXJzdCBtb250aCB0YWJiYWJsZVxuICAgICAgICByZXR1cm4gaXRlbS5tb250aCA9PT0gMDtcbiAgICB9XG59IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRGF0ZVRpbWVQaWNrZXJTZXJ2aWNlIH0gZnJvbSAnLi4vZGF0ZS10aW1lLXBpY2tlci5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1kYXRlLXRpbWUtcGlja2VyLXRpbWUtdmlldycsXG4gICAgdGVtcGxhdGVVcmw6ICcuL3RpbWUtdmlldy5jb21wb25lbnQuaHRtbCcsXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgVGltZVZpZXdDb21wb25lbnQge1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIGRhdGVwaWNrZXI6IERhdGVUaW1lUGlja2VyU2VydmljZSkgeyB9XG5cbiAgICBzZWxlY3RUaW1lem9uZShuYW1lOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgdGltZXpvbmVzID0gdGhpcy5kYXRlcGlja2VyLnRpbWV6b25lcyQudmFsdWU7XG4gICAgICAgIFxuICAgICAgICAvLyBmaW5kIG1hdGNoaW5nIHRpbWV6b25lXG4gICAgICAgIGNvbnN0IHRpbWV6b25lID0gdGltZXpvbmVzLmZpbmQoX3RpbWV6b25lID0+IF90aW1lem9uZS5uYW1lID09PSBuYW1lKTtcblxuICAgICAgICBpZiAodGltZXpvbmUpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0ZXBpY2tlci5zZXRUaW1lem9uZSh0aW1lem9uZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpbmNyZW1lbnRUaW1lem9uZSgpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgdGltZXpvbmUgPSB0aGlzLmRhdGVwaWNrZXIudGltZXpvbmUkLnZhbHVlO1xuICAgICAgICBjb25zdCB0aW1lem9uZXMgPSB0aGlzLmRhdGVwaWNrZXIudGltZXpvbmVzJC52YWx1ZTtcblxuICAgICAgICBjb25zdCBjdXJyZW50Wm9uZSA9IHRpbWV6b25lcy5maW5kSW5kZXgoem9uZSA9PiB6b25lLm5hbWUgPT09IHRpbWV6b25lLm5hbWUgJiYgem9uZS5vZmZzZXQgPT09IHRpbWV6b25lLm9mZnNldCk7XG5cbiAgICAgICAgLy8gdHJ5IHRvIGdldCB0aGUgcHJldmlvdXMgem9uZVxuICAgICAgICB0aGlzLmRhdGVwaWNrZXIuc2V0VGltZXpvbmUodGltZXpvbmVzW2N1cnJlbnRab25lICsgMV0gPyB0aW1lem9uZXNbY3VycmVudFpvbmUgKyAxXSA6IHRpbWV6b25lc1tjdXJyZW50Wm9uZV0pO1xuICAgIH1cblxuICAgIGRlY3JlbWVudFRpbWV6b25lKCk6IHZvaWQge1xuICAgICAgICBjb25zdCB0aW1lem9uZSA9IHRoaXMuZGF0ZXBpY2tlci50aW1lem9uZSQudmFsdWU7XG4gICAgICAgIGNvbnN0IHRpbWV6b25lcyA9IHRoaXMuZGF0ZXBpY2tlci50aW1lem9uZXMkLnZhbHVlO1xuXG4gICAgICAgIGNvbnN0IGN1cnJlbnRab25lID0gdGltZXpvbmVzLmZpbmRJbmRleCh6b25lID0+IHpvbmUubmFtZSA9PT0gdGltZXpvbmUubmFtZSAmJiB6b25lLm9mZnNldCA9PT0gdGltZXpvbmUub2Zmc2V0KTtcblxuICAgICAgICAvLyB0cnkgdG8gZ2V0IHRoZSBwcmV2aW91cyB6b25lXG4gICAgICAgIHRoaXMuZGF0ZXBpY2tlci5zZXRUaW1lem9uZSh0aW1lem9uZXNbY3VycmVudFpvbmUgLSAxXSA/IHRpbWV6b25lc1tjdXJyZW50Wm9uZSAtIDFdIDogdGltZXpvbmVzW2N1cnJlbnRab25lXSk7XG4gICAgfVxufSIsImltcG9ydCB7IEluamVjdGFibGUsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcy9CZWhhdmlvclN1YmplY3QnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcy9TdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgRGF0ZVBpY2tlckhlYWRlckV2ZW50LCBEYXRlVGltZVBpY2tlclNlcnZpY2UgfSBmcm9tICcuLi9kYXRlLXRpbWUtcGlja2VyLnNlcnZpY2UnO1xuaW1wb3J0IHsgZ3JpZGlmeSwgcmFuZ2UgfSBmcm9tICcuLi9kYXRlLXRpbWUtcGlja2VyLnV0aWxzJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFllYXJWaWV3U2VydmljZSBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG5cbiAgICBncmlkJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8WWVhclZpZXdJdGVtW11bXT4oW1tdXSk7XG4gICAgZm9jdXNlZCQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PG51bWJlcj4obnVsbCk7XG5cbiAgICBwcml2YXRlIF95ZWFyOiBudW1iZXIgPSBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCk7XG5cbiAgICBwcml2YXRlIF9zdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9kYXRlcGlja2VyOiBEYXRlVGltZVBpY2tlclNlcnZpY2UpIHtcbiAgICAgICAgY29uc3QgeWVhciA9IF9kYXRlcGlja2VyLnllYXIkLnN1YnNjcmliZShfeWVhciA9PiB0aGlzLmNyZWF0ZVllYXJHcmlkKF95ZWFyKSk7XG5cbiAgICAgICAgY29uc3QgZXZlbnQgPSBfZGF0ZXBpY2tlci5oZWFkZXJFdmVudCRcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoX2V2ZW50ID0+IF9ldmVudCA9PT0gRGF0ZVBpY2tlckhlYWRlckV2ZW50Lk5leHQgPyB0aGlzLmdvVG9OZXh0RGVjYWRlKCkgOiB0aGlzLmdvVG9QcmV2aW91c0RlY2FkZSgpKTtcblxuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24uYWRkKHllYXIpO1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24uYWRkKGV2ZW50KTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuXG4gICAgc2V0Rm9jdXMoeWVhcjogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZm9jdXNlZCQubmV4dCh5ZWFyKTtcbiAgICAgICAgdGhpcy5jcmVhdGVZZWFyR3JpZCh5ZWFyKTtcbiAgICB9XG5cbiAgICBnb1RvUHJldmlvdXNEZWNhZGUoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuY3JlYXRlWWVhckdyaWQodGhpcy5feWVhciAtIDEwKTtcbiAgICB9XG5cbiAgICBnb1RvTmV4dERlY2FkZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5jcmVhdGVZZWFyR3JpZCh0aGlzLl95ZWFyICsgMTApO1xuICAgIH1cblxuICAgIHByaXZhdGUgY3JlYXRlWWVhckdyaWQoeWVhcjogbnVtYmVyID0gdGhpcy5feWVhcik6IHZvaWQge1xuXG4gICAgICAgIHRoaXMuX3llYXIgPSB5ZWFyO1xuXG4gICAgICAgIC8vIGdldCB0aGUgeWVhcnMgdG8gZGlzcGxheVxuICAgICAgICBjb25zdCBkZWNhZGUgPSB0aGlzLmdldERlY2FkZSh5ZWFyKTtcblxuICAgICAgICBjb25zdCBjdXJyZW50WWVhciA9IG5ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKTtcblxuICAgICAgICAvLyBwcm9kdWNlIGl0ZW1zIGluIHRoZSBjb3JyZWN0IGZvcm1hdFxuICAgICAgICBjb25zdCBpdGVtczogWWVhclZpZXdJdGVtW10gPSBkZWNhZGUucmFuZ2UubWFwKF95ZWFyID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgeWVhcjogX3llYXIsXG4gICAgICAgICAgICAgICAgaXNDdXJyZW50WWVhcjogX3llYXIgPT09IGN1cnJlbnRZZWFyLFxuICAgICAgICAgICAgICAgIGlzQWN0aXZlWWVhcjogX3llYXIgPT09IHRoaXMuX2RhdGVwaWNrZXIueWVhciQudmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgaGVhZGVyIHRleHRcbiAgICAgICAgdGhpcy5fZGF0ZXBpY2tlci5zZXRIZWFkZXIoZGVjYWRlLnN0YXJ0ICsgJyAtICcgKyBkZWNhZGUuZW5kKTtcblxuICAgICAgICAvLyBjcmVhdGUgdGhlIGdyaWRcbiAgICAgICAgdGhpcy5ncmlkJC5uZXh0KGdyaWRpZnkoaXRlbXMsIDQpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHllYXJzIGluIHRoZSBjdXJyZW50IGRlY2FkZSB0byBkaXNwbGF5XG4gICAgICovXG4gICAgcHJpdmF0ZSBnZXREZWNhZGUoeWVhcjogbnVtYmVyKTogWWVhclJhbmdlIHtcblxuICAgICAgICAvLyBmaWd1cmUgdGhlIHN0YXJ0IGFuZCBlbmQgcG9pbnRzXG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gKHllYXIgLSAoeWVhciAlIDEwKSk7XG4gICAgICAgIGNvbnN0IGVuZCA9IHN0YXJ0ICsgOTtcblxuICAgICAgICAvLyBjcmVhdGUgYW4gYXJyYXkgY29udGFpbmluZyBhbGwgdGhlIG51bWJlcnMgYmV0d2VlbiB0aGUgc3RhcnQgYW5kIGVuZCBwb2ludHNcbiAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCwgcmFuZ2U6IHJhbmdlKHN0YXJ0LCBlbmQpIH07XG4gICAgfVxufVxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgWWVhclJhbmdlIHtcbiAgICBzdGFydDogbnVtYmVyO1xuICAgIGVuZDogbnVtYmVyO1xuICAgIHJhbmdlOiBudW1iZXJbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBZZWFyVmlld0l0ZW0ge1xuICAgIHllYXI6IG51bWJlcjtcbiAgICBpc0N1cnJlbnRZZWFyOiBib29sZWFuO1xuICAgIGlzQWN0aXZlWWVhcjogYm9vbGVhbjtcbn0iLCJpbXBvcnQgeyBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBEYXRlVGltZVBpY2tlclNlcnZpY2UgfSBmcm9tICcuLi9kYXRlLXRpbWUtcGlja2VyLnNlcnZpY2UnO1xuaW1wb3J0IHsgWWVhclZpZXdJdGVtLCBZZWFyVmlld1NlcnZpY2UgfSBmcm9tICcuL3llYXItdmlldy5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAndXgtZGF0ZS10aW1lLXBpY2tlci15ZWFyLXZpZXcnLFxuICB0ZW1wbGF0ZVVybDogJy4veWVhci12aWV3LmNvbXBvbmVudC5odG1sJyxcbiAgcHJvdmlkZXJzOiBbWWVhclZpZXdTZXJ2aWNlXSxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgWWVhclZpZXdDb21wb25lbnQge1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX2RhdGVQaWNrZXI6IERhdGVUaW1lUGlja2VyU2VydmljZSwgcHVibGljIHllYXJTZXJ2aWNlOiBZZWFyVmlld1NlcnZpY2UpIHt9XG5cbiAgc2VsZWN0KHllYXI6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMuX2RhdGVQaWNrZXIuc2V0Vmlld3BvcnRZZWFyKHllYXIpO1xuXG4gICAgLy8gc2hvdyB0aGUgbW9udGggcGlja2VyXG4gICAgdGhpcy5fZGF0ZVBpY2tlci5nb1RvQ2hpbGRNb2RlKCk7XG4gIH1cblxuICBmb2N1c1llYXIoaXRlbTogWWVhclZpZXdJdGVtLCB5ZWFyT2Zmc2V0OiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLnllYXJTZXJ2aWNlLnNldEZvY3VzKGl0ZW0ueWVhciArIHllYXJPZmZzZXQpO1xuICB9XG5cbiAgdHJhY2tSb3dCeUZuKGluZGV4OiBudW1iZXIpOiBudW1iZXIge1xuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIHRyYWNrWWVhckJ5Rm4oaW5kZXg6IG51bWJlciwgaXRlbTogWWVhclZpZXdJdGVtKTogbnVtYmVyIHtcbiAgICByZXR1cm4gaXRlbS55ZWFyO1xuICB9XG5cbiAgZ2V0VGFiYmFibGUoaXRlbTogWWVhclZpZXdJdGVtKTogYm9vbGVhbiB7XG4gICAgY29uc3QgZm9jdXNlZCA9IHRoaXMueWVhclNlcnZpY2UuZm9jdXNlZCQudmFsdWU7XG4gICAgY29uc3QgZ3JpZCA9IHRoaXMueWVhclNlcnZpY2UuZ3JpZCQudmFsdWU7XG5cbiAgICAvLyBpZiB0aGVyZSBpcyBhIGZvY3VzZWQgeWVhciBjaGVjayBpZiB0aGlzIGlzIGl0XG4gICAgaWYgKGZvY3VzZWQpIHtcblxuICAgICAgICAvLyBjaGVjayBpZiB0aGUgZm9jdXNlZCB5ZWFyIGlzIHZpc2libGVcbiAgICAgICAgY29uc3QgaXNGb2N1c2VkWWVhclZpc2libGUgPSAhIWdyaWQuZmluZChyb3cgPT4gISFyb3cuZmluZChfaXRlbSA9PiBfaXRlbS55ZWFyID09PSBmb2N1c2VkKSk7XG5cbiAgICAgICAgaWYgKGlzRm9jdXNlZFllYXJWaXNpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gZm9jdXNlZCA9PT0gaXRlbS55ZWFyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlcmUgaXMgbm8gZm9jdXNhYmxlIHllYXIgdGhlbiBjaGVjayBpZiB0aGVyZSBpcyBhIHNlbGVjdGVkIHllYXJcbiAgICBjb25zdCBpc1NlbGVjdGVkWWVhclZpc2libGUgPSAhIWdyaWQuZmluZChyb3cgPT4gISFyb3cuZmluZCh5ZWFyID0+IHllYXIuaXNBY3RpdmVZZWFyKSk7XG5cbiAgICBpZiAoaXNTZWxlY3RlZFllYXJWaXNpYmxlKSB7XG4gICAgICAgIHJldHVybiBpdGVtLmlzQWN0aXZlWWVhcjtcbiAgICB9XG5cbiAgICAvLyBvdGhlcndpc2UgbWFrZSB0aGUgZmlyc3QgbW9udGggdGFiYmFibGVcbiAgICByZXR1cm4gZ3JpZFswXVswXS55ZWFyID09PSBpdGVtLnllYXI7XG59XG5cbn1cbiIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbZm9jdXNJZl0nXG59KVxuZXhwb3J0IGNsYXNzIEZvY3VzSWZEaXJlY3RpdmUge1xuXG4gICAgQElucHV0KCkgZm9jdXNJZkRlbGF5OiBudW1iZXIgPSAwO1xuICAgIEBJbnB1dCgpIGZvY3VzSWZTY3JvbGw6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgQElucHV0KClcbiAgICBzZXQgZm9jdXNJZihmb2N1czogYm9vbGVhbikge1xuXG4gICAgICAgIC8vIGlmIGEgdGltZW91dCBpcyBwZW5kaW5nIHRoZW4gY2FuY2VsIGl0XG4gICAgICAgIGlmICghZm9jdXMgJiYgdGhpcy5fdGltZW91dCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy5fdGltZW91dCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZm9jdXMgJiYgdGhpcy5fdGltZW91dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuZm9jdXMoeyBwcmV2ZW50U2Nyb2xsOiAhdGhpcy5mb2N1c0lmU2Nyb2xsIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgfSwgdGhpcy5mb2N1c0lmRGVsYXkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfdGltZW91dDogbnVtYmVyID0gbnVsbDtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYpIHsgfVxufSIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGb2N1c0lmRGlyZWN0aXZlIH0gZnJvbSAnLi9mb2N1cy1pZi5kaXJlY3RpdmUnO1xuXG5cbkBOZ01vZHVsZSh7XG4gICAgZXhwb3J0czogW0ZvY3VzSWZEaXJlY3RpdmVdLFxuICAgIGRlY2xhcmF0aW9uczogW0ZvY3VzSWZEaXJlY3RpdmVdXG59KVxuZXhwb3J0IGNsYXNzIEZvY3VzSWZNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZvcm1zTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgU3BpbkJ1dHRvbk1vZHVsZSB9IGZyb20gJy4uL3NwaW4tYnV0dG9uL2luZGV4JztcbmltcG9ydCB7IFRpbWVQaWNrZXJNb2R1bGUgfSBmcm9tICcuLi90aW1lLXBpY2tlci9pbmRleCc7XG5pbXBvcnQgeyBEYXRlVGltZVBpY2tlckNvbXBvbmVudCB9IGZyb20gJy4vZGF0ZS10aW1lLXBpY2tlci5jb21wb25lbnQnO1xuaW1wb3J0IHsgRGF0ZVRpbWVQaWNrZXJDb25maWcgfSBmcm9tICcuL2RhdGUtdGltZS1waWNrZXIuY29uZmlnJztcbmltcG9ydCB7IERheVZpZXdDb21wb25lbnQgfSBmcm9tICcuL2RheS12aWV3L2RheS12aWV3LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBIZWFkZXJDb21wb25lbnQgfSBmcm9tICcuL2hlYWRlci9oZWFkZXIuY29tcG9uZW50JztcbmltcG9ydCB7IE1vbnRoVmlld0NvbXBvbmVudCB9IGZyb20gJy4vbW9udGgtdmlldy9tb250aC12aWV3LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBUaW1lVmlld0NvbXBvbmVudCB9IGZyb20gJy4vdGltZS12aWV3L3RpbWUtdmlldy5jb21wb25lbnQnO1xuaW1wb3J0IHsgWWVhclZpZXdDb21wb25lbnQgfSBmcm9tICcuL3llYXItdmlldy95ZWFyLXZpZXcuY29tcG9uZW50JztcbmltcG9ydCB7IEZvY3VzSWZNb2R1bGUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL2ZvY3VzLWlmL2luZGV4JztcblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgRm9ybXNNb2R1bGUsXG4gICAgICAgIFRpbWVQaWNrZXJNb2R1bGUsXG4gICAgICAgIFNwaW5CdXR0b25Nb2R1bGUsXG4gICAgICAgIEZvY3VzSWZNb2R1bGVcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtEYXRlVGltZVBpY2tlckNvbXBvbmVudF0sXG4gICAgZGVjbGFyYXRpb25zOiBbRGF0ZVRpbWVQaWNrZXJDb21wb25lbnQsIEhlYWRlckNvbXBvbmVudCwgRGF5Vmlld0NvbXBvbmVudCwgTW9udGhWaWV3Q29tcG9uZW50LCBZZWFyVmlld0NvbXBvbmVudCwgVGltZVZpZXdDb21wb25lbnRdLFxuICAgIHByb3ZpZGVyczogW1xuICAgICAgICBEYXRlVGltZVBpY2tlckNvbmZpZ1xuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgRGF0ZVRpbWVQaWNrZXJNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgQ29tcG9uZW50LCBEaXJlY3RpdmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1lYm94JyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vZWJveC5jb21wb25lbnQuaHRtbCcsXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgRWJveENvbXBvbmVudCB7IH1cblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICd1eC1lYm94LWhlYWRlcidcbn0pXG5leHBvcnQgY2xhc3MgRWJveEhlYWRlckRpcmVjdGl2ZSB7IH1cblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICd1eC1lYm94LWNvbnRlbnQnXG59KVxuZXhwb3J0IGNsYXNzIEVib3hDb250ZW50RGlyZWN0aXZlIHsgfVxuIiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgRWJveENvbXBvbmVudCwgRWJveENvbnRlbnREaXJlY3RpdmUsIEVib3hIZWFkZXJEaXJlY3RpdmUgfSBmcm9tICcuL2Vib3guY29tcG9uZW50JztcblxuQE5nTW9kdWxlKHtcbiAgICBleHBvcnRzOiBbRWJveENvbXBvbmVudCwgRWJveENvbnRlbnREaXJlY3RpdmUsIEVib3hIZWFkZXJEaXJlY3RpdmVdLFxuICAgIGRlY2xhcmF0aW9uczogW0Vib3hDb21wb25lbnQsIEVib3hDb250ZW50RGlyZWN0aXZlLCBFYm94SGVhZGVyRGlyZWN0aXZlXVxufSlcbmV4cG9ydCBjbGFzcyBFYm94TW9kdWxlIHsgfVxuIiwiZXhwb3J0IGNsYXNzIFR5cGVhaGVhZE9wdGlvbkV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgb3B0aW9uOiBhbnkpIHt9XG59IiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVHlwZWFoZWFkQ29tcG9uZW50IH0gZnJvbSAnLi90eXBlYWhlYWQuY29tcG9uZW50JztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFR5cGVhaGVhZEtleVNlcnZpY2Uge1xuXG4gICAgaGFuZGxlS2V5KGV2ZW50OiBLZXlib2FyZEV2ZW50LCB0eXBlYWhlYWQ6IFR5cGVhaGVhZENvbXBvbmVudCkge1xuICAgICAgICBpZiAodHlwZWFoZWFkKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGV2ZW50LmtleSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ0Fycm93VXAnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ1VwJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0eXBlYWhlYWQub3Blbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZWFoZWFkLm9wZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZWFoZWFkLm1vdmVIaWdobGlnaHQoLTEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ0Fycm93RG93bic6XG4gICAgICAgICAgICAgICAgY2FzZSAnRG93bic6XG4gICAgICAgICAgICAgICAgICAgIGlmICghdHlwZWFoZWFkLm9wZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVhaGVhZC5vcGVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVhaGVhZC5tb3ZlSGlnaGxpZ2h0KDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ0VzY2FwZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnRXNjJzpcbiAgICAgICAgICAgICAgICAgICAgdHlwZWFoZWFkLm9wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdFbnRlcic6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlYWhlYWQuc2VsZWN0T25FbnRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZWFoZWFkLnNlbGVjdEhpZ2hsaWdodGVkKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcclxuXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIFR5cGVhaGVhZFNlcnZpY2Uge1xyXG5cclxuICAgIG9wZW4kID0gbmV3IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPihmYWxzZSk7XHJcblxyXG4gICAgaGlnaGxpZ2h0ZWRFbGVtZW50JCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8SFRNTEVsZW1lbnQ+KG51bGwpO1xyXG59IiwiaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0b3JSZWYsIENvbXBvbmVudCwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBIb3N0QmluZGluZywgSG9zdExpc3RlbmVyLCBJbnB1dCwgT25DaGFuZ2VzLCBPbkRlc3Ryb3ksIE91dHB1dCwgU2ltcGxlQ2hhbmdlcywgVGVtcGxhdGVSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcy9CZWhhdmlvclN1YmplY3QnO1xyXG5pbXBvcnQgeyBjb21iaW5lTGF0ZXN0IH0gZnJvbSAncnhqcy9vYnNlcnZhYmxlL2NvbWJpbmVMYXRlc3QnO1xyXG5pbXBvcnQgeyBkaXN0aW5jdFVudGlsQ2hhbmdlZCwgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcclxuaW1wb3J0IHsgSW5maW5pdGVTY3JvbGxMb2FkRnVuY3Rpb24gfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL2luZmluaXRlLXNjcm9sbC9pbmRleCc7XHJcbmltcG9ydCB7IFR5cGVhaGVhZE9wdGlvbkV2ZW50IH0gZnJvbSAnLi90eXBlYWhlYWQtZXZlbnQnO1xyXG5pbXBvcnQgeyBUeXBlYWhlYWRTZXJ2aWNlIH0gZnJvbSAnLi90eXBlYWhlYWQuc2VydmljZSc7XHJcblxyXG5sZXQgdW5pcXVlSWQgPSAwO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgICBzZWxlY3RvcjogJ3V4LXR5cGVhaGVhZCcsXHJcbiAgICB0ZW1wbGF0ZVVybDogJ3R5cGVhaGVhZC5jb21wb25lbnQuaHRtbCcsXHJcbiAgICBwcm92aWRlcnM6IFtUeXBlYWhlYWRTZXJ2aWNlXSxcclxuICAgIGhvc3Q6IHtcclxuICAgICAgICAncm9sZSc6ICdsaXN0Ym94JyxcclxuICAgICAgICAnW2NsYXNzLm9wZW5dJzogJ29wZW4nLFxyXG4gICAgICAgICdbY2xhc3MuZHJvcC11cF0nOiAnZHJvcERpcmVjdGlvbiA9PT0gXCJ1cFwiJyxcclxuICAgICAgICAnW3N0eWxlLm1heEhlaWdodF0nOiAnbWF4SGVpZ2h0J1xyXG4gICAgfVxyXG59KVxyXG5leHBvcnQgY2xhc3MgVHlwZWFoZWFkQ29tcG9uZW50IGltcGxlbWVudHMgT25DaGFuZ2VzLCBPbkRlc3Ryb3kge1xyXG5cclxuICAgIEBJbnB1dCgpIEBIb3N0QmluZGluZygnYXR0ci5pZCcpIGlkOiBzdHJpbmcgPSBgdXgtdHlwZWFoZWFkLSR7Kyt1bmlxdWVJZH1gO1xyXG5cclxuICAgIEBJbnB1dCgpIG9wdGlvbnM6IGFueVtdIHwgSW5maW5pdGVTY3JvbGxMb2FkRnVuY3Rpb247XHJcbiAgICBASW5wdXQoKSBmaWx0ZXI6IHN0cmluZztcclxuXHJcbiAgICBASW5wdXQoKVxyXG4gICAgZ2V0IG9wZW4oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlcnZpY2Uub3BlbiQuZ2V0VmFsdWUoKTtcclxuICAgIH1cclxuICAgIHNldCBvcGVuKHZhbHVlOiBib29sZWFuKSB7XHJcbiAgICAgICAgdGhpcy5fc2VydmljZS5vcGVuJC5uZXh0KHZhbHVlKTtcclxuICAgIH1cclxuXHJcbiAgICBAT3V0cHV0KCkgb3BlbkNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oKTtcclxuXHJcbiAgICBASW5wdXQoKSBkaXNwbGF5OiAob3B0aW9uOiBhbnkpID0+IHN0cmluZyB8IHN0cmluZztcclxuICAgIEBJbnB1dCgpIGtleTogKG9wdGlvbjogYW55KSA9PiBzdHJpbmcgfCBzdHJpbmc7XHJcbiAgICBASW5wdXQoKSBkaXNhYmxlZE9wdGlvbnM6IGFueVtdO1xyXG4gICAgQElucHV0KCkgZHJvcERpcmVjdGlvbjogJ3VwJyB8ICdkb3duJyA9ICdkb3duJztcclxuICAgIEBJbnB1dCgpIG1heEhlaWdodDogc3RyaW5nID0gJzI1MHB4JztcclxuICAgIEBJbnB1dCgpIEBIb3N0QmluZGluZygnYXR0ci5hcmlhLW11bHRpc2VsZWN0YWJsZScpIG11bHRpc2VsZWN0YWJsZTogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgQElucHV0KCkgb3Blbk9uRmlsdGVyQ2hhbmdlOiBib29sZWFuID0gdHJ1ZTtcclxuICAgIEBJbnB1dCgpIHBhZ2VTaXplOiBudW1iZXIgPSAyMDtcclxuICAgIEBJbnB1dCgpIHNlbGVjdEZpcnN0OiBib29sZWFuID0gdHJ1ZTtcclxuICAgIEBJbnB1dCgpIHNlbGVjdE9uRW50ZXI6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIEBJbnB1dCgpIGxvYWRpbmcgPSBmYWxzZTtcclxuXHJcbiAgICBASW5wdXQoKSBsb2FkaW5nVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XHJcbiAgICBASW5wdXQoKSBvcHRpb25UZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcclxuICAgIEBJbnB1dCgpIG5vT3B0aW9uc1RlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xyXG5cclxuICAgIEBPdXRwdXQoKSBvcHRpb25TZWxlY3RlZCA9IG5ldyBFdmVudEVtaXR0ZXI8VHlwZWFoZWFkT3B0aW9uRXZlbnQ+KCk7XHJcblxyXG4gICAgQE91dHB1dCgpIGhpZ2hsaWdodGVkQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XHJcbiAgICBAT3V0cHV0KCkgaGlnaGxpZ2h0ZWRFbGVtZW50Q2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxIVE1MRWxlbWVudD4oKTtcclxuXHJcbiAgICBsb2FkT3B0aW9uc0NhbGxiYWNrOiBJbmZpbml0ZVNjcm9sbExvYWRGdW5jdGlvbjtcclxuICAgIHZpc2libGVPcHRpb25zJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8VHlwZWFoZWFkVmlzaWJsZU9wdGlvbltdPihbXSk7XHJcbiAgICBjbGlja2luZyA9IGZhbHNlO1xyXG4gICAgaGlnaGxpZ2h0ZWQkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxUeXBlYWhlYWRWaXNpYmxlT3B0aW9uPihudWxsKTtcclxuICAgIGhpZ2hsaWdodGVkS2V5OiBzdHJpbmcgPSBudWxsO1xyXG5cclxuICAgIGdldCBoaWdobGlnaHRlZCgpOiBhbnkge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5oaWdobGlnaHRlZCQuZ2V0VmFsdWUoKTtcclxuICAgICAgICByZXR1cm4gdmFsdWUgPyB2YWx1ZS52YWx1ZSA6IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfb25EZXN0cm95ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcclxuXHJcbiAgICBvcHRpb25BcGk6IFR5cGVhaGVhZE9wdGlvbkFwaSA9IHtcclxuICAgICAgICBnZXRLZXk6IHRoaXMuZ2V0S2V5LmJpbmQodGhpcyksXHJcbiAgICAgICAgZ2V0RGlzcGxheTogdGhpcy5nZXREaXNwbGF5LmJpbmQodGhpcyksXHJcbiAgICAgICAgZ2V0RGlzcGxheUh0bWw6IHRoaXMuZ2V0RGlzcGxheUh0bWwuYmluZCh0aGlzKVxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgICAgICBwdWJsaWMgdHlwZWFoZWFkRWxlbWVudDogRWxlbWVudFJlZixcclxuICAgICAgICBwcml2YXRlIF9jaGFuZ2VEZXRlY3RvcjogQ2hhbmdlRGV0ZWN0b3JSZWYsXHJcbiAgICAgICAgcHJpdmF0ZSBfc2VydmljZTogVHlwZWFoZWFkU2VydmljZVxyXG4gICAgKSB7XHJcblxyXG4gICAgICAgIHRoaXMubG9hZE9wdGlvbnNDYWxsYmFjayA9IChwYWdlTnVtOiBudW1iZXIsIHBhZ2VTaXplOiBudW1iZXIsIGZpbHRlcjogYW55KSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSW52b2tlIHRoZSBjYWxsYmFjayB3aGljaCBtYXkgcmV0dXJuIGFuIGFycmF5IG9yIGEgcHJvbWlzZS5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGFycmF5T3JQcm9taXNlID0gdGhpcy5vcHRpb25zKHBhZ2VOdW0sIHBhZ2VTaXplLCBmaWx0ZXIpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIE1hcCB0aGUgcmVzdWx0cyB0byBhbiBhcnJheSBvZiBUeXBlYWhlYWRWaXNpYmxlT3B0aW9uLlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShhcnJheU9yUHJvbWlzZSkudGhlbihuZXdPcHRpb25zID0+IHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG5ld09wdGlvbnMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdPcHRpb25zO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld09wdGlvbnMubWFwKChvcHRpb246IGFueSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG9wdGlvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogdGhpcy5nZXRLZXkob3B0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5fc2VydmljZS5vcGVuJC5waXBlKGRpc3RpbmN0VW50aWxDaGFuZ2VkKCksIHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUoKG5leHQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5vcGVuQ2hhbmdlLmVtaXQobmV4dCk7XHJcblxyXG4gICAgICAgICAgICBpZiAobmV4dCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5pbml0T3B0aW9ucygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWQkLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZSgobmV4dCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmhpZ2hsaWdodGVkS2V5ID0gbmV4dCA/IG5leHQua2V5IDogbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRlZENoYW5nZS5lbWl0KG5leHQgPyBuZXh0LnZhbHVlIDogbnVsbCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGNvbWJpbmVMYXRlc3QodGhpcy5fc2VydmljZS5vcGVuJCwgdGhpcy5fc2VydmljZS5oaWdobGlnaHRlZEVsZW1lbnQkLCB0aGlzLnZpc2libGVPcHRpb25zJClcclxuICAgICAgICAgICAgLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpXHJcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKFtvcGVuLCBoaWdobGlnaHRlZEVsZW1lbnQsIHZpc2libGVPcHRpb25zXSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRlZEVsZW1lbnRDaGFuZ2UuZW1pdChvcGVuICYmIHZpc2libGVPcHRpb25zLmxlbmd0aCA+IDAgPyBoaWdobGlnaHRlZEVsZW1lbnQgOiBudWxsKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xyXG4gICAgICAgIC8vIE9wZW4gdGhlIGRyb3Bkb3duIGlmIHRoZSBmaWx0ZXIgdmFsdWUgdXBkYXRlc1xyXG4gICAgICAgIGlmIChjaGFuZ2VzLmZpbHRlcikge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vcGVuT25GaWx0ZXJDaGFuZ2UgJiYgY2hhbmdlcy5maWx0ZXIuY3VycmVudFZhbHVlICYmIGNoYW5nZXMuZmlsdGVyLmN1cnJlbnRWYWx1ZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wZW4gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZS1maWx0ZXIgdmlzaWJsZU9wdGlvbnNcclxuICAgICAgICB0aGlzLnVwZGF0ZU9wdGlvbnMoKTtcclxuICAgIH1cclxuXHJcbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kubmV4dCgpO1xyXG4gICAgICAgIHRoaXMuX29uRGVzdHJveS5jb21wbGV0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIEBIb3N0TGlzdGVuZXIoJ21vdXNlZG93bicpXHJcbiAgICBtb3VzZWRvd25IYW5kbGVyKCkge1xyXG4gICAgICAgIHRoaXMuY2xpY2tpbmcgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIEBIb3N0TGlzdGVuZXIoJ21vdXNldXAnKVxyXG4gICAgbW91c2V1cEhhbmRsZXIoKSB7XHJcbiAgICAgICAgdGhpcy5jbGlja2luZyA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIG9wdGlvbk1vdXNlZG93bkhhbmRsZXIoZXZlbnQ6IE1vdXNlRXZlbnQpIHtcclxuICAgICAgICAvLyBXb3JrYXJvdW5kIHRvIHByZXZlbnQgZm9jdXMgY2hhbmdpbmcgd2hlbiBhbiBvcHRpb24gaXMgY2xpY2tlZFxyXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgb3B0aW9uQ2xpY2tIYW5kbGVyKGV2ZW50OiBNb3VzZUV2ZW50LCBvcHRpb246IFR5cGVhaGVhZFZpc2libGVPcHRpb24pIHtcclxuICAgICAgICB0aGlzLnNlbGVjdChvcHRpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdW5pcXVlIGtleSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gb3B0aW9uLlxyXG4gICAgICovXHJcbiAgICBnZXRLZXkob3B0aW9uOiBhbnkpOiBzdHJpbmcge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5rZXkgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMua2V5KG9wdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5rZXkgPT09ICdzdHJpbmcnICYmIG9wdGlvbiAmJiBvcHRpb24uaGFzT3duUHJvcGVydHkodGhpcy5rZXkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25bPHN0cmluZz50aGlzLmtleV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmdldERpc3BsYXkob3B0aW9uKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGRpc3BsYXkgdmFsdWUgb2YgdGhlIGdpdmVuIG9wdGlvbi5cclxuICAgICAqL1xyXG4gICAgZ2V0RGlzcGxheShvcHRpb246IGFueSk6IHN0cmluZyB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmRpc3BsYXkgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGxheShvcHRpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIHRoaXMuZGlzcGxheSA9PT0gJ3N0cmluZycgJiYgb3B0aW9uICYmIG9wdGlvbi5oYXNPd25Qcm9wZXJ0eSh0aGlzLmRpc3BsYXkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25bPHN0cmluZz50aGlzLmRpc3BsYXldO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3B0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZGlzcGxheSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gb3B0aW9uIHdpdGggSFRNTCBtYXJrdXAgYWRkZWQgdG8gaGlnaGxpZ2h0IHRoZSBwYXJ0IHdoaWNoIG1hdGNoZXMgdGhlIGN1cnJlbnQgZmlsdGVyIHZhbHVlLlxyXG4gICAgICogQHBhcmFtIG9wdGlvblxyXG4gICAgICovXHJcbiAgICBnZXREaXNwbGF5SHRtbChvcHRpb246IGFueSkge1xyXG4gICAgICAgIGNvbnN0IGRpc3BsYXlUZXh0ID0gdGhpcy5nZXREaXNwbGF5KG9wdGlvbikucmVwbGFjZSgvJi9nLCAnJmFtcDsnKS5yZXBsYWNlKC88L2csICcmbHQ7JykucmVwbGFjZSgvPi9nLCAnJmd0OycpO1xyXG4gICAgICAgIGxldCBkaXNwbGF5SHRtbCA9IGRpc3BsYXlUZXh0O1xyXG4gICAgICAgIGlmICh0aGlzLmZpbHRlcikge1xyXG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSB0aGlzLmZpbHRlci5sZW5ndGg7XHJcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoSW5kZXggPSBkaXNwbGF5VGV4dC50b0xvd2VyQ2FzZSgpLmluZGV4T2YodGhpcy5maWx0ZXIudG9Mb3dlckNhc2UoKSk7XHJcbiAgICAgICAgICAgIGlmIChtYXRjaEluZGV4ID49IDApIHtcclxuICAgICAgICAgICAgICAgIHZhciBoaWdobGlnaHQgPSBgPHNwYW4gY2xhc3M9XCJ1eC1maWx0ZXItbWF0Y2hcIj4ke2Rpc3BsYXlUZXh0LnN1YnN0cihtYXRjaEluZGV4LCBsZW5ndGgpfTwvc3Bhbj5gO1xyXG4gICAgICAgICAgICAgICAgZGlzcGxheUh0bWwgPSBkaXNwbGF5VGV4dC5zdWJzdHIoMCwgbWF0Y2hJbmRleCkgKyBoaWdobGlnaHQgKyBkaXNwbGF5VGV4dC5zdWJzdHIobWF0Y2hJbmRleCArIGxlbmd0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRpc3BsYXlIdG1sO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBpbmZpbml0ZSBzY3JvbGwgY29tcG9uZW50IHNob3VsZCBsb2FkXHJcbiAgICAgKi9cclxuICAgIGlzSW5maW5pdGVTY3JvbGwoKSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLm9wdGlvbnMgPT09ICdmdW5jdGlvbic7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZWxlY3RzIHRoZSBnaXZlbiBvcHRpb24sIGVtaXR0aW5nIHRoZSBvcHRpb25TZWxlY3RlZCBldmVudCBhbmQgY2xvc2luZyB0aGUgZHJvcGRvd24uXHJcbiAgICAgKi9cclxuICAgIHNlbGVjdChvcHRpb246IFR5cGVhaGVhZFZpc2libGVPcHRpb24pIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNEaXNhYmxlZChvcHRpb24pKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3B0aW9uU2VsZWN0ZWQuZW1pdChuZXcgVHlwZWFoZWFkT3B0aW9uRXZlbnQob3B0aW9uLnZhbHVlKSk7XHJcbiAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWQkLm5leHQobnVsbCk7XHJcbiAgICAgICAgICAgIHRoaXMub3BlbiA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gb3B0aW9uIGlzIHBhcnQgb2YgdGhlIGRpc2FibGVkT3B0aW9ucyBhcnJheS5cclxuICAgICAqL1xyXG4gICAgaXNEaXNhYmxlZChvcHRpb246IFR5cGVhaGVhZFZpc2libGVPcHRpb24pOiBib29sZWFuIHtcclxuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZE9wdGlvbnMpIHtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5kaXNhYmxlZE9wdGlvbnMuZmluZCgoc2VsZWN0ZWRPcHRpb24pID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEtleShzZWxlY3RlZE9wdGlvbikgPT09IG9wdGlvbi5rZXk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0ICE9PSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgZ2l2ZW4gb3B0aW9uIGFzIHRoZSBjdXJyZW50IGhpZ2hsaWdodGVkIG9wdGlvbiwgYXZhaWxhYmxlIGluIHRoZSBoaWdobGlnaHRlZE9wdGlvbiBwYXJhbWV0ZXIuXHJcbiAgICAgKi9cclxuICAgIGhpZ2hsaWdodChvcHRpb246IFR5cGVhaGVhZFZpc2libGVPcHRpb24pIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNEaXNhYmxlZChvcHRpb24pKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWQkLm5leHQob3B0aW9uKTtcclxuICAgICAgICAgICAgdGhpcy5fY2hhbmdlRGV0ZWN0b3IuZGV0ZWN0Q2hhbmdlcygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEluY3JlbWVudCBvciBkZWNyZW1lbnQgdGhlIGhpZ2hsaWdodGVkIG9wdGlvbiBpbiB0aGUgbGlzdC4gRGlzYWJsZWQgb3B0aW9ucyBhcmUgc2tpcHBlZC5cclxuICAgICAqIEBwYXJhbSBkIFZhbHVlIHRvIGJlIGFkZGVkIHRvIHRoZSBpbmRleCBvZiB0aGUgaGlnaGxpZ2h0ZWQgb3B0aW9uLCBpLmUuIC0xIHRvIG1vdmUgYmFja3dhcmRzLCArMSB0byBtb3ZlIGZvcndhcmRzLlxyXG4gICAgICovXHJcbiAgICBtb3ZlSGlnaGxpZ2h0KGQ6IG51bWJlcik6IGFueSB7XHJcbiAgICAgICAgY29uc3QgdmlzaWJsZU9wdGlvbnMgPSB0aGlzLnZpc2libGVPcHRpb25zJC5nZXRWYWx1ZSgpO1xyXG4gICAgICAgIGNvbnN0IGhpZ2hsaWdodEluZGV4ID0gdGhpcy5pbmRleE9mVmlzaWJsZU9wdGlvbih0aGlzLmhpZ2hsaWdodGVkKTtcclxuICAgICAgICBsZXQgbmV3SW5kZXggPSBoaWdobGlnaHRJbmRleDtcclxuICAgICAgICBsZXQgZGlzYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgIGxldCBpbkJvdW5kcyA9IHRydWU7XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBuZXdJbmRleCA9IG5ld0luZGV4ICsgZDtcclxuICAgICAgICAgICAgaW5Cb3VuZHMgPSAobmV3SW5kZXggPj0gMCAmJiBuZXdJbmRleCA8IHZpc2libGVPcHRpb25zLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIGRpc2FibGVkID0gaW5Cb3VuZHMgJiYgdGhpcy5pc0Rpc2FibGVkKHZpc2libGVPcHRpb25zW25ld0luZGV4XSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdoaWxlIChpbkJvdW5kcyAmJiBkaXNhYmxlZCk7XHJcblxyXG4gICAgICAgIGlmICghZGlzYWJsZWQgJiYgaW5Cb3VuZHMpIHtcclxuICAgICAgICAgICAgdGhpcy5oaWdobGlnaHQodmlzaWJsZU9wdGlvbnNbbmV3SW5kZXhdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLmhpZ2hsaWdodGVkO1xyXG4gICAgfVxyXG5cclxuICAgIHNlbGVjdEhpZ2hsaWdodGVkKCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLmhpZ2hsaWdodGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0KHsgdmFsdWU6IHRoaXMuaGlnaGxpZ2h0ZWQsIGtleTogdGhpcy5nZXRLZXkodGhpcy5oaWdobGlnaHRlZCl9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdXAgdGhlIG9wdGlvbnMgYmVmb3JlIHRoZSBkcm9wZG93biBpcyBkaXNwbGF5ZWQuXHJcbiAgICAgKi9cclxuICAgIGluaXRPcHRpb25zKCkge1xyXG4gICAgICAgIC8vIENsZWFyIHByZXZpb3VzIGhpZ2hsaWdodFxyXG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWQkLm5leHQobnVsbCk7XHJcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0Rmlyc3QpIHtcclxuICAgICAgICAgICAgLy8gVGhpcyB3aWxsIGhpZ2hsaWdodCB0aGUgZmlyc3Qgbm9uLWRpc2FibGVkIG9wdGlvbi5cclxuICAgICAgICAgICAgdGhpcy5tb3ZlSGlnaGxpZ2h0KDEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSB0aGUgdmlzaWJsZU9wdGlvbnMgYXJyYXkgd2l0aCB0aGUgY3VycmVudCBmaWx0ZXIuXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZU9wdGlvbnMoKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGlzZWRJbnB1dCA9ICh0aGlzLmZpbHRlciB8fCAnJykudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgY29uc3QgdmlzaWJsZU9wdGlvbnMgPSB0aGlzLm9wdGlvbnNcclxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKG9wdGlvbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldERpc3BsYXkob3B0aW9uKS50b0xvd2VyQ2FzZSgpLmluZGV4T2Yobm9ybWFsaXNlZElucHV0KSA+PSAwO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5tYXAoKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IHRoaXMuZ2V0S2V5KHZhbHVlKVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy52aXNpYmxlT3B0aW9ucyQubmV4dCh2aXNpYmxlT3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmluaXRPcHRpb25zKCk7XHJcblxyXG4gICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yLmRldGVjdENoYW5nZXMoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgaW5kZXggb2YgdGhlIGdpdmVuIG9wdGlvbiBpbiB0aGUgdmlzaWJsZU9wdGlvbnMgYXJyYXkuIFJldHVybnMgLTEgaWYgdGhlIG9wdGlvbiBpcyBub3QgY3VycmVudGx5IHZpc2libGUuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgaW5kZXhPZlZpc2libGVPcHRpb24ob3B0aW9uOiBhbnkpOiBudW1iZXIge1xyXG4gICAgICAgIGlmIChvcHRpb24pIHtcclxuICAgICAgICAgICAgY29uc3Qgb3B0aW9uS2V5ID0gdGhpcy5nZXRLZXkob3B0aW9uKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlzaWJsZU9wdGlvbnMkLmdldFZhbHVlKCkuZmluZEluZGV4KChlbCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsLmtleSA9PT0gb3B0aW9uS2V5O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBBUEkgYXZhaWxhYmxlIHRvIG9wdGlvbiB0ZW1wbGF0ZXMuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIFR5cGVhaGVhZE9wdGlvbkFwaSB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB1bmlxdWUga2V5IHZhbHVlIG9mIHRoZSBnaXZlbiBvcHRpb24uXHJcbiAgICAgKi9cclxuICAgIGdldEtleShvcHRpb246IGFueSk6IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGRpc3BsYXkgdmFsdWUgb2YgdGhlIGdpdmVuIG9wdGlvbi5cclxuICAgICAqL1xyXG4gICAgZ2V0RGlzcGxheShvcHRpb246IGFueSk6IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGRpc3BsYXkgdmFsdWUgb2YgdGhlIGdpdmVuIG9wdGlvbiB3aXRoIEhUTUwgbWFya3VwIGFkZGVkIHRvIGhpZ2hsaWdodCB0aGUgcGFydCB3aGljaCBtYXRjaGVzIHRoZSBjdXJyZW50IGZpbHRlciB2YWx1ZS4gT3ZlcnJpZGUgdGhlIHV4LWZpbHRlci1tYXRjaCBjbGFzcyBpbiBDU1MgdG8gbW9kaWZ5IHRoZSBkZWZhdWx0IGFwcGVhcmFuY2UuXHJcbiAgICAgKi9cclxuICAgIGdldERpc3BsYXlIdG1sKG9wdGlvbjogYW55KTogc3RyaW5nO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFR5cGVhaGVhZFZpc2libGVPcHRpb24ge1xyXG4gICAgdmFsdWU6IGFueTtcclxuICAgIGtleTogc3RyaW5nO1xyXG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbnB1dCwgT3V0cHV0LCBSZW5kZXJlcjIsIFRlbXBsYXRlUmVmLCBWaWV3Q29udGFpbmVyUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcy9PYnNlcnZhYmxlJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzL1N1YmplY3QnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1t1eEluZmluaXRlU2Nyb2xsTG9hZEJ1dHRvbl0nXG59KVxuZXhwb3J0IGNsYXNzIEluZmluaXRlU2Nyb2xsTG9hZEJ1dHRvbkRpcmVjdGl2ZSB7XG5cbiAgICBASW5wdXQoJ3V4SW5maW5pdGVTY3JvbGxMb2FkQnV0dG9uJylcbiAgICBnZXQgdmlzaWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2libGU7XG4gICAgfVxuICAgIHNldCB2aXNpYmxlKHZhbHVlOiBib29sZWFuKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fdmlzaWJsZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmlld0NvbnRhaW5lci5jcmVhdGVFbWJlZGRlZFZpZXcodGhpcy5fdGVtcGxhdGUpO1xuXG4gICAgICAgICAgICAgICAgLy8gVGVtcGxhdGUgY29udGVudCBmb2xsb3dzIHRoZSBlbGVtZW50UmVmLCB3aGljaCBpcyBhIGNvbW1lbnQuXG4gICAgICAgICAgICAgICAgY29uc3QgY2xpY2tUYXJnZXQgPSB0aGlzLmdldE5leHRFbGVtZW50U2libGluZyh0aGlzLl90ZW1wbGF0ZS5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmxpc3RlbihjbGlja1RhcmdldCwgJ2NsaWNrJywgdGhpcy5vbkNsaWNrLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl92aWV3Q29udGFpbmVyLmNsZWFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl92aXNpYmxlID0gdmFsdWU7XG4gICAgfVxuXG4gICAgQE91dHB1dCgpIGxvYWQ6IE9ic2VydmFibGU8RXZlbnQ+O1xuXG4gICAgcHJpdmF0ZSBfdmlzaWJsZTogYm9vbGVhbiA9IGZhbHNlO1xuICAgIHByaXZhdGUgX2xvYWQgPSBuZXcgU3ViamVjdCgpO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgX2VsZW1lbnQ6IEVsZW1lbnRSZWYsXG4gICAgICAgIHByaXZhdGUgX3RlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+LFxuICAgICAgICBwcml2YXRlIF92aWV3Q29udGFpbmVyOiBWaWV3Q29udGFpbmVyUmVmLFxuICAgICAgICBwcml2YXRlIF9yZW5kZXJlcjogUmVuZGVyZXIyKSB7XG5cbiAgICAgICAgdGhpcy5sb2FkID0gdGhpcy5fbG9hZC5hc09ic2VydmFibGUoKSBhcyBPYnNlcnZhYmxlPEV2ZW50PjtcbiAgICB9XG5cbiAgICBwcml2YXRlIG9uQ2xpY2soZXZlbnQ6IE1vdXNlRXZlbnQpIHtcbiAgICAgICAgdGhpcy5fbG9hZC5uZXh0KGV2ZW50KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldE5leHRFbGVtZW50U2libGluZyhlbGVtZW50OiBhbnkpOiBFbGVtZW50IHtcbiAgICAgICAgdmFyIG5leHQgPSBlbGVtZW50O1xuICAgICAgICB3aGlsZSAobmV4dCA9IG5leHQubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgIGlmIChuZXh0Lm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBJbnB1dCwgVGVtcGxhdGVSZWYsIFZpZXdDb250YWluZXJSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbdXhJbmZpbml0ZVNjcm9sbExvYWRpbmddJ1xufSlcbmV4cG9ydCBjbGFzcyBJbmZpbml0ZVNjcm9sbExvYWRpbmdEaXJlY3RpdmUge1xuXG4gICAgQElucHV0KCd1eEluZmluaXRlU2Nyb2xsTG9hZGluZycpXG4gICAgZ2V0IHZpc2libGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92aXNpYmxlO1xuICAgIH1cbiAgICBzZXQgdmlzaWJsZSh2YWx1ZTogYm9vbGVhbikge1xuICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMuX3Zpc2libGUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZpZXdDb250YWluZXIuY3JlYXRlRW1iZWRkZWRWaWV3KHRoaXMuX3RlbXBsYXRlUmVmKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmlld0NvbnRhaW5lci5jbGVhcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB0aGlzLl92aXNpYmxlID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfdmlzaWJsZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgX3RlbXBsYXRlUmVmOiBUZW1wbGF0ZVJlZjxhbnk+LFxuICAgICAgICBwcml2YXRlIF92aWV3Q29udGFpbmVyOiBWaWV3Q29udGFpbmVyUmVmKSB7IH1cbn1cbiIsIlxuaW1wb3J0IHsgQWZ0ZXJDb250ZW50SW5pdCwgQ29udGVudENoaWxkcmVuLCBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE9uQ2hhbmdlcywgT25EZXN0cm95LCBPbkluaXQsIE91dHB1dCwgUXVlcnlMaXN0LCBTaW1wbGVDaGFuZ2VzIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QgfSBmcm9tICdyeGpzL0JlaGF2aW9yU3ViamVjdCc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcy9PYnNlcnZhYmxlJztcbmltcG9ydCB7IGZyb20gfSBmcm9tICdyeGpzL29ic2VydmFibGUvZnJvbSc7XG5pbXBvcnQgeyBmcm9tRXZlbnQgfSBmcm9tICdyeGpzL29ic2VydmFibGUvZnJvbUV2ZW50JztcbmltcG9ydCB7IG9mIH0gZnJvbSAncnhqcy9vYnNlcnZhYmxlL29mJztcbmltcG9ydCB7IGF1ZGl0VGltZSwgY29tYmluZUxhdGVzdCwgZmlsdGVyIGFzIGZpbHRlck9wZXJhdG9yLCBmaXJzdCwgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBJbmZpbml0ZVNjcm9sbExvYWRCdXR0b25EaXJlY3RpdmUgfSBmcm9tICcuL2luZmluaXRlLXNjcm9sbC1sb2FkLWJ1dHRvbi5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgSW5maW5pdGVTY3JvbGxMb2FkaW5nRGlyZWN0aXZlIH0gZnJvbSAnLi9pbmZpbml0ZS1zY3JvbGwtbG9hZGluZy5kaXJlY3RpdmUnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1t1eEluZmluaXRlU2Nyb2xsXScsXG4gICAgZXhwb3J0QXM6ICd1eEluZmluaXRlU2Nyb2xsJ1xufSlcbmV4cG9ydCBjbGFzcyBJbmZpbml0ZVNjcm9sbERpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCwgQWZ0ZXJDb250ZW50SW5pdCwgT25DaGFuZ2VzLCBPbkRlc3Ryb3kge1xuXG4gICAgQElucHV0KCd1eEluZmluaXRlU2Nyb2xsJykgbG9hZDogSW5maW5pdGVTY3JvbGxMb2FkRnVuY3Rpb247XG5cbiAgICBASW5wdXQoJ2NvbGxlY3Rpb24nKSBfY29sbGVjdGlvbjogYW55W10gPSBbXTtcbiAgICBnZXQgY29sbGVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbGxlY3Rpb247XG4gICAgfVxuICAgIHNldCBjb2xsZWN0aW9uKHZhbHVlOiBhbnlbXSkge1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb25DaGFuZ2UuZW1pdCh2YWx1ZSk7XG4gICAgICAgIHRoaXMuX2NvbGxlY3Rpb24gPSB2YWx1ZTtcbiAgICB9XG5cblxuICAgIEBJbnB1dCgpIHNldCBzY3JvbGxFbGVtZW50KGVsZW1lbnQ6IEVsZW1lbnRSZWYgfCBIVE1MRWxlbWVudCkge1xuICAgICAgICB0aGlzLl9zY3JvbGxFbGVtZW50ID0gZWxlbWVudCBpbnN0YW5jZW9mIEVsZW1lbnRSZWYgPyBlbGVtZW50IDogbmV3IEVsZW1lbnRSZWYoZWxlbWVudCk7XG4gICAgfVxuXG4gICAgQElucHV0KCkgZW5hYmxlZDogYm9vbGVhbiA9IHRydWU7XG4gICAgQElucHV0KCkgZmlsdGVyOiBhbnk7XG4gICAgQElucHV0KCkgbG9hZE9uSW5pdDogYm9vbGVhbiA9IHRydWU7XG4gICAgQElucHV0KCkgbG9hZE9uU2Nyb2xsOiBib29sZWFuID0gdHJ1ZTtcbiAgICBASW5wdXQoKSBwYWdlU2l6ZTogbnVtYmVyID0gMjA7XG5cbiAgICBAT3V0cHV0KCkgY29sbGVjdGlvbkNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8YW55W10+KCk7XG5cbiAgICBAT3V0cHV0KCdsb2FkaW5nJylcbiAgICBsb2FkaW5nRXZlbnQgPSBuZXcgRXZlbnRFbWl0dGVyPEluZmluaXRlU2Nyb2xsTG9hZGluZ0V2ZW50PigpO1xuXG4gICAgQE91dHB1dCgnbG9hZGVkJylcbiAgICBsb2FkZWRFdmVudCA9IG5ldyBFdmVudEVtaXR0ZXI8SW5maW5pdGVTY3JvbGxMb2FkZWRFdmVudD4oKTtcblxuICAgIEBPdXRwdXQoJ2xvYWRFcnJvcicpXG4gICAgbG9hZEVycm9yRXZlbnQgPSBuZXcgRXZlbnRFbWl0dGVyPEluZmluaXRlU2Nyb2xsTG9hZEVycm9yRXZlbnQ+KCk7XG5cbiAgICBAQ29udGVudENoaWxkcmVuKEluZmluaXRlU2Nyb2xsTG9hZEJ1dHRvbkRpcmVjdGl2ZSlcbiAgICBwcml2YXRlIF9sb2FkQnV0dG9uUXVlcnk6IFF1ZXJ5TGlzdDxJbmZpbml0ZVNjcm9sbExvYWRCdXR0b25EaXJlY3RpdmU+O1xuXG4gICAgQENvbnRlbnRDaGlsZHJlbihJbmZpbml0ZVNjcm9sbExvYWRpbmdEaXJlY3RpdmUpXG4gICAgcHJpdmF0ZSBfbG9hZGluZ0luZGljYXRvclF1ZXJ5OiBRdWVyeUxpc3Q8SW5maW5pdGVTY3JvbGxMb2FkaW5nRGlyZWN0aXZlPjtcblxuICAgIHByaXZhdGUgX3BhZ2VzOiBhbnlbXVtdO1xuICAgIHByaXZhdGUgX25leHRQYWdlTnVtID0gMDtcbiAgICBwcml2YXRlIF9kb21PYnNlcnZlcjogTXV0YXRpb25PYnNlcnZlcjtcbiAgICBwcml2YXRlIF9zY3JvbGxFdmVudFN1YjogU3Vic2NyaXB0aW9uO1xuICAgIHByaXZhdGUgX3VwZGF0ZVJlcXVlc3RzID0gbmV3IFN1YmplY3Q8SW5maW5pdGVTY3JvbGxSZXF1ZXN0PigpO1xuXG4gICAgcHJpdmF0ZSBfaXNMb2FkaW5nID0gbmV3IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPihmYWxzZSk7XG4gICAgcHJpdmF0ZSBfaXNFeGhhdXN0ZWQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+KGZhbHNlKTtcbiAgICBwcml2YXRlIF9sb2FkQnV0dG9uRW5hYmxlZCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4oZmFsc2UpO1xuICAgIHByaXZhdGUgX2NhbkxvYWRNYW51YWxseTogT2JzZXJ2YWJsZTxib29sZWFuPjtcblxuICAgIHByaXZhdGUgX3Njcm9sbEVsZW1lbnQ6IEVsZW1lbnRSZWY7XG4gICAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcbiAgICBwcml2YXRlIF9sb2FkQnV0dG9uU3Vic2NyaXB0aW9uczogU3Vic2NyaXB0aW9uW10gPSBbXTtcbiAgICBwcml2YXRlIF9vbkRlc3Ryb3kgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfZWxlbWVudDogRWxlbWVudFJlZikge1xuICAgICAgICB0aGlzLl9jYW5Mb2FkTWFudWFsbHkgPSB0aGlzLl9pc0xvYWRpbmcucGlwZShjb21iaW5lTGF0ZXN0KFxuICAgICAgICAgICAgdGhpcy5faXNFeGhhdXN0ZWQsXG4gICAgICAgICAgICB0aGlzLl9sb2FkQnV0dG9uRW5hYmxlZCxcbiAgICAgICAgICAgIChpc0xvYWRpbmcsIGlzRXhoYXVzdGVkLCBsb2FkQnV0dG9uRW5hYmxlZCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiAhaXNMb2FkaW5nICYmICFpc0V4aGF1c3RlZCAmJiBsb2FkQnV0dG9uRW5hYmxlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKSk7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIGlmICghdGhpcy5fc2Nyb2xsRWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsRWxlbWVudCA9IHRoaXMuX2VsZW1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9sb2FkQnV0dG9uRW5hYmxlZC5uZXh0KCF0aGlzLmxvYWRPblNjcm9sbCk7XG4gICAgfVxuXG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuXG4gICAgICAgIC8vIFRoZXJlIGFyZSB0d28ga2luZHMgb2YgdXBkYXRlIHJlcXVlc3RzOiBjaGVjayBhbmQgbG9hZC5cbiAgICAgICAgLy8gQ2hlY2sgcmVxdWVzdHMgYXJlIHRocm90dGxlZCBhbmQgd2lsbCBvbmx5IGNhdXNlIGFuIHVwZGF0ZSBpZiBtb3JlIGRhdGEgaXMgcmVxdWlyZWRcbiAgICAgICAgLy8gdG8gZmlsbCB0aGUgc2Nyb2xsaW5nIHZpZXcsIGFuZCBpdCBpc24ndCBhbHJlYWR5IGxvYWRpbmcgc29tZS5cbiAgICAgICAgLy8gTG9hZCByZXF1ZXN0cyBhcmUgbm90IHRocm90dGxlZCBhbmQgYWx3YXlzIHJlcXVlc3QgYSBwYWdlIG9mIGRhdGEuXG4gICAgICAgIHRoaXMuX3VwZGF0ZVJlcXVlc3RzLnBpcGUoZmlsdGVyT3BlcmF0b3IocmVxdWVzdCA9PiByZXF1ZXN0LmNoZWNrKSwgYXVkaXRUaW1lKDIwMCksIHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUodGhpcy5kb1JlcXVlc3QuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVJlcXVlc3RzLnBpcGUoZmlsdGVyT3BlcmF0b3IocmVxdWVzdCA9PiAhcmVxdWVzdC5jaGVjayksIHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUodGhpcy5kb1JlcXVlc3QuYmluZCh0aGlzKSk7XG5cbiAgICAgICAgaWYgKHRoaXMuZW5hYmxlZCkge1xuICAgICAgICAgICAgLy8gU3Vic2NyaWJlIHRvIHNjcm9sbCBldmVudHMgYW5kIERPTSBjaGFuZ2VzLlxuICAgICAgICAgICAgdGhpcy5hdHRhY2hFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb25uZWN0IHRoZSBMb2FkIE1vcmUgYnV0dG9uIHZpc2libGUgc3RhdGUuXG4gICAgICAgIHRoaXMuX2NhbkxvYWRNYW51YWxseS5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUoY2FuTG9hZCA9PiB7XG4gICAgICAgICAgICB0aGlzLl9sb2FkQnV0dG9uUXVlcnkuZm9yRWFjaChsb2FkQnV0dG9uID0+IHtcbiAgICAgICAgICAgICAgICBsb2FkQnV0dG9uLnZpc2libGUgPSBjYW5Mb2FkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIENvbm5lY3QgdGhlIGxvYWRpbmcgaW5kaWNhdG9yIHZpc2libGUgc3RhdGUuXG4gICAgICAgIHRoaXMuX2lzTG9hZGluZy5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUoaXNMb2FkaW5nID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2xvYWRpbmdJbmRpY2F0b3JRdWVyeS5mb3JFYWNoKGxvYWRpbmcgPT4ge1xuICAgICAgICAgICAgICAgIGxvYWRpbmcudmlzaWJsZSA9IGlzTG9hZGluZztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBMaW5rIHRoZSBMb2FkIE1vcmUgYnV0dG9uIGNsaWNrIGV2ZW50IHRvIHRyaWdnZXIgYW4gdXBkYXRlLlxuICAgICAgICB0aGlzLmF0dGFjaExvYWRCdXR0b25FdmVudHMoKTtcbiAgICAgICAgdGhpcy5fbG9hZEJ1dHRvblF1ZXJ5LmNoYW5nZXMucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYXR0YWNoTG9hZEJ1dHRvbkV2ZW50cygpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBJbml0aWFsIHVwZGF0ZS5cbiAgICAgICAgaWYgKHRoaXMubG9hZE9uSW5pdCkge1xuICAgICAgICAgICAgdGhpcy5sb2FkTmV4dFBhZ2UoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcbiAgICAgICAgbGV0IGNoZWNrID0gdHJ1ZTtcblxuICAgICAgICBpZiAoY2hhbmdlcy5lbmFibGVkICYmIGNoYW5nZXMuZW5hYmxlZC5jdXJyZW50VmFsdWUgIT09IGNoYW5nZXMuZW5hYmxlZC5wcmV2aW91c1ZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoY2hhbmdlcy5lbmFibGVkLmN1cnJlbnRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXR0YWNoRXZlbnRIYW5kbGVycygpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgICAgICBjaGVjayA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRldGFjaEV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VzLmZpbHRlciAmJiBjaGFuZ2VzLmZpbHRlci5jdXJyZW50VmFsdWUgIT09IGNoYW5nZXMuZmlsdGVyLnByZXZpb3VzVmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgY2hlY2sgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNoYW5nZXMubG9hZE9uU2Nyb2xsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9hZEJ1dHRvbkVuYWJsZWQubmV4dChcbiAgICAgICAgICAgICAgICAgICAgIWNoYW5nZXMubG9hZE9uU2Nyb2xsLmN1cnJlbnRWYWx1ZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjaGFuZ2VzLnBhZ2VTaXplICYmIGNoYW5nZXMucGFnZVNpemUuY3VycmVudFZhbHVlICE9PSBjaGFuZ2VzLnBhZ2VTaXplLnByZXZpb3VzVmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgY2hlY2sgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlUmVxdWVzdHMubmV4dCh7XG4gICAgICAgICAgICAgICAgY2hlY2s6IGNoZWNrLFxuICAgICAgICAgICAgICAgIHBhZ2VOdW1iZXI6IHRoaXMuX25leHRQYWdlTnVtLFxuICAgICAgICAgICAgICAgIHBhZ2VTaXplOiB0aGlzLnBhZ2VTaXplLFxuICAgICAgICAgICAgICAgIGZpbHRlcjogdGhpcy5maWx0ZXJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGV0YWNoRXZlbnRIYW5kbGVycygpO1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kubmV4dCgpO1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kuY29tcGxldGUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0IGFuIGFkZGl0aW9uYWwgcGFnZSBvZiBkYXRhLlxuICAgICAqL1xuICAgIGxvYWROZXh0UGFnZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3VwZGF0ZVJlcXVlc3RzLm5leHQoe1xuICAgICAgICAgICAgY2hlY2s6IGZhbHNlLFxuICAgICAgICAgICAgcGFnZU51bWJlcjogdGhpcy5fbmV4dFBhZ2VOdW0sXG4gICAgICAgICAgICBwYWdlU2l6ZTogdGhpcy5wYWdlU2l6ZSxcbiAgICAgICAgICAgIGZpbHRlcjogdGhpcy5maWx0ZXJcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVxdWVzdCBhIGNoZWNrIGZvciB3aGV0aGVyIGFuIGFkZGl0aW9uYWwgcGFnZSBvZiBkYXRhIGlzIHJlcXVpcmVkLiBUaGlzIGlzIHRocm90dGxlZC5cbiAgICAgKi9cbiAgICBjaGVjaygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3VwZGF0ZVJlcXVlc3RzLm5leHQoe1xuICAgICAgICAgICAgY2hlY2s6IHRydWUsXG4gICAgICAgICAgICBwYWdlTnVtYmVyOiB0aGlzLl9uZXh0UGFnZU51bSxcbiAgICAgICAgICAgIHBhZ2VTaXplOiB0aGlzLnBhZ2VTaXplLFxuICAgICAgICAgICAgZmlsdGVyOiB0aGlzLmZpbHRlclxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhciB0aGUgY29sbGVjdGlvbi4gRnV0dXJlIHJlcXVlc3RzIHdpbGwgbG9hZCBmcm9tIHBhZ2UgMC5cbiAgICAgKi9cbiAgICByZXNldCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlc2V0IHRoZSBwYWdlIGNvdW50ZXIuXG4gICAgICAgIHRoaXMuX25leHRQYWdlTnVtID0gMDtcblxuICAgICAgICB0aGlzLl9wYWdlcyA9IFtdO1xuXG4gICAgICAgIC8vIENsZWFyIHRoZSBjb2xsZWN0aW9uICh3aXRob3V0IGNoYW5naW5nIHRoZSByZWZlcmVuY2UpLlxuICAgICAgICBpZiAodGhpcy5jb2xsZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmNvbGxlY3Rpb24ubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlc2V0IHRoZSBleGhhdXN0ZWQgZmxhZywgYWxsb3dpbmcgdGhlIExvYWQgTW9yZSBidXR0b24gdG8gYXBwZWFyLlxuICAgICAgICB0aGlzLl9pc0V4aGF1c3RlZC5uZXh0KGZhbHNlKTtcblxuICAgICAgICAvLyBDYW5jZWwgYW55IHBlbmRpbmcgcmVxdWVzdHNcbiAgICAgICAgaWYgKHRoaXMuX3N1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMuZm9yRWFjaChyZXF1ZXN0ID0+IHJlcXVlc3QudW5zdWJzY3JpYmUoKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWxvYWQgdGhlIGRhdGEgd2l0aG91dCBjbGVhcmluZyB0aGUgdmlldy5cbiAgICAgKi9cbiAgICByZWxvYWQoKSB7XG4gICAgICAgIHRoaXMuX3BhZ2VzLmZvckVhY2goKHBhZ2UsIGkpID0+IHRoaXMucmVsb2FkUGFnZShpKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVsb2FkIHRoZSBkYXRhIGluIGEgc3BlY2lmaWMgcGFnZSB3aXRob3V0IGNsZWFyaW5nIHRoZSB2aWV3LlxuICAgICAqIEBwYXJhbSBwYWdlTnVtIFBhZ2UgbnVtYmVyXG4gICAgICovXG4gICAgcmVsb2FkUGFnZShwYWdlTnVtOiBudW1iZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3VwZGF0ZVJlcXVlc3RzLm5leHQoe1xuICAgICAgICAgICAgY2hlY2s6IGZhbHNlLFxuICAgICAgICAgICAgcGFnZU51bWJlcjogcGFnZU51bSxcbiAgICAgICAgICAgIHBhZ2VTaXplOiB0aGlzLnBhZ2VTaXplLFxuICAgICAgICAgICAgZmlsdGVyOiB0aGlzLmZpbHRlcixcbiAgICAgICAgICAgIHJlbG9hZDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBdHRhY2ggc2Nyb2xsIGV2ZW50IGhhbmRsZXIgYW5kIERPTSBvYnNlcnZlci5cbiAgICAgKi9cbiAgICBwcml2YXRlIGF0dGFjaEV2ZW50SGFuZGxlcnMoKSB7XG5cbiAgICAgICAgLy8gaWYgdGhlIHNjcm9sbEVsZW1lbnQgaXMgZG9jdW1lbnRFbGVtZW50IHdlIG11c3Qgd2F0Y2ggZm9yIGEgc2Nyb2xsIGV2ZW50IG9uIHRoZSBkb2N1bWVudFxuICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLl9zY3JvbGxFbGVtZW50Lm5hdGl2ZUVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MSHRtbEVsZW1lbnQgPyBkb2N1bWVudCA6IHRoaXMuX3Njcm9sbEVsZW1lbnQubmF0aXZlRWxlbWVudDtcblxuICAgICAgICAvLyBTdWJzY3JpYmUgdG8gdGhlIHNjcm9sbCBldmVudCBvbiB0aGUgdGFyZ2V0IGVsZW1lbnQuXG4gICAgICAgIHRoaXMuX3Njcm9sbEV2ZW50U3ViID0gZnJvbUV2ZW50KHRhcmdldCwgJ3Njcm9sbCcpLnN1YnNjcmliZSh0aGlzLmNoZWNrLmJpbmQodGhpcykpO1xuXG4gICAgICAgIC8vIFN1YnNjcmliZSB0byBjaGlsZCBET00gY2hhbmdlcy4gVGhlIG1haW4gZWZmZWN0IG9mIHRoaXMgaXMgdG8gY2hlY2sgd2hldGhlciBldmVuIG1vcmUgZGF0YSBpc1xuICAgICAgICAvLyByZXF1aXJlZCBhZnRlciB0aGUgaW5pdGlhbCBsb2FkLlxuICAgICAgICB0aGlzLl9kb21PYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRoaXMuY2hlY2suYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuX2RvbU9ic2VydmVyLm9ic2VydmUodGhpcy5fc2Nyb2xsRWxlbWVudC5uYXRpdmVFbGVtZW50LCB7XG4gICAgICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgICAgICBzdWJ0cmVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERldGFjaCBzY3JvbGwgZXZlbnQgaGFuZGxlciBhbmQgRE9NIG9ic2VydmVyLlxuICAgICAqL1xuICAgIHByaXZhdGUgZGV0YWNoRXZlbnRIYW5kbGVycygpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Njcm9sbEV2ZW50U3ViKSB7XG4gICAgICAgICAgICB0aGlzLl9zY3JvbGxFdmVudFN1Yi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsRXZlbnRTdWIgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2RvbU9ic2VydmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9kb21PYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB0aGlzLl9kb21PYnNlcnZlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYW55IGV4aXN0aW5nIGV2ZW50IHN1YnNjcmlwdGlvbnMgZm9yIHRoZSBsb2FkIGJ1dHRvbiBgbG9hZGAgZXZlbnQsIHRoZW4gYXR0YWNoIHN1YnNjcmlwdGlvbnNcbiAgICAgKiBmb3IgYW55IGluIHRoZSBxdWVyeS5cbiAgICAgKi9cbiAgICBwcml2YXRlIGF0dGFjaExvYWRCdXR0b25FdmVudHMoKSB7XG4gICAgICAgIHRoaXMuX2xvYWRCdXR0b25TdWJzY3JpcHRpb25zLmZvckVhY2gocyA9PiBzLnVuc3Vic2NyaWJlKCkpO1xuICAgICAgICB0aGlzLl9sb2FkQnV0dG9uU3Vic2NyaXB0aW9ucyA9IHRoaXMuX2xvYWRCdXR0b25RdWVyeS5tYXAoXG4gICAgICAgICAgICBsb2FkQnV0dG9uID0+IGxvYWRCdXR0b24ubG9hZC5zdWJzY3JpYmUodGhpcy5sb2FkTmV4dFBhZ2UuYmluZCh0aGlzKSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb25kaXRpb25hbGx5IGxvYWRzIGEgcGFnZSBpbnRvIHRoZSBjb2xsZWN0aW9uIGJhc2VkIG9uIGRpcmVjdGl2ZSBzdGF0ZSBhbmQgcmVxdWVzdCBwYXJhbWV0ZXJzLlxuICAgICAqL1xuICAgIHByaXZhdGUgZG9SZXF1ZXN0KHJlcXVlc3Q6IEluZmluaXRlU2Nyb2xsUmVxdWVzdCkge1xuXG4gICAgICAgIC8vIExvYWQgYSBuZXcgcGFnZSBpZiB0aGUgc2Nyb2xsIHBvc2l0aW9uIGlzIGJleW9uZCB0aGUgdGhyZXNoaG9sZCBhbmQgaWYgdGhlIGNsaWVudCBjb2RlIGRpZCBub3RcbiAgICAgICAgLy8gY2FuY2VsLlxuICAgICAgICBpZiAodGhpcy5uZWVkc0RhdGEocmVxdWVzdCkgJiYgdGhpcy5iZWdpbkxvYWRpbmcocmVxdWVzdCkpIHtcblxuICAgICAgICAgICAgLy8gSW52b2tlIHRoZSBjYWxsYmFjayBsb2FkIGZ1bmN0aW9uLCB3aGljaCByZXR1cm5zIGEgcHJvbW9zZSBvciBwbGFpbiBkYXRhLlxuICAgICAgICAgICAgY29uc3QgbG9hZFJlc3VsdCA9IHRoaXMubG9hZChyZXF1ZXN0LnBhZ2VOdW1iZXIsIHJlcXVlc3QucGFnZVNpemUsIHJlcXVlc3QuZmlsdGVyKTtcblxuICAgICAgICAgICAgY29uc3Qgb2JzZXJ2YWJsZSA9IEFycmF5LmlzQXJyYXkobG9hZFJlc3VsdCkgPyBvZihsb2FkUmVzdWx0KSA6IGZyb208YW55W10+KGxvYWRSZXN1bHQpO1xuXG4gICAgICAgICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBvYnNlcnZhYmxlLnBpcGUoZmlyc3QoKSkuc3Vic2NyaWJlKFxuICAgICAgICAgICAgICAgIGl0ZW1zID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIHBhcmFtZXRlcnMgaGF2ZSBub3QgY2hhbmdlZCBzaW5jZSB0aGUgbG9hZCBzdGFydGVkO1xuICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgZGlzY2FyZCB0aGUgcmVzdWx0cy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QuZmlsdGVyID09PSB0aGlzLmZpbHRlciAmJiByZXF1ZXN0LnBhZ2VTaXplID09PSB0aGlzLnBhZ2VTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbXMgJiYgaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRQYWdlSXRlbXMocmVxdWVzdC5wYWdlTnVtYmVyLCBpdGVtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVtaXQgdGhlIGxvYWRlZCBldmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmRMb2FkaW5nKHJlcXVlc3QsIGl0ZW1zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVhc29uID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRW1pdCB0aGUgbG9hZEVycm9yIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kTG9hZGluZ1dpdGhFcnJvcihyZXF1ZXN0LCByZWFzb24pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhpcyByZXF1ZXN0IGZyb20gdGhlIGxpc3RcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9ucyA9IHRoaXMuX3N1YnNjcmlwdGlvbnMuZmlsdGVyKHMgPT4gcyAhPT0gc3Vic2NyaXB0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAvLyBhZGQgdGhlIHN1YnNjcmlwdGlvbiB0byB0aGUgbGlzdCBvZiByZXF1ZXN0c1xuICAgICAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9ucy5wdXNoKHN1YnNjcmlwdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHJlcXVlc3Qgc2hvdWxkIGJlIGZ1bGZpbGxlZC5cbiAgICAgKi9cbiAgICBwcml2YXRlIG5lZWRzRGF0YShyZXF1ZXN0OiBJbmZpbml0ZVNjcm9sbFJlcXVlc3QpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFsd2F5cyBsb2FkIGZvciBhIGxvYWQgcmVxdWVzdFxuICAgICAgICBpZiAoIXJlcXVlc3QuY2hlY2spIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWdub3JlIGEgY2hlY2sgcmVxdWVzdCB3aGVuIHRoZSBlbmQgb2YgZGF0YSBoYXMgYmVlbiBkZXRlY3RlZCwgb3IgaWYgZGF0YSBpcyBjdXJyZW50bHkgbG9hZGluZy5cbiAgICAgICAgaWYgKHRoaXMuX2lzRXhoYXVzdGVkLmdldFZhbHVlKCkgfHwgdGhpcy5faXNMb2FkaW5nLmdldFZhbHVlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIExvYWQgaWYgdGhlIHJlbWFpbmluZyBzY3JvbGwgYXJlYSBpcyA8PSB0aGUgZWxlbWVudCBoZWlnaHQuXG4gICAgICAgIGlmICh0aGlzLl9zY3JvbGxFbGVtZW50ICYmIHRoaXMubG9hZE9uU2Nyb2xsKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSA8SFRNTEVsZW1lbnQ+dGhpcy5fc2Nyb2xsRWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgY29uc3QgcmVtYWluaW5nU2Nyb2xsID1cbiAgICAgICAgICAgICAgICBlbGVtZW50LnNjcm9sbEhlaWdodCAtXG4gICAgICAgICAgICAgICAgKGVsZW1lbnQuc2Nyb2xsVG9wICsgZWxlbWVudC5jbGllbnRIZWlnaHQpO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVtYWluaW5nU2Nyb2xsIDw9IGVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgc3RhdGUgZm9yIHRoZSBiZWdpbm5pbmcgb2YgYSBsb2FkLiBSZXR1cm5zIGZhbHNlIGlmIHRoZSBgbG9hZGluZ2AgZXZlbnQgd2FzIGNhbmNlbGxlZC5cbiAgICAgKi9cbiAgICBwcml2YXRlIGJlZ2luTG9hZGluZyhyZXF1ZXN0OiBJbmZpbml0ZVNjcm9sbFJlcXVlc3QpOiBib29sZWFuIHtcblxuICAgICAgICBjb25zdCBldmVudCA9IG5ldyBJbmZpbml0ZVNjcm9sbExvYWRpbmdFdmVudChcbiAgICAgICAgICAgIHJlcXVlc3QucGFnZU51bWJlcixcbiAgICAgICAgICAgIHJlcXVlc3QucGFnZVNpemUsXG4gICAgICAgICAgICByZXF1ZXN0LmZpbHRlclxuICAgICAgICApO1xuICAgICAgICB0aGlzLmxvYWRpbmdFdmVudC5lbWl0KGV2ZW50KTtcblxuICAgICAgICB0aGlzLl9pc0xvYWRpbmcubmV4dCghZXZlbnQuZGVmYXVsdFByZXZlbnRlZCgpKTtcblxuICAgICAgICByZXR1cm4gIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHNldFBhZ2VJdGVtcyhwYWdlTnVtOiBudW1iZXIsIGl0ZW1zOiBhbnlbXSkge1xuICAgICAgICB0aGlzLl9wYWdlc1twYWdlTnVtXSA9IGl0ZW1zO1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb24gPSB0aGlzLl9wYWdlcy5yZWR1Y2UoKHByZXZpb3VzLCBjdXJyZW50KSA9PiBwcmV2aW91cy5jb25jYXQoY3VycmVudCksIFtdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHN0YXRlIGZyb20gYSBzdWNjZXNzZnVsIGxvYWQuIFJhaXNlcyB0aGUgYGxvYWRlZGAgZXZlbnQuXG4gICAgICovXG4gICAgcHJpdmF0ZSBlbmRMb2FkaW5nKHJlcXVlc3Q6IEluZmluaXRlU2Nyb2xsUmVxdWVzdCwgZGF0YT86IGFueSkge1xuICAgICAgICB0aGlzLl9pc0xvYWRpbmcubmV4dChmYWxzZSk7XG5cbiAgICAgICAgY29uc3QgaXNFeGhhdXN0ZWQgPSAhIShkYXRhICYmIGRhdGEubGVuZ3RoIDwgdGhpcy5wYWdlU2l6ZSk7XG4gICAgICAgIHRoaXMuX2lzRXhoYXVzdGVkLm5leHQoaXNFeGhhdXN0ZWQpO1xuXG4gICAgICAgIHRoaXMubG9hZGVkRXZlbnQuZW1pdChcbiAgICAgICAgICAgIG5ldyBJbmZpbml0ZVNjcm9sbExvYWRlZEV2ZW50KFxuICAgICAgICAgICAgICAgIHJlcXVlc3QucGFnZU51bWJlcixcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnBhZ2VTaXplLFxuICAgICAgICAgICAgICAgIHJlcXVlc3QuZmlsdGVyLFxuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgaXNFeGhhdXN0ZWRcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoIXJlcXVlc3QucmVsb2FkKSB7XG4gICAgICAgICAgICB0aGlzLl9uZXh0UGFnZU51bSArPSAxO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBzdGF0ZSBmcm9tIGEgZmFpbGVkIGxvYWQuIFJhaXNlcyB0aGUgYGxvYWRFcnJvcmAgZXZlbnQuXG4gICAgICovXG4gICAgcHJpdmF0ZSBlbmRMb2FkaW5nV2l0aEVycm9yKHJlcXVlc3Q6IEluZmluaXRlU2Nyb2xsUmVxdWVzdCwgZXJyb3I6IGFueSkge1xuICAgICAgICB0aGlzLl9pc0xvYWRpbmcubmV4dChmYWxzZSk7XG5cbiAgICAgICAgdGhpcy5sb2FkRXJyb3JFdmVudC5lbWl0KFxuICAgICAgICAgICAgbmV3IEluZmluaXRlU2Nyb2xsTG9hZEVycm9yRXZlbnQoXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5wYWdlTnVtYmVyLFxuICAgICAgICAgICAgICAgIHJlcXVlc3QucGFnZVNpemUsXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5maWx0ZXIsXG4gICAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhlIGludGVybmFsIGRhdGEgYXNzb2NpYXRlZCB3aXRoIGEgbG9hZC9jaGVjayByZXF1ZXN0LlxuICovXG5jbGFzcyBJbmZpbml0ZVNjcm9sbFJlcXVlc3Qge1xuICAgIGNoZWNrOiBib29sZWFuO1xuICAgIHBhZ2VOdW1iZXI6IG51bWJlcjtcbiAgICBwYWdlU2l6ZTogbnVtYmVyO1xuICAgIGZpbHRlcjogYW55O1xuICAgIHJlbG9hZD86IGJvb2xlYW47XG59XG5cbmV4cG9ydCB0eXBlIEluZmluaXRlU2Nyb2xsTG9hZEZ1bmN0aW9uID0gKFxuICAgIHBhZ2VOdW06IG51bWJlcixcbiAgICBwYWdlU2l6ZTogbnVtYmVyLFxuICAgIGZpbHRlcjogYW55XG4pID0+IGFueSB8IFByb21pc2U8YW55PjtcblxuLyoqXG4gKiBFdmVudCByYWlzZWQgYmVmb3JlIHRoZSBgbG9hZGluZ2AgZnVuY3Rpb24gaXMgY2FsbGVkLlxuICovXG5leHBvcnQgY2xhc3MgSW5maW5pdGVTY3JvbGxMb2FkaW5nRXZlbnQge1xuICAgIHByaXZhdGUgX2RlZmF1bHRQcmV2ZW50ZWQgPSBmYWxzZTtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGluZGV4IG9mIHRoZSByZXF1ZXN0ZWQgcGFnZSwgc3RhcnRpbmcgZnJvbSAwLlxuICAgICAgICAgKi9cbiAgICAgICAgcHVibGljIHBhZ2VOdW1iZXI6IG51bWJlcixcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBudW1iZXIgb2YgaXRlbXMgcmVxdWVzdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgcHVibGljIHBhZ2VTaXplOiBudW1iZXIsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZmlsdGVyIGRldGFpbHMgYXMgcHJvdmlkZWQgdmlhIHRoZSBgZmlsdGVyYCBiaW5kaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgcHVibGljIGZpbHRlcjogYW55XG4gICAgKSB7IH1cblxuICAgIC8qKlxuICAgICAqIFByZXZlbnRzIHRoZSBkZWZhdWx0IGJlaGF2aW91ciBvZiB0aGUgYGxvYWRpbmdgIGV2ZW50IChsb2FkaW5nIGZ1bmN0aW9uIHdpbGwgbm90IGJlIGNhbGxlZCkuXG4gICAgICovXG4gICAgcHJldmVudERlZmF1bHQoKSB7XG4gICAgICAgIHRoaXMuX2RlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGRlZmF1bHRQcmV2ZW50ZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWZhdWx0UHJldmVudGVkO1xuICAgIH1cbn1cblxuLyoqXG4gKiBFdmVudCByYWlzZWQgd2hlbiB0aGUgbG9hZGluZyBmdW5jdGlvbiByZXN1bHQgaGFzIGJlZW4gcmVzb2x2ZWQgYW5kIGFkZGVkIHRvIHRoZSBjb2xsZWN0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgSW5maW5pdGVTY3JvbGxMb2FkZWRFdmVudCB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaW5kZXggb2YgdGhlIHJlcXVlc3RlZCBwYWdlLCBzdGFydGluZyBmcm9tIDAuXG4gICAgICAgICAqL1xuICAgICAgICBwdWJsaWMgcGFnZU51bWJlcjogbnVtYmVyLFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG51bWJlciBvZiBpdGVtcyByZXF1ZXN0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICBwdWJsaWMgcGFnZVNpemU6IG51bWJlcixcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBmaWx0ZXIgZGV0YWlscyBhcyBwcm92aWRlZCB2aWEgdGhlIGBmaWx0ZXJgIGJpbmRpbmcuXG4gICAgICAgICAqL1xuICAgICAgICBwdWJsaWMgZmlsdGVyOiBhbnksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcmVzdWx0IG9mIHRoZSBwcm9taXNlIHJldHVybmVkIGZyb20gdGhlIGxvYWRpbmcgZnVuY3Rpb24uXG4gICAgICAgICAqL1xuICAgICAgICBwdWJsaWMgZGF0YTogYW55LFxuICAgICAgICAvKipcbiAgICAgICAgICogVHJ1ZSBpZiB0aGUgZGF0YSBpcyBjb25zaWRlcmVkIGV4aGF1c3RlZCAobnVtYmVyIG9mIGl0ZW1zIHJldHVybmVkIGxlc3MgdGhhbiBgcGFnZVNpemVgKS5cbiAgICAgICAgICovXG4gICAgICAgIHB1YmxpYyBleGhhdXN0ZWQ6IGJvb2xlYW5cbiAgICApIHsgfVxufVxuXG4vKipcbiAqIEV2ZW50IHJhaXNlZCBpZiB0aGUgbG9hZGluZyBmdW5jdGlvbiByZXR1cm5zIGEgcmVqZWN0ZWQgcHJvbWlzZS5cbiAqL1xuZXhwb3J0IGNsYXNzIEluZmluaXRlU2Nyb2xsTG9hZEVycm9yRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGluZGV4IG9mIHRoZSByZXF1ZXN0ZWQgcGFnZSwgc3RhcnRpbmcgZnJvbSAwLlxuICAgICAgICAgKi9cbiAgICAgICAgcHVibGljIHBhZ2VOdW1iZXI6IG51bWJlcixcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBudW1iZXIgb2YgaXRlbXMgcmVxdWVzdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgcHVibGljIHBhZ2VTaXplOiBudW1iZXIsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZmlsdGVyIGRldGFpbHMgYXMgcHJvdmlkZWQgdmlhIHRoZSBgZmlsdGVyYCBiaW5kaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgcHVibGljIGZpbHRlcjogYW55LFxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG9iamVjdCBwcm92aWRlZCB3aGVuIHJlamVjdGluZyB0aGUgcHJvbWlzZS5cbiAgICAgICAgICovXG4gICAgICAgIHB1YmxpYyBlcnJvcjogYW55XG4gICAgKSB7IH1cbn1cbiIsImltcG9ydCB7IEluZmluaXRlU2Nyb2xsTG9hZEJ1dHRvbkRpcmVjdGl2ZSB9IGZyb20gJy4vaW5maW5pdGUtc2Nyb2xsLWxvYWQtYnV0dG9uLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBJbmZpbml0ZVNjcm9sbExvYWRpbmdEaXJlY3RpdmUgfSBmcm9tICcuL2luZmluaXRlLXNjcm9sbC1sb2FkaW5nLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBJbmZpbml0ZVNjcm9sbERpcmVjdGl2ZSB9IGZyb20gJy4vaW5maW5pdGUtc2Nyb2xsLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgSW5maW5pdGVTY3JvbGxEaXJlY3RpdmUsXG4gICAgICAgIEluZmluaXRlU2Nyb2xsTG9hZEJ1dHRvbkRpcmVjdGl2ZSxcbiAgICAgICAgSW5maW5pdGVTY3JvbGxMb2FkaW5nRGlyZWN0aXZlXG4gICAgXSxcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgSW5maW5pdGVTY3JvbGxEaXJlY3RpdmUsXG4gICAgICAgIEluZmluaXRlU2Nyb2xsTG9hZEJ1dHRvbkRpcmVjdGl2ZSxcbiAgICAgICAgSW5maW5pdGVTY3JvbGxMb2FkaW5nRGlyZWN0aXZlXG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtdLFxufSlcbmV4cG9ydCBjbGFzcyBJbmZpbml0ZVNjcm9sbE1vZHVsZSB7IH1cbiIsImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFNjcm9sbEludG9WaWV3U2VydmljZSB7XG5cbiAgICBzY3JvbGxJbnRvVmlldyhlbGVtOiBIVE1MRWxlbWVudCwgc2Nyb2xsUGFyZW50OiBIVE1MRWxlbWVudCkge1xuICAgICAgICBjb25zdCBvZmZzZXRUb3AgPSAoZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgKyBzY3JvbGxQYXJlbnQuc2Nyb2xsVG9wKSAtIHNjcm9sbFBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XG4gICAgICAgIGlmIChvZmZzZXRUb3AgPCBzY3JvbGxQYXJlbnQuc2Nyb2xsVG9wKSB7XG4gICAgICAgICAgICBzY3JvbGxQYXJlbnQuc2Nyb2xsVG9wID0gb2Zmc2V0VG9wO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0Qm90dG9tID0gb2Zmc2V0VG9wICsgZWxlbS5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICBpZiAob2Zmc2V0Qm90dG9tID4gKHNjcm9sbFBhcmVudC5zY3JvbGxUb3AgKyBzY3JvbGxQYXJlbnQuY2xpZW50SGVpZ2h0KSkge1xuICAgICAgICAgICAgICAgIHNjcm9sbFBhcmVudC5zY3JvbGxUb3AgPSBvZmZzZXRCb3R0b20gLSBzY3JvbGxQYXJlbnQuY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSW5wdXQsIE9uQ2hhbmdlcyB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU2Nyb2xsSW50b1ZpZXdTZXJ2aWNlIH0gZnJvbSAnLi9zY3JvbGwtaW50by12aWV3LnNlcnZpY2UnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1t1eFNjcm9sbEludG9WaWV3SWZdJyxcbiAgICBwcm92aWRlcnM6IFtTY3JvbGxJbnRvVmlld1NlcnZpY2VdXG4gfSlcbmV4cG9ydCBjbGFzcyBTY3JvbGxJbnRvVmlld0lmRGlyZWN0aXZlIGltcGxlbWVudHMgT25DaGFuZ2VzIHtcblxuICAgIEBJbnB1dCgndXhTY3JvbGxJbnRvVmlld0lmJykgY29uZGl0aW9uID0gZmFsc2U7XG4gICAgQElucHV0KCkgc2Nyb2xsUGFyZW50OiBIVE1MRWxlbWVudDtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX2VsZW1lbnQ6IEVsZW1lbnRSZWYsIHByaXZhdGUgX3Njcm9sbEludG9WaWV3U2VydmljZTogU2Nyb2xsSW50b1ZpZXdTZXJ2aWNlKSB7fVxuXG4gICAgbmdPbkNoYW5nZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbmRpdGlvbikge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLl9zY3JvbGxJbnRvVmlld1NlcnZpY2Uuc2Nyb2xsSW50b1ZpZXcodGhpcy5fZWxlbWVudC5uYXRpdmVFbGVtZW50LCB0aGlzLnNjcm9sbFBhcmVudCkpO1xuICAgICAgICB9XG4gICAgfVxufSIsImltcG9ydCB7IEFmdGVyVmlld0luaXQsIERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbdXhTY3JvbGxJbnRvVmlld10nXG59KVxuZXhwb3J0IGNsYXNzIFNjcm9sbEludG9WaWV3RGlyZWN0aXZlIGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCB7XG5cbiAgICAvKiogQWxsb3cgYSBjb25kaXRpb24gYXJvdW5kIHdoZXRoZXIgb3Igbm90IHRoaXMgc2hvdWxkIHNjcm9sbCBpbnRvIHZpZXcgKi9cbiAgICBASW5wdXQoKSB1eFNjcm9sbEludG9WaWV3OiBib29sZWFuID0gdHJ1ZTtcblxuICAgIC8qKiBBbGxvdyB1c2VyIHRvIHByb3ZpZGUgdGhlIGJyb3dzZXIgc3VwcG9ydGVkIG9wdGlvbnMgKi9cbiAgICBASW5wdXQoKSBzY3JvbGxJbnRvVmlld09wdGlvbnM6IFNjcm9sbEludG9WaWV3T3B0aW9ucyB8IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZikgeyB9XG5cbiAgICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLnV4U2Nyb2xsSW50b1ZpZXcpIHtcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5zY3JvbGxJbnRvVmlldyh0aGlzLnNjcm9sbEludG9WaWV3T3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG59IiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFNjcm9sbEludG9WaWV3SWZEaXJlY3RpdmUgfSBmcm9tICcuL3Njcm9sbC1pbnRvLXZpZXctaWYuZGlyZWN0aXZlJztcbmltcG9ydCB7IFNjcm9sbEludG9WaWV3RGlyZWN0aXZlIH0gZnJvbSAnLi9zY3JvbGwtaW50by12aWV3LmRpcmVjdGl2ZSc7XG5cblxuQE5nTW9kdWxlKHtcbiAgICBleHBvcnRzOiBbU2Nyb2xsSW50b1ZpZXdJZkRpcmVjdGl2ZSwgU2Nyb2xsSW50b1ZpZXdEaXJlY3RpdmVdLFxuICAgIGRlY2xhcmF0aW9uczogW1Njcm9sbEludG9WaWV3SWZEaXJlY3RpdmUsIFNjcm9sbEludG9WaWV3RGlyZWN0aXZlXVxufSlcbmV4cG9ydCBjbGFzcyBTY3JvbGxNb2R1bGUgeyB9IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBUeXBlYWhlYWRTZXJ2aWNlIH0gZnJvbSAnLi90eXBlYWhlYWQuc2VydmljZSc7XHJcblxyXG5ARGlyZWN0aXZlKHtcclxuICAgIHNlbGVjdG9yOiAnW3V4VHlwZWFoZWFkSGlnaGxpZ2h0XSdcclxufSlcclxuZXhwb3J0IGNsYXNzIFR5cGVhaGVhZEhpZ2hsaWdodERpcmVjdGl2ZSB7XHJcblxyXG4gICAgQElucHV0KCd1eFR5cGVhaGVhZEhpZ2hsaWdodCcpXHJcbiAgICBzZXQgaGlnaGxpZ2h0KHZhbHVlOiBib29sZWFuKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NlcnZpY2UuaGlnaGxpZ2h0ZWRFbGVtZW50JC5uZXh0KHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX3NlcnZpY2U6IFR5cGVhaGVhZFNlcnZpY2UsIHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYpIHt9XHJcbn1cclxuIiwiaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBJbmZpbml0ZVNjcm9sbE1vZHVsZSB9IGZyb20gJy4uLy4uL2RpcmVjdGl2ZXMvaW5maW5pdGUtc2Nyb2xsL2luZGV4JztcbmltcG9ydCB7IFNjcm9sbE1vZHVsZSB9IGZyb20gJy4uLy4uL2RpcmVjdGl2ZXMvc2Nyb2xsL2luZGV4JztcbmltcG9ydCB7IFR5cGVhaGVhZEhpZ2hsaWdodERpcmVjdGl2ZSB9IGZyb20gJy4vdHlwZWFoZWFkLWhpZ2hsaWdodC5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgVHlwZWFoZWFkS2V5U2VydmljZSB9IGZyb20gJy4vdHlwZWFoZWFkLWtleS5zZXJ2aWNlJztcbmltcG9ydCB7IFR5cGVhaGVhZENvbXBvbmVudCB9IGZyb20gJy4vdHlwZWFoZWFkLmNvbXBvbmVudCc7XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIEluZmluaXRlU2Nyb2xsTW9kdWxlLFxuICAgICAgICBTY3JvbGxNb2R1bGVcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtUeXBlYWhlYWRDb21wb25lbnRdLFxuICAgIGRlY2xhcmF0aW9uczogW1R5cGVhaGVhZENvbXBvbmVudCwgVHlwZWFoZWFkSGlnaGxpZ2h0RGlyZWN0aXZlXSxcbiAgICBwcm92aWRlcnM6IFtUeXBlYWhlYWRLZXlTZXJ2aWNlXSxcbn0pXG5leHBvcnQgY2xhc3MgVHlwZWFoZWFkTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgRGlyZWN0aXZlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcblxyXG5ARGlyZWN0aXZlKHtcclxuICAgIHNlbGVjdG9yOiAnW3V4UmVvcmRlcmFibGVIYW5kbGVdJ1xyXG59KVxyXG5leHBvcnQgY2xhc3MgUmVvcmRlcmFibGVIYW5kbGVEaXJlY3RpdmUgeyB9XHJcbiIsImltcG9ydCB7IERpcmVjdGl2ZSwgSW5wdXQsIEVsZW1lbnRSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcbkBEaXJlY3RpdmUoe1xyXG4gICAgc2VsZWN0b3I6ICdbdXhSZW9yZGVyYWJsZU1vZGVsXSdcclxufSlcclxuZXhwb3J0IGNsYXNzIFJlb3JkZXJhYmxlTW9kZWxEaXJlY3RpdmUge1xyXG5cclxuICAgIC8vIGFsbG93IHRoZSB1c2VyIHRvIHNwZWNpZnkgYSBtb2RlbCBmb3IgdGhlIGl0ZW0gLSBhbGxvd3MgdXNlIHdpdGggbmdGb3JcclxuICAgIEBJbnB1dCgpIHV4UmVvcmRlcmFibGVNb2RlbDogYW55O1xyXG5cclxuICAgIC8vIHRoaXMgY2FuIGJlIHVzZWQgdG8gaWRlbnRpZnkgd2hpY2ggaW5zdGFuY2Ugb2YgdGhlIGRpcmVjdGl2ZSByZWxhdGVzIHRvIHdoaWNoIGVsZW1lbnRcclxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbGVtZW50UmVmOiBFbGVtZW50UmVmKSB7IH1cclxufVxyXG4iLCIvLyBXT1JLQVJPVU5EOiBuZy1wYWNrYWdyIGlzc3VlIC0gaHR0cHM6Ly9naXRodWIuY29tL2RoZXJnZXMvbmctcGFja2Fnci9pc3N1ZXMvMTYzXG5pbXBvcnQgeyBEcmFrZSB9IGZyb20gJ2RyYWd1bGEnO1xuLy8gQHRzLWlnbm9yZVxuaW1wb3J0ICogYXMgZHJhZ3VsYU5hbWVzcGFjZSBmcm9tICdkcmFndWxhL2Rpc3QvZHJhZ3VsYSc7XG5cbmV4cG9ydCBjb25zdCBkcmFndWxhOiAoY29udGFpbmVycz86IGFueSwgb3B0aW9ucz86IGFueSkgPT4gRHJha2UgPSAoZHJhZ3VsYU5hbWVzcGFjZSBhcyBhbnkpLmRlZmF1bHQgfHwgZHJhZ3VsYU5hbWVzcGFjZTtcbiIsImltcG9ydCB7IEluamVjdGFibGUsIEV2ZW50RW1pdHRlciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRHJha2UsIERyYWd1bGFPcHRpb25zIH0gZnJvbSAnZHJhZ3VsYSc7XG5pbXBvcnQgeyBkcmFndWxhIH0gZnJvbSAnLi9kcmFndWxhJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFJlb3JkZXJhYmxlU2VydmljZSB7XG5cbiAgICBwcml2YXRlIF9ncm91cHM6IHsgW2s6IHN0cmluZ106IFJlb3JkZXJhYmxlR3JvdXAgfSA9IHt9O1xuICAgIHByaXZhdGUgX3VuaXF1ZUdyb3VwSWQgPSAwO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHVuaXF1ZSBzdHJpbmcgd2hpY2ggY2FuIGJlIHVzZWQgYXMgYSBncm91cCBuYW1lIGlmIG9uZSB3YXMgbm90IGNvbmZpZ3VyZWQuXG4gICAgICovXG4gICAgZ2V0VW5pcXVlR3JvdXBOYW1lKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiAnX3V4UmVvcmRlcmFibGVfJyArIHRoaXMuX3VuaXF1ZUdyb3VwSWQrKztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSBjb250YWluZXIgdG8gdGhlIG5hbWVkIGdyb3VwLlxuICAgICAqL1xuICAgIHJlZ2lzdGVyKGdyb3VwTmFtZTogc3RyaW5nLCBjb250YWluZXI6IFJlb3JkZXJhYmxlQ29udGFpbmVyKTogUmVvcmRlcmFibGVHcm91cCB7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9ncm91cHNbZ3JvdXBOYW1lXSkge1xuICAgICAgICAgICAgdGhpcy5fZ3JvdXBzW2dyb3VwTmFtZV0gPSBuZXcgUmVvcmRlcmFibGVHcm91cCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZ3JvdXBzW2dyb3VwTmFtZV0ucmVnaXN0ZXIoY29udGFpbmVyKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fZ3JvdXBzW2dyb3VwTmFtZV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgY29udGFpbmVyIGZyb20gdGhlIG5hbWVkIGdyb3VwLiBJZiBpdCB3YXMgdGhlIGxhc3QgY29udGFpbmVyIGluIHRoZSBncm91cCwgZGVzdHJveXMgdGhlIGdyb3VwLlxuICAgICAqL1xuICAgIHVucmVnaXN0ZXIoZ3JvdXBOYW1lOiBzdHJpbmcsIGNvbnRhaW5lcjogUmVvcmRlcmFibGVDb250YWluZXIpOiB2b2lkIHtcblxuICAgICAgICBjb25zdCBncm91cCA9IHRoaXMuX2dyb3Vwc1tncm91cE5hbWVdO1xuXG4gICAgICAgIGlmIChncm91cCkge1xuICAgICAgICAgICAgZ3JvdXAudW5yZWdpc3Rlcihjb250YWluZXIpO1xuXG4gICAgICAgICAgICBpZiAoZ3JvdXAuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgZ3JvdXAuZGVzdHJveSgpO1xuXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2dyb3Vwc1tncm91cE5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgZHJhZ3VsYSBpbnN0YW5jZSB3aXRoIHRoZSBjdXJyZW50IGNvbmZpZyBhbmQgYXR0YWNoZXMgdGhlIGV2ZW50cywgaWYgbm90IGFscmVhZHkgY3JlYXRlZC5cbiAgICAgKi9cbiAgICBpbml0aWFsaXplKGdyb3VwTmFtZTogc3RyaW5nKTogUmVvcmRlcmFibGVHcm91cCB7XG5cbiAgICAgICAgY29uc3QgZ3JvdXAgPSB0aGlzLl9ncm91cHNbZ3JvdXBOYW1lXTtcblxuICAgICAgICBpZiAoZ3JvdXApIHtcbiAgICAgICAgICAgIGdyb3VwLmluaXRpYWxpemUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBncm91cDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBncm91cCBvYmplY3QgZm9yIHRoZSBnaXZlbiBuYW1lLlxuICAgICAqL1xuICAgIGdldEdyb3VwKGdyb3VwOiBzdHJpbmcpOiBSZW9yZGVyYWJsZUdyb3VwIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dyb3Vwc1tncm91cF07XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlb3JkZXJhYmxlQ29udGFpbmVyIHtcbiAgICBlbGVtZW50OiBFbGVtZW50O1xuICAgIGdldE1vZGVsRnJvbUVsZW1lbnQ6IChlbGVtZW50OiBFbGVtZW50KSA9PiBhbnk7XG4gICAgY2FuTW92ZTogKGVsZW1lbnQ6IEVsZW1lbnQsIGNvbnRhaW5lcjogRWxlbWVudCwgaGFuZGxlOiBFbGVtZW50KSA9PiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlb3JkZXJhYmxlRHJhZ0V2ZW50IHtcbiAgICBtb2RlbDogYW55O1xuICAgIGVsZW1lbnQ6IEVsZW1lbnQ7XG4gICAgc291cmNlOiBFbGVtZW50O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlb3JkZXJhYmxlRHJhZ0VuZEV2ZW50IHtcbiAgICBtb2RlbDogYW55O1xuICAgIGVsZW1lbnQ6IEVsZW1lbnQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVvcmRlcmFibGVEcm9wRXZlbnQge1xuICAgIG1vZGVsOiBhbnk7XG4gICAgZWxlbWVudDogRWxlbWVudDtcbiAgICB0YXJnZXQ6IEVsZW1lbnQ7XG4gICAgc291cmNlOiBFbGVtZW50O1xuICAgIHNpYmxpbmc6IEVsZW1lbnQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVvcmRlcmFibGVDYW5jZWxFdmVudCB7XG4gICAgbW9kZWw6IGFueTtcbiAgICBlbGVtZW50OiBFbGVtZW50O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlb3JkZXJhYmxlQ2xvbmVkRXZlbnQge1xuICAgIGNsb25lOiBFbGVtZW50O1xuICAgIGVsZW1lbnQ6IEVsZW1lbnQ7XG4gICAgdHlwZTogc3RyaW5nO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBjb2xsZWN0aW9uIG9mIGRyYWctYW5kLWRyb3AgY29udGFpbmVycyAodXhSZW9yZGVyYWJsZSkgdGhhdCBpdGVtcyBjYW4gYmUgZHJhZ2dlZCBiZXR3ZWVuLlxuICovXG5leHBvcnQgY2xhc3MgUmVvcmRlcmFibGVHcm91cCB7XG5cbiAgICBkcmFnID0gbmV3IEV2ZW50RW1pdHRlcjxSZW9yZGVyYWJsZURyYWdFdmVudD4oKTtcbiAgICBkcmFnRW5kID0gbmV3IEV2ZW50RW1pdHRlcjxSZW9yZGVyYWJsZURyYWdFbmRFdmVudD4oKTtcbiAgICBkcm9wID0gbmV3IEV2ZW50RW1pdHRlcjxSZW9yZGVyYWJsZURyb3BFdmVudD4oKTtcbiAgICBjYW5jZWwgPSBuZXcgRXZlbnRFbWl0dGVyPFJlb3JkZXJhYmxlQ2FuY2VsRXZlbnQ+KCk7XG4gICAgY2xvbmVkID0gbmV3IEV2ZW50RW1pdHRlcjxSZW9yZGVyYWJsZUNsb25lZEV2ZW50PigpO1xuXG4gICAgcHJpdmF0ZSBfaW5zdGFuY2U6IERyYWtlO1xuICAgIHByaXZhdGUgX2NvbnRhaW5lcnM6IFJlb3JkZXJhYmxlQ29udGFpbmVyW10gPSBbXTtcblxuICAgIHByaXZhdGUgX2NvbmZpZzogRHJhZ3VsYU9wdGlvbnMgPSB7XG4gICAgICAgIG1vdmVzOiB0aGlzLmNhbk1vdmUuYmluZCh0aGlzKVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlcmUgYXJlIG5vIGNvbnRhaW5lcnMgcmVnaXN0ZXJlZCB3aXRoIHRoZSBncm91cC5cbiAgICAgKi9cbiAgICBpc0VtcHR5KCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29udGFpbmVycy5sZW5ndGggPT09IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbW9kZWwgb2JqZWN0ICh1eFJlb3JkZXJhYmxlTW9kZWwpIGZvciBhbiBlbGVtZW50cyBpbiBvbmUgb2YgdGhlIGNvbnRhaW5lcnMgaW4gdGhlIGdyb3VwLlxuICAgICAqL1xuICAgIGdldE1vZGVsRm9yRWxlbWVudChlbGVtZW50OiBFbGVtZW50KTogYW55IHtcbiAgICAgICAgZm9yIChjb25zdCBjb250YWluZXIgb2YgdGhpcy5fY29udGFpbmVycykge1xuICAgICAgICAgICAgY29uc3QgbW9kZWwgPSBjb250YWluZXIuZ2V0TW9kZWxGcm9tRWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChtb2RlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb2RlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgdGhlIGNvbnRhaW5lciB0byB0aGUgZ3JvdXAuXG4gICAgICovXG4gICAgcmVnaXN0ZXIoY29udGFpbmVyOiBSZW9yZGVyYWJsZUNvbnRhaW5lcik6IHZvaWQge1xuICAgICAgICB0aGlzLl9jb250YWluZXJzLnB1c2goY29udGFpbmVyKTtcblxuICAgICAgICBpZiAodGhpcy5faW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlLmNvbnRhaW5lcnMgPSB0aGlzLl9jb250YWluZXJzLm1hcCgoYykgPT4gYy5lbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fY29uZmlnLm1pcnJvckNvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhpcy5fY29uZmlnLm1pcnJvckNvbnRhaW5lciA9IGNvbnRhaW5lci5lbGVtZW50O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgY29udGFpbmVyIGZyb20gdGhlIGdyb3VwLlxuICAgICAqL1xuICAgIHVucmVnaXN0ZXIoY29udGFpbmVyOiBSZW9yZGVyYWJsZUNvbnRhaW5lcik6IHZvaWQge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuX2NvbnRhaW5lcnMuaW5kZXhPZihjb250YWluZXIpO1xuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgdGhpcy5fY29udGFpbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2luc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5zdGFuY2UuY29udGFpbmVycyA9IHRoaXMuX2NvbnRhaW5lcnMubWFwKChjKSA9PiBjLmVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgZHJhZ3VsYSBpbnN0YW5jZSB3aXRoIHRoZSBjdXJyZW50IGNvbmZpZyBhbmQgYXR0YWNoZXMgdGhlIGV2ZW50cywgaWYgbm90IGFscmVhZHkgY3JlYXRlZC5cbiAgICAgKi9cbiAgICBpbml0aWFsaXplKCk6IHZvaWQge1xuXG4gICAgICAgIGlmICh0aGlzLl9pbnN0YW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5faW5zdGFuY2UgPSBkcmFndWxhKHRoaXMuX2NvbnRhaW5lcnMubWFwKChjKSA9PiBjLmVsZW1lbnQpLCB0aGlzLl9jb25maWcpO1xuXG4gICAgICAgIHRoaXMuX2luc3RhbmNlLm9uKCdkcmFnJywgKGVsZW1lbnQ6IEVsZW1lbnQsIHNvdXJjZTogRWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kcmFnLmVtaXQoe1xuICAgICAgICAgICAgICAgIG1vZGVsOiB0aGlzLmdldE1vZGVsRm9yRWxlbWVudChlbGVtZW50KSxcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICAgICAgICAgIHNvdXJjZTogc291cmNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2luc3RhbmNlLm9uKCdkcmFnZW5kJywgKGVsZW1lbnQ6IEVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ0VuZC5lbWl0KHtcbiAgICAgICAgICAgICAgICBtb2RlbDogdGhpcy5nZXRNb2RlbEZvckVsZW1lbnQoZWxlbWVudCksXG4gICAgICAgICAgICAgICAgZWxlbWVudDogZWxlbWVudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9pbnN0YW5jZS5vbignZHJvcCcsIChlbGVtZW50OiBFbGVtZW50LCB0YXJnZXQ6IEVsZW1lbnQsIHNvdXJjZTogRWxlbWVudCwgc2libGluZzogRWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kcm9wLmVtaXQoe1xuICAgICAgICAgICAgICAgIG1vZGVsOiB0aGlzLmdldE1vZGVsRm9yRWxlbWVudChlbGVtZW50KSxcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgICAgICAgIHNpYmxpbmc6IHNpYmxpbmdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5faW5zdGFuY2Uub24oJ2NhbmNlbCcsIChlbGVtZW50OiBFbGVtZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNhbmNlbC5lbWl0KHtcbiAgICAgICAgICAgICAgICBtb2RlbDogdGhpcy5nZXRNb2RlbEZvckVsZW1lbnQoZWxlbWVudCksXG4gICAgICAgICAgICAgICAgZWxlbWVudDogZWxlbWVudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9pbnN0YW5jZS5vbignY2xvbmVkJywgKGNsb25lOiBFbGVtZW50LCBlbGVtZW50OiBFbGVtZW50LCB0eXBlOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2xvbmVkLmVtaXQoe1xuICAgICAgICAgICAgICAgIGNsb25lOiBjbG9uZSxcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGUgZHJhZ3VsYSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBkZXN0cm95KCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5faW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBjb250YWluZXIgZm9yIHRoZSBjb250YWluZXJFbGVtZW50IGFuZCByZXR1cm5zIHRoZSByZXN1bHRzIG9mIGNhbk1vdmUuXG4gICAgICovXG4gICAgcHJpdmF0ZSBjYW5Nb3ZlKGVsZW1lbnQ6IEVsZW1lbnQsIGNvbnRhaW5lckVsZW1lbnQ6IEVsZW1lbnQsIGhhbmRsZTogRWxlbWVudCk6IGJvb2xlYW4ge1xuICAgICAgICBmb3IgKGxldCBjb250YWluZXIgb2YgdGhpcy5fY29udGFpbmVycykge1xuICAgICAgICAgICAgaWYgKGNvbnRhaW5lci5lbGVtZW50LmlzU2FtZU5vZGUoY29udGFpbmVyRWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGFpbmVyLmNhbk1vdmUoZWxlbWVudCwgY29udGFpbmVyRWxlbWVudCwgaGFuZGxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCB7IEFmdGVyVmlld0luaXQsIENvbnRlbnRDaGlsZHJlbiwgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIEhvc3RCaW5kaW5nLCBJbnB1dCwgT25EZXN0cm95LCBPbkluaXQsIE91dHB1dCwgUXVlcnlMaXN0LCBSZW5kZXJlcjIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IFJlb3JkZXJhYmxlSGFuZGxlRGlyZWN0aXZlIH0gZnJvbSAnLi9yZW9yZGVyYWJsZS1oYW5kbGUuZGlyZWN0aXZlJztcbmltcG9ydCB7IFJlb3JkZXJhYmxlTW9kZWxEaXJlY3RpdmUgfSBmcm9tICcuL3Jlb3JkZXJhYmxlLW1vZGVsLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBSZW9yZGVyYWJsZUNhbmNlbEV2ZW50LCBSZW9yZGVyYWJsZUNsb25lZEV2ZW50LCBSZW9yZGVyYWJsZUNvbnRhaW5lciwgUmVvcmRlcmFibGVEcmFnRW5kRXZlbnQsIFJlb3JkZXJhYmxlRHJhZ0V2ZW50LCBSZW9yZGVyYWJsZURyb3BFdmVudCwgUmVvcmRlcmFibGVTZXJ2aWNlIH0gZnJvbSAnLi9yZW9yZGVyYWJsZS5zZXJ2aWNlJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbdXhSZW9yZGVyYWJsZV0nXG59KVxuZXhwb3J0IGNsYXNzIFJlb3JkZXJhYmxlRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBBZnRlclZpZXdJbml0LCBPbkRlc3Ryb3kge1xuXG4gICAgQElucHV0KCkgcmVvcmRlcmFibGVNb2RlbDogQXJyYXk8YW55PjtcbiAgICBASW5wdXQoKSByZW9yZGVyYWJsZUdyb3VwOiBzdHJpbmc7XG4gICAgQElucHV0KCkgcmVvcmRlcmluZ0Rpc2FibGVkOiBib29sZWFuID0gZmFsc2U7XG4gICAgQE91dHB1dCgpIHJlb3JkZXJhYmxlTW9kZWxDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPEFycmF5PGFueT4+KCk7XG4gICAgQE91dHB1dCgpIHJlb3JkZXJTdGFydCA9IG5ldyBFdmVudEVtaXR0ZXI8UmVvcmRlckV2ZW50PigpO1xuICAgIEBPdXRwdXQoKSByZW9yZGVyQ2FuY2VsID0gbmV3IEV2ZW50RW1pdHRlcjxSZW9yZGVyRXZlbnQ+KCk7XG4gICAgQE91dHB1dCgpIHJlb3JkZXJFbmQgPSBuZXcgRXZlbnRFbWl0dGVyPFJlb3JkZXJFdmVudD4oKTtcblxuICAgIEBDb250ZW50Q2hpbGRyZW4oUmVvcmRlcmFibGVIYW5kbGVEaXJlY3RpdmUsIHsgcmVhZDogRWxlbWVudFJlZiwgZGVzY2VuZGFudHM6IHRydWUgfSkgaGFuZGxlczogUXVlcnlMaXN0PEVsZW1lbnRSZWY+O1xuICAgIEBDb250ZW50Q2hpbGRyZW4oUmVvcmRlcmFibGVNb2RlbERpcmVjdGl2ZSkgbW9kZWxzOiBRdWVyeUxpc3Q8UmVvcmRlcmFibGVNb2RlbERpcmVjdGl2ZT47XG5cbiAgICBwcml2YXRlIF9jb250YWluZXI6IFJlb3JkZXJhYmxlQ29udGFpbmVyO1xuXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy51eC1yZW9yZGVyYWJsZS1jb250YWluZXItbW92aW5nJykgZHJhZ2dpbmcgPSBmYWxzZTtcblxuICAgIHByaXZhdGUgX3N1YnNjcmlwdGlvbnMgPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZixcbiAgICAgICAgcHJpdmF0ZSBfcmVuZGVyZXI6IFJlbmRlcmVyMixcbiAgICAgICAgcHJpdmF0ZSBfc2VydmljZTogUmVvcmRlcmFibGVTZXJ2aWNlXG4gICAgKSB7IH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpc2UgZHJhZ3VsYSBhbmQgYmluZCB0byBhbGwgdGhlIHJlcXVpcmVkIGV2ZW50c1xuICAgICAqL1xuICAgIG5nT25Jbml0KCk6IHZvaWQge1xuXG4gICAgICAgIC8vIElmIG5vIGdyb3VwIG5hbWUgdGhlbiBnZW5lcmF0ZSBhIHVuaXF1ZSBvbmUgZm9yIHRoaXMgaW5zdGFuY2Ugb25seVxuICAgICAgICBpZiAoIXRoaXMucmVvcmRlcmFibGVHcm91cCkge1xuICAgICAgICAgICAgdGhpcy5yZW9yZGVyYWJsZUdyb3VwID0gdGhpcy5fc2VydmljZS5nZXRVbmlxdWVHcm91cE5hbWUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NvbnRhaW5lciA9IHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCxcbiAgICAgICAgICAgIGdldE1vZGVsRnJvbUVsZW1lbnQ6IHRoaXMuZ2V0TW9kZWxGcm9tRWxlbWVudC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgY2FuTW92ZTogdGhpcy5jYW5Nb3ZlLmJpbmQodGhpcylcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBSZWdpc3RlciBmb3IgZHJhZyBldmVudHMgb24gdGhpcyBlbGVtZW50XG4gICAgICAgIGNvbnN0IGdyb3VwID0gdGhpcy5fc2VydmljZS5yZWdpc3Rlcih0aGlzLnJlb3JkZXJhYmxlR3JvdXAsIHRoaXMuX2NvbnRhaW5lcik7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMuYWRkKGdyb3VwLmRyYWcuc3Vic2NyaWJlKHRoaXMub25EcmFnLmJpbmQodGhpcykpKTtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9ucy5hZGQoZ3JvdXAuZHJhZ0VuZC5zdWJzY3JpYmUodGhpcy5vbkRyYWdFbmQuYmluZCh0aGlzKSkpO1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zLmFkZChncm91cC5kcm9wLnN1YnNjcmliZSh0aGlzLm9uRHJvcC5iaW5kKHRoaXMpKSk7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMuYWRkKGdyb3VwLmNhbmNlbC5zdWJzY3JpYmUoKGV2ZW50OiBSZW9yZGVyYWJsZUNhbmNlbEV2ZW50KSA9PiB0aGlzLnJlb3JkZXJDYW5jZWwuZW1pdCh7IGVsZW1lbnQ6IGV2ZW50LmVsZW1lbnQsIG1vZGVsOiBldmVudC5tb2RlbCB9KSkpO1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zLmFkZChncm91cC5jbG9uZWQuc3Vic2NyaWJlKHRoaXMub25DbG9uZS5iaW5kKHRoaXMpKSk7XG4gICAgfVxuXG4gICAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9zZXJ2aWNlLmluaXRpYWxpemUodGhpcy5yZW9yZGVyYWJsZUdyb3VwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXZSBuZWVkIHRvIGRlc3Ryb3kgdGhlIGRyYWd1bGEgaW5zdGFuY2Ugb24gY29tcG9uZW50IGRlc3Ryb3lcbiAgICAgKi9cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fc2VydmljZS51bnJlZ2lzdGVyKHRoaXMucmVvcmRlcmFibGVHcm91cCwgdGhpcy5fY29udGFpbmVyKTtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9ucy51bnN1YnNjcmliZSgpO1xuICAgIH1cblxuICAgIG9uRHJhZyhldmVudDogUmVvcmRlcmFibGVEcmFnRXZlbnQpOiB2b2lkIHtcblxuICAgICAgICB0aGlzLmRyYWdnaW5nID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLnJlb3JkZXJTdGFydC5lbWl0KHsgZWxlbWVudDogZXZlbnQuZWxlbWVudCwgbW9kZWw6IGV2ZW50Lm1vZGVsIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgZmlyZWQgd2hlbiBpdGVtcyBnZXQgcmVvcmRlcmVkIC0gd2UgbmVlZCB0byBlbWl0IHRoZSBuZXcgb3JkZXIgb2YgdGhlIG1vZGVsc1xuICAgICAqL1xuICAgIG9uRHJvcChldmVudDogUmVvcmRlcmFibGVEcm9wRXZlbnQpOiB2b2lkIHtcblxuICAgICAgICAvLyBpZiB0aGVyZSBpcyBubyBwcm92aWRlZCBtb2R1bGUgd2UgY2FuIHNraXAgdGhpc1xuICAgICAgICBpZiAoIXRoaXMucmVvcmRlcmFibGVNb2RlbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoZXZlbnQuc291cmNlLmlzU2FtZU5vZGUodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50KSkge1xuXG4gICAgICAgICAgICAvLyByZW1vdmUgdGhpcyBtb2RlbCBmcm9tIHRoZSBsaXN0IG9mIG1vZGVsc1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLnJlb3JkZXJhYmxlTW9kZWwuaW5kZXhPZihldmVudC5tb2RlbCk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVvcmRlcmFibGVNb2RlbC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50LnRhcmdldC5pc1NhbWVOb2RlKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCkpIHtcblxuICAgICAgICAgICAgLy8gZ2V0IHRoZSBwb3NpdGlvbiBvZiBzaWJsaW5nIGVsZW1lbnRcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gZXZlbnQuc2libGluZyAmJiAhZXZlbnQuc2libGluZy5jbGFzc0xpc3QuY29udGFpbnMoJ2d1LW1pcnJvcicpID9cbiAgICAgICAgICAgICAgICB0aGlzLnJlb3JkZXJhYmxlTW9kZWwuaW5kZXhPZih0aGlzLmdldE1vZGVsRnJvbUVsZW1lbnQoZXZlbnQuc2libGluZykpIDpcbiAgICAgICAgICAgICAgICB0aGlzLnJlb3JkZXJhYmxlTW9kZWwubGVuZ3RoO1xuXG4gICAgICAgICAgICAvLyBpbnNlcnQgdGhlIG1vZGVsIGF0IGl0cyBuZXcgbG9jYXRpb25cbiAgICAgICAgICAgIHRoaXMucmVvcmRlcmFibGVNb2RlbC5zcGxpY2UoaW5kZXgsIDAsIGV2ZW50Lm1vZGVsKTtcbiAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRW1pdCBldmVudCBpZiBhbnkgY2hhbmdlcyB3ZXJlIG1hZGVcbiAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVvcmRlcmFibGVNb2RlbENoYW5nZS5lbWl0KHRoaXMucmVvcmRlcmFibGVNb2RlbCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIG1vZGVsIGFzc2NpYXRlZCB3aXRoIGEgcGFydGljdWxhciBlbGVtZW50IGluIHRoZSBsaXN0LlxuICAgICAqIFRoaXMgc2hvdWxkIGVuc3VyZSB0aGF0IHRoZSBpdGVtcyBoYXZlIHRoZSBkcmFnZ2FibGUgbW9kZWwgZGlyZWN0aXZlIGFwcGxpZWRcbiAgICAgKi9cbiAgICBnZXRNb2RlbEZyb21FbGVtZW50KGVsZW1lbnQ6IEVsZW1lbnQpOiBhbnkge1xuXG4gICAgICAgIGNvbnN0IG1vZGVsID0gdGhpcy5tb2RlbHMuZmluZChfbW9kZWwgPT4gX21vZGVsLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCA9PT0gZWxlbWVudCk7XG5cbiAgICAgICAgaWYgKCFtb2RlbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbW9kZWwudXhSZW9yZGVyYWJsZU1vZGVsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZW4gd2UgZmluaXNoIGRyYWdnaW5nIHJlbW92ZSB0aGUgdXRpbGxpdHkgY2xhc3MgZnJvbSB0aGUgZWxlbWVudCBiZWluZyBtb3ZlZFxuICAgICAqL1xuICAgIG9uRHJhZ0VuZChldmVudDogUmVvcmRlcmFibGVEcmFnRW5kRXZlbnQpOiB2b2lkIHtcblxuICAgICAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5jb250YWlucyhldmVudC5lbGVtZW50KSkge1xuXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5yZW1vdmVDbGFzcyhldmVudC5lbGVtZW50LCAndXgtcmVvcmRlcmFibGUtbW92aW5nJyk7XG5cbiAgICAgICAgICAgIHRoaXMucmVvcmRlckVuZC5lbWl0KHtcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBldmVudC5lbGVtZW50LFxuICAgICAgICAgICAgICAgIG1vZGVsOiBldmVudC5tb2RlbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXZSB3YW50IHRvIGVuc3VyZSB0aGF0IHRoZSBjbG9uZWQgZWxlbWVudCBpcyBpZGVudGljYWxcbiAgICAgKiB0byB0aGUgb3JpZ2luYWwsIHJlZ2FyZGxlc3Mgb2YgaXQncyBsb2NhdGlvbiBpbiB0aGUgRE9NIHRyZWVcbiAgICAgKi9cbiAgICBvbkNsb25lKGV2ZW50OiBSZW9yZGVyYWJsZUNsb25lZEV2ZW50KTogdm9pZCB7XG5cbiAgICAgICAgaWYgKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5jb250YWlucyhldmVudC5lbGVtZW50KSkge1xuXG4gICAgICAgICAgICB0aGlzLnNldFRhYmxlQ2VsbFdpZHRocyhldmVudC5lbGVtZW50LCBldmVudC5jbG9uZSk7XG4gICAgICAgICAgICB0aGlzLmNhcHR1cmVDYW52YXNlcyhldmVudC5lbGVtZW50LCBldmVudC5jbG9uZSk7XG5cbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmFkZENsYXNzKGV2ZW50LmVsZW1lbnQsICd1eC1yZW9yZGVyYWJsZS1tb3ZpbmcnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIGVsZW1lbnRzIGNvbnRhaW4gaGFuZGxlcyB0aGVuIG9ubHkgZHJhZyB3aGVuIHRoZSBoYW5kbGUgaXMgZHJhZ2dlZFxuICAgICAqIG90aGVyd2lzZSBkcmFnIHdoZW5ldmVyIGFuIGltbWVkaWF0ZSBjaGlsZCBpcyBzcGVjaWZpZWRcbiAgICAgKi9cbiAgICBjYW5Nb3ZlKGVsZW1lbnQ6IEVsZW1lbnQsIGNvbnRhaW5lcjogRWxlbWVudCwgaGFuZGxlOiBFbGVtZW50KTogYm9vbGVhbiB7XG4gICAgICAgIGlmICh0aGlzLnJlb3JkZXJpbmdEaXNhYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZXMubGVuZ3RoID09PSAwID8gdHJ1ZSA6ICEhdGhpcy5oYW5kbGVzLmZpbmQoX2hhbmRsZSA9PiBfaGFuZGxlLm5hdGl2ZUVsZW1lbnQgPT09IGhhbmRsZSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzZXRUYWJsZUNlbGxXaWR0aHMoc291cmNlOiBFbGVtZW50LCB0YXJnZXQ6IEVsZW1lbnQpOiB2b2lkIHtcblxuICAgICAgICAvLyBpZiBpdCBpcyBub3QgYSB0YWJsZSByb3cgdGhlbiBza2lwIHRoaXNcbiAgICAgICAgaWYgKHNvdXJjZS50YWdOYW1lICE9PSAnVFInKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaW5kIGFueSBpbW1lZGlhdGUgdGQgY2hpbGRyZW4gYW5kIGZpeCB0aGVpciB3aWR0aFxuICAgICAgICBjb25zdCBzb3VyY2VDZWxscyA9IEFycmF5LmZyb20oc291cmNlLmNoaWxkcmVuKSBhcyBIVE1MVGFibGVDZWxsRWxlbWVudFtdO1xuICAgICAgICBjb25zdCB0YXJnZXRDZWxscyA9IEFycmF5LmZyb20odGFyZ2V0LmNoaWxkcmVuKSBhcyBIVE1MVGFibGVDZWxsRWxlbWVudFtdO1xuXG4gICAgICAgIC8vIGZpeCB0aGUgd2lkdGggb2YgdGhlc2UgY2VsbHNcbiAgICAgICAgc291cmNlQ2VsbHMuZm9yRWFjaCgoY2VsbCwgaWR4KSA9PiB0YXJnZXRDZWxsc1tpZHhdLnN0eWxlLm1pbldpZHRoID0gZ2V0Q29tcHV0ZWRTdHlsZShjZWxsKS5nZXRQcm9wZXJ0eVZhbHVlKCd3aWR0aCcpKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGNhcHR1cmVDYW52YXNlcyhzb3VyY2U6IEVsZW1lbnQsIHRhcmdldDogRWxlbWVudCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGZpbmQgYWxsIGNoaWxkIGNhbnZhcyBlbGVtZW50c1xuICAgICAgICBjb25zdCBzb3VyY2VDYW52YXNlcyA9IEFycmF5LmZyb20oc291cmNlLnF1ZXJ5U2VsZWN0b3JBbGwoJ2NhbnZhcycpKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0Q2FudmFzZXMgPSBBcnJheS5mcm9tKHRhcmdldC5xdWVyeVNlbGVjdG9yQWxsKCdjYW52YXMnKSk7XG5cbiAgICAgICAgLy8gcmVwbGljYXRlIHRoZSBjYW52YXMgY29udGVudFxuICAgICAgICB0YXJnZXRDYW52YXNlcy5tYXAoY2FudmFzID0+IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpKVxuICAgICAgICAgICAgLmZvckVhY2goKGNvbnRleHQsIGlkeCkgPT4gY29udGV4dC5kcmF3SW1hZ2Uoc291cmNlQ2FudmFzZXNbaWR4XSwgMCwgMCkpO1xuXG4gICAgfVxuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVvcmRlckV2ZW50IHtcbiAgICBlbGVtZW50OiBFbGVtZW50O1xuICAgIG1vZGVsOiBhbnk7XG59XG4iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IFJlb3JkZXJhYmxlRGlyZWN0aXZlIH0gZnJvbSAnLi9yZW9yZGVyYWJsZS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgUmVvcmRlcmFibGVIYW5kbGVEaXJlY3RpdmUgfSBmcm9tICcuL3Jlb3JkZXJhYmxlLWhhbmRsZS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgUmVvcmRlcmFibGVNb2RlbERpcmVjdGl2ZSB9IGZyb20gJy4vcmVvcmRlcmFibGUtbW9kZWwuZGlyZWN0aXZlJztcbmltcG9ydCB7IFJlb3JkZXJhYmxlU2VydmljZSB9IGZyb20gJy4vcmVvcmRlcmFibGUuc2VydmljZSc7XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGVcbiAgICBdLFxuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBSZW9yZGVyYWJsZURpcmVjdGl2ZSxcbiAgICAgICAgUmVvcmRlcmFibGVIYW5kbGVEaXJlY3RpdmUsXG4gICAgICAgIFJlb3JkZXJhYmxlTW9kZWxEaXJlY3RpdmVcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgUmVvcmRlcmFibGVEaXJlY3RpdmUsXG4gICAgICAgIFJlb3JkZXJhYmxlSGFuZGxlRGlyZWN0aXZlLFxuICAgICAgICBSZW9yZGVyYWJsZU1vZGVsRGlyZWN0aXZlXG4gICAgXSxcbiAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgUmVvcmRlcmFibGVTZXJ2aWNlXG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBSZW9yZGVyYWJsZU1vZHVsZSB7IH1cbiIsImltcG9ydCB7IEZhY2V0IH0gZnJvbSAnLi9tb2RlbHMvZmFjZXQnO1xuXG5leHBvcnQgY2xhc3MgRmFjZXRTZWxlY3Qge1xuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBmYWNldDogRmFjZXQpIHt9XG59XG5cbmV4cG9ydCBjbGFzcyBGYWNldERlc2VsZWN0IHtcbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZmFjZXQ6IEZhY2V0KSB7fVxufVxuXG5leHBvcnQgY2xhc3MgRmFjZXREZXNlbGVjdEFsbCB7XG4gICAgY29uc3RydWN0b3IoKSB7fVxufVxuXG5leHBvcnQgdHlwZSBGYWNldEV2ZW50ID0gRmFjZXRTZWxlY3QgfCBGYWNldERlc2VsZWN0IHwgRmFjZXREZXNlbGVjdEFsbDsiLCJpbXBvcnQgeyBMaXZlQW5ub3VuY2VyIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2ExMXknO1xuaW1wb3J0IHsgQ29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIElucHV0LCBPbkRlc3Ryb3ksIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUmVvcmRlckV2ZW50IH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9yZW9yZGVyYWJsZS9pbmRleCc7XG5pbXBvcnQgeyBGYWNldERlc2VsZWN0LCBGYWNldERlc2VsZWN0QWxsLCBGYWNldEV2ZW50LCBGYWNldFNlbGVjdCB9IGZyb20gJy4vZmFjZXQtZXZlbnRzJztcbmltcG9ydCB7IEZhY2V0IH0gZnJvbSAnLi9tb2RlbHMvZmFjZXQnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LWZhY2V0LWNvbnRhaW5lcicsXG4gICAgdGVtcGxhdGVVcmw6ICcuL2ZhY2V0LWNvbnRhaW5lci5jb21wb25lbnQuaHRtbCdcbn0pXG5leHBvcnQgY2xhc3MgRmFjZXRDb250YWluZXJDb21wb25lbnQgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuXG4gICAgQElucHV0KCkgaGVhZGVyOiBzdHJpbmcgPSAnU2VsZWN0ZWQ6JztcbiAgICBASW5wdXQoKSBjbGVhclRvb2x0aXA6IHN0cmluZyA9ICdDbGVhciBBbGwnO1xuICAgIEBJbnB1dCgpIGVtcHR5VGV4dDogc3RyaW5nID0gJ05vIEl0ZW1zJztcbiAgICBASW5wdXQoKSBmYWNldHM6IEZhY2V0W10gPSBbXTtcbiAgICBASW5wdXQoKSBmYWNldHNSZW9yZGVyYWJsZTogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgQE91dHB1dCgpIGZhY2V0c0NoYW5nZTogRXZlbnRFbWl0dGVyPEZhY2V0W10+ID0gbmV3IEV2ZW50RW1pdHRlcjxGYWNldFtdPigpO1xuICAgIEBPdXRwdXQoKSBldmVudHM6IEV2ZW50RW1pdHRlcjxGYWNldEV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8RmFjZXRFdmVudD4oKTtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX2Fubm91bmNlcjogTGl2ZUFubm91bmNlcikgeyB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5ldmVudHMuY29tcGxldGUoKTtcbiAgICB9XG5cbiAgICBzZWxlY3RGYWNldChmYWNldDogRmFjZXQpOiB2b2lkIHtcbiAgICAgICAgLy8gcHVzaCB0aGUgZmFjZXQgb24gdG8gdGhlIGxpc3RcbiAgICAgICAgdGhpcy5mYWNldHMucHVzaChmYWNldCk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSB0d28gd2F5IGJpbmRpbmdcbiAgICAgICAgdGhpcy5mYWNldHNDaGFuZ2UuZW1pdCh0aGlzLmZhY2V0cyk7XG5cbiAgICAgICAgLy8gdHJpZ2dlciBldmVudFxuICAgICAgICB0aGlzLnRyaWdnZXJFdmVudChuZXcgRmFjZXRTZWxlY3QoZmFjZXQpKTtcbiAgICB9XG5cbiAgICBkZXNlbGVjdEZhY2V0KGZhY2V0OiBGYWNldCwgdGFnPzogSFRNTEVsZW1lbnQpOiB2b2lkIHtcblxuICAgICAgICAvLyBmaW5kIHRoZSBpbmRleCBvZiB0aGUgaXRlbSBpbiB0aGUgc2VsZWN0ZWQgYXJyYXlcbiAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5mYWNldHMuZmluZEluZGV4KHNlbGVjdGVkRmFjZXQgPT4gZmFjZXQgPT09IHNlbGVjdGVkRmFjZXQpO1xuXG4gICAgICAgIC8vIGlmIG1hdGNoIHRoZXJlIHdhcyBubyBtYXRjaCB0aGVuIGZpbmlzaFxuICAgICAgICBpZiAoaWR4ID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVtb3ZlIHRoZSBsYXN0IGl0ZW1cbiAgICAgICAgdGhpcy5mYWNldHMuc3BsaWNlKGlkeCwgMSk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSB0d28gd2F5IGJpbmRpbmdcbiAgICAgICAgdGhpcy5mYWNldHNDaGFuZ2UuZW1pdCh0aGlzLmZhY2V0cyk7XG5cbiAgICAgICAgLy8gdHJpZ2dlciBldmVudFxuICAgICAgICB0aGlzLnRyaWdnZXJFdmVudChuZXcgRmFjZXREZXNlbGVjdChmYWNldCkpO1xuXG4gICAgICAgIC8vIGFubm91bmNlIHRoZSBmYWNldCByZW1vdmFsXG4gICAgICAgIHRoaXMuX2Fubm91bmNlci5hbm5vdW5jZShgT3B0aW9uICR7ZmFjZXQudGl0bGV9IGRlc2VsZWN0ZWQuYCwgJ2Fzc2VydGl2ZScpO1xuXG4gICAgICAgIC8vIGZvY3VzIGFub3RoZXIgdGFnIGlmIHRoZXJlIGlzIG9uZVxuICAgICAgICBpZiAodGFnKSB7XG4gICAgICAgICAgICBjb25zdCBzaWJsaW5nID0gdGFnLnByZXZpb3VzRWxlbWVudFNpYmxpbmcgfHwgdGFnLm5leHRFbGVtZW50U2libGluZztcblxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYSBzaWJsaW5nIHRoZW4gZm9jdXMgaXRcbiAgICAgICAgICAgIGlmIChzaWJsaW5nKSB7XG4gICAgICAgICAgICAgICAgKHNpYmxpbmcgYXMgSFRNTEVsZW1lbnQpLmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZXNlbGVjdEFsbEZhY2V0cygpOiB2b2lkIHtcblxuICAgICAgICAvLyBlbXB0eSB0aGUgc2VsZWN0ZWQgYXJyYXlcbiAgICAgICAgdGhpcy5mYWNldHMgPSBbXTtcblxuICAgICAgICAvLyB1cGRhdGUgdGhlIHR3byB3YXkgYmluZGluZ1xuICAgICAgICB0aGlzLmZhY2V0c0NoYW5nZS5lbWl0KHRoaXMuZmFjZXRzKTtcblxuICAgICAgICAvLyB0cmlnZ2VyIGV2ZW50XG4gICAgICAgIHRoaXMudHJpZ2dlckV2ZW50KG5ldyBGYWNldERlc2VsZWN0QWxsKCkpO1xuXG4gICAgICAgIC8vIGFubm91bmNlIHRoZSBmYWNldCByZW1vdmFsXG4gICAgICAgIHRoaXMuX2Fubm91bmNlci5hbm5vdW5jZShgQWxsIG9wdGlvbnMgZGVzZWxlY3RlZC5gLCAnYXNzZXJ0aXZlJyk7XG4gICAgfVxuXG4gICAgdHJhY2tCeShfaW5kZXg6IG51bWJlciwgZmFjZXQ6IEZhY2V0KTogc3RyaW5nIHwgbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIGZhY2V0LmlkIHx8IGZhY2V0LnRpdGxlO1xuICAgIH1cblxuICAgIHNoaWZ0UmlnaHQoZmFjZXQ6IEZhY2V0LCBlbGVtZW50OiBIVE1MRWxlbWVudCk6IHZvaWQge1xuICAgICAgICAvLyBvbmx5IG1vdmUgdGhlIGl0ZW0gaWYgcmVvcmRlcmluZyBpcyBhbGxvd2VkXG4gICAgICAgIGlmICh0aGlzLmZhY2V0c1Jlb3JkZXJhYmxlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcGVyZm9ybSB0aGUgbW92ZW1lbnRcbiAgICAgICAgdGhpcy5zaGlmdEZhY2V0KGZhY2V0LCAxKTtcblxuICAgICAgICAvLyB0aGUgaXRlbSBtYXkgYmVjb21lIHVuZm9jdXNlZCBkdXJpbmcgdGhlIHJlb3JkZXIgc28gd2Ugc2hvdWxkIHJlZm9jdXMgaXRcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IGVsZW1lbnQuZm9jdXMoKSk7XG5cbiAgICAgICAgLy8gYW5ub3VuY2UgdGhlIG1vdmVcbiAgICAgICAgdGhpcy5fYW5ub3VuY2VyLmFubm91bmNlKGBPcHRpb24gJHtmYWNldC50aXRsZX0gbW92ZWQgZG93bi5gKTtcbiAgICB9XG5cbiAgICBzaGlmdExlZnQoZmFjZXQ6IEZhY2V0LCBlbGVtZW50OiBIVE1MRWxlbWVudCk6IHZvaWQge1xuICAgICAgICAvLyBvbmx5IG1vdmUgdGhlIGl0ZW0gaWYgcmVvcmRlcmluZyBpcyBhbGxvd2VkXG4gICAgICAgIGlmICh0aGlzLmZhY2V0c1Jlb3JkZXJhYmxlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcGVyZm9ybSB0aGUgbW92ZW1lbnRcbiAgICAgICAgdGhpcy5zaGlmdEZhY2V0KGZhY2V0LCAtMSk7XG5cbiAgICAgICAgLy8gdGhlIGl0ZW0gbWF5IGJlY29tZSB1bmZvY3VzZWQgZHVyaW5nIHRoZSByZW9yZGVyIHNvIHdlIHNob3VsZCByZWZvY3VzIGl0XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiBlbGVtZW50LmZvY3VzKCkpO1xuXG4gICAgICAgIC8vIGFubm91bmNlIHRoZSBtb3ZlXG4gICAgICAgIHRoaXMuX2Fubm91bmNlci5hbm5vdW5jZShgT3B0aW9uICR7ZmFjZXQudGl0bGV9IG1vdmVkIHVwLmApO1xuICAgIH1cblxuICAgIHByaXZhdGUgc2hpZnRGYWNldChmYWNldDogRmFjZXQsIGRpc3RhbmNlOiBudW1iZXIpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmZhY2V0cy5pbmRleE9mKGZhY2V0KTtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gaW5kZXggKyBkaXN0YW5jZTtcblxuICAgICAgICAvLyBFbnN1cmUgdGhlIG1vdmUgaXMgdmFsaWRcbiAgICAgICAgaWYgKHRhcmdldCA8IDAgfHwgdGFyZ2V0ID09PSB0aGlzLmZhY2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFBlcmZvcm0gdGhlIG1vdmVcbiAgICAgICAgdGhpcy5mYWNldHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgdGhpcy5mYWNldHMuc3BsaWNlKHRhcmdldCwgMCwgZmFjZXQpO1xuICAgIH1cblxuICAgIHByaXZhdGUgdHJpZ2dlckV2ZW50KGV2ZW50OiBGYWNldEV2ZW50KSB7XG4gICAgICAgIHRoaXMuZXZlbnRzLm5leHQoZXZlbnQpO1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBGYWNldFJlb3JkZXJFdmVudCBleHRlbmRzIFJlb3JkZXJFdmVudCB7XG4gICAgaW5kZXg6IG51bWJlcjtcbn0iLCJpbXBvcnQgeyBDb21wb25lbnQsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSG9zdCwgSW5wdXQsIE9uRGVzdHJveSwgT25Jbml0LCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGZpbHRlciwgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XG5pbXBvcnQgeyBGYWNldENvbnRhaW5lckNvbXBvbmVudCB9IGZyb20gJy4uLy4uL2ZhY2V0LWNvbnRhaW5lci5jb21wb25lbnQnO1xuaW1wb3J0IHsgRmFjZXREZXNlbGVjdCwgRmFjZXREZXNlbGVjdEFsbCwgRmFjZXRFdmVudCwgRmFjZXRTZWxlY3QgfSBmcm9tICcuLi8uLi9mYWNldC1ldmVudHMnO1xuaW1wb3J0IHsgRmFjZXQgfSBmcm9tICcuLi8uLi9tb2RlbHMvZmFjZXQnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LWZhY2V0LWJhc2UnLFxuICAgIHRlbXBsYXRlOiAnJyxcbn0pXG5leHBvcnQgY2xhc3MgRmFjZXRCYXNlQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuXG4gICAgQElucHV0KCkgc2VsZWN0ZWQ6IEZhY2V0W10gPSBbXTtcbiAgICBAT3V0cHV0KCkgc2VsZWN0ZWRDaGFuZ2U6IEV2ZW50RW1pdHRlcjxGYWNldFtdPiA9IG5ldyBFdmVudEVtaXR0ZXI8RmFjZXRbXT4oKTtcbiAgICBAT3V0cHV0KCkgZXZlbnRzOiBTdWJqZWN0PEZhY2V0RXZlbnQ+ID0gbmV3IFN1YmplY3Q8RmFjZXRFdmVudD4oKTtcblxuICAgIHByb3RlY3RlZCBfb25EZXN0cm95ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICAgIGNvbnN0cnVjdG9yKCBASG9zdCgpIHByaXZhdGUgZmFjZXRDb250YWluZXI6IEZhY2V0Q29udGFpbmVyQ29tcG9uZW50LCBwdWJsaWMgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYpIHtcblxuICAgICAgICBpZiAoZmFjZXRDb250YWluZXIpIHtcblxuICAgICAgICAgICAgLy8gc3Vic2NyaWJlIHRvIGFueSBkZXNlbGVjdCBldmVudHMgZnJvbSB0aGUgZmFjZXQgY29udGFpbmVyXG4gICAgICAgICAgICBmYWNldENvbnRhaW5lci5ldmVudHMucGlwZShcbiAgICAgICAgICAgICAgICBmaWx0ZXIoZXZlbnQgPT4gZXZlbnQgaW5zdGFuY2VvZiBGYWNldERlc2VsZWN0KSxcbiAgICAgICAgICAgICAgICBmaWx0ZXIoKGV2ZW50OiBGYWNldERlc2VsZWN0KSA9PiAhIXRoaXMuc2VsZWN0ZWQuZmluZChmYWNldCA9PiBmYWNldCA9PT0gZXZlbnQuZmFjZXQpKSxcbiAgICAgICAgICAgICAgICB0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KVxuICAgICAgICAgICAgKS5zdWJzY3JpYmUoKGV2ZW50OiBGYWNldERlc2VsZWN0KSA9PiB0aGlzLmRlc2VsZWN0RmFjZXQoZXZlbnQuZmFjZXQpKTtcblxuICAgICAgICAgICAgLy8gc3Vic2NyaWJlIHRvIGFueSBkZXNlbGVjdCBhbGwgZXZlbnRzIGZyb20gZmFjZXQgY29udGFpbmVyXG4gICAgICAgICAgICBmYWNldENvbnRhaW5lci5ldmVudHMucGlwZShcbiAgICAgICAgICAgICAgICBmaWx0ZXIoZXZlbnQgPT4gZXZlbnQgaW5zdGFuY2VvZiBGYWNldERlc2VsZWN0QWxsKSxcbiAgICAgICAgICAgICAgICB0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KVxuICAgICAgICAgICAgKS5zdWJzY3JpYmUoXyA9PiB0aGlzLmRlc2VsZWN0QWxsKCkpO1xuXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgc2hvdWxkIGJlIGFueSBmYWNldHMgaW5pdGlhbGx5IHNlbGVjdGVkXG4gICAgICAgIGlmICh0aGlzLmZhY2V0Q29udGFpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkLmZvckVhY2goZmFjZXQgPT4gdGhpcy5mYWNldENvbnRhaW5lci5zZWxlY3RGYWNldChmYWNldCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX29uRGVzdHJveS5uZXh0KCk7XG4gICAgICAgIHRoaXMuX29uRGVzdHJveS5jb21wbGV0ZSgpO1xuICAgIH1cblxuICAgIHNlbGVjdEZhY2V0KGZhY2V0OiBGYWNldCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGlmIHRoZSBmYWNldCBpcyBkaXNhYmxlZCBpdCBzaG91bGQgbm90IGJlIHNlbGVjdGVkXG4gICAgICAgIGlmIChmYWNldC5kaXNhYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIHRoZSBmYWNldCB0byB0aGUgbGlzdCBvZiBzZWxlY3RlZCBmYWNldHNcbiAgICAgICAgdGhpcy5zZWxlY3RlZC5wdXNoKGZhY2V0KTtcblxuICAgICAgICAvLyBzZW5kIHRoZSBuZXcgdmFsdWUgdG8gdGhlIGV2ZW50IGVtaXR0ZXJcbiAgICAgICAgdGhpcy5zZWxlY3RlZENoYW5nZS5lbWl0KHRoaXMuc2VsZWN0ZWQpO1xuXG4gICAgICAgIC8vIGZpcmUgdGhlIGV2ZW50IHRvIHRoZSBvYnNlcnZhYmxlXG4gICAgICAgIHRoaXMudHJpZ2dlckV2ZW50KG5ldyBGYWNldFNlbGVjdChmYWNldCkpO1xuXG4gICAgICAgIC8vIHRlbGwgdGhlIGZhY2V0IGNvbnRhaW5lciBhYm91dCB0aGUgc2VsZWN0ZWQgZmFjZXRcbiAgICAgICAgaWYgKHRoaXMuZmFjZXRDb250YWluZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZmFjZXRDb250YWluZXIuc2VsZWN0RmFjZXQoZmFjZXQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGVzZWxlY3RGYWNldChmYWNldDogRmFjZXQpOiB2b2lkIHtcblxuICAgICAgICAvLyBmaW5kIGZhY2V0IHRvIHJlbW92ZVxuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuc2VsZWN0ZWQuZmluZEluZGV4KHNlbGVjdGVkRmFjZXQgPT4gc2VsZWN0ZWRGYWNldCA9PT0gZmFjZXQpO1xuXG4gICAgICAgIC8vIG9ubHkgY29udGludWUgaWYgZmFjZXQgaXMgZm91bmRcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuXG4gICAgICAgICAgICAvLyByZW1vdmUgdGhlIGZhY2V0IGZyb20gdGhlIHNlbGVjdGVkIGxpc3RcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgICAgICAgICAgLy8gZW1pdCB0aGUgY2hhbmdlcyB0byBzZWxlY3RlZCBldmVudCBlbWl0dGVyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkQ2hhbmdlLmVtaXQodGhpcy5zZWxlY3RlZCk7XG5cbiAgICAgICAgICAgIC8vIGZpcmUgdGhlIGV2ZW50IHRvIHRoZSBvYnNlcnZhYmxlXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXJFdmVudChuZXcgRmFjZXREZXNlbGVjdChmYWNldCkpO1xuXG4gICAgICAgICAgICAvLyBkZXNlbGVjdCB0aGUgZmFjZXQgaW4gdGhlIGZhY2V0IGNvbnRhaW5lclxuICAgICAgICAgICAgaWYgKHRoaXMuZmFjZXRDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZhY2V0Q29udGFpbmVyLmRlc2VsZWN0RmFjZXQoZmFjZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGVzZWxlY3RBbGwoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gcmVtb3ZlIGFsbCBzZWxlY3RlZCBmYWNldHNcbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9IFtdO1xuXG4gICAgICAgIC8vIGZpcmUgdGhlIGV2ZW50IHRvIHRoZSBvYnNlcnZhYmxlXG4gICAgICAgIHRoaXMudHJpZ2dlckV2ZW50KG5ldyBGYWNldERlc2VsZWN0QWxsKCkpO1xuXG4gICAgICAgIC8vIGVtaXQgdGhlIGNoYW5nZXMgdG8gdGhlIHNlbGVjdGVkIGV2ZW50IGVtaXR0ZXJcbiAgICAgICAgdGhpcy5zZWxlY3RlZENoYW5nZS5lbWl0KHRoaXMuc2VsZWN0ZWQpO1xuICAgIH1cblxuICAgIHRvZ2dsZUZhY2V0U2VsZWN0aW9uKGZhY2V0OiBGYWNldCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGlmIHRoZSBmYWNldCBpcyBzZWxlY3RlZCB0aGVuIGRlc2VsZWN0IC0gb3RoZXJ3aXNlIHNlbGVjdCBpdFxuICAgICAgICBpZiAodGhpcy5pc0ZhY2V0U2VsZWN0ZWQoZmFjZXQpKSB7XG4gICAgICAgICAgICB0aGlzLmRlc2VsZWN0RmFjZXQoZmFjZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RGYWNldChmYWNldCk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIGlzRmFjZXRTZWxlY3RlZChmYWNldDogRmFjZXQpOiBib29sZWFuIHtcbiAgICAgICAgLy8gZGV0ZXJtaW5lIGlmIGEgZmFjZXQgaXMgY3VycmVudGx5IHNlbGVjdGVkXG4gICAgICAgIHJldHVybiAhIXRoaXMuc2VsZWN0ZWQuZmluZChzZWxlY3RlZEZhY2V0ID0+IHNlbGVjdGVkRmFjZXQgPT09IGZhY2V0KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHRyaWdnZXJFdmVudChldmVudDogRmFjZXRFdmVudCk6IHZvaWQge1xuICAgICAgICB0aGlzLmV2ZW50cy5uZXh0KGV2ZW50KTtcbiAgICB9XG59IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIElucHV0LCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1mYWNldC1oZWFkZXInLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9mYWNldC1oZWFkZXIuY29tcG9uZW50Lmh0bWwnLFxuICAgIGhvc3Q6IHtcbiAgICAgICAgJ3JvbGUnOiAnYnV0dG9uJyxcbiAgICAgICAgJ3RhYmluZGV4JzogJzAnLFxuICAgICAgICAnKGNsaWNrKSc6ICd0b2dnbGVFeHBhbmQoKScsXG4gICAgICAgICcoa2V5dXAuZW50ZXIpJzogJ3RvZ2dsZUV4cGFuZCgpJyxcbiAgICAgICAgJ1thdHRyLmFyaWEtZXhwYW5kZWRdJzogJ2V4cGFuZGVkJyxcbiAgICAgICAgJ1thdHRyLmFyaWEtbGFiZWxdJzogJ2hlYWRlciArIFxcJyBGYWNldDogQWN0aXZhdGUgdG8gXFwnICsgKGV4cGFuZGVkID8gXFwnY29sbGFwc2VcXCcgOiBcXCdleHBhbmRcXCcpJ1xuICAgIH1cbn0pXG5leHBvcnQgY2xhc3MgRmFjZXRIZWFkZXJDb21wb25lbnQge1xuXG4gICAgQElucHV0KCkgaGVhZGVyOiBzdHJpbmc7XG4gICAgQElucHV0KCkgY2FuRXhwYW5kOiBib29sZWFuID0gdHJ1ZTtcbiAgICBASW5wdXQoKSBleHBhbmRlZDogYm9vbGVhbiA9IHRydWU7XG4gICAgQE91dHB1dCgpIGV4cGFuZGVkQ2hhbmdlOiBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4gPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XG5cbiAgICB0b2dnbGVFeHBhbmQoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gaWYgbm90IGV4cGFuZGFibGUgdGhlbiBkbyBub3RoaW5nXG4gICAgICAgIGlmICh0aGlzLmNhbkV4cGFuZCkge1xuICAgICAgICAgICAgdGhpcy5leHBhbmRlZCA9ICF0aGlzLmV4cGFuZGVkO1xuICAgICAgICAgICAgdGhpcy5leHBhbmRlZENoYW5nZS5lbWl0KHRoaXMuZXhwYW5kZWQpO1xuICAgICAgICB9XG4gICAgfVxufSIsImltcG9ydCB7IEZvY3VzYWJsZU9wdGlvbiB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9hMTF5JztcbmltcG9ydCB7IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDb21wb25lbnQsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE91dHB1dCwgVmlld0NoaWxkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGYWNldCB9IGZyb20gJy4uLy4uL21vZGVscy9mYWNldCc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtZmFjZXQtY2hlY2stbGlzdC1pdGVtJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vZmFjZXQtY2hlY2stbGlzdC1pdGVtLmNvbXBvbmVudC5odG1sJyxcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxufSlcbmV4cG9ydCBjbGFzcyBGYWNldENoZWNrTGlzdEl0ZW1Db21wb25lbnQgaW1wbGVtZW50cyBGb2N1c2FibGVPcHRpb24ge1xuXG4gICAgQElucHV0KCkgZmFjZXQ6IEZhY2V0ID0gbnVsbDtcbiAgICBASW5wdXQoKSBzZWxlY3RlZDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIEBJbnB1dCgpIHRhYmJhYmxlOiBib29sZWFuID0gZmFsc2U7XG4gICAgQE91dHB1dCgpIHNlbGVjdGVkQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxGYWNldD4oKTtcbiAgICBAT3V0cHV0KCkgaXRlbUZvY3VzID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuICAgIEBPdXRwdXQoKSBpdGVtQmx1ciA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcbiAgICBAVmlld0NoaWxkKCdvcHRpb24nKSBvcHRpb246IEVsZW1lbnRSZWY7XG5cbiAgICBnZXQgZGlzYWJsZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmZhY2V0ICYmIHRoaXMuZmFjZXQuZGlzYWJsZWQ7XG4gICAgfVxuXG4gICAgZ2V0TGFiZWwoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmFjZXQgPyB0aGlzLmZhY2V0LnRpdGxlIDogJyc7XG4gICAgfVxuXG4gICAgZm9jdXMoKTogdm9pZCB7XG4gICAgICAgIHRoaXMub3B0aW9uLm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBGb2N1c0tleU1hbmFnZXIgfSBmcm9tICdAYW5ndWxhci9jZGsvYTExeSc7XG5pbXBvcnQgeyBBZnRlclZpZXdJbml0LCBDb21wb25lbnQsIElucHV0LCBRdWVyeUxpc3QsIFZpZXdDaGlsZHJlbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgRmFjZXRCYXNlQ29tcG9uZW50IH0gZnJvbSAnLi4vYmFzZS9mYWNldC1iYXNlL2ZhY2V0LWJhc2UuY29tcG9uZW50JztcbmltcG9ydCB7IEZhY2V0IH0gZnJvbSAnLi4vbW9kZWxzL2ZhY2V0JztcbmltcG9ydCB7IEZhY2V0Q2hlY2tMaXN0SXRlbUNvbXBvbmVudCB9IGZyb20gJy4vY2hlY2stbGlzdC1pdGVtL2ZhY2V0LWNoZWNrLWxpc3QtaXRlbS5jb21wb25lbnQnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LWZhY2V0LWNoZWNrLWxpc3QnLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9mYWNldC1jaGVjay1saXN0LmNvbXBvbmVudC5odG1sJ1xufSlcbmV4cG9ydCBjbGFzcyBGYWNldENoZWNrTGlzdENvbXBvbmVudCBleHRlbmRzIEZhY2V0QmFzZUNvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQge1xuXG4gICAgQElucHV0KCkgZmFjZXRzOiBGYWNldFtdID0gW107XG4gICAgQElucHV0KCkgaGVhZGVyOiBzdHJpbmc7XG4gICAgQElucHV0KCkgc2Nyb2xsYmFyOiBib29sZWFuID0gdHJ1ZTtcbiAgICBASW5wdXQoKSBleHBhbmRlZDogYm9vbGVhbiA9IHRydWU7XG5cbiAgICBAVmlld0NoaWxkcmVuKEZhY2V0Q2hlY2tMaXN0SXRlbUNvbXBvbmVudCkgb3B0aW9uczogUXVlcnlMaXN0PEZhY2V0Q2hlY2tMaXN0SXRlbUNvbXBvbmVudD47XG5cbiAgICBpc0ZvY3VzZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBhY3RpdmVJbmRleDogbnVtYmVyID0gMDtcblxuICAgIHByaXZhdGUgX2ZvY3VzS2V5TWFuYWdlcjogRm9jdXNLZXlNYW5hZ2VyPEZhY2V0Q2hlY2tMaXN0SXRlbUNvbXBvbmVudD47XG5cbiAgICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2ZvY3VzS2V5TWFuYWdlciA9IG5ldyBGb2N1c0tleU1hbmFnZXIodGhpcy5vcHRpb25zKVxuICAgICAgICAgICAgLndpdGhWZXJ0aWNhbE9yaWVudGF0aW9uKCk7XG5cbiAgICAgICAgdGhpcy5fZm9jdXNLZXlNYW5hZ2VyLmNoYW5nZS5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUoaW5kZXggPT4gdGhpcy5hY3RpdmVJbmRleCA9IGluZGV4KTtcbiAgICB9XG5cbiAgICBvbkZvY3VzKGluZGV4OiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuX2ZvY3VzS2V5TWFuYWdlci5hY3RpdmVJdGVtSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLl9mb2N1c0tleU1hbmFnZXIuc2V0QWN0aXZlSXRlbShpbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbktleWRvd24oZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fZm9jdXNLZXlNYW5hZ2VyLm9uS2V5ZG93bihldmVudCk7XG4gICAgfVxuXG4gICAgdG9nZ2xlRmFjZXQoaW5kZXg6IG51bWJlciwgZmFjZXQ6IEZhY2V0KTogdm9pZCB7XG4gICAgICAgIHRoaXMudG9nZ2xlRmFjZXRTZWxlY3Rpb24oZmFjZXQpO1xuICAgICAgICB0aGlzLl9mb2N1c0tleU1hbmFnZXIuc2V0QWN0aXZlSXRlbShpbmRleCk7XG4gICAgfVxufSIsImltcG9ydCB7IEZvY3VzYWJsZU9wdGlvbiB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9hMTF5JztcbmltcG9ydCB7IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDb21wb25lbnQsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE91dHB1dCwgVmlld0NoaWxkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGYWNldCB9IGZyb20gJy4uLy4uL21vZGVscy9mYWNldCc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtZmFjZXQtdHlwZWFoZWFkLWxpc3QtaXRlbScsXG4gICAgdGVtcGxhdGVVcmw6ICcuL2ZhY2V0LXR5cGVhaGVhZC1saXN0LWl0ZW0uY29tcG9uZW50Lmh0bWwnLFxuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG59KVxuZXhwb3J0IGNsYXNzIEZhY2V0VHlwZWFoZWFkTGlzdEl0ZW1Db21wb25lbnQgaW1wbGVtZW50cyBGb2N1c2FibGVPcHRpb24ge1xuXG4gICAgQElucHV0KCkgZmFjZXQ6IEZhY2V0O1xuICAgIEBJbnB1dCgpIHNlbGVjdGVkOiBib29sZWFuID0gZmFsc2U7XG4gICAgQElucHV0KCkgc2ltcGxpZmllZDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIEBJbnB1dCgpIHRhYmJhYmxlOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBAT3V0cHV0KCkgaXRlbUZvY3VzID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuICAgIEBPdXRwdXQoKSBzZWxlY3RlZENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8RmFjZXQ+KCk7XG5cbiAgICBAVmlld0NoaWxkKCdvcHRpb24nKSBvcHRpb246IEVsZW1lbnRSZWY7XG5cbiAgICBnZXQgZGlzYWJsZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmZhY2V0ICYmIHRoaXMuZmFjZXQuZGlzYWJsZWQ7XG4gICAgfVxuXG4gICAgZ2V0TGFiZWwoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmFjZXQgPyB0aGlzLmZhY2V0LnRpdGxlIDogbnVsbDtcbiAgICB9XG5cbiAgICBmb2N1cygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5vcHRpb24ubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IEZvY3VzS2V5TWFuYWdlciwgTGl2ZUFubm91bmNlciB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9hMTF5JztcbmltcG9ydCB7IEFmdGVyVmlld0luaXQsIENvbXBvbmVudCwgRWxlbWVudFJlZiwgSW5wdXQsIFBpcGUsIFBpcGVUcmFuc2Zvcm0sIFF1ZXJ5TGlzdCwgVmlld0NoaWxkcmVuIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QgfSBmcm9tICdyeGpzL0JlaGF2aW9yU3ViamVjdCc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcy9PYnNlcnZhYmxlJztcbmltcG9ydCB7IG9mIH0gZnJvbSAncnhqcy9vYnNlcnZhYmxlL29mJztcbmltcG9ydCB7IG1hcCwgbWVyZ2VNYXAsIHRha2VVbnRpbCwgdGFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgVHlwZWFoZWFkS2V5U2VydmljZSwgVHlwZWFoZWFkT3B0aW9uRXZlbnQgfSBmcm9tICcuLi8uLi90eXBlYWhlYWQvaW5kZXgnO1xuaW1wb3J0IHsgRmFjZXRCYXNlQ29tcG9uZW50IH0gZnJvbSAnLi4vYmFzZS9mYWNldC1iYXNlL2ZhY2V0LWJhc2UuY29tcG9uZW50JztcbmltcG9ydCB7IEZhY2V0Q29udGFpbmVyQ29tcG9uZW50IH0gZnJvbSAnLi4vZmFjZXQtY29udGFpbmVyLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBGYWNldCB9IGZyb20gJy4uL21vZGVscy9mYWNldCc7XG5pbXBvcnQgeyBGYWNldFR5cGVhaGVhZExpc3RJdGVtQ29tcG9uZW50IH0gZnJvbSAnLi90eXBlYWhlYWQtbGlzdC1pdGVtL2ZhY2V0LXR5cGVhaGVhZC1saXN0LWl0ZW0uY29tcG9uZW50JztcblxubGV0IHVuaXF1ZUlkID0gMTtcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1mYWNldC10eXBlYWhlYWQtbGlzdCcsXG4gICAgdGVtcGxhdGVVcmw6ICcuL2ZhY2V0LXR5cGVhaGVhZC1saXN0LmNvbXBvbmVudC5odG1sJ1xufSlcbmV4cG9ydCBjbGFzcyBGYWNldFR5cGVhaGVhZExpc3RDb21wb25lbnQgZXh0ZW5kcyBGYWNldEJhc2VDb21wb25lbnQgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0IHtcblxuICAgIEBJbnB1dCgpIGZhY2V0czogRmFjZXRbXSB8IE9ic2VydmFibGU8RmFjZXRbXT47XG4gICAgQElucHV0KCkgaGVhZGVyOiBzdHJpbmc7XG4gICAgQElucHV0KCkgZXhwYW5kZWQ6IGJvb2xlYW4gPSB0cnVlO1xuICAgIEBJbnB1dCgpIHN1Z2dlc3Rpb25zOiBGYWNldFtdID0gW107XG4gICAgQElucHV0KCkgc2ltcGxpZmllZDogYm9vbGVhbiA9IHRydWU7XG5cbiAgICBASW5wdXQoKVxuICAgIHNldCB0eXBlYWhlYWRDb25maWcoY29uZmlnOiBGYWNldFR5cGVhaGVhZExpc3RDb25maWcpIHtcbiAgICAgICAgdGhpcy5fY29uZmlnID0geyBwbGFjZWhvbGRlcjogJycsIG1heFJlc3VsdHM6IDUwLCBtaW5DaGFyYWN0ZXJzOiAxLCAuLi5jb25maWcgfTtcbiAgICB9XG5cbiAgICBnZXQgdHlwZWFoZWFkQ29uZmlnKCk6IEZhY2V0VHlwZWFoZWFkTGlzdENvbmZpZyB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25maWc7XG4gICAgfVxuXG4gICAgQFZpZXdDaGlsZHJlbihGYWNldFR5cGVhaGVhZExpc3RJdGVtQ29tcG9uZW50KSBvcHRpb25zOiBRdWVyeUxpc3Q8RmFjZXRUeXBlYWhlYWRMaXN0SXRlbUNvbXBvbmVudD47XG5cbiAgICBxdWVyeSQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PHN0cmluZz4oJycpO1xuICAgIGxvYWRpbmc6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBhY3RpdmVJbmRleDogbnVtYmVyID0gMDtcbiAgICB0eXBlYWhlYWRJZDogc3RyaW5nID0gYHV4LWZhY2V0LXR5cGVhaGVhZC0ke3VuaXF1ZUlkKyt9YDtcbiAgICB0eXBlYWhlYWRPcGVuOiBib29sZWFuID0gZmFsc2U7XG4gICAgdHlwZWFoZWFkT3B0aW9uczogRmFjZXRbXSA9IFtdO1xuICAgIGhpZ2hsaWdodGVkRWxlbWVudDogSFRNTEVsZW1lbnQ7XG5cbiAgICBwcml2YXRlIF9jb25maWc6IEZhY2V0VHlwZWFoZWFkTGlzdENvbmZpZyA9IHsgcGxhY2Vob2xkZXI6ICcnLCBtYXhSZXN1bHRzOiA1MCwgbWluQ2hhcmFjdGVyczogMSB9O1xuICAgIHByaXZhdGUgX2ZvY3VzS2V5TWFuYWdlcjogRm9jdXNLZXlNYW5hZ2VyPEZhY2V0VHlwZWFoZWFkTGlzdEl0ZW1Db21wb25lbnQ+O1xuXG4gICAgY29uc3RydWN0b3IocHVibGljIHR5cGVhaGVhZEtleVNlcnZpY2U6IFR5cGVhaGVhZEtleVNlcnZpY2UsIGZhY2V0Q29udGFpbmVyOiBGYWNldENvbnRhaW5lckNvbXBvbmVudCwgZWxlbWVudFJlZjogRWxlbWVudFJlZiwgcHJpdmF0ZSBfYW5ub3VuY2VyOiBMaXZlQW5ub3VuY2VyKSB7XG4gICAgICAgIHN1cGVyKGZhY2V0Q29udGFpbmVyLCBlbGVtZW50UmVmKTtcbiAgICB9XG5cbiAgICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gc2V0IHVwIHNlYXJjaCBxdWVyeSBzdWJzY3JpcHRpb25cbiAgICAgICAgdGhpcy5xdWVyeSQucGlwZShcbiAgICAgICAgICAgIHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpLFxuICAgICAgICAgICAgdGFwKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMudHlwZWFoZWFkT3B0aW9ucyA9IFtdO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBtZXJnZU1hcCgoKSA9PiB0aGlzLmdldEZhY2V0T2JzZXJ2YWJsZSgpLnBpcGUobWFwKGZhY2V0cyA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhY2V0cy5maWx0ZXIoZmFjZXQgPT4gIWZhY2V0LmRpc2FibGVkICYmICF0aGlzLnNlbGVjdGVkLmZpbmQoc2VsZWN0ZWRGYWNldCA9PiBzZWxlY3RlZEZhY2V0ID09PSBmYWNldCkpXG4gICAgICAgICAgICAgICAgICAgIC5zbGljZSgwLCB0aGlzLl9jb25maWcubWF4UmVzdWx0cyk7XG4gICAgICAgICAgICB9KSkpXG4gICAgICAgICkuc3Vic2NyaWJlKGZhY2V0cyA9PiB7XG4gICAgICAgICAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMudHlwZWFoZWFkT3B0aW9ucyA9IGZhY2V0cztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fZm9jdXNLZXlNYW5hZ2VyID0gbmV3IEZvY3VzS2V5TWFuYWdlcih0aGlzLm9wdGlvbnMpLndpdGhWZXJ0aWNhbE9yaWVudGF0aW9uKCk7XG4gICAgICAgIHRoaXMuX2ZvY3VzS2V5TWFuYWdlci5jaGFuZ2UucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSkuc3Vic2NyaWJlKGluZGV4ID0+IHRoaXMuYWN0aXZlSW5kZXggPSBpbmRleCk7XG4gICAgfVxuXG4gICAgb25LZXlkb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2ZvY3VzS2V5TWFuYWdlci5vbktleWRvd24oZXZlbnQpO1xuICAgIH1cblxuICAgIG9uRm9jdXMoaW5kZXg6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5fZm9jdXNLZXlNYW5hZ2VyLmFjdGl2ZUl0ZW1JbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZvY3VzS2V5TWFuYWdlci5zZXRBY3RpdmVJdGVtKGluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRvZ2dsZUZhY2V0KGluZGV4OiBudW1iZXIsIGZhY2V0OiBGYWNldCk6IHZvaWQge1xuICAgICAgICB0aGlzLnRvZ2dsZUZhY2V0U2VsZWN0aW9uKGZhY2V0KTtcbiAgICAgICAgdGhpcy5fZm9jdXNLZXlNYW5hZ2VyLnNldEFjdGl2ZUl0ZW0oaW5kZXgpO1xuICAgIH1cblxuICAgIC8qKiBPbmx5IHNob3cgdHlwZWFoZWFkIGlmIHdlIGhhdmUgZW5vdWdoIGNoYXJhY3RlcnMgKi9cbiAgICB1cGRhdGVUeXBlYWhlYWQocXVlcnk6IHN0cmluZyA9ICcnKTogdm9pZCB7XG4gICAgICAgIHRoaXMudHlwZWFoZWFkT3BlbiA9IHF1ZXJ5Lmxlbmd0aCA+PSB0aGlzLl9jb25maWcubWluQ2hhcmFjdGVycztcbiAgICB9XG5cbiAgICBnZXRGYWNldE9ic2VydmFibGUoKTogT2JzZXJ2YWJsZTxGYWNldFtdPiB7XG4gICAgICAgIHJldHVybiB0aGlzLmZhY2V0cyBpbnN0YW5jZW9mIE9ic2VydmFibGUgPyB0aGlzLmZhY2V0cyA6IG9mKHRoaXMuZmFjZXRzKTtcbiAgICB9XG5cbiAgICBzZWxlY3QoZXZlbnQ6IFR5cGVhaGVhZE9wdGlvbkV2ZW50KSB7XG5cbiAgICAgICAgLy8gY2hlY2sgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIGl0ZW0gaXMgbm90IGN1cnJlbnRseSBzZWxlY3RlZFxuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZC5maW5kKGZhY2V0ID0+IGZhY2V0ID09PSBldmVudC5vcHRpb24pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZWxlY3QgdGhlIGZhY2V0XG4gICAgICAgIHRoaXMuc2VsZWN0RmFjZXQoZXZlbnQub3B0aW9uKTtcblxuICAgICAgICAvLyBjbGVhciB0aGUgdHlwZWFoZWFkXG4gICAgICAgIHRoaXMucXVlcnkkLm5leHQoJycpO1xuXG4gICAgICAgIC8vIGFubm91bmNlIHRoZSBzZWxlY3RlZCBmYWNldFxuICAgICAgICB0aGlzLl9hbm5vdW5jZXIuYW5ub3VuY2UoYCR7KGV2ZW50Lm9wdGlvbiBhcyBGYWNldCkudGl0bGV9IHNlbGVjdGVkLmApO1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBGYWNldFR5cGVhaGVhZExpc3RDb25maWcge1xuICAgIHBsYWNlaG9sZGVyPzogc3RyaW5nO1xuICAgIG1pbkNoYXJhY3RlcnM/OiBudW1iZXI7XG4gICAgbWF4UmVzdWx0cz86IG51bWJlcjtcbiAgICBkZWxheT86IG51bWJlcjtcbn1cblxuQFBpcGUoe1xuICAgIG5hbWU6ICdmYWNldFR5cGVhaGVhZEhpZ2hsaWdodCdcbn0pXG5leHBvcnQgY2xhc3MgRmFjZXRUeXBlYWhlYWRIaWdobGlnaHQgaW1wbGVtZW50cyBQaXBlVHJhbnNmb3JtIHtcbiAgICB0cmFuc2Zvcm0odmFsdWU6IHN0cmluZywgc2VhcmNoUXVlcnk6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIGxldCByZWdleCA9IG5ldyBSZWdFeHAoc2VhcmNoUXVlcnksICdpJyk7XG4gICAgICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKHJlZ2V4LCBgPGIgY2xhc3M9XCJmYWNldC10eXBlYWhlYWQtaGlnaGxpZ2h0ZWRcIj4ke3ZhbHVlLm1hdGNoKHJlZ2V4KX08L2I+YCk7XG4gICAgfVxufSIsImltcG9ydCB7IEExMXlNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jZGsvYTExeSc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZvcm1zTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgQ2hlY2tib3hNb2R1bGUgfSBmcm9tICcuLi9jaGVja2JveC9pbmRleCc7XG5pbXBvcnQgeyBUb29sdGlwTW9kdWxlIH0gZnJvbSAnLi4vdG9vbHRpcC9pbmRleCc7XG5pbXBvcnQgeyBUeXBlYWhlYWRNb2R1bGUgfSBmcm9tICcuLi90eXBlYWhlYWQvaW5kZXgnO1xuaW1wb3J0IHsgUmVvcmRlcmFibGVNb2R1bGUgfSBmcm9tICcuLy4uLy4uL2RpcmVjdGl2ZXMvcmVvcmRlcmFibGUvcmVvcmRlcmFibGUubW9kdWxlJztcbmltcG9ydCB7IEZhY2V0QmFzZUNvbXBvbmVudCB9IGZyb20gJy4vYmFzZS9mYWNldC1iYXNlL2ZhY2V0LWJhc2UuY29tcG9uZW50JztcbmltcG9ydCB7IEZhY2V0SGVhZGVyQ29tcG9uZW50IH0gZnJvbSAnLi9iYXNlL2ZhY2V0LWhlYWRlci9mYWNldC1oZWFkZXIuY29tcG9uZW50JztcbmltcG9ydCB7IEZhY2V0Q2hlY2tMaXN0SXRlbUNvbXBvbmVudCB9IGZyb20gJy4vZmFjZXQtY2hlY2stbGlzdC9jaGVjay1saXN0LWl0ZW0vZmFjZXQtY2hlY2stbGlzdC1pdGVtLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBGYWNldENoZWNrTGlzdENvbXBvbmVudCB9IGZyb20gJy4vZmFjZXQtY2hlY2stbGlzdC9mYWNldC1jaGVjay1saXN0LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBGYWNldENvbnRhaW5lckNvbXBvbmVudCB9IGZyb20gJy4vZmFjZXQtY29udGFpbmVyLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBGYWNldFR5cGVhaGVhZEhpZ2hsaWdodCwgRmFjZXRUeXBlYWhlYWRMaXN0Q29tcG9uZW50IH0gZnJvbSAnLi9mYWNldC10eXBlYWhlYWQtbGlzdC9mYWNldC10eXBlYWhlYWQtbGlzdC5jb21wb25lbnQnO1xuaW1wb3J0IHsgRmFjZXRUeXBlYWhlYWRMaXN0SXRlbUNvbXBvbmVudCB9IGZyb20gJy4vZmFjZXQtdHlwZWFoZWFkLWxpc3QvdHlwZWFoZWFkLWxpc3QtaXRlbS9mYWNldC10eXBlYWhlYWQtbGlzdC1pdGVtLmNvbXBvbmVudCc7XG5cbmNvbnN0IERFQ0xBUkFUSU9OUyA9IFtcbiAgICBGYWNldENvbnRhaW5lckNvbXBvbmVudCxcbiAgICBGYWNldEhlYWRlckNvbXBvbmVudCxcbiAgICBGYWNldEJhc2VDb21wb25lbnQsXG4gICAgRmFjZXRDaGVja0xpc3RDb21wb25lbnQsXG4gICAgRmFjZXRDaGVja0xpc3RJdGVtQ29tcG9uZW50LFxuICAgIEZhY2V0VHlwZWFoZWFkTGlzdENvbXBvbmVudCxcbiAgICBGYWNldFR5cGVhaGVhZExpc3RJdGVtQ29tcG9uZW50LFxuICAgIEZhY2V0VHlwZWFoZWFkSGlnaGxpZ2h0XG5dO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQTExeU1vZHVsZSxcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgQ2hlY2tib3hNb2R1bGUsXG4gICAgICAgIFRvb2x0aXBNb2R1bGUsXG4gICAgICAgIFJlb3JkZXJhYmxlTW9kdWxlLFxuICAgICAgICBUeXBlYWhlYWRNb2R1bGVcbiAgICBdLFxuICAgIGV4cG9ydHM6IERFQ0xBUkFUSU9OUyxcbiAgICBkZWNsYXJhdGlvbnM6IERFQ0xBUkFUSU9OU1xufSlcbmV4cG9ydCBjbGFzcyBGYWNldHNNb2R1bGUgeyB9XG4iLCJleHBvcnQgY2xhc3MgRmFjZXQge1xuICAgIFxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwdWJsaWMgdGl0bGU6IHN0cmluZyxcbiAgICAgICAgcHVibGljIGRhdGE6IGFueSA9IHt9LFxuICAgICAgICBwdWJsaWMgY291bnQ/OiBudW1iZXIsXG4gICAgICAgIHB1YmxpYyBkaXNhYmxlZDogYm9vbGVhbiA9IGZhbHNlLFxuICAgICAgICBwdWJsaWMgaWQ/OiBzdHJpbmcgfCBudW1iZXJcbiAgICApIHsgfVxufSIsImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcbmltcG9ydCB7IE1lbnVOYXZpZ2F0aW9uSXRlbURpcmVjdGl2ZSB9IGZyb20gJy4vbWVudS1uYXZpZ2F0aW9uLWl0ZW0uZGlyZWN0aXZlJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIE1lbnVOYXZpZ2F0aW9uU2VydmljZSB7XG5cbiAgICBhY3RpdmUkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxNZW51TmF2aWdhdGlvbkl0ZW1EaXJlY3RpdmU+KG51bGwpO1xufSIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBPbkRlc3Ryb3ksIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcy9TdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgTWVudU5hdmlnYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi9tZW51LW5hdmlnYXRpb24uc2VydmljZSc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3V4TWVudU5hdmlnYXRpb25JdGVtXSdcbn0pXG5leHBvcnQgY2xhc3MgTWVudU5hdmlnYXRpb25JdGVtRGlyZWN0aXZlIGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICAgIEBPdXRwdXQoKSBhY3RpdmF0ZWQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICBwcml2YXRlIF9zdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2U6IE1lbnVOYXZpZ2F0aW9uU2VydmljZSwgcHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZikge1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24gPSBzZXJ2aWNlLmFjdGl2ZSQuc3Vic2NyaWJlKChuZXh0KSA9PiB7XG4gICAgICAgICAgICBpZiAobmV4dCA9PT0gdGhpcykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QWN0aXZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG5cbiAgICBzZXRBY3RpdmUoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgICAgICB0aGlzLmFjdGl2YXRlZC5lbWl0KCk7XG4gICAgfVxufSIsImltcG9ydCB7IERPQ1VNRU5UIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IEFmdGVyQ29udGVudEluaXQsIENvbnRlbnRDaGlsZHJlbiwgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIEhvc3RMaXN0ZW5lciwgSW5qZWN0LCBJbnB1dCwgT25EZXN0cm95LCBPbkluaXQsIE91dHB1dCwgUXVlcnlMaXN0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBNZW51TmF2aWdhdGlvbkl0ZW1EaXJlY3RpdmUgfSBmcm9tICcuL21lbnUtbmF2aWdhdGlvbi1pdGVtLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBNZW51TmF2aWdhdGlvblRvZ2dsZURpcmVjdGl2ZSB9IGZyb20gJy4vbWVudS1uYXZpZ2F0aW9uLXRvZ2dsZS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgTWVudU5hdmlnYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi9tZW51LW5hdmlnYXRpb24uc2VydmljZSc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3V4TWVudU5hdmlnYXRpb25dJyxcbiAgICBleHBvcnRBczogJ3V4TWVudU5hdmlnYXRpb24nLFxuICAgIHByb3ZpZGVyczogW01lbnVOYXZpZ2F0aW9uU2VydmljZV1cbn0pXG5leHBvcnQgY2xhc3MgTWVudU5hdmlnYXRpb25EaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIEFmdGVyQ29udGVudEluaXQsIE9uRGVzdHJveSB7XG5cbiAgICBASW5wdXQoKVxuICAgIHRvZ2dsZUJ1dHRvbjogTWVudU5hdmlnYXRpb25Ub2dnbGVEaXJlY3RpdmU7XG5cbiAgICBASW5wdXQoKVxuICAgIHRvZ2dsZUJ1dHRvblBvc2l0aW9uOiAndG9wJyB8ICdyaWdodCcgfCAnYm90dG9tJyB8ICdsZWZ0JyA9ICd0b3AnO1xuXG4gICAgQE91dHB1dCgpXG4gICAgbmF2aWdhdGVkT3V0ID0gbmV3IEV2ZW50RW1pdHRlcjxLZXlib2FyZEV2ZW50PigpO1xuXG4gICAgQENvbnRlbnRDaGlsZHJlbihNZW51TmF2aWdhdGlvbkl0ZW1EaXJlY3RpdmUsIHsgZGVzY2VuZGFudHM6IHRydWUgfSlcbiAgICBpdGVtczogUXVlcnlMaXN0PE1lbnVOYXZpZ2F0aW9uSXRlbURpcmVjdGl2ZT47XG5cbiAgICBnZXQgYWN0aXZlSW5kZXgoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1zT3JkZXJlZC5pbmRleE9mKHRoaXMuX3NlcnZpY2UuYWN0aXZlJC52YWx1ZSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfaXRlbXNPcmRlcmVkOiBNZW51TmF2aWdhdGlvbkl0ZW1EaXJlY3RpdmVbXTtcblxuICAgIHByaXZhdGUgX2RvY3VtZW50OiBhbnk7XG5cbiAgICBwcml2YXRlIF9zdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uKCk7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBfc2VydmljZTogTWVudU5hdmlnYXRpb25TZXJ2aWNlLFxuICAgICAgICBwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgICAgICBASW5qZWN0KERPQ1VNRU5UKSBkb2N1bWVudDogYW55XG4gICAgKSB7XG4gICAgICAgIHRoaXMuX2RvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLnRvZ2dsZUJ1dHRvbikge1xuICAgICAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLmFkZChcbiAgICAgICAgICAgICAgICB0aGlzLnRvZ2dsZUJ1dHRvbi5rZXlFbnRlci5zdWJzY3JpYmUodGhpcy5mb2N1c0ZpcnN0LmJpbmQodGhpcykpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCk6IHZvaWQge1xuXG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi5hZGQoXG4gICAgICAgICAgICB0aGlzLml0ZW1zLmNoYW5nZXMuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pdGVtc09yZGVyZWQgPSB0aGlzLml0ZW1zLnRvQXJyYXkoKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5faXRlbXNPcmRlcmVkID0gdGhpcy5pdGVtcy50b0FycmF5KCk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cblxuICAgIGZvY3VzRmlyc3QoKTogdm9pZCB7XG4gICAgICAgIHRoaXMubW92ZUZpcnN0KCk7XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcignZG9jdW1lbnQ6a2V5ZG93bicsIFsnJGV2ZW50J10pXG4gICAga2V5ZG93bkhhbmRsZXIoZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcblxuICAgICAgICAvLyBPbmx5IGhhbmRsZSBldmVudHMgd2hlbiBmb2N1cyBpbiB3aXRoaW4gdGhlIGxpc3Qgb2YgbWVudSBpdGVtc1xuICAgICAgICBpZiAoIXRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5jb250YWlucyh0aGlzLl9kb2N1bWVudC5hY3RpdmVFbGVtZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGhhbmRsZWQgPSBmYWxzZTtcblxuICAgICAgICBzd2l0Y2ggKGV2ZW50LmtleSkge1xuXG4gICAgICAgICAgICBjYXNlICdBcnJvd1VwJzpcbiAgICAgICAgICAgIGNhc2UgJ1VwJzpcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVQcmV2aW91cyhldmVudCk7XG4gICAgICAgICAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ0Fycm93RG93bic6XG4gICAgICAgICAgICBjYXNlICdEb3duJzpcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVOZXh0KGV2ZW50KTtcbiAgICAgICAgICAgICAgICBoYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnQXJyb3dMZWZ0JzpcbiAgICAgICAgICAgIGNhc2UgJ0xlZnQnOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRvZ2dsZUJ1dHRvblBvc2l0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb3ZlVG9Ub2dnbGVCdXR0b24oZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ0Fycm93UmlnaHQnOlxuICAgICAgICAgICAgY2FzZSAnUmlnaHQnOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRvZ2dsZUJ1dHRvblBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW92ZVRvVG9nZ2xlQnV0dG9uKGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdIb21lJzpcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVGaXJzdCgpO1xuICAgICAgICAgICAgICAgIGhhbmRsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdFbmQnOlxuICAgICAgICAgICAgICAgIHRoaXMubW92ZUxhc3QoKTtcbiAgICAgICAgICAgICAgICBoYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnRXNjYXBlJzpcbiAgICAgICAgICAgICAgICB0aGlzLm5hdmlnYXRlZE91dC5lbWl0KGV2ZW50KTtcbiAgICAgICAgICAgICAgICBoYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYW5kbGVkKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIG1vdmVOZXh0KGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZCB7XG5cbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiB0aGVyZSdzIG5vIGFjdGl2ZSBtZW51IGl0ZW0gcmVnaXN0ZXJlZFxuICAgICAgICBpZiAodGhpcy5hY3RpdmVJbmRleCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5leHRJbmRleCA9IHRoaXMuYWN0aXZlSW5kZXggKyAxO1xuICAgICAgICBpZiAobmV4dEluZGV4IDwgdGhpcy5faXRlbXNPcmRlcmVkLmxlbmd0aCkge1xuXG4gICAgICAgICAgICAvLyBBY3RpdmF0ZSB0aGUgbmV4dCBtZW51IGl0ZW1cbiAgICAgICAgICAgIC8vICh1eE1lbnVOYXZpZ2F0aW9uSXRlbSBzdWJzY3JpYmVzIHRvIHRoaXMgYW5kIGFwcGxpZXMgZm9jdXMgaWYgaXQgbWF0Y2hlcylcbiAgICAgICAgICAgIHRoaXMuX3NlcnZpY2UuYWN0aXZlJC5uZXh0KHRoaXMuX2l0ZW1zT3JkZXJlZFtuZXh0SW5kZXhdKTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiBmb2N1cyB3ZW50IG91dCBvZiBib3VuZHMgaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGUgb3JpZ2luIHRvZ2dsZSBidXR0b25cbiAgICAgICAgICAgIGlmICh0aGlzLnRvZ2dsZUJ1dHRvblBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgICAgICAgICAgICAgIHRoaXMubW92ZVRvVG9nZ2xlQnV0dG9uKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgbW92ZVByZXZpb3VzKGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZCB7XG5cbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiB0aGVyZSdzIG5vIGFjdGl2ZSBtZW51IGl0ZW0gcmVnaXN0ZXJlZFxuICAgICAgICBpZiAodGhpcy5hY3RpdmVJbmRleCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG5leHRJbmRleCA9IHRoaXMuYWN0aXZlSW5kZXggLSAxO1xuICAgICAgICBpZiAobmV4dEluZGV4ID49IDApIHtcblxuICAgICAgICAgICAgLy8gQWN0aXZhdGUgdGhlIHByZXZpb3VzIG1lbnUgaXRlbVxuICAgICAgICAgICAgLy8gKHV4TWVudU5hdmlnYXRpb25JdGVtIHN1YnNjcmliZXMgdG8gdGhpcyBhbmQgYXBwbGllcyBmb2N1cyBpZiBpdCBtYXRjaGVzKVxuICAgICAgICAgICAgdGhpcy5fc2VydmljZS5hY3RpdmUkLm5leHQodGhpcy5faXRlbXNPcmRlcmVkW25leHRJbmRleF0pO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGZvY3VzIHdlbnQgb3V0IG9mIGJvdW5kcyBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBvcmlnaW4gdG9nZ2xlIGJ1dHRvblxuICAgICAgICAgICAgaWYgKHRoaXMudG9nZ2xlQnV0dG9uUG9zaXRpb24gPT09ICd0b3AnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb3ZlVG9Ub2dnbGVCdXR0b24oZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBtb3ZlRmlyc3QoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLl9pdGVtc09yZGVyZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fc2VydmljZS5hY3RpdmUkLm5leHQodGhpcy5faXRlbXNPcmRlcmVkWzBdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgbW92ZUxhc3QoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLl9pdGVtc09yZGVyZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fc2VydmljZS5hY3RpdmUkLm5leHQodGhpcy5faXRlbXNPcmRlcmVkW3RoaXMuX2l0ZW1zT3JkZXJlZC5sZW5ndGggLSAxXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIG1vdmVUb1RvZ2dsZUJ1dHRvbihldmVudDogS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy50b2dnbGVCdXR0b24pIHtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlQnV0dG9uLmZvY3VzKCk7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZUJ1dHRvbi5tZW51T3BlbiA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5uYXZpZ2F0ZWRPdXQuZW1pdChldmVudCk7XG4gICAgfVxufSIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBIb3N0TGlzdGVuZXIsIElucHV0LCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbdXhNZW51TmF2aWdhdGlvblRvZ2dsZV0nLFxuICAgIGV4cG9ydEFzOiAndXhNZW51TmF2aWdhdGlvblRvZ2dsZSdcbn0pXG5leHBvcnQgY2xhc3MgTWVudU5hdmlnYXRpb25Ub2dnbGVEaXJlY3RpdmUge1xuXG4gICAgQElucHV0KClcbiAgICBnZXQgbWVudU9wZW4oKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZW51T3BlbjtcbiAgICB9XG5cbiAgICBzZXQgbWVudU9wZW4odmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5fbWVudU9wZW4gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5tZW51T3BlbkNoYW5nZS5lbWl0KHZhbHVlKTtcbiAgICB9XG5cbiAgICBASW5wdXQoKVxuICAgIG1lbnVQb3NpdGlvbjogJ3RvcCcgfCAncmlnaHQnIHwgJ2JvdHRvbScgfCAnbGVmdCcgPSAnYm90dG9tJztcblxuICAgIEBPdXRwdXQoKVxuICAgIG1lbnVPcGVuQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG4gICAga2V5RW50ZXIgPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG5cbiAgICBwcml2YXRlIF9tZW51T3BlbjogYm9vbGVhbjtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYpIHsgfVxuXG4gICAgZm9jdXMoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgIH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ2tleWRvd24nLCBbJyRldmVudCddKVxuICAgIGtleWRvd25IYW5kbGVyKGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZCB7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNLZXlNYXRjaChldmVudC5rZXkpKSB7XG5cbiAgICAgICAgICAgIC8vIE9wZW4gdGhlIG1lbnVcbiAgICAgICAgICAgIHRoaXMubWVudU9wZW4gPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBBbGxvdyB0aGUgbWVudSB0byBpbml0LCB0aGVuIHNlbmQgdGhlIGV2ZW50IHRvIGdpdmUgaXQgZm9jdXNcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMua2V5RW50ZXIuZW1pdCgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgaXNLZXlNYXRjaChrZXk6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICAgY2FzZSAnRW50ZXInOlxuICAgICAgICAgICAgY2FzZSAnICc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgICAgIGNhc2UgJ0Fycm93VXAnOlxuICAgICAgICAgICAgY2FzZSAnVXAnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1lbnVQb3NpdGlvbiA9PT0gJ3RvcCc7XG5cbiAgICAgICAgICAgIGNhc2UgJ0Fycm93RG93bic6XG4gICAgICAgICAgICBjYXNlICdEb3duJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tZW51UG9zaXRpb24gPT09ICdib3R0b20nO1xuXG4gICAgICAgICAgICBjYXNlICdBcnJvd0xlZnQnOlxuICAgICAgICAgICAgY2FzZSAnTGVmdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVudVBvc2l0aW9uID09PSAnbGVmdCc7XG5cbiAgICAgICAgICAgIGNhc2UgJ0Fycm93UmlnaHQnOlxuICAgICAgICAgICAgY2FzZSAnUmlnaHQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1lbnVQb3NpdGlvbiA9PT0gJ3JpZ2h0JztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59IiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgTWVudU5hdmlnYXRpb25EaXJlY3RpdmUgfSBmcm9tICcuL21lbnUtbmF2aWdhdGlvbi5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgTWVudU5hdmlnYXRpb25JdGVtRGlyZWN0aXZlIH0gZnJvbSAnLi9tZW51LW5hdmlnYXRpb24taXRlbS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgTWVudU5hdmlnYXRpb25Ub2dnbGVEaXJlY3RpdmUgfSBmcm9tICcuL21lbnUtbmF2aWdhdGlvbi10b2dnbGUuZGlyZWN0aXZlJztcblxuY29uc3QgRVhQT1JUUyA9IFtcbiAgICBNZW51TmF2aWdhdGlvbkRpcmVjdGl2ZSxcbiAgICBNZW51TmF2aWdhdGlvbkl0ZW1EaXJlY3RpdmUsXG4gICAgTWVudU5hdmlnYXRpb25Ub2dnbGVEaXJlY3RpdmVcbl07XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW10sXG4gICAgZXhwb3J0czogRVhQT1JUUyxcbiAgICBkZWNsYXJhdGlvbnM6IEVYUE9SVFMsXG59KVxuZXhwb3J0IGNsYXNzIE1lbnVOYXZpZ2F0aW9uTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIElucHV0LCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1maWx0ZXItY29udGFpbmVyJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vZmlsdGVyLWNvbnRhaW5lci5jb21wb25lbnQuaHRtbCdcbn0pXG5leHBvcnQgY2xhc3MgRmlsdGVyQ29udGFpbmVyQ29tcG9uZW50IHtcblxuICAgIEBJbnB1dCgpIGZpbHRlcnM6IEZpbHRlcltdID0gW107XG4gICAgQElucHV0KCkgY2xlYXJUb29sdGlwOiBzdHJpbmc7XG4gICAgQE91dHB1dCgpIGZpbHRlcnNDaGFuZ2U6IEV2ZW50RW1pdHRlcjxGaWx0ZXJbXT4gPSBuZXcgRXZlbnRFbWl0dGVyPEZpbHRlcltdPigpO1xuICAgIEBPdXRwdXQoKSBldmVudHM6IEV2ZW50RW1pdHRlcjxGaWx0ZXJFdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPEZpbHRlckV2ZW50PigpO1xuXG5cbiAgICBhZGRGaWx0ZXIoZmlsdGVyOiBGaWx0ZXIpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICAgICAgdGhpcy5ldmVudHMubmV4dChuZXcgRmlsdGVyQWRkRXZlbnQoZmlsdGVyKSk7XG4gICAgICAgIHRoaXMuZmlsdGVyc0NoYW5nZS5lbWl0KHRoaXMuZmlsdGVycyk7XG4gICAgfVxuXG4gICAgcmVtb3ZlRmlsdGVyKGZpbHRlcjogRmlsdGVyKTogdm9pZCB7XG4gICAgICAgIGxldCBpZHggPSB0aGlzLmZpbHRlcnMuZmluZEluZGV4KGZpbHRlcnMgPT4gZmlsdGVycyA9PT0gZmlsdGVyKTtcblxuICAgICAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5maWx0ZXJzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgICAgdGhpcy5ldmVudHMubmV4dChuZXcgRmlsdGVyUmVtb3ZlRXZlbnQoZmlsdGVyKSk7XG4gICAgICAgICAgICB0aGlzLmZpbHRlcnNDaGFuZ2UuZW1pdCh0aGlzLmZpbHRlcnMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVtb3ZlQWxsKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmV2ZW50cy5uZXh0KG5ldyBGaWx0ZXJSZW1vdmVBbGxFdmVudCgpKTtcbiAgICB9XG5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBGaWx0ZXIge1xuICAgIGdyb3VwOiBzdHJpbmc7XG4gICAgdGl0bGU6IHN0cmluZztcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgaW5pdGlhbD86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBjbGFzcyBGaWx0ZXJBZGRFdmVudCB7XG4gICAgY29uc3RydWN0b3IocHVibGljIGZpbHRlcjogRmlsdGVyKSB7fVxufVxuXG5leHBvcnQgY2xhc3MgRmlsdGVyUmVtb3ZlRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBmaWx0ZXI6IEZpbHRlcikge31cbn1cblxuZXhwb3J0IGNsYXNzIEZpbHRlclJlbW92ZUFsbEV2ZW50IHtcbn1cblxuZXhwb3J0IHR5cGUgRmlsdGVyRXZlbnQgPSBGaWx0ZXJBZGRFdmVudCB8IEZpbHRlclJlbW92ZUV2ZW50IHwgRmlsdGVyUmVtb3ZlQWxsRXZlbnQ7IiwiXG5pbXBvcnQgeyBMaXZlQW5ub3VuY2VyIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2ExMXknO1xuaW1wb3J0IHsgRGlyZWN0aXZlLCBIb3N0LCBJbnB1dCwgT25EZXN0cm95IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBmaWx0ZXIgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBGaWx0ZXIsIEZpbHRlckNvbnRhaW5lckNvbXBvbmVudCwgRmlsdGVyUmVtb3ZlQWxsRXZlbnQgfSBmcm9tICcuLi9maWx0ZXItY29udGFpbmVyLmNvbXBvbmVudCc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAndXgtZmlsdGVyLWJhc2UnXG59KVxuZXhwb3J0IGNsYXNzIEZpbHRlckJhc2VDb21wb25lbnQgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuXG4gICAgQElucHV0KCkgZmlsdGVyczogRmlsdGVyW107XG5cbiAgICBwcml2YXRlIF9zdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICAgIGNvbnN0cnVjdG9yKEBIb3N0KCkgcHJpdmF0ZSBmaWx0ZXJzQ29udGFpbmVyOiBGaWx0ZXJDb250YWluZXJDb21wb25lbnQsIHByaXZhdGUgX2Fubm91bmNlcjogTGl2ZUFubm91bmNlcikge1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24gPSBmaWx0ZXJzQ29udGFpbmVyLmV2ZW50cy5waXBlKGZpbHRlcihldmVudCA9PiBldmVudCBpbnN0YW5jZW9mIEZpbHRlclJlbW92ZUFsbEV2ZW50KSkuc3Vic2NyaWJlKHRoaXMucmVtb3ZlRmlsdGVyLmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG5cbiAgICBhZGRGaWx0ZXIoX2ZpbHRlcjogRmlsdGVyKTogdm9pZCB7XG4gICAgICAgIGlmICghX2ZpbHRlci5pbml0aWFsKSB7XG4gICAgICAgICAgICB0aGlzLmZpbHRlcnNDb250YWluZXIuYWRkRmlsdGVyKF9maWx0ZXIpO1xuICAgICAgICAgICAgdGhpcy5fYW5ub3VuY2VyLmFubm91bmNlKGBGaWx0ZXIgJHtfZmlsdGVyLm5hbWV9IHNlbGVjdGVkLmApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVtb3ZlRmlsdGVyKF9maWx0ZXI6IEZpbHRlcik6IHZvaWQge1xuICAgICAgICBpZiAoIV9maWx0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZmlsdGVyc0NvbnRhaW5lci5yZW1vdmVGaWx0ZXIoX2ZpbHRlcik7XG4gICAgICAgIHRoaXMuX2Fubm91bmNlci5hbm5vdW5jZShgRmlsdGVyICR7X2ZpbHRlci5uYW1lfSBkZXNlbGVjdGVkLmApO1xuICAgIH1cblxufSIsImltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZpbHRlckJhc2VDb21wb25lbnQgfSBmcm9tICcuLi9maWx0ZXItYmFzZS9maWx0ZXItYmFzZS5jb21wb25lbnQnO1xuaW1wb3J0IHsgRmlsdGVyIH0gZnJvbSAnLi4vZmlsdGVyLWNvbnRhaW5lci5jb21wb25lbnQnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LWZpbHRlci1kcm9wZG93bicsXG4gICAgdGVtcGxhdGVVcmw6ICcuL2ZpbHRlci1kcm9wZG93bi5jb21wb25lbnQuaHRtbCcsXG59KVxuZXhwb3J0IGNsYXNzIEZpbHRlckRyb3Bkb3duQ29tcG9uZW50IGV4dGVuZHMgRmlsdGVyQmFzZUNvbXBvbmVudCB7XG5cbiAgICBASW5wdXQoKSBpbml0aWFsOiBGaWx0ZXI7XG5cbiAgICBzZWxlY3RlZDogRmlsdGVyO1xuXG4gICAgcmVtb3ZlRmlsdGVyKCk6IHZvaWQge1xuICAgICAgICBzdXBlci5yZW1vdmVGaWx0ZXIodGhpcy5zZWxlY3RlZCk7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWQgPSB0aGlzLmluaXRpYWw7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWQgPSB0aGlzLmluaXRpYWw7XG4gICAgfVxuXG4gICAgc2VsZWN0RmlsdGVyKGZpbHRlcjogRmlsdGVyLCBldmVudDogTW91c2VFdmVudCkge1xuICAgICAgICB0aGlzLnJlbW92ZUZpbHRlcigpO1xuICAgICAgICB0aGlzLnNlbGVjdGVkID0gZmlsdGVyO1xuICAgICAgICB0aGlzLmFkZEZpbHRlcih0aGlzLnNlbGVjdGVkKTtcblxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbn0iLCJpbXBvcnQgeyBMaXZlQW5ub3VuY2VyIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2ExMXknO1xuaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgUGlwZSwgUGlwZVRyYW5zZm9ybSwgVmlld0NoaWxkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBCc0Ryb3Bkb3duRGlyZWN0aXZlIH0gZnJvbSAnbmd4LWJvb3RzdHJhcC9kcm9wZG93bic7XG5pbXBvcnQgeyBUeXBlYWhlYWRNYXRjaCB9IGZyb20gJ25neC1ib290c3RyYXAvdHlwZWFoZWFkJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcbmltcG9ydCB7IFR5cGVhaGVhZEtleVNlcnZpY2UsIFR5cGVhaGVhZE9wdGlvbkV2ZW50IH0gZnJvbSAnLi4vLi4vdHlwZWFoZWFkL2luZGV4JztcbmltcG9ydCB7IEZpbHRlckJhc2VDb21wb25lbnQgfSBmcm9tICcuLi9maWx0ZXItYmFzZS9maWx0ZXItYmFzZS5jb21wb25lbnQnO1xuaW1wb3J0IHsgRmlsdGVyLCBGaWx0ZXJDb250YWluZXJDb21wb25lbnQgfSBmcm9tICcuLi9maWx0ZXItY29udGFpbmVyLmNvbXBvbmVudCc7XG5cbmxldCB1bmlxdWVJZCA9IDE7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtZmlsdGVyLWR5bmFtaWMnLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9maWx0ZXItZHluYW1pYy5jb21wb25lbnQuaHRtbCcsXG4gICAgaG9zdDoge1xuICAgICAgICAnKGRvY3VtZW50OmNsaWNrKSc6ICdjbGlja09mZigkZXZlbnQpJyxcbiAgICB9XG59KVxuZXhwb3J0IGNsYXNzIEZpbHRlckR5bmFtaWNDb21wb25lbnQgZXh0ZW5kcyBGaWx0ZXJCYXNlQ29tcG9uZW50IHtcblxuICAgIEBJbnB1dCgpIGZpbHRlcnM6IEZpbHRlcltdO1xuICAgIEBJbnB1dCgpIGluaXRpYWw6IEZpbHRlcjtcblxuICAgIEBJbnB1dCgpIHNldCBvcHRpb25zKG9wdGlvbnM6IEZpbHRlckR5bmFtaWNMaXN0Q29uZmlnKSB7XG4gICAgICAgIHRoaXMuX2NvbmZpZyA9IHsuLi4gdGhpcy5kZWZhdWx0T3B0aW9ucywgLi4ub3B0aW9ucyB9O1xuICAgIH1cblxuICAgIGdldCBvcHRpb25zKCk6IEZpbHRlckR5bmFtaWNMaXN0Q29uZmlnIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbmZpZztcbiAgICB9XG5cbiAgICBAVmlld0NoaWxkKEJzRHJvcGRvd25EaXJlY3RpdmUpIGRyb3Bkb3duOiBCc0Ryb3Bkb3duRGlyZWN0aXZlO1xuXG4gICAgZGVmYXVsdE9wdGlvbnM6IEZpbHRlckR5bmFtaWNMaXN0Q29uZmlnID0ge1xuICAgICAgICBwbGFjZWhvbGRlcjogJycsXG4gICAgICAgIG1pbkNoYXJhY3RlcnM6IDMsXG4gICAgICAgIG1heFJlc3VsdHM6IEluZmluaXR5XG4gICAgfTtcblxuICAgIHR5cGVhaGVhZElkOiBzdHJpbmcgPSBgdXgtZmlsdGVyLWR5bmFtaWMtdHlwZWFoZWFkLSR7dW5pcXVlSWQrK31gO1xuICAgIHF1ZXJ5JCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8c3RyaW5nPignJyk7XG4gICAgc2VsZWN0ZWQ6IEZpbHRlcjtcbiAgICBzaG93VHlwZWFoZWFkOiBib29sZWFuID0gdHJ1ZTtcbiAgICB0eXBlYWhlYWRJdGVtczogc3RyaW5nW10gPSBbXTtcbiAgICBoaWdobGlnaHRlZEVsZW1lbnQ6IEhUTUxFbGVtZW50O1xuICAgIHR5cGVhaGVhZE9wZW46IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIHByaXZhdGUgX2NvbmZpZzogRmlsdGVyRHluYW1pY0xpc3RDb25maWcgPSB7IC4uLnRoaXMuZGVmYXVsdE9wdGlvbnMgfTtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyB0eXBlYWhlYWRLZXlTZXJ2aWNlOiBUeXBlYWhlYWRLZXlTZXJ2aWNlLCBjb250YWluZXI6IEZpbHRlckNvbnRhaW5lckNvbXBvbmVudCwgYW5ub3VuY2VyOiBMaXZlQW5ub3VuY2VyKSB7XG4gICAgICAgIHN1cGVyKGNvbnRhaW5lciwgYW5ub3VuY2VyKTtcbiAgICB9XG5cbiAgICBnZXRJdGVtcygpOiBzdHJpbmdbXSB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gdGhpcy5xdWVyeSQudmFsdWUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJzLmZpbHRlcihpdGVtID0+IGl0ZW0gIT09IHRoaXMuaW5pdGlhbCAmJiBpdGVtLm5hbWUudG9Mb3dlckNhc2UoKS5pbmRleE9mKHF1ZXJ5KSAhPT0gLTEpXG4gICAgICAgICAgICAubWFwKGl0ZW0gPT4gaXRlbS5uYW1lKVxuICAgICAgICAgICAgLnNsaWNlKDAsIHRoaXMuX2NvbmZpZy5tYXhSZXN1bHRzKTtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9IHRoaXMuaW5pdGlhbDtcbiAgICAgICAgdGhpcy50eXBlYWhlYWRJdGVtcyA9IHRoaXMuZ2V0SXRlbXMoKTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5tYXhJbmRpdmlkdWFsSXRlbXMgJiYgdGhpcy5vcHRpb25zLm1heEluZGl2aWR1YWxJdGVtcyArIDEgPj0gdGhpcy5maWx0ZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5zaG93VHlwZWFoZWFkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxlY3RPcHRpb24odHlwZWFoZWFkT3B0aW9uOiBUeXBlYWhlYWRNYXRjaCkge1xuICAgICAgICB0aGlzLnJlbW92ZUZpbHRlcigpO1xuICAgICAgICBjb25zdCBpZHggPSB0aGlzLmZpbHRlcnMuZmluZEluZGV4KGZpbHRlciA9PiBmaWx0ZXIubmFtZSA9PT0gdHlwZWFoZWFkT3B0aW9uLnZhbHVlKTtcbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9IHRoaXMuZmlsdGVyc1tpZHhdO1xuICAgICAgICB0aGlzLmFkZEZpbHRlcih0aGlzLnNlbGVjdGVkKTtcbiAgICAgICAgdGhpcy5xdWVyeSQubmV4dCgnJyk7XG4gICAgICAgIHRoaXMuZHJvcGRvd24uaGlkZSgpO1xuICAgIH1cblxuICAgIGNsaWNrT2ZmKGV2ZW50OiBNb3VzZUV2ZW50KSB7XG5cbiAgICAgICAgbGV0IHRhcmdldCA9IGV2ZW50LnRhcmdldCBhcyBIVE1MRWxlbWVudDtcbiAgICAgICAgbGV0IGhpZGVEcm9wZG93biA9IHRydWU7XG5cbiAgICAgICAgd2hpbGUgKHRhcmdldCAmJiB0YXJnZXQubm9kZU5hbWUgIT09ICdCT0RZJykge1xuICAgICAgICAgICAgaWYgKHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ3V4LWR5bmFtaWMtZmlsdGVyJykpIHtcbiAgICAgICAgICAgICAgICBoaWRlRHJvcGRvd24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGlkZURyb3Bkb3duKSB7XG4gICAgICAgICAgICB0aGlzLnF1ZXJ5JC5uZXh0KCcnKTtcbiAgICAgICAgICAgIHRoaXMuZHJvcGRvd24uaGlkZSgpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICByZW1vdmVGaWx0ZXIoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkICE9PSB0aGlzLmluaXRpYWwpIHtcbiAgICAgICAgICAgIHN1cGVyLnJlbW92ZUZpbHRlcih0aGlzLnNlbGVjdGVkKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWQgPSB0aGlzLmluaXRpYWw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5xdWVyeSQubmV4dCgnJyk7XG4gICAgfVxuXG4gICAgc2VsZWN0RmlsdGVyKGZpbHRlcjogRmlsdGVyKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRmlsdGVyKCk7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWQgPSBmaWx0ZXI7XG4gICAgICAgIHRoaXMuYWRkRmlsdGVyKHRoaXMuc2VsZWN0ZWQpO1xuICAgIH1cblxuICAgIHVwZGF0ZVR5cGVhaGVhZChxdWVyeTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHRoaXMudHlwZWFoZWFkT3BlbiA9IHF1ZXJ5Lmxlbmd0aCA+PSB0aGlzLl9jb25maWcubWluQ2hhcmFjdGVycztcbiAgICAgICAgdGhpcy50eXBlYWhlYWRJdGVtcyA9IHRoaXMuZ2V0SXRlbXMoKTtcbiAgICB9XG5cbiAgICBzZWxlY3QoZXZlbnQ6IFR5cGVhaGVhZE9wdGlvbkV2ZW50KTogdm9pZCB7XG4gICAgICAgIC8vIGZpbmQgdGhlIGZpbHRlciB3aXRoIHRoZSBtYXRjaGluZyBuYW1lXG4gICAgICAgIGNvbnN0IGZpbHRlciA9IHRoaXMuZmlsdGVycy5maW5kKF9maWx0ZXIgPT4gX2ZpbHRlci5uYW1lID09PSBldmVudC5vcHRpb24pO1xuXG4gICAgICAgIGlmIChmaWx0ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0RmlsdGVyKGZpbHRlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBGaWx0ZXJEeW5hbWljTGlzdENvbmZpZyB7XG4gICAgcGxhY2Vob2xkZXI/OiBzdHJpbmc7XG4gICAgbWluQ2hhcmFjdGVycz86IG51bWJlcjtcbiAgICBtYXhSZXN1bHRzPzogbnVtYmVyO1xuICAgIG1heEluZGl2aWR1YWxJdGVtcz86IG51bWJlcjtcbn1cblxuQFBpcGUoe1xuICAgIG5hbWU6ICdmaWx0ZXJUeXBlYWhlYWRIaWdobGlnaHQnXG59KVxuZXhwb3J0IGNsYXNzIEZpbHRlclR5cGVhaGVhZEhpZ2hsaWdodCBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0ge1xuICAgIHRyYW5zZm9ybSh2YWx1ZTogc3RyaW5nLCBzZWFyY2hRdWVyeTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKHNlYXJjaFF1ZXJ5LCAnaScpO1xuICAgICAgICByZXR1cm4gdmFsdWUucmVwbGFjZShyZWdleCwgYDxiIGNsYXNzPVwiZmlsdGVyLXR5cGVhaGVhZC1oaWdobGlnaHRlZFwiPiR7dmFsdWUubWF0Y2gocmVnZXgpfTwvYj5gKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgQTExeU1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9hMTF5JztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRm9ybXNNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBCc0Ryb3Bkb3duTW9kdWxlIH0gZnJvbSAnbmd4LWJvb3RzdHJhcC9kcm9wZG93bic7XG5pbXBvcnQgeyBNZW51TmF2aWdhdGlvbk1vZHVsZSB9IGZyb20gJy4uLy4uL2RpcmVjdGl2ZXMvbWVudS1uYXZpZ2F0aW9uL2luZGV4JztcbmltcG9ydCB7IFRvb2x0aXBNb2R1bGUgfSBmcm9tICcuLi90b29sdGlwL2luZGV4JztcbmltcG9ydCB7IFR5cGVhaGVhZE1vZHVsZSB9IGZyb20gJy4uL3R5cGVhaGVhZC90eXBlYWhlYWQubW9kdWxlJztcbmltcG9ydCB7IEZpbHRlckJhc2VDb21wb25lbnQgfSBmcm9tICcuL2ZpbHRlci1iYXNlL2ZpbHRlci1iYXNlLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBGaWx0ZXJDb250YWluZXJDb21wb25lbnQgfSBmcm9tICcuL2ZpbHRlci1jb250YWluZXIuY29tcG9uZW50JztcbmltcG9ydCB7IEZpbHRlckRyb3Bkb3duQ29tcG9uZW50IH0gZnJvbSAnLi9maWx0ZXItZHJvcGRvd24vZmlsdGVyLWRyb3Bkb3duLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBGaWx0ZXJEeW5hbWljQ29tcG9uZW50LCBGaWx0ZXJUeXBlYWhlYWRIaWdobGlnaHQgfSBmcm9tICcuL2ZpbHRlci1keW5hbWljL2ZpbHRlci1keW5hbWljLmNvbXBvbmVudCc7XG5cbmNvbnN0IERFQ0xBUkFUSU9OUyA9IFtcbiAgICBGaWx0ZXJCYXNlQ29tcG9uZW50LFxuICAgIEZpbHRlckNvbnRhaW5lckNvbXBvbmVudCxcbiAgICBGaWx0ZXJEcm9wZG93bkNvbXBvbmVudCxcbiAgICBGaWx0ZXJEeW5hbWljQ29tcG9uZW50LFxuICAgIEZpbHRlclR5cGVhaGVhZEhpZ2hsaWdodFxuXTtcblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIEJzRHJvcGRvd25Nb2R1bGUuZm9yUm9vdCgpLFxuICAgICAgICBUb29sdGlwTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgTWVudU5hdmlnYXRpb25Nb2R1bGUsXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgVHlwZWFoZWFkTW9kdWxlLFxuICAgICAgICBBMTF5TW9kdWxlXG4gICAgXSxcbiAgICBleHBvcnRzOiBERUNMQVJBVElPTlMsXG4gICAgZGVjbGFyYXRpb25zOiBERUNMQVJBVElPTlNcbn0pXG5leHBvcnQgY2xhc3MgRmlsdGVyTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBEaXJlY3RpdmUsIEV2ZW50RW1pdHRlciwgSG9zdExpc3RlbmVyLCBJbnB1dCwgT3V0cHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtZmxpcHBhYmxlLWNhcmQnLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9mbGlwcGFibGUtY2FyZC5jb21wb25lbnQuaHRtbCcsXG4gICAgaG9zdDoge1xuICAgICAgICAndGFiaW5kZXgnOiAnMCcsXG4gICAgICAgICdbY2xhc3MuaG9yaXpvbnRhbF0nOiAnZGlyZWN0aW9uID09PSBcImhvcml6b250YWxcIicsXG4gICAgICAgICdbY2xhc3MudmVydGljYWxdJzogJ2RpcmVjdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiJ1xuICAgIH0sXG4gICAgZXhwb3J0QXM6ICd1eC1mbGlwcGFibGUtY2FyZCdcbn0pXG5leHBvcnQgY2xhc3MgRmxpcHBhYmxlQ2FyZENvbXBvbmVudCB7XG5cbiAgICBASW5wdXQoKSBkaXJlY3Rpb246ICdob3Jpem9udGFsJyB8ICd2ZXJ0aWNhbCcgPSAnaG9yaXpvbnRhbCc7XG4gICAgQElucHV0KCkgdHJpZ2dlcjogJ2NsaWNrJyB8ICdob3ZlcicgfCAnbWFudWFsJyA9ICdob3Zlcic7XG4gICAgQElucHV0KCkgd2lkdGg6IG51bWJlciA9IDI4MDtcbiAgICBASW5wdXQoKSBoZWlnaHQ6IG51bWJlciA9IDIwMDtcbiAgICBASW5wdXQoKSBmbGlwcGVkOiBib29sZWFuID0gZmFsc2U7XG4gICAgQE91dHB1dCgpIGZsaXBwZWRDaGFuZ2U6IEV2ZW50RW1pdHRlcjxib29sZWFuPiA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oKTtcblxuICAgIHNldEZsaXBwZWQoc3RhdGU6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5mbGlwcGVkID0gc3RhdGU7XG4gICAgICAgIHRoaXMuZmxpcHBlZENoYW5nZS5lbWl0KHRoaXMuZmxpcHBlZCk7XG4gICAgfVxuXG4gICAgdG9nZ2xlRmxpcHBlZCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zZXRGbGlwcGVkKCF0aGlzLmZsaXBwZWQpO1xuICAgIH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ2NsaWNrJylcbiAgICBjbGlja1RyaWdnZXIoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gYWRkIG9yIHJlbW92ZSB0aGUgY2xhc3MgZGVwZW5kaW5nIG9uIHdoZXRoZXIgb3Igbm90IHRoZSBjYXJkIGhhcyBiZWVuIGZsaXBwZWRcbiAgICAgICAgaWYgKHRoaXMudHJpZ2dlciA9PT0gJ2NsaWNrJykge1xuICAgICAgICAgICAgdGhpcy50b2dnbGVGbGlwcGVkKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBASG9zdExpc3RlbmVyKCdtb3VzZWVudGVyJylcbiAgICBob3ZlckVudGVyKCk6IHZvaWQge1xuICAgICAgICAvLyBpZiB0aGUgdHJpZ2dlciBpcyBob3ZlciB0aGVuIGJlZ2luIHRvIGZsaXBcbiAgICAgICAgaWYgKHRoaXMudHJpZ2dlciA9PT0gJ2hvdmVyJykge1xuICAgICAgICAgICAgdGhpcy5zZXRGbGlwcGVkKHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcignbW91c2VsZWF2ZScpXG4gICAgaG92ZXJFeGl0KCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy50cmlnZ2VyID09PSAnaG92ZXInKSB7XG4gICAgICAgICAgICB0aGlzLnNldEZsaXBwZWQoZmFsc2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcigna2V5ZG93bi5lbnRlcicsIFsnJGV2ZW50J10pXG4gICAgQEhvc3RMaXN0ZW5lcigna2V5ZG93bi5zcGFjZScsIFsnJGV2ZW50J10pXG4gICAgQEhvc3RMaXN0ZW5lcigna2V5ZG93bi5zcGFjZWJhcicsIFsnJGV2ZW50J10pIC8vIElFIHVzZXMgZGlmZmVyZW50IG5hbWluZ1xuICAgIG9uS2V5RG93bihldmVudDogS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy50cmlnZ2VyICE9PSAnbWFudWFsJykge1xuICAgICAgICAgICAgdGhpcy50b2dnbGVGbGlwcGVkKCk7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ3V4LWZsaXBwYWJsZS1jYXJkLWZyb250J1xufSlcbmV4cG9ydCBjbGFzcyBGbGlwcGFibGVDYXJkRnJvbnREaXJlY3RpdmUgeyB9XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAndXgtZmxpcHBhYmxlLWNhcmQtYmFjaydcbn0pXG5leHBvcnQgY2xhc3MgRmxpcHBhYmxlQ2FyZEJhY2tEaXJlY3RpdmUgeyB9IiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgRmxpcHBhYmxlQ2FyZENvbXBvbmVudCwgRmxpcHBhYmxlQ2FyZEJhY2tEaXJlY3RpdmUsIEZsaXBwYWJsZUNhcmRGcm9udERpcmVjdGl2ZSB9IGZyb20gJy4vZmxpcHBhYmxlLWNhcmQuY29tcG9uZW50JztcblxuQE5nTW9kdWxlKHtcbiAgICBleHBvcnRzOiBbRmxpcHBhYmxlQ2FyZENvbXBvbmVudCwgRmxpcHBhYmxlQ2FyZEJhY2tEaXJlY3RpdmUsIEZsaXBwYWJsZUNhcmRGcm9udERpcmVjdGl2ZV0sXG4gICAgZGVjbGFyYXRpb25zOiBbRmxpcHBhYmxlQ2FyZENvbXBvbmVudCwgRmxpcHBhYmxlQ2FyZEJhY2tEaXJlY3RpdmUsIEZsaXBwYWJsZUNhcmRGcm9udERpcmVjdGl2ZV1cbn0pXG5leHBvcnQgY2xhc3MgRmxpcHBhYmxlQ2FyZE1vZHVsZSB7IH1cbiIsImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEZsb2F0aW5nQWN0aW9uQnV0dG9uc1NlcnZpY2Uge1xuXG4gICAgb3BlbiQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+KGZhbHNlKTtcblxuICAgIG9wZW4oKTogdm9pZCB7XG4gICAgICAgIHRoaXMub3BlbiQubmV4dCh0cnVlKTtcbiAgICB9XG5cbiAgICB0b2dnbGUoKTogdm9pZCB7XG4gICAgICAgIHRoaXMub3BlbiQubmV4dCghdGhpcy5vcGVuJC5nZXRWYWx1ZSgpKTtcbiAgICB9XG5cbiAgICBjbG9zZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5vcGVuJC5uZXh0KGZhbHNlKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgYW5pbWF0ZSwgcXVlcnksIHN0YWdnZXIsIHN0eWxlLCB0cmFuc2l0aW9uLCB0cmlnZ2VyIH0gZnJvbSAnQGFuZ3VsYXIvYW5pbWF0aW9ucyc7XG5pbXBvcnQgeyBBZnRlclZpZXdJbml0LCBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgQ29tcG9uZW50LCBDb250ZW50Q2hpbGRyZW4sIEVsZW1lbnRSZWYsIEhvc3RMaXN0ZW5lciwgSW5wdXQsIE9uRGVzdHJveSwgUXVlcnlMaXN0LCBPdXRwdXQsIEV2ZW50RW1pdHRlciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVG9vbHRpcERpcmVjdGl2ZSB9IGZyb20gJ25neC1ib290c3RyYXAvdG9vbHRpcCc7XG5pbXBvcnQgeyBmaWx0ZXIgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBGbG9hdGluZ0FjdGlvbkJ1dHRvbnNTZXJ2aWNlIH0gZnJvbSAnLi9mbG9hdGluZy1hY3Rpb24tYnV0dG9ucy5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1mbG9hdGluZy1hY3Rpb24tYnV0dG9ucycsXG4gICAgdGVtcGxhdGVVcmw6ICcuL2Zsb2F0aW5nLWFjdGlvbi1idXR0b25zLmNvbXBvbmVudC5odG1sJyxcbiAgICBwcm92aWRlcnM6IFtGbG9hdGluZ0FjdGlvbkJ1dHRvbnNTZXJ2aWNlXSxcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICBwcmVzZXJ2ZVdoaXRlc3BhY2VzOiBmYWxzZSxcbiAgICBhbmltYXRpb25zOiBbXG4gICAgICAgIHRyaWdnZXIoJ2ZhYkFuaW1hdGlvbicsIFtcbiAgICAgICAgICAgIHRyYW5zaXRpb24oJ3ZvaWQgPT4gdHJ1ZScsIFtcbiAgICAgICAgICAgICAgICBxdWVyeSgndXgtZmxvYXRpbmctYWN0aW9uLWJ1dHRvbicsIHN0eWxlKHsgb3BhY2l0eTogMCB9KSksXG4gICAgICAgICAgICAgICAgcXVlcnkoJ3V4LWZsb2F0aW5nLWFjdGlvbi1idXR0b24nLCBzdGFnZ2VyKDUwLCBhbmltYXRlKDI1MCwgc3R5bGUoeyBvcGFjaXR5OiAxIH0pKSkpXG4gICAgICAgICAgICBdKSxcbiAgICAgICAgICAgIHRyYW5zaXRpb24oJ3RydWUgPT4gdm9pZCcsIFtcbiAgICAgICAgICAgICAgICBxdWVyeSgndXgtZmxvYXRpbmctYWN0aW9uLWJ1dHRvbicsIHN0YWdnZXIoLTUwLCBhbmltYXRlKDI1MCwgc3R5bGUoeyBvcGFjaXR5OiAwIH0pKSkpXG4gICAgICAgICAgICBdKVxuICAgICAgICBdKVxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgRmxvYXRpbmdBY3Rpb25CdXR0b25zQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCwgT25EZXN0cm95IHtcblxuICAgIEBJbnB1dCgpIGRpcmVjdGlvbjogRmxvYXRpbmdBY3Rpb25CdXR0b25EaXJlY3Rpb24gPSAndG9wJztcbiAgICBAQ29udGVudENoaWxkcmVuKFRvb2x0aXBEaXJlY3RpdmUpIHRvb2x0aXBzOiBRdWVyeUxpc3Q8VG9vbHRpcERpcmVjdGl2ZT47XG4gICAgQE91dHB1dCgpIG9wZW5DaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XG5cbiAgICBwcml2YXRlIF9zdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24oKTtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBmYWI6IEZsb2F0aW5nQWN0aW9uQnV0dG9uc1NlcnZpY2UsIHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYpIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLmFkZCh0aGlzLmZhYi5vcGVuJC5zdWJzY3JpYmUodmFsdWUgPT4gdGhpcy5vcGVuQ2hhbmdlLmVtaXQodmFsdWUpKSk7XG4gICAgfVxuXG4gICAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24uYWRkKHRoaXMuZmFiLm9wZW4kLnBpcGUoZmlsdGVyKG9wZW4gPT4gb3BlbiA9PT0gZmFsc2UpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLnRvb2x0aXBzLmZvckVhY2godG9vbHRpcCA9PiB0b29sdGlwLmhpZGUoKSkpKTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBEZXRlY3QgYW55IGNsaWNrcyB0byB0cmlnZ2VyIGNsb3NlIG9mIHRoZSBtZW51XG4gICAgICovXG4gICAgQEhvc3RMaXN0ZW5lcignZG9jdW1lbnQ6Y2xpY2snLCBbJyRldmVudC50YXJnZXQnXSkgY2xvc2UodGFyZ2V0OiBIVE1MRWxlbWVudCk6IHZvaWQge1xuICAgICAgICBpZiAoIXRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAgICAgICB0aGlzLmZhYi5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgdHlwZSBGbG9hdGluZ0FjdGlvbkJ1dHRvbkRpcmVjdGlvbiA9ICd0b3AnIHwgJ3JpZ2h0JyB8ICdib3R0b20nIHwgJ2xlZnQnOyIsImltcG9ydCB7IEF0dHJpYnV0ZSwgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENvbXBvbmVudCwgSG9zdEJpbmRpbmcsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGbG9hdGluZ0FjdGlvbkJ1dHRvbnNTZXJ2aWNlIH0gZnJvbSAnLi9mbG9hdGluZy1hY3Rpb24tYnV0dG9ucy5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1mbG9hdGluZy1hY3Rpb24tYnV0dG9uJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vZmxvYXRpbmctYWN0aW9uLWJ1dHRvbi5jb21wb25lbnQuaHRtbCcsXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgcHJlc2VydmVXaGl0ZXNwYWNlczogZmFsc2Vcbn0pXG5leHBvcnQgY2xhc3MgRmxvYXRpbmdBY3Rpb25CdXR0b25Db21wb25lbnQge1xuXG4gICAgQElucHV0KCkgaWNvbjogc3RyaW5nO1xuICAgIEBIb3N0QmluZGluZygpIHRhYmluZGV4ID0gMTtcblxuICAgIHByaW1hcnk6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIGNvbnN0cnVjdG9yKEBBdHRyaWJ1dGUoJ2ZhYi1wcmltYXJ5JykgcHJpbWFyeTogc3RyaW5nLCBwdWJsaWMgZmFiOiBGbG9hdGluZ0FjdGlvbkJ1dHRvbnNTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMucHJpbWFyeSA9IHByaW1hcnkgIT09IG51bGw7XG4gICAgfVxufSIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuXG5pbXBvcnQgeyBGbG9hdGluZ0FjdGlvbkJ1dHRvbnNDb21wb25lbnQgfSBmcm9tICcuL2Zsb2F0aW5nLWFjdGlvbi1idXR0b25zLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBGbG9hdGluZ0FjdGlvbkJ1dHRvbkNvbXBvbmVudCB9IGZyb20gJy4vZmxvYXRpbmctYWN0aW9uLWJ1dHRvbi5jb21wb25lbnQnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlXG4gICAgXSxcbiAgICBleHBvcnRzOiBbXG4gICAgICAgIEZsb2F0aW5nQWN0aW9uQnV0dG9uc0NvbXBvbmVudCxcbiAgICAgICAgRmxvYXRpbmdBY3Rpb25CdXR0b25Db21wb25lbnRcbiAgICBdLFxuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBGbG9hdGluZ0FjdGlvbkJ1dHRvbnNDb21wb25lbnQsXG4gICAgICAgIEZsb2F0aW5nQWN0aW9uQnV0dG9uQ29tcG9uZW50XG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBGbG9hdGluZ0FjdGlvbkJ1dHRvbnNNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMvT2JzZXJ2YWJsZSc7XHJcbmltcG9ydCB7IE9ic2VydmVyIH0gZnJvbSAncnhqcy9PYnNlcnZlcic7XHJcbmltcG9ydCB7IG9mIH0gZnJvbSAncnhqcy9vYnNlcnZhYmxlL29mJztcclxuaW1wb3J0IHsgZmlyc3QgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcblxyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBIaWVyYXJjaHlCYXJTZXJ2aWNlIHtcclxuXHJcbiAgICBub2RlcyQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PEhpZXJhcmNoeUJhck5vZGVbXT4oW10pO1xyXG5cclxuICAgIHByaXZhdGUgX3Jvb3Q6IEhpZXJhcmNoeUJhck5vZGU7XHJcbiAgICBwcml2YXRlIF9ub2RlczogSGllcmFyY2h5QmFyTm9kZVtdID0gW107XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdG9yZSB0aGUgcm9vdCBub2RlIG9mIHRoZSBoaWVyYXJjaHkgdHJlZVxyXG4gICAgICovXHJcbiAgICBzZXRSb290Tm9kZShyb290OiBIaWVyYXJjaHlCYXJOb2RlKSB7XHJcblxyXG4gICAgICAgIC8vIHN0b3JlIHRoZSByb290IG5vZGVcclxuICAgICAgICB0aGlzLl9yb290ID0gcm9vdDtcclxuXHJcbiAgICAgICAgLy8gY3JlYXRlIGEgZmxhdCBzdHJ1Y3R1cmUgb2Ygbm9kZXNcclxuICAgICAgICB0aGlzLl9ub2RlcyA9IHRoaXMuZ2V0Tm9kZUxpc3Qocm9vdCk7XHJcblxyXG4gICAgICAgIC8vIGZsYXR0ZW4gdGhlIGFycmF5IC0gYmFzZWQgb24gdGhlIHNlbGVjdGVkIG5vZGVcclxuICAgICAgICB0aGlzLm5vZGVzJC5uZXh0KHRoaXMuZ2V0U2VsZWN0ZWRDaGlsZHJlbihyb290KSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZWxlY3QgYSBub2RlLiBUaGlzIGNhdXNlcyBhbGwgbm9kZXMgdG8gYmVcclxuICAgICAqIGRlc2VsZWN0ZWQgYW5kIHRoZSBwYXRoIHRvIHRoZSBzZWxlY3RlZCBub2RlXHJcbiAgICAgKiB0byBiZSBzZWxlY3RlZFxyXG4gICAgICovXHJcbiAgICBzZWxlY3ROb2RlKG5vZGU6IEhpZXJhcmNoeUJhck5vZGUpOiB2b2lkIHtcclxuXHJcbiAgICAgICAgLy8gZGVzZWxlY3QgYWxsIG5vZGVzXHJcbiAgICAgICAgdGhpcy5kZXNlbGVjdEFsbCgpO1xyXG5cclxuICAgICAgICAvLyBlbnN1cmUgdGhlIGN1cnJlbnQgbm9kZSBpcyBzZWxlY3RlZCBhbmQgaXRzIHBhcmVudHNcclxuICAgICAgICB0aGlzLnNlbGVjdChub2RlKTtcclxuXHJcbiAgICAgICAgLy8gZW1pdCBhIG5ldyBub2RlIGxpc3QgdG8gdHJpZ2dlciBjaGFuZ2UgZGV0ZWN0aW9uXHJcbiAgICAgICAgdGhpcy5ub2RlcyQubmV4dCh0aGlzLmdldFNlbGVjdGVkQ2hpbGRyZW4odGhpcy5fcm9vdCkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogSGFuZGxlcyBnZXR0aW5nIGNoaWxkcmVuIHdpdGggc3VwcG9ydCBmb3IgYm90aCBhcnJheXMgYW5kIG9ic2VydmFibGVzXHJcbiAgICAgKi9cclxuICAgIGdldENoaWxkcmVuKG5vZGU6IEhpZXJhcmNoeUJhck5vZGUpOiBPYnNlcnZhYmxlPEhpZXJhcmNoeUJhck5vZGVDaGlsZHJlbj4ge1xyXG5cclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShub2RlLmNoaWxkcmVuKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gb2YoeyBsb2FkaW5nOiBmYWxzZSwgY2hpbGRyZW46IG5vZGUuY2hpbGRyZW4gfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBjaGlsZHJlbiQ6IE9ic2VydmFibGU8SGllcmFyY2h5QmFyTm9kZVtdPiA9IG5vZGUuY2hpbGRyZW47XHJcblxyXG4gICAgICAgIC8vIGlmIGl0IGlzIGFuIG9ic2VydmFibGUgdGhlbiBoYW5kbGUgbG9hZGluZ1xyXG4gICAgICAgIHJldHVybiBPYnNlcnZhYmxlLmNyZWF0ZSgob2JzZXJ2ZXI6IE9ic2VydmVyPEhpZXJhcmNoeUJhck5vZGVDaGlsZHJlbj4pID0+IHtcclxuICAgICAgICAgICAgLy8gZW1pdCBpbml0aWFsIHZhbHVlXHJcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQoeyBsb2FkaW5nOiB0cnVlLCBjaGlsZHJlbjogW10gfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBub3cgd2FpdCB1bnRpbCB0aGUgY2hpbGRyZW4gb2JzZXJ2YWJsZSBjb21wbGV0ZXNcclxuICAgICAgICAgICAgY2hpbGRyZW4kLnBpcGUoZmlyc3QoKSkuc3Vic2NyaWJlKGNoaWxkcmVuID0+IHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyByZXBsYWNlIHRoZSBvYnNlcnZhYmxlIHdpdGggYW4gYXJyYXkgZm9yIGZ1dHVyZSBsb2FkaW5nXHJcbiAgICAgICAgICAgICAgICBub2RlLmNoaWxkcmVuID0gY2hpbGRyZW47XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gcmVidWlsZCB0aGUgbm9kZSB0cmVlXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFJvb3ROb2RlKHRoaXMuX3Jvb3QpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGVtaXQgdGhlIGxhdGVzdCB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCh7IGxvYWRpbmc6IGZhbHNlLCBjaGlsZHJlbjogY2hpbGRyZW4gfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gY2xvc2UgdGhlIG9ic2VydmFibGUgc3RyZWFtXHJcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRyYXZlcnNlcyBhbGwgdGhlIHBhcmVudHMgdG8gZW5zdXJlIHRoZXkgYXJlIHNlbGVjdGVkXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc2VsZWN0KG5vZGU6IEhpZXJhcmNoeUJhck5vZGUpOiB2b2lkIHtcclxuICAgICAgICBub2RlLnNlbGVjdGVkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgaWYgKG5vZGUucGFyZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0KG5vZGUucGFyZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXNlbGVjdHMgYWxsIG5vZGVzXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgZGVzZWxlY3RBbGwoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fbm9kZXMuZm9yRWFjaChub2RlID0+IG5vZGUuc2VsZWN0ZWQgPSBmYWxzZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGFsbCB0aGUgbm9kZXMgaW4gdGhlIHRyZWUgYXMgYSBmbGF0IGFycmF5LlxyXG4gICAgICogSXQgYWxzbyBzdG9yZXMgdGhlIHBhcmVudCBub2RlIGluIGEgcGFyZW50IHByb3BlcnR5XHJcbiAgICAgKiBvbiB0aGUgbm9kZSBmb3IgZWFzeSB0cmF2ZXJzYWwgaW4gYm90aCBkaXJlY3Rpb25zXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgZ2V0Tm9kZUxpc3Qobm9kZTogSGllcmFyY2h5QmFyTm9kZSk6IEhpZXJhcmNoeUJhck5vZGVbXSB7XHJcblxyXG4gICAgICAgIC8vIGlmIHRoZXJlIGFyZSBubyBjaGlsZHJlbiB0aGVuIHJldHVybiBvbmx5IGl0c2VsZlxyXG4gICAgICAgIGlmICghbm9kZS5jaGlsZHJlbiB8fCBub2RlLmNoaWxkcmVuIGluc3RhbmNlb2YgT2JzZXJ2YWJsZSB8fCBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW25vZGVdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gc3RvcmUgdGhlIHBhcmVudCBwcm9wZXJ0eVxyXG4gICAgICAgIG5vZGUuY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiBjaGlsZC5wYXJlbnQgPSBub2RlKTtcclxuXHJcbiAgICAgICAgLy8gZ2V0IGFsbCBkZXNjZW5kYW50cyBvZiB0aGlzIG5vZGVcclxuICAgICAgICBjb25zdCBkZXNjZW5kYW50cyA9IG5vZGUuY2hpbGRyZW4ucmVkdWNlPEhpZXJhcmNoeUJhck5vZGVbXT4oKG5vZGVzLCBjdXJyZW50KSA9PiBbLi4ubm9kZXMsIC4uLnRoaXMuZ2V0Tm9kZUxpc3QoY3VycmVudCldLCBbXSk7XHJcblxyXG4gICAgICAgIHJldHVybiBbbm9kZSwgLi4uZGVzY2VuZGFudHNdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBhbGwgc2VsZWN0ZWQgbm9kZXMgZnJvbSB0aGUgcGFyZW50IG5vZGUuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgZ2V0U2VsZWN0ZWRDaGlsZHJlbihub2RlOiBIaWVyYXJjaHlCYXJOb2RlKTogSGllcmFyY2h5QmFyTm9kZVtdIHtcclxuXHJcbiAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4gaW5zdGFuY2VvZiBPYnNlcnZhYmxlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbbm9kZV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBnZXQgdGhlIGNoaWxkcmVuIC0gYW5kIGFjY291bnQgZm9yIHdoZW4gdGhlcmUgaXMgbm9uZVxyXG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlbiB8fCBbXTtcclxuXHJcbiAgICAgICAgLy8gY2hlY2sgaWYgYW55IGNoaWxkIGlzIHNlbGVjdGVkXHJcbiAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbi5maW5kKF9jaGlsZCA9PiBfY2hpbGQuc2VsZWN0ZWQpO1xyXG5cclxuICAgICAgICAvLyByZXR1cm4gdGhlIHJlbWFpbmluZyBjaGFpbiBvZiBzZWxlY3RlZCBpdGVtc1xyXG4gICAgICAgIHJldHVybiBjaGlsZCA/IFtub2RlLCAuLi50aGlzLmdldFNlbGVjdGVkQ2hpbGRyZW4oY2hpbGQpXSA6IFtub2RlXTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBIaWVyYXJjaHlCYXJOb2RlIHtcclxuICAgIGljb24/OiBzdHJpbmc7XHJcbiAgICB0aXRsZTogc3RyaW5nO1xyXG4gICAgc2VsZWN0ZWQ/OiBib29sZWFuO1xyXG4gICAgcGFyZW50PzogSGllcmFyY2h5QmFyTm9kZTtcclxuICAgIGNoaWxkcmVuPzogSGllcmFyY2h5QmFyTm9kZVtdIHwgT2JzZXJ2YWJsZTxIaWVyYXJjaHlCYXJOb2RlW10+O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEhpZXJhcmNoeUJhck5vZGVDaGlsZHJlbiB7XHJcbiAgICBsb2FkaW5nOiBib29sZWFuO1xyXG4gICAgY2hpbGRyZW46IEhpZXJhcmNoeUJhck5vZGVbXTtcclxufSIsImltcG9ydCB7IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDb21wb25lbnQsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE9uRGVzdHJveSwgT3V0cHV0LCBRdWVyeUxpc3QsIFRlbXBsYXRlUmVmLCBWaWV3Q2hpbGQsIFZpZXdDaGlsZHJlbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QgfSBmcm9tICdyeGpzL0JlaGF2aW9yU3ViamVjdCc7XHJcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcclxuaW1wb3J0IHsgZGVib3VuY2VUaW1lIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG5pbXBvcnQgeyBIaWVyYXJjaHlCYXJOb2RlLCBIaWVyYXJjaHlCYXJTZXJ2aWNlIH0gZnJvbSAnLi9oaWVyYXJjaHktYmFyLnNlcnZpY2UnO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgICBzZWxlY3RvcjogJ3V4LWhpZXJhcmNoeS1iYXInLFxyXG4gICAgdGVtcGxhdGVVcmw6ICcuL2hpZXJhcmNoeS1iYXIuY29tcG9uZW50Lmh0bWwnLFxyXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXHJcbiAgICB2aWV3UHJvdmlkZXJzOiBbSGllcmFyY2h5QmFyU2VydmljZV1cclxufSlcclxuZXhwb3J0IGNsYXNzIEhpZXJhcmNoeUJhckNvbXBvbmVudCBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XHJcblxyXG4gICAgQElucHV0KCkgc2V0IHJvb3Qobm9kZTogSGllcmFyY2h5QmFyTm9kZSkge1xyXG4gICAgICAgIHRoaXMuaGllcmFyY2h5QmFyLnNldFJvb3ROb2RlKG5vZGUpO1xyXG4gICAgfVxyXG5cclxuICAgIEBJbnB1dCgpIHNldCBzZWxlY3RlZChub2RlOiBIaWVyYXJjaHlCYXJOb2RlKSB7XHJcbiAgICAgICAgdGhpcy5oaWVyYXJjaHlCYXIuc2VsZWN0Tm9kZShub2RlKTtcclxuICAgIH1cclxuXHJcbiAgICBASW5wdXQoKSBsb2FkaW5nSW5kaWNhdG9yOiBUZW1wbGF0ZVJlZjxhbnk+O1xyXG5cclxuICAgIEBPdXRwdXQoKSBzZWxlY3RlZENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8SGllcmFyY2h5QmFyTm9kZT4oKTtcclxuICAgIEBWaWV3Q2hpbGQoJ25vZGVsaXN0Jykgbm9kZWxpc3Q6IEVsZW1lbnRSZWY7XHJcbiAgICBAVmlld0NoaWxkcmVuKCdub2RlRWxlbWVudCcpIG5vZGVzOiBRdWVyeUxpc3Q8RWxlbWVudFJlZj47XHJcblxyXG4gICAgb3ZlcmZsb3ckID0gbmV3IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPihmYWxzZSk7XHJcbiAgICBvdmVyZmxvd05vZGVzJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8SGllcmFyY2h5QmFyTm9kZVtdPihbXSk7XHJcblxyXG4gICAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbigpO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBoaWVyYXJjaHlCYXI6IEhpZXJhcmNoeUJhclNlcnZpY2UpIHtcclxuXHJcbiAgICAgICAgLy8gc3Vic2NyaWJlIHRvIGNoYW5nZXMgaW4gdGhlIHNlbGVjdGVkIG5vZGVcclxuICAgICAgICBjb25zdCBzZWxlY3RlZCA9IGhpZXJhcmNoeUJhci5ub2RlcyQuc3Vic2NyaWJlKG5vZGVzID0+IHRoaXMuc2VsZWN0ZWRDaGFuZ2UuZW1pdChub2Rlcy5sZW5ndGggPT09IDAgPyBudWxsIDogbm9kZXNbbm9kZXMubGVuZ3RoIC0gMV0pKTtcclxuICAgICAgICBjb25zdCBjaGFuZ2VkID0gaGllcmFyY2h5QmFyLm5vZGVzJC5waXBlKGRlYm91bmNlVGltZSgwKSkuc3Vic2NyaWJlKCgpID0+IHRoaXMuc2Nyb2xsSW50b1ZpZXcoKSk7XHJcblxyXG4gICAgICAgIC8vIHN0b3JlIHN1YnNjcmlwdGlvbnNcclxuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24uYWRkKHNlbGVjdGVkKTtcclxuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24uYWRkKGNoYW5nZWQpO1xyXG4gICAgfVxyXG5cclxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hlbiB0aGVyZSBpcyBvdmVyZmxvdyBlbnN1cmUgdGhhdCB0aGUgcmlnaHRtb3N0XHJcbiAgICAgKiBub2RlIHJlbWFpbnMgaW4gdmlldyBhdCBhbGwgdGltZXMuIFRoZSBub2RlcyBubyBsb25nZXJcclxuICAgICAqIHZpc2libGUgYmUgYmUgZGlzcGxheWVkIGluIGEgcG9wb3ZlciBhdmFpbGFibGUgb24gdGhlXHJcbiAgICAgKiBvdmVyZmxvdyBpbmRpY2F0b3JcclxuICAgICAqL1xyXG4gICAgc2Nyb2xsSW50b1ZpZXcoKTogdm9pZCB7XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5ub2RlbGlzdCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBnZXQgdGhlIG5hdGl2ZSBlbGVtZW50XHJcbiAgICAgICAgY29uc3QgeyBuYXRpdmVFbGVtZW50IH0gPSB0aGlzLm5vZGVsaXN0O1xyXG5cclxuICAgICAgICAvLyBlbWl0IHdoZXRoZXIgb3Igbm90IHRoZXJlIGlzIG92ZXJmbG93XHJcbiAgICAgICAgdGhpcy5vdmVyZmxvdyQubmV4dChuYXRpdmVFbGVtZW50LnNjcm9sbFdpZHRoID4gbmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aCk7XHJcblxyXG4gICAgICAgIC8vIGlmIHRoZSBoaWVyYXJjaHkgYmFyIGNvbnRlbnRzIGRvIG5vdCBvdmVyZmxvdyB0aGVuIGRvIG5vdGhpbmdcclxuICAgICAgICBpZiAobmF0aXZlRWxlbWVudC5zY3JvbGxXaWR0aCA+IG5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGgpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIGRldGVybWluZSB0aGUgYW1vdW50IG9mIG92ZXJmbG93XHJcbiAgICAgICAgICAgIGNvbnN0IG92ZXJmbG93QW1vdW50ID0gbmF0aXZlRWxlbWVudC5zY3JvbGxXaWR0aCAtIG5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGg7XHJcblxyXG4gICAgICAgICAgICAvLyBkZXRlcm1pbmUgd2hpY2ggbm9kZXMgYXJlIG5vdCBmdWxseSB2aXNpYmxlXHJcbiAgICAgICAgICAgIHRoaXMub3ZlcmZsb3dOb2RlcyQubmV4dChcclxuICAgICAgICAgICAgICAgIHRoaXMubm9kZXMuZmlsdGVyKG5vZGUgPT4gbm9kZS5uYXRpdmVFbGVtZW50Lm9mZnNldExlZnQgPCBvdmVyZmxvd0Ftb3VudClcclxuICAgICAgICAgICAgICAgICAgICAubWFwKChub2RlLCBpbmRleCkgPT4gdGhpcy5oaWVyYXJjaHlCYXIubm9kZXMkLnZhbHVlW2luZGV4XSlcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIC8vIG1vdmUgdGhlIHNjcm9sbCBwb3NpdGlvbiB0byBhbHdheXMgc2hvdyB0aGUgbGFzdCBpdG1lXHJcbiAgICAgICAgICAgIHRoaXMubm9kZWxpc3QubmF0aXZlRWxlbWVudC5zY3JvbGxMZWZ0ID0gb3ZlcmZsb3dBbW91bnQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIEhvc3RMaXN0ZW5lciwgT3V0cHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3V4Q2xpY2tPdXRzaWRlXSdcbn0pXG5leHBvcnQgY2xhc3MgQ2xpY2tPdXRzaWRlRGlyZWN0aXZlIHtcblxuICAgIEBPdXRwdXQoKSB1eENsaWNrT3V0c2lkZSA9IG5ldyBFdmVudEVtaXR0ZXI8TW91c2VFdmVudD4oKTtcblxuICAgIC8qKiBPZnRlbiBhIGNsaWNrIGV2ZW50IG1ha2VzIHRoZSBlbGVtZW50IGFwcGVhciAtIGlmIHNvIHdlIGNhbiBlbmQgdXAgY2xvc2luZyBpdCBpbW1lZGlhdGVseSAqL1xuICAgIHByaXZhdGUgX2luaXRpYWxpc2VkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5faW5pdGlhbGlzZWQgPSB0cnVlKTtcbiAgICB9XG5cbiAgICBASG9zdExpc3RlbmVyKCdkb2N1bWVudDpjbGljaycsIFsnJGV2ZW50J10pXG4gICAgY2xpY2soZXZlbnQ6IE1vdXNlRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuX2luaXRpYWxpc2VkICYmIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCAhPT0gZXZlbnQudGFyZ2V0ICYmICF0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuY29udGFpbnMoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgICAgICAgdGhpcy51eENsaWNrT3V0c2lkZS5lbWl0KGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbn0iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ2xpY2tPdXRzaWRlRGlyZWN0aXZlIH0gZnJvbSAnLi9jbGljay1vdXRzaWRlLmRpcmVjdGl2ZSc7XG5cblxuQE5nTW9kdWxlKHtcbiAgICBleHBvcnRzOiBbQ2xpY2tPdXRzaWRlRGlyZWN0aXZlXSxcbiAgICBkZWNsYXJhdGlvbnM6IFtDbGlja091dHNpZGVEaXJlY3RpdmVdXG59KVxuZXhwb3J0IGNsYXNzIENsaWNrT3V0c2lkZU1vZHVsZSB7IH1cbiIsImltcG9ydCB7IENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzL1N1YmplY3QnO1xuaW1wb3J0IHsgVG9vbHRpcENvbXBvbmVudCB9IGZyb20gJy4uL3Rvb2x0aXAvaW5kZXgnO1xuXG5sZXQgdW5pcXVlUG9wb3ZlcklkID0gMDtcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAndXgtcG9wb3ZlcicsXG4gIHRlbXBsYXRlVXJsOiAnLi9wb3BvdmVyLmNvbXBvbmVudC5odG1sJyxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgUG9wb3ZlckNvbXBvbmVudCBleHRlbmRzIFRvb2x0aXBDb21wb25lbnQge1xuXG4gIC8qKiBEZWZpbmUgYSB1bmlxdWUgaWQgZm9yIGVhY2ggcG9wb3ZlciAqL1xuICBpZDogc3RyaW5nID0gYHV4LXBvcG92ZXItJHsrK3VuaXF1ZVBvcG92ZXJJZH1gO1xuXG4gIC8qKiBJZiBzcGVjaWZpZWQgYWxsb3dzIHRoZSBwb3BvdmVyIHRvIHNob3cgYSB0aXRsZSAqL1xuICB0aXRsZTogc3RyaW5nO1xuXG4gIC8qKiBUaGlzIHdpbGwgZW1pdCBhbiBldmVudCBhbnkgdGltZSB0aGUgdXNlciBjbGlja3Mgb3V0c2lkZSB0aGUgcG9wb3ZlciAqL1xuICBjbGlja091dHNpZGUkID0gbmV3IFN1YmplY3Q8TW91c2VFdmVudD4oKTtcblxuICAvKiogVGhpcyB3aWxsIHVwZGF0ZSB0aGUgdGl0bGUgb2YgdGhlIHBvcG92ZXIgYW5kIHRyaWdnZXIgY2hhbmdlIGRldGVjdGlvbiAqL1xuICBzZXRUaXRsZSh0aXRsZTogc3RyaW5nKTogdm9pZCB7XG4gICAgdGhpcy50aXRsZSA9IHRpdGxlO1xuICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICB9XG59IiwiaW1wb3J0IHsgRVNDQVBFIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2tleWNvZGVzJztcbmltcG9ydCB7IE92ZXJsYXlSZWYgfSBmcm9tICdAYW5ndWxhci9jZGsvb3ZlcmxheSc7XG5pbXBvcnQgeyBDb21wb25lbnRQb3J0YWwgfSBmcm9tICdAYW5ndWxhci9jZGsvcG9ydGFsJztcbmltcG9ydCB7IERpcmVjdGl2ZSwgSG9zdEJpbmRpbmcsIElucHV0LCBPbkNoYW5nZXMsIE9uSW5pdCwgU2ltcGxlQ2hhbmdlcywgVGVtcGxhdGVSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGZyb21FdmVudCB9IGZyb20gJ3J4anMvb2JzZXJ2YWJsZS9mcm9tRXZlbnQnO1xuaW1wb3J0IHsgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgVG9vbHRpcERpcmVjdGl2ZSB9IGZyb20gJy4uL3Rvb2x0aXAvaW5kZXgnO1xuaW1wb3J0IHsgUG9wb3ZlckNvbXBvbmVudCB9IGZyb20gJy4vcG9wb3Zlci5jb21wb25lbnQnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1t1eFBvcG92ZXJdJyxcbiAgICBleHBvcnRBczogJ3V4LXBvcG92ZXInXG59KVxuZXhwb3J0IGNsYXNzIFBvcG92ZXJEaXJlY3RpdmUgZXh0ZW5kcyBUb29sdGlwRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBPbkNoYW5nZXMge1xuXG4gICAgLyoqIENvbnRhaW5zIHRoZSBjb250ZW50IG9mIHRoZSBwb3BvdmVyIG9yIGEgVGVtcGxhdGVSZWYgZm9yIG1vcmUgZGV0YWlsZWQgY29udGVudCAqL1xuICAgIEBJbnB1dCgndXhQb3BvdmVyJykgY29udGVudDogc3RyaW5nIHwgVGVtcGxhdGVSZWY8YW55PjtcblxuICAgIC8qKiBPcHRpb25hbGx5IGRpc3BsYXkgYSB0aXRsZSBpbiB0aGUgcG9wb3ZlciAqL1xuICAgIEBJbnB1dCgncG9wb3ZlclRpdGxlJykgdGl0bGU6IHN0cmluZztcblxuICAgIC8qKiBBbGxvdyB0aGUgcG9wb3ZlciB0byBiZSBjb25kaXRpb25hbGx5IGRpc2FibGVkICovXG4gICAgQElucHV0KCdwb3BvdmVyRGlzYWJsZWQnKSBkaXNhYmxlZDogYm9vbGVhbjtcblxuICAgIC8qKiBBbGwgdGhlIHVzZXIgdG8gYWRkIGEgY3VzdG9tIGNsYXNzIHRvIHRoZSBwb3BvdmVyICovXG4gICAgQElucHV0KCdwb3BvdmVyQ2xhc3MnKSBjdXN0b21DbGFzczogc3RyaW5nID0gJyc7XG5cbiAgICAvKiogQWxsIHRoZSB1c2VyIHRvIGFkZCBhIHJvbGUgdG8gdGhlIHBvcG92ZXIgLSBkZWZhdWx0IGlzIHRvb2x0aXAgKi9cbiAgICBASW5wdXQoJ3BvcG92ZXJSb2xlJykgcm9sZTogc3RyaW5nID0gJ3Rvb2x0aXAnO1xuXG4gICAgLyoqIFByb3ZpZGUgdGhlIFRlbXBsYXRlUmVmIGEgY29udGV4dCBvYmplY3QgKi9cbiAgICBASW5wdXQoJ3BvcG92ZXJDb250ZXh0JykgY29udGV4dDogYW55ID0ge307XG5cbiAgICAvKiogRGVsYXkgdGhlIHNob3dpbmcgb2YgdGhlIHBvcG92ZXIgYnkgYSBudW1iZXIgb2YgbWlsaXNlY29uZHMgKi9cbiAgICBASW5wdXQoJ3BvcG92ZXJEZWxheScpIGRlbGF5OiBudW1iZXIgPSAwO1xuXG4gICAgLyoqIFNwZWNpZnkgd2hpY2ggZXZlbnRzIHNob3VsZCBzaG93IHRoZSBwb3BvdmVyICovXG4gICAgQElucHV0KCkgc2hvd1RyaWdnZXJzOiBzdHJpbmdbXSA9IFsnY2xpY2snXTtcblxuICAgIC8qKiBTcGVjaWZ5IHdoaWNoIGV2ZW50cyBzaG91bGQgaGlkZSB0aGUgcG9wb3ZlciAqL1xuICAgIEBJbnB1dCgpIGhpZGVUcmlnZ2Vyczogc3RyaW5nW10gPSBbJ2NsaWNrJywgJ2NsaWNrb3V0c2lkZScsICdlc2NhcGUnXTtcblxuICAgIC8qKiBLZWVwIHRyYWNrIG9mIHRoZSB0b29sdGlwIHZpc2liaWxpdHkgYW5kIHVwZGF0ZSBhcmlhLWV4cGFuZGVkIGF0dHJpYnV0ZSAqL1xuICAgIEBIb3N0QmluZGluZygnYXR0ci5hcmlhLWV4cGFuZGVkJykgaXNWaXNpYmxlOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKiogQSByZWZlcmVuY2UgdG8gdGhlIENESyBwb3J0YWwgY29udGFpbmluZyB0aGUgb3ZlcmxheSAqL1xuICAgIHByb3RlY3RlZCBfcG9ydGFsOiBDb21wb25lbnRQb3J0YWw8UG9wb3ZlckNvbXBvbmVudD47XG5cbiAgICAvKiogQSByZWZlcmVuY2UgdG8gdGhlIGluc3RhbmNlIG9mIHRoZSBwb3BvdmVyIGNvbXBvbmVudCB3aGVuIGNyZWF0ZWQgKi9cbiAgICBwcm90ZWN0ZWQgX2luc3RhbmNlOiBQb3BvdmVyQ29tcG9uZW50O1xuXG4gICAgLyoqIERldGVybWluZSB3aGV0aGVyIG9yIG5vdCBhbiBhcmlhLWRlc2NyaWJlZGJ5IHByb3BlcnR5IG9yaWdpbmFsbHkgZXhpc3RlZCBvbiB0aGUgZWxlbWVudCAqL1xuICAgIHByaXZhdGUgX2FyaWFEZXNjcmliZWRCeTogYm9vbGVhbjtcblxuICAgIC8qKiBJbnRlcm5hbGx5IHN0b3JlIHRoZSB0eXBlIG9mIHRoaXMgY29tcG9uZW50IC0gdXN1YWwgZm9yIGRpc3RpbmN0aW9ucyB3aGVuIGV4dGVuZGluZyB0aGUgdG9vbHRpcCBjbGFzcyAqL1xuICAgIHByb3RlY3RlZCBfdHlwZTogc3RyaW5nID0gJ3BvcG92ZXInO1xuXG4gICAgLyoqIFNldCB1cCB0aGUgdHJpZ2dlcnMgYW5kIGJpbmQgdG8gdGhlIHNob3cvaGlkZSBldmVudHMgdG8ga2VlcCB2aXNpYmlsaXR5IGluIHN5bmMgKi9cbiAgICBuZ09uSW5pdCgpOiB2b2lkIHtcblxuICAgICAgICAvLyBzZXQgdXAgdGhlIGV2ZW50IHRyaWdnZXJzXG4gICAgICAgIGZyb21FdmVudChkb2N1bWVudCwgJ2tleWRvd24nKS5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUodGhpcy5vbktleURvd24uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgaXMgYW4gYXJpYS1kZXNjcmliZWQgYnkgYXR0cmlidXRlXG4gICAgICAgIHRoaXMuX2FyaWFEZXNjcmliZWRCeSA9IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2FyaWEtZGVzY3JpYmVkYnknKTtcblxuICAgICAgICAvLyBzZXQgdXAgdGhlIGRlZmF1bHQgZXZlbnQgdHJpZ2dlcnNcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXZSBuZWVkIHRvIHNlbmQgaW5wdXQgY2hhbmdlcyB0byB0aGUgcG9wb3ZlciBjb21wb25lbnRcbiAgICAgKiBXZSBjYW4ndCB1c2Ugc2V0dGVycyBhcyB0aGV5IG1heSB0cmlnZ2VyIGJlZm9yZSBwb3BvdmVyIGluaXRpYWxpc2VkIGFuZCBjYW4ndCByZXNlbmQgb25jZSBpbml0aWFsaXNlZFxuICAgICAqKi9cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG4gICAgICAgIHN1cGVyLm5nT25DaGFuZ2VzKGNoYW5nZXMpO1xuXG4gICAgICAgIGlmICh0aGlzLl9pbnN0YW5jZSAmJiBjaGFuZ2VzLnRpdGxlKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZS5zZXRUaXRsZShjaGFuZ2VzLnRpdGxlLmN1cnJlbnRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgY3JlYXRlSW5zdGFuY2Uob3ZlcmxheVJlZjogT3ZlcmxheVJlZik6IFBvcG92ZXJDb21wb25lbnQge1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IG92ZXJsYXlSZWYuYXR0YWNoKHRoaXMuX3BvcnRhbCkuaW5zdGFuY2UgYXMgUG9wb3ZlckNvbXBvbmVudDtcblxuICAgICAgICAvLyBzdXBwbHkgdGhlIHRvb2x0aXAgd2l0aCB0aGUgY29ycmVjdCBwcm9wZXJ0aWVzXG4gICAgICAgIGluc3RhbmNlLnNldFRpdGxlKHRoaXMudGl0bGUpO1xuICAgICAgICBpbnN0YW5jZS5zZXRDb250ZW50KHRoaXMuY29udGVudCk7XG4gICAgICAgIGluc3RhbmNlLnNldFBsYWNlbWVudCh0aGlzLnBsYWNlbWVudCk7XG4gICAgICAgIGluc3RhbmNlLnNldENsYXNzKHRoaXMuY3VzdG9tQ2xhc3MpO1xuICAgICAgICBpbnN0YW5jZS5zZXRDb250ZXh0KHRoaXMuY29udGV4dCk7XG4gICAgICAgIGluc3RhbmNlLnNldFJvbGUodGhpcy5yb2xlKTtcblxuICAgICAgICAvLyBVcGRhdGUgdGhlIGFyaWEtZGVzY3JpYmVkYnkgYXR0cmlidXRlXG4gICAgICAgIHRoaXMuc2V0QXJpYURlc2NyaWJlZEJ5KGluc3RhbmNlLmlkKTtcblxuICAgICAgICAvLyBzdWJzY3JpYmUgdG8gdGhlIG91dHNpZGUgY2xpY2sgZXZlbnRcbiAgICAgICAgaW5zdGFuY2UuY2xpY2tPdXRzaWRlJC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUodGhpcy5vbkNsaWNrT3V0c2lkZS5iaW5kKHRoaXMpKTtcblxuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGNyZWF0ZVBvcnRhbCgpOiBDb21wb25lbnRQb3J0YWw8UG9wb3ZlckNvbXBvbmVudD4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9ydGFsIHx8IG5ldyBDb21wb25lbnRQb3J0YWwoUG9wb3ZlckNvbXBvbmVudCwgdGhpcy5fdmlld0NvbnRhaW5lclJlZik7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBvbktleURvd24oZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcblxuICAgICAgICAvLyBpZiB2aXNpYmxlIGFuZCB0aGUgZXNjYXBlIGtleSBpcyBwcmVzc2VkIGFuZCBpdCBpcyBvbmUgb2YgdGhlIGhpZGUgdHJpZ2dlcnNcbiAgICAgICAgaWYgKHRoaXMuaXNWaXNpYmxlICYmIGV2ZW50LmtleUNvZGUgPT09IEVTQ0FQRSAmJiB0aGlzLmluY2x1ZGVzKHRoaXMuaGlkZVRyaWdnZXJzLCAnZXNjYXBlJykpIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBvbkNsaWNrT3V0c2lkZSgpOiB2b2lkIHtcbiAgICAgICAgLy8gaWYgdmlzaWJsZSBhbmQgaXQgaXMgb25lIG9mIHRoZSBoaWRlIHRyaWdnZXJzXG4gICAgICAgIGlmICh0aGlzLmlzVmlzaWJsZSAmJiB0aGlzLmluY2x1ZGVzKHRoaXMuaGlkZVRyaWdnZXJzLCAnY2xpY2tvdXRzaWRlJykpIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIFByb2dyYW1tYXRpY2FsbHkgdXBkYXRlIHRoZSBhcmlhLWRlc2NyaWJlZGJ5IHByb3BlcnR5ICovXG4gICAgcHJvdGVjdGVkIHNldEFyaWFEZXNjcmliZWRCeShpZDogc3RyaW5nIHwgbnVsbCk6IHZvaWQge1xuXG4gICAgICAgIC8vIHdlIG9ubHkgd2FudCB0byBzZXQgdGhlIGFyaWEtZGVzY3JpYmVkYnkgYXR0ciB3aGVuIHRoZSBjb250ZW50IGlzIGEgc3RyaW5nIGFuZCB0aGVyZSB3YXMgbm8gdXNlciBkZWZpbmVkIGF0dHJpYnV0ZSBhbHJlYWR5XG4gICAgICAgIGlmICh0aGlzLl9hcmlhRGVzY3JpYmVkQnkgPT09IGZhbHNlICYmIHR5cGVvZiB0aGlzLmNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBzdXBlci5zZXRBcmlhRGVzY3JpYmVkQnkoaWQpO1xuICAgICAgICB9XG4gICAgfVxuXG59IiwiaW1wb3J0IHsgT2JzZXJ2ZXJzTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL29ic2VydmVycyc7XG5pbXBvcnQgeyBPdmVybGF5TW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL292ZXJsYXknO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDbGlja091dHNpZGVNb2R1bGUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL2NsaWNrLW91dHNpZGUvaW5kZXgnO1xuaW1wb3J0IHsgVG9vbHRpcE1vZHVsZSB9IGZyb20gJy4uL3Rvb2x0aXAvaW5kZXgnO1xuaW1wb3J0IHsgUG9wb3ZlckNvbXBvbmVudCB9IGZyb20gJy4vcG9wb3Zlci5jb21wb25lbnQnO1xuaW1wb3J0IHsgUG9wb3ZlckRpcmVjdGl2ZSB9IGZyb20gJy4vcG9wb3Zlci5kaXJlY3RpdmUnO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbXG4gICAgQ29tbW9uTW9kdWxlLFxuICAgIE92ZXJsYXlNb2R1bGUsXG4gICAgT2JzZXJ2ZXJzTW9kdWxlLFxuICAgIENsaWNrT3V0c2lkZU1vZHVsZSxcbiAgICBUb29sdGlwTW9kdWxlXG4gIF0sXG4gIGV4cG9ydHM6IFtQb3BvdmVyRGlyZWN0aXZlXSxcbiAgZGVjbGFyYXRpb25zOiBbUG9wb3ZlckNvbXBvbmVudCwgUG9wb3ZlckRpcmVjdGl2ZV0sXG4gIGVudHJ5Q29tcG9uZW50czogW1BvcG92ZXJDb21wb25lbnRdXG59KVxuZXhwb3J0IGNsYXNzIFBvcG92ZXJNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZvY3VzSWZNb2R1bGUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL2ZvY3VzLWlmL2luZGV4JztcbmltcG9ydCB7IFJlc2l6ZU1vZHVsZSB9IGZyb20gJy4uLy4uL2RpcmVjdGl2ZXMvcmVzaXplL2luZGV4JztcbmltcG9ydCB7IEhpZXJhcmNoeUJhckNvbXBvbmVudCB9IGZyb20gJy4vaGllcmFyY2h5LWJhci5jb21wb25lbnQnO1xuaW1wb3J0IHsgUG9wb3Zlck1vZHVsZSB9IGZyb20gJy4uL3BvcG92ZXIvaW5kZXgnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBSZXNpemVNb2R1bGUsXG4gICAgICAgIEZvY3VzSWZNb2R1bGUsXG4gICAgICAgIFBvcG92ZXJNb2R1bGVcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtIaWVyYXJjaHlCYXJDb21wb25lbnRdLFxuICAgIGRlY2xhcmF0aW9uczogW0hpZXJhcmNoeUJhckNvbXBvbmVudF0sXG59KVxuZXhwb3J0IGNsYXNzIEhpZXJhcmNoeUJhck1vZHVsZSB7IH1cbiIsImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFNpZGVQYW5lbFNlcnZpY2Uge1xuXG4gICAgb3BlbiQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+KGZhbHNlKTtcblxuICAgIG9wZW4oKSB7XG4gICAgICAgIHRoaXMub3BlbiQubmV4dCh0cnVlKTtcbiAgICB9XG5cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgdGhpcy5vcGVuJC5uZXh0KGZhbHNlKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIEhvc3RCaW5kaW5nLCBIb3N0TGlzdGVuZXIsIElucHV0LCBPbkRlc3Ryb3ksIE9uSW5pdCwgT3V0cHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcbmltcG9ydCB7IFNpZGVQYW5lbFNlcnZpY2UgfSBmcm9tICcuL3NpZGUtcGFuZWwuc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtc2lkZS1wYW5lbCcsXG4gICAgZXhwb3J0QXM6ICd1eC1zaWRlLXBhbmVsJyxcbiAgICB0ZW1wbGF0ZVVybDogJ3NpZGUtcGFuZWwuY29tcG9uZW50Lmh0bWwnLFxuICAgIHByb3ZpZGVyczogW1NpZGVQYW5lbFNlcnZpY2VdLFxuICAgIGhvc3Q6IHtcbiAgICAgICAgJ2NsYXNzJzogJ3V4LXNpZGUtcGFuZWwnXG4gICAgfVxufSlcbmV4cG9ydCBjbGFzcyBTaWRlUGFuZWxDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG5cbiAgICBASW5wdXQoKVxuICAgIEBIb3N0QmluZGluZygnY2xhc3Mub3BlbicpXG4gICAgZ2V0IG9wZW4oKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlcnZpY2Uub3BlbiQudmFsdWU7XG4gICAgfVxuXG4gICAgc2V0IG9wZW4odmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5zZXJ2aWNlLm9wZW4kLm5leHQodmFsdWUpO1xuICAgIH1cblxuICAgIEBJbnB1dCgpXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5pbmxpbmUnKVxuICAgIGlubGluZSA9IGZhbHNlO1xuXG4gICAgQElucHV0KClcbiAgICBhdHRhY2hUbzogJ3dpbmRvdycgfCAnY29udGFpbmVyJyA9ICd3aW5kb3cnO1xuXG4gICAgQElucHV0KClcbiAgICB3aWR0aDogc3RyaW5nIHwgbnVtYmVyID0gJzUwJSc7XG5cbiAgICBASW5wdXQoKVxuICAgIHRvcDogc3RyaW5nIHwgbnVtYmVyID0gJzAnO1xuXG4gICAgQElucHV0KClcbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIuYXJpYS1tb2RhbCcpXG4gICAgbW9kYWwgPSBmYWxzZTtcblxuICAgIEBJbnB1dCgpXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5hbmltYXRlJylcbiAgICBhbmltYXRlID0gZmFsc2U7XG5cbiAgICBASW5wdXQoKVxuICAgIGNsb3NlT25FeHRlcm5hbENsaWNrID0gZmFsc2U7XG5cbiAgICBASW5wdXQoKVxuICAgIGZvY3VzT25TaG93OiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBAT3V0cHV0KClcbiAgICBvcGVuQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG4gICAgZ2V0IHBvc2l0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5pbmxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnc3RhdGljJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hdHRhY2hUbyA9PT0gJ2NvbnRhaW5lcicpIHtcbiAgICAgICAgICAgIHJldHVybiAnYWJzb2x1dGUnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnZml4ZWQnO1xuICAgIH1cblxuICAgIGdldCBjc3NXaWR0aCgpOiBzdHJpbmcge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMud2lkdGggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53aWR0aCA9PT0gMCA/ICcwJyA6IHRoaXMud2lkdGggKyAncHgnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLndpZHRoO1xuICAgIH1cblxuICAgIGdldCBjc3NUb3AoKTogc3RyaW5nIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnRvcCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvcCA9PT0gMCA/ICcwJyA6IHRoaXMudG9wICsgJ3B4JztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50b3A7XG4gICAgfVxuXG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS53aWR0aCcpXG4gICAgZ2V0IGNvbXBvbmVudFdpZHRoKCk6IHN0cmluZyB7XG4gICAgICAgIGlmICh0aGlzLmlubGluZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3BlbiA/IHRoaXMuY3NzV2lkdGggOiAnMCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZ2V0IGhvc3RXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5saW5lID8gJzEwMCUnIDogdGhpcy5jc3NXaWR0aDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX29uRGVzdHJveSA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJvdGVjdGVkIHNlcnZpY2U6IFNpZGVQYW5lbFNlcnZpY2UsXG4gICAgICAgIHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWZcbiAgICApIHsgfVxuXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMuc2VydmljZS5vcGVuJC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUoaXNPcGVuID0+IHRoaXMub3BlbkNoYW5nZS5lbWl0KGlzT3BlbikpO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kubmV4dCgpO1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kuY29tcGxldGUoKTtcbiAgICB9XG5cbiAgICBvcGVuUGFuZWwoKSB7XG4gICAgICAgIHRoaXMuc2VydmljZS5vcGVuKCk7XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcignZG9jdW1lbnQ6a2V5dXAuZXNjYXBlJylcbiAgICBjbG9zZVBhbmVsKCkge1xuICAgICAgICB0aGlzLnNlcnZpY2UuY2xvc2UoKTtcbiAgICB9XG5cbiAgICBASG9zdExpc3RlbmVyKCdkb2N1bWVudDpjbGljaycsIFsnJGV2ZW50J10pXG4gICAgY2xpY2tIYW5kbGVyKGV2ZW50OiBNb3VzZUV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5vcGVuIHx8ICF0aGlzLmNsb3NlT25FeHRlcm5hbENsaWNrKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQgYXMgSFRNTEVsZW1lbnQ7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuY29udGFpbnModGFyZ2V0KSB8fFxuICAgICAgICAgICAgKHRhcmdldCAmJiB0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdtb2RhbC1iYWNrZHJvcCcpKSkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZVBhbmVsKCk7XG4gICAgICAgIH1cbiAgICB9XG59IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBDb250ZW50Q2hpbGQsIERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT25Jbml0LCBPdXRwdXQsIFZpZXdDaGlsZCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgZGlzdGluY3RVbnRpbENoYW5nZWQsIHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFNpZGVQYW5lbENvbXBvbmVudCB9IGZyb20gJy4uL3NpZGUtcGFuZWwvc2lkZS1wYW5lbC5jb21wb25lbnQnO1xuaW1wb3J0IHsgU2lkZVBhbmVsU2VydmljZSB9IGZyb20gJy4uL3NpZGUtcGFuZWwvc2lkZS1wYW5lbC5zZXJ2aWNlJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbdXhJdGVtRGlzcGxheVBhbmVsQ29udGVudF0nXG59KVxuZXhwb3J0IGNsYXNzIEl0ZW1EaXNwbGF5UGFuZWxDb250ZW50RGlyZWN0aXZlIHsgfVxuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1t1eEl0ZW1EaXNwbGF5UGFuZWxGb290ZXJdJ1xufSlcbmV4cG9ydCBjbGFzcyBJdGVtRGlzcGxheVBhbmVsRm9vdGVyRGlyZWN0aXZlIHsgfVxuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LWl0ZW0tZGlzcGxheS1wYW5lbCcsXG4gICAgdGVtcGxhdGVVcmw6ICcuL2l0ZW0tZGlzcGxheS1wYW5lbC5jb21wb25lbnQuaHRtbCcsXG4gICAgcHJvdmlkZXJzOiBbU2lkZVBhbmVsU2VydmljZV0sXG4gICAgaG9zdDoge1xuICAgICAgICAnY2xhc3MnOiAndXgtc2lkZS1wYW5lbCB1eC1pdGVtLWRpc3BsYXktcGFuZWwnXG4gICAgfVxufSlcbmV4cG9ydCBjbGFzcyBJdGVtRGlzcGxheVBhbmVsQ29tcG9uZW50IGV4dGVuZHMgU2lkZVBhbmVsQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcblxuICAgIEBJbnB1dCgpIGhlYWRlcjogc3RyaW5nO1xuXG4gICAgQElucHV0KCkgYm94U2hhZG93OiBib29sZWFuID0gdHJ1ZTtcblxuICAgIEBJbnB1dCgpIGNsb3NlVmlzaWJsZTogYm9vbGVhbiA9IHRydWU7XG5cbiAgICBnZXQgcHJldmVudENsb3NlKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gIXRoaXMuY2xvc2VPbkV4dGVybmFsQ2xpY2s7XG4gICAgfVxuXG4gICAgQElucHV0KClcbiAgICBzZXQgcHJldmVudENsb3NlKHZhbHVlOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuY2xvc2VPbkV4dGVybmFsQ2xpY2sgPSAhdmFsdWU7XG4gICAgfVxuXG4gICAgQElucHV0KCkgc2hhZG93OiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBAT3V0cHV0KCkgdmlzaWJsZUNoYW5nZTogRXZlbnRFbWl0dGVyPGJvb2xlYW4+ID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG4gICAgQENvbnRlbnRDaGlsZChJdGVtRGlzcGxheVBhbmVsRm9vdGVyRGlyZWN0aXZlKSBmb290ZXI6IEl0ZW1EaXNwbGF5UGFuZWxGb290ZXJEaXJlY3RpdmU7XG4gICAgQFZpZXdDaGlsZCgncGFuZWwnKSBwYW5lbDogRWxlbWVudFJlZjtcblxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICogVGl0bGUgdXNlZCBmb3IgYWRkaW5nIHRvb2x0aXBzIGFuZCBzaG91bGRuJ3QgYmUgdXNlZCBhcyBhbiBpbnB1dFxuICAgICAqIGluc3RlYWQgaGVhZGVyIHdpbGwgYmUgdXNlZC4gVGhpcyBpcyBoZXJlIHRvIHN1cHBvcnQgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBvbmx5XG4gICAgICogdGhpcyBwcm9wZXJ0eSBzaG91bGQgbm90IGJlIHVzZWQuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzZXQgdGl0bGUodmFsdWU6IHN0cmluZykge1xuICAgICAgICB0aGlzLmhlYWRlciA9IHZhbHVlO1xuICAgIH1cblxuICAgIGdldCB0aXRsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVhZGVyO1xuICAgIH1cblxuICAgIEBJbnB1dCgpXG4gICAgc2V0IHZpc2libGUodmlzaWJsZTogYm9vbGVhbikge1xuICAgICAgICB0aGlzLm9wZW4gPSB2aXNpYmxlO1xuICAgIH1cblxuICAgIGdldCB2aXNpYmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcGVuO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2U6IFNpZGVQYW5lbFNlcnZpY2UsIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYpIHtcbiAgICAgICAgc3VwZXIoc2VydmljZSwgZWxlbWVudFJlZik7XG5cbiAgICAgICAgdGhpcy5hbmltYXRlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2xvc2VPbkV4dGVybmFsQ2xpY2sgPSB0cnVlO1xuICAgIH1cblxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLnNlcnZpY2Uub3BlbiQucGlwZShkaXN0aW5jdFVudGlsQ2hhbmdlZCgpLCB0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSkuc3Vic2NyaWJlKGlzVmlzaWJsZSA9PiB0aGlzLnZpc2libGVDaGFuZ2UuZW1pdChpc1Zpc2libGUpKTtcbiAgICB9XG5cbiAgICBmb2N1cygpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMucGFuZWwpIHtcbiAgICAgICAgICAgIHRoaXMucGFuZWwubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfVxufSIsImltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRm9jdXNJZk1vZHVsZSB9IGZyb20gJy4uLy4uL2RpcmVjdGl2ZXMvZm9jdXMtaWYvZm9jdXMtaWYubW9kdWxlJztcbmltcG9ydCB7IEl0ZW1EaXNwbGF5UGFuZWxDb21wb25lbnQsIEl0ZW1EaXNwbGF5UGFuZWxDb250ZW50RGlyZWN0aXZlLCBJdGVtRGlzcGxheVBhbmVsRm9vdGVyRGlyZWN0aXZlIH0gZnJvbSAnLi9pdGVtLWRpc3BsYXktcGFuZWwuY29tcG9uZW50JztcblxuY29uc3QgREVDTEFSQVRJT05TID0gW1xuICAgIEl0ZW1EaXNwbGF5UGFuZWxDb21wb25lbnQsXG4gICAgSXRlbURpc3BsYXlQYW5lbENvbnRlbnREaXJlY3RpdmUsXG4gICAgSXRlbURpc3BsYXlQYW5lbEZvb3RlckRpcmVjdGl2ZVxuXTtcblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgRm9jdXNJZk1vZHVsZVxuICAgIF0sXG4gICAgZXhwb3J0czogREVDTEFSQVRJT05TLFxuICAgIGRlY2xhcmF0aW9uczogREVDTEFSQVRJT05TXG59KVxuZXhwb3J0IGNsYXNzIEl0ZW1EaXNwbGF5UGFuZWxNb2R1bGUge30iLCJpbXBvcnQgeyBDb21wb25lbnQsIElucHV0LCBFdmVudEVtaXR0ZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC13aXphcmQtc3RlcCcsXG4gICAgdGVtcGxhdGVVcmw6ICcuL3dpemFyZC1zdGVwLmNvbXBvbmVudC5odG1sJ1xufSlcbmV4cG9ydCBjbGFzcyBXaXphcmRTdGVwQ29tcG9uZW50IHtcbiAgICBcbiAgICBASW5wdXQoKSBoZWFkZXI6IHN0cmluZztcbiAgICBASW5wdXQoKSB2YWxpZDogYm9vbGVhbiA9IHRydWU7XG4gICAgQElucHV0KCkgdmlzaXRlZENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oKTtcblxuICAgIHByaXZhdGUgX2FjdGl2ZTogYm9vbGVhbiA9IGZhbHNlO1xuICAgIHByaXZhdGUgX3Zpc2l0ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIEBJbnB1dCgpIFxuICAgIGdldCB2aXNpdGVkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaXRlZDtcbiAgICB9XG5cbiAgICBzZXQgdmlzaXRlZCh2YWx1ZTogYm9vbGVhbikge1xuICAgICAgICB0aGlzLl92aXNpdGVkID0gdmFsdWU7XG4gICAgICAgIHRoaXMudmlzaXRlZENoYW5nZS5uZXh0KHZhbHVlKTtcbiAgICB9XG5cbiAgICBzZXQgYWN0aXZlKHZhbHVlOiBib29sZWFuKSB7XG4gICAgICAgIFxuICAgICAgICAvLyBzdG9yZSB0aGUgYWN0aXZlIHN0YXRlIG9mIHRoZSBzdGVwXG4gICAgICAgIHRoaXMuX2FjdGl2ZSA9IHZhbHVlO1xuXG4gICAgICAgIC8vIGlmIHRoZSB2YWx1ZSBpcyB0cnVlIHRoZW4gdGhlIHN0ZXAgc2hvdWxkIGFsc28gYmUgbWFya2VkIGFzIHZpc2l0ZWRcbiAgICAgICAgaWYgKHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLnZpc2l0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IGFjdGl2ZSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZTtcbiAgICB9XG5cbn0iLCJpbXBvcnQgeyBBZnRlclZpZXdJbml0LCBDb21wb25lbnQsIENvbnRlbnRDaGlsZHJlbiwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT3V0cHV0LCBRdWVyeUxpc3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFdpemFyZFN0ZXBDb21wb25lbnQgfSBmcm9tICcuL3dpemFyZC1zdGVwLmNvbXBvbmVudCc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtd2l6YXJkJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vd2l6YXJkLmNvbXBvbmVudC5odG1sJyxcbiAgICBob3N0OiB7XG4gICAgICAgICdbY2xhc3NdJzogJ29yaWVudGF0aW9uJ1xuICAgIH1cbn0pXG5leHBvcnQgY2xhc3MgV2l6YXJkQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCB7XG5cbiAgICBwcml2YXRlIF9zdGVwOiBudW1iZXIgPSAwO1xuXG4gICAgQENvbnRlbnRDaGlsZHJlbihXaXphcmRTdGVwQ29tcG9uZW50KSBzdGVwcyA9IG5ldyBRdWVyeUxpc3Q8V2l6YXJkU3RlcENvbXBvbmVudD4oKTtcblxuICAgIEBJbnB1dCgpIG9yaWVudGF0aW9uOiAnaG9yaXpvbnRhbCcgfCAndmVydGljYWwnID0gJ2hvcml6b250YWwnO1xuXG4gICAgQElucHV0KCkgbmV4dFRleHQ6IHN0cmluZyA9ICdOZXh0JztcbiAgICBASW5wdXQoKSBwcmV2aW91c1RleHQ6IHN0cmluZyA9ICdQcmV2aW91cyc7XG4gICAgQElucHV0KCkgY2FuY2VsVGV4dDogc3RyaW5nID0gJ0NhbmNlbCc7XG4gICAgQElucHV0KCkgZmluaXNoVGV4dDogc3RyaW5nID0gJ0ZpbmlzaCc7XG5cbiAgICBASW5wdXQoKSBuZXh0VG9vbHRpcDogc3RyaW5nID0gJ0dvIHRvIHRoZSBuZXh0IHN0ZXAnO1xuICAgIEBJbnB1dCgpIHByZXZpb3VzVG9vbHRpcDogc3RyaW5nID0gJ0dvIHRvIHRoZSBwcmV2aW91cyBzdGVwJztcbiAgICBASW5wdXQoKSBjYW5jZWxUb29sdGlwOiBzdHJpbmcgPSAnQ2FuY2VsIHRoZSB3aXphcmQnO1xuICAgIEBJbnB1dCgpIGZpbmlzaFRvb2x0aXA6IHN0cmluZyA9ICdGaW5pc2ggdGhlIHdpemFyZCc7XG5cbiAgICBASW5wdXQoKSBuZXh0RGlzYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBASW5wdXQoKSBwcmV2aW91c0Rpc2FibGVkOiBib29sZWFuID0gZmFsc2U7XG4gICAgQElucHV0KCkgY2FuY2VsRGlzYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBASW5wdXQoKSBmaW5pc2hEaXNhYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgQElucHV0KCkgbmV4dFZpc2libGU6IGJvb2xlYW4gPSB0cnVlO1xuICAgIEBJbnB1dCgpIHByZXZpb3VzVmlzaWJsZTogYm9vbGVhbiA9IHRydWU7XG4gICAgQElucHV0KCkgY2FuY2VsVmlzaWJsZTogYm9vbGVhbiA9IHRydWU7XG4gICAgQElucHV0KCkgZmluaXNoVmlzaWJsZTogYm9vbGVhbiA9IHRydWU7XG4gICAgQElucHV0KCkgY2FuY2VsQWx3YXlzVmlzaWJsZTogYm9vbGVhbiA9IGZhbHNlO1xuICAgIEBJbnB1dCgpIGZpbmlzaEFsd2F5c1Zpc2libGU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIEBPdXRwdXQoKSBvbk5leHQgPSBuZXcgRXZlbnRFbWl0dGVyPG51bWJlcj4oKTtcbiAgICBAT3V0cHV0KCkgb25QcmV2aW91cyA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyPigpO1xuICAgIEBPdXRwdXQoKSBvbkNhbmNlbCA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcbiAgICBAT3V0cHV0KCkgb25GaW5pc2hpbmcgPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG4gICAgQE91dHB1dCgpIG9uRmluaXNoID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuICAgIEBPdXRwdXQoKSBzdGVwQ2hhbmdpbmcgPSBuZXcgRXZlbnRFbWl0dGVyPFN0ZXBDaGFuZ2luZ0V2ZW50PigpO1xuICAgIEBPdXRwdXQoKSBzdGVwQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxudW1iZXI+KCk7XG5cbiAgICBpbnZhbGlkSW5kaWNhdG9yOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBASW5wdXQoKVxuICAgIGdldCBzdGVwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RlcDtcbiAgICB9XG4gICAgc2V0IHN0ZXAodmFsdWU6IG51bWJlcikge1xuXG4gICAgICAgIC8vIG9ubHkgYWNjZXB0IG51bWJlcnMgYXMgdmFsaWQgb3B0aW9uc1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuXG4gICAgICAgICAgICAvLyBzdG9yZSB0aGUgYWN0aXZlIHN0ZXBcbiAgICAgICAgICAgIHRoaXMuX3N0ZXAgPSB2YWx1ZTtcblxuICAgICAgICAgICAgLy8gdXBkYXRlIHdoaWNoIHN0ZXBzIHNob3VsZCBiZSBhY3RpdmVcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG5cbiAgICAgICAgICAgIC8vIGVtaXQgdGhlIGNoYW5nZSBldmVudFxuICAgICAgICAgICAgdGhpcy5zdGVwQ2hhbmdlLm5leHQodGhpcy5zdGVwKTtcblxuICAgICAgICAgICAgLy8gcmVzZXQgdGhlIGludmFsaWQgc3RhdGVcbiAgICAgICAgICAgIHRoaXMuaW52YWxpZEluZGljYXRvciA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGluaXRpYWxseSBzZXQgdGhlIGNvcnJlY3QgdmlzaWJpbGl0eSBvZiB0aGUgc3RlcHNcbiAgICAgICAgc2V0VGltZW91dCh0aGlzLnVwZGF0ZS5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOYXZpZ2F0ZSB0byB0aGUgbmV4dCBzdGVwXG4gICAgICovXG4gICAgbmV4dCgpOiB2b2lkIHtcblxuICAgICAgICB0aGlzLnN0ZXBDaGFuZ2luZy5uZXh0KG5ldyBTdGVwQ2hhbmdpbmdFdmVudCh0aGlzLnN0ZXAsIHRoaXMuc3RlcCArIDEpKTtcblxuICAgICAgICAvLyBjaGVjayBpZiBjdXJyZW50IHN0ZXAgaXMgaW52YWxpZFxuICAgICAgICBpZiAoIXRoaXMuZ2V0Q3VycmVudFN0ZXAoKS52YWxpZCkge1xuICAgICAgICAgICAgdGhpcy5pbnZhbGlkSW5kaWNhdG9yID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIGlmIHdlIGFyZSBjdXJyZW50bHkgb24gdGhlIGxhc3Qgc3RlcFxuICAgICAgICBpZiAoKHRoaXMuc3RlcCArIDEpIDwgdGhpcy5zdGVwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuc3RlcCsrO1xuXG4gICAgICAgICAgICAvLyBlbWl0IHRoZSBjdXJyZW50IHN0ZXBcbiAgICAgICAgICAgIHRoaXMub25OZXh0Lm5leHQodGhpcy5zdGVwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5hdmlnYXRlIHRvIHRoZSBwcmV2aW91cyBzdGVwXG4gICAgICovXG4gICAgcHJldmlvdXMoKTogdm9pZCB7XG5cbiAgICAgICAgdGhpcy5zdGVwQ2hhbmdpbmcubmV4dChuZXcgU3RlcENoYW5naW5nRXZlbnQodGhpcy5zdGVwLCB0aGlzLnN0ZXAgLSAxKSk7XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgd2UgYXJlIGN1cnJlbnRseSBvbiB0aGUgbGFzdCBzdGVwXG4gICAgICAgIGlmICh0aGlzLnN0ZXAgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnN0ZXAtLTtcblxuICAgICAgICAgICAgLy8gZW1pdCB0aGUgY3VycmVudCBzdGVwXG4gICAgICAgICAgICB0aGlzLm9uUHJldmlvdXMubmV4dCh0aGlzLnN0ZXApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBhY3Rpb25zIHdoZW4gdGhlIGZpbmlzaCBidXR0b24gaXMgY2xpY2tlZFxuICAgICAqL1xuICAgIGZpbmlzaCgpOiBQcm9taXNlPHZvaWQ+IHtcblxuICAgICAgICAvLyBmaXJlcyB3aGVuIHRoZSBmaW5pc2ggYnV0dG9uIGlzIGNsaWNrZWQgYWx3YXlzXG4gICAgICAgIHRoaXMub25GaW5pc2hpbmcubmV4dCgpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGlzIHJlcXVpcmVkIGJlY2F1c2Ugd2UgbmVlZCB0byBlbnN1cmUgY2hhbmdlIGRldGVjdGlvbiBoYXMgcnVuXG4gICAgICAgICAqIHRvIGRldGVybWluZSB3aGV0aGVyIG9yIG5vdCB3ZSBoYXZlIHRoZSBsYXRlc3QgdmFsdWUgZm9yIHRoZSAndmFsaWQnIGlucHV0XG4gICAgICAgICAqIG9uIHRoZSBjdXJyZW50IHN0ZXAuIFVuZm9ydHVuYXRlbHkgd2UgY2FuJ3QgdXNlIENoYW5nZURldGVjdG9yUmVmIGFzIHdlIGFyZSBsb29raW5nIHRvIHJ1blxuICAgICAgICAgKiBvbiBjb250ZW50IGNoaWxkcmVuLCBhbmQgd2UgY2FudCB1c2UgQXBwbGljYXRpb25SZWYudGljaygpIGFzIHRoaXMgZG9lcyBub3Qgd29yayBpbiBhIGh5YnJpZCBhcHAsIGVnLiBvdXIgZG9jc1xuICAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG5cbiAgICAgICAgICAgICAgICAvLyBvbmx5IGZpcmVzIHdoZW4gdGhlIGZpbmlzaCBidXR0b24gaXMgY2xpY2tlZCBhbmQgdGhlIHN0ZXAgaXMgdmFsaWRcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXRDdXJyZW50U3RlcCgpLnZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25GaW5pc2gubmV4dCgpOyAgICAgICAgXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gYWN0aW9ucyB3aGVuIHRoZSBjYW5jZWwgYnV0dG9uIGlzIGNsaWNrZWRcbiAgICAgKi9cbiAgICBjYW5jZWwoKTogdm9pZCB7XG4gICAgICAgIHRoaXMub25DYW5jZWwubmV4dCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgYWN0aXZlIHN0YXRlIG9mIGVhY2ggc3RlcFxuICAgICAqL1xuICAgIHVwZGF0ZSgpOiB2b2lkIHtcbiAgICAgICAgLy8gdXBkYXRlIHdoaWNoIHN0ZXBzIHNob3VsZCBiZSBhY3RpdmVcbiAgICAgICAgdGhpcy5zdGVwcy5mb3JFYWNoKChzdGVwLCBpZHgpID0+IHN0ZXAuYWN0aXZlID0gaWR4ID09PSB0aGlzLnN0ZXApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEp1bXAgdG8gYSBzcGVjaWZpYyBzdGVwIG9ubHkgaWYgdGhlIHN0ZXAgaGFzIHByZXZpb3VzbHkgYmVlbiB2aXNpdGVkXG4gICAgICovXG4gICAgZ290b1N0ZXAoc3RlcDogV2l6YXJkU3RlcENvbXBvbmVudCk6IHZvaWQge1xuICAgICAgICBpZiAoc3RlcC52aXNpdGVkKSB7XG5cbiAgICAgICAgICAgIGNvbnN0IHN0ZXBJbmRleCA9IHRoaXMuc3RlcHMudG9BcnJheSgpLmZpbmRJbmRleChzdHAgPT4gc3RwID09PSBzdGVwKTtcblxuICAgICAgICAgICAgdGhpcy5zdGVwQ2hhbmdpbmcubmV4dChuZXcgU3RlcENoYW5naW5nRXZlbnQodGhpcy5zdGVwLCBzdGVwSW5kZXgpKTtcblxuICAgICAgICAgICAgdGhpcy5zdGVwID0gc3RlcEluZGV4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIGlmIHRoZSBjdXJyZW50IHN0ZXAgaXMgdGhlIGxhc3Qgc3RlcFxuICAgICAqL1xuICAgIGlzTGFzdFN0ZXAoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0ZXAgPT09ICh0aGlzLnN0ZXBzLmxlbmd0aCAtIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2V0IHRoZSB3aXphcmQgLSBnb2VzIHRvIGZpcnN0IHN0ZXAgYW5kIHJlc2V0cyB2aXNpdGVkIHN0YXRlXG4gICAgICovXG4gICAgcmVzZXQoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gbWFyayBhbGwgc3RlcHMgYXMgbm90IHZpc2l0ZWRcbiAgICAgICAgdGhpcy5zdGVwcy5mb3JFYWNoKHN0ZXAgPT4gc3RlcC52aXNpdGVkID0gZmFsc2UpO1xuXG4gICAgICAgIC8vIGdvIHRvIHRoZSBmaXJzdCBzdGVwXG4gICAgICAgIHRoaXMuc3RlcCA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBzdGVwIGF0IHRoZSBjdXJyZW50IGluZGV4XG4gICAgICovXG4gICAgZ2V0Q3VycmVudFN0ZXAoKTogV2l6YXJkU3RlcENvbXBvbmVudCB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFN0ZXBBdEluZGV4KHRoaXMuc3RlcCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgc3RlcCBhdCBhIHNwZWNpZmljIGluZGV4XG4gICAgICovXG4gICAgZ2V0U3RlcEF0SW5kZXgoaW5kZXg6IG51bWJlcik6IFdpemFyZFN0ZXBDb21wb25lbnQge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGVwcy50b0FycmF5KClbaW5kZXhdO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIFN0ZXBDaGFuZ2luZ0V2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZnJvbTogbnVtYmVyLCBwdWJsaWMgdG86IG51bWJlcikgeyB9XG59IiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBXaXphcmRDb21wb25lbnQgfSBmcm9tICcuL3dpemFyZC5jb21wb25lbnQnO1xuaW1wb3J0IHsgV2l6YXJkU3RlcENvbXBvbmVudCB9IGZyb20gJy4vd2l6YXJkLXN0ZXAuY29tcG9uZW50JztcbmltcG9ydCB7IFRvb2x0aXBNb2R1bGUgfSBmcm9tICcuLi90b29sdGlwL2luZGV4JztcblxuY29uc3QgREVDTEFSQVRJT05TID0gW1xuICAgIFdpemFyZENvbXBvbmVudCxcbiAgICBXaXphcmRTdGVwQ29tcG9uZW50XG5dO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBUb29sdGlwTW9kdWxlXG4gICAgXSxcbiAgICBleHBvcnRzOiBERUNMQVJBVElPTlMsXG4gICAgZGVjbGFyYXRpb25zOiBERUNMQVJBVElPTlNcbn0pXG5leHBvcnQgY2xhc3MgV2l6YXJkTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XG5pbXBvcnQgeyBNYXJxdWVlV2l6YXJkU3RlcENvbXBvbmVudCB9IGZyb20gJy4vbWFycXVlZS13aXphcmQtc3RlcC5jb21wb25lbnQnO1xuXG4vKipcbiAqIFRoaXMgc2VydmljZSBpcyByZXF1aXJlZCB0byBwcm92aWRlIGEgZm9ybSBvZiBjb21tdW5pY2F0aW9uXG4gKiBiZXR3ZWVuIHRoZSBtYXJxdWVlIHdpemFyZCBzdGVwcyBhbmQgdGhlIGNvbnRhaW5pbmcgbWFycXVlZSB3aXphcmQuXG4gKiBXZSBjYW5ub3QgaW5qZWN0IHRoZSBIb3N0IGR1ZSB0byB0aGUgc3RlcHMgYmVpbmcgY29udGVudCBjaGlsZHJlbiBcbiAqIHJhdGhlciB0aGFuIHZpZXcgY2hpbGRyZW4uXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBNYXJxdWVlV2l6YXJkU2VydmljZSB7XG4gICAgdmFsaWQkID0gbmV3IFN1YmplY3Q8TWFycXVlZVdpemFyZFZhbGlkRXZlbnQ+KCk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWFycXVlZVdpemFyZFZhbGlkRXZlbnQge1xuICAgIHN0ZXA6IE1hcnF1ZWVXaXphcmRTdGVwQ29tcG9uZW50O1xuICAgIHZhbGlkOiBib29sZWFuO1xufSIsImltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIE91dHB1dCwgRXZlbnRFbWl0dGVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBXaXphcmRTdGVwQ29tcG9uZW50IH0gZnJvbSAnLi4vd2l6YXJkL2luZGV4JztcbmltcG9ydCB7IE1hcnF1ZWVXaXphcmRTZXJ2aWNlIH0gZnJvbSAnLi9tYXJxdWVlLXdpemFyZC5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1tYXJxdWVlLXdpemFyZC1zdGVwJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vbWFycXVlZS13aXphcmQtc3RlcC5jb21wb25lbnQuaHRtbCdcbn0pXG5leHBvcnQgY2xhc3MgTWFycXVlZVdpemFyZFN0ZXBDb21wb25lbnQgZXh0ZW5kcyBXaXphcmRTdGVwQ29tcG9uZW50IHtcblxuICAgIEBJbnB1dCgpIGljb246IHN0cmluZztcbiAgICBASW5wdXQoKSBjb21wbGV0ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBAT3V0cHV0KCkgY29tcGxldGVkQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuICAgIFxuICAgIGdldCB2YWxpZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbGlkO1xuICAgIH1cblxuICAgIHNldCB2YWxpZCh2YWxpZDogYm9vbGVhbikge1xuICAgICAgICB0aGlzLl92YWxpZCA9IHZhbGlkO1xuXG4gICAgICAgIGlmICh0aGlzLl9tYXJxdWVlV2l6YXJkU2VydmljZSkge1xuICAgICAgICAgICAgdGhpcy5fbWFycXVlZVdpemFyZFNlcnZpY2UudmFsaWQkLm5leHQoeyBzdGVwOiB0aGlzLCB2YWxpZDogdmFsaWQgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIF92YWxpZDogYm9vbGVhbiA9IHRydWU7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9tYXJxdWVlV2l6YXJkU2VydmljZTogTWFycXVlZVdpemFyZFNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIGNvbXBsZXRlZCBzdGF0ZSBhbmQgZW1pdCB0aGUgbGF0ZXN0IHZhbHVlXG4gICAgICogQHBhcmFtIGNvbXBsZXRlZCB3aGV0aGVyIG9yIG5vdCB0aGUgc3RlcCBpcyBjb21wbGV0ZWRcbiAgICAgKi9cbiAgICBzZXRDb21wbGV0ZWQoY29tcGxldGVkOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIHRoaXMuY29tcGxldGVkID0gY29tcGxldGVkO1xuICAgICAgICB0aGlzLmNvbXBsZXRlZENoYW5nZS5lbWl0KGNvbXBsZXRlZCk7XG4gICAgfVxufSIsImltcG9ydCB7IENvbXBvbmVudCwgQ29udGVudENoaWxkcmVuLCBJbnB1dCwgUXVlcnlMaXN0LCBUZW1wbGF0ZVJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgZmlsdGVyIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgV2l6YXJkQ29tcG9uZW50IH0gZnJvbSAnLi4vd2l6YXJkL2luZGV4JztcbmltcG9ydCB7IE1hcnF1ZWVXaXphcmRTdGVwQ29tcG9uZW50IH0gZnJvbSAnLi9tYXJxdWVlLXdpemFyZC1zdGVwLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBNYXJxdWVlV2l6YXJkU2VydmljZSwgTWFycXVlZVdpemFyZFZhbGlkRXZlbnQgfSBmcm9tICcuL21hcnF1ZWUtd2l6YXJkLnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LW1hcnF1ZWUtd2l6YXJkJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vbWFycXVlZS13aXphcmQuY29tcG9uZW50Lmh0bWwnLFxuICAgIHByb3ZpZGVyczogWyBNYXJxdWVlV2l6YXJkU2VydmljZSBdXG59KVxuZXhwb3J0IGNsYXNzIE1hcnF1ZWVXaXphcmRDb21wb25lbnQgZXh0ZW5kcyBXaXphcmRDb21wb25lbnQge1xuXG4gICAgQElucHV0KCkgZGVzY3JpcHRpb246IHN0cmluZyB8IFRlbXBsYXRlUmVmPGFueT47XG4gICAgQENvbnRlbnRDaGlsZHJlbihNYXJxdWVlV2l6YXJkU3RlcENvbXBvbmVudCkgc3RlcHMgPSBuZXcgUXVlcnlMaXN0PE1hcnF1ZWVXaXphcmRTdGVwQ29tcG9uZW50PigpO1xuXG4gICAgZ2V0IGlzVGVtcGxhdGUoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlc2NyaXB0aW9uICYmIHRoaXMuZGVzY3JpcHRpb24gaW5zdGFuY2VvZiBUZW1wbGF0ZVJlZjtcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3RvcihtYXJxdWVlV2l6YXJkU2VydmljZTogTWFycXVlZVdpemFyZFNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICBtYXJxdWVlV2l6YXJkU2VydmljZS52YWxpZCQucGlwZShcbiAgICAgICAgICAgIGZpbHRlcigoZXZlbnQ6IE1hcnF1ZWVXaXphcmRWYWxpZEV2ZW50KSA9PiAhZXZlbnQudmFsaWQpXG4gICAgICAgICkuc3Vic2NyaWJlKHRoaXMudmFsaWRDaGFuZ2UuYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSWYgdGhlIGN1cnJlbnQgc3RlcCBpcyB2YWxpZCwgbWFyayBpdCBhc1xuICAgICAqIGNvbXBsZXRlIGFuZCBnbyB0byB0aGUgbmV4dCBzdGVwXG4gICAgICovXG4gICAgbmV4dCgpOiB2b2lkIHtcblxuICAgICAgICAvLyBnZXQgdGhlIGN1cnJlbnQgc3RlcFxuICAgICAgICBjb25zdCBzdGVwID0gdGhpcy5nZXRDdXJyZW50U3RlcCgpIGFzIE1hcnF1ZWVXaXphcmRTdGVwQ29tcG9uZW50O1xuXG4gICAgICAgIGlmIChzdGVwLnZhbGlkKSB7XG4gICAgICAgICAgICBzdXBlci5uZXh0KCk7XG5cbiAgICAgICAgICAgIC8vIG1hcmsgdGhpcyBzdGVwIGFzIGNvbXBsZXRlZFxuICAgICAgICAgICAgc3RlcC5zZXRDb21wbGV0ZWQodHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbWl0IHRoZSBvbkZpbmlzaGluZyBldmVudCBhbmQgaWYgdmFsaWQgdGhlIG9uRmluaXNoIGV2ZW50LlxuICAgICAqIEFsc28gbWFyayB0aGUgZmluYWwgc3RlcCBhcyBjb21wbGV0ZWQgaWYgaXQgaXMgdmFsaWRcbiAgICAgKi9cbiAgICBmaW5pc2goKTogUHJvbWlzZTx2b2lkPiB7XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBjdXJyZW50IHN0ZXBcbiAgICAgICAgY29uc3Qgc3RlcCA9IHRoaXMuZ2V0Q3VycmVudFN0ZXAoKSBhcyBNYXJxdWVlV2l6YXJkU3RlcENvbXBvbmVudDtcblxuICAgICAgICAvLyBjYWxsIHRoZSBvcmlnaW5hbCBmaW5pc2ggZnVuY3Rpb25cbiAgICAgICAgcmV0dXJuIHN1cGVyLmZpbmlzaCgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgLy8gaWYgdGhlIHN0ZXAgaXMgdmFsaWQgaW5kaWNhdGUgdGhhdCBpdCBpcyBub3cgY29tcGxldGVcbiAgICAgICAgICAgIGlmIChzdGVwLnZhbGlkKSB7XG4gICAgICAgICAgICAgICAgc3RlcC5zZXRDb21wbGV0ZWQodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIGEgc3RlcCBpbiB0aGUgd2l6YXJkIGJlY29tZXMgaW52YWxpZCwgYWxsIHN0ZXBzIHNlcXVlbnRpYWxseSBhZnRlclxuICAgICAqIGl0LCBzaG91bGQgYmVjb21lIHVudmlzaXRlZCBhbmQgaW5jb21wbGV0ZVxuICAgICAqL1xuICAgIHZhbGlkQ2hhbmdlKHN0YXRlOiBNYXJxdWVlV2l6YXJkVmFsaWRFdmVudCk6IHZvaWQge1xuXG4gICAgICAgIGNvbnN0IHN0ZXBzID0gdGhpcy5zdGVwcy50b0FycmF5KCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSBzdGVwcy5maW5kSW5kZXgoc3RlcCA9PiBzdGVwID09PSBzdGF0ZS5zdGVwKTtcbiAgICAgICAgY29uc3QgYWZmZWN0ZWQgPSBzdGVwcy5zbGljZShjdXJyZW50KTtcblxuICAgICAgICBhZmZlY3RlZC5mb3JFYWNoKHN0ZXAgPT4ge1xuXG4gICAgICAgICAgICAvLyB0aGUgc3RlcCBzaG91bGQgbm8gbG9uZ2VyIGJlIGNvbXBsZXRlZFxuICAgICAgICAgICAgc3RlcC5jb21wbGV0ZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgLy8gaWYgdGhlIHN0ZXAgaXMgbm90IHRoZSBjdXJyZW50IHN0ZXAgdGhlbiBhbHNvIG1hcmsgaXQgYXMgdW52aXNpdGVkXG4gICAgICAgICAgICBpZiAoc3RlcCAhPT0gc3RhdGUuc3RlcCkge1xuICAgICAgICAgICAgICAgIHN0ZXAudmlzaXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgIH1cbn0iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcblxuaW1wb3J0IHsgV2l6YXJkTW9kdWxlIH0gZnJvbSAnLi4vd2l6YXJkL2luZGV4JztcbmltcG9ydCB7IE1hcnF1ZWVXaXphcmRDb21wb25lbnQgfSBmcm9tICcuL21hcnF1ZWUtd2l6YXJkLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBNYXJxdWVlV2l6YXJkU3RlcENvbXBvbmVudCB9IGZyb20gJy4vbWFycXVlZS13aXphcmQtc3RlcC5jb21wb25lbnQnO1xuaW1wb3J0IHsgVG9vbHRpcE1vZHVsZSB9IGZyb20gJy4uL3Rvb2x0aXAvaW5kZXgnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBXaXphcmRNb2R1bGUsXG4gICAgICAgIFRvb2x0aXBNb2R1bGVcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgTWFycXVlZVdpemFyZENvbXBvbmVudCxcbiAgICAgICAgTWFycXVlZVdpemFyZFN0ZXBDb21wb25lbnRcbiAgICBdLFxuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBNYXJxdWVlV2l6YXJkQ29tcG9uZW50LFxuICAgICAgICBNYXJxdWVlV2l6YXJkU3RlcENvbXBvbmVudFxuICAgIF1cbn0pXG5leHBvcnQgY2xhc3MgTWFycXVlZVdpemFyZE1vZHVsZSB7IH1cbiIsImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzL09ic2VydmFibGUnO1xuaW1wb3J0IHsgY29uY2F0IH0gZnJvbSAncnhqcy9vYnNlcnZhYmxlL2NvbmNhdCc7XG5pbXBvcnQgeyBmcm9tRXZlbnQgfSBmcm9tICdyeGpzL29ic2VydmFibGUvZnJvbUV2ZW50JztcbmltcG9ydCB7IE9ic2VydmVyIH0gZnJvbSAncnhqcy9PYnNlcnZlcic7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBGcmFtZUV4dHJhY3Rpb25TZXJ2aWNlIHtcblxuICAgIHByaXZhdGUgY3JlYXRlVmlkZW9QbGF5ZXIoc291cmNlOiBzdHJpbmcpOiBIVE1MVmlkZW9FbGVtZW50IHtcbiAgICAgICAgbGV0IHZpZGVvUGxheWVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcbiAgICAgICAgdmlkZW9QbGF5ZXIucHJlbG9hZCA9ICdhdXRvJztcbiAgICAgICAgdmlkZW9QbGF5ZXIuc3JjID0gc291cmNlO1xuICAgICAgICByZXR1cm4gdmlkZW9QbGF5ZXI7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmVhdGVDYW52YXMod2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIpOiBIVE1MQ2FudmFzRWxlbWVudCB7XG4gICAgICAgIGxldCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHJldHVybiBjYW52YXM7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnb1RvRnJhbWUodmlkZW9QbGF5ZXI6IEhUTUxWaWRlb0VsZW1lbnQsIHRpbWU6IG51bWJlcik6IE9ic2VydmFibGU8RXZlbnQ+IHtcbiAgICAgICAgdmlkZW9QbGF5ZXIuY3VycmVudFRpbWUgPSB0aW1lO1xuICAgICAgICByZXR1cm4gZnJvbUV2ZW50KHZpZGVvUGxheWVyLCB0aW1lID09PSAwID8gJ2xvYWRlZGRhdGEnIDogJ3NlZWtlZCcpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0VGh1bWJuYWlsKHZpZGVvUGxheWVyOiBIVE1MVmlkZW9FbGVtZW50LCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LCB0aW1lOiBudW1iZXIsIHdpZHRoOiBudW1iZXIgPSAxNjAsIGhlaWdodDogbnVtYmVyID0gOTApOiBPYnNlcnZhYmxlPEV4dHJhY3RlZEZyYW1lPiB7XG5cbiAgICAgICAgcmV0dXJuIE9ic2VydmFibGUuY3JlYXRlKChvYnNlcnZlcjogT2JzZXJ2ZXI8RXh0cmFjdGVkRnJhbWU+KSA9PiB7XG5cbiAgICAgICAgICAgIC8vIGdvIHRvIHNwZWNpZmllZCBmcmFtZVxuICAgICAgICAgICAgbGV0IHN1YnNjcmlwdGlvbiA9IHRoaXMuZ29Ub0ZyYW1lKHZpZGVvUGxheWVyLCB0aW1lKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBpbWFnZSBmcm9tIGN1cnJlbnQgZnJhbWVcbiAgICAgICAgICAgICAgICBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5kcmF3SW1hZ2UodmlkZW9QbGF5ZXIsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLm5leHQoeyBpbWFnZTogY2FudmFzLnRvRGF0YVVSTCgpLCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0LCB0aW1lOiB0aW1lIH0pO1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZ2V0RnJhbWVUaHVtYm5haWwoc291cmNlOiBzdHJpbmcsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyLCB0aW1lOiBudW1iZXIpOiBPYnNlcnZhYmxlPEV4dHJhY3RlZEZyYW1lPiB7XG5cbiAgICAgICAgLy8gY3JlYXRlIHJlcXVpcmVkIGVsZW1lbnRzXG4gICAgICAgIGxldCB2aWRlb1BsYXllciA9IHRoaXMuY3JlYXRlVmlkZW9QbGF5ZXIoc291cmNlKTtcbiAgICAgICAgbGV0IGNhbnZhcyA9IHRoaXMuY3JlYXRlQ2FudmFzKHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAgIGxldCBmcmFtZVN1YnNjcmlwdGlvbiA9IHRoaXMuZ2V0VGh1bWJuYWlsKHZpZGVvUGxheWVyLCBjYW52YXMsIHRpbWUsIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICAgIC8vIGVuc3VyZSB3ZSByZWxlYXNlIG1lbW9yeSBhZnRlciB3ZSBhcmUgZmluaXNoZWRcbiAgICAgICAgZnJhbWVTdWJzY3JpcHRpb24uc3Vic2NyaWJlKG51bGwsIG51bGwsICgpID0+IHtcbiAgICAgICAgICAgIHZpZGVvUGxheWVyID0gbnVsbDtcbiAgICAgICAgICAgIGNhbnZhcyA9IG51bGw7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBmcmFtZVN1YnNjcmlwdGlvbjtcbiAgICB9XG5cbiAgICBnZXRGcmFtZVRodW1ibmFpbHMoc291cmNlOiBzdHJpbmcsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyLCBzdGFydDogbnVtYmVyLCBlbmQ6IG51bWJlciwgc2tpcDogbnVtYmVyID0gNSk6IE9ic2VydmFibGU8RXh0cmFjdGVkRnJhbWU+IHtcblxuICAgICAgICAvLyBjcmVhdGUgcmVxdWlyZWQgZWxlbWVudHNcbiAgICAgICAgbGV0IHZpZGVvUGxheWVyID0gdGhpcy5jcmVhdGVWaWRlb1BsYXllcihzb3VyY2UpO1xuICAgICAgICBsZXQgY2FudmFzID0gdGhpcy5jcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCk7XG5cbiAgICAgICAgcmV0dXJuIE9ic2VydmFibGUuY3JlYXRlKChvYnNlcnZlcjogT2JzZXJ2ZXI8RXh0cmFjdGVkRnJhbWU+KSA9PiB7XG5cbiAgICAgICAgICAgIGZyb21FdmVudCh2aWRlb1BsYXllciwgJ2xvYWRlZG1ldGFkYXRhJykuc3Vic2NyaWJlKCgpID0+IHtcblxuICAgICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgZnJhbWVzIHJlcXVpcmVkXG4gICAgICAgICAgICAgICAgbGV0IGZyYW1lcyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaWR4ID0gc3RhcnQ7IGlkeCA8IGVuZDsgaWR4ICs9IHNraXApIHtcbiAgICAgICAgICAgICAgICAgICAgZnJhbWVzLnB1c2godGhpcy5nZXRUaHVtYm5haWwodmlkZW9QbGF5ZXIsIGNhbnZhcywgaWR4LCB3aWR0aCwgaGVpZ2h0KSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uY2F0KC4uLmZyYW1lcykuc3Vic2NyaWJlKChmcmFtZTogRXh0cmFjdGVkRnJhbWUpID0+IG9ic2VydmVyLm5leHQoZnJhbWUpLCBudWxsLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZpZGVvUGxheWVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIuY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0pO1xuICAgIH1cblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEV4dHJhY3RlZEZyYW1lIHtcbiAgICBpbWFnZTogc3RyaW5nO1xuICAgIHdpZHRoOiBudW1iZXI7XG4gICAgaGVpZ2h0OiBudW1iZXI7XG4gICAgdGltZTogbnVtYmVyO1xufSIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IEZyYW1lRXh0cmFjdGlvblNlcnZpY2UgfSBmcm9tICcuL2ZyYW1lLWV4dHJhY3Rpb24uc2VydmljZSc7XG5cbkBOZ01vZHVsZSh7XG4gICAgcHJvdmlkZXJzOiBbRnJhbWVFeHRyYWN0aW9uU2VydmljZV0sXG59KVxuZXhwb3J0IGNsYXNzIEZyYW1lRXh0cmFjdGlvbk1vZHVsZSB7IH1cbiIsImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzL09ic2VydmFibGUnO1xuaW1wb3J0IHsgZnJvbSB9IGZyb20gJ3J4anMvb2JzZXJ2YWJsZS9mcm9tJztcbmltcG9ydCB7IE9ic2VydmVyIH0gZnJvbSAncnhqcy9PYnNlcnZlcic7XG5pbXBvcnQgeyBSZXBsYXlTdWJqZWN0IH0gZnJvbSAncnhqcy9SZXBsYXlTdWJqZWN0JztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzL1N1YmplY3QnO1xuaW1wb3J0IHsgRXh0cmFjdGVkRnJhbWUsIEZyYW1lRXh0cmFjdGlvblNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9mcmFtZS1leHRyYWN0aW9uL2luZGV4JztcbmltcG9ydCB7IE1lZGlhUGxheWVyVHlwZSB9IGZyb20gJy4vbWVkaWEtcGxheWVyLmNvbXBvbmVudCc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBNZWRpYVBsYXllclNlcnZpY2Uge1xuXG4gICAgc291cmNlOiBzdHJpbmc7XG4gICAgdHlwZTogTWVkaWFQbGF5ZXJUeXBlID0gJ3ZpZGVvJztcbiAgICBsb2FkZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIC8qXG4gICAgICAgIENyZWF0ZSBvYnNlcnZhYmxlcyBmb3IgbWVkaWEgcGxheWVyIGV2ZW50c1xuICAgICovXG4gICAgcGxheWluZzogQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+ID0gbmV3IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPihmYWxzZSk7XG4gICAgaW5pdEV2ZW50OiBSZXBsYXlTdWJqZWN0PGJvb2xlYW4+ID0gbmV3IFJlcGxheVN1YmplY3Q8Ym9vbGVhbj4oKTtcbiAgICBhYm9ydEV2ZW50OiBTdWJqZWN0PHZvaWQ+ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcbiAgICBjYW5QbGF5RXZlbnQ6IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPiA9IG5ldyBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4oZmFsc2UpO1xuICAgIGNhblBsYXlUaHJvdWdoRXZlbnQ6IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPiA9IG5ldyBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4oZmFsc2UpO1xuICAgIGR1cmF0aW9uQ2hhbmdlRXZlbnQ6IFN1YmplY3Q8bnVtYmVyPiA9IG5ldyBTdWJqZWN0PG51bWJlcj4oKTtcbiAgICBlbmRlZEV2ZW50OiBTdWJqZWN0PHZvaWQ+ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcbiAgICBlcnJvckV2ZW50OiBTdWJqZWN0PGFueT4gPSBuZXcgU3ViamVjdDxhbnk+KCk7XG4gICAgbG9hZGVkRGF0YUV2ZW50OiBTdWJqZWN0PGFueT4gPSBuZXcgU3ViamVjdDxhbnk+KCk7XG4gICAgbG9hZGVkTWV0YWRhdGFFdmVudDogU3ViamVjdDxhbnk+ID0gbmV3IFN1YmplY3Q8YW55PigpO1xuICAgIGxvYWRTdGFydEV2ZW50OiBTdWJqZWN0PHZvaWQ+ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcbiAgICBwYXVzZUV2ZW50OiBTdWJqZWN0PHZvaWQ+ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcbiAgICBwbGF5RXZlbnQ6IFN1YmplY3Q8dm9pZD4gPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuICAgIHBsYXlpbmdFdmVudDogU3ViamVjdDxib29sZWFuPiA9IG5ldyBTdWJqZWN0PGJvb2xlYW4+KCk7XG4gICAgcmF0ZUNoYW5nZUV2ZW50OiBTdWJqZWN0PG51bWJlcj4gPSBuZXcgU3ViamVjdDxudW1iZXI+KCk7XG4gICAgc2Vla2VkRXZlbnQ6IFN1YmplY3Q8bnVtYmVyPiA9IG5ldyBTdWJqZWN0PG51bWJlcj4oKTtcbiAgICBzZWVraW5nRXZlbnQ6IFN1YmplY3Q8bnVtYmVyPiA9IG5ldyBTdWJqZWN0PG51bWJlcj4oKTtcbiAgICBzdGFsbGVkRXZlbnQ6IFN1YmplY3Q8dm9pZD4gPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuICAgIHN1c3BlbmRFdmVudDogU3ViamVjdDx2b2lkPiA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG4gICAgdGltZVVwZGF0ZUV2ZW50OiBTdWJqZWN0PG51bWJlcj4gPSBuZXcgU3ViamVjdDxudW1iZXI+KCk7XG4gICAgdm9sdW1lQ2hhbmdlRXZlbnQ6IFN1YmplY3Q8bnVtYmVyPiA9IG5ldyBTdWJqZWN0PG51bWJlcj4oKTtcbiAgICB3YWl0aW5nRXZlbnQ6IFN1YmplY3Q8dm9pZD4gPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuICAgIG1lZGlhQ2xpY2tFdmVudDogU3ViamVjdDxNb3VzZUV2ZW50PiA9IG5ldyBTdWJqZWN0PE1vdXNlRXZlbnQ+KCk7XG4gICAgZnVsbHNjcmVlbkV2ZW50OiBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4gPSBuZXcgQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+KGZhbHNlKTtcbiAgICBxdWlldE1vZGVFdmVudDogQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+ID0gbmV3IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPihmYWxzZSk7XG4gICAgcHJvZ3Jlc3NFdmVudDogT2JzZXJ2YWJsZTxUaW1lUmFuZ2VzPiA9IE9ic2VydmFibGUuY3JlYXRlKChvYnNlcnZlcjogT2JzZXJ2ZXI8VGltZVJhbmdlcz4pID0+IHtcblxuICAgICAgICAvLyByZXBlYXQgdW50aWwgdGhlIHdob2xlIHZpZGVvIGhhcyBmdWxseSBsb2FkZWRcbiAgICAgICAgY29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG5cbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlcmVkID0gdGhpcy5fbWVkaWFQbGF5ZXIuYnVmZmVyZWQgYXMgVGltZVJhbmdlcztcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQoYnVmZmVyZWQpO1xuXG4gICAgICAgICAgICBpZiAoYnVmZmVyZWQubGVuZ3RoID09PSAxICYmIGJ1ZmZlcmVkLnN0YXJ0KDApID09PSAwICYmIGJ1ZmZlcmVkLmVuZCgwKSA9PT0gdGhpcy5kdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDEwMDApO1xuICAgIH0pO1xuXG4gICAgcHJpdmF0ZSBfbWVkaWFQbGF5ZXI6IEhUTUxNZWRpYUVsZW1lbnQ7XG4gICAgcHJpdmF0ZSBfaG9zdEVsZW1lbnQ6IEhUTUxFbGVtZW50O1xuICAgIHByaXZhdGUgX2Z1bGxzY3JlZW46IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBwcml2YXRlIF9xdWlldE1vZGU6IGJvb2xlYW47XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9mcmFtZUV4dHJhY3Rpb25TZXJ2aWNlOiBGcmFtZUV4dHJhY3Rpb25TZXJ2aWNlKSB7IH1cblxuICAgIC8qXG4gICAgICAgIENyZWF0ZSBhbGwgdGhlIGdldHRlcnMgYW5kIHNldHRlcnMgdGhlIGNhbiBiZSB1c2VkIGJ5IG1lZGlhIHBsYXllciBleHRlbnNpb25zXG4gICAgKi9cbiAgICBnZXQgbWVkaWFQbGF5ZXIoKTogSFRNTE1lZGlhRWxlbWVudCB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZWRpYVBsYXllcjtcbiAgICB9XG5cbiAgICBnZXQgcXVpZXRNb2RlKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fcXVpZXRNb2RlO1xuICAgIH1cblxuICAgIHNldCBxdWlldE1vZGUodmFsdWU6IGJvb2xlYW4pIHtcblxuICAgICAgICAvLyBxdWlldCBtb2RlIGNhbm5vdCBiZSBlbmFibGVkIG9uIGF1ZGlvIHBsYXllclxuICAgICAgICBpZiAodGhpcy50eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcXVpZXRNb2RlID0gdmFsdWU7XG4gICAgICAgIHRoaXMucXVpZXRNb2RlRXZlbnQubmV4dCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgZ2V0IG1lZGlhUGxheWVyV2lkdGgoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhUGxheWVyID8gdGhpcy5fbWVkaWFQbGF5ZXIub2Zmc2V0V2lkdGggOiAwO1xuICAgIH1cblxuICAgIGdldCBtZWRpYVBsYXllckhlaWdodCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVkaWFQbGF5ZXIgPyB0aGlzLl9tZWRpYVBsYXllci5vZmZzZXRIZWlnaHQgOiAwO1xuICAgIH1cblxuICAgIGdldCBhdWRpb1RyYWNrcygpOiBBdWRpb1RyYWNrTGlzdCB8IEFycmF5PGFueT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVkaWFQbGF5ZXIgPyB0aGlzLl9tZWRpYVBsYXllci5hdWRpb1RyYWNrcyA6IFtdO1xuICAgIH1cblxuICAgIGdldCBhdXRvcGxheSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhUGxheWVyID8gdGhpcy5fbWVkaWFQbGF5ZXIuYXV0b3BsYXkgOiBmYWxzZTtcbiAgICB9XG4gICAgc2V0IGF1dG9wbGF5KHZhbHVlOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuX21lZGlhUGxheWVyLmF1dG9wbGF5ID0gdmFsdWU7XG4gICAgfVxuXG4gICAgZ2V0IGJ1ZmZlcmVkKCk6IFRpbWVSYW5nZXMge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVkaWFQbGF5ZXIgPyB0aGlzLl9tZWRpYVBsYXllci5idWZmZXJlZCA6IG5ldyBUaW1lUmFuZ2VzKCk7XG4gICAgfVxuXG4gICAgZ2V0IGNyb3NzT3JpZ2luKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZWRpYVBsYXllciA/IHRoaXMuX21lZGlhUGxheWVyLmNyb3NzT3JpZ2luIDogbnVsbDtcbiAgICB9XG4gICAgc2V0IGNyb3NzT3JpZ2luKHZhbHVlOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5fbWVkaWFQbGF5ZXIuY3Jvc3NPcmlnaW4gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBnZXQgY3VycmVudFNyYygpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVkaWFQbGF5ZXIgPyB0aGlzLl9tZWRpYVBsYXllci5jdXJyZW50U3JjIDogbnVsbDtcbiAgICB9XG5cbiAgICBnZXQgY3VycmVudFRpbWUoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhUGxheWVyID8gdGhpcy5fbWVkaWFQbGF5ZXIuY3VycmVudFRpbWUgOiAwO1xuICAgIH1cbiAgICBzZXQgY3VycmVudFRpbWUodmFsdWU6IG51bWJlcikge1xuICAgICAgICB0aGlzLl9tZWRpYVBsYXllci5jdXJyZW50VGltZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIGdldCBkZWZhdWx0TXV0ZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZWRpYVBsYXllciA/IHRoaXMuX21lZGlhUGxheWVyLmRlZmF1bHRNdXRlZCA6IGZhbHNlO1xuICAgIH1cbiAgICBzZXQgZGVmYXVsdE11dGVkKHZhbHVlOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuX21lZGlhUGxheWVyLmRlZmF1bHRNdXRlZCA9IHZhbHVlO1xuICAgIH1cblxuICAgIGdldCBkZWZhdWx0UGxheWJhY2tSYXRlKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZWRpYVBsYXllciA/IHRoaXMuX21lZGlhUGxheWVyLmRlZmF1bHRQbGF5YmFja1JhdGUgOiAxO1xuICAgIH1cbiAgICBzZXQgZGVmYXVsdFBsYXliYWNrUmF0ZSh2YWx1ZTogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX21lZGlhUGxheWVyLmRlZmF1bHRQbGF5YmFja1JhdGUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBnZXQgZHVyYXRpb24oKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhUGxheWVyID8gdGhpcy5fbWVkaWFQbGF5ZXIuZHVyYXRpb24gOiAwO1xuICAgIH1cblxuICAgIGdldCBlbmRlZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhUGxheWVyID8gdGhpcy5fbWVkaWFQbGF5ZXIuZW5kZWQgOiBmYWxzZTtcbiAgICB9XG5cbiAgICBnZXQgbG9vcCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhUGxheWVyID8gdGhpcy5fbWVkaWFQbGF5ZXIubG9vcCA6IGZhbHNlO1xuICAgIH1cbiAgICBzZXQgbG9vcCh2YWx1ZTogYm9vbGVhbikge1xuICAgICAgICB0aGlzLl9tZWRpYVBsYXllci5sb29wID0gdmFsdWU7XG4gICAgfVxuXG4gICAgZ2V0IG11dGVkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVkaWFQbGF5ZXIgPyB0aGlzLl9tZWRpYVBsYXllci5tdXRlZCA6IGZhbHNlO1xuICAgIH1cbiAgICBzZXQgbXV0ZWQodmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5fbWVkaWFQbGF5ZXIubXV0ZWQgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBnZXQgbmV0d29ya1N0YXRlKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZWRpYVBsYXllci5uZXR3b3JrU3RhdGU7XG4gICAgfVxuXG4gICAgZ2V0IHBhdXNlZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhUGxheWVyID8gdGhpcy5fbWVkaWFQbGF5ZXIucGF1c2VkIDogdHJ1ZTtcbiAgICB9XG5cbiAgICBnZXQgcGxheWJhY2tSYXRlKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZWRpYVBsYXllciA/IHRoaXMuX21lZGlhUGxheWVyLnBsYXliYWNrUmF0ZSA6IDE7XG4gICAgfVxuICAgIHNldCBwbGF5YmFja1JhdGUodmFsdWU6IG51bWJlcikge1xuICAgICAgICB0aGlzLl9tZWRpYVBsYXllci5wbGF5YmFja1JhdGUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBnZXQgcGxheWVkKCk6IFRpbWVSYW5nZXMge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVkaWFQbGF5ZXIgPyB0aGlzLl9tZWRpYVBsYXllci5wbGF5ZWQgOiBuZXcgVGltZVJhbmdlcygpO1xuICAgIH1cblxuICAgIGdldCBwcmVsb2FkKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZWRpYVBsYXllciA/IHRoaXMuX21lZGlhUGxheWVyLnByZWxvYWQgOiAnYXV0byc7XG4gICAgfVxuICAgIHNldCBwcmVsb2FkKHZhbHVlOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5fbWVkaWFQbGF5ZXIucHJlbG9hZCA9IHZhbHVlO1xuICAgIH1cblxuICAgIGdldCByZWFkeVN0YXRlKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZWRpYVBsYXllciA/IHRoaXMuX21lZGlhUGxheWVyLnJlYWR5U3RhdGUgOiAwO1xuICAgIH1cblxuICAgIGdldCBzZWVrYWJsZSgpOiBUaW1lUmFuZ2VzIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhUGxheWVyID8gdGhpcy5fbWVkaWFQbGF5ZXIuc2Vla2FibGUgOiBuZXcgVGltZVJhbmdlcygpO1xuICAgIH1cblxuICAgIGdldCBzZWVraW5nKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVkaWFQbGF5ZXIgPyB0aGlzLl9tZWRpYVBsYXllci5zZWVraW5nIDogZmFsc2U7XG4gICAgfVxuXG4gICAgZ2V0IHNyYygpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVkaWFQbGF5ZXIgPyB0aGlzLl9tZWRpYVBsYXllci5zcmMgOiAnJztcbiAgICB9XG4gICAgc2V0IHNyYyh2YWx1ZTogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuX21lZGlhUGxheWVyLnNyYyA9IHZhbHVlO1xuICAgIH1cblxuICAgIGdldCB0ZXh0VHJhY2tzKCk6IEFycmF5PFRleHRUcmFjaz4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVkaWFQbGF5ZXIgPyBBcnJheS5mcm9tKHRoaXMuX21lZGlhUGxheWVyLnRleHRUcmFja3MpIDogW107XG4gICAgfVxuXG4gICAgZ2V0IHZpZGVvVHJhY2tzKCk6IEFycmF5PFZpZGVvVHJhY2s+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhUGxheWVyID8gQXJyYXkuZnJvbSh0aGlzLl9tZWRpYVBsYXllci52aWRlb1RyYWNrcykgOiBbXTtcbiAgICB9XG5cbiAgICBnZXQgdm9sdW1lKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZWRpYVBsYXllciA/IHRoaXMuX21lZGlhUGxheWVyLnZvbHVtZSA6IDE7XG4gICAgfVxuICAgIHNldCB2b2x1bWUodmFsdWU6IG51bWJlcikge1xuICAgICAgICBpZiAodGhpcy5fbWVkaWFQbGF5ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX21lZGlhUGxheWVyLnZvbHVtZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IGZ1bGxzY3JlZW4oKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZWRpYVBsYXllciA/IHRoaXMuX2Z1bGxzY3JlZW4gOiBmYWxzZTtcbiAgICB9XG4gICAgc2V0IGZ1bGxzY3JlZW4odmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5fZnVsbHNjcmVlbiA9IHZhbHVlO1xuICAgICAgICB0aGlzLmZ1bGxzY3JlZW5FdmVudC5uZXh0KHZhbHVlKTtcbiAgICB9XG5cbiAgICBzZXRNZWRpYVBsYXllcihob3N0RWxlbWVudDogSFRNTEVsZW1lbnQsIG1lZGlhUGxheWVyOiBIVE1MTWVkaWFFbGVtZW50KTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2hvc3RFbGVtZW50ID0gaG9zdEVsZW1lbnQ7XG4gICAgICAgIHRoaXMuX21lZGlhUGxheWVyID0gbWVkaWFQbGF5ZXI7XG5cbiAgICAgICAgdGhpcy5pbml0RXZlbnQubmV4dCh0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUb2dnbGUgcGxheWluZyBzdGF0ZVxuICAgICAqL1xuICAgIHRvZ2dsZVBsYXkoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gcHJldmVudCBhbnkgYWN0aW9uIGlzIG5vdCBsb2FkZWRcbiAgICAgICAgaWYgKHRoaXMubG9hZGVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucGF1c2VkKSB7XG4gICAgICAgICAgICB0aGlzLnBsYXkoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0YXJ0cyBwbGF5aW5nIHRoZSBhdWRpby92aWRlb1xuICAgICAqL1xuICAgIHBsYXkoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX21lZGlhUGxheWVyLnBsYXkoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXVzZXMgdGhlIGN1cnJlbnRseSBwbGF5aW5nIGF1ZGlvL3ZpZGVvXG4gICAgICovXG4gICAgcGF1c2UoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX21lZGlhUGxheWVyLnBhdXNlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmUtbG9hZHMgdGhlIGF1ZGlvL3ZpZGVvIGVsZW1lbnRcbiAgICAgKi9cbiAgICBsb2FkKCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9tZWRpYVBsYXllci5sb2FkKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBicm93c2VyIGNhbiBwbGF5IHRoZSBzcGVjaWZpZWQgYXVkaW8vdmlkZW8gdHlwZVxuICAgICAqL1xuICAgIGNhblBsYXlUeXBlKHR5cGU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZWRpYVBsYXllci5jYW5QbGF5VHlwZSh0eXBlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbmV3IHRleHQgdHJhY2sgdG8gdGhlIGF1ZGlvL3ZpZGVvXG4gICAgICovXG4gICAgYWRkVGV4dFRyYWNrKGtpbmQ6ICdzdWJ0aXRsZXMnIHwgJ2NhcHRpb25zJyB8ICdkZXNjcmlwdGlvbnMnIHwgJ2NoYXB0ZXJzJyB8ICdtZXRhZGF0YScsIGxhYmVsOiBzdHJpbmcsIGxhbmd1YWdlOiBzdHJpbmcpOiBUZXh0VHJhY2sge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVkaWFQbGF5ZXIuYWRkVGV4dFRyYWNrKGtpbmQsIGxhYmVsLCBsYW5ndWFnZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXR0ZW1wdCB0byBkaXNwbGF5IG1lZGlhIGluIGZ1bGxzY3JlZW4gbW9kZVxuICAgICAqL1xuICAgIHJlcXVlc3RGdWxsc2NyZWVuKCk6IHZvaWQge1xuXG4gICAgICAgIGlmICh0aGlzLl9ob3N0RWxlbWVudC5yZXF1ZXN0RnVsbHNjcmVlbikge1xuICAgICAgICAgICAgdGhpcy5faG9zdEVsZW1lbnQucmVxdWVzdEZ1bGxzY3JlZW4oKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ob3N0RWxlbWVudC53ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbikge1xuICAgICAgICAgICAgdGhpcy5faG9zdEVsZW1lbnQud2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4oKTtcbiAgICAgICAgfSBlbHNlIGlmICgoPGFueT50aGlzLl9ob3N0RWxlbWVudCkubXNSZXF1ZXN0RnVsbHNjcmVlbikge1xuICAgICAgICAgICAgKDxhbnk+dGhpcy5faG9zdEVsZW1lbnQpLm1zUmVxdWVzdEZ1bGxzY3JlZW4oKTtcbiAgICAgICAgfSBlbHNlIGlmICgoPGFueT50aGlzLl9ob3N0RWxlbWVudCkubW96UmVxdWVzdEZ1bGxTY3JlZW4pIHtcbiAgICAgICAgICAgICg8YW55PnRoaXMuX2hvc3RFbGVtZW50KS5tb3pSZXF1ZXN0RnVsbFNjcmVlbigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhpdCBmdWxsIHNjcmVlbiBtb2RlXG4gICAgICovXG4gICAgZXhpdEZ1bGxzY3JlZW4oKTogdm9pZCB7XG5cbiAgICAgICAgaWYgKCg8YW55PnRoaXMuX2hvc3RFbGVtZW50KS5leGl0RnVsbHNjcmVlbikge1xuICAgICAgICAgICAgZG9jdW1lbnQuZXhpdEZ1bGxzY3JlZW4oKTtcbiAgICAgICAgfSBlbHNlIGlmIChkb2N1bWVudC53ZWJraXRFeGl0RnVsbHNjcmVlbikge1xuICAgICAgICAgICAgZG9jdW1lbnQud2Via2l0RXhpdEZ1bGxzY3JlZW4oKTtcbiAgICAgICAgfSBlbHNlIGlmICgoPGFueT5kb2N1bWVudCkubXNFeGl0RnVsbHNjcmVlbikge1xuICAgICAgICAgICAgKDxhbnk+ZG9jdW1lbnQpLm1zRXhpdEZ1bGxzY3JlZW4oKTtcbiAgICAgICAgfSBlbHNlIGlmICgoPGFueT5kb2N1bWVudCkubW96Q2FuY2VsRnVsbFNjcmVlbikge1xuICAgICAgICAgICAgKDxhbnk+ZG9jdW1lbnQpLm1vekNhbmNlbEZ1bGxTY3JlZW4oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bGxzY3JlZW5DaGFuZ2UoKSB7XG4gICAgICAgIHRoaXMuZnVsbHNjcmVlbiA9ICg8YW55PmRvY3VtZW50KS5mdWxsc2NyZWVuIHx8IGRvY3VtZW50LndlYmtpdElzRnVsbFNjcmVlbiB8fCAoPGFueT5kb2N1bWVudCkubW96RnVsbFNjcmVlbiB8fCAoPGFueT5kb2N1bWVudCkubXNGdWxsc2NyZWVuRWxlbWVudCAhPT0gbnVsbCAmJiAoPGFueT5kb2N1bWVudCkubXNGdWxsc2NyZWVuRWxlbWVudCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmZ1bGxzY3JlZW5FdmVudC5uZXh0KHRoaXMuZnVsbHNjcmVlbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVG9nZ2xlIEZ1bGxzY3JlZW4gU3RhdGVcbiAgICAgKi9cbiAgICB0b2dnbGVGdWxsc2NyZWVuKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5mdWxsc2NyZWVuKSB7XG4gICAgICAgICAgICB0aGlzLmV4aXRGdWxsc2NyZWVuKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RGdWxsc2NyZWVuKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0IHRoZSBmcmFtZXMgZnJvbSB0aGUgdmlkZW9cbiAgICAgKi9cbiAgICBnZXRGcmFtZXMod2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIsIHNraXA6IG51bWJlcik6IE9ic2VydmFibGU8RXh0cmFjdGVkRnJhbWU+IHtcblxuICAgICAgICBpZiAodGhpcy50eXBlID09PSAndmlkZW8nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZnJhbWVFeHRyYWN0aW9uU2VydmljZS5nZXRGcmFtZVRodW1ibmFpbHModGhpcy5zb3VyY2UsIHdpZHRoLCBoZWlnaHQsIDAsIHRoaXMuZHVyYXRpb24sIDEwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmcm9tKFtdKTtcbiAgICB9XG5cbiAgICBoaWRlU3VidGl0bGVUcmFja3MoKTogdm9pZCB7XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLnRleHRUcmFja3MubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICB0aGlzLnRleHRUcmFja3NbaW5kZXhdLm1vZGUgPSAnaGlkZGVuJztcbiAgICAgICAgfVxuICAgIH1cbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE1lZGlhUGxheWVyU2VydmljZSB9IGZyb20gJy4uL21lZGlhLXBsYXllci5zZXJ2aWNlJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbbWVkaWFQbGF5ZXJCYXNlRXh0ZW5zaW9uXSdcbn0pXG5leHBvcnQgY2xhc3MgTWVkaWFQbGF5ZXJCYXNlRXh0ZW5zaW9uRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgbWVkaWFQbGF5ZXJTZXJ2aWNlOiBNZWRpYVBsYXllclNlcnZpY2UpIHsgfVxufSIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb2xvclNlcnZpY2UgfSBmcm9tICcuL2NvbG9yLnNlcnZpY2UnO1xuXG5ATmdNb2R1bGUoe1xuICAgIHByb3ZpZGVyczogW0NvbG9yU2VydmljZV0sXG59KVxuZXhwb3J0IGNsYXNzIENvbG9yU2VydmljZU1vZHVsZSB7IH1cbiIsImltcG9ydCB7IEFmdGVyVmlld0luaXQsIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDaGFuZ2VEZXRlY3RvclJlZiwgQ29tcG9uZW50LCBEb0NoZWNrLCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIElucHV0LCBPbkluaXQsIE91dHB1dCwgVmlld0NoaWxkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb2xvclNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9jb2xvci9pbmRleCc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtc2xpZGVyJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vc2xpZGVyLmNvbXBvbmVudC5odG1sJyxcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxufSlcbmV4cG9ydCBjbGFzcyBTbGlkZXJDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIEFmdGVyVmlld0luaXQsIERvQ2hlY2sge1xuXG4gICAgQElucHV0KCkgdmFsdWU6IFNsaWRlclZhbHVlIHwgbnVtYmVyID0gMDtcbiAgICBASW5wdXQoKSBvcHRpb25zOiBTbGlkZXJPcHRpb25zO1xuICAgIEBPdXRwdXQoKSB2YWx1ZUNoYW5nZTogRXZlbnRFbWl0dGVyPFNsaWRlclZhbHVlIHwgbnVtYmVyPiA9IG5ldyBFdmVudEVtaXR0ZXI8U2xpZGVyVmFsdWUgfCBudW1iZXI+KCk7XG5cbiAgICBAVmlld0NoaWxkKCdsb3dlclRvb2x0aXAnKSBsb3dlclRvb2x0aXA6IEVsZW1lbnRSZWY7XG4gICAgQFZpZXdDaGlsZCgndXBwZXJUb29sdGlwJykgdXBwZXJUb29sdGlwOiBFbGVtZW50UmVmO1xuICAgIEBWaWV3Q2hpbGQoJ3RyYWNrJykgdHJhY2s6IEVsZW1lbnRSZWY7XG5cbiAgICAvLyBzdG9yZSBjdXJyZW50IHZhbHVlcyBmb3IgZGVlcCBjaGFuZ2UgZGV0ZWN0aW9uXG4gICAgcHJpdmF0ZSBfdmFsdWU6IFNsaWRlclZhbHVlIHwgbnVtYmVyO1xuXG4gICAgLy8gZXhwb3NlIGVudW1zIHRvIEFuZ3VsYXIgdmlld1xuICAgIHNsaWRlclR5cGUgPSBTbGlkZXJUeXBlO1xuICAgIHNsaWRlclN0eWxlID0gU2xpZGVyU3R5bGU7XG4gICAgc2xpZGVyU2l6ZSA9IFNsaWRlclNpemU7XG4gICAgc2xpZGVyU25hcCA9IFNsaWRlclNuYXA7XG4gICAgc2xpZGVyVGh1bWIgPSBTbGlkZXJUaHVtYjtcbiAgICBzbGlkZXJUaWNrVHlwZSA9IFNsaWRlclRpY2tUeXBlO1xuICAgIHNsaWRlclRodW1iRXZlbnQgPSBTbGlkZXJUaHVtYkV2ZW50O1xuICAgIHNsaWRlckNhbGxvdXRUcmlnZ2VyID0gU2xpZGVyQ2FsbG91dFRyaWdnZXI7XG5cbiAgICB0cmFja3MgPSB7XG4gICAgICAgIGxvd2VyOiB7XG4gICAgICAgICAgICBzaXplOiAwLFxuICAgICAgICAgICAgY29sb3I6ICcnXG4gICAgICAgIH0sXG4gICAgICAgIG1pZGRsZToge1xuICAgICAgICAgICAgc2l6ZTogMCxcbiAgICAgICAgICAgIGNvbG9yOiAnJ1xuICAgICAgICB9LFxuICAgICAgICB1cHBlcjoge1xuICAgICAgICAgICAgc2l6ZTogMCxcbiAgICAgICAgICAgIGNvbG9yOiAnJ1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRvb2x0aXBzID0ge1xuICAgICAgICBsb3dlcjoge1xuICAgICAgICAgICAgdmlzaWJsZTogZmFsc2UsXG4gICAgICAgICAgICBwb3NpdGlvbjogMCxcbiAgICAgICAgICAgIGxhYmVsOiAnJ1xuICAgICAgICB9LFxuICAgICAgICB1cHBlcjoge1xuICAgICAgICAgICAgdmlzaWJsZTogZmFsc2UsXG4gICAgICAgICAgICBwb3NpdGlvbjogMCxcbiAgICAgICAgICAgIGxhYmVsOiAnJ1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRodW1icyA9IHtcbiAgICAgICAgbG93ZXI6IHtcbiAgICAgICAgICAgIGhvdmVyOiBmYWxzZSxcbiAgICAgICAgICAgIGRyYWc6IGZhbHNlLFxuICAgICAgICAgICAgcG9zaXRpb246IDAsXG4gICAgICAgICAgICBvcmRlcjogMTAwLFxuICAgICAgICAgICAgdmFsdWU6IG51bGwgYXMgbnVtYmVyXG4gICAgICAgIH0sXG4gICAgICAgIHVwcGVyOiB7XG4gICAgICAgICAgICBob3ZlcjogZmFsc2UsXG4gICAgICAgICAgICBkcmFnOiBmYWxzZSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiAwLFxuICAgICAgICAgICAgb3JkZXI6IDEwMSxcbiAgICAgICAgICAgIHZhbHVlOiBudWxsIGFzIG51bWJlclxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIHN0b3JlIGFsbCB0aGUgdGlja3MgdG8gZGlzcGxheVxuICAgIHRpY2tzOiBTbGlkZXJUaWNrW10gPSBbXTtcbiAgICBkZWZhdWx0T3B0aW9uczogU2xpZGVyT3B0aW9ucztcblxuICAgIGNvbnN0cnVjdG9yKGNvbG9yU2VydmljZTogQ29sb3JTZXJ2aWNlLCBwcml2YXRlIF9jaGFuZ2VEZXRlY3RvclJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYpIHtcblxuICAgICAgICAvLyBzZXR1cCBkZWZhdWx0IG9wdGlvbnNcbiAgICAgICAgdGhpcy5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHR5cGU6IFNsaWRlclR5cGUuVmFsdWUsXG4gICAgICAgICAgICBoYW5kbGVzOiB7XG4gICAgICAgICAgICAgICAgc3R5bGU6IFNsaWRlclN0eWxlLkJ1dHRvbixcbiAgICAgICAgICAgICAgICBjYWxsb3V0OiB7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXI6IFNsaWRlckNhbGxvdXRUcmlnZ2VyLk5vbmUsXG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IGNvbG9yU2VydmljZS5nZXRDb2xvcignZ3JleTInKS50b0hleCgpLFxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogJyNmZmYnLFxuICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZXI6ICh2YWx1ZTogbnVtYmVyKTogc3RyaW5nIHwgbnVtYmVyID0+IHZhbHVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBrZXlib2FyZDoge1xuICAgICAgICAgICAgICAgICAgICBtYWpvcjogNSxcbiAgICAgICAgICAgICAgICAgICAgbWlub3I6IDFcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGFyaWE6IHtcbiAgICAgICAgICAgICAgICAgICAgdGh1bWI6ICdTbGlkZXIgdmFsdWUnLFxuICAgICAgICAgICAgICAgICAgICBsb3dlclRodW1iOiAnU2xpZGVyIGxvd2VyIHZhbHVlJyxcbiAgICAgICAgICAgICAgICAgICAgdXBwZXJUaHVtYjogJ1NsaWRlciB1cHBlciB2YWx1ZSdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHJhY2s6IHtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IFNsaWRlclNpemUuV2lkZSxcbiAgICAgICAgICAgICAgICBtaW46IDAsXG4gICAgICAgICAgICAgICAgbWF4OiAxMDAsXG4gICAgICAgICAgICAgICAgdGlja3M6IHtcbiAgICAgICAgICAgICAgICAgICAgc25hcDogU2xpZGVyU25hcC5Ob25lLFxuICAgICAgICAgICAgICAgICAgICBtYWpvcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXBzOiAxMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlcjogKHZhbHVlOiBudW1iZXIpOiBzdHJpbmcgfCBudW1iZXIgPT4gdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgbWlub3I6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGVwczogNSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZXI6ICh2YWx1ZTogbnVtYmVyKTogc3RyaW5nIHwgbnVtYmVyID0+IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNvbG9yczoge1xuICAgICAgICAgICAgICAgICAgICBsb3dlcjogY29sb3JTZXJ2aWNlLmdldENvbG9yKCdncmV5NicpLnRvSGV4KCksXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiBjb2xvclNlcnZpY2UuZ2V0Q29sb3IoJ2FjY2VudCcpLnNldEFscGhhKDAuNzUpLnRvUmdiYSgpLFxuICAgICAgICAgICAgICAgICAgICBoaWdoZXI6IGNvbG9yU2VydmljZS5nZXRDb2xvcignZ3JleTYnKS50b0hleCgpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIG5nT25Jbml0KCk6IHZvaWQge1xuXG4gICAgICAgIHRoaXMudXBkYXRlT3B0aW9ucygpO1xuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlcygpO1xuXG4gICAgICAgIHRoaXMuc2V0VGh1bWJTdGF0ZShTbGlkZXJUaHVtYi5Mb3dlciwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5zZXRUaHVtYlN0YXRlKFNsaWRlclRodW1iLlVwcGVyLCBmYWxzZSwgZmFsc2UpO1xuXG4gICAgICAgIC8vIGVtaXQgdGhlIGluaXRpYWwgdmFsdWVcbiAgICAgICAgdGhpcy52YWx1ZUNoYW5nZS5uZXh0KHRoaXMuY2xvbmUodGhpcy52YWx1ZSkpO1xuICAgIH1cblxuICAgIG5nRG9DaGVjaygpOiB2b2lkIHtcblxuICAgICAgICBpZiAodGhpcy5kZXRlY3RWYWx1ZUNoYW5nZSh0aGlzLnZhbHVlLCB0aGlzLl92YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWVzKCk7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHRoaXMuY2xvbmUodGhpcy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgICAgIC8vIHBlcnNpc3RlbnQgdG9vbHRpcHMgd2lsbCBuZWVkIHBvc2l0aW9uZWQgY29ycmVjdGx5IGF0IHRoaXMgc3RhZ2VcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRvb2x0aXBQb3NpdGlvbihTbGlkZXJUaHVtYi5Mb3dlcik7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRvb2x0aXBQb3NpdGlvbihTbGlkZXJUaHVtYi5VcHBlcik7XG5cbiAgICAgICAgICAgIC8vIG1hcmsgYXMgZGlydHlcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yUmVmLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzbmFwVG9OZWFyZXN0VGljayh0aHVtYjogU2xpZGVyVGh1bWIsIHNuYXBUYXJnZXQ6IFNsaWRlclNuYXAsIGZvcndhcmRzOiBib29sZWFuKTogdm9pZCB7XG5cbiAgICAgICAgLy8gZ2V0IHRoZSB2YWx1ZSBmb3IgdGhlIHRodW1iXG4gICAgICAgIGNvbnN0IHsgdmFsdWUgfSA9IHRoaXMuZ2V0VGh1bWJTdGF0ZSh0aHVtYik7XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBjbG9zZXN0IHRpY2tzIC0gcmVtb3ZlIGFueSB0aWNrIGlmIHdlIGFyZSBjdXJyZW50bHkgb24gaXRcbiAgICAgICAgY29uc3QgY2xvc2VzdCA9IHRoaXMuZ2V0VGlja0Rpc3RhbmNlcyh2YWx1ZSwgdGh1bWIsIHNuYXBUYXJnZXQpXG4gICAgICAgICAgICAuZmlsdGVyKHRpY2sgPT4gdGljay52YWx1ZSAhPT0gdmFsdWUpXG4gICAgICAgICAgICAuZmluZCh0aWNrID0+IGZvcndhcmRzID8gdGljay52YWx1ZSA+IHZhbHVlIDogdGljay52YWx1ZSA8IHZhbHVlKTtcblxuICAgICAgICAvLyBJZiB3ZSBoYXZlIG5vIHRpY2tzIHRoZW4gbW92ZSBieSBhIHByZWRlZmluZWQgYW1vdW50XG4gICAgICAgIGlmIChjbG9zZXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRUaHVtYlZhbHVlKHRodW1iLCB0aGlzLnZhbGlkYXRlVmFsdWUodGh1bWIsIGNsb3Nlc3QudmFsdWUpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHN0ZXAgPSBzbmFwVGFyZ2V0ID09PSBTbGlkZXJTbmFwLk1ham9yID8gdGhpcy5vcHRpb25zLmhhbmRsZXMua2V5Ym9hcmQubWFqb3IgOiB0aGlzLm9wdGlvbnMuaGFuZGxlcy5rZXlib2FyZC5taW5vcjtcblxuICAgICAgICB0aGlzLnNldFRodW1iVmFsdWUodGh1bWIsIHRoaXMudmFsaWRhdGVWYWx1ZSh0aHVtYiwgdmFsdWUgKyAoZm9yd2FyZHMgPyBzdGVwIDogLXN0ZXApKSk7XG5cbiAgICB9XG5cbiAgICBzbmFwVG9FbmQodGh1bWI6IFNsaWRlclRodW1iLCBmb3J3YXJkczogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICB0aGlzLnNldFRodW1iVmFsdWUodGh1bWIsIHRoaXMudmFsaWRhdGVWYWx1ZSh0aHVtYiwgZm9yd2FyZHMgPyB0aGlzLm9wdGlvbnMudHJhY2subWF4IDogdGhpcy5vcHRpb25zLnRyYWNrLm1pbikpO1xuICAgIH1cblxuICAgIGdldFRodW1iVmFsdWUodGh1bWI6IFNsaWRlclRodW1iKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VGh1bWJTdGF0ZSh0aHVtYikudmFsdWU7XG4gICAgfVxuXG4gICAgZ2V0Rm9ybWF0dGVkVmFsdWUodGh1bWI6IFNsaWRlclRodW1iKTogc3RyaW5nIHwgbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5oYW5kbGVzLmNhbGxvdXQuZm9ybWF0dGVyKHRoaXMuZ2V0VGh1bWJTdGF0ZSh0aHVtYikudmFsdWUpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0VGh1bWJTdGF0ZSh0aHVtYjogU2xpZGVyVGh1bWIpIHtcbiAgICAgICAgcmV0dXJuIHRodW1iID09PSBTbGlkZXJUaHVtYi5Mb3dlciA/IHRoaXMudGh1bWJzLmxvd2VyIDogdGhpcy50aHVtYnMudXBwZXI7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzZXRUaHVtYlN0YXRlKHRodW1iOiBTbGlkZXJUaHVtYiwgaG92ZXI6IGJvb2xlYW4sIGRyYWc6IGJvb2xlYW4pIHtcblxuICAgICAgICBpZiAodGh1bWIgPT09IFNsaWRlclRodW1iLkxvd2VyKSB7XG4gICAgICAgICAgICB0aGlzLnRodW1icy5sb3dlci5ob3ZlciA9IGhvdmVyO1xuICAgICAgICAgICAgdGhpcy50aHVtYnMubG93ZXIuZHJhZyA9IGRyYWc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRodW1icy51cHBlci5ob3ZlciA9IGhvdmVyO1xuICAgICAgICAgICAgdGhpcy50aHVtYnMudXBwZXIuZHJhZyA9IGRyYWc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB1cGRhdGUgdGhlIHZpc2liaWxpdHkgb2YgdGhlIHRvb2x0aXBzXG4gICAgICAgIHRoaXMudXBkYXRlVG9vbHRpcHModGh1bWIpO1xuICAgIH1cblxuICAgIHRodW1iRXZlbnQodGh1bWI6IFNsaWRlclRodW1iLCBldmVudDogU2xpZGVyVGh1bWJFdmVudCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGdldCB0aGUgY3VycmVudCB0aHVtYiBzdGF0ZVxuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0VGh1bWJTdGF0ZSh0aHVtYik7XG5cbiAgICAgICAgLy8gdXBkYXRlIGJhc2VkIHVwb24gZXZlbnRcbiAgICAgICAgc3dpdGNoIChldmVudCkge1xuXG4gICAgICAgICAgICBjYXNlIFNsaWRlclRodW1iRXZlbnQuRHJhZ1N0YXJ0OlxuICAgICAgICAgICAgICAgIHN0YXRlLmRyYWcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFNsaWRlclRodW1iRXZlbnQuRHJhZ0VuZDpcbiAgICAgICAgICAgICAgICBzdGF0ZS5kcmFnID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgU2xpZGVyVGh1bWJFdmVudC5Nb3VzZU92ZXI6XG4gICAgICAgICAgICAgICAgc3RhdGUuaG92ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFNsaWRlclRodW1iRXZlbnQuTW91c2VMZWF2ZTpcbiAgICAgICAgICAgICAgICBzdGF0ZS5ob3ZlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFNsaWRlclRodW1iRXZlbnQuTm9uZTpcbiAgICAgICAgICAgICAgICBzdGF0ZS5kcmFnID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc3RhdGUuaG92ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgdGh1bWIgc3RhdGVcbiAgICAgICAgdGhpcy5zZXRUaHVtYlN0YXRlKHRodW1iLCBzdGF0ZS5ob3Zlciwgc3RhdGUuZHJhZyk7XG4gICAgfVxuXG4gICAgZ2V0QXJpYVZhbHVlVGV4dCh0aHVtYjogU2xpZGVyVGh1bWIpOiBzdHJpbmcgfCBudW1iZXIge1xuICAgICAgICAvLyBnZXQgdGhlIGN1cnJlbnQgdGh1bWIgdmFsdWVcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmdldFRodW1iVmFsdWUodGh1bWIpO1xuXG4gICAgICAgIC8vIGdldCBhbGwgdGhlIHRpY2tzXG4gICAgICAgIGNvbnN0IHRpY2sgPSB0aGlzLnRpY2tzLmZpbmQoX3RpY2sgPT4gX3RpY2sudmFsdWUgPT09IHZhbHVlKTtcblxuICAgICAgICBpZiAodGljayAmJiB0aWNrLmxhYmVsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGljay5sYWJlbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG90aGVyd2lzZSBzaW1wbHkgZGlzcGxheSB0aGUgZm9ybWF0dGVkIHZhbHVlXG4gICAgICAgIHJldHVybiB0aGlzLmdldEZvcm1hdHRlZFZhbHVlKHRodW1iKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHVwZGF0ZVRvb2x0aXBzKHRodW1iOiBTbGlkZXJUaHVtYik6IHZvaWQge1xuXG4gICAgICAgIGxldCB2aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXRUaHVtYlN0YXRlKHRodW1iKTtcblxuICAgICAgICBzd2l0Y2ggKHRoaXMub3B0aW9ucy5oYW5kbGVzLmNhbGxvdXQudHJpZ2dlcikge1xuXG4gICAgICAgICAgICBjYXNlIFNsaWRlckNhbGxvdXRUcmlnZ2VyLlBlcnNpc3RlbnQ6XG4gICAgICAgICAgICAgICAgdmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgU2xpZGVyQ2FsbG91dFRyaWdnZXIuRHJhZzpcbiAgICAgICAgICAgICAgICB2aXNpYmxlID0gc3RhdGUuZHJhZztcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBTbGlkZXJDYWxsb3V0VHJpZ2dlci5Ib3ZlcjpcbiAgICAgICAgICAgICAgICB2aXNpYmxlID0gc3RhdGUuaG92ZXIgfHwgc3RhdGUuZHJhZztcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBTbGlkZXJDYWxsb3V0VHJpZ2dlci5EeW5hbWljOlxuICAgICAgICAgICAgICAgIHZpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSBzdGF0ZSBmb3IgdGhlIGNvcnJlc3BvbmRpbmcgdGh1bWJcbiAgICAgICAgdGhpcy5nZXRUb29sdGlwKHRodW1iKS52aXNpYmxlID0gdmlzaWJsZTtcblxuICAgICAgICAvLyB1cGRhdGUgdGhlIHRvb2x0aXAgdGV4dFxuICAgICAgICB0aGlzLnVwZGF0ZVRvb2x0aXBUZXh0KHRodW1iKTtcblxuICAgICAgICAvLyB1cGRhdGUgdGhlIHRvb2x0aXAgcG9zaXRpb25zXG4gICAgICAgIHRoaXMudXBkYXRlVG9vbHRpcFBvc2l0aW9uKHRodW1iKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHVwZGF0ZVRvb2x0aXBUZXh0KHRodW1iOiBTbGlkZXJUaHVtYikge1xuXG4gICAgICAgIC8vIGdldCB0aGUgdGh1bWIgdmFsdWVcbiAgICAgICAgbGV0IHN0YXRlID0gdGhpcy5nZXRUaHVtYlN0YXRlKHRodW1iKTtcbiAgICAgICAgbGV0IHRvb2x0aXAgPSB0aGlzLmdldFRvb2x0aXAodGh1bWIpO1xuXG4gICAgICAgIC8vIHN0b3JlIHRoZSBmb3JtYXR0ZWQgbGFiZWxcbiAgICAgICAgdG9vbHRpcC5sYWJlbCA9IHRoaXMuZ2V0Rm9ybWF0dGVkVmFsdWUodGh1bWIpLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRUb29sdGlwRWxlbWVudCh0aHVtYjogU2xpZGVyVGh1bWIpOiBFbGVtZW50UmVmIHtcbiAgICAgICAgcmV0dXJuIHRodW1iID09PSBTbGlkZXJUaHVtYi5Mb3dlciA/IHRoaXMubG93ZXJUb29sdGlwIDogdGhpcy51cHBlclRvb2x0aXA7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRUb29sdGlwKHRodW1iOiBTbGlkZXJUaHVtYikge1xuICAgICAgICByZXR1cm4gdGh1bWIgPT09IFNsaWRlclRodW1iLkxvd2VyID8gdGhpcy50b29sdGlwcy5sb3dlciA6IHRoaXMudG9vbHRpcHMudXBwZXI7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVUb29sdGlwUG9zaXRpb24odGh1bWI6IFNsaWRlclRodW1iKTogdm9pZCB7XG5cbiAgICAgICAgY29uc3QgdG9vbHRpcCA9IHRoaXMuZ2V0VG9vbHRpcCh0aHVtYik7XG5cbiAgICAgICAgLy8gaWYgdG9vbHRpcCBpcyBub3QgdmlzaWJsZSB0aGVuIHN0b3AgaGVyZVxuICAgICAgICBpZiAodG9vbHRpcC52aXNpYmxlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHRvb2x0aXBFbGVtZW50ID0gdGhpcy5nZXRUb29sdGlwRWxlbWVudCh0aHVtYik7XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBlbGVtZW50IHdpZHRoc1xuICAgICAgICBsZXQgdGh1bWJXaWR0aDogbnVtYmVyO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGFuZGxlcy5zdHlsZSA9PT0gU2xpZGVyU3R5bGUuQnV0dG9uKSB7XG4gICAgICAgICAgICB0aHVtYldpZHRoID0gdGhpcy5vcHRpb25zLnRyYWNrLmhlaWdodCA9PT0gU2xpZGVyU2l6ZS5OYXJyb3cgPyAxNiA6IDI0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGh1bWJXaWR0aCA9IDI7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgdG9vbHRpcFdpZHRoID0gdG9vbHRpcEVsZW1lbnQubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aDtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIHRvb2x0aXBzIG5ldyBwb3NpdGlvblxuICAgICAgICBsZXQgdG9vbHRpcFBvc2l0aW9uID0gTWF0aC5jZWlsKCh0b29sdGlwV2lkdGggLSB0aHVtYldpZHRoKSAvIDIpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0b29sdGlwIHBvc2l0aW9uXG4gICAgICAgIHRvb2x0aXAucG9zaXRpb24gPSAtdG9vbHRpcFBvc2l0aW9uO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudHlwZSA9PT0gU2xpZGVyVHlwZS5SYW5nZSAmJiB0aGlzLm9wdGlvbnMuaGFuZGxlcy5jYWxsb3V0LnRyaWdnZXIgPT09IFNsaWRlckNhbGxvdXRUcmlnZ2VyLkR5bmFtaWMpIHtcbiAgICAgICAgICAgIHRoaXMucHJldmVudFRvb2x0aXBPdmVybGFwKHRvb2x0aXApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBwcmV2ZW50VG9vbHRpcE92ZXJsYXAodG9vbHRpcDogYW55KTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHRyYWNrV2lkdGggPSB0aGlzLnRyYWNrLm5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGg7XG5cbiAgICAgICAgY29uc3QgbG93ZXIgPSAodHJhY2tXaWR0aCAvIDEwMCkgKiB0aGlzLnRodW1icy5sb3dlci5wb3NpdGlvbjtcbiAgICAgICAgY29uc3QgdXBwZXIgPSAodHJhY2tXaWR0aCAvIDEwMCkgKiB0aGlzLnRodW1icy51cHBlci5wb3NpdGlvbjtcblxuICAgICAgICBjb25zdCBsb3dlcldpZHRoID0gdGhpcy5sb3dlclRvb2x0aXAubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aCAvIDI7XG4gICAgICAgIGNvbnN0IHVwcGVyV2lkdGggPSB0aGlzLnVwcGVyVG9vbHRpcC5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoIC8gMjtcblxuICAgICAgICBjb25zdCBkaWZmID0gKGxvd2VyICsgbG93ZXJXaWR0aCkgLSAodXBwZXIgLSB1cHBlcldpZHRoKTtcblxuICAgICAgICAvLyBpZiB0aGUgdG9vbHRpcHMgYXJlIGNsb3NlciB0aGFuIDE2cHggdGhlbiBhZGp1c3Qgc28gdGhlIGRvbnQgbW92ZSBhbnkgY2xvc2VcbiAgICAgICAgaWYgKGRpZmYgPiAwKSB7XG4gICAgICAgICAgICBpZiAodG9vbHRpcCA9PT0gdGhpcy50b29sdGlwcy5sb3dlciAmJiB0aGlzLnRodW1icy5sb3dlci5kcmFnID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRvb2x0aXAucG9zaXRpb24gLT0gKGRpZmYgLyAyKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodG9vbHRpcCA9PT0gdGhpcy50b29sdGlwcy51cHBlciAmJiB0aGlzLnRodW1icy51cHBlci5kcmFnID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRvb2x0aXAucG9zaXRpb24gKz0gKGRpZmYgLyAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgY2xhbXAodmFsdWU6IG51bWJlciwgbWluOiBudW1iZXIsIG1heDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHZhbHVlLCBtaW4pLCBtYXgpO1xuICAgIH1cblxuICAgIHVwZGF0ZVRodW1iUG9zaXRpb24oZXZlbnQ6IE1vdXNlRXZlbnQgfCBUb3VjaEV2ZW50LCB0aHVtYjogU2xpZGVyVGh1bWIpOiB2b2lkIHtcblxuICAgICAgICAvLyBnZXQgZXZlbnQgcG9zaXRpb24gLSBlaXRoZXIgbW91c2Ugb3IgdG91Y2hcbiAgICAgICAgbGV0IGV2ZW50UG9zaXRpb24gPSBldmVudCBpbnN0YW5jZW9mIE1vdXNlRXZlbnQgPyBldmVudC5jbGllbnRYIDogZXZlbnQudG91Y2hlcyAmJiBldmVudC50b3VjaGVzLmxlbmd0aCA+IDAgPyBldmVudC50b3VjaGVzWzBdLmNsaWVudFggOiBudWxsO1xuXG4gICAgICAgIC8vIGlmIGV2ZW50IHBvc2l0aW9uIGlzIG51bGwgZG8gbm90aGluZ1xuICAgICAgICBpZiAoZXZlbnRQb3NpdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2V0IG1vdXNlIHBvc2l0aW9uXG4gICAgICAgIGxldCBtb3VzZVggPSB3aW5kb3cucGFnZVhPZmZzZXQgKyBldmVudFBvc2l0aW9uO1xuXG4gICAgICAgIC8vIGdldCB0cmFjayBzaXplIGFuZCBwb3NpdGlvblxuICAgICAgICBsZXQgdHJhY2tCb3VuZHMgPSB0aGlzLnRyYWNrLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgLy8gcmVzdHJpY3QgdGhlIHZhbHVlIHdpdGhpbiB0aGUgcmFuZ2Ugc2l6ZVxuICAgICAgICBsZXQgcG9zaXRpb24gPSB0aGlzLmNsYW1wKG1vdXNlWCAtIHRyYWNrQm91bmRzLmxlZnQsIDAsIHRyYWNrQm91bmRzLndpZHRoKTtcblxuICAgICAgICAvLyBnZXQgZnJhY3Rpb24gcmVwcmVzZW50YXRpb24gb2YgbG9jYXRpb24gd2l0aGluIHRoZSB0cmFja1xuICAgICAgICBsZXQgZnJhY3Rpb24gPSAocG9zaXRpb24gLyB0cmFja0JvdW5kcy53aWR0aCk7XG5cbiAgICAgICAgLy8gY29udmVydCB0byB2YWx1ZSB3aXRoaW4gdGhlIHJhbmdlXG4gICAgICAgIGxldCB2YWx1ZSA9ICgodGhpcy5vcHRpb25zLnRyYWNrLm1heCAtIHRoaXMub3B0aW9ucy50cmFjay5taW4pICogZnJhY3Rpb24pICsgdGhpcy5vcHRpb25zLnRyYWNrLm1pbjtcblxuICAgICAgICAvLyBlbnN1cmUgdmFsdWUgaXMgdmFsaWRcbiAgICAgICAgdmFsdWUgPSB0aGlzLnZhbGlkYXRlVmFsdWUodGh1bWIsIHZhbHVlKTtcblxuICAgICAgICAvLyBzbmFwIHRvIGEgdGljayBpZiByZXF1aXJlZFxuICAgICAgICB2YWx1ZSA9IHRoaXMuc25hcFRvVGljayh2YWx1ZSwgdGh1bWIpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgdmFsdWUgYWNjb3JkaW5nbHlcbiAgICAgICAgdGhpcy5zZXRUaHVtYlZhbHVlKHRodW1iLCB2YWx1ZSk7XG5cbiAgICAgICAgdGhpcy51cGRhdGVPcmRlcih0aHVtYik7XG4gICAgICAgIHRoaXMudXBkYXRlVmFsdWVzKCk7XG5cbiAgICAgICAgLy8gdXBkYXRlIHRvb2x0aXAgdGV4dCAmIHBvc2l0aW9uXG4gICAgICAgIHRoaXMudXBkYXRlVG9vbHRpcFRleHQodGh1bWIpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgcG9zaXRpb24gb2YgYWxsIHZpc2libGUgdG9vbHRpcHNcbiAgICAgICAgdGhpcy51cGRhdGVUb29sdGlwUG9zaXRpb24oU2xpZGVyVGh1bWIuTG93ZXIpO1xuICAgICAgICB0aGlzLnVwZGF0ZVRvb2x0aXBQb3NpdGlvbihTbGlkZXJUaHVtYi5VcHBlcik7XG5cbiAgICAgICAgLy8gbWFyayBhcyBkaXJ0eSBmb3IgY2hhbmdlIGRldGVjdGlvblxuICAgICAgICB0aGlzLl9jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHVwZGF0ZU9yZGVyKHRodW1iOiBTbGlkZXJUaHVtYik6IHZvaWQge1xuXG4gICAgICAgIGxldCBsb3dlciA9IHRodW1iID09PSBTbGlkZXJUaHVtYi5Mb3dlciA/IDEwMSA6IDEwMDtcbiAgICAgICAgbGV0IHVwcGVyID0gdGh1bWIgPT09IFNsaWRlclRodW1iLkxvd2VyID8gMTAwIDogMTAxO1xuXG4gICAgICAgIC8vIFRoZSBtb3N0IHJlY2VudGx5IHVzZWQgdGh1bWIgc2hvdWxkIGJlIGFib3ZlXG4gICAgICAgIHRoaXMudGh1bWJzLmxvd2VyLm9yZGVyID0gbG93ZXI7XG4gICAgICAgIHRoaXMudGh1bWJzLnVwcGVyLm9yZGVyID0gdXBwZXI7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRUaWNrRGlzdGFuY2VzKHZhbHVlOiBudW1iZXIsIHRodW1iOiBTbGlkZXJUaHVtYiwgc25hcFRhcmdldDogU2xpZGVyU25hcCk6IFNsaWRlclRpY2tbXSB7XG5cbiAgICAgICAgLy8gaWYgc25hcCB0YXJnZXQgaXMgbm9uZSB0aGVuIHJldHVybiBvcmlnaW5hbCB2YWx1ZVxuICAgICAgICBpZiAoc25hcFRhcmdldCA9PT0gU2xpZGVyU25hcC5Ob25lKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgZmlsdGVyZWQgdGlja3NcbiAgICAgICAgbGV0IHRpY2tzOiBTbGlkZXJUaWNrW107XG5cbiAgICAgICAgc3dpdGNoIChzbmFwVGFyZ2V0KSB7XG5cbiAgICAgICAgICAgIGNhc2UgU2xpZGVyU25hcC5NaW5vcjpcbiAgICAgICAgICAgICAgICB0aWNrcyA9IHRoaXMudGlja3MuZmlsdGVyKHRpY2sgPT4gdGljay50eXBlID09PSBTbGlkZXJUaWNrVHlwZS5NaW5vcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgU2xpZGVyU25hcC5NYWpvcjpcbiAgICAgICAgICAgICAgICB0aWNrcyA9IHRoaXMudGlja3MuZmlsdGVyKHRpY2sgPT4gdGljay50eXBlID09PSBTbGlkZXJUaWNrVHlwZS5NYWpvcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGlja3MgPSB0aGlzLnRpY2tzLnNsaWNlKDApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2V0IHRoZSB0cmFjayBsaW1pdFxuICAgICAgICBsZXQgbG93ZXJMaW1pdCA9IHRoaXMub3B0aW9ucy50cmFjay5taW47XG4gICAgICAgIGxldCB1cHBlckxpbWl0ID0gdGhpcy5vcHRpb25zLnRyYWNrLm1heDtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnR5cGUgPT09IFNsaWRlclR5cGUuUmFuZ2UgJiYgdGh1bWIgPT09IFNsaWRlclRodW1iLkxvd2VyKSB7XG4gICAgICAgICAgICB1cHBlckxpbWl0ID0gdGhpcy50aHVtYnMudXBwZXIudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnR5cGUgPT09IFNsaWRlclR5cGUuUmFuZ2UgJiYgdGh1bWIgPT09IFNsaWRlclRodW1iLlVwcGVyKSB7XG4gICAgICAgICAgICBsb3dlckxpbWl0ID0gdGhpcy50aHVtYnMubG93ZXIudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaW5kIHRoZSBjbG9zZXN0IHRpY2sgdG8gdGhlIGN1cnJlbnQgcG9zaXRpb25cbiAgICAgICAgY29uc3QgcmFuZ2UgPSB0aWNrcy5maWx0ZXIodGljayA9PiB0aWNrLnZhbHVlID49IGxvd2VyTGltaXQgJiYgdGljay52YWx1ZSA8PSB1cHBlckxpbWl0KTtcblxuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gY2xvc2UgdGlja3MgaW4gdGhlIHZhbGlkIHJhbmdlIHRoZW4gZG9udCBzbmFwXG4gICAgICAgIGlmIChyYW5nZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByYW5nZS5zb3J0KCh0aWNrT25lLCB0aWNrVHdvKSA9PiB7XG5cbiAgICAgICAgICAgIGNvbnN0IHRpY2tPbmVEZWx0YSA9IE1hdGgubWF4KHRpY2tPbmUudmFsdWUsIHZhbHVlKSAtIE1hdGgubWluKHRpY2tPbmUudmFsdWUsIHZhbHVlKTtcbiAgICAgICAgICAgIGNvbnN0IHRpY2tUd29EZWx0YSA9IE1hdGgubWF4KHRpY2tUd28udmFsdWUsIHZhbHVlKSAtIE1hdGgubWluKHRpY2tUd28udmFsdWUsIHZhbHVlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIHRpY2tPbmVEZWx0YSAtIHRpY2tUd29EZWx0YTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzbmFwVG9UaWNrKHZhbHVlOiBudW1iZXIsIHRodW1iOiBTbGlkZXJUaHVtYik6IG51bWJlciB7XG5cbiAgICAgICAgY29uc3QgdGlja0Rpc3RhbmNlcyA9IHRoaXMuZ2V0VGlja0Rpc3RhbmNlcyh2YWx1ZSwgdGh1bWIsIHRoaXMub3B0aW9ucy50cmFjay50aWNrcy5zbmFwKTtcblxuICAgICAgICAvLyBpZiB0aGVyZSBhcmUgbm8gdGlja3MgcmV0dXJuIHRoZSBjdXJyZW50IHZhbHVlXG4gICAgICAgIGlmICh0aWNrRGlzdGFuY2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBjbG9zZXN0IHRpY2tcbiAgICAgICAgcmV0dXJuIHRpY2tEaXN0YW5jZXNbMF0udmFsdWU7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB2YWxpZGF0ZVZhbHVlKHRodW1iOiBTbGlkZXJUaHVtYiwgdmFsdWU6IG51bWJlcik6IG51bWJlciB7XG5cbiAgICAgICAgLy8gaWYgc2xpZGVyIGlzIG5vdCBhIHJhbmdlIHZhbHVlIGlzIGFsd2F5cyB2YWxpZCBwcm92aWRpbmcgaXQgaXMgd2l0aGluIHRoZSBjaGFydCBtaW4gYW5kIG1heCB2YWx1ZXNcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50eXBlID09PSBTbGlkZXJUeXBlLlZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4odmFsdWUsIHRoaXMub3B0aW9ucy50cmFjay5tYXgpLCB0aGlzLm9wdGlvbnMudHJhY2subWluKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIGlmIHZhbHVlIGlzIHdpdGggY2hhcnQgcmFuZ2VzXG4gICAgICAgIGlmICh2YWx1ZSA+IHRoaXMub3B0aW9ucy50cmFjay5tYXgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aHVtYiA9PT0gU2xpZGVyVGh1bWIuTG93ZXIgPyBNYXRoLm1pbih0aGlzLm9wdGlvbnMudHJhY2subWF4LCB0aGlzLnRodW1icy51cHBlci52YWx1ZSkgOiB0aGlzLm9wdGlvbnMudHJhY2subWF4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlIDwgdGhpcy5vcHRpb25zLnRyYWNrLm1pbikge1xuICAgICAgICAgICAgcmV0dXJuIHRodW1iID09PSBTbGlkZXJUaHVtYi5VcHBlciA/IE1hdGgubWF4KHRoaXMub3B0aW9ucy50cmFjay5taW4sIHRoaXMudGh1bWJzLmxvd2VyLnZhbHVlKSA6IHRoaXMub3B0aW9ucy50cmFjay5taW47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvdGhlcndpc2Ugd2UgbmVlZCB0byBjaGVjayB0byBtYWtlIHN1cmUgbG93ZXIgdGh1bWIgY2Fubm90IGdvIGFib3ZlIGhpZ2hlciBhbmQgdmljZSB2ZXJzYVxuICAgICAgICBpZiAodGh1bWIgPT09IFNsaWRlclRodW1iLkxvd2VyKSB7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnRodW1icy51cHBlci52YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlIDw9IHRoaXMudGh1bWJzLnVwcGVyLnZhbHVlID8gdmFsdWUgOiB0aGlzLnRodW1icy51cHBlci52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aHVtYiA9PT0gU2xpZGVyVGh1bWIuVXBwZXIpIHtcblxuICAgICAgICAgICAgaWYgKHRoaXMudGh1bWJzLmxvd2VyLnZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPj0gdGhpcy50aHVtYnMubG93ZXIudmFsdWUgPyB2YWx1ZSA6IHRoaXMudGh1bWJzLmxvd2VyLnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVPcHRpb25zKCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGFkZCBpbiB0aGUgZGVmYXVsdCBvcHRpb25zIHRoYXQgdXNlciBoYXNuJ3Qgc3BlY2lmaWVkXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHRoaXMuZGVlcE1lcmdlKHRoaXMub3B0aW9ucyB8fCB7fSwgdGhpcy5kZWZhdWx0T3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy51cGRhdGVUcmFja0NvbG9ycygpO1xuICAgICAgICB0aGlzLnVwZGF0ZVRpY2tzKCk7XG4gICAgICAgIHRoaXMudXBkYXRlVmFsdWVzKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVWYWx1ZXMoKTogdm9pZCB7XG5cbiAgICAgICAgaWYgKHRoaXMudmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLnZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBsb3dlclZhbHVlID0gdHlwZW9mIHRoaXMudmFsdWUgPT09ICdudW1iZXInID8gdGhpcy52YWx1ZSA6IHRoaXMudmFsdWUubG93O1xuICAgICAgICBsZXQgdXBwZXJWYWx1ZSA9IHR5cGVvZiB0aGlzLnZhbHVlID09PSAnbnVtYmVyJyA/IHRoaXMudmFsdWUgOiB0aGlzLnZhbHVlLmhpZ2g7XG5cbiAgICAgICAgLy8gdmFsaWRhdGUgdmFsdWVzXG4gICAgICAgIGxvd2VyVmFsdWUgPSB0aGlzLnZhbGlkYXRlVmFsdWUoU2xpZGVyVGh1bWIuTG93ZXIsIE51bWJlcihsb3dlclZhbHVlLnRvRml4ZWQoNCkpKTtcbiAgICAgICAgdXBwZXJWYWx1ZSA9IHRoaXMudmFsaWRhdGVWYWx1ZShTbGlkZXJUaHVtYi5VcHBlciwgTnVtYmVyKHVwcGVyVmFsdWUudG9GaXhlZCg0KSkpO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgcG9zaXRpb25zIGFzIHBlcmNlbnRhZ2VzXG4gICAgICAgIGxldCBsb3dlclBvc2l0aW9uID0gKCgobG93ZXJWYWx1ZSAtIHRoaXMub3B0aW9ucy50cmFjay5taW4pIC8gKHRoaXMub3B0aW9ucy50cmFjay5tYXggLSB0aGlzLm9wdGlvbnMudHJhY2subWluKSkgKiAxMDApO1xuICAgICAgICBsZXQgdXBwZXJQb3NpdGlvbiA9ICgoKHVwcGVyVmFsdWUgLSB0aGlzLm9wdGlvbnMudHJhY2subWluKSAvICh0aGlzLm9wdGlvbnMudHJhY2subWF4IC0gdGhpcy5vcHRpb25zLnRyYWNrLm1pbikpICogMTAwKTtcblxuICAgICAgICAvLyB1cGRhdGUgdGh1bWIgcG9zaXRpb25zXG4gICAgICAgIHRoaXMudGh1bWJzLmxvd2VyLnBvc2l0aW9uID0gbG93ZXJQb3NpdGlvbjtcbiAgICAgICAgdGhpcy50aHVtYnMudXBwZXIucG9zaXRpb24gPSB1cHBlclBvc2l0aW9uO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgdHJhY2sgc2l6ZXNcbiAgICAgICAgdGhpcy50cmFja3MubG93ZXIuc2l6ZSA9IGxvd2VyUG9zaXRpb247XG4gICAgICAgIHRoaXMudHJhY2tzLm1pZGRsZS5zaXplID0gdXBwZXJQb3NpdGlvbiAtIGxvd2VyUG9zaXRpb247XG4gICAgICAgIHRoaXMudHJhY2tzLnVwcGVyLnNpemUgPSB0aGlzLm9wdGlvbnMudHlwZSA9PT0gU2xpZGVyVHlwZS5WYWx1ZSA/IDEwMCAtIGxvd2VyUG9zaXRpb24gOiAxMDAgLSB1cHBlclBvc2l0aW9uO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgdmFsdWUgaW5wdXRcbiAgICAgICAgdGhpcy5zZXRWYWx1ZShsb3dlclZhbHVlLCB1cHBlclZhbHVlKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHNldFZhbHVlKGxvdzogbnVtYmVyLCBoaWdoPzogbnVtYmVyKTogdm9pZCB7XG5cbiAgICAgICAgdGhpcy50aHVtYnMubG93ZXIudmFsdWUgPSBsb3c7XG4gICAgICAgIHRoaXMudGh1bWJzLnVwcGVyLnZhbHVlID0gaGlnaDtcblxuICAgICAgICBsZXQgcHJldmlvdXNWYWx1ZSA9IHRoaXMuY2xvbmUodGhpcy5fdmFsdWUpO1xuXG4gICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLm9wdGlvbnMudHlwZSA9PT0gU2xpZGVyVHlwZS5WYWx1ZSA/IGxvdyA6IHsgbG93OiBsb3csIGhpZ2g6IGhpZ2ggfTtcblxuICAgICAgICAvLyBjYWxsIHRoZSBldmVudCBlbWl0dGVyIGlmIGNoYW5nZXMgb2NjdXJlZFxuICAgICAgICBpZiAodGhpcy5kZXRlY3RWYWx1ZUNoYW5nZSh0aGlzLnZhbHVlLCBwcmV2aW91c1ZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZUNoYW5nZS5lbWl0KHRoaXMuY2xvbmUodGhpcy52YWx1ZSkpO1xuXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRvb2x0aXBUZXh0KFNsaWRlclRodW1iLkxvd2VyKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVG9vbHRpcFRleHQoU2xpZGVyVGh1bWIuVXBwZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy52YWx1ZUNoYW5nZS5lbWl0KHRoaXMuY2xvbmUodGhpcy52YWx1ZSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzZXRUaHVtYlZhbHVlKHRodW1iOiBTbGlkZXJUaHVtYiwgdmFsdWU6IG51bWJlcik6IHZvaWQge1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgdGh1bWIgdmFsdWVcbiAgICAgICAgdGhpcy5nZXRUaHVtYlN0YXRlKHRodW1iKS52YWx1ZSA9IHZhbHVlO1xuXG4gICAgICAgIC8vIGZvcndhcmQgdGhlc2UgY2hhbmdlcyB0byB0aGUgdmFsdWVcbiAgICAgICAgdGhpcy5zZXRWYWx1ZSh0aGlzLnRodW1icy5sb3dlci52YWx1ZSwgdGhpcy50aHVtYnMudXBwZXIudmFsdWUpO1xuICAgIH1cblxuICAgIHByaXZhdGUgdXBkYXRlVGlja3MoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gZ2V0IHRpY2sgb3B0aW9uc1xuICAgICAgICBjb25zdCBtYWpvck9wdGlvbnMgPSB0aGlzLm9wdGlvbnMudHJhY2sudGlja3MubWFqb3I7XG4gICAgICAgIGNvbnN0IG1pbm9yT3B0aW9ucyA9IHRoaXMub3B0aW9ucy50cmFjay50aWNrcy5taW5vcjtcblxuICAgICAgICAvLyBjaGVjayBpZiB3ZSBzaG91bGQgc2hvdyB0aWNrc1xuICAgICAgICBpZiAobWFqb3JPcHRpb25zLnNob3cgPT09IGZhbHNlICYmIG1pbm9yT3B0aW9ucy5zaG93ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy50aWNrcyA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlIHRpY2tzIGZvciBib3RoIG1ham9yIGFuZCBtaW5vciAtIG9ubHkgZ2V0IHRoZSBvbmVzIHRvIGJlIHNob3duXG4gICAgICAgIGNvbnN0IG1ham9yVGlja3MgPSB0aGlzLmdldFRpY2tzKG1ham9yT3B0aW9ucywgU2xpZGVyVGlja1R5cGUuTWFqb3IpLmZpbHRlcih0aWNrID0+IHRpY2suc2hvd1RpY2tzKTtcbiAgICAgICAgY29uc3QgbWlub3JUaWNrcyA9IHRoaXMuZ2V0VGlja3MobWlub3JPcHRpb25zLCBTbGlkZXJUaWNrVHlwZS5NaW5vcikuZmlsdGVyKHRpY2sgPT4gdGljay5zaG93VGlja3MpO1xuXG4gICAgICAgIC8vIHJlbW92ZSBhbnkgbWlub3IgdGlja3MgdGhhdCBhcmUgb24gYSBtYWpvciBpbnRlcnZhbFxuICAgICAgICB0aGlzLnRpY2tzID0gdGhpcy51bmlvblRpY2tzKG1ham9yVGlja3MsIG1pbm9yVGlja3MpO1xuICAgIH1cblxuICAgIHByaXZhdGUgdXBkYXRlVHJhY2tDb2xvcnMoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gZ2V0IGNvbG9ycyBmb3IgZWFjaCBwYXJ0IG9mIHRoZSB0cmFja1xuICAgICAgICBjb25zdCB7IGxvd2VyLCByYW5nZSwgaGlnaGVyIH0gPSB0aGlzLm9wdGlvbnMudHJhY2suY29sb3JzO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgY29udHJvbGxlciB2YWx1ZVxuICAgICAgICB0aGlzLnRyYWNrcy5sb3dlci5jb2xvciA9IHR5cGVvZiBsb3dlciA9PT0gJ3N0cmluZycgPyBsb3dlciA6IGBsaW5lYXItZ3JhZGllbnQodG8gcmlnaHQsICR7bG93ZXIuam9pbignLCAnKX0pYDtcbiAgICAgICAgdGhpcy50cmFja3MubWlkZGxlLmNvbG9yID0gdHlwZW9mIHJhbmdlID09PSAnc3RyaW5nJyA/IHJhbmdlIDogYGxpbmVhci1ncmFkaWVudCh0byByaWdodCwgJHtyYW5nZS5qb2luKCcsICcpfSlgO1xuICAgICAgICB0aGlzLnRyYWNrcy51cHBlci5jb2xvciA9IHR5cGVvZiBoaWdoZXIgPT09ICdzdHJpbmcnID8gaGlnaGVyIDogYGxpbmVhci1ncmFkaWVudCh0byByaWdodCwgJHtoaWdoZXIuam9pbignLCAnKX0pYDtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldFN0ZXBzKHN0ZXBzOiBudW1iZXIgfCBudW1iZXJbXSk6IG51bWJlcltdIHtcblxuICAgICAgICAvLyBpZiB0aGV5IGFyZSBhbHJlYWR5IGFuIGFycmF5IGp1c3QgcmV0dXJuIGl0XG4gICAgICAgIGlmIChzdGVwcyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gc3RlcHM7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgb3V0cHV0OiBudW1iZXJbXSA9IFtdO1xuXG4gICAgICAgIC8vIG90aGVyd2lzZSBjYWxjdWxhdGUgdGhlIHN0ZXBzXG4gICAgICAgIGZvciAobGV0IGlkeCA9IHRoaXMub3B0aW9ucy50cmFjay5taW47IGlkeCA8PSB0aGlzLm9wdGlvbnMudHJhY2subWF4OyBpZHggKz0gc3RlcHMpIHtcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKGlkeCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0VGlja3Mob3B0aW9uczogU2xpZGVyVGlja09wdGlvbnMsIHR5cGU6IFNsaWRlclRpY2tUeXBlKTogU2xpZGVyVGlja1tdIHtcblxuICAgICAgICAvLyBjcmVhdGUgYW4gYXJyYXkgdG8gc3RvcmUgdGhlIHRpY2tzIGFuZCBzdGVwIHBvaW50c1xuICAgICAgICBsZXQgc3RlcHMgPSB0aGlzLmdldFN0ZXBzKG9wdGlvbnMuc3RlcHMpO1xuXG4gICAgICAgIC8vIGdldCBzb21lIGNoYXJ0IG9wdGlvbnNcbiAgICAgICAgbGV0IG1pbiA9IHRoaXMub3B0aW9ucy50cmFjay5taW47XG4gICAgICAgIGxldCBtYXggPSB0aGlzLm9wdGlvbnMudHJhY2subWF4O1xuXG4gICAgICAgIC8vIGNvbnZlcnQgZWFjaCBzdGVwIHRvIGEgc2xpZGVyIHRpY2sgYW5kIHJlbW92ZSBpbnZhbGlkIHRpY2tzXG4gICAgICAgIHJldHVybiBzdGVwcy5tYXAoc3RlcCA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNob3dUaWNrczogb3B0aW9ucy5zaG93LFxuICAgICAgICAgICAgICAgIHNob3dMYWJlbHM6IG9wdGlvbnMubGFiZWxzLFxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICgoc3RlcCAtIG1pbikgLyAobWF4IC0gbWluKSkgKiAxMDAsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHN0ZXAsXG4gICAgICAgICAgICAgICAgbGFiZWw6IG9wdGlvbnMuZm9ybWF0dGVyKHN0ZXApXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KS5maWx0ZXIodGljayA9PiB0aWNrLnBvc2l0aW9uID49IDAgJiYgdGljay5wb3NpdGlvbiA8PSAxMDApO1xuICAgIH1cblxuICAgIHByaXZhdGUgdW5pb25UaWNrcyhtYWpvclRpY2tzOiBTbGlkZXJUaWNrW10sIG1pbm9yVGlja3M6IFNsaWRlclRpY2tbXSk6IFNsaWRlclRpY2tbXSB7XG5cbiAgICAgICAgLy8gZ2V0IGFsbCB0aWNrcyBjb21iaW5lZCByZW1vdmluZyBhbnkgbWlub3IgdGlja3Mgd2l0aCB0aGUgc2FtZSB2YWx1ZSBhcyBtYWpvciB0aWNrc1xuICAgICAgICByZXR1cm4gbWFqb3JUaWNrcy5jb25jYXQobWlub3JUaWNrcylcbiAgICAgICAgICAgIC5maWx0ZXIoKHRpY2ssIGluZGV4LCBhcnJheSkgPT4gdGljay50eXBlID09PSBTbGlkZXJUaWNrVHlwZS5NYWpvciB8fCAhYXJyYXkuZmluZCh0ayA9PiB0ay50eXBlID09PSBTbGlkZXJUaWNrVHlwZS5NYWpvciAmJiB0ay5wb3NpdGlvbiA9PT0gdGljay5wb3NpdGlvbikpXG4gICAgICAgICAgICAuc29ydCgodDEsIHQyKSA9PiB0MS52YWx1ZSAtIHQyLnZhbHVlKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGRlZXBNZXJnZTxUPihkZXN0aW5hdGlvbjogVCwgc291cmNlOiBUKTogVCB7XG5cbiAgICAgICAgLy8gbG9vcCB0aG91Z2ggYWxsIG9mIHRoZSBwcm9wZXJ0aWVzIGluIHRoZSBzb3VyY2Ugb2JqZWN0XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gc291cmNlKSB7XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QgaGFzIHRoZSBwcm9wZXJ0eVxuICAgICAgICAgICAgaWYgKCFkZXN0aW5hdGlvbi5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgICAgIC8vIGNvcHkgdGhlIHByb3BlcnR5IGFjcm9zc1xuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uW3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGUgcHJvcGVydHkgZXhpc3RzIGFuZCBpcyBub3QgYW4gb2JqZWN0IHRoZW4gc2tpcFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkZXN0aW5hdGlvbltwcm9wXSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgcHJvcGVydHkgaXMgYW4gYXJyYXlcbiAgICAgICAgICAgIGlmIChkZXN0aW5hdGlvbltwcm9wXSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIGl0IGlzIGFuIG9iamVjdCB0aGVuIHBlcmZvcm0gYSByZWN1cnNpdmUgY2hlY2tcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uW3Byb3BdID0gdGhpcy5kZWVwTWVyZ2UoZGVzdGluYXRpb25bcHJvcF0sIHNvdXJjZVtwcm9wXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVzdGluYXRpb247XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBkZXRlY3RWYWx1ZUNoYW5nZSh2YWx1ZTE6IG51bWJlciB8IFNsaWRlclZhbHVlLCB2YWx1ZTI6IG51bWJlciB8IFNsaWRlclZhbHVlKTogYm9vbGVhbiB7XG5cbiAgICAgICAgLy8gY29tcGFyZSB0d28gc2xpZGVyIHZhbHVlc1xuICAgICAgICBpZiAodGhpcy5pc1NsaWRlclZhbHVlKHZhbHVlMSkgJiYgdGhpcy5pc1NsaWRlclZhbHVlKHZhbHVlMikpIHtcblxuICAgICAgICAgICAgLy8gcmVmZXJlbmNlcyB0byB0aGUgb2JqZWN0cyBpbiB0aGUgY29ycmVjdCB0eXBlc1xuICAgICAgICAgICAgY29uc3Qgb2JqMSA9IHZhbHVlMSBhcyBTbGlkZXJWYWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IG9iajIgPSB2YWx1ZTIgYXMgU2xpZGVyVmFsdWU7XG5cbiAgICAgICAgICAgIHJldHVybiBvYmoxLmxvdyAhPT0gb2JqMi5sb3cgfHwgb2JqMS5oaWdoICE9PSBvYmoyLmhpZ2g7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBub3QgYSBzbGlkZXIgdmFsdWUgLSBzaG91bGQgYmUgbnVtYmVyIG9mIG51bGxhYmxlIHR5cGUgLSBjb21wYXJlIG5vcm1hbGx5XG4gICAgICAgIHJldHVybiB2YWx1ZTEgIT09IHZhbHVlMjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IGFuIG9iamVjdCBjb25mb3JtcyB0byB0aGVcbiAgICAgKiBTbGlkZXJWYWx1ZSBpbnRlcmZhY2UuXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIG9iamVjdCB0byBjaGVjayAtIHRoaXMgbXVzdCBiZSB0eXBlIGFueVxuICAgICAqL1xuICAgIHByaXZhdGUgaXNTbGlkZXJWYWx1ZSh2YWx1ZTogYW55KTogYm9vbGVhbiB7XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgaXMgYW4gb2JqZWN0XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBuZXh0IGNoZWNrIGlmIGl0IGNvbnRhaW5zIHRoZSBuZWNlc3NhcnkgcHJvcGVydGllc1xuICAgICAgICByZXR1cm4gJ2xvdycgaW4gdmFsdWUgJiYgJ2hpZ2gnIGluIHZhbHVlO1xuICAgIH1cblxuICAgIHByaXZhdGUgY2xvbmUodmFsdWU6IG51bWJlciB8IFNsaWRlclZhbHVlKTogbnVtYmVyIHwgU2xpZGVyVmFsdWUge1xuXG4gICAgICAgIC8vIGlmIGl0IGlzIG5vdCBhbiBvYmplY3Qgc2ltcGx5IHJldHVybiB0aGUgdmFsdWVcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNyZWF0ZSBhIG5ldyBvYmplY3QgZnJvbSB0aGUgZXhpc3Rpbmcgb25lXG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0geyAuLi52YWx1ZSB9O1xuXG4gICAgICAgIC8vIGRlbGV0ZSByZW1vdmUgdGhlIHZhbHVlIGZyb20gdGhlIG9sZCBvYmplY3RcbiAgICAgICAgdmFsdWUgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgLy8gcmV0dXJuIHRoZSBuZXcgaW5zdGFuY2Ugb2YgdGhlIG9iamVjdFxuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxufVxuXG5leHBvcnQgZW51bSBTbGlkZXJUeXBlIHtcbiAgICBWYWx1ZSxcbiAgICBSYW5nZVxufVxuXG5leHBvcnQgZW51bSBTbGlkZXJTdHlsZSB7XG4gICAgQnV0dG9uLFxuICAgIExpbmVcbn1cblxuZXhwb3J0IGVudW0gU2xpZGVyU2l6ZSB7XG4gICAgTmFycm93LFxuICAgIFdpZGVcbn1cblxuZXhwb3J0IGVudW0gU2xpZGVyQ2FsbG91dFRyaWdnZXIge1xuICAgIE5vbmUsXG4gICAgSG92ZXIsXG4gICAgRHJhZyxcbiAgICBQZXJzaXN0ZW50LFxuICAgIER5bmFtaWNcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTbGlkZXJWYWx1ZSB7XG4gICAgbG93OiBudW1iZXI7XG4gICAgaGlnaDogbnVtYmVyO1xufVxuXG5leHBvcnQgZW51bSBTbGlkZXJTbmFwIHtcbiAgICBOb25lLFxuICAgIE1pbm9yLFxuICAgIE1ham9yLFxuICAgIEFsbFxufVxuXG5leHBvcnQgZW51bSBTbGlkZXJUaWNrVHlwZSB7XG4gICAgTWlub3IsXG4gICAgTWFqb3Jcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTbGlkZXJPcHRpb25zIHtcbiAgICB0eXBlPzogU2xpZGVyVHlwZTtcbiAgICBoYW5kbGVzPzogU2xpZGVySGFuZGxlT3B0aW9ucztcbiAgICB0cmFjaz86IFNsaWRlclRyYWNrT3B0aW9ucztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTbGlkZXJIYW5kbGVPcHRpb25zIHtcbiAgICBzdHlsZT86IFNsaWRlclN0eWxlO1xuICAgIGNhbGxvdXQ/OiBTbGlkZXJDYWxsb3V0O1xuICAgIGtleWJvYXJkPzogU2xpZGVyS2V5Ym9hcmRPcHRpb25zO1xuICAgIGFyaWE/OiBTbGlkZXJBcmlhT3B0aW9ucztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTbGlkZXJBcmlhT3B0aW9ucyB7XG4gICAgdGh1bWI/OiBzdHJpbmc7XG4gICAgbG93ZXJUaHVtYj86IHN0cmluZztcbiAgICB1cHBlclRodW1iPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNsaWRlcktleWJvYXJkT3B0aW9ucyB7XG4gICAgbWFqb3I/OiBudW1iZXI7XG4gICAgbWlub3I/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2xpZGVyVHJhY2tPcHRpb25zIHtcbiAgICBoZWlnaHQ/OiBTbGlkZXJTaXplO1xuICAgIG1pbj86IG51bWJlcjtcbiAgICBtYXg/OiBudW1iZXI7XG4gICAgdGlja3M/OiBTbGlkZXJUaWNrc09wdGlvbnM7XG4gICAgY29sb3JzPzogU2xpZGVyVHJhY2tDb2xvcnM7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2xpZGVyVGlja3NPcHRpb25zIHtcbiAgICBzbmFwPzogU2xpZGVyU25hcDtcbiAgICBtYWpvcj86IFNsaWRlclRpY2tPcHRpb25zO1xuICAgIG1pbm9yPzogU2xpZGVyVGlja09wdGlvbnM7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2xpZGVyVGlja09wdGlvbnMge1xuICAgIHNob3c/OiBib29sZWFuO1xuICAgIHN0ZXBzPzogbnVtYmVyIHwgbnVtYmVyW107XG4gICAgbGFiZWxzPzogYm9vbGVhbjtcbiAgICBmb3JtYXR0ZXI/OiAodmFsdWU6IG51bWJlcikgPT4gc3RyaW5nIHwgbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNsaWRlclRpY2sge1xuICAgIHNob3dUaWNrczogYm9vbGVhbjtcbiAgICBzaG93TGFiZWxzOiBib29sZWFuO1xuICAgIHR5cGU6IFNsaWRlclRpY2tUeXBlO1xuICAgIHBvc2l0aW9uOiBudW1iZXI7XG4gICAgdmFsdWU6IG51bWJlcjtcbiAgICBsYWJlbDogc3RyaW5nIHwgbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNsaWRlclRyYWNrQ29sb3JzIHtcbiAgICBsb3dlcj86IHN0cmluZyB8IHN0cmluZ1tdO1xuICAgIHJhbmdlPzogc3RyaW5nIHwgc3RyaW5nW107XG4gICAgaGlnaGVyPzogc3RyaW5nIHwgc3RyaW5nW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2xpZGVyQ2FsbG91dCB7XG4gICAgdHJpZ2dlcj86IFNsaWRlckNhbGxvdXRUcmlnZ2VyO1xuICAgIGJhY2tncm91bmQ/OiBzdHJpbmc7XG4gICAgY29sb3I/OiBzdHJpbmc7XG4gICAgZm9ybWF0dGVyPzogKHZhbHVlOiBudW1iZXIpID0+IHN0cmluZyB8IG51bWJlcjtcbn1cblxuZXhwb3J0IGVudW0gU2xpZGVyVGh1bWJFdmVudCB7XG4gICAgTm9uZSxcbiAgICBNb3VzZU92ZXIsXG4gICAgTW91c2VMZWF2ZSxcbiAgICBEcmFnU3RhcnQsXG4gICAgRHJhZ0VuZFxufVxuXG5leHBvcnQgZW51bSBTbGlkZXJUaHVtYiB7XG4gICAgTG93ZXIsXG4gICAgVXBwZXJcbn0iLCJpbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbG9yU2VydmljZU1vZHVsZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2NvbG9yL2luZGV4JztcblxuaW1wb3J0IHsgU2xpZGVyQ29tcG9uZW50IH0gZnJvbSAnLi9zbGlkZXIuY29tcG9uZW50JztcbmltcG9ydCB7IERyYWdNb2R1bGUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL2RyYWcvaW5kZXgnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBDb2xvclNlcnZpY2VNb2R1bGUsXG4gICAgICAgIERyYWdNb2R1bGVcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtTbGlkZXJDb21wb25lbnRdLFxuICAgIGRlY2xhcmF0aW9uczogW1NsaWRlckNvbXBvbmVudF1cbn0pXG5leHBvcnQgY2xhc3MgU2xpZGVyTW9kdWxlIHsgfSIsImltcG9ydCB7IENvbXBvbmVudCwgT25EZXN0cm95LCBPbkluaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IHRpbWVyIH0gZnJvbSAncnhqcy9vYnNlcnZhYmxlL3RpbWVyJztcbmltcG9ydCB7IHN3aXRjaE1hcCwgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XG5pbXBvcnQgeyBTbGlkZXJPcHRpb25zLCBTbGlkZXJTaXplIH0gZnJvbSAnLi4vLi4vLi4vc2xpZGVyL2luZGV4JztcbmltcG9ydCB7IE1lZGlhUGxheWVyQmFzZUV4dGVuc2lvbkRpcmVjdGl2ZSB9IGZyb20gJy4uL2Jhc2UtZXh0ZW5zaW9uLmRpcmVjdGl2ZSc7XG5cbmxldCB1bmlxdWVJZDogbnVtYmVyID0gMTtcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1tZWRpYS1wbGF5ZXItY29udHJvbHMnLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9jb250cm9scy5jb21wb25lbnQuaHRtbCcsXG4gICAgaG9zdDoge1xuICAgICAgICAnW2NsYXNzLnF1aWV0XSc6ICdtZWRpYVBsYXllclNlcnZpY2UucXVpZXRNb2RlIHx8IG1lZGlhUGxheWVyU2VydmljZS5mdWxsc2NyZWVuJ1xuICAgIH1cbn0pXG5leHBvcnQgY2xhc3MgTWVkaWFQbGF5ZXJDb250cm9sc0V4dGVuc2lvbkNvbXBvbmVudCBleHRlbmRzIE1lZGlhUGxheWVyQmFzZUV4dGVuc2lvbkRpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcblxuICAgIHZvbHVtZUFjdGl2ZTogYm9vbGVhbiA9IGZhbHNlO1xuICAgIHZvbHVtZUZvY3VzOiBib29sZWFuID0gZmFsc2U7XG4gICAgcmV0dXJuRm9jdXM6IGJvb2xlYW4gPSB0cnVlO1xuICAgIHN1YnRpdGxlc0lkOiBzdHJpbmcgPSBgdXgtbWVkaWEtcGxheWVyLXN1YnRpdGxlLXBvcG92ZXItJHt1bmlxdWVJZCsrfWA7XG4gICAgc3VidGl0bGVzT3BlbjogYm9vbGVhbiA9IGZhbHNlO1xuICAgIG1vdXNlRW50ZXJWb2x1bWUgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuICAgIG1vdXNlTGVhdmVWb2x1bWUgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gICAgb3B0aW9uczogU2xpZGVyT3B0aW9ucyA9IHtcbiAgICAgICAgaGFuZGxlczoge1xuICAgICAgICAgICAgYXJpYToge1xuICAgICAgICAgICAgICAgIHRodW1iOiAnVm9sdW1lJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0cmFjazoge1xuICAgICAgICAgICAgY29sb3JzOiB7XG4gICAgICAgICAgICAgICAgbG93ZXI6ICcjNjY2J1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhlaWdodDogU2xpZGVyU2l6ZS5OYXJyb3csXG4gICAgICAgICAgICB0aWNrczoge1xuICAgICAgICAgICAgICAgIG1ham9yOiB7XG4gICAgICAgICAgICAgICAgICAgIHNob3c6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBtaW5vcjoge1xuICAgICAgICAgICAgICAgICAgICBzaG93OiBmYWxzZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBwcml2YXRlIF92b2x1bWU6IG51bWJlciA9IDUwO1xuICAgIHByaXZhdGUgX3ByZXZpb3VzVm9sdW1lID0gNTA7XG4gICAgcHJpdmF0ZSBfb25EZXN0cm95ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICAgIGdldCB2b2x1bWUoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZvbHVtZTtcbiAgICB9XG5cbiAgICBzZXQgdm9sdW1lKHZhbHVlOiBudW1iZXIpIHtcblxuICAgICAgICBpZiAodmFsdWUgPT09IDAgJiYgdGhpcy5fdm9sdW1lICE9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9wcmV2aW91c1ZvbHVtZSA9IHRoaXMuX3ZvbHVtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3ZvbHVtZSA9IE1hdGgubWluKE1hdGgubWF4KHZhbHVlLCAwKSwgMTAwKTtcbiAgICAgICAgdGhpcy5tZWRpYVBsYXllclNlcnZpY2Uudm9sdW1lID0gdGhpcy5fdm9sdW1lIC8gMTAwO1xuICAgIH1cblxuICAgIG5nT25Jbml0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLm1lZGlhUGxheWVyU2VydmljZS52b2x1bWVDaGFuZ2VFdmVudC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUodm9sdW1lID0+IHRoaXMudm9sdW1lID0gdm9sdW1lICogMTAwKTtcbiAgICAgICAgdGhpcy5tZWRpYVBsYXllclNlcnZpY2UuaW5pdEV2ZW50LnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZSgoKSA9PiB0aGlzLnZvbHVtZSA9IHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLnZvbHVtZSAqIDEwMCk7XG5cbiAgICAgICAgdGhpcy5tb3VzZUVudGVyVm9sdW1lLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZSgoKSA9PiB0aGlzLnZvbHVtZUFjdGl2ZSA9IHRydWUpO1xuICAgICAgICB0aGlzLm1vdXNlTGVhdmVWb2x1bWUucGlwZShcbiAgICAgICAgICAgIHN3aXRjaE1hcCgoKSA9PiB0aW1lcigxNTAwKS5waXBlKHRha2VVbnRpbCh0aGlzLm1vdXNlRW50ZXJWb2x1bWUpKSksIHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpXG4gICAgICAgICkuc3Vic2NyaWJlKCgpID0+IHRoaXMudm9sdW1lQWN0aXZlID0gZmFsc2UpO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kubmV4dCgpO1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kuY29tcGxldGUoKTtcbiAgICB9XG5cbiAgICB0b2dnbGVNdXRlKCk6IHZvaWQge1xuICAgICAgICB0aGlzLnZvbHVtZSA9IHRoaXMudm9sdW1lID09PSAwID8gdGhpcy5fcHJldmlvdXNWb2x1bWUgOiAwO1xuICAgIH1cblxuICAgIGdvVG9TdGFydCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5tZWRpYVBsYXllclNlcnZpY2UuY3VycmVudFRpbWUgPSAwO1xuICAgIH1cblxuICAgIGdvVG9FbmQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLmN1cnJlbnRUaW1lID0gdGhpcy5tZWRpYVBsYXllclNlcnZpY2UuZHVyYXRpb247XG4gICAgfVxuXG4gICAgaXNTdWJ0aXRsZUFjdGl2ZSgpOiBib29sZWFuIHtcbiAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgdGhpcy5tZWRpYVBsYXllclNlcnZpY2UudGV4dFRyYWNrcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tZWRpYVBsYXllclNlcnZpY2UudGV4dFRyYWNrc1tpZHhdLm1vZGUgPT09ICdzaG93aW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHNldFN1YnRpdGxlVHJhY2sodHJhY2s6IFRleHRUcmFjayk6IHZvaWQge1xuICAgICAgICAvLyBoaWRlIGFsbCB0cmFja3NcbiAgICAgICAgdGhpcy5tZWRpYVBsYXllclNlcnZpY2UuaGlkZVN1YnRpdGxlVHJhY2tzKCk7XG5cbiAgICAgICAgLy8gc2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgc3VidGl0bGUgdHJhY2tcbiAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgdHJhY2suY3Vlcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgICBjb25zdCBjdWU6IGFueSA9IHRyYWNrLmN1ZXNbaWR4XTtcbiAgICAgICAgICAgIGN1ZS5saW5lID0gLTM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhY3RpdmF0ZSB0aGUgc2VsZWN0ZWQgb25lXG4gICAgICAgIHRyYWNrLm1vZGUgPSAnc2hvd2luZyc7XG5cbiAgICB9XG5cbiAgICBnZXRTdWJ0aXRsZVRyYWNrKCk6IHN0cmluZyB7XG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLnRleHRUcmFja3MubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLnRleHRUcmFja3NbaWR4XS5tb2RlID09PSAnc2hvd2luZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tZWRpYVBsYXllclNlcnZpY2UudGV4dFRyYWNrc1tpZHhdLmxhYmVsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICdObyBzdWJ0aXRsZXMnO1xuICAgIH1cblxufSIsImltcG9ydCB7IERpcmVjdGl2ZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1t1eE1lZGlhUGxheWVyQ3VzdG9tQ29udHJvbF0nLFxufSlcbmV4cG9ydCBjbGFzcyBNZWRpYVBsYXllckN1c3RvbUNvbnRyb2xEaXJlY3RpdmUge30iLCJpbXBvcnQgeyBBZnRlclZpZXdJbml0LCBDb21wb25lbnQsIEVsZW1lbnRSZWYsIE9uRGVzdHJveSwgT25Jbml0LCBWaWV3Q2hpbGQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGZyb21FdmVudCB9IGZyb20gJ3J4anMvb2JzZXJ2YWJsZS9mcm9tRXZlbnQnO1xuaW1wb3J0IHsgc3dpdGNoTWFwLCB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcbmltcG9ydCB7IE1lZGlhUGxheWVyQmFzZUV4dGVuc2lvbkRpcmVjdGl2ZSB9IGZyb20gJy4uL2Jhc2UtZXh0ZW5zaW9uLmRpcmVjdGl2ZSc7XG5cblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1tZWRpYS1wbGF5ZXItdGltZWxpbmUnLFxuICAgIHRlbXBsYXRlVXJsOiAnLi90aW1lbGluZS5jb21wb25lbnQuaHRtbCcsXG4gICAgaG9zdDoge1xuICAgICAgICAnKGRvY3VtZW50Om1vdXNldXApJzogJ21vdXNlRG93biA9IGZhbHNlJyxcbiAgICAgICAgJ1tjbGFzcy5xdWlldF0nOiAnbWVkaWFQbGF5ZXJTZXJ2aWNlLnF1aWV0TW9kZSB8fCBtZWRpYVBsYXllclNlcnZpY2UuZnVsbHNjcmVlbidcbiAgICB9XG59KVxuZXhwb3J0IGNsYXNzIE1lZGlhUGxheWVyVGltZWxpbmVFeHRlbnNpb25Db21wb25lbnQgZXh0ZW5kcyBNZWRpYVBsYXllckJhc2VFeHRlbnNpb25EaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIEFmdGVyVmlld0luaXQsIE9uRGVzdHJveSB7XG5cbiAgICBAVmlld0NoaWxkKCdwcm9ncmVzc1RodW1iJykgdGh1bWI6IEVsZW1lbnRSZWY7XG4gICAgQFZpZXdDaGlsZCgndGltZWxpbmUnKSB0aW1lbGluZVJlZjogRWxlbWVudFJlZjtcblxuICAgIGN1cnJlbnQ6IG51bWJlciA9IDA7XG4gICAgcG9zaXRpb246IG51bWJlciA9IDA7XG4gICAgYnVmZmVyZWQ6IE1lZGlhUGxheWVyQnVmZmVyZWRbXSA9IFtdO1xuICAgIG1vdXNlRG93bjogYm9vbGVhbiA9IGZhbHNlO1xuICAgIHNjcnViID0geyB2aXNpYmxlOiBmYWxzZSwgcG9zaXRpb246IDAsIHRpbWU6IDAgfTtcblxuICAgIHByaXZhdGUgX29uRGVzdHJveSA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgICBuZ09uSW5pdCgpOiB2b2lkIHtcblxuICAgICAgICAvLyB3YXRjaCBmb3IgY2hhbmdlcyB0byB0aGUgY3VycmVudCB0aW1lXG4gICAgICAgIHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLmZ1bGxzY3JlZW5FdmVudC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUoZnVsbHNjcmVlbiA9PiB7XG4gICAgICAgICAgICB0aGlzLnNjcnViLnBvc2l0aW9uID0gMDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5tZWRpYVBsYXllclNlcnZpY2UudGltZVVwZGF0ZUV2ZW50LnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZShjdXJyZW50ID0+IHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudCA9IGN1cnJlbnQ7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gKHRoaXMuY3VycmVudCAvIHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLmR1cmF0aW9uKSAqIDEwMDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5tZWRpYVBsYXllclNlcnZpY2UucHJvZ3Jlc3NFdmVudC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUoKGJ1ZmZlcmVkOiBUaW1lUmFuZ2VzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcmVkID0gW107XG5cbiAgICAgICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IGJ1ZmZlcmVkLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlcmVkLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogKGJ1ZmZlcmVkLnN0YXJ0KGlkeCkgLyB0aGlzLm1lZGlhUGxheWVyU2VydmljZS5kdXJhdGlvbikgKiAxMDAsXG4gICAgICAgICAgICAgICAgICAgIGVuZDogKGJ1ZmZlcmVkLmVuZChpZHgpIC8gdGhpcy5tZWRpYVBsYXllclNlcnZpY2UuZHVyYXRpb24pICogMTAwXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgbW91c2Vkb3duJCA9IGZyb21FdmVudCh0aGlzLnRodW1iLm5hdGl2ZUVsZW1lbnQsICdtb3VzZWRvd24nKTtcbiAgICAgICAgY29uc3QgbW91c2Vtb3ZlJCA9IGZyb21FdmVudChkb2N1bWVudCwgJ21vdXNlbW92ZScpO1xuICAgICAgICBjb25zdCBtb3VzZXVwJCA9IGZyb21FdmVudChkb2N1bWVudCwgJ21vdXNldXAnKTtcblxuICAgICAgICBtb3VzZWRvd24kLnBpcGUoXG4gICAgICAgICAgICBzd2l0Y2hNYXAoKCkgPT4gbW91c2Vtb3ZlJC5waXBlKHRha2VVbnRpbChtb3VzZXVwJCkpKSxcbiAgICAgICAgICAgIHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpXG4gICAgICAgICkuc3Vic2NyaWJlKCgpID0+IHRoaXMuc2NydWIudmlzaWJsZSA9IGZhbHNlKTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fb25EZXN0cm95Lm5leHQoKTtcbiAgICAgICAgdGhpcy5fb25EZXN0cm95LmNvbXBsZXRlKCk7XG4gICAgfVxuXG4gICAgdXBkYXRlU2NydWIoZXZlbnQ6IE1vdXNlRXZlbnQpOiB2b2lkIHtcblxuICAgICAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQgYXMgSFRNTEVsZW1lbnQ7XG5cbiAgICAgICAgaWYgKHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ21lZGlhLXByb2dyZXNzLWJhci10aHVtYicpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0aW1lbGluZSA9IHRoaXMudGltZWxpbmVSZWYubmF0aXZlRWxlbWVudCBhcyBIVE1MRGl2RWxlbWVudDtcbiAgICAgICAgY29uc3QgYm91bmRzID0gdGltZWxpbmUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgdGhpcy5zY3J1Yi5wb3NpdGlvbiA9IGV2ZW50Lm9mZnNldFg7XG4gICAgICAgIHRoaXMuc2NydWIudGltZSA9IChldmVudC5vZmZzZXRYIC8gYm91bmRzLndpZHRoKSAqIHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLmR1cmF0aW9uO1xuXG4gICAgICAgIGlmICh0aGlzLm1vdXNlRG93bikge1xuICAgICAgICAgICAgdGhpcy5tZWRpYVBsYXllclNlcnZpY2UucGF1c2UoKTtcbiAgICAgICAgICAgIHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLmN1cnJlbnRUaW1lID0gdGhpcy5zY3J1Yi50aW1lO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIFNraXAgYSBudW1iZXIgb2Ygc2Vjb25kcyBpbiBhbnkgZGlyZWN0aW9uICovXG4gICAgc2tpcChzZWNvbmRzOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgbGV0IHRhcmdldCA9IHRoaXMuY3VycmVudCArIHNlY29uZHM7XG5cbiAgICAgICAgLy8gZW5zdXJlIHRoYXQgdGhlIHRhcmdldCBwb3NpdGlvbiBpcyB3aXRoaW4gdGhlIGJvdW5kcyBvZiB0aGUgY2xpcFxuICAgICAgICBpZiAodGFyZ2V0IDwgMCkge1xuICAgICAgICAgICAgdGFyZ2V0ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0YXJnZXQgPiB0aGlzLm1lZGlhUGxheWVyU2VydmljZS5kdXJhdGlvbikge1xuICAgICAgICAgICAgdGFyZ2V0ID0gdGhpcy5tZWRpYVBsYXllclNlcnZpY2UuZHVyYXRpb247XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1lZGlhUGxheWVyU2VydmljZS5jdXJyZW50VGltZSA9IHRhcmdldDtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWVkaWFQbGF5ZXJCdWZmZXJlZCB7XG4gICAgc3RhcnQ6IG51bWJlcjtcbiAgICBlbmQ6IG51bWJlcjtcbn1cbiIsImltcG9ydCB7IEh0dHBDbGllbnQgfSBmcm9tICdAYW5ndWxhci9jb21tb24vaHR0cCc7XG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcy9PYnNlcnZhYmxlJztcbmltcG9ydCB7IG9mIH0gZnJvbSAncnhqcy9vYnNlcnZhYmxlL29mJztcbmltcG9ydCB7IE9ic2VydmVyIH0gZnJvbSAncnhqcy9PYnNlcnZlcic7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBBdWRpb1NlcnZpY2Uge1xuXG4gICAgcHJpdmF0ZSBfYXVkaW9CdWZmZXI6IEF1ZGlvQnVmZmVyO1xuICAgIHByaXZhdGUgX2F1ZGlvQnVmZmVyU291cmNlOiBBdWRpb0J1ZmZlclNvdXJjZU5vZGU7XG4gICAgcHJpdmF0ZSBfYXVkaW9Db250ZXh0OiBBdWRpb0NvbnRleHQ7XG4gICAgcHJpdmF0ZSBfZ2Fpbk5vZGU6IEdhaW5Ob2RlO1xuICAgIHByaXZhdGUgX2FuYWx5c2VyTm9kZTogQW5hbHlzZXJOb2RlO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfaHR0cDogSHR0cENsaWVudCkgeyB9XG5cbiAgICBnZXRBdWRpb0ZpbGVNZXRhZGF0YShtZWRpYUVsZW1lbnQ6IEhUTUxNZWRpYUVsZW1lbnQpOiBPYnNlcnZhYmxlPEF1ZGlvTWV0YWRhdGE+IHtcbiAgICAgICAgcmV0dXJuIE9ic2VydmFibGUuY3JlYXRlKChvYnNlcnZlcjogT2JzZXJ2ZXI8QXVkaW9NZXRhZGF0YT4pID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2h0dHAuZ2V0KG1lZGlhRWxlbWVudC5zcmMsIHsgcmVzcG9uc2VUeXBlOiAnYmxvYicgfSkuc3Vic2NyaWJlKHJlc3BvbnNlID0+IHtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVuYW1lID0gbWVkaWFFbGVtZW50LnNyYy5zdWJzdHJpbmcobWVkaWFFbGVtZW50LnNyYy5sYXN0SW5kZXhPZignLycpICsgMSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZXh0ZW5zaW9uID0gbWVkaWFFbGVtZW50LnNyYy5zdWJzdHJpbmcobWVkaWFFbGVtZW50LnNyYy5sYXN0SW5kZXhPZignLicpICsgMSkudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgICAgICAgIGxldCBkZXNjcmlwdGlvbjtcblxuICAgICAgICAgICAgICAgIHN3aXRjaCAoZXh0ZW5zaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ21wMyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbiA9ICdNUEVHIGF1ZGlvIGxheWVyIDMgZmlsZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICd3bWEnOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb24gPSAnV2luZG93cyBtZWRpYSBhdWRpbyBmaWxlJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3dhdic6XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbiA9ICdXQVZFIGF1ZGlvIGZpbGUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnb2dnJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uID0gJ09nZyBWb3JiaXMgZmlsZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdhYWMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb24gPSAnQWR2YW5jZWQgYXVkaW8gY29kaW5nIGZpbGUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWlkaSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbiA9ICdNdXNpY2FsIGluc3RydW1lbnQgZGlnaXRhbCBpbnRlcmZhY2UgZmlsZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb24gPSAnQXVkaW8gZmlsZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KHtcbiAgICAgICAgICAgICAgICAgICAgZmlsZW5hbWU6IGZpbGVuYW1lLFxuICAgICAgICAgICAgICAgICAgICBleHRlbnNpb246IGV4dGVuc2lvbixcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgICAgICBzaXplOiByZXNwb25zZS5zaXplXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZ2V0V2F2ZWZvcm1Gcm9tVXJsKHVybDogc3RyaW5nKTogT2JzZXJ2YWJsZTxGbG9hdDMyQXJyYXlbXT4ge1xuXG4gICAgICAgIC8vIGlmIGF1ZGlvIGNvbnRleHQgaXMgbm90IHN1cHBvcnQgcmV0dXJuIGEgc3RyZWFtIG9mIGVtcHR5IGRhdGFcbiAgICAgICAgaWYgKCEoPGFueT53aW5kb3cpLkF1ZGlvQ29udGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIG9mPEZsb2F0MzJBcnJheVtdPihbbmV3IEZsb2F0MzJBcnJheSgwKV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fYXVkaW9Db250ZXh0ID0gbmV3IEF1ZGlvQ29udGV4dCgpO1xuICAgICAgICB0aGlzLmNyZWF0ZVZvbHVtZU5vZGUoKTtcbiAgICAgICAgdGhpcy5jcmVhdGVBbmFseXNlck5vZGUoKTtcblxuICAgICAgICByZXR1cm4gT2JzZXJ2YWJsZS5jcmVhdGUoKG9ic2VydmVyOiBPYnNlcnZlcjxGbG9hdDMyQXJyYXlbXT4pID0+IHtcblxuICAgICAgICAgICAgLy8gbG9hZCB0aGUgbWVkaWEgZnJvbSB0aGUgVVJMIHByb3ZpZGVkXG4gICAgICAgICAgICB0aGlzLl9odHRwLmdldCh1cmwsIHsgcmVzcG9uc2VUeXBlOiAnYXJyYXlidWZmZXInIH0pLnN1YnNjcmliZShyZXNwb25zZSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRBdWRpb0J1ZmZlcihyZXNwb25zZSkuc3Vic2NyaWJlKGF1ZGlvQnVmZmVyID0+IHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGUgdGhlIGJ1ZmZlciBzb3VyY2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVCdWZmZXJTb3VyY2UoYXVkaW9CdWZmZXIpO1xuXG4gICAgICAgICAgICAgICAgICAgIGxldCBkYXRhUG9pbnRzOiBGbG9hdDMyQXJyYXlbXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGFubmVscyA9IHRoaXMuX2F1ZGlvQnVmZmVyLm51bWJlck9mQ2hhbm5lbHM7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZXh0cmFjdCB0aGUgZGF0YSBmcm9tIGVhY2ggY2hhbm5lbFxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBjaGFubmVsSWR4ID0gMDsgY2hhbm5lbElkeCA8IGNoYW5uZWxzOyBjaGFubmVsSWR4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFQb2ludHNbY2hhbm5lbElkeF0gPSB0aGlzLl9hdWRpb0J1ZmZlci5nZXRDaGFubmVsRGF0YShjaGFubmVsSWR4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLm5leHQoZGF0YVBvaW50cyk7XG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmVyLmNvbXBsZXRlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY2xlYW51cCBhZnRlciBvdXJzZWx2ZXNcbiAgICAgICAgICAgICAgICAgICAgZGF0YVBvaW50cyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSwgKGVycm9yKSA9PiBvYnNlcnZlci5lcnJvcihlcnJvcikpO1xuICAgICAgICAgICAgfSwgKGVycm9yKSA9PiBvYnNlcnZlci5lcnJvcihlcnJvcikpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBnZXRXYXZlZm9ybVBvaW50cyhjaGFubmVsczogRmxvYXQzMkFycmF5W10gPSBbXSwgc2tpcDogbnVtYmVyID0gMTAwMCk6IFdhdmVmb3JtUG9pbnRbXSB7XG5cbiAgICAgICAgY29uc3Qgd2F2ZWZvcm06IFdhdmVmb3JtUG9pbnRbXSA9IFtdO1xuICAgICAgICBjb25zdCBkdXJhdGlvbiA9IGNoYW5uZWxzLmxlbmd0aCA+IDAgPyBjaGFubmVsc1swXS5sZW5ndGggOiAwO1xuXG4gICAgICAgIC8vIGNvbnZlcnQgZWFjaCBjaGFubmVsIGRhdGEgdG8gYSBzZXJpZXMgb2Ygd2F2ZWZvcm0gcG9pbnRzXG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IGR1cmF0aW9uOyBpZHggKz0gc2tpcCkge1xuXG4gICAgICAgICAgICAvLyBnZXQgYWxsIHRoZSBjaGFubmVsIGRhdGEgZm9yIGEgc3BlY2lmaWMgcG9pbnRcbiAgICAgICAgICAgIGNvbnN0IHBvaW50cyA9IGNoYW5uZWxzLm1hcChjaGFubmVsID0+IGNoYW5uZWxbaWR4XSk7XG5cbiAgICAgICAgICAgIC8vIGZpbmQgdGhlIG1pbmltdW0gcG9pbnQgYW5kIG1heGltdW0gcG9pbnRzIGF0IGVhY2ggcG9zaXRpb24gYWNyb3NzIGFsbCBjaGFubmVsc1xuICAgICAgICAgICAgd2F2ZWZvcm0ucHVzaCh7XG4gICAgICAgICAgICAgICAgbWluOiBwb2ludHMucmVkdWNlKChwcmV2aW91cywgY3VycmVudCkgPT4gY3VycmVudCA8IHByZXZpb3VzID8gY3VycmVudCA6IHByZXZpb3VzKSxcbiAgICAgICAgICAgICAgICBtYXg6IHBvaW50cy5yZWR1Y2UoKHByZXZpb3VzLCBjdXJyZW50KSA9PiBjdXJyZW50ID4gcHJldmlvdXMgPyBjdXJyZW50IDogcHJldmlvdXMpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB3YXZlZm9ybTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldEF1ZGlvQnVmZmVyKGFycmF5QnVmZmVyOiBBcnJheUJ1ZmZlcik6IE9ic2VydmFibGU8QXVkaW9CdWZmZXI+IHtcbiAgICAgICAgcmV0dXJuIE9ic2VydmFibGUuY3JlYXRlKChvYnNlcnZlcjogT2JzZXJ2ZXI8QXVkaW9CdWZmZXI+KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmdldE9mZmxpbmVBdWRpb0NvbnRleHQoKS5kZWNvZGVBdWRpb0RhdGEoYXJyYXlCdWZmZXIsIChhdWRpb0J1ZmZlcjogQXVkaW9CdWZmZXIpID0+IHtcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5uZXh0KGF1ZGlvQnVmZmVyKTtcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgfSwgKGVycm9yKSA9PiBvYnNlcnZlci5lcnJvcihlcnJvcikpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldE9mZmxpbmVBdWRpb0NvbnRleHQoKTogT2ZmbGluZUF1ZGlvQ29udGV4dCB7XG4gICAgICAgIHJldHVybiBuZXcgT2ZmbGluZUF1ZGlvQ29udGV4dCgxLCAyLCB0aGlzLl9hdWRpb0NvbnRleHQuc2FtcGxlUmF0ZSB8fCA0NDEwMCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmVhdGVCdWZmZXJTb3VyY2UoYXVkaW9CdWZmZXI6IEF1ZGlvQnVmZmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdFNvdXJjZSgpO1xuXG4gICAgICAgIHRoaXMuX2F1ZGlvQnVmZmVyID0gYXVkaW9CdWZmZXI7XG4gICAgICAgIHRoaXMuX2F1ZGlvQnVmZmVyU291cmNlID0gdGhpcy5fYXVkaW9Db250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpO1xuICAgICAgICB0aGlzLl9hdWRpb0J1ZmZlclNvdXJjZS5idWZmZXIgPSB0aGlzLl9hdWRpb0J1ZmZlcjtcbiAgICAgICAgdGhpcy5fYXVkaW9CdWZmZXJTb3VyY2UuY29ubmVjdCh0aGlzLl9hbmFseXNlck5vZGUpO1xuICAgIH1cblxuICAgIHByaXZhdGUgY3JlYXRlVm9sdW1lTm9kZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fZ2Fpbk5vZGUgPSB0aGlzLl9hdWRpb0NvbnRleHQuY3JlYXRlR2FpbigpO1xuICAgICAgICB0aGlzLl9nYWluTm9kZS5jb25uZWN0KHRoaXMuX2F1ZGlvQ29udGV4dC5kZXN0aW5hdGlvbik7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjcmVhdGVBbmFseXNlck5vZGUoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2FuYWx5c2VyTm9kZSA9IHRoaXMuX2F1ZGlvQ29udGV4dC5jcmVhdGVBbmFseXNlcigpO1xuICAgICAgICB0aGlzLl9hbmFseXNlck5vZGUuY29ubmVjdCh0aGlzLl9nYWluTm9kZSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBkaXNjb25uZWN0U291cmNlKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5fYXVkaW9CdWZmZXJTb3VyY2UpIHtcbiAgICAgICAgICAgIHRoaXMuX2F1ZGlvQnVmZmVyU291cmNlLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBXYXZlZm9ybVBvaW50IHtcbiAgICBtaW46IG51bWJlcjtcbiAgICBtYXg6IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBdWRpb01ldGFkYXRhIHtcbiAgICBmaWxlbmFtZTogc3RyaW5nO1xuICAgIGV4dGVuc2lvbjogc3RyaW5nO1xuICAgIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gICAgc2l6ZTogbnVtYmVyO1xufSIsImltcG9ydCB7IEh0dHBDbGllbnRNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24vaHR0cCc7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQXVkaW9TZXJ2aWNlIH0gZnJvbSAnLi9hdWRpby5zZXJ2aWNlJztcblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbIEh0dHBDbGllbnRNb2R1bGUgXSxcbiAgICBwcm92aWRlcnM6IFtBdWRpb1NlcnZpY2VdXG59KVxuZXhwb3J0IGNsYXNzIEF1ZGlvU2VydmljZU1vZHVsZSB7IH1cbiIsImltcG9ydCB7IEFmdGVyVmlld0luaXQsIENvbXBvbmVudCwgRWxlbWVudFJlZiwgSW5wdXQsIE9uRGVzdHJveSwgVmlld0NoaWxkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcy9PYnNlcnZhYmxlJztcbmltcG9ydCB7IGZyb21FdmVudCB9IGZyb20gJ3J4anMvb2JzZXJ2YWJsZS9mcm9tRXZlbnQnO1xuaW1wb3J0IHsgZGVib3VuY2VUaW1lLCB0YWtlVW50aWwsIHRhcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzL1N1YmplY3QnO1xuaW1wb3J0IHsgQXVkaW9NZXRhZGF0YSwgQXVkaW9TZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvYXVkaW8vaW5kZXgnO1xuaW1wb3J0IHsgTWVkaWFQbGF5ZXJTZXJ2aWNlIH0gZnJvbSAnLi9tZWRpYS1wbGF5ZXIuc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtbWVkaWEtcGxheWVyJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vbWVkaWEtcGxheWVyLmNvbXBvbmVudC5odG1sJyxcbiAgICBwcm92aWRlcnM6IFtNZWRpYVBsYXllclNlcnZpY2VdLFxuICAgIGhvc3Q6IHtcbiAgICAgICAgJyhrZXlkb3duLlNwYWNlKSc6ICdtZWRpYVBsYXllclNlcnZpY2UudG9nZ2xlUGxheSgpOyAkZXZlbnQucHJldmVudERlZmF1bHQoKScsXG4gICAgICAgICdbY2xhc3Muc3RhbmRhcmRdJzogJyFtZWRpYVBsYXllclNlcnZpY2UuZnVsbHNjcmVlbicsXG4gICAgICAgICdbY2xhc3MuZnVsbHNjcmVlbl0nOiAnbWVkaWFQbGF5ZXJTZXJ2aWNlLmZ1bGxzY3JlZW4nLFxuICAgICAgICAnW2NsYXNzLnF1aWV0XSc6ICdxdWlldE1vZGUgJiYgdHlwZSA9PT0gXCJ2aWRlb1wiIHx8IG1lZGlhUGxheWVyU2VydmljZS5mdWxsc2NyZWVuJyxcbiAgICAgICAgJ1tjbGFzcy5ob3Zlcl0nOiAnaG92ZXJpbmcgfHwgZm9jdXNlZCcsXG4gICAgICAgICdbY2xhc3MudmlkZW9dJzogJ3R5cGUgPT09IFwidmlkZW9cIicsXG4gICAgICAgICdbY2xhc3MuYXVkaW9dJzogJ3R5cGUgPT09IFwiYXVkaW9cIicsXG4gICAgICAgICcobW91c2VlbnRlciknOiAnaG92ZXJpbmcgPSB0cnVlJyxcbiAgICAgICAgJyhtb3VzZWxlYXZlKSc6ICdob3ZlcmluZyA9IGZhbHNlJyxcbiAgICAgICAgJyhkb2N1bWVudDp3ZWJraXRmdWxsc2NyZWVuY2hhbmdlKSc6ICdtZWRpYVBsYXllclNlcnZpY2UuZnVsbHNjcmVlbkNoYW5nZSgpJyxcbiAgICAgICAgJyhkb2N1bWVudDptb3pmdWxsc2NyZWVuY2hhbmdlKSc6ICdtZWRpYVBsYXllclNlcnZpY2UuZnVsbHNjcmVlbkNoYW5nZSgpJyxcbiAgICAgICAgJyhkb2N1bWVudDpNU0Z1bGxzY3JlZW5DaGFuZ2UpJzogJ21lZGlhUGxheWVyU2VydmljZS5mdWxsc2NyZWVuQ2hhbmdlKCknXG4gICAgfVxufSlcbmV4cG9ydCBjbGFzcyBNZWRpYVBsYXllckNvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQsIE9uRGVzdHJveSB7XG5cbiAgICBAVmlld0NoaWxkKCdwbGF5ZXInKSBwcml2YXRlIF9wbGF5ZXJSZWY6IEVsZW1lbnRSZWY7XG5cbiAgICBob3ZlcmluZzogYm9vbGVhbiA9IGZhbHNlO1xuICAgIGZvY3VzZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBhdWRpb01ldGFkYXRhOiBPYnNlcnZhYmxlPEF1ZGlvTWV0YWRhdGE+O1xuXG4gICAgQElucHV0KCkgY3Jvc3NvcmlnaW46ICd1c2UtY3JlZGVudGlhbHMnIHwgJ2Fub255bW91cycgPSAndXNlLWNyZWRlbnRpYWxzJztcblxuICAgIGdldCBzb3VyY2UoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLnNvdXJjZTtcbiAgICB9XG5cbiAgICBASW5wdXQoKVxuICAgIHNldCBzb3VyY2UodmFsdWU6IHN0cmluZykge1xuICAgICAgICB0aGlzLm1lZGlhUGxheWVyU2VydmljZS5zb3VyY2UgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBnZXQgdHlwZSgpOiBNZWRpYVBsYXllclR5cGUge1xuICAgICAgICByZXR1cm4gdGhpcy5tZWRpYVBsYXllclNlcnZpY2UudHlwZTtcbiAgICB9XG5cbiAgICBASW5wdXQoKVxuICAgIHNldCB0eXBlKHZhbHVlOiBNZWRpYVBsYXllclR5cGUpIHtcbiAgICAgICAgdGhpcy5tZWRpYVBsYXllclNlcnZpY2UudHlwZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIGdldCBxdWlldE1vZGUoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lZGlhUGxheWVyU2VydmljZS5xdWlldE1vZGU7XG4gICAgfVxuXG4gICAgQElucHV0KClcbiAgICBzZXQgcXVpZXRNb2RlKHZhbHVlOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLnF1aWV0TW9kZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHByaXZhdGUgX29uRGVzdHJveSA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgbWVkaWFQbGF5ZXJTZXJ2aWNlOiBNZWRpYVBsYXllclNlcnZpY2UsIHByaXZhdGUgX2F1ZGlvU2VydmljZTogQXVkaW9TZXJ2aWNlLCBwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmKSB7XG5cbiAgICAgICAgLy8gc2hvdyBjb250cm9scyB3aGVuIGhvdmVyaW5nIGFuZCBpbiBxdWlldCBtb2RlXG4gICAgICAgIGZyb21FdmVudCh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdtb3VzZW1vdmUnKS5waXBlKFxuICAgICAgICAgICAgdGFwKCgpID0+IHRoaXMuaG92ZXJpbmcgPSB0cnVlKSxcbiAgICAgICAgICAgIGRlYm91bmNlVGltZSgyMDAwKSxcbiAgICAgICAgICAgIHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpXG4gICAgICAgICkuc3Vic2NyaWJlKCgpID0+IHRoaXMuaG92ZXJpbmcgPSBmYWxzZSk7XG4gICAgfVxuXG4gICAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLm1lZGlhUGxheWVyU2VydmljZS5zZXRNZWRpYVBsYXllcih0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsIHRoaXMuX3BsYXllclJlZi5uYXRpdmVFbGVtZW50KTtcblxuICAgICAgICB0aGlzLmF1ZGlvTWV0YWRhdGEgPSB0aGlzLl9hdWRpb1NlcnZpY2UuZ2V0QXVkaW9GaWxlTWV0YWRhdGEodGhpcy5fcGxheWVyUmVmLm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICB0aGlzLm1lZGlhUGxheWVyU2VydmljZS5wbGF5aW5nRXZlbnQucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSkuc3Vic2NyaWJlKCgpID0+IHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLnBsYXlpbmcubmV4dCh0cnVlKSk7XG4gICAgICAgIHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLnBhdXNlRXZlbnQucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSkuc3Vic2NyaWJlKCgpID0+IHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLnBsYXlpbmcubmV4dChmYWxzZSkpO1xuICAgICAgICB0aGlzLm1lZGlhUGxheWVyU2VydmljZS5tZWRpYUNsaWNrRXZlbnQucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSkuc3Vic2NyaWJlKCgpID0+IHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLnRvZ2dsZVBsYXkoKSk7XG4gICAgICAgIHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLmxvYWRlZE1ldGFkYXRhRXZlbnQucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSkuc3Vic2NyaWJlKCgpID0+IHRoaXMubWVkaWFQbGF5ZXJTZXJ2aWNlLmxvYWRlZCA9IHRydWUpO1xuXG4gICAgICAgIC8vIGluaXRpYWxseSBoaWRlIGFsbCB0ZXh0IHRyYWNrc1xuICAgICAgICB0aGlzLm1lZGlhUGxheWVyU2VydmljZS5oaWRlU3VidGl0bGVUcmFja3MoKTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fb25EZXN0cm95Lm5leHQoKTtcbiAgICAgICAgdGhpcy5fb25EZXN0cm95LmNvbXBsZXRlKCk7XG4gICAgfVxufVxuXG5leHBvcnQgdHlwZSBNZWRpYVBsYXllclR5cGUgPSAndmlkZW8nIHwgJ2F1ZGlvJztcblxuZXhwb3J0IGludGVyZmFjZSBNZWRpYVBsYXllckJ1ZmZlciB7XG4gICAgc3RhcnQ6IG51bWJlcjtcbiAgICBlbmQ6IG51bWJlcjtcbn0iLCJpbXBvcnQgeyBQaXBlLCBQaXBlVHJhbnNmb3JtIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBQaXBlKHtcbiAgICBuYW1lOiAnZHVyYXRpb24nXG59KVxuZXhwb3J0IGNsYXNzIER1cmF0aW9uUGlwZSBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0ge1xuICAgIFxuICAgIHRyYW5zZm9ybShzZWNvbmRzOiBudW1iZXIpOiBhbnkge1xuXG4gICAgICAgIGxldCBtaW51dGVzID0gTWF0aC5mbG9vcihzZWNvbmRzIC8gNjApO1xuICAgICAgICBsZXQgaG91cnMgPSBNYXRoLmZsb29yKG1pbnV0ZXMgLyA2MCk7XG4gICAgICAgIGxldCBkYXlzID0gTWF0aC5mbG9vcihob3VycyAvIDI0KTtcblxuICAgICAgICBob3VycyA9IGhvdXJzIC0gKGRheXMgKiAyNCk7XG4gICAgICAgIG1pbnV0ZXMgPSBtaW51dGVzIC0gKGRheXMgKiAyNCAqIDYwKSAtIChob3VycyAqIDYwKTtcbiAgICAgICAgc2Vjb25kcyA9IE1hdGguZmxvb3Ioc2Vjb25kcyAtIChkYXlzICogMjQgKiA2MCAqIDYwKSAtIChob3VycyAqIDYwICogNjApIC0gKG1pbnV0ZXMgKiA2MCkpO1xuXG4gICAgICAgIGlmIChob3VycyA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLnBhZChob3Vycyl9OiR7dGhpcy5wYWQobWludXRlcyl9OiR7dGhpcy5wYWQoc2Vjb25kcyl9YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBgJHt0aGlzLnBhZChtaW51dGVzKX06JHt0aGlzLnBhZChzZWNvbmRzKX1gO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcGFkKHZhbHVlOiBudW1iZXIpOiBzdHJpbmcge1xuICAgICAgICBpZiAodmFsdWUgPCAxMCkge1xuICAgICAgICAgICAgcmV0dXJuIGAwJHt2YWx1ZX1gO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfVxufSIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IER1cmF0aW9uUGlwZSB9IGZyb20gJy4vZHVyYXRpb24ucGlwZSc7XG5cbkBOZ01vZHVsZSh7XG4gICAgZXhwb3J0czogW0R1cmF0aW9uUGlwZV0sXG4gICAgZGVjbGFyYXRpb25zOiBbRHVyYXRpb25QaXBlXVxufSlcbmV4cG9ydCBjbGFzcyBEdXJhdGlvblBpcGVNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBQaXBlLCBQaXBlVHJhbnNmb3JtIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBQaXBlKHtcbiAgICBuYW1lOiAnZmlsZVNpemUnXG59KVxuZXhwb3J0IGNsYXNzIEZpbGVTaXplUGlwZSBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0ge1xuXG4gICAgdHJhbnNmb3JtKHZhbHVlOiBudW1iZXIpOiBhbnkge1xuXG4gICAgICAgIC8vIGFsbG93IGZvciBhc3luYyB2YWx1ZXNcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBsZXQgdW5pdHMgPSBbJ0InLCAnS0InLCAnTUInLCAnR0InLCAnVEInXTtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIHdoaWNoIHVuaXQgYnJhY2tldCB0aGUgdmFsdWVzIHNob3VsZCBiZSBhIHBhcnQgb2ZcbiAgICAgICAgbGV0IGlkeCA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5sb2coMTAyNCkpO1xuICAgICAgICBsZXQgZm9ybWF0dGVkVmFsdWUgPSB2YWx1ZSAvIE1hdGgucG93KDEwMjQsIGlkeCk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gYCR7Zm9ybWF0dGVkVmFsdWUudG9GaXhlZCgyKX0gJHt1bml0c1tpZHhdfWA7XG4gICAgfVxufSIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IEZpbGVTaXplUGlwZSB9IGZyb20gJy4vZmlsZS1zaXplLnBpcGUnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGV4cG9ydHM6IFtGaWxlU2l6ZVBpcGVdLFxuICAgIGRlY2xhcmF0aW9uczogW0ZpbGVTaXplUGlwZV1cbn0pXG5leHBvcnQgY2xhc3MgRmlsZVNpemVQaXBlTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgQTExeU1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9hMTF5JztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQWNjZXNzaWJpbGl0eU1vZHVsZSB9IGZyb20gJy4uLy4uL2RpcmVjdGl2ZXMvYWNjZXNzaWJpbGl0eS9pbmRleCc7XG5pbXBvcnQgeyBDbGlja091dHNpZGVNb2R1bGUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL2NsaWNrLW91dHNpZGUvaW5kZXgnO1xuaW1wb3J0IHsgRHVyYXRpb25QaXBlTW9kdWxlIH0gZnJvbSAnLi4vLi4vcGlwZXMvZHVyYXRpb24vaW5kZXgnO1xuaW1wb3J0IHsgRmlsZVNpemVQaXBlTW9kdWxlIH0gZnJvbSAnLi4vLi4vcGlwZXMvZmlsZS1zaXplL2luZGV4JztcbmltcG9ydCB7IEF1ZGlvU2VydmljZU1vZHVsZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2F1ZGlvL2luZGV4JztcbmltcG9ydCB7IEZyYW1lRXh0cmFjdGlvbk1vZHVsZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2ZyYW1lLWV4dHJhY3Rpb24vZnJhbWUtZXh0cmFjdGlvbi5tb2R1bGUnO1xuaW1wb3J0IHsgU2xpZGVyTW9kdWxlIH0gZnJvbSAnLi4vc2xpZGVyL2luZGV4JztcbmltcG9ydCB7IFRvb2x0aXBNb2R1bGUgfSBmcm9tICcuLi90b29sdGlwL2luZGV4JztcbmltcG9ydCB7IE1lZGlhUGxheWVyQmFzZUV4dGVuc2lvbkRpcmVjdGl2ZSB9IGZyb20gJy4vZXh0ZW5zaW9ucy9iYXNlLWV4dGVuc2lvbi5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgTWVkaWFQbGF5ZXJDb250cm9sc0V4dGVuc2lvbkNvbXBvbmVudCB9IGZyb20gJy4vZXh0ZW5zaW9ucy9jb250cm9scy9jb250cm9scy5jb21wb25lbnQnO1xuaW1wb3J0IHsgTWVkaWFQbGF5ZXJDdXN0b21Db250cm9sRGlyZWN0aXZlIH0gZnJvbSAnLi9leHRlbnNpb25zL2NvbnRyb2xzL2N1c3RvbS1jb250cm9sL2N1c3RvbS1jb250cm9sLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBNZWRpYVBsYXllclRpbWVsaW5lRXh0ZW5zaW9uQ29tcG9uZW50IH0gZnJvbSAnLi9leHRlbnNpb25zL3RpbWVsaW5lL3RpbWVsaW5lLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBNZWRpYVBsYXllckNvbXBvbmVudCB9IGZyb20gJy4vbWVkaWEtcGxheWVyLmNvbXBvbmVudCc7XG5cbmNvbnN0IERFQ0xBUkFUSU9OUyA9IFtcbiAgICBNZWRpYVBsYXllckNvbXBvbmVudCxcbiAgICBNZWRpYVBsYXllclRpbWVsaW5lRXh0ZW5zaW9uQ29tcG9uZW50LFxuICAgIE1lZGlhUGxheWVyQmFzZUV4dGVuc2lvbkRpcmVjdGl2ZSxcbiAgICBNZWRpYVBsYXllckNvbnRyb2xzRXh0ZW5zaW9uQ29tcG9uZW50LFxuICAgIE1lZGlhUGxheWVyQ3VzdG9tQ29udHJvbERpcmVjdGl2ZVxuXTtcblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgRnJhbWVFeHRyYWN0aW9uTW9kdWxlLFxuICAgICAgICBUb29sdGlwTW9kdWxlLFxuICAgICAgICBBdWRpb1NlcnZpY2VNb2R1bGUsXG4gICAgICAgIER1cmF0aW9uUGlwZU1vZHVsZSxcbiAgICAgICAgRmlsZVNpemVQaXBlTW9kdWxlLFxuICAgICAgICBTbGlkZXJNb2R1bGUsXG4gICAgICAgIEFjY2Vzc2liaWxpdHlNb2R1bGUsXG4gICAgICAgIEExMXlNb2R1bGUsXG4gICAgICAgIENsaWNrT3V0c2lkZU1vZHVsZVxuICAgIF0sXG4gICAgZXhwb3J0czogREVDTEFSQVRJT05TLFxuICAgIGRlY2xhcmF0aW9uczogREVDTEFSQVRJT05TXG59KVxuZXhwb3J0IGNsYXNzIE1lZGlhUGxheWVyTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgQWZ0ZXJDb250ZW50SW5pdCwgQWZ0ZXJWaWV3SW5pdCwgQ29tcG9uZW50LCBDb250ZW50Q2hpbGRyZW4sIEVsZW1lbnRSZWYsIElucHV0LCBPbkRlc3Ryb3ksIE9wdGlvbmFsLCBRdWVyeUxpc3QsIFJlbmRlcmVyMiwgU2tpcFNlbGYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE5hdmlnYXRpb25FbmQsIFJvdXRlciwgVXJsVHJlZSB9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7XG5pbXBvcnQgeyBmaWx0ZXIgfSBmcm9tICdyeGpzL29wZXJhdG9ycy9maWx0ZXInO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcy9TdWJzY3JpcHRpb24nO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ1t1eC1uYXZpZ2F0aW9uLWl0ZW1dJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vbmF2aWdhdGlvbi1pdGVtLmNvbXBvbmVudC5odG1sJyxcbiAgICBob3N0OiB7XG4gICAgICAgICdbY2xhc3MuYWN0aXZlXSc6ICdhY3RpdmUnLFxuICAgICAgICAnW2NsYXNzLnNlbGVjdGVkXSc6ICdleHBhbmRlZCcsXG4gICAgfVxufSlcbmV4cG9ydCBjbGFzcyBOYXZpZ2F0aW9uSXRlbUNvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQsIEFmdGVyQ29udGVudEluaXQsIE9uRGVzdHJveSB7XG4gICAgQElucHV0KCkgaGVhZGVyOiBzdHJpbmc7XG4gICAgQElucHV0KCkgaWNvbjogc3RyaW5nO1xuICAgIEBJbnB1dCgpIGV4cGFuZGVkOiBib29sZWFuID0gZmFsc2U7XG4gICAgQElucHV0KCkgbGluazogc3RyaW5nO1xuXG4gICAgZ2V0IGFjdGl2ZSgpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKHRoaXMubGluaykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JvdXRlci5pc0FjdGl2ZSh0aGlzLmxpbmssIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbGV2ZWw6IG51bWJlciA9IDE7XG4gICAgaW5kZW50V2l0aG91dEFycm93OiBib29sZWFuID0gdHJ1ZTtcblxuICAgIHByaXZhdGUgX25hdmlnYXRpb25FbmQ6IFN1YnNjcmlwdGlvbjtcbiAgICBwcml2YXRlIF9jaGlsZHJlbkNoYW5nZXM6IFN1YnNjcmlwdGlvbjtcblxuICAgIEBDb250ZW50Q2hpbGRyZW4oTmF2aWdhdGlvbkl0ZW1Db21wb25lbnQsIHsgZGVzY2VuZGFudHM6IHRydWUgfSlcbiAgICBwcml2YXRlIF9jaGlsZHJlbjogUXVlcnlMaXN0PE5hdmlnYXRpb25JdGVtQ29tcG9uZW50PjtcblxuICAgIGdldCBjaGlsZHJlbigpOiBOYXZpZ2F0aW9uSXRlbUNvbXBvbmVudFtdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuLmZpbHRlcihpdGVtID0+IGl0ZW0gIT09IHRoaXMpO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgICAgICBwcml2YXRlIF9yZW5kZXJlcjogUmVuZGVyZXIyLFxuICAgICAgICBAT3B0aW9uYWwoKVxuICAgICAgICBAU2tpcFNlbGYoKVxuICAgICAgICBwcml2YXRlIF9wYXJlbnQ6IE5hdmlnYXRpb25JdGVtQ29tcG9uZW50LFxuICAgICAgICBwcml2YXRlIF9yb3V0ZXI6IFJvdXRlclxuICAgICkge1xuICAgICAgICB0aGlzLmxldmVsID0gX3BhcmVudCA/IF9wYXJlbnQubGV2ZWwgKyAxIDogMTtcblxuICAgICAgICB0aGlzLl9uYXZpZ2F0aW9uRW5kID0gX3JvdXRlci5ldmVudHMucGlwZShmaWx0ZXIoZXZlbnQgPT4gZXZlbnQgaW5zdGFuY2VvZiBOYXZpZ2F0aW9uRW5kKSkuc3Vic2NyaWJlKGV2ZW50ID0+IHtcbiAgICAgICAgICAgIC8vIEV4cGFuZCB0aGlzIGNvbXBvbmVudCBpZiBpdCBvciBhIGRlc2NlbmRhbnQgaXMgYWN0aXZlLlxuICAgICAgICAgICAgdGhpcy5leHBhbmRlZCA9IHRoaXMuaGFzQWN0aXZlTGluayh0aGlzLmxpbmspO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgICAgIC8vIEFkZCBjbGFzc2VzIHRvIHBhcmVudCBmb3Igc3R5bGluZ1xuICAgICAgICBjb25zdCBwYXJlbnRMaXN0RWxlbWVudCA9IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgICAgICBpZiAocGFyZW50TGlzdEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGxldCBsZXZlbENsYXNzOiBzdHJpbmcgPSB0aGlzLmdldExldmVsQ2xhc3MoKTtcbiAgICAgICAgICAgIGlmIChsZXZlbENsYXNzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5hZGRDbGFzcyhwYXJlbnRMaXN0RWxlbWVudCwgJ25hdicpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmFkZENsYXNzKHBhcmVudExpc3RFbGVtZW50LCBsZXZlbENsYXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpOiB2b2lkIHtcbiAgICAgICAgLy8gU2V0ICdpbmRlbnRXaXRob3V0QXJyb3cnXG4gICAgICAgIHRoaXMuc2V0SW5kZW50V2l0aG91dEFycm93KCk7XG5cbiAgICAgICAgLy8gVXBkYXRlICdpbmRlbnRXaXRob3V0QXJyb3cnIGluIHJlc3BvbnNlIHRvIGNoYW5nZXMgdG8gY2hpbGRyZW5cbiAgICAgICAgdGhpcy5fY2hpbGRyZW5DaGFuZ2VzID0gdGhpcy5fY2hpbGRyZW4uY2hhbmdlcy5zdWJzY3JpYmUoKCkgPT4gdGhpcy5zZXRJbmRlbnRXaXRob3V0QXJyb3coKSk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3kgKCkge1xuICAgICAgICB0aGlzLl9uYXZpZ2F0aW9uRW5kLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuX2NoaWxkcmVuQ2hhbmdlcy51bnN1YnNjcmliZSgpO1xuICAgIH1cblxuICAgIHByaXZhdGUgaGFzQWN0aXZlTGluayhsaW5rOiBzdHJpbmcgfCBVcmxUcmVlKTogYm9vbGVhbiB7XG4gICAgICAgIC8vIElmIHRoaXMgY29tcG9uZW50IGhhcyBhIGxpbmssIGNoZWNrIGlmIGl0IGlzIGFjdGl2ZS5cbiAgICAgICAgaWYgKGxpbmsgJiYgdGhpcy5fcm91dGVyLmlzQWN0aXZlKGxpbmssIHRydWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoaXMgY29tcG9uZW50IGhhcyBjaGlsZHJlbiwgY2hlY2sgaWYgYW55IG9mIHRoZW0sIG9yIHRoZWlyIGRlc2NlbmRhbnRzLCBhcmUgYWN0aXZlLlxuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5zb21lKChpdGVtKSA9PiBpdGVtLmhhc0FjdGl2ZUxpbmsoaXRlbS5saW5rKSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRMZXZlbENsYXNzKCk6IHN0cmluZyB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5sZXZlbCkge1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiAnbmF2LXNlY29uZC1sZXZlbCc7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgcmV0dXJuICduYXYtdGhpcmQtbGV2ZWwnO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIHJldHVybiAnbmF2LWZvdXJ0aC1sZXZlbCc7XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgcmV0dXJuICduYXYtZmlmdGgtbGV2ZWwnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIHByaXZhdGUgc2V0SW5kZW50V2l0aG91dEFycm93KCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIGVsZW1lbnQgaGFzIGNoaWxkcmVuIGl0IHdpbGwgYmUgaW5kZW50ZWQgYW5kIHdpbGwgaGF2ZSBhbiBhcnJvd1xuICAgICAgICAgICAgdGhpcy5pbmRlbnRXaXRob3V0QXJyb3cgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9wYXJlbnQpIHtcbiAgICAgICAgICAgIC8vIElmIHRoaXMgZWxlbWVudCBoYXMgYSBwYXJlbnQsIGluZGVudCBpdCBpZiBhbnkgb2YgaXRzIHNpYmxpbmdzIGhhdmUgY2hpbGRyZW5cbiAgICAgICAgICAgIHRoaXMuaW5kZW50V2l0aG91dEFycm93ID0gIXRoaXMuX3BhcmVudC5jaGlsZHJlbi5ldmVyeSgoaXRlbSkgPT4gaXRlbS5jaGlsZHJlbi5sZW5ndGggPT09IDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVG9wLWxldmVsIGVsZW1lbnRzIHNob3VsZCBiZSBpbmRlbnRlZFxuICAgICAgICAgICAgdGhpcy5pbmRlbnRXaXRob3V0QXJyb3cgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTmF2aWdhdGlvbkl0ZW0gfSBmcm9tICcuL25hdmlnYXRpb24taXRlbS5pbmZlcmZhY2UnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgTmF2aWdhdGlvblNlcnZpY2Uge1xuXG4gICAgaXRlbXM6IE5hdmlnYXRpb25JdGVtW107XG5cbiAgICBhdXRvQ29sbGFwc2U6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgc2V0RXhwYW5kZWQoc291cmNlOiBOYXZpZ2F0aW9uSXRlbSwgZXhwYW5kZWQ6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgaWYgKGV4cGFuZGVkICYmIHRoaXMuYXV0b0NvbGxhcHNlKSB7XG4gICAgICAgICAgICB0aGlzLmNvbGxhcHNlU2libGluZ3Moc291cmNlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgY29sbGFwc2VTaWJsaW5ncyhzb3VyY2U6IE5hdmlnYXRpb25JdGVtKTogdm9pZCB7XG4gICAgICAgIGxldCBzaWJsaW5ncyA9IHRoaXMuaXRlbXM7XG4gICAgICAgIGZvciAobGV0IGl0ZW0gb2YgdGhpcy5pdGVtcykge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnQoc291cmNlLCBpdGVtKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBzaWJsaW5ncyA9IHBhcmVudC5jaGlsZHJlbjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGl0ZW0gb2Ygc2libGluZ3MpIHtcbiAgICAgICAgICAgIGlmIChpdGVtICE9PSBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbGxhcHNlQWxsKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjb2xsYXBzZUFsbChpdGVtOiBOYXZpZ2F0aW9uSXRlbSk6IHZvaWQge1xuICAgICAgICBpdGVtLmV4cGFuZGVkID0gZmFsc2U7XG4gICAgICAgIGlmIChpdGVtLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiBpdGVtLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2xsYXBzZUFsbChjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGdldFBhcmVudCh0YXJnZXQ6IE5hdmlnYXRpb25JdGVtLCBpdGVtOiBOYXZpZ2F0aW9uSXRlbSk6IE5hdmlnYXRpb25JdGVtIHtcbiAgICAgICAgaWYgKGl0ZW0uY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGZvciAobGV0IGNoaWxkIG9mIGl0ZW0uY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQgPT09IHRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59IiwiaW1wb3J0IHsgTG9jYXRpb25TdHJhdGVneSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBEaXJlY3RpdmUsIEhvc3RCaW5kaW5nLCBIb3N0TGlzdGVuZXIsIElucHV0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSwgT25Jbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOYXZpZ2F0aW9uRW5kLCBSb3V0ZXIgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuaW1wb3J0IHsgZmlsdGVyLCB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcbmltcG9ydCB7IHRpY2sgfSBmcm9tICcuLi8uLi8uLi9jb21tb24vaW5kZXgnO1xuaW1wb3J0IHsgTmF2aWdhdGlvbkl0ZW0gfSBmcm9tICcuLi9uYXZpZ2F0aW9uLWl0ZW0uaW5mZXJmYWNlJztcbmltcG9ydCB7IE5hdmlnYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi4vbmF2aWdhdGlvbi5zZXJ2aWNlJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbdXhOYXZpZ2F0aW9uTGlua10nLFxuICAgIGV4cG9ydEFzOiAndXhOYXZpZ2F0aW9uTGluaydcbn0pXG5leHBvcnQgY2xhc3MgTmF2aWdhdGlvbkxpbmtEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIE9uQ2hhbmdlcywgT25EZXN0cm95IHtcblxuICAgIEBJbnB1dCgpXG4gICAgbmF2aWdhdGlvbkl0ZW06IE5hdmlnYXRpb25JdGVtO1xuXG4gICAgQElucHV0KClcbiAgICBzZXQgZXhwYW5kZWQodmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5fZXhwYW5kZWQkLm5leHQodmFsdWUpO1xuICAgIH1cblxuICAgIEBJbnB1dCgpXG4gICAgY2FuRXhwYW5kOiBib29sZWFuO1xuXG4gICAgQElucHV0KClcbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmluZGVudCcpXG4gICAgaW5kZW50OiBib29sZWFuO1xuXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLmhyZWYnKVxuICAgIGhyZWY6IHN0cmluZztcblxuICAgIEBIb3N0QmluZGluZygnYXR0ci5yb2xlJylcbiAgICByb2xlOiBzdHJpbmc7XG5cbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIuYXJpYS1leHBhbmRlZCcpXG4gICAgYXJpYUV4cGFuZGVkOiBzdHJpbmcgPSAndW5kZWZpbmVkJztcblxuICAgIGlzQWN0aXZlOiBib29sZWFuO1xuXG4gICAgaW5kZW50Q2hpbGRyZW46IGJvb2xlYW47XG5cbiAgICBwcml2YXRlIF9leHBhbmRlZCQgPSBuZXcgU3ViamVjdDxib29sZWFuPigpO1xuICAgIHByaXZhdGUgX29uRGVzdHJveSA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBfcm91dGVyOiBSb3V0ZXIsXG4gICAgICAgIHByaXZhdGUgX2xvY2F0aW9uU3RyYXRlZ3k6IExvY2F0aW9uU3RyYXRlZ3ksXG4gICAgICAgIHByaXZhdGUgX25hdmlnYXRpb25TZXJ2aWNlOiBOYXZpZ2F0aW9uU2VydmljZVxuICAgICkgeyB9XG5cbiAgICBuZ09uSW5pdCgpOiB2b2lkIHtcblxuICAgICAgICB0aGlzLl9leHBhbmRlZCQucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSwgdGljaygpKS5zdWJzY3JpYmUoZXhwYW5kZWQgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMubmF2aWdhdGlvbkl0ZW0uY2hpbGRyZW4gJiYgdGhpcy5uYXZpZ2F0aW9uSXRlbS5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcmlhRXhwYW5kZWQgPSBgJHtleHBhbmRlZH1gO1xuICAgICAgICAgICAgICAgIHRoaXMuX25hdmlnYXRpb25TZXJ2aWNlLnNldEV4cGFuZGVkKHRoaXMubmF2aWdhdGlvbkl0ZW0sIGV4cGFuZGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fcm91dGVyLmV2ZW50c1xuICAgICAgICAgICAgLnBpcGUoZmlsdGVyKGV2ZW50ID0+IGV2ZW50IGluc3RhbmNlb2YgTmF2aWdhdGlvbkVuZCksIHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSh0aGlzLnVwZGF0ZU5hdmlnYXRpb25TdGF0ZS5iaW5kKHRoaXMpKTtcblxuICAgICAgICB0aGlzLnVwZGF0ZU5hdmlnYXRpb25TdGF0ZSgpO1xuXG4gICAgICAgIHRoaXMudXBkYXRlQXR0cmlidXRlcygpO1xuICAgIH1cblxuICAgIG5nT25DaGFuZ2VzKCk6IHZvaWQge1xuICAgICAgICB0aGlzLnVwZGF0ZUF0dHJpYnV0ZXMoKTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fb25EZXN0cm95Lm5leHQoKTtcbiAgICAgICAgdGhpcy5fb25EZXN0cm95LmNvbXBsZXRlKCk7XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcignY2xpY2snLCBbJyRldmVudCddKVxuICAgIEBIb3N0TGlzdGVuZXIoJ2tleWRvd24uZW50ZXInLCBbJyRldmVudCddKVxuICAgIGFjdGl2YXRlZChldmVudDogRXZlbnQpOiBib29sZWFuIHtcblxuICAgICAgICBpZiAodGhpcy5uYXZpZ2F0aW9uSXRlbS5yb3V0ZXJMaW5rKSB7XG4gICAgICAgICAgICBjb25zdCBjb21tYW5kcyA9IEFycmF5LmlzQXJyYXkodGhpcy5uYXZpZ2F0aW9uSXRlbS5yb3V0ZXJMaW5rKSA/IHRoaXMubmF2aWdhdGlvbkl0ZW0ucm91dGVyTGluayA6IFt0aGlzLm5hdmlnYXRpb25JdGVtLnJvdXRlckxpbmtdO1xuICAgICAgICAgICAgdGhpcy5fcm91dGVyLm5hdmlnYXRlKGNvbW1hbmRzLCB0aGlzLm5hdmlnYXRpb25JdGVtLnJvdXRlckV4dHJhcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUb2dnbGUgZXhwYW5kZWQgc3RhdGUgKHJlbGV2YW50IG9ubHkgaWYgaXQgaGFzIGNoaWxkcmVuKVxuICAgICAgICB0aGlzLm5hdmlnYXRpb25JdGVtLmV4cGFuZGVkID0gIXRoaXMubmF2aWdhdGlvbkl0ZW0uZXhwYW5kZWQ7XG5cbiAgICAgICAgLy8gSW52b2tlIHRoZSBjdXN0b20gY2xpY2sgaGFuZGxlciBpZiBzcGVjaWZpZWRcbiAgICAgICAgaWYgKHRoaXMubmF2aWdhdGlvbkl0ZW0uY2xpY2spIHtcbiAgICAgICAgICAgIHRoaXMubmF2aWdhdGlvbkl0ZW0uY2xpY2soZXZlbnQsIHRoaXMubmF2aWdhdGlvbkl0ZW0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHByaXZhdGUgdXBkYXRlTmF2aWdhdGlvblN0YXRlKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmlzQWN0aXZlID0gdGhpcy5pc0FjdGl2ZUl0ZW0odGhpcy5uYXZpZ2F0aW9uSXRlbSk7XG5cbiAgICAgICAgaWYgKHRoaXMubmF2aWdhdGlvbkl0ZW0uY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGFjdGl2ZUNoaWxkID0gdGhpcy5uYXZpZ2F0aW9uSXRlbS5jaGlsZHJlbi5maW5kKGNoaWxkID0+IHRoaXMuaXNBY3RpdmVJdGVtKGNoaWxkKSk7XG4gICAgICAgICAgICBpZiAoYWN0aXZlQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5hdmlnYXRpb25JdGVtLmV4cGFuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgdXBkYXRlQXR0cmlidXRlcygpOiB2b2lkIHtcblxuICAgICAgICB0aGlzLmhyZWYgPSB0aGlzLmdldEhyZWYoKTtcbiAgICAgICAgdGhpcy5yb2xlID0gKHRoaXMubmF2aWdhdGlvbkl0ZW0uY2hpbGRyZW4gJiYgdGhpcy5uYXZpZ2F0aW9uSXRlbS5jaGlsZHJlbi5sZW5ndGggPiAwKSA/ICdidXR0b24nIDogJ3RyZWVpdGVtJztcblxuICAgICAgICB0aGlzLmluZGVudENoaWxkcmVuID0gdGhpcy5uYXZpZ2F0aW9uSXRlbS5jaGlsZHJlbiAmJiB0aGlzLm5hdmlnYXRpb25JdGVtLmNoaWxkcmVuLnNvbWUoaXRlbSA9PiBpdGVtLmNoaWxkcmVuICYmIGl0ZW0uY2hpbGRyZW4ubGVuZ3RoID4gMCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRIcmVmKCk6IHN0cmluZyB7XG5cbiAgICAgICAgaWYgKHRoaXMubmF2aWdhdGlvbkl0ZW0ucm91dGVyTGluaykge1xuICAgICAgICAgICAgY29uc3QgY29tbWFuZHMgPSBBcnJheS5pc0FycmF5KHRoaXMubmF2aWdhdGlvbkl0ZW0ucm91dGVyTGluaykgPyB0aGlzLm5hdmlnYXRpb25JdGVtLnJvdXRlckxpbmsgOiBbdGhpcy5uYXZpZ2F0aW9uSXRlbS5yb3V0ZXJMaW5rXTtcbiAgICAgICAgICAgIGNvbnN0IHVybFRyZWUgPSB0aGlzLl9yb3V0ZXIuY3JlYXRlVXJsVHJlZShjb21tYW5kcywgdGhpcy5uYXZpZ2F0aW9uSXRlbS5yb3V0ZXJFeHRyYXMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2F0aW9uU3RyYXRlZ3kucHJlcGFyZUV4dGVybmFsVXJsKHRoaXMuX3JvdXRlci5zZXJpYWxpemVVcmwodXJsVHJlZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpc0FjdGl2ZUl0ZW0oaXRlbTogTmF2aWdhdGlvbkl0ZW0pOiBib29sZWFuIHtcblxuICAgICAgICBpZiAoaXRlbS5yb3V0ZXJMaW5rKSB7XG4gICAgICAgICAgICBjb25zdCBjb21tYW5kcyA9IEFycmF5LmlzQXJyYXkoaXRlbS5yb3V0ZXJMaW5rKSA/IGl0ZW0ucm91dGVyTGluayA6IFtpdGVtLnJvdXRlckxpbmtdO1xuICAgICAgICAgICAgY29uc3QgdXJsVHJlZSA9IHRoaXMuX3JvdXRlci5jcmVhdGVVcmxUcmVlKGNvbW1hbmRzLCBpdGVtLnJvdXRlckV4dHJhcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcm91dGVyLmlzQWN0aXZlKHVybFRyZWUsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBDb21wb25lbnQsIENvbnRlbnRDaGlsZCwgSW5wdXQsIFRlbXBsYXRlUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOYXZpZ2F0aW9uSXRlbSB9IGZyb20gJy4vbmF2aWdhdGlvbi1pdGVtLmluZmVyZmFjZSc7XG5pbXBvcnQgeyBOYXZpZ2F0aW9uU2VydmljZSB9IGZyb20gJy4vbmF2aWdhdGlvbi5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1uYXZpZ2F0aW9uJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vbmF2aWdhdGlvbi5jb21wb25lbnQuaHRtbCcsXG4gICAgcHJvdmlkZXJzOiBbTmF2aWdhdGlvblNlcnZpY2VdXG59KVxuZXhwb3J0IGNsYXNzIE5hdmlnYXRpb25Db21wb25lbnQge1xuXG4gICAgLyoqIFRoZSBuYXZpZ2F0aW9uIGl0ZW1zIHRvIHBvcHVsYXRlIHRoZSBtZW51IHdpdGguICovXG4gICAgQElucHV0KClcbiAgICBzZXQgaXRlbXMoaXRlbXM6IE5hdmlnYXRpb25JdGVtW10pIHtcbiAgICAgICAgdGhpcy5fbmF2aWdhdGlvblNlcnZpY2UuaXRlbXMgPSBpdGVtcztcbiAgICB9XG4gICAgZ2V0IGl0ZW1zKCk6IE5hdmlnYXRpb25JdGVtW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmF2aWdhdGlvblNlcnZpY2UuaXRlbXM7XG4gICAgfVxuXG4gICAgLyoqIFdoZXRoZXIgdG8gcHJlc2VudCB0aGUgbWVudSBhcyBhIGhpZXJhcmNoaWNhbCB0cmVlLiAqL1xuICAgIEBJbnB1dCgpXG4gICAgdHJlZTogYm9vbGVhbiA9IHRydWU7XG5cbiAgICAvKiogV2hldGhlciB0byBjb2xsYXBzZSBvdGhlciBtZW51IGl0ZW1zIHdoZW4gZXhwYW5kaW5nIGEgbWVudSBpdGVtLiAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2V0IGF1dG9Db2xsYXBzZShhdXRvQ29sbGFwc2U6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5fbmF2aWdhdGlvblNlcnZpY2UuYXV0b0NvbGxhcHNlID0gYXV0b0NvbGxhcHNlO1xuICAgIH1cblxuICAgIEBDb250ZW50Q2hpbGQoJ3V4TmF2aWdhdGlvbkl0ZW0nKVxuICAgIG5hdmlnYXRpb25JdGVtVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICBoaWVyYXJjaHlDbGFzc2VzID0gW1xuICAgICAgICAnJyxcbiAgICAgICAgJ25hdi1zZWNvbmQtbGV2ZWwnLFxuICAgICAgICAnbmF2LXRoaXJkLWxldmVsJyxcbiAgICAgICAgJ25hdi1mb3VydGgtbGV2ZWwnLFxuICAgICAgICAnbmF2LWZpZnRoLWxldmVsJyxcbiAgICBdO1xuXG4gICAgZ2V0IGRlcHRoTGltaXQoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZSA/IHRoaXMuaGllcmFyY2h5Q2xhc3Nlcy5sZW5ndGggOiAyO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX25hdmlnYXRpb25TZXJ2aWNlOiBOYXZpZ2F0aW9uU2VydmljZSkgeyB9XG5cbiAgICBpdGVtQ2xpY2soaXRlbTogTmF2aWdhdGlvbkl0ZW0sIGV2ZW50OiBFdmVudCk6IHZvaWQge1xuXG4gICAgICAgIC8vIFRvZ2dsZSBleHBhbmRlZCBzdGF0ZSAocmVsZXZhbnQgb25seSBpZiBpdCBoYXMgY2hpbGRyZW4pXG4gICAgICAgIGl0ZW0uZXhwYW5kZWQgPSAhaXRlbS5leHBhbmRlZDtcblxuICAgICAgICAvLyBJbnZva2UgdGhlIGN1c3RvbSBjbGljayBoYW5kbGVyIGlmIHNwZWNpZmllZFxuICAgICAgICBpZiAoaXRlbS5jbGljaykge1xuICAgICAgICAgICAgaXRlbS5jbGljayhldmVudCwgaXRlbSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNldHMgb2YgaXRlbXMgbmVlZHMgdG8gYmUgaW5kZW50ZWQgdG8gbWFrZSByb29tIGZvciBvbmUgb3IgbW9yZSBleHBhbmRlci5cbiAgICAgKi9cbiAgICBuZWVkc0luZGVudChpdGVtczogTmF2aWdhdGlvbkl0ZW1bXSk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gaXRlbXMgJiYgaXRlbXMuc29tZShpdGVtID0+IGl0ZW0uY2hpbGRyZW4gJiYgaXRlbS5jaGlsZHJlbi5sZW5ndGggPiAwKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFJvdXRlck1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7XG5pbXBvcnQgeyBBY2Nlc3NpYmlsaXR5TW9kdWxlIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9hY2Nlc3NpYmlsaXR5L2luZGV4JztcbmltcG9ydCB7IE5hdmlnYXRpb25JdGVtQ29tcG9uZW50IH0gZnJvbSAnLi9uYXZpZ2F0aW9uLWl0ZW0vbmF2aWdhdGlvbi1pdGVtLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBOYXZpZ2F0aW9uTGlua0RpcmVjdGl2ZSB9IGZyb20gJy4vbmF2aWdhdGlvbi1saW5rL25hdmlnYXRpb24tbGluay5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgTmF2aWdhdGlvbkNvbXBvbmVudCB9IGZyb20gJy4vbmF2aWdhdGlvbi5jb21wb25lbnQnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQWNjZXNzaWJpbGl0eU1vZHVsZSxcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBSb3V0ZXJNb2R1bGVcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgTmF2aWdhdGlvbkNvbXBvbmVudCxcbiAgICAgICAgTmF2aWdhdGlvbkl0ZW1Db21wb25lbnRcbiAgICBdLFxuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBOYXZpZ2F0aW9uQ29tcG9uZW50LFxuICAgICAgICBOYXZpZ2F0aW9uSXRlbUNvbXBvbmVudCxcbiAgICAgICAgTmF2aWdhdGlvbkxpbmtEaXJlY3RpdmVcbiAgICBdXG59KVxuZXhwb3J0IGNsYXNzIE5hdmlnYXRpb25Nb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBUZW1wbGF0ZVJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QgfSBmcm9tICdyeGpzL0JlaGF2aW9yU3ViamVjdCc7XHJcbmltcG9ydCB7IENvbG9yU2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2NvbG9yL2luZGV4JztcclxuXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIE5vdGlmaWNhdGlvblNlcnZpY2Uge1xyXG5cclxuICAgIC8vIHByb3ZpZGUgZGVmYXVsdCBvcHRpb25zXHJcbiAgICBvcHRpb25zOiBOb3RpZmljYXRpb25PcHRpb25zID0ge1xyXG4gICAgICAgIGR1cmF0aW9uOiA0LFxyXG4gICAgICAgIGhlaWdodDogMTAwLFxyXG4gICAgICAgIHNwYWNpbmc6IDEwLFxyXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhpcy5fY29sb3JTZXJ2aWNlLmdldENvbG9yKCdhY2NlbnQnKS50b0hleCgpLFxyXG4gICAgICAgIGljb25Db2xvcjogdGhpcy5fY29sb3JTZXJ2aWNlLmdldENvbG9yKCdhY2NlbnQnKS50b0hleCgpXHJcbiAgICB9O1xyXG5cclxuICAgIGRpcmVjdGlvbjogTm90aWZpY2F0aW9uTGlzdERpcmVjdGlvbiA9ICdhYm92ZSc7XHJcblxyXG4gICAgbm90aWZpY2F0aW9ucyQ6IEJlaGF2aW9yU3ViamVjdDxOb3RpZmljYXRpb25SZWZbXT4gPSBuZXcgQmVoYXZpb3JTdWJqZWN0PE5vdGlmaWNhdGlvblJlZltdPihbXSk7ICAgIFxyXG5cclxuICAgIHNob3codGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPGFueT4sIG9wdGlvbnM6IE5vdGlmaWNhdGlvbk9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsIGRhdGE6IHsgW2tleTogc3RyaW5nXTogYW55IH0gPSB7fSk6IE5vdGlmaWNhdGlvblJlZiB7XHJcblxyXG4gICAgICAgIG9wdGlvbnMgPSB7IC4uLnRoaXMub3B0aW9ucywgLi4ub3B0aW9ucyB9O1xyXG5cclxuICAgICAgICBjb25zdCBub3RpZmljYXRpb25SZWY6IE5vdGlmaWNhdGlvblJlZiA9IHtcclxuICAgICAgICAgICAgdGVtcGxhdGVSZWY6IHRlbXBsYXRlUmVmLFxyXG4gICAgICAgICAgICBkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcclxuICAgICAgICAgICAgZGF0ZTogbmV3IERhdGUoKSxcclxuICAgICAgICAgICAgdmlzaWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgaGVpZ2h0OiBvcHRpb25zLmhlaWdodCxcclxuICAgICAgICAgICAgc3BhY2luZzogb3B0aW9ucy5zcGFjaW5nLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxyXG4gICAgICAgICAgICBpY29uQ29sb3I6IG9wdGlvbnMuaWNvbkNvbG9yLFxyXG4gICAgICAgICAgICBkYXRhOiBkYXRhXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29uc3Qgbm90aWZpY2F0aW9ucyA9IHRoaXMubm90aWZpY2F0aW9ucyQuZ2V0VmFsdWUoKTtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZGlyZWN0aW9uID09PSAnYWJvdmUnKSB7XHJcbiAgICAgICAgICAgIG5vdGlmaWNhdGlvbnMudW5zaGlmdChub3RpZmljYXRpb25SZWYpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG5vdGlmaWNhdGlvbnMucHVzaChub3RpZmljYXRpb25SZWYpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5ub3RpZmljYXRpb25zJC5uZXh0KG5vdGlmaWNhdGlvbnMpO1xyXG5cclxuICAgICAgICAvLyByZW1vdmUgbm90aWZpY2F0aW9uIGFmdGVyIGRlbGF5XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuZHVyYXRpb24gIT09IDApIHtcclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLmRpc21pc3Mobm90aWZpY2F0aW9uUmVmKSwgb3B0aW9ucy5kdXJhdGlvbiAqIDEwMDApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG5vdGlmaWNhdGlvblJlZjtcclxuICAgIH1cclxuXHJcbiAgICBnZXRIaXN0b3J5KCk6IE5vdGlmaWNhdGlvblJlZltdIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ub3RpZmljYXRpb25zJC5nZXRWYWx1ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGRpc21pc3Mobm90aWZpY2F0aW9uUmVmOiBOb3RpZmljYXRpb25SZWYpOiB2b2lkIHtcclxuICAgICAgICBub3RpZmljYXRpb25SZWYudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMubm90aWZpY2F0aW9ucyQubmV4dCh0aGlzLm5vdGlmaWNhdGlvbnMkLmdldFZhbHVlKCkpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBkaXNtaXNzQWxsKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMubm90aWZpY2F0aW9ucyQuZ2V0VmFsdWUoKS5mb3JFYWNoKG5vdGlmaWNhdGlvblJlZiA9PiBub3RpZmljYXRpb25SZWYudmlzaWJsZSA9IGZhbHNlKTtcclxuICAgICAgICB0aGlzLm5vdGlmaWNhdGlvbnMkLm5leHQodGhpcy5ub3RpZmljYXRpb25zJC5nZXRWYWx1ZSgpKTsgICAgICAgIFxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX2NvbG9yU2VydmljZTogQ29sb3JTZXJ2aWNlKSB7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgTm90aWZpY2F0aW9uUmVmIHtcclxuICAgIHRlbXBsYXRlUmVmOiBUZW1wbGF0ZVJlZjxhbnk+O1xyXG4gICAgZHVyYXRpb246IG51bWJlcjtcclxuICAgIGRhdGU6IERhdGU7XHJcbiAgICB2aXNpYmxlPzogYm9vbGVhbjtcclxuICAgIGhlaWdodD86IG51bWJlcjtcclxuICAgIHNwYWNpbmc/OiBudW1iZXI7XHJcbiAgICBiYWNrZ3JvdW5kQ29sb3I/OiBzdHJpbmc7XHJcbiAgICBpY29uQ29sb3I/OiBzdHJpbmc7XHJcbiAgICBkYXRhOiB7IFtrZXk6IHN0cmluZ106IGFueSB9O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIE5vdGlmaWNhdGlvbk9wdGlvbnMge1xyXG4gICAgZHVyYXRpb24/OiBudW1iZXI7XHJcbiAgICBoZWlnaHQ/OiBudW1iZXI7XHJcbiAgICBzcGFjaW5nPzogbnVtYmVyO1xyXG4gICAgYmFja2dyb3VuZENvbG9yPzogc3RyaW5nO1xyXG4gICAgaWNvbkNvbG9yPzogc3RyaW5nO1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBOb3RpZmljYXRpb25MaXN0RGlyZWN0aW9uID0gJ2Fib3ZlJyB8ICdiZWxvdyc7IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBIb3N0QmluZGluZywgSW5wdXQsIENoYW5nZURldGVjdGlvblN0cmF0ZWd5IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOb3RpZmljYXRpb25TZXJ2aWNlLCBOb3RpZmljYXRpb25SZWYsIE5vdGlmaWNhdGlvbkxpc3REaXJlY3Rpb24gfSBmcm9tICcuL25vdGlmaWNhdGlvbi5zZXJ2aWNlJztcbmltcG9ydCB7IHRyaWdnZXIsIHN0YXRlLCBzdHlsZSwgYW5pbWF0ZSwgdHJhbnNpdGlvbiB9IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xuaW1wb3J0IHsgbWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMvT2JzZXJ2YWJsZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtbm90aWZpY2F0aW9uLWxpc3QnLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9ub3RpZmljYXRpb24tbGlzdC5jb21wb25lbnQuaHRtbCcsXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgYW5pbWF0aW9uczogW1xuICAgICAgICB0cmlnZ2VyKCdub3RpZmljYXRpb25TdGF0ZScsIFtcbiAgICAgICAgICAgIHN0YXRlKCdpbicsIHN0eWxlKHsgdHJhbnNmb3JtOiAndHJhbnNsYXRlWSgwKScsIG9wYWNpdHk6IDAuOSB9KSksXG4gICAgICAgICAgICB0cmFuc2l0aW9uKCc6ZW50ZXInLCBbXG4gICAgICAgICAgICAgICAgc3R5bGUoeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGVZKC01MHB4KScsIG9wYWNpdHk6IDAgfSksXG4gICAgICAgICAgICAgICAgYW5pbWF0ZSg1MDApXG4gICAgICAgICAgICBdKSxcbiAgICAgICAgICAgIHRyYW5zaXRpb24oJzpsZWF2ZScsIFtcbiAgICAgICAgICAgICAgICBhbmltYXRlKDUwMCwgc3R5bGUoeyB0cmFuc2Zvcm06ICd0cmFuc2xhdGVZKDUwcHgpJywgb3BhY2l0eTogMCB9KSlcbiAgICAgICAgICAgIF0pXG4gICAgICAgIF0pXG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBOb3RpZmljYXRpb25MaXN0Q29tcG9uZW50IHtcbiAgICBcbiAgICBASW5wdXQoKSBcbiAgICBzZXQgZGlyZWN0aW9uKGRpcmVjdGlvbjogTm90aWZpY2F0aW9uTGlzdERpcmVjdGlvbikge1xuICAgICAgICB0aGlzLl9ub3RpZmljYXRpb25TZXJ2aWNlLmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICB9XG5cbiAgICBASW5wdXQoKSBASG9zdEJpbmRpbmcoJ2NsYXNzJykgcG9zaXRpb246IE5vdGlmaWNhdGlvbkxpc3RQb3N0aW9uID0gJ3RvcC1yaWdodCc7XG5cbiAgICBub3RpZmljYXRpb25zJDogT2JzZXJ2YWJsZTxOb3RpZmljYXRpb25SZWZbXT4gPSB0aGlzLl9ub3RpZmljYXRpb25TZXJ2aWNlLm5vdGlmaWNhdGlvbnMkLnBpcGUoXG4gICAgICAgIG1hcCgobm90aWZpY2F0aW9uUmVmczogTm90aWZpY2F0aW9uUmVmW10pID0+IG5vdGlmaWNhdGlvblJlZnMuZmlsdGVyKG5vdGlmaWNhdGlvblJlZiA9PiBub3RpZmljYXRpb25SZWYudmlzaWJsZSksXG4gICAgKSk7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9ub3RpZmljYXRpb25TZXJ2aWNlOiBOb3RpZmljYXRpb25TZXJ2aWNlKSB7XG5cbiAgICB9XG59XG5cbmV4cG9ydCB0eXBlIE5vdGlmaWNhdGlvbkxpc3RQb3N0aW9uID0gJ3RvcC1sZWZ0JyB8ICd0b3AtcmlnaHQnIHwgJ2JvdHRvbS1sZWZ0JyB8ICdib3R0b20tcmlnaHQnOyIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XHJcbmltcG9ydCB7IE5vdGlmaWNhdGlvbkxpc3RDb21wb25lbnQgfSBmcm9tICcuL25vdGlmaWNhdGlvbi1saXN0LmNvbXBvbmVudCc7XHJcbmltcG9ydCB7IE5vdGlmaWNhdGlvblNlcnZpY2UgfSBmcm9tICcuL25vdGlmaWNhdGlvbi5zZXJ2aWNlJztcclxuaW1wb3J0IHsgQ29sb3JTZXJ2aWNlTW9kdWxlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvY29sb3IvaW5kZXgnO1xyXG5cclxuQE5nTW9kdWxlKHtcclxuICAgIGltcG9ydHM6IFtcclxuICAgICAgICBDb21tb25Nb2R1bGUsXHJcbiAgICAgICAgQ29sb3JTZXJ2aWNlTW9kdWxlXHJcbiAgICBdLFxyXG4gICAgZXhwb3J0czogW1xyXG4gICAgICAgIE5vdGlmaWNhdGlvbkxpc3RDb21wb25lbnRcclxuICAgIF0sXHJcbiAgICBkZWNsYXJhdGlvbnM6IFtcclxuICAgICAgICBOb3RpZmljYXRpb25MaXN0Q29tcG9uZW50XHJcbiAgICBdLFxyXG4gICAgcHJvdmlkZXJzOiBbXHJcbiAgICAgICAgTm90aWZpY2F0aW9uU2VydmljZVxyXG4gICAgXVxyXG59KVxyXG5leHBvcnQgY2xhc3MgTm90aWZpY2F0aW9uTW9kdWxlIHsgfVxyXG4iLCJpbXBvcnQgeyBEaXJlY3RpdmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQERpcmVjdGl2ZSh7IFxuICAgIHNlbGVjdG9yOiAnW3V4UGFnZUhlYWRlckN1c3RvbU1lbnVdJyBcbn0pXG5leHBvcnQgY2xhc3MgUGFnZUhlYWRlckN1c3RvbU1lbnVEaXJlY3RpdmUgeyB9IiwiaW1wb3J0IHsgSW5qZWN0YWJsZSwgT25EZXN0cm95IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOYXZpZ2F0aW9uRW5kLCBSb3V0ZXIgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcy9CZWhhdmlvclN1YmplY3QnO1xuaW1wb3J0IHsgZmlsdGVyLCBtYXAsIHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzL1N1YmplY3QnO1xuaW1wb3J0IHsgUGFnZUhlYWRlckljb25NZW51IH0gZnJvbSAnLi9pbnRlcmZhY2VzJztcbmltcG9ydCB7IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uRHJvcGRvd25JdGVtLCBQYWdlSGVhZGVyTmF2aWdhdGlvbkl0ZW0gfSBmcm9tICcuL25hdmlnYXRpb24vbmF2aWdhdGlvbi5jb21wb25lbnQnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgUGFnZUhlYWRlclNlcnZpY2UgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICAgIGl0ZW1zJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8UGFnZUhlYWRlck5hdmlnYXRpb25JdGVtW10+KFtdKTtcbiAgICBzZWxlY3RlZCQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PFBhZ2VIZWFkZXJOYXZpZ2F0aW9uSXRlbT4obnVsbCk7XG4gICAgc2VsZWN0ZWRSb290JCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8UGFnZUhlYWRlck5hdmlnYXRpb25JdGVtPihudWxsKTtcbiAgICBzZWNvbmRhcnkkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPihmYWxzZSk7XG4gICAgYWN0aXZlSWNvbk1lbnUkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxQYWdlSGVhZGVySWNvbk1lbnU+KG51bGwpO1xuICAgIHNlY29uZGFyeU5hdmlnYXRpb25BdXRvc2VsZWN0ID0gZmFsc2U7XG5cbiAgICBwcml2YXRlIF9vbkRlc3Ryb3kgPSBuZXcgU3ViamVjdCgpO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfcm91dGVyOiBSb3V0ZXIpIHtcblxuICAgICAgICB0aGlzLnNlbGVjdGVkJFxuICAgICAgICAgICAgLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSksIG1hcChzZWxlY3RlZCA9PiB0aGlzLmdldFJvb3Qoc2VsZWN0ZWQpKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUocm9vdCA9PiB0aGlzLnNlbGVjdGVkUm9vdCQubmV4dChyb290KSk7XG5cbiAgICAgICAgdGhpcy5fcm91dGVyLmV2ZW50c1xuICAgICAgICAgICAgLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSksIGZpbHRlcihlID0+IGUgaW5zdGFuY2VvZiBOYXZpZ2F0aW9uRW5kKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUodGhpcy51cGRhdGVJdGVtc1dpdGhBY3RpdmVSb3V0ZS5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fb25EZXN0cm95Lm5leHQoKTtcbiAgICAgICAgdGhpcy5fb25EZXN0cm95LmNvbXBsZXRlKCk7XG4gICAgfVxuXG4gICAgc2VsZWN0KGl0ZW06IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uSXRlbSk6IHZvaWQge1xuXG4gICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGl0ZW0ucm91dGVyTGluaykge1xuXG4gICAgICAgICAgICAvLyBUcmlnZ2VyIHJvdXRlciBuYXZpZ2F0aW9uXG4gICAgICAgICAgICBjb25zdCByb3V0ZXJMaW5rID0gQXJyYXkuaXNBcnJheShpdGVtLnJvdXRlckxpbmspID8gaXRlbS5yb3V0ZXJMaW5rIDogW2l0ZW0ucm91dGVyTGlua107XG4gICAgICAgICAgICB0aGlzLl9yb3V0ZXIubmF2aWdhdGUocm91dGVyTGluaywgaXRlbS5yb3V0ZXJFeHRyYXMpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zZWNvbmRhcnlOYXZpZ2F0aW9uQXV0b3NlbGVjdCAmJiBpdGVtLmNoaWxkcmVuICYmIGl0ZW0uY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuXG4gICAgICAgICAgICAvLyBTZWxlY3QgdGhlIGZpcnN0IGNoaWxkIGluIHNlY29uZGFyeU5hdmlnYXRpb25BdXRvc2VsZWN0IG1vZGVcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0KGl0ZW0uY2hpbGRyZW5bMF0pO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIC8vIGlmIHdlIGFyZSBpbiBzZWNvbmRhcnkgbmF2aWdhdGlvbiBtb2RlIGFuZCB3ZSBjbGljayBhIHBhcmVudCAtIGRvbnQgZGVzZWxlY3QgdGhlIGNoaWxkXG4gICAgICAgICAgICBpZiAodGhpcy5zZWNvbmRhcnkkLmdldFZhbHVlKCkgPT09IHRydWUgJiYgdGhpcy5pc1BhcmVudE9mKHRoaXMuc2VsZWN0ZWQkLmdldFZhbHVlKCksIGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBPdGhlcndpc2Ugc2VsZWN0IHRoZSBnaXZlbiBpdGVtXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkJC5uZXh0KGl0ZW0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGVzZWxlY3QoaXRlbTogUGFnZUhlYWRlck5hdmlnYXRpb25JdGVtIHwgUGFnZUhlYWRlck5hdmlnYXRpb25Ecm9wZG93bkl0ZW0pOiB2b2lkIHtcbiAgICAgICAgLy8gZGVzZWxlY3QgdGhlIGN1cnJlbnQgaXRlbVxuICAgICAgICBpdGVtLnNlbGVjdGVkID0gZmFsc2U7XG5cbiAgICAgICAgLy8gaXRlcmF0ZSBhbnkgY2hpbGRyZW4gYW5kIGRlc2VsZWN0IHRoZW1cbiAgICAgICAgaWYgKGl0ZW0uY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGl0ZW0uY2hpbGRyZW4uZm9yRWFjaChfaXRlbSA9PiB0aGlzLmRlc2VsZWN0KF9pdGVtKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZXNlbGVjdEFsbCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5pdGVtcyQuZ2V0VmFsdWUoKS5mb3JFYWNoKGl0ZW0gPT4gdGhpcy5kZXNlbGVjdChpdGVtKSk7XG4gICAgfVxuXG4gICAgdXBkYXRlSXRlbShpdGVtOiBQYWdlSGVhZGVyTmF2aWdhdGlvbkl0ZW0sIHNlbGVjdGVkOiBQYWdlSGVhZGVyTmF2aWdhdGlvbkl0ZW0pOiB2b2lkIHtcbiAgICAgICAgLy8gSXRlbSBpcyBzZWxlY3RlZCBpZiBpdCBpcyB0aGUgc2VsZWN0ZWQgaXRlbSwgb3Igb25lIG9mIHRoZSBzZWxlY3RlZCBpdGVtJ3MgYW5jZXN0b3JzLlxuICAgICAgICBpdGVtLnNlbGVjdGVkID0gaXRlbSA9PT0gc2VsZWN0ZWQgfHwgdGhpcy5pc1BhcmVudE9mKHNlbGVjdGVkLCBpdGVtKTtcblxuICAgICAgICBpZiAoaXRlbSA9PT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIC8vIGNhbGwgdGhlIHNlbGVjdCBmdW5jdGlvbiBpZiBwcmVzZW50XG4gICAgICAgICAgICBpZiAoaXRlbS5zZWxlY3QpIHtcbiAgICAgICAgICAgICAgICBpdGVtLnNlbGVjdC5jYWxsKGl0ZW0sIGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0SXRlbXMoaXRlbXM6IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uSXRlbVtdID0gW10pOiB2b2lkIHtcbiAgICAgICAgLy8gaWRlbnRpZnkgYWxsIHBhcmVudCBlbGVtZW50c1xuICAgICAgICBpdGVtcy5mb3JFYWNoKGl0ZW0gPT4gdGhpcy5zZXRQYXJlbnQoaXRlbSkpO1xuXG4gICAgICAgIHRoaXMuaXRlbXMkLm5leHQoaXRlbXMpO1xuXG4gICAgICAgIC8vIFNldCB1cCB0aGUgaW5pdGFsbHkgc2VsZWN0ZWQgaXRlbVxuICAgICAgICAvLyBJZiBub3RoaW5nIGlzIHNldCBhcyBzZWxlY3RlZCwgdXNpbmcgdGhlIGluaXRpYWwgcm91dGVcbiAgICAgICAgY29uc3QgaW5pdGlhbFNlbGVjdGVkSXRlbSA9IGl0ZW1zLmZpbmQoaXRlbSA9PiBpdGVtLnNlbGVjdGVkID09PSB0cnVlKTtcbiAgICAgICAgaWYgKGluaXRpYWxTZWxlY3RlZEl0ZW0pIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0KGluaXRpYWxTZWxlY3RlZEl0ZW0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVJdGVtc1dpdGhBY3RpdmVSb3V0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0U2Vjb25kYXJ5TmF2aWdhdGlvbihlbmFibGVkOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIHRoaXMuc2Vjb25kYXJ5JC5uZXh0KGVuYWJsZWQpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0Um9vdChpdGVtOiBQYWdlSGVhZGVyTmF2aWdhdGlvbik6IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0gJiYgaXRlbS5wYXJlbnQgPyB0aGlzLmdldFJvb3QoaXRlbS5wYXJlbnQpIDogaXRlbTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHNldFBhcmVudChpdGVtOiBQYWdlSGVhZGVyTmF2aWdhdGlvbiwgcGFyZW50PzogUGFnZUhlYWRlck5hdmlnYXRpb24gfCBudWxsKTogdm9pZCB7XG5cbiAgICAgICAgLy8gc2V0IHRoZSBwYXJlbnQgZmllbGRcbiAgICAgICAgaXRlbS5wYXJlbnQgPSBwYXJlbnQ7XG5cbiAgICAgICAgLy8gY2FsbCB0aGlzIGZ1bmN0aW9uIHJlY3Vyc2l2ZWx5IG9uIGFsbCBjaGlsZHJlblxuICAgICAgICBpZiAoaXRlbS5jaGlsZHJlbikge1xuICAgICAgICAgICAgaXRlbS5jaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHRoaXMuc2V0UGFyZW50KGNoaWxkLCBpdGVtKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGlzUGFyZW50T2Yobm9kZTogUGFnZUhlYWRlck5hdmlnYXRpb24sIHBhcmVudDogUGFnZUhlYWRlck5hdmlnYXRpb24pOiBib29sZWFuIHtcblxuICAgICAgICAvLyBpZiB0aGVyZSBhcmUgbm8gcGFyZW50cyByZXR1cm4gZmFsc2VcbiAgICAgICAgaWYgKCFub2RlIHx8ICFub2RlLnBhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhlIHBhcmVudCBpcyB0aGUgbWF0Y2ggd2UgYXJlIGxvb2tpbmcgZm9yIHJldHVybiB0cnVlXG4gICAgICAgIGlmIChub2RlLnBhcmVudCA9PT0gcGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoZXJlIGFyZSBwb3RlbnRpYWxseSBncmFuZHBhcmVudHMgdGhlbiBjaGVjayB0aGVtIHRvb1xuICAgICAgICByZXR1cm4gdGhpcy5pc1BhcmVudE9mKG5vZGUucGFyZW50LCBwYXJlbnQpO1xuICAgIH1cblxuICAgIHByaXZhdGUgdXBkYXRlSXRlbXNXaXRoQWN0aXZlUm91dGUoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGFjdGl2ZUl0ZW0gPSBuZXcgUGFnZUhlYWRlckFjdGl2ZU5hdmlnYXRpb25JdGVtKCk7XG4gICAgICAgIGZvciAodmFyIGl0ZW0gb2YgdGhpcy5pdGVtcyQuZ2V0VmFsdWUoKSkge1xuICAgICAgICAgICAgdGhpcy5maW5kQWN0aXZlSXRlbShpdGVtLCBhY3RpdmVJdGVtKTtcbiAgICAgICAgICAgIGlmIChhY3RpdmVJdGVtLmV4YWN0KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWN0aXZlSXRlbS5pdGVtKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkJC5uZXh0KGFjdGl2ZUl0ZW0uaXRlbSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGZpbmRBY3RpdmVJdGVtKGl0ZW06IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uSXRlbSwgYWN0aXZlSXRlbTogUGFnZUhlYWRlckFjdGl2ZU5hdmlnYXRpb25JdGVtKTogdm9pZCB7XG5cbiAgICAgICAgaWYgKGl0ZW0ucm91dGVyTGluaykge1xuXG4gICAgICAgICAgICBjb25zdCByb3V0ZXJMaW5rID0gQXJyYXkuaXNBcnJheShpdGVtLnJvdXRlckxpbmspID8gaXRlbS5yb3V0ZXJMaW5rIDogW2l0ZW0ucm91dGVyTGlua107XG4gICAgICAgICAgICBjb25zdCB1cmxUcmVlID0gdGhpcy5fcm91dGVyLmNyZWF0ZVVybFRyZWUocm91dGVyTGluaywgaXRlbS5yb3V0ZXJFeHRyYXMpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fcm91dGVyLmlzQWN0aXZlKHVybFRyZWUsIHRydWUpICYmICFhY3RpdmVJdGVtLmV4YWN0KSB7XG5cbiAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZSBpdGVtIHJvdXRlIGlzIGFuIGV4YWN0IG1hdGNoLCBubyBuZWVkIHRvIGxvb2sgYW55IGZ1cnRoZXJcbiAgICAgICAgICAgICAgICBhY3RpdmVJdGVtLml0ZW0gPSBpdGVtO1xuICAgICAgICAgICAgICAgIGFjdGl2ZUl0ZW0uZXhhY3QgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5fcm91dGVyLmlzQWN0aXZlKHVybFRyZWUsIGZhbHNlKSkge1xuXG4gICAgICAgICAgICAgICAgLy8gU3RvcmUgYW4gaW5leGFjdCBtYXRjaCBhbmQgY29udGludWUgbG9va2luZ1xuICAgICAgICAgICAgICAgIGFjdGl2ZUl0ZW0uaXRlbSA9IGl0ZW07XG4gICAgICAgICAgICAgICAgYWN0aXZlSXRlbS5leGFjdCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGl0ZW0uY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGZvciAobGV0IGNoaWxkSXRlbSBvZiBpdGVtLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maW5kQWN0aXZlSXRlbShjaGlsZEl0ZW0sIGFjdGl2ZUl0ZW0pO1xuICAgICAgICAgICAgICAgIGlmIChhY3RpdmVJdGVtLmV4YWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCB0eXBlIFBhZ2VIZWFkZXJOYXZpZ2F0aW9uID0gUGFnZUhlYWRlck5hdmlnYXRpb25JdGVtIHwgUGFnZUhlYWRlck5hdmlnYXRpb25Ecm9wZG93bkl0ZW07XG5cbmNsYXNzIFBhZ2VIZWFkZXJBY3RpdmVOYXZpZ2F0aW9uSXRlbSB7XG4gICAgaXRlbTogUGFnZUhlYWRlck5hdmlnYXRpb25JdGVtO1xuICAgIGV4YWN0OiBib29sZWFuO1xufVxuIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgT25EZXN0cm95LCBWaWV3Q2hpbGQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IE1lbnVOYXZpZ2F0aW9uVG9nZ2xlRGlyZWN0aXZlIH0gZnJvbSAnLi4vLi4vLi4vZGlyZWN0aXZlcy9tZW51LW5hdmlnYXRpb24vbWVudS1uYXZpZ2F0aW9uLXRvZ2dsZS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgUGFnZUhlYWRlckljb25NZW51LCBQYWdlSGVhZGVySWNvbk1lbnVEcm9wZG93bkl0ZW0gfSBmcm9tICcuLi9pbnRlcmZhY2VzJztcbmltcG9ydCB7IFBhZ2VIZWFkZXJTZXJ2aWNlIH0gZnJvbSAnLi4vcGFnZS1oZWFkZXIuc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtcGFnZS1oZWFkZXItaWNvbi1tZW51JyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vaWNvbi1tZW51LmNvbXBvbmVudC5odG1sJ1xufSlcbmV4cG9ydCBjbGFzcyBQYWdlSGVhZGVySWNvbk1lbnVDb21wb25lbnQgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuXG4gICAgQElucHV0KCkgbWVudTogUGFnZUhlYWRlckljb25NZW51O1xuXG4gICAgZ2V0IGlzT3BlbigpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzT3BlbjtcbiAgICB9XG5cbiAgICBzZXQgaXNPcGVuKHZhbHVlOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuX2lzT3BlbiA9IHZhbHVlO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3NlcnZpY2UuYWN0aXZlSWNvbk1lbnUkLm5leHQodGhpcy5tZW51KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIEBWaWV3Q2hpbGQoJ21lbnVOYXZpZ2F0aW9uVG9nZ2xlJykgbWVudU5hdmlnYXRpb25Ub2dnbGU6IE1lbnVOYXZpZ2F0aW9uVG9nZ2xlRGlyZWN0aXZlO1xuXG4gICAgcHJpdmF0ZSBfaXNPcGVuOiBib29sZWFuO1xuICAgIHByaXZhdGUgX3N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfc2VydmljZTogUGFnZUhlYWRlclNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gX3NlcnZpY2UuYWN0aXZlSWNvbk1lbnUkLnN1YnNjcmliZSgobmV4dCkgPT4ge1xuICAgICAgICAgICAgLy8gQ2xvc2UgYWxsIGJ1dCB0aGUgbW9zdCByZWNlbnRseSBvcGVuZWQgbWVudVxuICAgICAgICAgICAgaWYgKG5leHQgIT09IHRoaXMubWVudSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzT3BlbiA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuXG4gICAgc2VsZWN0KGl0ZW06IFBhZ2VIZWFkZXJJY29uTWVudSB8IFBhZ2VIZWFkZXJJY29uTWVudURyb3Bkb3duSXRlbSkge1xuICAgICAgICBpZiAoaXRlbS5zZWxlY3QpIHtcbiAgICAgICAgICAgIGl0ZW0uc2VsZWN0LmNhbGwoaXRlbSwgaXRlbSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBrZXlkb3duSGFuZGxlcihpdGVtOiBQYWdlSGVhZGVySWNvbk1lbnUgfCBQYWdlSGVhZGVySWNvbk1lbnVEcm9wZG93bkl0ZW0sIGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZCB7XG5cbiAgICAgICAgc3dpdGNoIChldmVudC5rZXkpIHtcbiAgICAgICAgICAgIGNhc2UgJ0VudGVyJzpcbiAgICAgICAgICAgIGNhc2UgJyAnOlxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0KGl0ZW0pO1xuICAgICAgICAgICAgICAgIHRoaXMuaXNPcGVuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5tZW51TmF2aWdhdGlvblRvZ2dsZS5mb2N1cygpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBJbnB1dCwgT25EZXN0cm95LCBWaWV3Q2hpbGQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzL1N1YmplY3QnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcy9TdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgZGVib3VuY2VUaW1lIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgUGFnZUhlYWRlclNlcnZpY2UgfSBmcm9tICcuLi8uLi9wYWdlLWhlYWRlci5zZXJ2aWNlJztcbmltcG9ydCB7IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uRHJvcGRvd25JdGVtIH0gZnJvbSAnLi4vbmF2aWdhdGlvbi5jb21wb25lbnQnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LXBhZ2UtaGVhZGVyLWhvcml6b250YWwtbmF2aWdhdGlvbi1kcm9wZG93bi1pdGVtJyxcbiAgICBleHBvcnRBczogJ3V4LXBhZ2UtaGVhZGVyLWhvcml6b250YWwtbmF2aWdhdGlvbi1kcm9wZG93bi1pdGVtJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vbmF2aWdhdGlvbi1kcm9wZG93bi1pdGVtLmNvbXBvbmVudC5odG1sJ1xufSlcbmV4cG9ydCBjbGFzcyBQYWdlSGVhZGVyTmF2aWdhdGlvbkRyb3Bkb3duSXRlbUNvbXBvbmVudCBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG5cbiAgICBASW5wdXQoKSBpdGVtOiBQYWdlSGVhZGVyTmF2aWdhdGlvbkRyb3Bkb3duSXRlbTtcblxuICAgIEBWaWV3Q2hpbGQoJ2J1dHRvbicpXG4gICAgYnV0dG9uOiBFbGVtZW50UmVmO1xuXG4gICAgZHJvcGRvd25PcGVuOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBwcml2YXRlIF9zdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcbiAgICBwcml2YXRlIF9ob3ZlciQ6IFN1YmplY3Q8Ym9vbGVhbj4gPSBuZXcgU3ViamVjdDxib29sZWFuPigpO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfcGFnZUhlYWRlclNlcnZpY2U6IFBhZ2VIZWFkZXJTZXJ2aWNlKSB7XG5cbiAgICAgICAgLy8gc3Vic2NyaWJlIHRvIHN0cmVhbSB3aXRoIGEgZGVib3VuY2UgKGEgc21hbGwgZGVib3VuY2UgaXMgYWxsIHRoYXQgaXMgcmVxdWlyZWQpXG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IHRoaXMuX2hvdmVyJC5waXBlKGRlYm91bmNlVGltZSgxKSkuc3Vic2NyaWJlKHZpc2libGUgPT4gdGhpcy5kcm9wZG93bk9wZW4gPSB2aXNpYmxlKTtcblxuICAgICAgICAvLyBDbG9zZSBzdWJtZW51cyB3aGVuIHNlbGVjdGVkIGl0ZW0gY2hhbmdlc1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24uYWRkKFxuICAgICAgICAgICAgX3BhZ2VIZWFkZXJTZXJ2aWNlLnNlbGVjdGVkJC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZHJvcGRvd25PcGVuID0gZmFsc2U7XG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG5cbiAgICBzZWxlY3QoaXRlbTogUGFnZUhlYWRlck5hdmlnYXRpb25Ecm9wZG93bkl0ZW0pIHtcblxuICAgICAgICAvLyBjbGlja2luZyBvbiBhbiBpdGVtIHdpdGggY2hpbGRyZW4gdGhlbiByZXR1cm5cbiAgICAgICAgaWYgKGl0ZW0uY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVtaXQgdGhlIHNlbGVjdGVkIGl0ZW0gaW4gYW4gZXZlbnRcbiAgICAgICAgdGhpcy5fcGFnZUhlYWRlclNlcnZpY2Uuc2VsZWN0KGl0ZW0pO1xuICAgIH1cblxuICAgIGZvY3VzKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmJ1dHRvbi5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgfVxuXG4gICAgaG92ZXJTdGFydCgpIHtcbiAgICAgICAgdGhpcy5faG92ZXIkLm5leHQodHJ1ZSk7XG4gICAgfVxuXG4gICAgaG92ZXJMZWF2ZSgpIHtcbiAgICAgICAgdGhpcy5faG92ZXIkLm5leHQoZmFsc2UpO1xuICAgIH1cblxuICAgIGNsb3NlKCkge1xuICAgICAgICB0aGlzLmRyb3Bkb3duT3BlbiA9IGZhbHNlO1xuICAgIH1cblxuICAgIGtleWRvd25IYW5kbGVyKGV2ZW50OiBLZXlib2FyZEV2ZW50LCBpdGVtOiBQYWdlSGVhZGVyTmF2aWdhdGlvbkRyb3Bkb3duSXRlbSk6IHZvaWQge1xuXG4gICAgICAgIHN3aXRjaCAoZXZlbnQua2V5KSB7XG4gICAgICAgICAgICBjYXNlICdFbnRlcic6XG4gICAgICAgICAgICBjYXNlICcgJzpcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdChpdGVtKTtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufSIsImltcG9ydCB7IENvbXBvbmVudCwgRWxlbWVudFJlZiwgSW5wdXQsIE9uRGVzdHJveSwgT25Jbml0LCBRdWVyeUxpc3QsIFZpZXdDaGlsZCwgVmlld0NoaWxkcmVuIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBCc0Ryb3Bkb3duRGlyZWN0aXZlIH0gZnJvbSAnbmd4LWJvb3RzdHJhcC9kcm9wZG93bic7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QgfSBmcm9tICdyeGpzL0JlaGF2aW9yU3ViamVjdCc7XG5pbXBvcnQgeyB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcbmltcG9ydCB7IE1lbnVOYXZpZ2F0aW9uVG9nZ2xlRGlyZWN0aXZlIH0gZnJvbSAnLi4vLi4vLi4vLi4vZGlyZWN0aXZlcy9tZW51LW5hdmlnYXRpb24vbWVudS1uYXZpZ2F0aW9uLXRvZ2dsZS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgUGFnZUhlYWRlclNlcnZpY2UgfSBmcm9tICcuLi8uLi9wYWdlLWhlYWRlci5zZXJ2aWNlJztcbmltcG9ydCB7IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uRHJvcGRvd25JdGVtQ29tcG9uZW50IH0gZnJvbSAnLi4vbmF2aWdhdGlvbi1kcm9wZG93bi1pdGVtL25hdmlnYXRpb24tZHJvcGRvd24taXRlbS5jb21wb25lbnQnO1xuaW1wb3J0IHsgUGFnZUhlYWRlck5hdmlnYXRpb25JdGVtIH0gZnJvbSAnLi4vbmF2aWdhdGlvbi5jb21wb25lbnQnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LXBhZ2UtaGVhZGVyLWhvcml6b250YWwtbmF2aWdhdGlvbi1pdGVtJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vbmF2aWdhdGlvbi1pdGVtLmNvbXBvbmVudC5odG1sJ1xufSlcbmV4cG9ydCBjbGFzcyBQYWdlSGVhZGVyTmF2aWdhdGlvbkl0ZW1Db21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG5cbiAgICBAVmlld0NoaWxkKCdidXR0b24nKSBidXR0b246IE1lbnVOYXZpZ2F0aW9uVG9nZ2xlRGlyZWN0aXZlO1xuICAgIEBWaWV3Q2hpbGQoJ21lbnUnKSBtZW51OiBCc0Ryb3Bkb3duRGlyZWN0aXZlO1xuICAgIEBWaWV3Q2hpbGRyZW4oUGFnZUhlYWRlck5hdmlnYXRpb25Ecm9wZG93bkl0ZW1Db21wb25lbnQpIGRyb3Bkb3duczogUXVlcnlMaXN0PFBhZ2VIZWFkZXJOYXZpZ2F0aW9uRHJvcGRvd25JdGVtQ29tcG9uZW50PjtcblxuICAgIEBJbnB1dCgpIGl0ZW06IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uSXRlbTtcblxuICAgIHNlY29uZGFyeSQ6IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPiA9IHRoaXMuX3BhZ2VIZWFkZXJTZXJ2aWNlLnNlY29uZGFyeSQ7XG5cbiAgICBpc09wZW46IGJvb2xlYW47XG5cbiAgICBwcml2YXRlIF9vbkRlc3Ryb3kgPSBuZXcgU3ViamVjdCgpO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHB1YmxpYyBlbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgICAgICBwcml2YXRlIF9wYWdlSGVhZGVyU2VydmljZTogUGFnZUhlYWRlclNlcnZpY2VcbiAgICApIHsgfVxuXG4gICAgbmdPbkluaXQoKSB7XG5cbiAgICAgICAgdGhpcy5fcGFnZUhlYWRlclNlcnZpY2Uuc2VsZWN0ZWQkLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZShuZXh0ID0+IHtcblxuICAgICAgICAgICAgLy8gVXBkYXRlIHNlbGVjdGVkIHN0YXRlIGZvciB0aGlzIGl0ZW1cbiAgICAgICAgICAgIHRoaXMuX3BhZ2VIZWFkZXJTZXJ2aWNlLnVwZGF0ZUl0ZW0odGhpcy5pdGVtLCBuZXh0KTtcblxuICAgICAgICAgICAgaWYgKG5leHQgJiYgdGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzT3BlbiA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgbWVudSB3YXMgY2xvc2VkLCBrZWVwIGZvY3VzIG9uIHRoZSB0b2dnbGUgYnV0dG9uXG4gICAgICAgICAgICAgICAgdGhpcy5idXR0b24uZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHRoaXMubWVudSkge1xuICAgICAgICAgICAgdGhpcy5tZW51Lm9uSGlkZGVuXG4gICAgICAgICAgICAgICAgLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpXG4gICAgICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLmRyb3Bkb3ducy5mb3JFYWNoKGRyb3Bkb3duID0+IGRyb3Bkb3duLmNsb3NlKCkpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kubmV4dCgpO1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kuY29tcGxldGUoKTtcbiAgICB9XG5cbiAgICBzZWxlY3QoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gaWYgdGhlIGl0ZW0gaGFzIGNoaWxkcmVuIHRoZW4gZG8gbm90aGluZyBhdCB0aGlzIHN0YWdlXG4gICAgICAgIGlmICh0aGlzLml0ZW0uY2hpbGRyZW4gJiYgdGhpcy5fcGFnZUhlYWRlclNlcnZpY2Uuc2Vjb25kYXJ5JC5nZXRWYWx1ZSgpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gb3RoZXJ3aXNlIHNlbGVjdCB0aGUgY3VycmVudCBpdGVtXG4gICAgICAgIHRoaXMuX3BhZ2VIZWFkZXJTZXJ2aWNlLnNlbGVjdCh0aGlzLml0ZW0pO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIElucHV0LCBPbkRlc3Ryb3ksIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBkZWxheSwgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcclxuaW1wb3J0IHsgUGFnZUhlYWRlclNlcnZpY2UgfSBmcm9tICcuLi8uLi9wYWdlLWhlYWRlci5zZXJ2aWNlJztcclxuaW1wb3J0IHsgUGFnZUhlYWRlck5hdmlnYXRpb25JdGVtIH0gZnJvbSAnLi4vbmF2aWdhdGlvbi5jb21wb25lbnQnO1xyXG5cclxuQERpcmVjdGl2ZSh7XHJcbiAgICBzZWxlY3RvcjogJ1t1eFBhZ2VIZWFkZXJOYXZpZ2F0aW9uU2Vjb25kYXJ5SXRlbV0nXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBQYWdlSGVhZGVyTmF2aWdhdGlvblNlY29uZGFyeUl0ZW1EaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XHJcblxyXG4gICAgQElucHV0KCd1eFBhZ2VIZWFkZXJOYXZpZ2F0aW9uU2Vjb25kYXJ5SXRlbScpXHJcbiAgICBpdGVtOiBQYWdlSGVhZGVyTmF2aWdhdGlvbkl0ZW07XHJcblxyXG4gICAgcHJpdmF0ZSBfb25EZXN0cm95ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9wYWdlSGVhZGVyU2VydmljZTogUGFnZUhlYWRlclNlcnZpY2UpIHsgfVxyXG5cclxuICAgIG5nT25Jbml0KCkge1xyXG5cclxuICAgICAgICB0aGlzLl9wYWdlSGVhZGVyU2VydmljZS5zZWxlY3RlZCQucGlwZShkZWxheSgwKSwgdGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZShuZXh0ID0+IHtcclxuXHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBzZWxlY3RlZCBzdGF0ZSBmb3IgdGhpcyBpdGVtXHJcbiAgICAgICAgICAgIHRoaXMuX3BhZ2VIZWFkZXJTZXJ2aWNlLnVwZGF0ZUl0ZW0odGhpcy5pdGVtLCBuZXh0KTtcclxuXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fb25EZXN0cm95Lm5leHQoKTtcclxuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kuY29tcGxldGUoKTtcclxuICAgIH1cclxufSIsImltcG9ydCB7IEFmdGVyVmlld0luaXQsIENvbXBvbmVudCwgRWxlbWVudFJlZiwgT25EZXN0cm95LCBRdWVyeUxpc3QsIFZpZXdDaGlsZHJlbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTmF2aWdhdGlvbkV4dHJhcyB9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QgfSBmcm9tICdyeGpzL0JlaGF2aW9yU3ViamVjdCc7XG5pbXBvcnQgeyBkaXN0aW5jdFVudGlsQ2hhbmdlZCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IFJlc2l6ZVNlcnZpY2UgfSBmcm9tICcuLi8uLi8uLi9kaXJlY3RpdmVzL3Jlc2l6ZS9pbmRleCc7XG5pbXBvcnQgeyBQYWdlSGVhZGVyTmF2aWdhdGlvbiwgUGFnZUhlYWRlclNlcnZpY2UgfSBmcm9tICcuLi9wYWdlLWhlYWRlci5zZXJ2aWNlJztcbmltcG9ydCB7IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uSXRlbUNvbXBvbmVudCB9IGZyb20gJy4vbmF2aWdhdGlvbi1pdGVtL25hdmlnYXRpb24taXRlbS5jb21wb25lbnQnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LXBhZ2UtaGVhZGVyLWhvcml6b250YWwtbmF2aWdhdGlvbicsXG4gICAgdGVtcGxhdGVVcmw6ICcuL25hdmlnYXRpb24uY29tcG9uZW50Lmh0bWwnLFxuICAgIGhvc3Q6IHtcbiAgICAgICAgJ3JvbGUnOiAnbWVudWJhcidcbiAgICB9XG59KVxuZXhwb3J0IGNsYXNzIFBhZ2VIZWFkZXJOYXZpZ2F0aW9uQ29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCwgT25EZXN0cm95IHtcblxuICAgIEBWaWV3Q2hpbGRyZW4oUGFnZUhlYWRlck5hdmlnYXRpb25JdGVtQ29tcG9uZW50KSBtZW51SXRlbXM6IFF1ZXJ5TGlzdDxQYWdlSGVhZGVyTmF2aWdhdGlvbkl0ZW1Db21wb25lbnQ+O1xuXG4gICAgaXRlbXMkOiBCZWhhdmlvclN1YmplY3Q8UGFnZUhlYWRlck5hdmlnYXRpb25JdGVtW10+ID0gdGhpcy5fcGFnZUhlYWRlclNlcnZpY2UuaXRlbXMkO1xuICAgIGluZGljYXRvclZpc2libGU6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBpbmRpY2F0b3JYOiBudW1iZXIgPSAwO1xuICAgIGluZGljYXRvcldpZHRoOiBudW1iZXIgPSAwO1xuXG4gICAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuXG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZjogRWxlbWVudFJlZiwgcmVzaXplU2VydmljZTogUmVzaXplU2VydmljZSwgcHJpdmF0ZSBfcGFnZUhlYWRlclNlcnZpY2U6IFBhZ2VIZWFkZXJTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi5hZGQocmVzaXplU2VydmljZS5hZGRSZXNpemVMaXN0ZW5lcihlbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpLnN1YnNjcmliZSh0aGlzLnVwZGF0ZVNlbGVjdGVkSW5kaWNhdG9yLmJpbmQodGhpcykpKTtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLmFkZChfcGFnZUhlYWRlclNlcnZpY2Uuc2VsZWN0ZWQkLnBpcGUoZGlzdGluY3RVbnRpbENoYW5nZWQoKSkuc3Vic2NyaWJlKHRoaXMudXBkYXRlU2VsZWN0ZWRJbmRpY2F0b3IuYmluZCh0aGlzKSkpO1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24uYWRkKF9wYWdlSGVhZGVyU2VydmljZS5zZWNvbmRhcnkkLnBpcGUoZGlzdGluY3RVbnRpbENoYW5nZWQoKSkuc3Vic2NyaWJlKHRoaXMudXBkYXRlU2VsZWN0ZWRJbmRpY2F0b3IuYmluZCh0aGlzKSkpO1xuICAgIH1cblxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy51cGRhdGVTZWxlY3RlZEluZGljYXRvcigpO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG5cbiAgICB1cGRhdGVTZWxlY3RlZEluZGljYXRvcigpOiB2b2lkIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAvLyBmaW5kIHRoZSBzZWxlY3RlZCBpdGVtXG4gICAgICAgICAgICBjb25zdCBzZWxlY3RlZCA9IHRoaXMubWVudUl0ZW1zLmZpbmQoaXRlbSA9PiBpdGVtLml0ZW0uc2VsZWN0ZWQpO1xuXG4gICAgICAgICAgICAvLyBkZXRlcm1pbmUgd2hldGhlciBvciBub3QgdG8gc2hvdyB0aGUgaW5kaWNhdG9yXG4gICAgICAgICAgICB0aGlzLmluZGljYXRvclZpc2libGUgPSAhIXNlbGVjdGVkO1xuXG4gICAgICAgICAgICAvLyBzZXQgdGhlIHdpZHRoIG9mIHRoZSBpbmRpY2F0b3IgdG8gbWF0Y2ggdGhlIHdpZHRoIG9mIHRoZSBuYXZpZ2F0aW9uIGl0ZW1cbiAgICAgICAgICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0eWxlcyA9IGdldENvbXB1dGVkU3R5bGUoc2VsZWN0ZWQuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50KTtcblxuICAgICAgICAgICAgICAgIHRoaXMuaW5kaWNhdG9yWCA9IHNlbGVjdGVkLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5vZmZzZXRMZWZ0O1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kaWNhdG9yV2lkdGggPSBwYXJzZUludChzdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZSgnd2lkdGgnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBhZ2VIZWFkZXJOYXZpZ2F0aW9uSXRlbSB7XG4gICAgaWNvbj86IHN0cmluZztcbiAgICB0aXRsZTogc3RyaW5nO1xuICAgIHNlbGVjdGVkPzogYm9vbGVhbjtcbiAgICByb3V0ZXJMaW5rPzogc3RyaW5nIHwgYW55W107XG4gICAgcm91dGVyRXh0cmFzPzogTmF2aWdhdGlvbkV4dHJhcztcbiAgICBzZWxlY3Q/OiAoaXRlbTogUGFnZUhlYWRlck5hdmlnYXRpb25JdGVtKSA9PiB2b2lkO1xuICAgIGNoaWxkcmVuPzogUGFnZUhlYWRlck5hdmlnYXRpb25Ecm9wZG93bkl0ZW1bXTtcbiAgICBwYXJlbnQ/OiBQYWdlSGVhZGVyTmF2aWdhdGlvbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQYWdlSGVhZGVyTmF2aWdhdGlvbkRyb3Bkb3duSXRlbSB7XG4gICAgdGl0bGU6IHN0cmluZztcbiAgICBzZWxlY3RlZD86IGJvb2xlYW47XG4gICAgcm91dGVyTGluaz86IHN0cmluZyB8IGFueVtdO1xuICAgIHJvdXRlckV4dHJhcz86IE5hdmlnYXRpb25FeHRyYXM7XG4gICAgc2VsZWN0PzogKGl0ZW06IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uRHJvcGRvd25JdGVtKSA9PiB2b2lkO1xuICAgIGNoaWxkcmVuPzogUGFnZUhlYWRlck5hdmlnYXRpb25Ecm9wZG93bkl0ZW1bXTtcbiAgICBwYXJlbnQ/OiBQYWdlSGVhZGVyTmF2aWdhdGlvbjtcbn1cblxuLy8gVGhpcyBpcyBhbiBhbGlhcyBmb3IgTUYgdXNlIGFzIFwiRHJvcGRvd25JdGVtXCIgZG9lc24ndCBtYWtlIHNlbnNlIGluIGNvbnRleHQgd2l0aCBob3cgaXQgaXMgdXNlZFxuZXhwb3J0IGludGVyZmFjZSBQYWdlSGVhZGVyU2Vjb25kYXJ5TmF2aWdhdGlvbkl0ZW0gZXh0ZW5kcyBQYWdlSGVhZGVyTmF2aWdhdGlvbkRyb3Bkb3duSXRlbSB7IH0iLCJpbXBvcnQgeyBDb21wb25lbnQsIENvbnRlbnRDaGlsZCwgQ29udGVudENoaWxkcmVuLCBFdmVudEVtaXR0ZXIsIElucHV0LCBPdXRwdXQsIFF1ZXJ5TGlzdCwgVGVtcGxhdGVSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcbmltcG9ydCB7IENvbG9yU2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2NvbG9yL2luZGV4JztcbmltcG9ydCB7IEJyZWFkY3J1bWIgfSBmcm9tICcuLi9icmVhZGNydW1icy9pbmRleCc7XG5pbXBvcnQgeyBQYWdlSGVhZGVyQ3VzdG9tTWVudURpcmVjdGl2ZSB9IGZyb20gJy4vY3VzdG9tLW1lbnUvY3VzdG9tLW1lbnUuZGlyZWN0aXZlJztcbmltcG9ydCB7IFBhZ2VIZWFkZXJJY29uTWVudSB9IGZyb20gJy4vaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBQYWdlSGVhZGVyTmF2aWdhdGlvbkl0ZW0gfSBmcm9tICcuL25hdmlnYXRpb24vbmF2aWdhdGlvbi5jb21wb25lbnQnO1xuaW1wb3J0IHsgUGFnZUhlYWRlck5hdmlnYXRpb24sIFBhZ2VIZWFkZXJTZXJ2aWNlIH0gZnJvbSAnLi9wYWdlLWhlYWRlci5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1wYWdlLWhlYWRlcicsXG4gICAgZXhwb3J0QXM6ICd1eC1wYWdlLWhlYWRlcicsXG4gICAgdGVtcGxhdGVVcmw6ICdwYWdlLWhlYWRlci5jb21wb25lbnQuaHRtbCcsXG4gICAgcHJvdmlkZXJzOiBbIFBhZ2VIZWFkZXJTZXJ2aWNlIF1cbn0pXG5leHBvcnQgY2xhc3MgUGFnZUhlYWRlckNvbXBvbmVudCB7XG5cbiAgICBASW5wdXQoKSBsb2dvOiBzdHJpbmc7XG4gICAgQElucHV0KCkgaGVhZGVyOiBzdHJpbmc7XG4gICAgQElucHV0KCkgdGl0bGU6IHN0cmluZztcbiAgICBASW5wdXQoKSBhbGlnbm1lbnQ6ICdsZWZ0JyB8ICdyaWdodCcgfCAnY2VudGVyJyA9ICdjZW50ZXInO1xuICAgIEBJbnB1dCgpIGNvbmRlbnNlZDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIEBJbnB1dCgpIGljb25NZW51czogUGFnZUhlYWRlckljb25NZW51W107XG4gICAgQElucHV0KCkgYmFja1Zpc2libGU6IGJvb2xlYW4gPSB0cnVlO1xuICAgIEBJbnB1dCgpIHNlY29uZGFyeU5hdmlnYXRpb25BbGlnbm1lbnQ6ICdsZWZ0JyB8ICdyaWdodCcgfCAnY2VudGVyJyA9ICdjZW50ZXInO1xuXG4gICAgQElucHV0KClcbiAgICBzZXQgc2Vjb25kYXJ5TmF2aWdhdGlvbkF1dG9zZWxlY3QodmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5fcGFnZUhlYWRlclNlcnZpY2Uuc2Vjb25kYXJ5TmF2aWdhdGlvbkF1dG9zZWxlY3QgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBnZXQgc2Vjb25kYXJ5TmF2aWdhdGlvbkF1dG9zZWxlY3QoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYWdlSGVhZGVyU2VydmljZS5zZWNvbmRhcnlOYXZpZ2F0aW9uQXV0b3NlbGVjdDtcbiAgICB9XG5cbiAgICBASW5wdXQoKVxuICAgIHNldCBpdGVtcyhpdGVtczogUGFnZUhlYWRlck5hdmlnYXRpb25JdGVtW10pIHtcbiAgICAgICAgdGhpcy5fcGFnZUhlYWRlclNlcnZpY2Uuc2V0SXRlbXMoaXRlbXMpO1xuICAgIH1cblxuICAgIEBJbnB1dCgpXG4gICAgc2V0IHNlY29uZGFyeU5hdmlnYXRpb24oZW5hYmxlZDogYm9vbGVhbikge1xuICAgICAgICB0aGlzLl9wYWdlSGVhZGVyU2VydmljZS5zZXRTZWNvbmRhcnlOYXZpZ2F0aW9uKGVuYWJsZWQpO1xuICAgIH1cblxuICAgIGdldCBzZWNvbmRhcnlOYXZpZ2F0aW9uKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFnZUhlYWRlclNlcnZpY2Uuc2Vjb25kYXJ5JC5nZXRWYWx1ZSgpO1xuICAgIH1cblxuICAgIEBJbnB1dCgpXG4gICAgc2V0IGNydW1icyhjcnVtYnM6IEJyZWFkY3J1bWJbXSkge1xuICAgICAgICB0aGlzLl9jcnVtYnMgPSBjcnVtYnM7XG4gICAgfVxuXG4gICAgZ2V0IGNydW1icygpOiBCcmVhZGNydW1iW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25kZW5zZWQgPyBbLi4udGhpcy5fY3J1bWJzLCB7IHRpdGxlOiB0aGlzLmhlYWRlciB9XSA6IHRoaXMuX2NydW1icztcbiAgICB9XG5cbiAgICBASW5wdXQoKSBjcnVtYnNTdHlsZTogJ3N0YW5kYXJkJyB8ICdzbWFsbCcgPSAnc3RhbmRhcmQnO1xuXG4gICAgQElucHV0KClcbiAgICBzZXQgbG9nb0JhY2tncm91bmQoY29sb3I6IHN0cmluZykge1xuICAgICAgICB0aGlzLl9sb2dvQmFja2dyb3VuZCA9IHRoaXMuX2NvbG9yU2VydmljZS5yZXNvbHZlKGNvbG9yKTtcbiAgICB9XG5cbiAgICBnZXQgbG9nb0JhY2tncm91bmQoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvZ29CYWNrZ3JvdW5kO1xuICAgIH1cblxuICAgIEBJbnB1dCgpXG4gICAgc2V0IGxvZ29Gb3JlZ3JvdW5kKGNvbG9yOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5fbG9nb0ZvcmVncm91bmQgPSB0aGlzLl9jb2xvclNlcnZpY2UucmVzb2x2ZShjb2xvcik7XG4gICAgfVxuXG4gICAgZ2V0IGxvZ29Gb3JlZ3JvdW5kKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2dvRm9yZWdyb3VuZDtcbiAgICB9XG5cbiAgICBASW5wdXQoKVxuICAgIHNldCBmYW1pbHlCYWNrZ3JvdW5kKGNvbG9yOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5sb2dvQmFja2dyb3VuZCA9IGNvbG9yO1xuICAgIH1cblxuICAgIEBJbnB1dCgpXG4gICAgc2V0IGZhbWlseUZvcmVncm91bmQoY29sb3I6IHN0cmluZykge1xuICAgICAgICB0aGlzLmxvZ29Gb3JlZ3JvdW5kID0gY29sb3I7XG4gICAgfVxuXG4gICAgQE91dHB1dCgpIGJhY2tDbGljayA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIEBDb250ZW50Q2hpbGQoJ3RpdGxlJykgdGl0bGVUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcblxuICAgIEBDb250ZW50Q2hpbGRyZW4oUGFnZUhlYWRlckN1c3RvbU1lbnVEaXJlY3RpdmUsIHsgcmVhZDogVGVtcGxhdGVSZWYgfSkgY3VzdG9tTWVudXM6IFF1ZXJ5TGlzdDxUZW1wbGF0ZVJlZjxhbnk+PjtcblxuICAgIHNlbGVjdGVkJDogQmVoYXZpb3JTdWJqZWN0PFBhZ2VIZWFkZXJOYXZpZ2F0aW9uSXRlbT4gPSB0aGlzLl9wYWdlSGVhZGVyU2VydmljZS5zZWxlY3RlZCQ7XG4gICAgc2VsZWN0ZWRSb290JDogQmVoYXZpb3JTdWJqZWN0PFBhZ2VIZWFkZXJOYXZpZ2F0aW9uSXRlbT4gPSB0aGlzLl9wYWdlSGVhZGVyU2VydmljZS5zZWxlY3RlZFJvb3QkO1xuXG4gICAgcHJpdmF0ZSBfY3J1bWJzOiBCcmVhZGNydW1iW10gPSBbXTtcbiAgICBwcml2YXRlIF9sb2dvQmFja2dyb3VuZDogc3RyaW5nO1xuICAgIHByaXZhdGUgX2xvZ29Gb3JlZ3JvdW5kOiBzdHJpbmc7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9jb2xvclNlcnZpY2U6IENvbG9yU2VydmljZSwgcHJpdmF0ZSBfcGFnZUhlYWRlclNlcnZpY2U6IFBhZ2VIZWFkZXJTZXJ2aWNlKSB7IH1cblxuICAgIGdvQmFjaygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5iYWNrQ2xpY2suZW1pdCgpO1xuICAgIH1cblxuICAgIHNlbGVjdChpdGVtOiBQYWdlSGVhZGVyTmF2aWdhdGlvbik6IHZvaWQge1xuICAgICAgICB0aGlzLl9wYWdlSGVhZGVyU2VydmljZS5zZWxlY3QoaXRlbSk7XG4gICAgfVxufSIsImltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUm91dGVyTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcbmltcG9ydCB7IEJzRHJvcGRvd25Nb2R1bGUgfSBmcm9tICduZ3gtYm9vdHN0cmFwL2Ryb3Bkb3duJztcbmltcG9ydCB7IE1lbnVOYXZpZ2F0aW9uTW9kdWxlIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9tZW51LW5hdmlnYXRpb24vaW5kZXgnO1xuaW1wb3J0IHsgUmVzaXplTW9kdWxlIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9yZXNpemUvaW5kZXgnO1xuaW1wb3J0IHsgQ29sb3JTZXJ2aWNlTW9kdWxlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvY29sb3IvaW5kZXgnO1xuaW1wb3J0IHsgQnJlYWRjcnVtYnNNb2R1bGUgfSBmcm9tICcuLi9icmVhZGNydW1icy9pbmRleCc7XG5pbXBvcnQgeyBQYWdlSGVhZGVyQ3VzdG9tTWVudURpcmVjdGl2ZSB9IGZyb20gJy4vY3VzdG9tLW1lbnUvY3VzdG9tLW1lbnUuZGlyZWN0aXZlJztcbmltcG9ydCB7IFBhZ2VIZWFkZXJJY29uTWVudUNvbXBvbmVudCB9IGZyb20gJy4vaWNvbi1tZW51L2ljb24tbWVudS5jb21wb25lbnQnO1xuaW1wb3J0IHsgUGFnZUhlYWRlck5hdmlnYXRpb25Ecm9wZG93bkl0ZW1Db21wb25lbnQgfSBmcm9tICcuL25hdmlnYXRpb24vbmF2aWdhdGlvbi1kcm9wZG93bi1pdGVtL25hdmlnYXRpb24tZHJvcGRvd24taXRlbS5jb21wb25lbnQnO1xuaW1wb3J0IHsgUGFnZUhlYWRlck5hdmlnYXRpb25JdGVtQ29tcG9uZW50IH0gZnJvbSAnLi9uYXZpZ2F0aW9uL25hdmlnYXRpb24taXRlbS9uYXZpZ2F0aW9uLWl0ZW0uY29tcG9uZW50JztcbmltcG9ydCB7IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uU2Vjb25kYXJ5SXRlbURpcmVjdGl2ZSB9IGZyb20gJy4vbmF2aWdhdGlvbi9uYXZpZ2F0aW9uLXNlY29uZGFyeS1pdGVtL25hdmlnYXRpb24tc2Vjb25kYXJ5LWl0ZW0uZGlyZWN0aXZlJztcbmltcG9ydCB7IFBhZ2VIZWFkZXJOYXZpZ2F0aW9uQ29tcG9uZW50IH0gZnJvbSAnLi9uYXZpZ2F0aW9uL25hdmlnYXRpb24uY29tcG9uZW50JztcbmltcG9ydCB7IFBhZ2VIZWFkZXJDb21wb25lbnQgfSBmcm9tICcuL3BhZ2UtaGVhZGVyLmNvbXBvbmVudCc7XG5cblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIEJyZWFkY3J1bWJzTW9kdWxlLFxuICAgICAgICBCc0Ryb3Bkb3duTW9kdWxlLmZvclJvb3QoKSxcbiAgICAgICAgQ29sb3JTZXJ2aWNlTW9kdWxlLFxuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIE1lbnVOYXZpZ2F0aW9uTW9kdWxlLFxuICAgICAgICBSZXNpemVNb2R1bGUsXG4gICAgICAgIFJvdXRlck1vZHVsZSxcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgUGFnZUhlYWRlckNvbXBvbmVudCxcbiAgICAgICAgUGFnZUhlYWRlckN1c3RvbU1lbnVEaXJlY3RpdmVcbiAgICBdLFxuICAgIGRlY2xhcmF0aW9uczogW1xuICAgICAgICBQYWdlSGVhZGVyQ29tcG9uZW50LFxuICAgICAgICBQYWdlSGVhZGVySWNvbk1lbnVDb21wb25lbnQsXG4gICAgICAgIFBhZ2VIZWFkZXJDdXN0b21NZW51RGlyZWN0aXZlLFxuICAgICAgICBQYWdlSGVhZGVyTmF2aWdhdGlvbkNvbXBvbmVudCxcbiAgICAgICAgUGFnZUhlYWRlck5hdmlnYXRpb25JdGVtQ29tcG9uZW50LFxuICAgICAgICBQYWdlSGVhZGVyTmF2aWdhdGlvbkRyb3Bkb3duSXRlbUNvbXBvbmVudCxcbiAgICAgICAgUGFnZUhlYWRlck5hdmlnYXRpb25TZWNvbmRhcnlJdGVtRGlyZWN0aXZlXG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBQYWdlSGVhZGVyTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENvbXBvbmVudCwgSG9zdEJpbmRpbmcsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtcHJvZ3Jlc3MtYmFyJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vcHJvZ3Jlc3MtYmFyLmNvbXBvbmVudC5odG1sJyxcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICBob3N0OiB7XG4gICAgICAgIHJvbGU6ICdwcm9ncmVzc2JhcidcbiAgICB9XG59KVxuZXhwb3J0IGNsYXNzIFByb2dyZXNzQmFyQ29tcG9uZW50IHtcbiAgICBASW5wdXQoKSB2YWx1ZTogbnVtYmVyID0gMDtcbiAgICBASW5wdXQoKSBASG9zdEJpbmRpbmcoJ2F0dHIuYXJpYS12YWx1ZW1pbicpIG1pbjogbnVtYmVyID0gMDtcbiAgICBASW5wdXQoKSBASG9zdEJpbmRpbmcoJ2F0dHIuYXJpYS12YWx1ZW1heCcpIG1heDogbnVtYmVyID0gMTAwO1xuICAgIEBJbnB1dCgpIGluZGV0ZXJtaW5hdGU6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBASW5wdXQoKSB0cmFja0NvbG9yOiBzdHJpbmc7XG4gICAgQElucHV0KCkgYmFyQ29sb3I6IHN0cmluZztcblxuICAgIC8qKiBXaGVuIGluZGV0ZW1pbmF0ZSB3ZSBzaG91bGQgb21pdCB0aGUgdmFsdWVub3cgbGFiZWwgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIuYXJpYS12YWx1ZW5vdycpIGdldCB2YWx1ZU5vdygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXRlcm1pbmF0ZSA/IG51bGwgOiB0aGlzLnZhbHVlO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuXG5pbXBvcnQgeyBQcm9ncmVzc0JhckNvbXBvbmVudCB9IGZyb20gJy4vcHJvZ3Jlc3MtYmFyLmNvbXBvbmVudCc7XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGVcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtQcm9ncmVzc0JhckNvbXBvbmVudF0sXG4gICAgZGVjbGFyYXRpb25zOiBbUHJvZ3Jlc3NCYXJDb21wb25lbnRdXG59KVxuZXhwb3J0IGNsYXNzIFByb2dyZXNzQmFyTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIElucHV0LCBPdXRwdXQsIGZvcndhcmRSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBOR19WQUxVRV9BQ0NFU1NPUiB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuZXhwb3J0IGNvbnN0IFJBRElPQlVUVE9OX1ZBTFVFX0FDQ0VTU09SOiBhbnkgPSB7XG4gICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gUmFkaW9CdXR0b25Db21wb25lbnQpLFxuICAgIG11bHRpOiB0cnVlXG59O1xuXG5sZXQgdW5pcXVlUmFkaW9JZCA9IDA7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtcmFkaW8tYnV0dG9uJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vcmFkaW9idXR0b24uY29tcG9uZW50Lmh0bWwnLFxuICAgIHByb3ZpZGVyczogW1JBRElPQlVUVE9OX1ZBTFVFX0FDQ0VTU09SXVxufSlcbmV4cG9ydCBjbGFzcyBSYWRpb0J1dHRvbkNvbXBvbmVudCBpbXBsZW1lbnRzIENvbnRyb2xWYWx1ZUFjY2Vzc29yIHtcblxuICAgIHByaXZhdGUgX3JhZGlvQnV0dG9uSWQ6IHN0cmluZyA9IGB1eC1yYWRpby1idXR0b24tJHsrK3VuaXF1ZVJhZGlvSWR9YDtcblxuICAgIEBJbnB1dCgpIGlkOiBzdHJpbmcgPSB0aGlzLl9yYWRpb0J1dHRvbklkO1xuICAgIEBJbnB1dCgpIG5hbWU6IHN0cmluZyB8IG51bGw7XG4gICAgQElucHV0KCkgcmVxdWlyZWQ6IGJvb2xlYW47XG4gICAgQElucHV0KCkgdGFiaW5kZXg6IG51bWJlciA9IDA7XG4gICAgQElucHV0KCkgY2xpY2thYmxlOiBib29sZWFuID0gdHJ1ZTtcbiAgICBASW5wdXQoKSBkaXNhYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIEBJbnB1dCgpIHNpbXBsaWZpZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBASW5wdXQoKSBvcHRpb246IGFueTtcbiAgICBASW5wdXQoJ2FyaWEtbGFiZWwnKSBhcmlhTGFiZWw6IHN0cmluZyA9ICcnO1xuICAgIEBJbnB1dCgnYXJpYS1sYWJlbGxlZGJ5JykgYXJpYUxhYmVsbGVkYnk6IHN0cmluZyA9IG51bGw7XG4gICAgQElucHV0KCdhcmlhLWRlc2NyaWJlZGJ5JykgYXJpYURlc2NyaWJlZGJ5OiBzdHJpbmcgPSBudWxsO1xuXG4gICAgQE91dHB1dCgpIHZhbHVlQ2hhbmdlOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gICAgQElucHV0KClcbiAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICB9XG5cbiAgICBzZXQgdmFsdWUodmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcblxuICAgICAgICAvLyBpbnZva2UgY2hhbmdlIGV2ZW50XG4gICAgICAgIHRoaXMudmFsdWVDaGFuZ2UuZW1pdCh0aGlzLl92YWx1ZSk7XG5cbiAgICAgICAgLy8gY2FsbCBjYWxsYmFja1xuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2sodGhpcy5fdmFsdWUpO1xuICAgICAgICB0aGlzLm9uVG91Y2hlZENhbGxiYWNrKCk7ICAgICAgICBcbiAgICB9XG5cbiAgICBnZXQgaW5wdXRJZCgpOiBzdHJpbmcgeyBcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuaWQgfHwgdGhpcy5fcmFkaW9CdXR0b25JZH0taW5wdXRgO1xuICAgIH1cblxuICAgIHByaXZhdGUgX3ZhbHVlOiBhbnkgPSBmYWxzZTtcblxuICAgIGZvY3VzZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBvblRvdWNoZWRDYWxsYmFjazogKCkgPT4gdm9pZCA9ICgpID0+IHsgfTtcbiAgICBvbkNoYW5nZUNhbGxiYWNrOiAoXzogYW55KSA9PiB2b2lkID0gKCkgPT4geyB9O1xuXG4gICAgdG9nZ2xlKCk6IHZvaWQge1xuXG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkIHx8ICF0aGlzLmNsaWNrYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdG9nZ2xlIHRoZSBjaGVja2VkIHN0YXRlXG4gICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLm9wdGlvbjtcblxuICAgICAgICAvLyBjYWxsIGNhbGxiYWNrXG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjayh0aGlzLnZhbHVlKTtcbiAgICB9XG5cbiAgICAvLyBGdW5jdGlvbnMgcmVxdWlyZWQgdG8gdXBkYXRlIG5nLW1vZGVsXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZTogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMuX3ZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVnaXN0ZXJPbkNoYW5nZShmbjogYW55KTogdm9pZCB7XG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjayA9IGZuO1xuICAgIH1cblxuICAgIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5vblRvdWNoZWRDYWxsYmFjayA9IGZuO1xuICAgIH1cblxuICAgIHNldERpc2FibGVkU3RhdGUoaXNEaXNhYmxlZDogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gaXNEaXNhYmxlZDtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtGb3Jtc01vZHVsZX0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5pbXBvcnQgeyBSYWRpb0J1dHRvbkNvbXBvbmVudCB9IGZyb20gJy4vcmFkaW9idXR0b24uY29tcG9uZW50JztcblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbRm9ybXNNb2R1bGVdLFxuICAgIGV4cG9ydHM6IFtSYWRpb0J1dHRvbkNvbXBvbmVudF0sXG4gICAgZGVjbGFyYXRpb25zOiBbUmFkaW9CdXR0b25Db21wb25lbnRdXG59KVxuZXhwb3J0IGNsYXNzIFJhZGlvQnV0dG9uTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcy9CZWhhdmlvclN1YmplY3QnO1xuXG5jb25zdCBVTlNFVF9GT0NVUzogU2VhcmNoQnVpbGRlckZvY3VzID0geyBncm91cElkOiBudWxsLCBpbmRleDogLTEgfTtcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFNlYXJjaEJ1aWxkZXJGb2N1c1NlcnZpY2Uge1xuXG4gICAgZm9jdXMkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxTZWFyY2hCdWlsZGVyRm9jdXM+KFVOU0VUX0ZPQ1VTKTtcblxuICAgIC8qKlxuICAgICAqIFNldCBmb2N1cyBvbiBhIHNlYXJjaCBidWlsZGVyIGNvbXBvbmVudC5cbiAgICAgKiBAcGFyYW0gZ3JvdXBJZCBUaGUgYGlkYCBvZiB0aGUgZ3JvdXAgY29udGFpbmluZyB0aGUgY29tcG9uZW50LlxuICAgICAqIEBwYXJhbSBpbmRleCBUaGUgKHplcm8tYmFzZWQpIGluZGV4IG9mIHRoZSBjb21wb25lbnQuXG4gICAgICovXG4gICAgc2V0Rm9jdXMoZ3JvdXBJZDogc3RyaW5nLCBpbmRleDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZm9jdXMkLm5leHQoeyBncm91cElkOiBncm91cElkLCBpbmRleDogaW5kZXggfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBmb2N1cyBmcm9tIGFsbCBjb21wb25lbnRzLiBJZiBmb2N1cyBpcyBub3Qgb24gYSBzZWFyY2ggYnVpbGRlciBjb21wb25lbnQsIHRoaXMgZG9lcyBub3RoaW5nLlxuICAgICAqL1xuICAgIGNsZWFyRm9jdXMoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZm9jdXMkLm5leHQoVU5TRVRfRk9DVVMpO1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBTZWFyY2hCdWlsZGVyRm9jdXMge1xuICAgIGdyb3VwSWQ6IHN0cmluZztcbiAgICBpbmRleDogbnVtYmVyO1xufSIsImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzL1N1YmplY3QnO1xuaW1wb3J0IHsgU2VhcmNoQnVpbGRlckNvbXBvbmVudERlZmluaXRpb24gfSBmcm9tICcuL2ludGVyZmFjZXMvY29tcG9uZW50LWRlZmluaXRpb24uaW50ZXJmYWNlJztcbmltcG9ydCB7IFNlYXJjaEJ1aWxkZXJRdWVyeSB9IGZyb20gJy4vaW50ZXJmYWNlcy9xdWVyeS5pbnRlcmZhY2UnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgU2VhcmNoQnVpbGRlclNlcnZpY2Uge1xuXG4gIHF1ZXJ5OiBTZWFyY2hCdWlsZGVyUXVlcnkgPSB7fTtcbiAgcXVlcnlDaGFuZ2U6IFN1YmplY3Q8U2VhcmNoQnVpbGRlclF1ZXJ5PiA9IG5ldyBTdWJqZWN0PFNlYXJjaEJ1aWxkZXJRdWVyeT4oKTtcbiAgdmFsaWRhdGlvbkNoYW5nZTogQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+ID0gbmV3IEJlaGF2aW9yU3ViamVjdDxib29sZWFuPih0cnVlKTtcblxuICBwcml2YXRlIF9jb21wb25lbnRJZDogbnVtYmVyID0gMDtcbiAgcHJpdmF0ZSBfY29tcG9uZW50czogU2VhcmNoQnVpbGRlckNvbXBvbmVudERlZmluaXRpb25bXSA9IFtdO1xuICBwcml2YXRlIF92YWxpZGF0aW9uOiB7IFtrZXk6IG51bWJlcl06IGJvb2xlYW4gfSA9IHt9O1xuXG4gIC8qKlxuICAgKiBBZGQgYSBjb21wb25lbnQgdG8gdGhlIGludGVybmFsIGxpc3Qgb2YgY29tcG9uZW50c1xuICAgKi9cbiAgcmVnaXN0ZXJDb21wb25lbnQoY29tcG9uZW50OiBTZWFyY2hCdWlsZGVyQ29tcG9uZW50RGVmaW5pdGlvbik6IHZvaWQge1xuXG4gICAgLy8gZW5zdXJlIHRoZXJlIGFyZSBubyBjb21wb25lbnRzIHdpdGggYSBtYXRjaGluZyBuYW1lXG4gICAgaWYgKHRoaXMuX2NvbXBvbmVudHMuZmluZChjbXAgPT4gY21wLm5hbWUgPT09IGNvbXBvbmVudC5uYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBTZWFyY2ggYnVpbGRlciBjb21wb25lbnRzIG11c3QgaGF2ZSBhIHVuaXF1ZSBuYW1lLiBUaGUgbmFtZSAke2NvbXBvbmVudC5uYW1lfSBoYXMgYWxyZWFkeSBiZWVuIHVzZWQuYCk7XG4gICAgfVxuXG4gICAgLy8gaWYgdW5pcXVlIHRoZW4gYWRkIHRoZSBjb21wb25lbnQgdG8gdGhlIGxpc3RcbiAgICB0aGlzLl9jb21wb25lbnRzLnB1c2goY29tcG9uZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWxrIHJlZ2lzdHJhdGlvbiBvZiBjb21wb25lbnRzXG4gICAqIChKdXN0IGEgaGVscGVyIG1ldGhvZClcbiAgICovXG4gIHJlZ2lzdGVyQ29tcG9uZW50cyhjb21wb25lbnRzOiBTZWFyY2hCdWlsZGVyQ29tcG9uZW50RGVmaW5pdGlvbltdKTogdm9pZCB7XG4gICAgY29tcG9uZW50cy5mb3JFYWNoKGNvbXBvbmVudCA9PiB0aGlzLnJlZ2lzdGVyQ29tcG9uZW50KGNvbXBvbmVudCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHJlZ2lzdGVyZWQgY29tcG9uZW50IGNsYXNzXG4gICAqL1xuICBnZXRDb21wb25lbnQobmFtZTogc3RyaW5nKTogYW55IHtcblxuICAgIC8vIGZpbmQgdGhlIGNvbXBvbmVudFxuICAgIGNvbnN0IGNvbXBvbmVudCA9IHRoaXMuX2NvbXBvbmVudHMuZmluZChjbXAgPT4gY21wLm5hbWUgPT09IG5hbWUpO1xuXG4gICAgLy8gaWYgdGhlcmUgaXMgbm8gbWF0Y2ggdGhyb3cgYW4gZXhjZXB0aW9uXG4gICAgaWYgKCFjb21wb25lbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gc2VhcmNoIGJ1aWxkIGNvbXBvbmVudCB3aXRoIHRoZSBuYW1lICR7bmFtZX0gZXhpc3RzYCk7XG4gICAgfVxuXG4gICAgLy8gZW5zdXJlIGNvbmZpZyBpcyBkZWZpbmVkIC0gYXQgbGVhc3QgdG8gYW4gZW1wdHkgb2JqZWN0XG4gICAgY29tcG9uZW50LmNvbmZpZyA9IGNvbXBvbmVudC5jb25maWcgfHwge307XG5cbiAgICByZXR1cm4gY29tcG9uZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgaW50ZXJuYWwgc2VhcmNoIHF1ZXJ5IHN0YXRlXG4gICAqIG5vdGUgdGhhdCB0aGUgcXVlcnkgd2lsbCBiZSBpbW11dGFibGVcbiAgICovXG4gIHNldFF1ZXJ5KHF1ZXJ5OiBTZWFyY2hCdWlsZGVyUXVlcnkpOiB2b2lkIHtcbiAgICB0aGlzLnF1ZXJ5ID0gT2JqZWN0LmFzc2lnbih7fSwgcXVlcnkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgY3VycmVudCBxdWVyeSBzdGF0ZVxuICAgKi9cbiAgZ2V0UXVlcnkoKTogU2VhcmNoQnVpbGRlclF1ZXJ5IHtcbiAgICByZXR1cm4gdGhpcy5xdWVyeTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmlnZ2VyIHRoZSBvYnNlcnZhYmxlIHRvIGluZGljYXRlIHRoZSBxdWVyeSBoYXMgYmVlbiB1cGRhdGVkXG4gICAqL1xuICBxdWVyeUhhc0NoYW5nZWQoKTogdm9pZCB7XG4gICAgdGhpcy5xdWVyeUNoYW5nZS5uZXh0KHRoaXMucXVlcnkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3JlIHRoZSB2YWxpZGF0aW9uIHN0YXRlIG9mIHRoZSBxdWVyeVxuICAgKi9cbiAgc2V0VmFsaWQoaWQ6IG51bWJlciwgdmFsaWQ6IGJvb2xlYW4pOiB2b2lkIHtcblxuICAgIC8vIHN0b3JlIHRoZSBzdGF0ZSBmb3IgdGhpcyBzcGVjaWZpYyBjb21wb25lbnRcbiAgICB0aGlzLl92YWxpZGF0aW9uW2lkXSA9IHZhbGlkO1xuXG4gICAgLy8gZXZhbHVhdGUgdGhlIGVudGlyZSB2YWxpZGF0aW9uIHN0YXRlXG4gICAgdGhpcy52YWxpZGF0aW9uQ2hhbmdlLm5leHQoIU9iamVjdC5rZXlzKHRoaXMuX3ZhbGlkYXRpb24pLnNvbWUoa2V5ID0+ICF0aGlzLl92YWxpZGF0aW9uW2tleV0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHVuaXF1ZSBpZCBmb3IgZWFjaCBjb21wb25lbnRcbiAgICovXG4gIGdlbmVyYXRlQ29tcG9uZW50SWQoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fY29tcG9uZW50SWQrKztcbiAgfVxufVxuIiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU2VhcmNoQnVpbGRlckdyb3VwUXVlcnkgfSBmcm9tICcuLi9pbnRlcmZhY2VzL2dyb3VwLXF1ZXJ5LmludGVyZmFjZSc7XG5pbXBvcnQgeyBTZWFyY2hCdWlsZGVyRm9jdXNTZXJ2aWNlIH0gZnJvbSAnLi4vc2VhcmNoLWJ1aWxkZXItZm9jdXMuc2VydmljZSc7XG5pbXBvcnQgeyBTZWFyY2hCdWlsZGVyU2VydmljZSB9IGZyb20gJy4uL3NlYXJjaC1idWlsZGVyLnNlcnZpY2UnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgU2VhcmNoQnVpbGRlckdyb3VwU2VydmljZSB7XG5cbiAgcHJpdmF0ZSBfaWQ6IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIF9zZWFyY2hCdWlsZGVyU2VydmljZTogU2VhcmNoQnVpbGRlclNlcnZpY2UsXG4gICAgcHJpdmF0ZSBfc2VhcmNoQnVpbGRlckZvY3VzU2VydmljZTogU2VhcmNoQnVpbGRlckZvY3VzU2VydmljZVxuICApIHsgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXNlIHRoZSBncm91cCBieSBkZWZpbmluZyBhbiBpZFxuICAgKi9cbiAgaW5pdChpZDogc3RyaW5nKTogdm9pZCB7XG4gICAgLy8gc3RvcmUgdGhlIG5hbWUgb2YgdGhlIGdyb3VwXG4gICAgdGhpcy5faWQgPSBpZDtcblxuICAgIC8vIGNyZWF0ZSB0aGUgZW50cnkgaW4gdGhlIHF1ZXJ5IG9iamVjdCBpZiBpdCBkb2Vzbid0IGV4aXN0XG4gICAgaWYgKCF0aGlzLl9zZWFyY2hCdWlsZGVyU2VydmljZS5xdWVyeVt0aGlzLl9pZF0pIHtcblxuICAgICAgLy8gY3JlYXRlIHRoZSBzZWN0aW9uXG4gICAgICB0aGlzLl9zZWFyY2hCdWlsZGVyU2VydmljZS5xdWVyeVt0aGlzLl9pZF0gPSBbXTtcblxuICAgICAgLy8gZW1pdCB0aGUgY2hhbmdlcyBhZnRlciB0aGUgaW5pdGlhbCBzZXR1cFxuICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLl9zZWFyY2hCdWlsZGVyU2VydmljZS5xdWVyeUhhc0NoYW5nZWQoKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIGZpZWxkIGZyb20gdGhlIHNlYXJjaCBidWlsZGVyIHF1ZXJ5IGFuZCByZXR1cm4gZm9jdXMgdG8gdGhlIHByZXZpb3VzIGZpZWxkLlxuICAgKi9cbiAgcmVtb3ZlQXRJbmRleChpbmRleDogbnVtYmVyKTogdm9pZCB7XG5cbiAgICAvLyBnZXQgdGhlIHF1ZXJ5IGZvciB0aGlzIGdyb3VwXG4gICAgY29uc3QgcXVlcnkgPSB0aGlzLmdldFF1ZXJ5KCk7XG5cbiAgICAvLyByZW1vdmUgdGhlIGZpZWxkIGZyb20gdGhlIGFycmF5XG4gICAgcXVlcnkuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgIC8vIEZvY3VzIHRoZSBwcmV2aW91cyBpdGVtIGlmIGF2YWlsYWJsZVxuICAgIHRoaXMuX3NlYXJjaEJ1aWxkZXJGb2N1c1NlcnZpY2Uuc2V0Rm9jdXModGhpcy5faWQsIGluZGV4IDw9IDAgPyAwIDogaW5kZXggLSAxKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHF1ZXJ5IGZvciB0aGlzIHNwZWNpZmljIHNlYXJjaCBncm91cFxuICAgKi9cbiAgZ2V0UXVlcnkoKTogU2VhcmNoQnVpbGRlckdyb3VwUXVlcnlbXSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlYXJjaEJ1aWxkZXJTZXJ2aWNlLnF1ZXJ5W3RoaXMuX2lkXSA/IHRoaXMuX3NlYXJjaEJ1aWxkZXJTZXJ2aWNlLnF1ZXJ5W3RoaXMuX2lkXSA6IFtdO1xuICB9XG59XG4iLCJpbXBvcnQgeyBDb21wb25lbnQsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE9uRGVzdHJveSwgT25Jbml0LCBPdXRwdXQsIFRlbXBsYXRlUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcbmltcG9ydCB7IFNlYXJjaEJ1aWxkZXJHcm91cFF1ZXJ5IH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9ncm91cC1xdWVyeS5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgU2VhcmNoQnVpbGRlckZvY3VzU2VydmljZSB9IGZyb20gJy4uL3NlYXJjaC1idWlsZGVyLWZvY3VzLnNlcnZpY2UnO1xuaW1wb3J0IHsgU2VhcmNoQnVpbGRlckdyb3VwU2VydmljZSB9IGZyb20gJy4vc2VhcmNoLWJ1aWxkZXItZ3JvdXAuc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ3V4LXNlYXJjaC1idWlsZGVyLWdyb3VwJyxcbiAgdGVtcGxhdGVVcmw6ICcuL3NlYXJjaC1idWlsZGVyLWdyb3VwLmNvbXBvbmVudC5odG1sJyxcbiAgcHJvdmlkZXJzOiBbU2VhcmNoQnVpbGRlckdyb3VwU2VydmljZV1cbn0pXG5leHBvcnQgY2xhc3MgU2VhcmNoQnVpbGRlckdyb3VwQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuXG4gIEBJbnB1dCgpIGlkOiBzdHJpbmc7XG4gIEBJbnB1dCgpIGhlYWRlcjogc3RyaW5nO1xuICBASW5wdXQoKSBvcGVyYXRvcjogU2VhcmNoQnVpbGRlckdyb3VwT3BlcmF0b3IgPSAnYW5kJztcbiAgQElucHV0KCkgYWRkVGV4dDogc3RyaW5nID0gJ0FkZCBhIGZpZWxkJztcbiAgQElucHV0KCkgcGxhY2Vob2xkZXI6IFRlbXBsYXRlUmVmPGFueT47XG4gIEBJbnB1dCgpIHNob3dQbGFjZWhvbGRlcjogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIEBPdXRwdXQoKSBhZGQ6IEV2ZW50RW1pdHRlcjxNb3VzZUV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8TW91c2VFdmVudD4oKTtcbiAgQE91dHB1dCgpIHJlbW92ZTogRXZlbnRFbWl0dGVyPFNlYXJjaEJ1aWxkZXJHcm91cFF1ZXJ5PiA9IG5ldyBFdmVudEVtaXR0ZXI8U2VhcmNoQnVpbGRlckdyb3VwUXVlcnk+KCk7XG5cbiAgZm9jdXNJbmRleDogbnVtYmVyID0gLTE7XG5cbiAgcHJpdmF0ZSBfb25EZXN0cm95ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgc2VhcmNoQnVpbGRlckdyb3VwU2VydmljZTogU2VhcmNoQnVpbGRlckdyb3VwU2VydmljZSxcbiAgICBwcml2YXRlIF9zZWFyY2hCdWlsZGVyRm9jdXNTZXJ2aWNlOiBTZWFyY2hCdWlsZGVyRm9jdXNTZXJ2aWNlXG4gICkgeyB9XG5cbiAgbmdPbkluaXQoKTogdm9pZCB7XG5cbiAgICAvLyBlbnN1cmUgd2UgaGF2ZSBhIG5hbWUgb3RoZXJ3aXNlIHRocm93IGFuIGVycm9yXG4gICAgaWYgKCF0aGlzLmlkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlYXJjaCBidWlsZGVyIGdyb3VwIG11c3QgaGF2ZSBhbiBpZCBhdHRyaWJ1dGUuJyk7XG4gICAgfVxuXG4gICAgLy8gb3RoZXJ3aXNlIHJlZ2lzdGVyIHRoZSBncm91cFxuICAgIHRoaXMuc2VhcmNoQnVpbGRlckdyb3VwU2VydmljZS5pbml0KHRoaXMuaWQpO1xuXG4gICAgLy8gVHJhY2sgZm9jdXMgZm9yIGNoaWxkIGNvbXBvbmVudHNcbiAgICB0aGlzLl9zZWFyY2hCdWlsZGVyRm9jdXNTZXJ2aWNlLmZvY3VzJC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUoZm9jdXMgPT4ge1xuICAgICAgdGhpcy5mb2N1c0luZGV4ID0gKGZvY3VzLmdyb3VwSWQgPT09IHRoaXMuaWQpID8gZm9jdXMuaW5kZXggOiAtMTtcbiAgICB9KTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMuX29uRGVzdHJveS5uZXh0KCk7XG4gICAgdGhpcy5fb25EZXN0cm95LmNvbXBsZXRlKCk7XG4gIH1cblxuICBhZGRGaWVsZChldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xuICAgIHRoaXMuYWRkLmVtaXQoZXZlbnQpO1xuICB9XG5cbiAgcmVtb3ZlRmllbGRBdEluZGV4KGluZGV4OiBudW1iZXIsIGZpZWxkOiBTZWFyY2hCdWlsZGVyR3JvdXBRdWVyeSk6IHZvaWQge1xuICAgIHRoaXMuc2VhcmNoQnVpbGRlckdyb3VwU2VydmljZS5yZW1vdmVBdEluZGV4KGluZGV4KTtcbiAgICB0aGlzLnJlbW92ZS5lbWl0KGZpZWxkKTtcbiAgfVxuXG4gIHNldEZvY3VzKGluZGV4OiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLl9zZWFyY2hCdWlsZGVyRm9jdXNTZXJ2aWNlLnNldEZvY3VzKHRoaXMuaWQsIGluZGV4KTtcbiAgfVxuXG4gIGNsZWFyRm9jdXMoKTogdm9pZCB7XG4gICAgdGhpcy5fc2VhcmNoQnVpbGRlckZvY3VzU2VydmljZS5jbGVhckZvY3VzKCk7XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgU2VhcmNoQnVpbGRlckdyb3VwT3BlcmF0b3IgPSAnYW5kJyB8ICdvcicgfCAnbm90JztcbiIsImltcG9ydCB7IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlciwgQ29tcG9uZW50UmVmLCBEaXJlY3RpdmUsIElucHV0LCBPbkRlc3Ryb3ksIE9uSW5pdCwgVmlld0NvbnRhaW5lclJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgZGVsYXksIGRpc3RpbmN0VW50aWxDaGFuZ2VkLCB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcbmltcG9ydCB7IFNlYXJjaEJ1aWxkZXJGb2N1c1NlcnZpY2UgfSBmcm9tICcuLi9zZWFyY2gtYnVpbGRlci1mb2N1cy5zZXJ2aWNlJztcbmltcG9ydCB7IFNlYXJjaEJ1aWxkZXJTZXJ2aWNlIH0gZnJvbSAnLi4vc2VhcmNoLWJ1aWxkZXIuc2VydmljZSc7XG5pbXBvcnQgeyBCYXNlU2VhcmNoQ29tcG9uZW50IH0gZnJvbSAnLi4vc2VhcmNoLWNvbXBvbmVudHMvYmFzZS1zZWFyY2guY29tcG9uZW50JztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbdXhTZWFyY2hCdWlsZGVyT3V0bGV0XSdcbn0pXG5leHBvcnQgY2xhc3MgU2VhcmNoQnVpbGRlck91dGxldERpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcblxuICAgIEBJbnB1dCgndXhTZWFyY2hCdWlsZGVyT3V0bGV0Jykgb3V0bGV0OiBzdHJpbmc7XG4gICAgQElucHV0KCd1eFNlYXJjaEJ1aWxkZXJPdXRsZXRDb250ZXh0JykgY29udGV4dDogYW55O1xuICAgIEBJbnB1dCgndXhTZWFyY2hCdWlsZGVyT3V0bGV0R3JvdXBJZCcpIGdyb3VwSWQ6IHN0cmluZztcbiAgICBASW5wdXQoJ3V4U2VhcmNoQnVpbGRlck91dGxldEluZGV4JykgaW5kZXg6IG51bWJlcjtcblxuICAgIHByaXZhdGUgX2NvbXBvbmVudFJlZjogQ29tcG9uZW50UmVmPEJhc2VTZWFyY2hDb21wb25lbnQ+O1xuICAgIHByaXZhdGUgX29uRGVzdHJveSA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBfdmlld0NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZixcbiAgICAgICAgcHJpdmF0ZSBfY29tcG9uZW50RmFjdG9yeVJlc29sdmVyOiBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsXG4gICAgICAgIHByaXZhdGUgX3NlYXJjaEJ1aWxkZXJTZXJ2aWNlOiBTZWFyY2hCdWlsZGVyU2VydmljZSxcbiAgICAgICAgcHJpdmF0ZSBfc2VhcmNoQnVpbGRlckZvY3VzU2VydmljZTogU2VhcmNoQnVpbGRlckZvY3VzU2VydmljZVxuICAgICkgeyB9XG5cbiAgICBuZ09uSW5pdCgpOiB2b2lkIHtcblxuICAgICAgICAvLyBnZXQgdGhlIGNsYXNzIGZyb20gdGhlIHR5cGVcbiAgICAgICAgY29uc3QgY29tcG9uZW50RGVmaW5pdGlvbiA9IHRoaXMuX3NlYXJjaEJ1aWxkZXJTZXJ2aWNlLmdldENvbXBvbmVudCh0aGlzLm91dGxldCk7XG5cbiAgICAgICAgLy8gY3JlYXRlIHRoZSBjb21wb25lbnQgZmFjdG9yeVxuICAgICAgICBjb25zdCBjb21wb25lbnRGYWN0b3J5ID0gdGhpcy5fY29tcG9uZW50RmFjdG9yeVJlc29sdmVyLnJlc29sdmVDb21wb25lbnRGYWN0b3J5PEJhc2VTZWFyY2hDb21wb25lbnQ+KGNvbXBvbmVudERlZmluaXRpb24uY29tcG9uZW50KTtcblxuICAgICAgICAvLyBjcmVhdGUgdGhlIGNvbXBvbmVudCBpbnN0YW5jZVxuICAgICAgICB0aGlzLl9jb21wb25lbnRSZWYgPSB0aGlzLl92aWV3Q29udGFpbmVyUmVmLmNyZWF0ZUNvbXBvbmVudChjb21wb25lbnRGYWN0b3J5KTtcblxuICAgICAgICAvLyBjb21iaW5lIHRoZSBwcmVkZWZpbmVkIGNvbmZpZyB3aXRoIGFueSBkeW5tYWljIGNvbmZpZ1xuICAgICAgICBjb25zdCBjb25maWcgPSBPYmplY3QuYXNzaWduKHt9LCBjb21wb25lbnREZWZpbml0aW9uLmNvbmZpZywgdGhpcy5jb250ZXh0LmNvbmZpZyB8fCB7fSk7XG5cbiAgICAgICAgLy8gc2V0IHRoZSBjb250ZXh0IGFuZCBjb25maWcgcHJvcGVydHkgb24gdGhlIGNvbXBvbmVudCBpbnN0YW5jZVxuICAgICAgICB0aGlzLl9jb21wb25lbnRSZWYuaW5zdGFuY2UuY29udGV4dCA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgdGhpcy5fY29tcG9uZW50UmVmLmluc3RhbmNlLmNvbmZpZyA9IGNvbmZpZztcblxuICAgICAgICB0aGlzLl9zZWFyY2hCdWlsZGVyRm9jdXNTZXJ2aWNlLmZvY3VzJFxuICAgICAgICAgICAgLnBpcGUoZGlzdGluY3RVbnRpbENoYW5nZWQoKSwgZGVsYXkoMCksIHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKVxuICAgICAgICAgICAgLnN1YnNjcmliZShmb2N1cyA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29tcG9uZW50UmVmLmluc3RhbmNlLmZvY3VzID0gKGZvY3VzLmdyb3VwSWQgPT09IHRoaXMuZ3JvdXBJZCAmJiBmb2N1cy5pbmRleCA9PT0gdGhpcy5pbmRleCk7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fb25EZXN0cm95Lm5leHQoKTtcbiAgICAgICAgdGhpcy5fb25EZXN0cm95LmNvbXBsZXRlKCk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIElucHV0LCBPbkRlc3Ryb3ksIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgZGlzdGluY3RVbnRpbENoYW5nZWQgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBTZWFyY2hCdWlsZGVyQ29tcG9uZW50RGVmaW5pdGlvbiB9IGZyb20gJy4vaW50ZXJmYWNlcy9jb21wb25lbnQtZGVmaW5pdGlvbi5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgU2VhcmNoQnVpbGRlclF1ZXJ5IH0gZnJvbSAnLi9pbnRlcmZhY2VzL3F1ZXJ5LmludGVyZmFjZSc7XG5pbXBvcnQgeyBTZWFyY2hCdWlsZGVyU2VydmljZSB9IGZyb20gJy4vc2VhcmNoLWJ1aWxkZXIuc2VydmljZSc7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ3V4LXNlYXJjaC1idWlsZGVyJyxcbiAgdGVtcGxhdGVVcmw6ICcuL3NlYXJjaC1idWlsZGVyLmNvbXBvbmVudC5odG1sJyxcbiAgcHJvdmlkZXJzOiBbU2VhcmNoQnVpbGRlclNlcnZpY2VdXG59KVxuZXhwb3J0IGNsYXNzIFNlYXJjaEJ1aWxkZXJDb21wb25lbnQgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuXG4gIEBJbnB1dCgpXG4gIHNldCBjb21wb25lbnRzKGNvbXBvbmVudHM6IFNlYXJjaEJ1aWxkZXJDb21wb25lbnREZWZpbml0aW9uW10pIHtcbiAgICB0aGlzLl9zZWFyY2hCdWlsZGVyU2VydmljZS5yZWdpc3RlckNvbXBvbmVudHMoY29tcG9uZW50cyk7XG4gIH1cblxuICBASW5wdXQoKVxuICBzZXQgcXVlcnkodmFsdWU6IFNlYXJjaEJ1aWxkZXJRdWVyeSkge1xuICAgIHRoaXMuX3NlYXJjaEJ1aWxkZXJTZXJ2aWNlLnNldFF1ZXJ5KHZhbHVlKTtcbiAgfVxuXG4gIGdldCBxdWVyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VhcmNoQnVpbGRlclNlcnZpY2UuZ2V0UXVlcnkoKTtcbiAgfVxuXG4gIEBPdXRwdXQoKSBxdWVyeUNoYW5nZTogRXZlbnRFbWl0dGVyPFNlYXJjaEJ1aWxkZXJRdWVyeT4gPSBuZXcgRXZlbnRFbWl0dGVyPFNlYXJjaEJ1aWxkZXJRdWVyeT4oKTtcbiAgQE91dHB1dCgpIHZhbGlkOiBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4gPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KHRydWUpO1xuXG4gIHByaXZhdGUgX3F1ZXJ5U3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG4gIHByaXZhdGUgX3ZhbGlkU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIHRoZSBkZWZhdWx0IHNlYXJjaCBidWlsZGVyIGNvbXBvbmVudHNcbiAgICovXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX3NlYXJjaEJ1aWxkZXJTZXJ2aWNlOiBTZWFyY2hCdWlsZGVyU2VydmljZSkge1xuXG4gICAgLy8gd2F0Y2ggZm9yIGFueSBxdWVyeSBjaGFuZ2VzXG4gICAgdGhpcy5fcXVlcnlTdWJzY3JpcHRpb24gPSBfc2VhcmNoQnVpbGRlclNlcnZpY2UucXVlcnlDaGFuZ2Uuc3Vic2NyaWJlKHF1ZXJ5ID0+IHRoaXMucXVlcnlDaGFuZ2UuZW1pdChxdWVyeSkpO1xuXG4gICAgLy8gd2F0Y2ggZm9yIGFueSBjaGFuZ2VzIHRvIHRoZSB2YWxpZGF0aW9uXG4gICAgdGhpcy5fdmFsaWRTdWJzY3JpcHRpb24gPSBfc2VhcmNoQnVpbGRlclNlcnZpY2UudmFsaWRhdGlvbkNoYW5nZS5waXBlKGRpc3RpbmN0VW50aWxDaGFuZ2VkKCkpLnN1YnNjcmliZSh2YWxpZCA9PiB0aGlzLnZhbGlkLmVtaXQodmFsaWQpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW55IHN1YnNjcmlwdGlvbnMgYW5kIGNsZWFudXBcbiAgICovXG4gIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMuX3F1ZXJ5U3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgdGhpcy5fdmFsaWRTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgfVxuXG59XG4iLCJpbXBvcnQgeyBET0NVTUVOVCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XHJcbmltcG9ydCB7IENvbXBvbmVudCwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBmb3J3YXJkUmVmLCBIb3N0QmluZGluZywgSG9zdExpc3RlbmVyLCBJbmplY3QsIElucHV0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSwgT25Jbml0LCBPdXRwdXQsIFNpbXBsZUNoYW5nZXMsIFN0YXRpY1Byb3ZpZGVyLCBUZW1wbGF0ZVJlZiwgVmlld0NoaWxkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBOR19WQUxVRV9BQ0NFU1NPUiB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcclxuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcy9CZWhhdmlvclN1YmplY3QnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcy9PYnNlcnZhYmxlJztcclxuaW1wb3J0IHsgZGVib3VuY2VUaW1lLCBkZWxheSwgZGlzdGluY3RVbnRpbENoYW5nZWQsIGZpbHRlciwgbWFwLCB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzL1N1YmplY3QnO1xyXG5pbXBvcnQgeyBJbmZpbml0ZVNjcm9sbExvYWRGdW5jdGlvbiB9IGZyb20gJy4uLy4uL2RpcmVjdGl2ZXMvaW5maW5pdGUtc2Nyb2xsL2luZGV4JztcclxuaW1wb3J0IHsgVGFnSW5wdXRDb21wb25lbnQgfSBmcm9tICcuLi90YWctaW5wdXQvaW5kZXgnO1xyXG5pbXBvcnQgeyBUeXBlYWhlYWRDb21wb25lbnQsIFR5cGVhaGVhZEtleVNlcnZpY2UsIFR5cGVhaGVhZE9wdGlvbkV2ZW50IH0gZnJvbSAnLi4vdHlwZWFoZWFkL2luZGV4JztcclxuXHJcbmxldCB1bmlxdWVJZCA9IDA7XHJcblxyXG5leHBvcnQgY29uc3QgU0VMRUNUX1ZBTFVFX0FDQ0VTU09SOiBTdGF0aWNQcm92aWRlciA9IHtcclxuICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxyXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gU2VsZWN0Q29tcG9uZW50KSxcclxuICAgIG11bHRpOiB0cnVlXHJcbn07XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICAgIHNlbGVjdG9yOiAndXgtc2VsZWN0JyxcclxuICAgIHRlbXBsYXRlVXJsOiAnc2VsZWN0LmNvbXBvbmVudC5odG1sJyxcclxuICAgIHByb3ZpZGVyczogW1NFTEVDVF9WQUxVRV9BQ0NFU1NPUl0sXHJcbiAgICBob3N0OiB7XHJcbiAgICAgICAgJ3RhYmluZGV4JzogJzAnXHJcbiAgICB9XHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBTZWxlY3RDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uQ2hhbmdlcywgT25EZXN0cm95LCBDb250cm9sVmFsdWVBY2Nlc3NvciB7XHJcblxyXG4gICAgQElucHV0KCkgQEhvc3RCaW5kaW5nKCdhdHRyLmlkJykgaWQ6IHN0cmluZyA9IGB1eC1zZWxlY3QtJHsrK3VuaXF1ZUlkfWA7XHJcblxyXG4gICAgQElucHV0KClcclxuICAgIHNldCB2YWx1ZSh2YWx1ZTogYW55KSB7XHJcbiAgICAgICAgdGhpcy5fdmFsdWUkLm5leHQodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHZhbHVlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZSQudmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgQElucHV0KClcclxuICAgIHNldCBpbnB1dCh2YWx1ZTogc3RyaW5nKSB7XHJcbiAgICAgICAgdGhpcy5faW5wdXQkLm5leHQodmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGlucHV0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pbnB1dCQudmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgQElucHV0KClcclxuICAgIHNldCBkcm9wZG93bk9wZW4odmFsdWU6IGJvb2xlYW4pIHtcclxuICAgICAgICB0aGlzLl9kcm9wZG93bk9wZW4gPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLmRyb3Bkb3duT3BlbkNoYW5nZS5lbWl0KHZhbHVlKTtcclxuICAgIH1cclxuICAgIGdldCBkcm9wZG93bk9wZW4oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Ryb3Bkb3duT3BlbjtcclxuICAgIH1cclxuXHJcbiAgICBASW5wdXQoKSBvcHRpb25zOiBhbnlbXSB8IEluZmluaXRlU2Nyb2xsTG9hZEZ1bmN0aW9uO1xyXG4gICAgQElucHV0KCkgZGlzcGxheTogKG9wdGlvbjogYW55KSA9PiBzdHJpbmcgfCBzdHJpbmc7XHJcbiAgICBASW5wdXQoKSBrZXk6IChvcHRpb246IGFueSkgPT4gc3RyaW5nIHwgc3RyaW5nO1xyXG4gICAgQElucHV0KCkgYWxsb3dOdWxsOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICBASW5wdXQoKSBkaXNhYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgQElucHV0KCkgZHJvcERpcmVjdGlvbjogJ3VwJyB8ICdkb3duJyA9ICdkb3duJztcclxuICAgIEBJbnB1dCgpIG1heEhlaWdodDogc3RyaW5nID0gJzI1MHB4JztcclxuICAgIEBJbnB1dCgpIG11bHRpcGxlOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICBASW5wdXQoKSBwYWdlU2l6ZTogbnVtYmVyID0gMjA7XHJcbiAgICBASW5wdXQoKSBwbGFjZWhvbGRlcjogc3RyaW5nO1xyXG5cclxuICAgIEBJbnB1dCgpIGxvYWRpbmdUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcclxuICAgIEBJbnB1dCgpIG5vT3B0aW9uc1RlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xyXG4gICAgQElucHV0KCkgb3B0aW9uVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XHJcblxyXG4gICAgQE91dHB1dCgpIHZhbHVlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XHJcbiAgICBAT3V0cHV0KCkgaW5wdXRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPHN0cmluZz4oKTtcclxuICAgIEBPdXRwdXQoKSBkcm9wZG93bk9wZW5DaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XHJcblxyXG4gICAgQFZpZXdDaGlsZCgnc2luZ2xlSW5wdXQnKSBzaW5nbGVJbnB1dDogRWxlbWVudFJlZjtcclxuICAgIEBWaWV3Q2hpbGQoJ3RhZ0lucHV0JykgdGFnSW5wdXQ6IFRhZ0lucHV0Q29tcG9uZW50O1xyXG4gICAgQFZpZXdDaGlsZCgnbXVsdGlwbGVUeXBlYWhlYWQnKSBtdWx0aXBsZVR5cGVhaGVhZDogVHlwZWFoZWFkQ29tcG9uZW50O1xyXG4gICAgQFZpZXdDaGlsZCgnc2luZ2xlVHlwZWFoZWFkJykgc2luZ2xlVHlwZWFoZWFkOiBUeXBlYWhlYWRDb21wb25lbnQ7XHJcblxyXG4gICAgaGlnaGxpZ2h0ZWRFbGVtZW50OiBIVE1MRWxlbWVudDtcclxuICAgIGZpbHRlciQ6IE9ic2VydmFibGU8c3RyaW5nPjtcclxuICAgIHByb3BhZ2F0ZUNoYW5nZSA9IChfOiBhbnkpID0+IHsgfTtcclxuXHJcbiAgICBwcml2YXRlIF92YWx1ZSQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PGFueT4obnVsbCk7XHJcbiAgICBwcml2YXRlIF9pbnB1dCQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PHN0cmluZz4oJycpO1xyXG4gICAgcHJpdmF0ZSBfZHJvcGRvd25PcGVuOiBib29sZWFuID0gZmFsc2U7XHJcbiAgICBwcml2YXRlIF9vbkRlc3Ryb3kgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKFxyXG4gICAgICAgIHByaXZhdGUgX2VsZW1lbnQ6IEVsZW1lbnRSZWYsXHJcbiAgICAgICAgQEluamVjdChET0NVTUVOVCkgcHJpdmF0ZSBfZG9jdW1lbnQ6IGFueSxcclxuICAgICAgICBwcml2YXRlIF90eXBlYWhlYWRLZXlTZXJ2aWNlOiBUeXBlYWhlYWRLZXlTZXJ2aWNlKSB7IH1cclxuXHJcbiAgICBuZ09uSW5pdCgpIHtcclxuXHJcbiAgICAgICAgLy8gRW1pdCBjaGFuZ2UgZXZlbnRzXHJcbiAgICAgICAgdGhpcy5fdmFsdWUkLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSksIGRpc3RpbmN0VW50aWxDaGFuZ2VkKCkpLnN1YnNjcmliZSh2YWx1ZSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMudmFsdWVDaGFuZ2UuZW1pdCh2YWx1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcGFnYXRlQ2hhbmdlKHZhbHVlKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5faW5wdXQkLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSksIGRpc3RpbmN0VW50aWxDaGFuZ2VkKCkpLnN1YnNjcmliZSh2YWx1ZSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5wdXRDaGFuZ2UuZW1pdCh2YWx1ZSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIENoYW5nZXMgdG8gdGhlIGlucHV0IGZpZWxkXHJcbiAgICAgICAgdGhpcy5faW5wdXQkLnBpcGUoXHJcbiAgICAgICAgICAgIHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpLFxyXG4gICAgICAgICAgICBmaWx0ZXIodmFsdWUgPT4gdGhpcy5hbGxvd051bGwpLFxyXG4gICAgICAgICAgICBmaWx0ZXIodmFsdWUgPT4gIXRoaXMubXVsdGlwbGUgJiYgdmFsdWUgIT09IHRoaXMuZ2V0RGlzcGxheSh0aGlzLnZhbHVlKSlcclxuICAgICAgICApLnN1YnNjcmliZSh2YWx1ZSA9PiB0aGlzLnZhbHVlID0gbnVsbCk7XHJcblxyXG4gICAgICAgIC8vIFNldCB1cCBmaWx0ZXIgZnJvbSBpbnB1dFxyXG4gICAgICAgIHRoaXMuZmlsdGVyJCA9IHRoaXMuX2lucHV0JC5waXBlKFxyXG4gICAgICAgICAgICBtYXAoaW5wdXQgPT4gIXRoaXMubXVsdGlwbGUgJiYgaW5wdXQgPT09IHRoaXMuZ2V0RGlzcGxheSh0aGlzLnZhbHVlKSA/ICcnIDogaW5wdXQpLFxyXG4gICAgICAgICAgICBkZWJvdW5jZVRpbWUoMjAwKVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIC8vIE9wZW4gdGhlIGRyb3Bkb3duIHdoZW4gZmlsdGVyIGlzIG5vbmVtcHR5LlxyXG4gICAgICAgIHRoaXMuZmlsdGVyJC5waXBlKFxyXG4gICAgICAgICAgICB0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSxcclxuICAgICAgICAgICAgZmlsdGVyKHZhbHVlID0+IHZhbHVlICYmIHZhbHVlLmxlbmd0aCA+IDApXHJcbiAgICAgICAgKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5kcm9wZG93bk9wZW4gPSB0cnVlKTtcclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBzaW5nbGUtc2VsZWN0IGlucHV0IHdoZW4gdGhlIG1vZGVsIGNoYW5nZXNcclxuICAgICAgICB0aGlzLl92YWx1ZSQucGlwZShcclxuICAgICAgICAgICAgdGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSksXHJcbiAgICAgICAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKCksXHJcbiAgICAgICAgICAgIGRlbGF5KDApLFxyXG4gICAgICAgICAgICBmaWx0ZXIodmFsdWUgPT4gdmFsdWUgIT09IG51bGwgJiYgIXRoaXMubXVsdGlwbGUpXHJcbiAgICAgICAgKS5zdWJzY3JpYmUodmFsdWUgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmlucHV0ID0gdGhpcy5nZXREaXNwbGF5KHZhbHVlKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XHJcbiAgICAgICAgaWYgKGNoYW5nZXMubXVsdGlwbGUgJiYgIWNoYW5nZXMubXVsdGlwbGUuZmlyc3RDaGFuZ2UgJiYgY2hhbmdlcy5tdWx0aXBsZS5jdXJyZW50VmFsdWUgIT09IGNoYW5nZXMubXVsdGlwbGUucHJldmlvdXNWYWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLmlucHV0ID0gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX29uRGVzdHJveS5uZXh0KCk7XHJcbiAgICAgICAgdGhpcy5fb25EZXN0cm95LmNvbXBsZXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgQEhvc3RMaXN0ZW5lcignZm9jdXMnKVxyXG4gICAgb25mb2N1cygpOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5zaW5nbGVJbnB1dCkge1xyXG4gICAgICAgICAgICB0aGlzLnNpbmdsZUlucHV0Lm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMudGFnSW5wdXQpIHtcclxuICAgICAgICAgICAgdGhpcy50YWdJbnB1dC5mb2N1cygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB3cml0ZVZhbHVlKG9iajogYW55KTogdm9pZCB7XHJcbiAgICAgICAgaWYgKG9iaiAhPT0gdW5kZWZpbmVkICYmIG9iaiAhPT0gdGhpcy52YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gb2JqO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZWdpc3Rlck9uQ2hhbmdlKGZuOiBhbnkpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnByb3BhZ2F0ZUNoYW5nZSA9IGZuO1xyXG4gICAgfVxyXG5cclxuICAgIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiBhbnkpOiB2b2lkIHsgfVxyXG5cclxuICAgIHNldERpc2FibGVkU3RhdGUoaXNEaXNhYmxlZDogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xyXG4gICAgfVxyXG5cclxuICAgIGlucHV0Q2xpY2tIYW5kbGVyKGV2ZW50OiBNb3VzZUV2ZW50KSB7XHJcbiAgICAgICAgdGhpcy5zZWxlY3RJbnB1dFRleHQoKTtcclxuICAgICAgICB0aGlzLmRyb3Bkb3duT3BlbiA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgaW5wdXRCbHVySGFuZGxlcihldmVudDogRXZlbnQpIHtcclxuXHJcbiAgICAgICAgLy8gSWYgYSBjbGljayBvbiB0aGUgdHlwZWFoZWFkIGlzIGluIHByb2dyZXNzLCBqdXN0IHJlZm9jdXMgdGhlIGlucHV0LlxyXG4gICAgICAgIC8vIFRoaXMgd29ya3MgYXJvdW5kIGFuIGlzc3VlIGluIElFIHdoZXJlIGNsaWNraW5nIGEgc2Nyb2xsYmFyIGRyb3BzIGZvY3VzLlxyXG4gICAgICAgIGlmICh0aGlzLnNpbmdsZVR5cGVhaGVhZCAmJiB0aGlzLnNpbmdsZVR5cGVhaGVhZC5jbGlja2luZykge1xyXG4gICAgICAgICAgICB0aGlzLnNpbmdsZUlucHV0Lm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2xvc2UgZHJvcGRvd24gYW5kIHJlc2V0IHRleHQgaW5wdXQgaWYgZm9jdXMgaXMgbG9zdFxyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2VsZW1lbnQubmF0aXZlRWxlbWVudC5jb250YWlucyh0aGlzLl9kb2N1bWVudC5hY3RpdmVFbGVtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kcm9wZG93bk9wZW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5tdWx0aXBsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5wdXQgPSB0aGlzLmdldERpc3BsYXkodGhpcy52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCAyMDApO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogS2V5IGhhbmRsZXIgZm9yIHNpbmdsZSBzZWxlY3Qgb25seS4gTXVsdGlwbGUgc2VsZWN0IGtleSBoYW5kbGluZyBpcyBpbiBUYWdJbnB1dENvbXBvbmVudC5cclxuICAgICAqL1xyXG4gICAgaW5wdXRLZXlIYW5kbGVyKGV2ZW50OiBLZXlib2FyZEV2ZW50KSB7XHJcblxyXG4gICAgICAgIC8vIFN0YW5kYXJkIGtleXMgZm9yIHR5cGVhaGVhZCAodXAvZG93bi9lc2MpXHJcbiAgICAgICAgdGhpcy5fdHlwZWFoZWFkS2V5U2VydmljZS5oYW5kbGVLZXkoZXZlbnQsIHRoaXMuc2luZ2xlVHlwZWFoZWFkKTtcclxuXHJcbiAgICAgICAgc3dpdGNoIChldmVudC5rZXkpIHtcclxuICAgICAgICAgICAgY2FzZSAnRW50ZXInOlxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2Ryb3Bkb3duT3Blbikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCB0aGUgaGlnaGxpZ2h0ZWQgb3B0aW9uIGFzIHRoZSB2YWx1ZSBhbmQgY2xvc2VcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5zaW5nbGVUeXBlYWhlYWQuaGlnaGxpZ2h0ZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcm9wZG93bk9wZW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGlucHV0IGZpZWxkLiBJZiBkcm9wZG93biBpc24ndCBvcGVuIHRoZW4gcmVzZXQgaXQgdG8gdGhlIHByZXZpb3VzIHZhbHVlLlxyXG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dCA9IHRoaXMuZ2V0RGlzcGxheSh0aGlzLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgc2luZ2xlT3B0aW9uU2VsZWN0ZWQoZXZlbnQ6IFR5cGVhaGVhZE9wdGlvbkV2ZW50KSB7XHJcbiAgICAgICAgaWYgKGV2ZW50Lm9wdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gZXZlbnQub3B0aW9uO1xyXG4gICAgICAgICAgICB0aGlzLmRyb3Bkb3duT3BlbiA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGRpc3BsYXkgdmFsdWUgb2YgdGhlIGdpdmVuIG9wdGlvbi5cclxuICAgICAqL1xyXG4gICAgZ2V0RGlzcGxheShvcHRpb246IGFueSk6IHN0cmluZyB7XHJcbiAgICAgICAgaWYgKG9wdGlvbiA9PT0gbnVsbCB8fCBvcHRpb24gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5kaXNwbGF5ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRpc3BsYXkob3B0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmRpc3BsYXkgPT09ICdzdHJpbmcnICYmIG9wdGlvbi5oYXNPd25Qcm9wZXJ0eSh0aGlzLmRpc3BsYXkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25bPHN0cmluZz50aGlzLmRpc3BsYXldO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3B0aW9uO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgc2VsZWN0SW5wdXRUZXh0KCkge1xyXG4gICAgICAgIHRoaXMuc2luZ2xlSW5wdXQubmF0aXZlRWxlbWVudC5zZWxlY3QoKTtcclxuICAgIH1cclxufSIsImV4cG9ydCBjbGFzcyBUYWdJbnB1dEV2ZW50IHtcblxuICAgIHByaXZhdGUgX2RlZmF1bHRQcmV2ZW50ZWQgPSBmYWxzZTtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyB0YWc6IGFueSkge31cblxuICAgIHByZXZlbnREZWZhdWx0KCkge1xuICAgICAgICB0aGlzLl9kZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBkZWZhdWx0UHJldmVudGVkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmYXVsdFByZXZlbnRlZDtcbiAgICB9XG59IiwiaW1wb3J0IHsgQkFDS1NQQUNFLCBERUxFVEUsIEVOVEVSLCBMRUZUX0FSUk9XLCBSSUdIVF9BUlJPVywgU1BBQ0UgfSBmcm9tICdAYW5ndWxhci9jZGsva2V5Y29kZXMnO1xyXG5pbXBvcnQgeyBET0NVTUVOVCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XHJcbmltcG9ydCB7IEFmdGVyQ29udGVudEluaXQsIENvbXBvbmVudCwgQ29udGVudENoaWxkcmVuLCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIGZvcndhcmRSZWYsIEhvc3RCaW5kaW5nLCBIb3N0TGlzdGVuZXIsIEluamVjdCwgSW5wdXQsIE9uQ2hhbmdlcywgT25EZXN0cm95LCBPbkluaXQsIE91dHB1dCwgUXVlcnlMaXN0LCBTaW1wbGVDaGFuZ2VzLCBUZW1wbGF0ZVJlZiwgVmlld0NoaWxkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBOR19WQUxJREFUT1JTLCBOR19WQUxVRV9BQ0NFU1NPUiB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcclxuaW1wb3J0IHsgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcclxuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcy9TdWJzY3JpcHRpb24nO1xyXG5pbXBvcnQgeyB0aWNrIH0gZnJvbSAnLi4vLi4vY29tbW9uL2luZGV4JztcclxuaW1wb3J0IHsgVHlwZWFoZWFkQ29tcG9uZW50LCBUeXBlYWhlYWRLZXlTZXJ2aWNlIH0gZnJvbSAnLi4vdHlwZWFoZWFkL2luZGV4JztcclxuaW1wb3J0IHsgVHlwZWFoZWFkT3B0aW9uRXZlbnQgfSBmcm9tICcuLi90eXBlYWhlYWQvdHlwZWFoZWFkLWV2ZW50JztcclxuaW1wb3J0IHsgVGFnSW5wdXRFdmVudCB9IGZyb20gJy4vdGFnLWlucHV0LWV2ZW50JztcclxuXHJcbmxldCB1bmlxdWVJZCA9IDA7XHJcblxyXG5jb25zdCBUQUdJTlBVVF9WQUxVRV9BQ0NFU1NPUiA9IHtcclxuICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxyXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gVGFnSW5wdXRDb21wb25lbnQpLFxyXG4gICAgbXVsdGk6IHRydWVcclxufTtcclxuY29uc3QgVEFHSU5QVVRfVkFMSURBVE9SID0ge1xyXG4gICAgcHJvdmlkZTogTkdfVkFMSURBVE9SUyxcclxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFRhZ0lucHV0Q29tcG9uZW50KSxcclxuICAgIG11bHRpOiB0cnVlXHJcbn07XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICAgIHNlbGVjdG9yOiAndXgtdGFnLWlucHV0JyxcclxuICAgIGV4cG9ydEFzOiAndXgtdGFnLWlucHV0JyxcclxuICAgIHRlbXBsYXRlVXJsOiAndGFnLWlucHV0LmNvbXBvbmVudC5odG1sJyxcclxuICAgIHByb3ZpZGVyczogW1RBR0lOUFVUX1ZBTFVFX0FDQ0VTU09SLCBUQUdJTlBVVF9WQUxJREFUT1JdLFxyXG4gICAgaG9zdDoge1xyXG4gICAgICAgICdbY2xhc3MuZGlzYWJsZWRdJzogJ2Rpc2FibGVkJyxcclxuICAgICAgICAnW2NsYXNzLmZvY3VzXSc6ICdoYXNGb2N1cygpJyxcclxuICAgICAgICAnW2NsYXNzLmludmFsaWRdJzogJyF2YWxpZCB8fCAhaW5wdXRWYWxpZCdcclxuICAgIH1cclxufSlcclxuZXhwb3J0IGNsYXNzIFRhZ0lucHV0Q29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBBZnRlckNvbnRlbnRJbml0LCBPbkNoYW5nZXMsIENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBPbkRlc3Ryb3kge1xyXG5cclxuICAgIEBJbnB1dCgpIEBIb3N0QmluZGluZygnYXR0ci5pZCcpIGlkOiBzdHJpbmcgPSBgdXgtdGFnLWlucHV0LSR7Kyt1bmlxdWVJZH1gO1xyXG5cclxuICAgIEBJbnB1dCgndGFncycpXHJcbiAgICBnZXQgdGFncygpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX3RhZ3MpIHtcclxuICAgICAgICAgICAgdGhpcy5fdGFncyA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fdGFncztcclxuICAgIH1cclxuICAgIHNldCB0YWdzKHZhbHVlOiBhbnlbXSkge1xyXG4gICAgICAgIHRoaXMuX3RhZ3MgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLl9vbkNoYW5nZUhhbmRsZXIodGhpcy5fdGFncyk7XHJcbiAgICAgICAgdGhpcy50YWdzQ2hhbmdlLmVtaXQodGhpcy5fdGFncyk7XHJcbiAgICB9XHJcblxyXG4gICAgQE91dHB1dCgpIHRhZ3NDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGFueVtdPigpO1xyXG5cclxuICAgIEBJbnB1dCgnaW5wdXQnKVxyXG4gICAgZ2V0IGlucHV0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pbnB1dDtcclxuICAgIH1cclxuICAgIHNldCBpbnB1dCh2YWx1ZTogc3RyaW5nKSB7XHJcbiAgICAgICAgdGhpcy5faW5wdXQgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLmlucHV0Q2hhbmdlLmVtaXQodmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIEBPdXRwdXQoKSBpbnB1dENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8c3RyaW5nPigpO1xyXG5cclxuICAgIEBJbnB1dCgpIGRpc3BsYXk6IChvcHRpb246IGFueSkgPT4gc3RyaW5nIHwgc3RyaW5nO1xyXG4gICAgQElucHV0KCkgYWRkT25QYXN0ZTogYm9vbGVhbiA9IHRydWU7XHJcbiAgICBASW5wdXQoKSBkaXNhYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgQElucHV0KCkgZW5mb3JjZVRhZ0xpbWl0czogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgQElucHV0KCkgZnJlZUlucHV0OiBib29sZWFuID0gdHJ1ZTtcclxuICAgIEBJbnB1dCgpIG1heFRhZ3M6IG51bWJlciA9IE51bWJlci5NQVhfVkFMVUU7XHJcbiAgICBASW5wdXQoKSBtaW5UYWdzOiBudW1iZXIgPSAwO1xyXG4gICAgQElucHV0KCkgcGxhY2Vob2xkZXI6IHN0cmluZyA9ICcnO1xyXG4gICAgQElucHV0KCkgc2hvd1R5cGVhaGVhZE9uQ2xpY2s6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIEBJbnB1dCgpIHRhZ0RlbGltaXRlcnM6IHN0cmluZyA9ICcnO1xyXG4gICAgQElucHV0KCkgdGFnUGF0dGVybjogUmVnRXhwO1xyXG4gICAgQElucHV0KCkgdGFnVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XHJcbiAgICBASW5wdXQoKSB0YWdDbGFzczogVGFnQ2xhc3NGdW5jdGlvbiA9ICgpID0+IHVuZGVmaW5lZDtcclxuICAgIEBJbnB1dCgpIHZhbGlkYXRpb25FcnJvcnM6IGFueSA9IHt9O1xyXG4gICAgQElucHV0KCdjcmVhdGVUYWcnKSBjcmVhdGVUYWdIYW5kbGVyOiAodmFsdWU6IHN0cmluZykgPT4gYW55O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQGRlcHJlY2F0ZWRcclxuICAgICAqIFdvcmthcm91bmQgZm9yIEVMLTMyMjQgLSBObyBsb25nZXIgbmVlZGVkXHJcbiAgICAgKi9cclxuICAgIEBJbnB1dCgpIHRyYWNrQXJpYURlc2NlbmRhbnQ6IGJvb2xlYW4gPSB0cnVlO1xyXG5cclxuICAgIEBPdXRwdXQoKSB0YWdBZGRpbmcgPSBuZXcgRXZlbnRFbWl0dGVyPFRhZ0lucHV0RXZlbnQ+KCk7XHJcbiAgICBAT3V0cHV0KCkgdGFnQWRkZWQgPSBuZXcgRXZlbnRFbWl0dGVyPFRhZ0lucHV0RXZlbnQ+KCk7XHJcbiAgICBAT3V0cHV0KCkgdGFnSW52YWxpZGF0ZWQgPSBuZXcgRXZlbnRFbWl0dGVyPFRhZ0lucHV0RXZlbnQ+KCk7XHJcbiAgICBAT3V0cHV0KCkgdGFnUmVtb3ZpbmcgPSBuZXcgRXZlbnRFbWl0dGVyPFRhZ0lucHV0RXZlbnQ+KCk7XHJcbiAgICBAT3V0cHV0KCkgdGFnUmVtb3ZlZCA9IG5ldyBFdmVudEVtaXR0ZXI8VGFnSW5wdXRFdmVudD4oKTtcclxuICAgIEBPdXRwdXQoKSB0YWdDbGljayA9IG5ldyBFdmVudEVtaXR0ZXI8VGFnSW5wdXRFdmVudD4oKTtcclxuXHJcbiAgICBAQ29udGVudENoaWxkcmVuKFR5cGVhaGVhZENvbXBvbmVudCkgdHlwZWFoZWFkUXVlcnk6IFF1ZXJ5TGlzdDxUeXBlYWhlYWRDb21wb25lbnQ+O1xyXG5cclxuICAgIEBWaWV3Q2hpbGQoJ3RhZ0lucHV0JykgdGFnSW5wdXQ6IEVsZW1lbnRSZWY7XHJcblxyXG4gICAgQFZpZXdDaGlsZCgnZGVmYXVsdFRhZ1RlbXBsYXRlJykgcHJpdmF0ZSBfZGVmYXVsdFRhZ1RlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xyXG5cclxuICAgIHNlbGVjdGVkSW5kZXg6IG51bWJlciA9IC0xO1xyXG5cclxuICAgIHRhZ0FwaTogVGFnQXBpID0ge1xyXG4gICAgICAgIGdldFRhZ0Rpc3BsYXk6IHRoaXMuZ2V0VGFnRGlzcGxheS5iaW5kKHRoaXMpLFxyXG4gICAgICAgIHJlbW92ZVRhZ0F0OiB0aGlzLnJlbW92ZVRhZ0F0LmJpbmQodGhpcyksXHJcbiAgICAgICAgY2FuUmVtb3ZlVGFnQXQ6IHRoaXMuY2FuUmVtb3ZlVGFnQXQuYmluZCh0aGlzKVxyXG4gICAgfTtcclxuXHJcbiAgICB2YWxpZDogYm9vbGVhbiA9IHRydWU7XHJcbiAgICBpbnB1dFZhbGlkOiBib29sZWFuID0gdHJ1ZTtcclxuICAgIHR5cGVhaGVhZDogVHlwZWFoZWFkQ29tcG9uZW50O1xyXG4gICAgaGlnaGxpZ2h0ZWRFbGVtZW50OiBIVE1MRWxlbWVudDtcclxuXHJcbiAgICBwcml2YXRlIF9pbnB1dDogc3RyaW5nID0gJyc7XHJcbiAgICBwcml2YXRlIF90YWdzOiBhbnlbXSA9IFtdO1xyXG4gICAgcHJpdmF0ZSBfb25DaGFuZ2VIYW5kbGVyOiAoXzogYW55KSA9PiB2b2lkID0gKCkgPT4geyB9O1xyXG4gICAgcHJpdmF0ZSBfb25Ub3VjaGVkSGFuZGxlcjogKCkgPT4gdm9pZCA9ICgpID0+IHsgfTtcclxuICAgIHByaXZhdGUgX3N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xyXG4gICAgcHJpdmF0ZSBfb25EZXN0cm95ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihcclxuICAgICAgICBwcml2YXRlIF9lbGVtZW50OiBFbGVtZW50UmVmLFxyXG4gICAgICAgIEBJbmplY3QoRE9DVU1FTlQpIHByaXZhdGUgX2RvY3VtZW50OiBhbnksXHJcbiAgICAgICAgcHJpdmF0ZSBfdHlwZWFoZWFkS2V5U2VydmljZTogVHlwZWFoZWFkS2V5U2VydmljZSkgeyB9XHJcblxyXG4gICAgbmdPbkluaXQoKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnRhZ1RlbXBsYXRlKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGFnVGVtcGxhdGUgPSB0aGlzLl9kZWZhdWx0VGFnVGVtcGxhdGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpOiB2b2lkIHtcclxuICAgICAgICAvLyBXYXRjaCBmb3Igb3B0aW9uYWwgY2hpbGQgdHlwZWFoZWFkIGNvbnRyb2xcclxuICAgICAgICB0aGlzLmNvbm5lY3RUeXBlYWhlYWQodGhpcy50eXBlYWhlYWRRdWVyeS5maXJzdCk7XHJcblxyXG4gICAgICAgIHRoaXMudHlwZWFoZWFkUXVlcnkuY2hhbmdlcy5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKVxyXG4gICAgICAgICAgICAuc3Vic2NyaWJlKChxdWVyeSkgPT4gdGhpcy5jb25uZWN0VHlwZWFoZWFkKHF1ZXJ5LmZpcnN0KSk7XHJcbiAgICB9XHJcblxyXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xyXG4gICAgICAgIGlmIChjaGFuZ2VzLmRpc2FibGVkKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGFuZ2VzLmRpc2FibGVkLmN1cnJlbnRWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gQ2xlYXIgc2VsZWN0aW9uIGFuZCBjbG9zZSBkcm9wZG93blxyXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEluZGV4ID0gLTE7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50eXBlYWhlYWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnR5cGVhaGVhZC5vcGVuID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZSB2YWxpZGF0aW9uIHN0YXR1c1xyXG4gICAgICAgIHRoaXMudmFsaWRhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5fc3Vic2NyaXB0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5fb25EZXN0cm95Lm5leHQoKTtcclxuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kuY29tcGxldGUoKTtcclxuICAgIH1cclxuXHJcbiAgICB3cml0ZVZhbHVlKHZhbHVlOiBhbnlbXSk6IHZvaWQge1xyXG4gICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnRhZ3MgPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmVnaXN0ZXJPbkNoYW5nZShmbjogYW55KTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fb25DaGFuZ2VIYW5kbGVyID0gZm47XHJcbiAgICB9XHJcblxyXG4gICAgcmVnaXN0ZXJPblRvdWNoZWQoZm46IGFueSk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX29uVG91Y2hlZEhhbmRsZXIgPSBmbjtcclxuICAgIH1cclxuXHJcbiAgICBzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQ6IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmRpc2FibGVkID0gaXNEaXNhYmxlZDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCBmb2N1cyBvbiB0aGUgaW5wdXQgZmllbGQuXHJcbiAgICAgKi9cclxuICAgIGZvY3VzKCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLnRhZ0lucHV0KSB7XHJcbiAgICAgICAgICAgIHRoaXMudGFnSW5wdXQubmF0aXZlRWxlbWVudC5mb2N1cygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFZhbGlkYXRlIHRoZSB2YWx1ZSBvZiB0aGUgY29udHJvbCAodGFncyBwcm9wZXJ0eSkuXHJcbiAgICAgKi9cclxuICAgIHZhbGlkYXRlKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMudmFsaWQgPSB0cnVlO1xyXG4gICAgICAgIGxldCB0YWdSYW5nZUVycm9yID0gbnVsbDtcclxuICAgICAgICBpZiAodGhpcy50YWdzICYmICh0aGlzLnRhZ3MubGVuZ3RoIDwgdGhpcy5taW5UYWdzIHx8IHRoaXMudGFncy5sZW5ndGggPiB0aGlzLm1heFRhZ3MpKSB7XHJcbiAgICAgICAgICAgIHRhZ1JhbmdlRXJyb3IgPSB7XHJcbiAgICAgICAgICAgICAgICBnaXZlbjogdGhpcy50YWdzLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgIG1pbjogdGhpcy5taW5UYWdzLFxyXG4gICAgICAgICAgICAgICAgbWF4OiB0aGlzLm1heFRhZ3NcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy52YWxpZCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnZhbGlkYXRpb25FcnJvcnNbJ3RhZ1JhbmdlRXJyb3InXSA9IHRhZ1JhbmdlRXJyb3I7XHJcbiAgICB9XHJcblxyXG4gICAgQEhvc3RMaXN0ZW5lcigna2V5ZG93bicsIFsnJGV2ZW50J10pXHJcbiAgICBrZXlIYW5kbGVyKGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZCB7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7IHJldHVybjsgfVxyXG5cclxuICAgICAgICAvLyBHZXQgdGhlIGlucHV0IGZpZWxkIGN1cnNvciBsb2NhdGlvblxyXG4gICAgICAgIGNvbnN0IGlucHV0Q3Vyc29yUG9zID0gdGhpcy50YWdJbnB1dC5uYXRpdmVFbGVtZW50LnNlbGVjdGlvblN0YXJ0O1xyXG5cclxuICAgICAgICAvLyBEZXRlcm1pbmUgaWYgdGhlIGlucHV0IGZpZWxkIGhhcyBhbnkgdGV4dCBzZWxlY3RlZFxyXG4gICAgICAgIGNvbnN0IGhhc1NlbGVjdGlvbiA9IHRoaXMudGFnSW5wdXQubmF0aXZlRWxlbWVudC5zZWxlY3Rpb25TdGFydCAhPT0gdGhpcy50YWdJbnB1dC5uYXRpdmVFbGVtZW50LnNlbGVjdGlvbkVuZDtcclxuXHJcbiAgICAgICAgLy8gRGV0ZXJtaW5lIGlmIGEgdGFnIGhhcyBmb2N1c1xyXG4gICAgICAgIGNvbnN0IHRhZ1NlbGVjdGVkID0gdGhpcy5pc1ZhbGlkVGFnSW5kZXgodGhpcy5zZWxlY3RlZEluZGV4KTtcclxuXHJcbiAgICAgICAgY29uc3QgaW5wdXRMZW5ndGggPSB0aGlzLmlucHV0ID8gdGhpcy5pbnB1dC5sZW5ndGggOiAwO1xyXG5cclxuICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSBhcnJvdyBrZXlzIGNhbiBtb3ZlIHRoZSBzZWxlY3Rpb24uIE90aGVyd2lzZSB0aGUgaW5wdXQgZmllbGQgdGFrZXMgdGhlIGV2ZW50LlxyXG4gICAgICAgIGNvbnN0IGNhbk5hdmlnYXRlTGVmdCA9IHRhZ1NlbGVjdGVkIHx8IChpbnB1dEN1cnNvclBvcyA8PSAwICYmICFoYXNTZWxlY3Rpb24pO1xyXG4gICAgICAgIGNvbnN0IGNhbk5hdmlnYXRlUmlnaHQgPSB0YWdTZWxlY3RlZCB8fCAoaW5wdXRDdXJzb3JQb3MgPj0gaW5wdXRMZW5ndGggJiYgIWhhc1NlbGVjdGlvbik7XHJcblxyXG4gICAgICAgIC8vIEZvcndhcmQga2V5IGV2ZW50cyB0byB0aGUgdHlwZWFoZWFkIGNvbXBvbmVudC5cclxuICAgICAgICB0aGlzLl90eXBlYWhlYWRLZXlTZXJ2aWNlLmhhbmRsZUtleShldmVudCwgdGhpcy50eXBlYWhlYWQpO1xyXG5cclxuICAgICAgICBzd2l0Y2ggKGV2ZW50LndoaWNoKSB7XHJcbiAgICAgICAgICAgIGNhc2UgRU5URVI6XHJcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBhIHR5cGVhaGVhZCBvcHRpb24gaXMgaGlnaGxpZ2h0ZWRcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnR5cGVhaGVhZCAmJiB0aGlzLnR5cGVhaGVhZC5vcGVuICYmIHRoaXMudHlwZWFoZWFkLmhpZ2hsaWdodGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoZSB0eXBlYWhlYWQgb3B0aW9uIGFzIGEgdGFnLCBjbGVhciB0aGUgaW5wdXQsIGFuZCBjbG9zZSB0aGUgZHJvcGRvd25cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbW1pdFR5cGVhaGVhZCh0aGlzLnR5cGVhaGVhZC5oaWdobGlnaHRlZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50eXBlYWhlYWQub3BlbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBWYWxpZGF0ZSBhbmQgYWRkIHRoZSBpbnB1dCB0ZXh0IGFzIGEgdGFnLCBpZiBwb3NzaWJsZVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tbWl0SW5wdXQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgQkFDS1NQQUNFOlxyXG4gICAgICAgICAgICAgICAgaWYgKGNhbk5hdmlnYXRlTGVmdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYmFja3NwYWNlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSBERUxFVEU6XHJcbiAgICAgICAgICAgICAgICBpZiAodGFnU2VsZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVRhZ0F0KHRoaXMuc2VsZWN0ZWRJbmRleCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgTEVGVF9BUlJPVzpcclxuICAgICAgICAgICAgICAgIGlmIChjYW5OYXZpZ2F0ZUxlZnQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdmVTZWxlY3Rpb24oLTEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgUklHSFRfQVJST1c6XHJcbiAgICAgICAgICAgICAgICBpZiAoY2FuTmF2aWdhdGVSaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW92ZVNlbGVjdGlvbigxKTtcclxuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDaGVjayBmb3Iga2V5cyBpbiB0aGUgdGFnRGVsaW1pdGVyc1xyXG4gICAgICAgIGlmICh0aGlzLnRhZ0RlbGltaXRlcnMgJiYgdGhpcy50YWdEZWxpbWl0ZXJzLmluZGV4T2YodGhpcy5nZXRLZXlDaGFyKGV2ZW50KSkgPj0gMCkge1xyXG4gICAgICAgICAgICAvLyBDb21taXQgcHJldmlvdXMgdGV4dFxyXG4gICAgICAgICAgICB0aGlzLmNvbW1pdElucHV0KCk7XHJcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBASG9zdExpc3RlbmVyKCdmb2N1c291dCcpXHJcbiAgICBmb2N1c091dEhhbmRsZXIoKTogdm9pZCB7XHJcblxyXG4gICAgICAgIC8vIElmIGEgY2xpY2sgb24gdGhlIHR5cGVhaGVhZCBpcyBpbiBwcm9ncmVzcywgZG9uJ3QgZG8gYW55dGhpbmcuXHJcbiAgICAgICAgLy8gVGhpcyB3b3JrcyBhcm91bmQgYW4gaXNzdWUgaW4gSUUgd2hlcmUgY2xpY2tpbmcgYSBzY3JvbGxiYXIgZHJvcHMgZm9jdXMuXHJcbiAgICAgICAgaWYgKHRoaXMudHlwZWFoZWFkICYmIHRoaXMudHlwZWFoZWFkLmNsaWNraW5nKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENsb3NlIHRoZSBkcm9wZG93biBvbiBibHVyXHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fZWxlbWVudC5uYXRpdmVFbGVtZW50LmNvbnRhaW5zKHRoaXMuX2RvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkSW5kZXggPSAtMTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnR5cGVhaGVhZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHlwZWFoZWFkLm9wZW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIDIwMCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGFnQ2xpY2tIYW5kbGVyKGV2ZW50OiBNb3VzZUV2ZW50LCB0YWc6IGFueSwgaW5kZXg6IG51bWJlcik6IHZvaWQge1xyXG5cclxuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkgeyByZXR1cm47IH1cclxuXHJcbiAgICAgICAgLy8gU2VuZCB0YWdDbGljayBldmVudFxyXG4gICAgICAgIGNvbnN0IHRhZ0NsaWNrRXZlbnQgPSBuZXcgVGFnSW5wdXRFdmVudCh0YWcpO1xyXG4gICAgICAgIHRoaXMudGFnQ2xpY2suZW1pdCh0YWdDbGlja0V2ZW50KTtcclxuXHJcbiAgICAgICAgLy8gUHJldmVudCBmb2N1cyBpZiBwcmV2ZW50RGVmYXVsdCgpIHdhcyBjYWxsZWRcclxuICAgICAgICBpZiAodGFnQ2xpY2tFdmVudC5kZWZhdWx0UHJldmVudGVkKCkpIHtcclxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU2VsZWN0IHRoZSB0YWcgKGZvciBJRSB0aGF0IGRvZXNuJ3QgcHJvcGFnYXRlIGZvY3VzKVxyXG4gICAgICAgIHRoaXMuc2VsZWN0VGFnQXQoaW5kZXgpO1xyXG4gICAgfVxyXG5cclxuICAgIGlucHV0Q2xpY2tIYW5kbGVyKCk6IHZvaWQge1xyXG5cclxuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkgeyByZXR1cm47IH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMudHlwZWFoZWFkICYmIHRoaXMuc2hvd1R5cGVhaGVhZE9uQ2xpY2spIHtcclxuICAgICAgICAgICAgdGhpcy50eXBlYWhlYWQub3BlbiA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlucHV0Rm9jdXNIYW5kbGVyKCk6IHZvaWQge1xyXG5cclxuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnNlbGVjdElucHV0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgaW5wdXRQYXN0ZUhhbmRsZXIoZXZlbnQ6IENsaXBib2FyZEV2ZW50KTogdm9pZCB7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7IHJldHVybjsgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5hZGRPblBhc3RlKSB7XHJcbiAgICAgICAgICAgIC8vIEdldCB0ZXh0IGZyb20gdGhlIGNsaXBib2FyZFxyXG4gICAgICAgICAgICBsZXQgaW5wdXQ6IHN0cmluZyA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmIChldmVudC5jbGlwYm9hcmREYXRhKSB7XHJcbiAgICAgICAgICAgICAgICBpbnB1dCA9IGV2ZW50LmNsaXBib2FyZERhdGEuZ2V0RGF0YSgndGV4dC9wbGFpbicpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKCg8YW55PndpbmRvdykuY2xpcGJvYXJkRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgLy8gSW50ZXJuZXQgRXhwbG9yZXIgb25seVxyXG4gICAgICAgICAgICAgICAgaW5wdXQgPSAoPGFueT53aW5kb3cpLmNsaXBib2FyZERhdGEuZ2V0RGF0YSgnVGV4dCcpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBDb21taXQgdGhlIGNsaXBib2FyZCB0ZXh0IGRpcmVjdGx5XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbW1pdChpbnB1dCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0SW5wdXQoKTtcclxuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB0eXBlYWhlYWRPcHRpb25TZWxlY3RlZEhhbmRsZXIoZXZlbnQ6IFR5cGVhaGVhZE9wdGlvbkV2ZW50KTogdm9pZCB7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7IHJldHVybjsgfVxyXG5cclxuICAgICAgICAvLyBXaGVuIHRoZSB0eXBlYWhlYWQgc2VuZHMgdGhlIG9wdGlvblNlbGVjdGVkIGV2ZW50LCBjb21taXQgdGhlIG9iamVjdCBkaXJlY3RseVxyXG4gICAgICAgIHRoaXMuY29tbWl0VHlwZWFoZWFkKGV2ZW50Lm9wdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21taXQgdGhlIGN1cnJlbnQgaW5wdXQgdmFsdWUgYW5kIGNsZWFyIHRoZSBpbnB1dCBmaWVsZCBpZiBzdWNjZXNzZnVsLlxyXG4gICAgICovXHJcbiAgICBjb21taXRJbnB1dCgpOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5jb21taXQodGhpcy5pbnB1dCkpIHtcclxuICAgICAgICAgICAgdGhpcy5zZWxlY3RJbnB1dCgpO1xyXG4gICAgICAgICAgICB0aGlzLmlucHV0ID0gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tbWl0IHRoZSBnaXZlbiB0YWcgb2JqZWN0IGFuZCBjbGVhciB0aGUgaW5wdXQgaWYgc3VjY2Vzc2Z1bC5cclxuICAgICAqL1xyXG4gICAgY29tbWl0VHlwZWFoZWFkKHRhZzogYW55KTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHRoaXMuYWRkVGFnKHRhZykpIHtcclxuICAgICAgICAgICAgdGhpcy5zZWxlY3RJbnB1dCgpO1xyXG4gICAgICAgICAgICB0aGlzLmlucHV0ID0gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tbWl0IHRoZSBnaXZlbiBzdHJpbmcgdmFsdWUgYXMgb25lIG9yIG1vcmUgdGFncywgaWYgdmFsaWRhdGlvbiBwYXNzZXMuIFJldHVybnMgdHJ1ZSBpZiB0aGUgdGFnKHMpIHdlcmUgY3JlYXRlZC5cclxuICAgICAqL1xyXG4gICAgY29tbWl0KGlucHV0OiBzdHJpbmcpOiBib29sZWFuIHtcclxuICAgICAgICBpZiAoaW5wdXQgJiYgdGhpcy5mcmVlSW5wdXQpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFNwbGl0IHRoZSB0YWdzIGJ5IHRoZSB0YWdEZWxpbWl0ZXJzIGlmIGNvbmZpZ3VyZWRcclxuICAgICAgICAgICAgY29uc3QgbmV3VGFncyA9IHRoaXMuc3BsaXRUYWdJbnB1dChpbnB1dCk7XHJcblxyXG4gICAgICAgICAgICAvLyBDaGVjayB0YWcgdmFsaWRhdGlvbiBmb3IgYWxsIG9mIHRoZSBpbmRpdmlkdWFsIHZhbHVlc1xyXG4gICAgICAgICAgICBsZXQgYWxsVmFsaWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBuZXdUYWcgb2YgbmV3VGFncykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsaWQgPSB0aGlzLnZhbGlkYXRlVGFnKG5ld1RhZyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXZhbGlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWxsVmFsaWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gQWRkIHRoZSB0YWdzIGlmIGFsbCBhcmUgdmFsaWRcclxuICAgICAgICAgICAgaWYgKGFsbFZhbGlkKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBuZXdUYWcgb2YgbmV3VGFncykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkVGFnKHRoaXMuY3JlYXRlVGFnKG5ld1RhZykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJZiBubyB0YWcgaXMgc2VsZWN0ZWQsIHNlbGVjdCB0aGUgcmlnaHRtb3N0IHRhZy4gSWYgYSB0YWcgaXMgc2VsZWN0ZWQsIHJlbW92ZSBpdC5cclxuICAgICAqL1xyXG4gICAgYmFja3NwYWNlKCk6IHZvaWQge1xyXG5cclxuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZFRhZ0luZGV4KHRoaXMuc2VsZWN0ZWRJbmRleCkpIHtcclxuICAgICAgICAgICAgdGhpcy5zZWxlY3RUYWdBdCh0aGlzLnRhZ3MubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVUYWdBdCh0aGlzLnNlbGVjdGVkSW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE1vdmUgdGhlIGhpZ2hsaWdodGVkIG9wdGlvbiBmb3J3YXJkcyBvciBiYWNrd2FyZHMgaW4gdGhlIGxpc3QuIFdyYXBzIGF0IHRoZSBsaW1pdHMuXHJcbiAgICAgKiBAcGFyYW0gZGVsdGEgVmFsdWUgdG8gYmUgYWRkZWQgdG8gdGhlIHNlbGVjdGVkIGluZGV4LCBpLmUuIC0xIHRvIG1vdmUgYmFja3dhcmRzLCArMSB0byBtb3ZlIGZvcndhcmRzLlxyXG4gICAgICovXHJcbiAgICBtb3ZlU2VsZWN0aW9uKGRlbHRhOiBudW1iZXIpOiB2b2lkIHtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmlzVmFsaWRTZWxlY3RJbmRleCh0aGlzLnNlbGVjdGVkSW5kZXgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCArPSBkZWx0YTtcclxuXHJcbiAgICAgICAgICAgIC8vIERvIHdyYXBwaW5nIG9mIHNlbGVjdGlvbiB3aGVuIG91dCBvZiBib3VuZHNcclxuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRJbmRleCA8IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IHRoaXMudGFncy5sZW5ndGg7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5zZWxlY3RlZEluZGV4ID4gdGhpcy50YWdzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEluZGV4ID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSB2YWx1ZSB0byBkaXNwbGF5IGZvciB0aGUgZ2l2ZW4gdGFnLiBVc2VzIGRpc3BsYXkgZnVuY3Rpb24vcHJvcGVydHkgbmFtZSBpZiBzZXQsIG90aGVyd2lzZSBhc3N1bWVzIHRoYXQgdGhlIHRhZyBpcyBhIHNpbXBsZSBzdHJpbmcuXHJcbiAgICAgKi9cclxuICAgIGdldFRhZ0Rpc3BsYXkodGFnOiBhbnkpOiBzdHJpbmcge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5kaXNwbGF5ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRpc3BsYXkodGFnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmRpc3BsYXkgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0YWdbPHN0cmluZz50aGlzLmRpc3BsYXldO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGFnO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBpbmRleCBpcyBzZWxlY3RlZCAodGFnIGluZGV4IG9yIGlucHV0IGZpZWxkKS5cclxuICAgICAqL1xyXG4gICAgaXNTZWxlY3RlZChpbmRleDogbnVtYmVyKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIGluZGV4ID09PSB0aGlzLnNlbGVjdGVkSW5kZXg7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZWxlY3QgdGhlIHRhZyBhdCB0aGUgZ2l2ZW4gaW5kZXguIERvZXMgbm90aGluZyBpZiBkaXNhYmxlZCBpcyB0cnVlLlxyXG4gICAgICovXHJcbiAgICBzZWxlY3RUYWdBdCh0YWdJbmRleDogbnVtYmVyKTogdm9pZCB7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7IHJldHVybjsgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5pc1ZhbGlkVGFnSW5kZXgodGFnSW5kZXgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IHRhZ0luZGV4O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNlbGVjdCB0aGUgaW5wdXQgZmllbGQsIGdpdmluZyBpdCBmb2N1cy4gRG9lcyBub3RoaW5nIGlmIGRpc2FibGVkIGlzIHRydWUuXHJcbiAgICAgKi9cclxuICAgIHNlbGVjdElucHV0KCk6IHZvaWQge1xyXG5cclxuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLnNlbGVjdGVkSW5kZXggPSB0aGlzLnRhZ3MubGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlIHRoZSB0YWcgYXQgdGhlIGdpdmVuIGluZGV4LiBEb2VzIG5vdGhpbmcgaWYgZGlzYWJsZWQgaXMgdHJ1ZSBvciB0aGUgbWluVGFncyBwcm9wZXJ0eSBwcmV2ZW50cyByZW1vdmFsLlxyXG4gICAgICovXHJcbiAgICByZW1vdmVUYWdBdCh0YWdJbmRleDogbnVtYmVyKTogdm9pZCB7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkIHx8ICF0aGlzLmNhblJlbW92ZVRhZ0F0KHRhZ0luZGV4KSkgeyByZXR1cm47IH1cclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgdGhhdCB0aGUgdGFnSW5kZXggaXMgaW4gcmFuZ2VcclxuICAgICAgICBpZiAodGhpcy5pc1ZhbGlkVGFnSW5kZXgodGFnSW5kZXgpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhZyA9IHRoaXMudGFnc1t0YWdJbmRleF07XHJcbiAgICAgICAgICAgIGNvbnN0IHRhZ1JlbW92aW5nRXZlbnQgPSBuZXcgVGFnSW5wdXRFdmVudCh0YWcpO1xyXG4gICAgICAgICAgICB0aGlzLnRhZ1JlbW92aW5nLmVtaXQodGFnUmVtb3ZpbmdFdmVudCk7XHJcbiAgICAgICAgICAgIGlmICghdGFnUmVtb3ZpbmdFdmVudC5kZWZhdWx0UHJldmVudGVkKCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIFNlbGVjdCBpbnB1dCBmaXJzdCB0byBhdm9pZCBpc3N1ZXMgd2l0aCBkcm9wcGluZyBmb2N1c1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RJbnB1dCgpO1xyXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSB0YWdcclxuICAgICAgICAgICAgICAgIHRoaXMudGFncy5zcGxpY2UodGFnSW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgLy8gU2V0IGZvY3VzIGFnYWluIHNpbmNlIGluZGljZXMgaGF2ZSBjaGFuZ2VkXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdElucHV0KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRhZ1JlbW92ZWQuZW1pdChuZXcgVGFnSW5wdXRFdmVudCh0YWcpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudmFsaWRhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdGFnIGF0IHRoZSBnaXZlbiBpbmRleCBjYW4gYmUgcmVtb3ZlZC5cclxuICAgICAqL1xyXG4gICAgY2FuUmVtb3ZlVGFnQXQodGFnSW5kZXg6IG51bWJlcik6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRhZ3MubGVuZ3RoID4gdGhpcy5taW5UYWdzIHx8ICF0aGlzLmVuZm9yY2VUYWdMaW1pdHM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGlucHV0IGZpZWxkIHNob3VsZCBiZSBhdmFpbGFibGUuXHJcbiAgICAgKi9cclxuICAgIGlzSW5wdXRWaXNpYmxlKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRhZ3MubGVuZ3RoIDwgdGhpcy5tYXhUYWdzIHx8ICF0aGlzLmVuZm9yY2VUYWdMaW1pdHM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgYW55IHBhcnQgb2YgdGhlIGNvbnRyb2wgaGFzIGZvY3VzLlxyXG4gICAgICovXHJcbiAgICBoYXNGb2N1cygpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkU2VsZWN0SW5kZXgodGhpcy5zZWxlY3RlZEluZGV4KTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIGNvbm5lY3RUeXBlYWhlYWQodHlwZWFoZWFkOiBUeXBlYWhlYWRDb21wb25lbnQpOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5fc3Vic2NyaXB0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24gPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy50eXBlYWhlYWQgPSB0eXBlYWhlYWQ7XHJcbiAgICAgICAgaWYgKHRoaXMudHlwZWFoZWFkKSB7XHJcbiAgICAgICAgICAgIC8vIFNldCB1cCBldmVudCBoYW5kbGVyIGZvciBzZWxlY3RlZCBvcHRpb25zXHJcbiAgICAgICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IHRoaXMudHlwZWFoZWFkLm9wdGlvblNlbGVjdGVkLnN1YnNjcmliZSh0aGlzLnR5cGVhaGVhZE9wdGlvblNlbGVjdGVkSGFuZGxlci5iaW5kKHRoaXMpKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNldCB1cCBldmVudCBoYW5kbGVyIGZvciB0aGUgaGlnaGxpZ2h0ZWQgZWxlbWVudFxyXG4gICAgICAgICAgICAvLyBBZGRlZCBhIGRlbGF5IHRvIG1vdmUgaXQgb3V0IG9mIHRoZSBjdXJyZW50IGNoYW5nZSBkZXRlY3Rpb24gY3ljbGVcclxuICAgICAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLmFkZChcclxuICAgICAgICAgICAgICAgIHRoaXMudHlwZWFoZWFkLmhpZ2hsaWdodGVkRWxlbWVudENoYW5nZS5waXBlKHRpY2soKSlcclxuICAgICAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKChlbGVtZW50OiBIVE1MRWxlbWVudCkgPT4gdGhpcy5oaWdobGlnaHRlZEVsZW1lbnQgPSBlbGVtZW50KVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFZhbGlkYXRlIHRoZSBnaXZlbiB0YWdWYWx1ZSB3aXRoIHRoZSB0YWdQYXR0ZXJuLCBpZiBzZXQuIFVwZGF0ZSB2YWxpZGF0aW9uRXJyb3JzIG9uIHZhbGlkYXRpb24gZmFpbHVyZS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSB2YWxpZGF0ZVRhZyh0YWdWYWx1ZTogc3RyaW5nKTogYm9vbGVhbiB7XHJcbiAgICAgICAgbGV0IGlucHV0UGF0dGVybiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5pbnB1dFZhbGlkID0gdHJ1ZTtcclxuICAgICAgICBpZiAodGhpcy50YWdQYXR0ZXJuICYmICF0aGlzLnRhZ1BhdHRlcm4udGVzdCh0YWdWYWx1ZSkpIHtcclxuICAgICAgICAgICAgaW5wdXRQYXR0ZXJuID0ge1xyXG4gICAgICAgICAgICAgICAgZ2l2ZW46IHRhZ1ZhbHVlLFxyXG4gICAgICAgICAgICAgICAgcGF0dGVybjogdGhpcy50YWdQYXR0ZXJuXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMuaW5wdXRWYWxpZCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnZhbGlkYXRpb25FcnJvcnNbJ2lucHV0UGF0dGVybiddID0gaW5wdXRQYXR0ZXJuO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmlucHV0VmFsaWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSB0YWcgb2JqZWN0IGZvciB0aGUgZ2l2ZW4gdGFnVmFsdWUuIElmIGNyZWF0ZVRhZ0hhbmRsZXIgaXMgc3BlY2lmaWVkLCB1c2UgaXQ7IG90aGVyd2lzZSBpZiBkaXNwbGF5UHJvcGVydHkgaXMgc3BlY2lmaWVkLCBjcmVhdGUgYW4gb2JqZWN0IHdpdGggdGhlIHRhZ1ZhbHVlIGFzIHRoZSBzaW5nbGUgbmFtZWQgcHJvcGVydHk7IG90aGVyd2lzZSByZXR1cm4gdGhlIHRhZ1ZhbHVlIGl0c2VsZi5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBjcmVhdGVUYWcodGFnVmFsdWU6IHN0cmluZyk6IGFueSB7XHJcbiAgICAgICAgbGV0IHRhZyA9IG51bGw7XHJcbiAgICAgICAgaWYgKHRoaXMuY3JlYXRlVGFnSGFuZGxlciAmJiB0eXBlb2YgdGhpcy5jcmVhdGVUYWdIYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHRhZyA9IHRoaXMuY3JlYXRlVGFnSGFuZGxlcih0YWdWYWx1ZSk7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5kaXNwbGF5ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB0YWcgPSB7fTtcclxuICAgICAgICAgICAgdGFnWzxzdHJpbmc+dGhpcy5kaXNwbGF5XSA9IHRhZ1ZhbHVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRhZyA9IHRhZ1ZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGFnO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgdGFnIG9iamVjdCwgY2FsbGluZyB0aGUgdGFnQWRkaW5nIGFuZCB0YWdBZGRlZCBldmVudHMuIFJldHVybnMgdHJ1ZSBpZiB0aGUgdGFnIHdhcyBhZGRlZCB0byB0aGUgdGFncyBhcnJheS5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBhZGRUYWcodGFnOiBhbnkpOiBib29sZWFuIHtcclxuICAgICAgICBpZiAodGFnKSB7XHJcbiAgICAgICAgICAgIC8vIFZlcmlmeSB0aGF0IHRoZSBuZXcgdGFnIGNhbiBiZSBkaXNwbGF5ZWRcclxuICAgICAgICAgICAgY29uc3QgZGlzcGxheVZhbHVlID0gdGhpcy5nZXRUYWdEaXNwbGF5KHRhZyk7XHJcbiAgICAgICAgICAgIGlmIChkaXNwbGF5VmFsdWUgJiYgdHlwZW9mIGRpc3BsYXlWYWx1ZSA9PT0gJ3N0cmluZycgJiYgZGlzcGxheVZhbHVlLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRhZ0FkZGluZ0V2ZW50ID0gbmV3IFRhZ0lucHV0RXZlbnQodGFnKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudGFnQWRkaW5nLmVtaXQodGFnQWRkaW5nRXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0YWdBZGRpbmdFdmVudC5kZWZhdWx0UHJldmVudGVkKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRhZ3MgPSB0aGlzLnRhZ3MgfHwgW107XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YWdzLnB1c2godGFnKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRhZ0FkZGVkLmVtaXQobmV3IFRhZ0lucHV0RXZlbnQodGFnKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWxpZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHRhZ0luZGV4IGlzIGEgdmFsaWQgdGFnIGluZGV4LlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGlzVmFsaWRUYWdJbmRleCh0YWdJbmRleDogbnVtYmVyKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRhZ0luZGV4ID49IDAgJiYgdGFnSW5kZXggPCB0aGlzLnRhZ3MubGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBpbmRleCBpcyBhIHZhbGlkIHNlbGVjdGlvbiBpbmRleCAodGFncyBvciBpbnB1dCBmaWVsZCkuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgaXNWYWxpZFNlbGVjdEluZGV4KGluZGV4OiBudW1iZXIpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gaW5kZXggPj0gMCAmJiBpbmRleCA8PSB0aGlzLnRhZ3MubGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY2hhcmFjdGVyIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGtleSBldmVudCwgbWFpbmx5IGZvciBJRSBjb21wYXRpYmlsaXR5LlxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGdldEtleUNoYXIoZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiBzdHJpbmcge1xyXG4gICAgICAgIHN3aXRjaCAoZXZlbnQud2hpY2gpIHtcclxuICAgICAgICAgICAgY2FzZSBTUEFDRTpcclxuICAgICAgICAgICAgICAgIHJldHVybiAnICc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBldmVudC5rZXk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHN0cmluZ3MgY29ycmVzcG9uZGluZyB0byB0aGUgaW5wdXQgc3RyaW5nIHNwbGl0IGJ5IHRoZSB0YWdEZWxpbWl0ZXJzIGNoYXJhY3RlcnMuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgc3BsaXRUYWdJbnB1dChpbnB1dDogc3RyaW5nKTogc3RyaW5nW10ge1xyXG4gICAgICAgIGxldCB0YWdWYWx1ZXMgPSBbaW5wdXRdO1xyXG4gICAgICAgIGlmICh0aGlzLnRhZ0RlbGltaXRlcnMgJiYgdHlwZW9mIHRoaXMudGFnRGVsaW1pdGVycyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgY29uc3QgZXNjYXBlZERlbGltaXRlcnMgPSB0aGlzLnRhZ0RlbGltaXRlcnMucmVwbGFjZSgvWy1cXC9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGRlbGltaXRlclJlZ2V4ID0gbmV3IFJlZ0V4cChgWyR7ZXNjYXBlZERlbGltaXRlcnN9XWAsICdnJyk7XHJcbiAgICAgICAgICAgIHRhZ1ZhbHVlcyA9IGlucHV0LnNwbGl0KGRlbGltaXRlclJlZ2V4KS5maWx0ZXIoKHMpID0+IHMubGVuZ3RoID4gMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0YWdWYWx1ZXM7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUaGUgQVBJIGF2YWlsYWJsZSB0byB0YWcgdGVtcGxhdGVzLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBUYWdBcGkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBkaXNwbGF5IHZhbHVlIG9mIHRoZSBnaXZlbiB0YWcsIGFjY29yZGluZyB0byB0aGUgZGlzcGxheVByb3BlcnR5IHByb3BlcnR5LlxyXG4gICAgICovXHJcbiAgICBnZXRUYWdEaXNwbGF5OiAodGFnOiBhbnkpID0+IHN0cmluZztcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgdGhlIHRhZyBhdCB0aGUgZ2l2ZW4gaW5kZXgsIGlmIHBvc3NpYmxlLlxyXG4gICAgICovXHJcbiAgICByZW1vdmVUYWdBdDogKGluZGV4OiBudW1iZXIpID0+IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBcdFJldHVybnMgdHJ1ZSBpZiB0aGUgdGFnIGF0IHRoZSBnaXZlbiBpbmRleCBjYW4gYmUgcmVtb3ZlZC5cclxuICAgICAqL1xyXG4gICAgY2FuUmVtb3ZlVGFnQXQ6IChpbmRleDogbnVtYmVyKSA9PiBib29sZWFuO1xyXG59XHJcblxyXG4vKipcclxuICogVGhlIGZ1bmN0aW9uIHVzZWQgdG8gcmV0dXJuIGN1c3RvbSBjbGFzcyBpbmZvcm1hdGlvbiwgZm9yIHVzZSBpbiBgbmdDbGFzc2AuXHJcbiAqL1xyXG5leHBvcnQgdHlwZSBUYWdDbGFzc0Z1bmN0aW9uID0gKHRhZzogYW55LCBpbmRleDogbnVtYmVyLCBzZWxlY3RlZDogYm9vbGVhbikgPT4gKHN0cmluZyB8IHN0cmluZ1tdIHwgU2V0PHN0cmluZz4pOyIsImltcG9ydCB7IEZvY3VzSWZNb2R1bGUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL2ZvY3VzLWlmL2luZGV4JztcbmltcG9ydCB7IFR5cGVhaGVhZE1vZHVsZSB9IGZyb20gJy4uL3R5cGVhaGVhZC9pbmRleCc7XG5pbXBvcnQgeyBUYWdJbnB1dENvbXBvbmVudCB9IGZyb20gJy4vdGFnLWlucHV0LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZvcm1zTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgRm9jdXNJZk1vZHVsZSxcbiAgICAgICAgVHlwZWFoZWFkTW9kdWxlXG4gICAgXSxcbiAgICBleHBvcnRzOiBbVGFnSW5wdXRDb21wb25lbnRdLFxuICAgIGRlY2xhcmF0aW9uczogW1RhZ0lucHV0Q29tcG9uZW50XSxcbiAgICBwcm92aWRlcnM6IFtdLFxufSlcbmV4cG9ydCBjbGFzcyBUYWdJbnB1dE1vZHVsZSB7IH1cbiIsImltcG9ydCB7IEluZmluaXRlU2Nyb2xsTW9kdWxlIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9pbmZpbml0ZS1zY3JvbGwvaW5kZXgnO1xuaW1wb3J0IHsgVGFnSW5wdXRNb2R1bGUgfSBmcm9tICcuLi90YWctaW5wdXQvaW5kZXgnO1xuaW1wb3J0IHsgVHlwZWFoZWFkTW9kdWxlIH0gZnJvbSAnLi4vdHlwZWFoZWFkL2luZGV4JztcbmltcG9ydCB7IFNlbGVjdENvbXBvbmVudCB9IGZyb20gJy4vc2VsZWN0LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZvcm1zTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBGb3Jtc01vZHVsZSxcbiAgICAgICAgSW5maW5pdGVTY3JvbGxNb2R1bGUsXG4gICAgICAgIFRhZ0lucHV0TW9kdWxlLFxuICAgICAgICBUeXBlYWhlYWRNb2R1bGVcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtTZWxlY3RDb21wb25lbnRdLFxuICAgIGRlY2xhcmF0aW9uczogW1NlbGVjdENvbXBvbmVudF1cbn0pXG5leHBvcnQgY2xhc3MgU2VsZWN0TW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFNlYXJjaEJ1aWxkZXJDb21wb25lbnRDb250ZXh0IH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9jb21wb25lbnQtY29udGV4dC5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgU2VhcmNoQnVpbGRlclNlcnZpY2UgfSBmcm9tICcuLi9zZWFyY2gtYnVpbGRlci5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1iYXNlLXNlYXJjaCcsXG4gICAgdGVtcGxhdGU6ICcnXG59KVxuZXhwb3J0IGNsYXNzIEJhc2VTZWFyY2hDb21wb25lbnQgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuXG4gICAgZ2V0IGlkKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBgdXgtc2VhcmNoLWJ1aWxkZXItc2VhcmNoLWNvbXBvbmVudC0ke3RoaXMuX2lkfWA7XG4gICAgfVxuXG4gICAgdHlwZTogc3RyaW5nO1xuICAgIGNvbmZpZzogYW55O1xuICAgIGNvbnRleHQ6IFNlYXJjaEJ1aWxkZXJDb21wb25lbnRDb250ZXh0O1xuICAgIGZvY3VzOiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBjb21wb25lbnRcbiAgICAgKi9cbiAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQudmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBjb21wb25lbnRcbiAgICAgKi9cbiAgICBzZXQgdmFsdWUodmFsdWU6IGFueSkge1xuICAgICAgICB0aGlzLmNvbnRleHQudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5fc2VhcmNoQnVpbGRlclNlcnZpY2UucXVlcnlIYXNDaGFuZ2VkKCk7XG5cbiAgICAgICAgLy8gaWYgdmFsdWUgaGFzIGJlZW4gc2V0IHBlcmZvcm0gdmFsaWRhdGlvblxuICAgICAgICB0aGlzLnZhbGlkYXRlKCk7XG4gICAgfVxuXG4gICAgZ2V0IHZhbGlkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsaWQ7XG4gICAgfVxuXG4gICAgc2V0IHZhbGlkKHZhbGlkOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuX3ZhbGlkID0gdmFsaWQ7XG4gICAgICAgIHRoaXMuX3NlYXJjaEJ1aWxkZXJTZXJ2aWNlLnNldFZhbGlkKHRoaXMuX2lkLCB2YWxpZCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfaWQ6IG51bWJlciA9IHRoaXMuX3NlYXJjaEJ1aWxkZXJTZXJ2aWNlLmdlbmVyYXRlQ29tcG9uZW50SWQoKTtcbiAgICBwcml2YXRlIF92YWxpZDogYm9vbGVhbiA9IHRydWU7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9zZWFyY2hCdWlsZGVyU2VydmljZTogU2VhcmNoQnVpbGRlclNlcnZpY2UpIHsgfVxuXG4gICAgLyoqXG4gICAgICogTWFrZSBzdXJlIHdlIGNsZWFuIHVwIGFmdGVyIG91cnNlbHZlc1xuICAgICAqL1xuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLnZhbGlkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGFueSByZXF1aXJlZCB2YWxpZGF0aW9uIG9uIHRoZSB2YWx1ZVxuICAgICAqL1xuICAgIHZhbGlkYXRlKCk6IHZvaWQge1xuICAgICAgICAvLyBpZiBhIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9uIGhhcyBiZWVuIHByb3ZpZGVkIHRoZW4gdXNlIGl0XG4gICAgICAgIHRoaXMudmFsaWQgPSB0aGlzLmNvbmZpZy52YWxpZGF0aW9uID8gdGhpcy5jb25maWcudmFsaWRhdGlvbih0aGlzLCB0aGlzLnZhbHVlKSA6IHRydWU7XG4gICAgfVxuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQmFzZVNlYXJjaENvbXBvbmVudENvbmZpZyB7XG4gICAgbGFiZWw/OiBzdHJpbmc7XG4gICAgcGxhY2Vob2xkZXI/OiBzdHJpbmc7XG4gICAgdmFsaWRhdGlvbj86ICh2YWx1ZTogYW55KSA9PiBib29sZWFuO1xufSIsImltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmFzZVNlYXJjaENvbXBvbmVudCB9IGZyb20gJy4uL2Jhc2Utc2VhcmNoLmNvbXBvbmVudCc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtc2VhcmNoLWRhdGUtcmFuZ2UnLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9kYXRlLXJhbmdlLmNvbXBvbmVudC5odG1sJ1xufSlcbmV4cG9ydCBjbGFzcyBTZWFyY2hEYXRlUmFuZ2VDb21wb25lbnQgZXh0ZW5kcyBCYXNlU2VhcmNoQ29tcG9uZW50IHtcblxuICAgIHR5cGU6IHN0cmluZyA9ICdkYXRlLXJhbmdlJztcblxuICAgIGdldCBsYWJlbCgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWcubGFiZWw7XG4gICAgfVxuXG4gICAgZ2V0IGZyb20oKSB7XG5cbiAgICAgICAgLy8gaWYgdmFsdWUgZG9lcyBub3QgZXhpc3QgdGhlIHNldCBpdFxuICAgICAgICBpZiAoIXRoaXMudmFsdWUgfHwgIXRoaXMudmFsdWUuZnJvbSkge1xuICAgICAgICAgICAgdGhpcy5mcm9tID0gbmV3IERhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVuc3VyZSB0aGF0IHRoZSBmcm9tIHZhbHVlIGlzIGEgZGF0ZSBvYmplY3RcbiAgICAgICAgaWYgKHRoaXMudmFsdWUuZnJvbSBpbnN0YW5jZW9mIERhdGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlLmZyb20gPSBuZXcgRGF0ZSh0aGlzLnZhbHVlLmZyb20pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUuZnJvbTtcbiAgICB9XG5cbiAgICBzZXQgZnJvbShmcm9tVmFsdWU6IGFueSkge1xuXG4gICAgICAgIC8vIGNyZWF0ZSBuZXcgb2JqZWN0IGJhc2VkIG9uIHRoZSBjdXJyZW50IHZhbHVlXG4gICAgICAgIGNvbnN0IHZhbHVlID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy52YWx1ZSk7XG5cbiAgICAgICAgLy8gZW5zdXJlIHRoYXQgdGhlIGZyb20gdmFsdWUgaXMgYSBkYXRlXG4gICAgICAgIGlmIChmcm9tVmFsdWUgaW5zdGFuY2VvZiBEYXRlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgZnJvbVZhbHVlID0gbmV3IERhdGUoZnJvbVZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldCB0aGUgbGF0ZXN0IHZhbHVlXG4gICAgICAgIHZhbHVlLmZyb20gPSBmcm9tVmFsdWU7XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSB2YWx1ZSBvYmplY3Qgd2hpbGUgZW5zdXJpbmcgaW1tdXRhYmlsaXR5XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBnZXQgdG8oKSB7XG5cbiAgICAgICAgLy8gaWYgdmFsdWUgZG9lcyBub3QgZXhpc3QgdGhlIHNldCBpdFxuICAgICAgICBpZiAoIXRoaXMudmFsdWUgfHwgIXRoaXMudmFsdWUudG8pIHtcbiAgICAgICAgICAgIHRoaXMudG8gPSBuZXcgRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZW5zdXJlIHRoYXQgdGhlIHRvIHZhbHVlIGlzIGEgZGF0ZSBvYmplY3RcbiAgICAgICAgaWYgKHRoaXMudmFsdWUudG8gaW5zdGFuY2VvZiBEYXRlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZS50byA9IG5ldyBEYXRlKHRoaXMudmFsdWUudG8pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUudG87XG4gICAgfVxuXG4gICAgc2V0IHRvKHRvVmFsdWU6IGFueSkge1xuXG4gICAgICAgIC8vIGNyZWF0ZSBuZXcgb2JqZWN0IGJhc2VkIG9uIHRoZSBjdXJyZW50IHZhbHVlXG4gICAgICAgIGNvbnN0IHZhbHVlID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy52YWx1ZSk7XG5cbiAgICAgICAgLy8gZW5zdXJlIHRoYXQgdGhlIHRvIHZhbHVlIGlzIGEgZGF0ZVxuICAgICAgICBpZiAodG9WYWx1ZSBpbnN0YW5jZW9mIERhdGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0b1ZhbHVlID0gbmV3IERhdGUodG9WYWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzZXQgdGhlIGxhdGVzdCB2YWx1ZVxuICAgICAgICB2YWx1ZS50byA9IHRvVmFsdWU7XG5cbiAgICAgICAgLy8gdXBkYXRlIHRoZSB2YWx1ZSBvYmplY3Qgd2hpbGUgZW5zdXJpbmcgaW1tdXRhYmlsaXR5XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBnZXQgZnJvbUxhYmVsKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5mcm9tTGFiZWwgfHwgJ0Zyb20nO1xuICAgIH1cblxuICAgIGdldCB0b0xhYmVsKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy50b0xhYmVsIHx8ICdUbyc7XG4gICAgfVxuXG4gICAgZ2V0IGZyb21QbGFjZWhvbGRlcigpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWcuZnJvbVBsYWNlaG9sZGVyO1xuICAgIH1cblxuICAgIGdldCB0b1BsYWNlaG9sZGVyKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy50b1BsYWNlaG9sZGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoZSBkZWZhdWx0IHZhbGlkYXRpb25cbiAgICAgKi9cbiAgICB2YWxpZGF0ZSgpOiB2b2lkIHtcblxuICAgICAgICAvLyBjaGVjayBpZiB0aGVyZSBpcyBhIGNvbmZpZyB2YWxpZGF0aW9uIGZ1bmN0aW9uXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy52YWxpZGF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gc3VwZXIudmFsaWRhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNyZWF0ZSBjb3BpZXMgb2YgdGhlIGRhdGVzIHNvIHdlIGNhbiBtb2RpZnkgdGltZSB2YWx1ZSAodG8gaWdub3JlIGl0KVxuICAgICAgICBjb25zdCBmcm9tID0gbmV3IERhdGUodGhpcy52YWx1ZS5mcm9tKTtcbiAgICAgICAgY29uc3QgdG8gPSBuZXcgRGF0ZSh0aGlzLnZhbHVlLnRvKTtcblxuICAgICAgICAvLyBzZXQgdGhlIHRpbWUgdG8gdGhlIHNhbWUgc28gd2UgZG9udCBjb21wYXJlIGl0XG4gICAgICAgIGZyb20uc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gICAgICAgIHRvLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuXG4gICAgICAgIC8vIHZhbGlkIGlmIHRoZSBmcm9tIGRhdGUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSB0byBkYXRlXG4gICAgICAgIHRoaXMudmFsaWQgPSBmcm9tIDw9IHRvO1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBTZWFyY2hEYXRlUmFuZ2VDb25maWcge1xuICAgIGxhYmVsPzogc3RyaW5nO1xuICAgIGZyb21MYWJlbD86IHN0cmluZztcbiAgICB0b0xhYmVsPzogc3RyaW5nO1xuICAgIGZyb21QbGFjZWhvbGRlcj86IHN0cmluZztcbiAgICB0b1BsYWNlaG9sZGVyPzogc3RyaW5nO1xuICAgIHZhbGlkYXRpb246ICh2YWx1ZTogYW55KSA9PiBib29sZWFuO1xufSIsImltcG9ydCB7IENvbXBvbmVudCwgT25Jbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBCYXNlU2VhcmNoQ29tcG9uZW50LCBCYXNlU2VhcmNoQ29tcG9uZW50Q29uZmlnIH0gZnJvbSAnLi4vYmFzZS1zZWFyY2guY29tcG9uZW50JztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAndXgtc2VhcmNoLWRhdGUnLFxuICB0ZW1wbGF0ZVVybDogJy4vZGF0ZS5jb21wb25lbnQuaHRtbCdcbn0pXG5leHBvcnQgY2xhc3MgU2VhcmNoRGF0ZUNvbXBvbmVudCBleHRlbmRzIEJhc2VTZWFyY2hDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xuXG4gIHR5cGU6IHN0cmluZyA9ICdkYXRlJztcblxuICBnZXQgbGFiZWwoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcubGFiZWw7XG4gIH1cblxuICBnZXQgcGxhY2Vob2xkZXIoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcucGxhY2Vob2xkZXIgfHwgJ0VudGVyIGRhdGUnO1xuICB9XG5cbiAgbmdPbkluaXQoKTogdm9pZCB7XG5cbiAgICAvLyBieSBkZWZhdWx0IHNldCB0byB0aGUgY3VycmVudCBkYXRlIGlmIG5vdCBzcGVjaWZpZWRcbiAgICBpZiAoIXRoaXMudmFsdWUpIHtcbiAgICAgIHRoaXMudmFsdWUgPSBuZXcgRGF0ZSgpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNlYXJjaERhdGVDb25maWcgZXh0ZW5kcyBCYXNlU2VhcmNoQ29tcG9uZW50Q29uZmlnIHsgfSIsImltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmFzZVNlYXJjaENvbXBvbmVudCwgQmFzZVNlYXJjaENvbXBvbmVudENvbmZpZyB9IGZyb20gJy4uL2Jhc2Utc2VhcmNoLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBJbmZpbml0ZVNjcm9sbExvYWRGdW5jdGlvbiB9IGZyb20gJy4uLy4uLy4uLy4uL2luZGV4JztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAndXgtc2VhcmNoLXNlbGVjdCcsXG4gIHRlbXBsYXRlVXJsOiAnLi9zZWxlY3QuY29tcG9uZW50Lmh0bWwnXG59KVxuZXhwb3J0IGNsYXNzIFNlYXJjaFNlbGVjdENvbXBvbmVudCBleHRlbmRzIEJhc2VTZWFyY2hDb21wb25lbnQge1xuXG4gIHR5cGU6IHN0cmluZyA9ICdzZWxlY3QnO1xuXG4gIC8qKlxuICAgKiBQcm92aWRlIGRlZmF1bHRzIGZvciB1bmRlZmluZWQgcHJvcGVydGllc1xuICAgKi9cbiAgZ2V0IGxhYmVsKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLmxhYmVsO1xuICB9XG5cbiAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLm9wdGlvbnMgfHwgW107XG4gIH1cblxuICBnZXQgbXVsdGlwbGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLm11bHRpcGxlIHx8IGZhbHNlO1xuICB9XG5cbiAgZ2V0IHBsYWNlaG9sZGVyKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLnBsYWNlaG9sZGVyIHx8ICdTZWxlY3QgaXRlbSc7XG4gIH1cblxuICBnZXQgZHJvcERpcmVjdGlvbigpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmNvbmZpZy5kcm9wRGlyZWN0aW9uIHx8ICdkb3duJztcbiAgfVxuXG4gIGdldCBhbGxvd051bGwoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLmFsbG93TnVsbCB8fCBmYWxzZTtcbiAgfVxuXG4gIGdldCBkaXNhYmxlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcuZGlzYWJsZWQgfHwgZmFsc2U7XG4gIH1cblxuICBnZXQgbWF4SGVpZ2h0KCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLm1heEhlaWdodCB8fCAnMjUwcHgnO1xuICB9XG5cbiAgZ2V0IHBhZ2VTaXplKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLnBhZ2VTaXplIHx8IDIwO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VhcmNoU2VsZWN0Q29uZmlnIGV4dGVuZHMgQmFzZVNlYXJjaENvbXBvbmVudENvbmZpZyB7XG4gIG9wdGlvbnM/OiBhbnlbXSB8IEluZmluaXRlU2Nyb2xsTG9hZEZ1bmN0aW9uO1xuICBtdWx0aXBsZT86IGJvb2xlYW47XG4gIGRyb3BEaXJlY3Rpb24/OiAndXAnIHwgJ2Rvd24nO1xuICBhbGxvd051bGw/OiBib29sZWFuO1xuICBkaXNhYmxlZD86IGJvb2xlYW47XG4gIG1heEhlaWdodD86IHN0cmluZztcbiAgcGFnZVNpemU/OiBudW1iZXI7XG59IiwiaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBCYXNlU2VhcmNoQ29tcG9uZW50LCBCYXNlU2VhcmNoQ29tcG9uZW50Q29uZmlnIH0gZnJvbSAnLi4vYmFzZS1zZWFyY2guY29tcG9uZW50JztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAndXgtc2VhcmNoLXRleHQnLFxuICB0ZW1wbGF0ZVVybDogJy4vdGV4dC5jb21wb25lbnQuaHRtbCdcbn0pXG5leHBvcnQgY2xhc3MgU2VhcmNoVGV4dENvbXBvbmVudCBleHRlbmRzIEJhc2VTZWFyY2hDb21wb25lbnQge1xuXG4gIHR5cGU6IHN0cmluZyA9ICd0ZXh0JztcblxuICBnZXQgbGFiZWwoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcubGFiZWw7XG4gIH1cblxuICBnZXQgcGxhY2Vob2xkZXIoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcucGxhY2Vob2xkZXIgfHwgJ0VudGVyIHRleHQnO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VhcmNoVGV4dENvbmZpZyBleHRlbmRzIEJhc2VTZWFyY2hDb21wb25lbnRDb25maWcgeyB9IiwiaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGb3Jtc01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IEFjY2Vzc2liaWxpdHlNb2R1bGUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL2FjY2Vzc2liaWxpdHkvaW5kZXgnO1xuaW1wb3J0IHsgRm9jdXNJZk1vZHVsZSB9IGZyb20gJy4uLy4uL2RpcmVjdGl2ZXMvZm9jdXMtaWYvaW5kZXgnO1xuaW1wb3J0IHsgRGF0ZVRpbWVQaWNrZXJNb2R1bGUgfSBmcm9tICcuLi9kYXRlLXRpbWUtcGlja2VyL2RhdGUtdGltZS1waWNrZXIubW9kdWxlJztcbmltcG9ydCB7IFBvcG92ZXJNb2R1bGUgfSBmcm9tICcuLi9wb3BvdmVyL2luZGV4JztcbmltcG9ydCB7IFNlbGVjdE1vZHVsZSB9IGZyb20gJy4uL3NlbGVjdC9pbmRleCc7XG5pbXBvcnQgeyBTZWFyY2hCdWlsZGVyRm9jdXNTZXJ2aWNlIH0gZnJvbSAnLi9zZWFyY2gtYnVpbGRlci1mb2N1cy5zZXJ2aWNlJztcbmltcG9ydCB7IFNlYXJjaEJ1aWxkZXJHcm91cENvbXBvbmVudCB9IGZyb20gJy4vc2VhcmNoLWJ1aWxkZXItZ3JvdXAvc2VhcmNoLWJ1aWxkZXItZ3JvdXAuY29tcG9uZW50JztcbmltcG9ydCB7IFNlYXJjaEJ1aWxkZXJPdXRsZXREaXJlY3RpdmUgfSBmcm9tICcuL3NlYXJjaC1idWlsZGVyLW91dGxldC9zZWFyY2gtYnVpbGRlci1vdXRsZXQuZGlyZWN0aXZlJztcbmltcG9ydCB7IFNlYXJjaEJ1aWxkZXJDb21wb25lbnQgfSBmcm9tICcuL3NlYXJjaC1idWlsZGVyLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBCYXNlU2VhcmNoQ29tcG9uZW50IH0gZnJvbSAnLi9zZWFyY2gtY29tcG9uZW50cy9iYXNlLXNlYXJjaC5jb21wb25lbnQnO1xuaW1wb3J0IHsgU2VhcmNoRGF0ZVJhbmdlQ29tcG9uZW50IH0gZnJvbSAnLi9zZWFyY2gtY29tcG9uZW50cy9kYXRlLXJhbmdlL2RhdGUtcmFuZ2UuY29tcG9uZW50JztcbmltcG9ydCB7IFNlYXJjaERhdGVDb21wb25lbnQgfSBmcm9tICcuL3NlYXJjaC1jb21wb25lbnRzL2RhdGUvZGF0ZS5jb21wb25lbnQnO1xuaW1wb3J0IHsgU2VhcmNoU2VsZWN0Q29tcG9uZW50IH0gZnJvbSAnLi9zZWFyY2gtY29tcG9uZW50cy9zZWxlY3Qvc2VsZWN0LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBTZWFyY2hUZXh0Q29tcG9uZW50IH0gZnJvbSAnLi9zZWFyY2gtY29tcG9uZW50cy90ZXh0L3RleHQuY29tcG9uZW50JztcblxuQE5nTW9kdWxlKHtcbiAgaW1wb3J0czogW1xuICAgIEFjY2Vzc2liaWxpdHlNb2R1bGUsXG4gICAgQ29tbW9uTW9kdWxlLFxuICAgIERhdGVUaW1lUGlja2VyTW9kdWxlLFxuICAgIEZvY3VzSWZNb2R1bGUsXG4gICAgRm9ybXNNb2R1bGUsXG4gICAgUG9wb3Zlck1vZHVsZSxcbiAgICBTZWxlY3RNb2R1bGUsXG4gIF0sXG4gIGV4cG9ydHM6IFtcbiAgICBTZWFyY2hCdWlsZGVyQ29tcG9uZW50LFxuICAgIFNlYXJjaEJ1aWxkZXJHcm91cENvbXBvbmVudCxcbiAgICBCYXNlU2VhcmNoQ29tcG9uZW50XG4gIF0sXG4gIGRlY2xhcmF0aW9uczogW1xuICAgIFNlYXJjaEJ1aWxkZXJDb21wb25lbnQsXG4gICAgU2VhcmNoQnVpbGRlckdyb3VwQ29tcG9uZW50LFxuICAgIFNlYXJjaFRleHRDb21wb25lbnQsXG4gICAgU2VhcmNoRGF0ZUNvbXBvbmVudCxcbiAgICBTZWFyY2hEYXRlUmFuZ2VDb21wb25lbnQsXG4gICAgU2VhcmNoQnVpbGRlck91dGxldERpcmVjdGl2ZSxcbiAgICBTZWFyY2hTZWxlY3RDb21wb25lbnQsXG4gICAgQmFzZVNlYXJjaENvbXBvbmVudFxuICBdLFxuICBlbnRyeUNvbXBvbmVudHM6IFtcbiAgICBTZWFyY2hUZXh0Q29tcG9uZW50LFxuICAgIFNlYXJjaERhdGVDb21wb25lbnQsXG4gICAgU2VhcmNoRGF0ZVJhbmdlQ29tcG9uZW50LFxuICAgIFNlYXJjaFNlbGVjdENvbXBvbmVudFxuICBdLFxuICBwcm92aWRlcnM6IFtcbiAgICBTZWFyY2hCdWlsZGVyRm9jdXNTZXJ2aWNlXG4gIF1cbn0pXG5leHBvcnQgY2xhc3MgU2VhcmNoQnVpbGRlck1vZHVsZSB7IH1cbiIsImltcG9ydCB7IFNlbGVjdGlvblNlcnZpY2UgfSBmcm9tICcuLi9zZWxlY3Rpb24uc2VydmljZSc7XG5cbmV4cG9ydCBjbGFzcyBTZWxlY3Rpb25TdHJhdGVneSB7XG5cbiAgY29uc3RydWN0b3IocHJvdGVjdGVkIHNlbGVjdGlvblNlcnZpY2U/OiBTZWxlY3Rpb25TZXJ2aWNlKSB7IH1cblxuICBzZXRTZWxlY3Rpb25TZXJ2aWNlKHNlbGVjdGlvblNlcnZpY2U6IFNlbGVjdGlvblNlcnZpY2UpOiB2b2lkIHtcbiAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2UgPSBzZWxlY3Rpb25TZXJ2aWNlO1xuICB9XG5cbiAgbW91c2Vkb3duKGV2ZW50OiBNb3VzZUV2ZW50LCBkYXRhOiBhbnkpOiB2b2lkIHsgfVxuXG4gIGNsaWNrKGV2ZW50OiBNb3VzZUV2ZW50LCBkYXRhOiBhbnkpOiB2b2lkIHsgfVxuXG4gIGtleWRvd24oZXZlbnQ6IEtleWJvYXJkRXZlbnQsIGRhdGE6IGFueSk6IHZvaWQgeyB9XG5cbiAgLyoqXG4gICAqIFNlbGVjdCB0aGUgaXRlbSAtIGRlZmF1bHQgYmVoYXZpb3JcbiAgICovXG4gIHNlbGVjdCguLi5kYXRhOiBhbnlbXSk6IHZvaWQge1xuICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZS5zZWxlY3QoLi4uZGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogVG9nZ2xlIHRoZSBpdGVtJ3Mgc2VsZWN0ZWQgc3RhdGUgLSBkZWZhdWx0IGJlaGF2aW9yXG4gICAqL1xuICB0b2dnbGUoLi4uZGF0YTogYW55W10pOiB2b2lkIHtcbiAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2UudG9nZ2xlKC4uLmRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlc2VsZWN0IHRoZSBpdGVtIC0gZGVmYXVsdCBiZWhhdmlvclxuICAgKi9cbiAgZGVzZWxlY3QoLi4uZGF0YTogYW55W10pOiB2b2lkIHtcbiAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2UuZGVzZWxlY3QoLi4uZGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogU2VsZWN0IGFsbCBpdGVtcyAtIGRlZmF1bHQgYmVoYXZpb3JcbiAgICovXG4gIHNlbGVjdEFsbCgpOiB2b2lkIHtcbiAgICB0aGlzLnNlbGVjdCguLi50aGlzLnNlbGVjdGlvblNlcnZpY2UuZGF0YXNldCk7XG4gIH1cblxuICAvKipcbiAgICogRGVzZWxlY3QgYWxsIGl0ZW1zIC0gZGVmYXVsdCBiZWhhdmlvclxuICAgKi9cbiAgZGVzZWxlY3RBbGwoKTogdm9pZCB7XG5cbiAgICAvLyBjYWxsIGRlc2VsZWN0IG9uIGFsbCBpdGVtcyBpbiB0aGUgZGF0YXNldFxuICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZS5kZXNlbGVjdEFsbCgpO1xuICB9XG5cbiAgZGVzdHJveSgpOiB2b2lkIHsgfVxufVxuIiwiaW1wb3J0IHsgRE9XTl9BUlJPVywgU1BBQ0UsIFVQX0FSUk9XIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2tleWNvZGVzJztcbmltcG9ydCB7IFNlbGVjdGlvblN0cmF0ZWd5IH0gZnJvbSAnLi9zZWxlY3Rpb24uc3RyYXRlZ3knO1xuXG5leHBvcnQgY2xhc3MgUm93U2VsZWN0aW9uU3RyYXRlZ3kgZXh0ZW5kcyBTZWxlY3Rpb25TdHJhdGVneSB7XG5cbiAgLy8gc3RvcmUgdGhlIG1vc3QgcmVjZW50bHkgc2VsZWN0ZWQgcm93XG4gIHByaXZhdGUgX3NlbGVjdGlvbjogU2VsZWN0aW9uID0geyBzdGFydDogbnVsbCwgZW5kOiBudWxsIH07XG5cbiAgLyoqXG4gICAqIEJ5IGRlZmF1bHQgb24gc2hpZnQgY2xpY2sgdGhlIGJyb3dzZXIgd2lsbCBoaWdobGlnaHRcbiAgICogdGV4dC4gVGhpcyBsb29rcyBiYWQgYW5kIHdlIGRvbid0IHdhbnQgdGhpcyB0byBvY2N1clxuICAgKi9cbiAgbW91c2Vkb3duKGV2ZW50OiBNb3VzZUV2ZW50KTogdm9pZCB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGVuIGEgcm93IGlzIGNsaWNrZWQgd2Ugd2FudCB0byBoYW5kbGUgc2VsZWN0aW9uXG4gICAqL1xuICBjbGljayhldmVudDogTW91c2VFdmVudCwgZGF0YTogYW55KTogdm9pZCB7XG5cbiAgICAvLyBkZXRlcm1pbmUgd2hpY2ggbW9kaWZpZXIga2V5cyBhcmUgcHJlc3NlZFxuICAgIGNvbnN0IHsgY3RybEtleSwgc2hpZnRLZXkgfSA9IGV2ZW50O1xuXG4gICAgLy8gaWYgdGhlIHNoaWZ0IGtleSBpcyBwcmVzc2VkIHdlIHdhbnQgdG8gcGVyZm9ybSBhIG11bHRpcGxlIHNlbGVjdGlvblxuICAgIGlmIChzaGlmdEtleSkge1xuICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbGVTZWxlY3QoZGF0YSk7XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlIGNvbnRyb2wga2V5IGlzIHByZXNzZWQgd2Ugd2FudCB0byBwZXJmb3JtIGFuIGFkZGl0aXZlIHRvZ2dsZSBzZWxlY3Rpb25cbiAgICBpZiAoY3RybEtleSkge1xuICAgICAgcmV0dXJuIHRoaXMudG9nZ2xlKGRhdGEpO1xuICAgIH1cblxuICAgIC8vIHBlcmZvcm0gYSBzaW5nbGUgc2VsZWN0aW9uIHdoZXJlIGFsbCBvdGhlciByb3dzIGFyZSBkZXNlbGVjdGVkXG4gICAgdGhpcy5zaW5nbGVTZWxlY3QoZGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogVG8gc3VwcG9ydCBmdWxsIGtleWJvYXJkIGNvbnRyb2wgd2UgbmVlZCB0byBzdXBwb3J0IHRoZSBmb2xsb3dpbmc6XG4gICAqIDEuIEFycm93IGtleXMgdG8gbmF2aWdhdGUgdXAgYW5kIGRvd25cbiAgICogMi4gU3BhY2ViYXIgdG8gdG9nZ2xlIHNlbGVjdGlvblxuICAgKiAzLiBTaGlmdCArIEFycm93IGtleXMgdG8gbXVsdGlwbGUgc2VsZWN0XG4gICAqIDQuIEN0cmwgKyBBcnJvdyBrZXlzIHRvIGFsbG93IHJldGFpbmVkIHNlbGVjdGlvbiBhbmQgbmF2aWdhdGlvblxuICAgKi9cbiAga2V5ZG93bihldmVudDogS2V5Ym9hcmRFdmVudCwgZGF0YTogYW55KTogdm9pZCB7XG5cbiAgICBzd2l0Y2ggKGV2ZW50LndoaWNoKSB7XG5cbiAgICAgIGNhc2UgVVBfQVJST1c6XG4gICAgICBjYXNlIERPV05fQVJST1c6XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMubmF2aWdhdGUoZXZlbnQsIGRhdGEpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBTUEFDRTpcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLnN0cmF0ZWd5LnRvZ2dsZShkYXRhLCB0cnVlKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogT3ZlcnJpZGUgdGhlIHN0YW5kYXJkIHRvZ2dsZSBmdW5jdGlvbiB0byBzdG9yZSBvciBjbGVhciB0aGVcbiAgICogbW9zdCByZWNlbnRseSBzZWxlY3RlZCBpdGVtXG4gICAqL1xuICB0b2dnbGUoZGF0YTogYW55LCBhY3RpdmF0ZTogYm9vbGVhbiA9IGZhbHNlKTogdm9pZCB7XG4gICAgc3VwZXIudG9nZ2xlKGRhdGEpO1xuXG4gICAgLy8gc3RvcmUgb3IgY2xlYXIgdGhlIHNlbGVjdGlvblxuICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZS5pc1NlbGVjdGVkKGRhdGEpID8gdGhpcy5zZXRTZWxlY3Rpb25TdGFydChkYXRhKSA6IHRoaXMuY2xlYXJTZWxlY3Rpb24oKTtcblxuICAgIC8vIGlmIHdlIHdhbnQgdG8ga2VlcCB0aGUgaXRlbSBhY3RpdmF0ZWQgdGhlbiBhY3RpdmF0ZVxuICAgIGlmIChhY3RpdmF0ZSkge1xuICAgICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmFjdGl2YXRlKGRhdGEpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhciBhbGwgb3RoZXIgc2VsZWN0ZWQgaXRlbXMgYW5kIHNlbGVjdCBvbmx5XG4gICAqIHRoZSBtb3N0IHJlY2VudGx5IHNlbGVjdGVkIGl0ZW1cbiAgICovXG4gIHByaXZhdGUgc2luZ2xlU2VsZWN0KGRhdGE6IGFueSk6IHZvaWQge1xuXG4gICAgLy8gZGVzZWxlY3QgYWxsIG90aGVyIHJvd3MgaWYgbmVpdGhlciBtb2RpZmllciBrZXkgaXMgcHJlc3NlZFxuICAgIHRoaXMuZGVzZWxlY3RBbGwoKTtcblxuICAgIC8vIHNlbGVjdCB0aGUgY3VycmVudCByb3dcbiAgICB0aGlzLnNlbGVjdChkYXRhKTtcblxuICAgIC8vIHN0b3JlIHRoZSBjdXJyZW50IGl0ZW0gYXMgdGhlIHNlbGVjdGlvbiBzdGFydFxuICAgIHRoaXMuc2V0U2VsZWN0aW9uU3RhcnQoZGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIG11bHRpcGxlIHNlbGVjdGlvbjpcbiAgICogMS4gSWYgbm8gc3RhcnQgaXRlbSBzZWxlY3RlZCAtIHNlbGVjdCBpdFxuICAgKiAyLiBJZiBhIHN0YXJ0IGl0ZW0gaGFzIGJlZW4gc2VsZWN0ZWQgLSBzZWxlY3QgYWxsIGluIGJldHdlZW5cbiAgICogMy4gSWYgYSBzdGFydCBhbmQgZW5kIGl0ZW0gaGF2ZSBiZWVuIHNlbGVjdGVkIGNsZWFyIHRoZSByYW5nZSBhbmQgdGhlbiBzZWxlY3QgdGhlIG5ldyByYW5nZVxuICAgKi9cbiAgcHJvdGVjdGVkIG11bHRpcGxlU2VsZWN0KGRhdGE6IGFueSk6IHZvaWQge1xuXG4gICAgLy8gaWYgbm8gc2VsZWN0aW9uIGN1cnJlbnRseSBleGlzdHMgdGhlbiBwZXJmb3JtIGluaXRpYWwgc2VsZWN0aW9uXG4gICAgaWYgKCF0aGlzLl9zZWxlY3Rpb24uc3RhcnQpIHtcblxuICAgICAgLy8gc2VsZWN0IHRoZSByb3dcbiAgICAgIHRoaXMuc2VsZWN0KGRhdGEpO1xuXG4gICAgICAvLyBzdG9yZSB0aGUgc3RhcnRpbmcgcG9pbnRcbiAgICAgIHJldHVybiB0aGlzLnNldFNlbGVjdGlvblN0YXJ0KGRhdGEpO1xuICAgIH1cblxuICAgIC8vIGlmIGEgbXVsdGlwbGUgc2VsZWN0aW9uIGFscmVhZHkgdG9vayBwbGFjZSAtIGNsZWFyIHRoZSBwcmV2aW91cyBzZWxlY3Rpb25cbiAgICBpZiAodGhpcy5fc2VsZWN0aW9uLnN0YXJ0ICYmIHRoaXMuX3NlbGVjdGlvbi5lbmQpIHtcbiAgICAgIHRoaXMuZGVzZWxlY3QoLi4udGhpcy5nZXRTZWxlY3RlZEl0ZW1zKCkpO1xuICAgIH1cblxuICAgIC8vIHNldCB0aGUgbmV3IHNlbGVjdGlvbiBlbmQgcG9pbnRcbiAgICB0aGlzLnNldFNlbGVjdGlvbkVuZChkYXRhKTtcblxuICAgIC8vIHNlbGVjdCBhbGwgdGhlIGl0ZW1zIGluIHRoZSByYW5nZVxuICAgIHRoaXMuc2VsZWN0KC4uLnRoaXMuZ2V0U2VsZWN0ZWRJdGVtcygpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHNlbGVjdGlvbiBzdGFydCBwb2ludC4gSWYgdGhlcmUgd2FzIHByZXZpb3VzbHkgYVxuICAgKiBzZWxlY3Rpb24gZW5kIHBvaW50IHRoZW4gY2xlYXIgaXQgYXMgdGhpcyBpcyBhIG5ldyBzZWxlY3Rpb25cbiAgICovXG4gIHByaXZhdGUgc2V0U2VsZWN0aW9uU3RhcnQoZGF0YTogYW55KTogdm9pZCB7XG4gICAgdGhpcy5fc2VsZWN0aW9uLnN0YXJ0ID0gZGF0YTtcbiAgICB0aGlzLl9zZWxlY3Rpb24uZW5kID0gbnVsbDtcblxuICAgIC8vIGFjdGl2YXRlIHRoZSBpdGVtXG4gICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmFjdGl2YXRlKGRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgc2VsZWN0aW9uIGVuZCBwb2ludFxuICAgKi9cbiAgcHJpdmF0ZSBzZXRTZWxlY3Rpb25FbmQoZGF0YTogYW55KTogdm9pZCB7XG4gICAgdGhpcy5fc2VsZWN0aW9uLmVuZCA9IGRhdGE7XG5cbiAgICAvLyBhY3RpdmF0ZSB0aGUgaXRlbVxuICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZS5hY3RpdmF0ZShkYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhciBib3RoIHN0YXJ0IGFuZCBlbmQgc2VsZWN0aW9uIHBvaW50c1xuICAgKi9cbiAgcHJvdGVjdGVkIGNsZWFyU2VsZWN0aW9uKGRlYWN0aXZhdGU6IGJvb2xlYW4gPSB0cnVlKTogdm9pZCB7XG5cbiAgICAvLyByZXNldCB0aGUgc2VsZWN0ZWQgaXRlbVxuICAgIHRoaXMuX3NlbGVjdGlvbiA9IHsgc3RhcnQ6IG51bGwsIGVuZDogbnVsbCB9O1xuXG4gICAgLy8gcmVtb3ZlIHRoZSBjdXJyZW50IGFjdGl2ZSBpdGVtXG4gICAgaWYgKGRlYWN0aXZhdGUpIHtcbiAgICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZS5kZWFjdGl2YXRlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZSBhbGwgdGhlIGl0ZW1zIGFmZmVjdGVkIGJ5IHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAgICogTm90ZSB0aGF0IHRoZSBlbmQgcG9pbnQgbWF5IGJlIGFib3ZlIHRoZSBzdGFydCBwb2ludCBzb1xuICAgKiB3ZSBuZWVkIHRvIGFjY291bnQgZm9yIHRoaXMuXG4gICAqL1xuICBwcml2YXRlIGdldFNlbGVjdGVkSXRlbXMoKTogYW55W10ge1xuXG4gICAgLy8gZ2V0IHRoZSBsYXRlc3QgZGF0YXNldFxuICAgIGNvbnN0IHsgZGF0YXNldCB9ID0gdGhpcy5zZWxlY3Rpb25TZXJ2aWNlO1xuXG4gICAgLy8gZ2V0IHRoZSBpbmRleGVzIG9mIHRoZSBzdGFydCBhbmQgZW5kIHBvaW50XG4gICAgY29uc3Qgc3RhcnRJZHggPSBkYXRhc2V0LmluZGV4T2YodGhpcy5fc2VsZWN0aW9uLnN0YXJ0KTtcbiAgICBjb25zdCBlbmRJZHggPSBkYXRhc2V0LmluZGV4T2YodGhpcy5fc2VsZWN0aW9uLmVuZCk7XG5cbiAgICAvLyBnZXQgdGhlIHJlZ2lvbiBvZiB0aGUgYXJyYXkgdGhhdCBpcyBzZWxlY3RlZCAtIG5vdGUgdGhlIGVuZElkeCBtYXkgYmUgYmVmb3JlIHRoZSBzdGFydElkeCBzbyBhY2NvdW50IGZvciB0aGlzXG4gICAgcmV0dXJuIGRhdGFzZXQuc2xpY2UoTWF0aC5taW4oc3RhcnRJZHgsIGVuZElkeCksIE1hdGgubWF4KHN0YXJ0SWR4LCBlbmRJZHgpICsgMSk7XG4gIH1cblxuICAvKipcbiAgICogQWN0aXZhdGUgdGhlIHNpYmxpbmcgaXRlbSB3aGVuIGFycm93IGtleXMgYXJlIHByZXNzZWRcbiAgICovXG4gIHByaXZhdGUgbmF2aWdhdGUoZXZlbnQ6IEtleWJvYXJkRXZlbnQsIGRhdGE6IGFueSk6IHZvaWQge1xuXG4gICAgLy8gZGV0ZXJtaW5lIHdoaWNoIG1vZGlmaWVyIGtleXMgYXJlIHByZXNzZWRcbiAgICBjb25zdCB7IGN0cmxLZXksIHNoaWZ0S2V5IH0gPSBldmVudDtcblxuICAgIC8vIGlmIG5vIG1vZGlmaWVyIGtleXMgYXJlIHByZXNzZWQgdGhlbiBkZXNlbGVjdCBhbGwgYW5kIGNsZWFyIHRoZSBzZWxlY3Rpb25cbiAgICBpZiAoIWN0cmxLZXkgJiYgIXNoaWZ0S2V5KSB7XG4gICAgICB0aGlzLmRlc2VsZWN0QWxsKCk7XG4gICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKGZhbHNlKTtcbiAgICB9XG5cbiAgICAvLyBhY3RpdmF0ZSB0aGUgc2libGluZyAtIGlmIHRoZSB1cCBhcnJvdyBpcyBwcmVzc2VkIHRoZW4gbmF2aWdhdGUgdG8gdGhlIHByZXZpb3VzIHNpYmxpbmdcbiAgICBjb25zdCBzaWJsaW5nID0gdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmFjdGl2YXRlU2libGluZyhldmVudC53aGljaCA9PT0gVVBfQVJST1cpO1xuXG4gICAgLy8gaWYgdGhlIHNoaWZ0IGtleSBpcyBwcmVzc2VkIHRoZW4gd2UgYWxzbyB3YW50IHRvIHRvZ2dsZSB0aGUgc3RhdGUgaWYgdGhlIGl0ZW1cbiAgICBpZiAoc2hpZnRLZXkgJiYgc2libGluZykge1xuXG4gICAgICAvLyBpZiB0aGVyZSBpcyBubyBjdXJyZW50IHNlbGVjdGlvbiBzdGFydCB0aGVuIHNlbGVjdCB0aGUgY3VycmVudCByb3dcbiAgICAgIGlmICghdGhpcy5fc2VsZWN0aW9uLnN0YXJ0KSB7XG4gICAgICAgIHRoaXMubXVsdGlwbGVTZWxlY3QoZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubXVsdGlwbGVTZWxlY3Qoc2libGluZyk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VsZWN0aW9uIHtcbiAgc3RhcnQ6IGFueTtcbiAgZW5kOiBhbnk7XG59XG4iLCJpbXBvcnQgeyBET1dOX0FSUk9XLCBTUEFDRSwgVVBfQVJST1cgfSBmcm9tICdAYW5ndWxhci9jZGsva2V5Y29kZXMnO1xyXG5pbXBvcnQgeyBSb3dTZWxlY3Rpb25TdHJhdGVneSB9IGZyb20gJy4vcm93LXNlbGVjdGlvbi5zdHJhdGVneSc7XHJcblxyXG5leHBvcnQgY2xhc3MgUm93QWx0U2VsZWN0aW9uU3RyYXRlZ3kgZXh0ZW5kcyBSb3dTZWxlY3Rpb25TdHJhdGVneSB7XHJcbiAgICBrZXlkb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50LCBkYXRhOiBhbnkpOiB2b2lkIHtcclxuICAgICAgICBzd2l0Y2ggKGV2ZW50LndoaWNoKSB7XHJcbiAgICAgICAgICAgIGNhc2UgVVBfQVJST1c6XHJcbiAgICAgICAgICAgIGNhc2UgRE9XTl9BUlJPVzpcclxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUN1cnNvcktleShldmVudCwgZGF0YSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgU1BBQ0U6XHJcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLnN0cmF0ZWd5LnRvZ2dsZShkYXRhKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNlbGVjdCB0aGUgc2libGluZyBpdGVtIHdoZW4gYXJyb3cga2V5cyBhcmUgcHJlc3NlZFxyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGhhbmRsZUN1cnNvcktleShldmVudDogS2V5Ym9hcmRFdmVudCwgZGF0YTogYW55KTogdm9pZCB7XHJcbiAgICAgICAgLy8gZGV0ZXJtaW5lIHdoaWNoIG1vZGlmaWVyIGtleXMgYXJlIHByZXNzZWRcclxuICAgICAgICBjb25zdCB7IGN0cmxLZXksIHNoaWZ0S2V5IH0gPSBldmVudDtcclxuXHJcbiAgICAgICAgLy8gaWYgbm8gbW9kaWZpZXIga2V5cyBhcmUgcHJlc3NlZCB0aGVuIGRlc2VsZWN0IGFsbCBhbmQgY2xlYXIgdGhlIHNlbGVjdGlvblxyXG4gICAgICAgIGlmICghY3RybEtleSAmJiAhc2hpZnRLZXkpIHtcclxuICAgICAgICAgICAgdGhpcy5kZXNlbGVjdEFsbCgpO1xyXG4gICAgICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKGZhbHNlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChjdHJsS2V5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZS5hY3RpdmF0ZVNpYmxpbmcoZXZlbnQud2hpY2ggPT09IFVQX0FSUk9XKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBzaWJsaW5nID0gdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmdldFNpYmxpbmcoZXZlbnQud2hpY2ggPT09IFVQX0FSUk9XKTtcclxuICAgICAgICAgICAgdGhpcy5tdWx0aXBsZVNlbGVjdChzaWJsaW5nID8gc2libGluZyA6IGRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBET1dOX0FSUk9XLCBTUEFDRSwgVVBfQVJST1cgfSBmcm9tICdAYW5ndWxhci9jZGsva2V5Y29kZXMnO1xuaW1wb3J0IHsgU2VsZWN0aW9uU3RyYXRlZ3kgfSBmcm9tICcuL3NlbGVjdGlvbi5zdHJhdGVneSc7XG5cbmV4cG9ydCBjbGFzcyBTaW1wbGVTZWxlY3Rpb25TdHJhdGVneSBleHRlbmRzIFNlbGVjdGlvblN0cmF0ZWd5IHtcblxuICAvKipcbiAgICogV2hlbiB0aGUgaXRlbSBpcyBjbGlja2VkIHNpbXBseSB0b2dnbGUgdGhlIGN1cnJlbnQgc2VsZWN0ZWQgc3RhdGVcbiAgICovXG4gIGNsaWNrKF9ldmVudDogTW91c2VFdmVudCwgZGF0YTogYW55KTogdm9pZCB7XG4gICAgdGhpcy50b2dnbGUoZGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGJhc2ljIGtleWJvYXJkIHN1cHBvcnQgZm9yIG5hdmlnYXRpbmdcbiAgICogYW5kIHNlbGVjdGluZy9kZXNlbGVjdGluZyBpdGVtc1xuICAgKi9cbiAga2V5ZG93bihldmVudDogS2V5Ym9hcmRFdmVudCwgZGF0YTogYW55KTogdm9pZCB7XG5cbiAgICBzd2l0Y2ggKGV2ZW50LndoaWNoKSB7XG5cbiAgICAgIGNhc2UgVVBfQVJST1c6XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvblNlcnZpY2UuYWN0aXZhdGVTaWJsaW5nKHRydWUpO1xuXG4gICAgICBjYXNlIERPV05fQVJST1c6XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvblNlcnZpY2UuYWN0aXZhdGVTaWJsaW5nKGZhbHNlKTtcblxuICAgICAgY2FzZSBTUEFDRTpcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9nZ2xlKGRhdGEpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBPdmVycmlkZSB0aGUgc3RhbmRhcmQgdG9nZ2xlIGZ1bmN0aW9uIHRvIGFsd2F5cyBhY3RpdmF0ZSB0aGUgaXRlbVxuICAgKi9cbiAgdG9nZ2xlKGRhdGE6IGFueSk6IHZvaWQge1xuICAgIHN1cGVyLnRvZ2dsZShkYXRhKTtcbiAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2UuYWN0aXZhdGUoZGF0YSk7XG4gIH1cbn1cbiIsImltcG9ydCB7IEluamVjdGFibGUsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcy9CZWhhdmlvclN1YmplY3QnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMvT2JzZXJ2YWJsZSc7XG5pbXBvcnQgeyBkaXN0aW5jdFVudGlsQ2hhbmdlZCwgbWFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgUm93QWx0U2VsZWN0aW9uU3RyYXRlZ3kgfSBmcm9tICcuL3N0cmF0ZWdpZXMvcm93LWFsdC1zZWxlY3Rpb24uc3RyYXRlZ3knO1xuaW1wb3J0IHsgUm93U2VsZWN0aW9uU3RyYXRlZ3kgfSBmcm9tICcuL3N0cmF0ZWdpZXMvcm93LXNlbGVjdGlvbi5zdHJhdGVneSc7XG5pbXBvcnQgeyBTZWxlY3Rpb25TdHJhdGVneSB9IGZyb20gJy4vc3RyYXRlZ2llcy9zZWxlY3Rpb24uc3RyYXRlZ3knO1xuaW1wb3J0IHsgU2ltcGxlU2VsZWN0aW9uU3RyYXRlZ3kgfSBmcm9tICcuL3N0cmF0ZWdpZXMvc2ltcGxlLXNlbGVjdGlvbi5zdHJhdGVneSc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBTZWxlY3Rpb25TZXJ2aWNlIGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICBzZXQgZGF0YXNldChkYXRhc2V0OiBSZWFkb25seUFycmF5PGFueT4pIHtcbiAgICB0aGlzLl9kYXRhc2V0ID0gZGF0YXNldDtcbiAgICBpZiAodGhpcy5fZGF0YXNldC5pbmRleE9mKHRoaXMuX2FjdGl2ZSkgPT09IC0xKSB7XG4gICAgICB0aGlzLnNldEZpcnN0SXRlbUZvY3VzYWJsZSgpO1xuICAgIH1cbiAgfVxuXG4gIGdldCBkYXRhc2V0KCk6IFJlYWRvbmx5QXJyYXk8YW55PiB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFzZXQ7XG4gIH1cblxuICBzdHJhdGVneTogU2VsZWN0aW9uU3RyYXRlZ3kgPSBuZXcgU2ltcGxlU2VsZWN0aW9uU3RyYXRlZ3kodGhpcyk7XG4gIGlzRW5hYmxlZDogYm9vbGVhbiA9IHRydWU7XG4gIGlzQ2xpY2tFbmFibGVkOiBib29sZWFuID0gdHJ1ZTtcbiAgaXNLZXlib2FyZEVuYWJsZWQ6IGJvb2xlYW4gPSB0cnVlO1xuXG4gIGZvY3VzJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8YW55PihudWxsKTtcbiAgYWN0aXZlJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8YW55PihudWxsKTtcbiAgc2VsZWN0aW9uJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8YW55W10+KFtdKTtcblxuICBwcml2YXRlIF9hY3RpdmU6IGFueTtcbiAgcHJpdmF0ZSBfZGF0YXNldDogUmVhZG9ubHlBcnJheTxhbnk+ID0gW107XG4gIHByaXZhdGUgX3NlbGVjdGlvbiA9IG5ldyBTZXQoKTtcbiAgcHJpdmF0ZSBfc3RyYXRlZ3lUb0Rlc3Ryb3k6IFNlbGVjdGlvblN0cmF0ZWd5ID0gdGhpcy5zdHJhdGVneTtcblxuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fc3RyYXRlZ3lUb0Rlc3Ryb3kpIHtcbiAgICAgIHRoaXMuX3N0cmF0ZWd5VG9EZXN0cm95LmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSWYgdGhlIGl0ZW0gaXMgbm90IGN1cnJlbnRseSBzZWxlY3RlZCB0aGVuIGFkZCBpdFxuICAgKiB0byB0aGUgbGlzdCBvZiBzZWxlY3RlZCBpdGVtc1xuICAgKi9cbiAgc2VsZWN0KC4uLnNlbGVjdGlvbnM6IGFueVtdKTogdm9pZCB7XG5cbiAgICAvLyBhZGQgZWFjaCBzZWxlY3Rpb24gdG8gdGhlIHNldFxuICAgIHNlbGVjdGlvbnMuZm9yRWFjaChzZWxlY3Rpb24gPT4gdGhpcy5fc2VsZWN0aW9uLmFkZChzZWxlY3Rpb24pKTtcblxuICAgIC8vIHByb3BhZ2F0ZSB0aGUgY2hhbmdlc1xuICAgIHRoaXMuc2VsZWN0aW9uSGFzTXV0YXRlZCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBpdGVtIGZyb20gdGhlIGxpc3Qgb2Ygc2VsZWN0ZWQgaXRlbXNcbiAgICovXG4gIGRlc2VsZWN0KC4uLnNlbGVjdGlvbnM6IGFueVtdKTogdm9pZCB7XG4gICAgLy8gcmVtb3ZlIGVhY2ggaXRlbSBmcm9tIHRoZSBzZXRcbiAgICBzZWxlY3Rpb25zLmZvckVhY2goc2VsZWN0aW9uID0+IHRoaXMuX3NlbGVjdGlvbi5kZWxldGUoc2VsZWN0aW9uKSk7XG5cbiAgICAvLyBwcm9wYWdhdGUgdGhlIGNoYW5nZXNcbiAgICB0aGlzLnNlbGVjdGlvbkhhc011dGF0ZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYWxsIGl0ZW1zIGZyb20gdGhlIGxpc3Qgb2Ygc2VsZWN0ZWQgaXRlbXNcbiAgICovXG4gIGRlc2VsZWN0QWxsKCk6IHZvaWQge1xuICAgIC8vIHJlbW92ZSBhbGwgaXRlbXMgaW4gdGhlIGFycmF5XG4gICAgdGhpcy5kZXNlbGVjdCguLi50aGlzLl9kYXRhc2V0KTtcblxuICAgIC8vIGNsZWFyIHRoZSBzZXQgaW4gY2FzZSBhbnkgaXRlbXMgaGF2ZSBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgRE9NIGJ1dCBhcmUgc3RpbGwgc2VsZWN0ZWRcbiAgICB0aGlzLl9zZWxlY3Rpb24uY2xlYXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUb2dnbGUgdGhlIHNlbGVjdGVkIHN0YXRlIG9mIGFueSBzcGVjaWZpZWQgaXRlbXNcbiAgICovXG4gIHRvZ2dsZSguLi5zZWxlY3Rpb25zOiBhbnlbXSk6IHZvaWQge1xuICAgIHNlbGVjdGlvbnMuZm9yRWFjaChzZWxlY3Rpb24gPT4gdGhpcy5pc1NlbGVjdGVkKHNlbGVjdGlvbikgPyB0aGlzLmRlc2VsZWN0KHNlbGVjdGlvbikgOiB0aGlzLnNlbGVjdChzZWxlY3Rpb24pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgd2hldGhlciBvciBub3QgYSBzcGVjaWZpYyBpdGVtIGlzIGN1cnJlbnRseSBzZWxlY3RlZFxuICAgKi9cbiAgaXNTZWxlY3RlZChkYXRhOiBhbnkpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0aW9uLmhhcyhkYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gb2JzZXJ2YWJsZSBzcGVjaWZpY2FsbHkgZm9yIG5vdGlmeWluZyB0aGUgc3Vic2NyaWJlclxuICAgKiBvbmx5IHdoZW4gdGhlIHNlbGVjdGlvbiBzdGF0ZSBvZiBhIHNwZWNpZmljIG9iamVjdCBoYXMgY2hhbmdlZFxuICAgKi9cbiAgZ2V0U2VsZWN0aW9uU3RhdGUoZGF0YTogYW55KTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uJC5waXBlKG1hcCgoKSA9PiB0aGlzLmlzU2VsZWN0ZWQoZGF0YSkpLCBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWZpbmUgaG93IHNlbGVjdGlvbnMgc2hvdWxkIGJlIHBlcmZvcm1lZC5cbiAgICogVGhpcyBhbGxvd3MgdXMgdG8gdXNlIGFuIHN0cmF0ZWd5IHBhdHRlcm4gdG8gaGFuZGxlIHRoZSB2YXJpb3VzIGtleWJvYXJkXG4gICAqIGFuZCBtb3VzZSBpbnRlcmFjdGlvbnMgd2hpbGUga2VlcGluZyBlYWNoIG1vZGUgc2VwYXJhdGVkIGFuZFxuICAgKiBlYXNpbHkgZXh0ZW5zaWJsZSBpZiB3ZSB3YW50IHRvIGFkZCBtb3JlIG1vZGVzIGluIGZ1dHVyZSFcbiAgICovXG4gIHNldFN0cmF0ZWd5KG1vZGU6IFNlbGVjdGlvbk1vZGUgfCBTZWxlY3Rpb25TdHJhdGVneSk6IHZvaWQge1xuXG4gICAgaWYgKHRoaXMuX3N0cmF0ZWd5VG9EZXN0cm95KSB7XG4gICAgICAvLyBEZXN0cm95IHByZXZpb3VzIHN0cmF0ZWd5IGlmIGl0IHdhcyBjcmVhdGVkIGludGVybmFsbHlcbiAgICAgIHRoaXMuX3N0cmF0ZWd5VG9EZXN0cm95LmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuX3N0cmF0ZWd5VG9EZXN0cm95ID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAobW9kZSBpbnN0YW5jZW9mIFNlbGVjdGlvblN0cmF0ZWd5KSB7XG5cbiAgICAgIC8vIEN1c3RvbSBzdHJhdGVneSAtIHBhc3MgaW4gdGhlIHNlcnZpY2UgaW5zdGFuY2VcbiAgICAgIHRoaXMuc3RyYXRlZ3kgPSBtb2RlO1xuICAgICAgdGhpcy5zdHJhdGVneS5zZXRTZWxlY3Rpb25TZXJ2aWNlKHRoaXMpO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgc3dpdGNoIChtb2RlLnRvTG93ZXJDYXNlKCkudHJpbSgpKSB7XG5cbiAgICAgICAgY2FzZSAnc2ltcGxlJzpcbiAgICAgICAgICB0aGlzLnN0cmF0ZWd5ID0gdGhpcy5fc3RyYXRlZ3lUb0Rlc3Ryb3kgPSBuZXcgU2ltcGxlU2VsZWN0aW9uU3RyYXRlZ3kodGhpcyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncm93JzpcbiAgICAgICAgICB0aGlzLnN0cmF0ZWd5ID0gdGhpcy5fc3RyYXRlZ3lUb0Rlc3Ryb3kgPSBuZXcgUm93U2VsZWN0aW9uU3RyYXRlZ3kodGhpcyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncm93LWFsdCc6XG4gICAgICAgICAgdGhpcy5zdHJhdGVneSA9IHRoaXMuX3N0cmF0ZWd5VG9EZXN0cm95ID0gbmV3IFJvd0FsdFNlbGVjdGlvblN0cmF0ZWd5KHRoaXMpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgc2VsZWN0aW9uIG1vZGUgJyR7bW9kZX0nIGRvZXMgbm90IGV4aXN0LiBWYWxpZCBtb2RlcyBhcmUgJ3NpbXBsZScsICdyb3cnLCBvciAncm93LWFsdCcuYCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgY3VycmVudCBhY3RpdmUgaXRlbVxuICAgKi9cbiAgYWN0aXZhdGUoZGF0YTogYW55KTogdm9pZCB7XG4gICAgdGhpcy5fYWN0aXZlID0gZGF0YTtcbiAgICB0aGlzLmFjdGl2ZSQubmV4dCh0aGlzLl9hY3RpdmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlYWN0aXZlIGFsbCBpdGVtc1xuICAgKi9cbiAgZGVhY3RpdmF0ZSgpOiB2b2lkIHtcbiAgICB0aGlzLl9hY3RpdmUgPSBudWxsO1xuICAgIHRoaXMuYWN0aXZlJC5uZXh0KHRoaXMuX2FjdGl2ZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBuZXh0IG9yIHByZXZpb3VzIHNpYmxpbmcgb2YgdGhlIGN1cnJlbnQgYWN0aXZlIGl0ZW0uXG4gICAqIEBwYXJhbSBwcmV2aW91cyBJZiB0cnVlLCB0aGUgcHJldmlvdXMgc2libGluZyB3aWxsIGJlIHJldHVybmVkLlxuICAgKi9cbiAgZ2V0U2libGluZyhwcmV2aW91czogYm9vbGVhbiA9IGZhbHNlKTogYW55IHtcblxuICAgIC8vIGNoZWNrIGlmIHRoZXJlIGlzIGEgY3VycmVudCBhY3RpdmUgaXRlbVxuICAgIGlmICghdGhpcy5fYWN0aXZlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgY3VycmVudCBpdGVtXG4gICAgY29uc3QgaWR4ID0gdGhpcy5kYXRhc2V0LmluZGV4T2YodGhpcy5fYWN0aXZlKTtcbiAgICBjb25zdCB0YXJnZXQgPSB0aGlzLmRhdGFzZXRbcHJldmlvdXMgPyBpZHggLSAxIDogaWR4ICsgMV07XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgLyoqXG4gICAqIEFjdGl2YXRlIHRoZSBzaWJsaW5nIG9mIHRoZSBjdXJyZW50IGFjdGl2ZSBpdGVtLlxuICAgKiBJZiBwcmV2aW91cyBpcyBzZXQgdG8gdHJ1ZSB0aGUgcHJldmlvdXMgc2libGluZyB3aWxsIGJlIGFjdGl2YXRlZFxuICAgKiByYXRoZXIgdGhhbiB0aGUgbmV4dCBzaWJsaW5nLiBUaGlzIGZ1bmN0aW9uIHdpbGwgYWxzbyByZXR1cm4gdGhlXG4gICAqIGRhdGEgb2YgdGhlIG5ld2x5IGFjdGl2YXRlZCBzaWJsaW5nXG4gICAqL1xuICBhY3RpdmF0ZVNpYmxpbmcocHJldmlvdXM6IGJvb2xlYW4gPSBmYWxzZSk6IGFueSB7XG5cbiAgICBjb25zdCB0YXJnZXQgPSB0aGlzLmdldFNpYmxpbmcocHJldmlvdXMpO1xuXG4gICAgLy8gY2hlY2sgaWYgdGhlIHRhcmdldCBleGlzdHNcbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICB0aGlzLmFjdGl2YXRlKHRhcmdldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuXG4gIHNldERpc2FibGVkKGRpc2FibGVkOiBib29sZWFuKTogdm9pZCB7XG4gICAgLy8gc3RvcmUgdGhlIGN1cnJlbnQgZGlzYWJsZWQgc3RhdGVcbiAgICB0aGlzLmlzRW5hYmxlZCA9ICFkaXNhYmxlZDtcblxuICAgIC8vIGNsZWFyIGFueSBzdGF0ZWZ1bCBkYXRhXG4gICAgdGhpcy5fYWN0aXZlID0gbnVsbDtcbiAgICB0aGlzLmFjdGl2ZSQubmV4dCh0aGlzLl9hY3RpdmUpO1xuICAgIHRoaXMuX3NlbGVjdGlvbi5jbGVhcigpO1xuXG4gICAgLy8gZW1pdCB0aGUgc2VsZWN0aW9uIGNoYW5nZSBpbmZvcm1hdGlvblxuICAgIHRoaXMuc2VsZWN0aW9uSGFzTXV0YXRlZCgpO1xuICB9XG5cbiAgcHJpdmF0ZSBzZWxlY3Rpb25IYXNNdXRhdGVkKCk6IHZvaWQge1xuICAgIHRoaXMuc2VsZWN0aW9uJC5uZXh0KEFycmF5LmZyb20odGhpcy5fc2VsZWN0aW9uKSk7XG4gIH1cblxuICBwcml2YXRlIHNldEZpcnN0SXRlbUZvY3VzYWJsZSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fZGF0YXNldC5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmZvY3VzJC5uZXh0KHRoaXMuX2RhdGFzZXRbMF0pO1xuICAgICAgdGhpcy5fYWN0aXZlID0gdGhpcy5fZGF0YXNldFswXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYWN0aXZlID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgU2VsZWN0aW9uTW9kZSA9ICdzaW1wbGUnIHwgJ3JvdycgfCAncm93LWFsdCc7IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBIb3N0QmluZGluZywgSG9zdExpc3RlbmVyLCBJbnB1dCwgT25EZXN0cm95IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBmaWx0ZXIsIHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzL1N1YmplY3QnO1xuaW1wb3J0IHsgU2VsZWN0aW9uU2VydmljZSB9IGZyb20gJy4uLy4uLy4uL2RpcmVjdGl2ZXMvc2VsZWN0aW9uL3NlbGVjdGlvbi5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1zZWxlY3QtbGlzdC1pdGVtJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vc2VsZWN0LWxpc3QtaXRlbS5jb21wb25lbnQuaHRtbCcsXG4gICAgaG9zdDoge1xuICAgICAgICByb2xlOiAnbGlzdGl0ZW0nXG4gICAgfVxufSlcbmV4cG9ydCBjbGFzcyBTZWxlY3RMaXN0SXRlbUNvbXBvbmVudCBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG5cbiAgICBASW5wdXQoKSBkYXRhOiBhbnk7XG4gICAgQEhvc3RCaW5kaW5nKCd0YWJpbmRleCcpIHRhYmluZGV4OiBudW1iZXIgPSAtMTtcblxuICAgIEBIb3N0QmluZGluZygnY2xhc3Muc2VsZWN0ZWQnKVxuICAgIEBIb3N0QmluZGluZygnYXR0ci5hcmlhLXNlbGVjdGVkJylcbiAgICBzZXQgc2VsZWN0ZWQoaXNTZWxlY3RlZDogYm9vbGVhbikge1xuICAgICAgICBpc1NlbGVjdGVkID8gdGhpcy5fc2VsZWN0aW9uLnNlbGVjdCh0aGlzLmRhdGEpIDogdGhpcy5fc2VsZWN0aW9uLmRlc2VsZWN0KHRoaXMuZGF0YSk7XG4gICAgfVxuXG4gICAgZ2V0IHNlbGVjdGVkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VsZWN0aW9uLmlzU2VsZWN0ZWQodGhpcy5kYXRhKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9vbkRlc3Ryb3kgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfc2VsZWN0aW9uOiBTZWxlY3Rpb25TZXJ2aWNlLCBlbGVtZW50UmVmOiBFbGVtZW50UmVmKSB7XG5cbiAgICAgICAgX3NlbGVjdGlvbi5hY3RpdmUkLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSksIGZpbHRlcihkYXRhID0+IGRhdGEgPT09IHRoaXMuZGF0YSkpLnN1YnNjcmliZShhY3RpdmUgPT4ge1xuICAgICAgICAgICAgX3NlbGVjdGlvbi5mb2N1cyQubmV4dChhY3RpdmUpO1xuICAgICAgICAgICAgZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIG1ha2UgdGhpcyBpdGVtIHRhYmJhYmxlIG9yIG5vdCBiYXNlZCBvbiB0aGUgZm9jdXNlZCBlbGVtZW50XG4gICAgICAgIF9zZWxlY3Rpb24uZm9jdXMkLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKGZvY3VzZWQgPT4gdGhpcy50YWJpbmRleCA9IGZvY3VzZWQgPT09IHRoaXMuZGF0YSA/IDAgOiAtMSk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX29uRGVzdHJveS5uZXh0KCk7XG4gICAgICAgIHRoaXMuX29uRGVzdHJveS5jb21wbGV0ZSgpO1xuICAgIH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ21vdXNlZG93bicsIFsnJGV2ZW50J10pXG4gICAgb25Nb3VzZURvd24oZXZlbnQ6IE1vdXNlRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fc2VsZWN0aW9uLnN0cmF0ZWd5Lm1vdXNlZG93bihldmVudCwgdGhpcy5kYXRhKTtcbiAgICB9XG5cbiAgICBASG9zdExpc3RlbmVyKCdjbGljaycsIFsnJGV2ZW50J10pXG4gICAgb25DbGljayhldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9zZWxlY3Rpb24uc3RyYXRlZ3kuY2xpY2soZXZlbnQsIHRoaXMuZGF0YSk7XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcigna2V5ZG93bicsIFsnJGV2ZW50J10pXG4gICAgb25LZXlkb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3NlbGVjdGlvbi5zdHJhdGVneS5rZXlkb3duKGV2ZW50LCB0aGlzLmRhdGEpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBET1dOX0FSUk9XLCBFTlRFUiwgU1BBQ0UsIFVQX0FSUk9XIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2tleWNvZGVzJztcbmltcG9ydCB7IFNlbGVjdGlvblN0cmF0ZWd5IH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9zZWxlY3Rpb24vc3RyYXRlZ2llcy9zZWxlY3Rpb24uc3RyYXRlZ3knO1xuXG5leHBvcnQgY2xhc3MgTXVsdGlwbGVTZWxlY3RMaXN0U3RyYXRlZ3kgZXh0ZW5kcyBTZWxlY3Rpb25TdHJhdGVneSB7XG5cbiAgICBwcml2YXRlIF9sYXN0U2VsZWN0aW9uOiBhbnk7XG5cbiAgICAvKiogUHJldmVudCB0aGUgYnJvd3NlciBmcm9tIGhpZ2hsaWdodGluZyB0ZXh0IG9uIHNoaWZ0IGNsaWNrICovXG4gICAgbW91c2Vkb3duKGV2ZW50OiBNb3VzZUV2ZW50KTogdm9pZCB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgY2xpY2soZXZlbnQ6IE1vdXNlRXZlbnQsIGRhdGE6IGFueSk6IHZvaWQge1xuXG4gICAgICAgIC8vIGFjdGl2YXRlIHRoZSBjbGlja2VkIGl0ZW1cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmFjdGl2YXRlKGRhdGEpO1xuXG4gICAgICAgIC8vIGlmIHRoZSBzaGlmdCBrZXkgaXMgcHJlc3NlZCB3ZSB3YW50IHRvIHBlcmZvcm0gYSBtdWx0aXBsZSBzZWxlY3Rpb25cbiAgICAgICAgaWYgKGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBsZVNlbGVjdChkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG90aGVyd2lzZSBwZXJmb3JtIGEgc2luZ2xlIHRvZ2dsZSBzZWxlY3Rpb25cbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uU2VydmljZS5pc1NlbGVjdGVkKGRhdGEpKSB7XG4gICAgICAgICAgICB0aGlzLmRlc2VsZWN0KGRhdGEpO1xuICAgICAgICAgICAgdGhpcy5fbGFzdFNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdChkYXRhKTtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RTZWxlY3Rpb24gPSBkYXRhO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAga2V5ZG93bihldmVudDogS2V5Ym9hcmRFdmVudCwgZGF0YTogYW55KTogdm9pZCB7XG5cbiAgICAgICAgc3dpdGNoIChldmVudC53aGljaCkge1xuXG4gICAgICAgICAgICBjYXNlIFVQX0FSUk9XOiB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzaWJsaW5nID0gdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmFjdGl2YXRlU2libGluZyh0cnVlKTtcblxuICAgICAgICAgICAgICAgIGlmIChldmVudC5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdChkYXRhLCBzaWJsaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGFzdFNlbGVjdGlvbiA9IHNpYmxpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlIERPV05fQVJST1c6IHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpYmxpbmcgPSB0aGlzLnNlbGVjdGlvblNlcnZpY2UuYWN0aXZhdGVTaWJsaW5nKGZhbHNlKTtcblxuICAgICAgICAgICAgICAgIGlmIChldmVudC5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdChkYXRhLCBzaWJsaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGFzdFNlbGVjdGlvbiA9IHNpYmxpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlIFNQQUNFOlxuICAgICAgICAgICAgY2FzZSBFTlRFUjpcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMudG9nZ2xlKGRhdGEpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RTZWxlY3Rpb24gPSB0aGlzLnNlbGVjdGlvblNlcnZpY2UuaXNTZWxlY3RlZChkYXRhKSA/IGRhdGEgOiBudWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbXVsdGlwbGVTZWxlY3QoZGF0YTogYW55KTogdm9pZCB7XG5cbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gc3RhcnQgaXRlbSBzZWxlY3RlZFxuICAgICAgICBpZiAoIXRoaXMuX2xhc3RTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0KGRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xhc3RTZWxlY3Rpb24gPSBkYXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhlcmUgYWxyZWFkeSBpcyBhIHN0YXJ0IGl0ZW0gdGhlbiBmaW5kIHRoZSBpdGVtcyBpbiB0aGUgcmFuZ2VcbiAgICAgICAgdGhpcy5zZWxlY3QoLi4udGhpcy5nZXRTZWxlY3RlZEl0ZW1zKHRoaXMuX2xhc3RTZWxlY3Rpb24sIGRhdGEpKTtcblxuICAgICAgICAvLyBzdG9yZSB0aGUgc2VsZWN0aW9uIGVuZCBwb2ludFxuICAgICAgICB0aGlzLl9sYXN0U2VsZWN0aW9uID0gZGF0YTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldFNlbGVjdGVkSXRlbXMoc3RhcnQ6IGFueSwgZW5kOiBhbnkpOiBhbnlbXSB7XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBsYXRlc3QgZGF0YXNldFxuICAgICAgICBjb25zdCB7IGRhdGFzZXQgfSA9IHRoaXMuc2VsZWN0aW9uU2VydmljZTtcblxuICAgICAgICAvLyBnZXQgdGhlIGluZGV4ZXMgb2YgdGhlIHN0YXJ0IGFuZCBlbmQgcG9pbnRcbiAgICAgICAgY29uc3Qgc3RhcnRJZHggPSBkYXRhc2V0LmluZGV4T2Yoc3RhcnQpO1xuICAgICAgICBjb25zdCBlbmRJZHggPSBkYXRhc2V0LmluZGV4T2YoZW5kKTtcblxuICAgICAgICAvLyBnZXQgdGhlIHJlZ2lvbiBvZiB0aGUgYXJyYXkgdGhhdCBpcyBzZWxlY3RlZCAtIG5vdGUgdGhlIGVuZElkeCBtYXkgYmUgYmVmb3JlIHRoZSBzdGFydElkeCBzbyBhY2NvdW50IGZvciB0aGlzXG4gICAgICAgIHJldHVybiBkYXRhc2V0LnNsaWNlKE1hdGgubWluKHN0YXJ0SWR4LCBlbmRJZHgpLCBNYXRoLm1heChzdGFydElkeCwgZW5kSWR4KSArIDEpO1xuICAgIH1cblxufSIsImltcG9ydCB7IERPV05fQVJST1csIEVOVEVSLCBTUEFDRSwgVVBfQVJST1cgfSBmcm9tICdAYW5ndWxhci9jZGsva2V5Y29kZXMnO1xuaW1wb3J0IHsgU2VsZWN0aW9uU3RyYXRlZ3kgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL3NlbGVjdGlvbi9zdHJhdGVnaWVzL3NlbGVjdGlvbi5zdHJhdGVneSc7XG5cbmV4cG9ydCBjbGFzcyBTaW5nbGVTZWxlY3RMaXN0U3RyYXRlZ3kgZXh0ZW5kcyBTZWxlY3Rpb25TdHJhdGVneSB7XG5cbiAgICBjbGljayhfZXZlbnQ6IE1vdXNlRXZlbnQsIGRhdGE6IGFueSk6IHZvaWQge1xuXG4gICAgICAgIGlmICghdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmlzU2VsZWN0ZWQoZGF0YSkpIHtcbiAgICAgICAgICAgIC8vIGRlc2VsZWN0IGFsbCBvdGhlciBpdGVtc1xuICAgICAgICAgICAgdGhpcy5kZXNlbGVjdEFsbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWN0aXZhdGUgdGhlIGNsaWNrZWQgaXRlbVxuICAgICAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2UuYWN0aXZhdGUoZGF0YSk7XG5cbiAgICAgICAgLy8gdG9nZ2xlIHRoZSBzZWxlY3RlZCBzdGF0ZSBvZiB0aGUgaXRlbVxuICAgICAgICB0aGlzLnRvZ2dsZShkYXRhKTtcbiAgICB9XG5cbiAgICBrZXlkb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50LCBkYXRhOiBhbnkpOiB2b2lkIHtcblxuICAgICAgICBzd2l0Y2ggKGV2ZW50LndoaWNoKSB7XG5cbiAgICAgICAgICAgIGNhc2UgVVBfQVJST1c6IHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZS5hY3RpdmF0ZVNpYmxpbmcodHJ1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgRE9XTl9BUlJPVzoge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmFjdGl2YXRlU2libGluZyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhc2UgU1BBQ0U6XG4gICAgICAgICAgICBjYXNlIEVOVEVSOlxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGljayhudWxsLCBkYXRhKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxufSIsImltcG9ydCB7IEFmdGVyQ29udGVudEluaXQsIENvbXBvbmVudCwgQ29udGVudENoaWxkcmVuLCBFdmVudEVtaXR0ZXIsIElucHV0LCBPbkRlc3Ryb3ksIE91dHB1dCwgUXVlcnlMaXN0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzL1N1YnNjcmlwdGlvbic7XG5pbXBvcnQgeyBTZWxlY3Rpb25TZXJ2aWNlIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9zZWxlY3Rpb24vc2VsZWN0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgTXVsdGlwbGVTZWxlY3RMaXN0U3RyYXRlZ3kgfSBmcm9tICcuL211bHRpcGxlLXNlbGVjdC1saXN0LnN0cmF0ZWd5JztcbmltcG9ydCB7IFNlbGVjdExpc3RJdGVtQ29tcG9uZW50IH0gZnJvbSAnLi9zZWxlY3QtbGlzdC1pdGVtL3NlbGVjdC1saXN0LWl0ZW0uY29tcG9uZW50JztcbmltcG9ydCB7IFNpbmdsZVNlbGVjdExpc3RTdHJhdGVneSB9IGZyb20gJy4vc2luZ2xlLXNlbGVjdC1saXN0LnN0cmF0ZWd5JztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC1zZWxlY3QtbGlzdCcsXG4gICAgdGVtcGxhdGVVcmw6ICcuL3NlbGVjdC1saXN0LmNvbXBvbmVudC5odG1sJyxcbiAgICBwcm92aWRlcnM6IFtTZWxlY3Rpb25TZXJ2aWNlXSxcbiAgICBob3N0OiB7XG4gICAgICAgIHJvbGU6ICdsaXN0J1xuICAgIH1cbn0pXG5leHBvcnQgY2xhc3MgU2VsZWN0TGlzdENvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQsIE9uRGVzdHJveSB7XG5cbiAgICBASW5wdXQoKSBzZXQgbXVsdGlwbGUobXVsdGlwbGU6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5fc2VsZWN0aW9uLnN0cmF0ZWd5LmRlc2VsZWN0QWxsKCk7XG4gICAgICAgIHRoaXMuX3NlbGVjdGlvbi5zZXRTdHJhdGVneShtdWx0aXBsZSA/IG5ldyBNdWx0aXBsZVNlbGVjdExpc3RTdHJhdGVneSgpIDogbmV3IFNpbmdsZVNlbGVjdExpc3RTdHJhdGVneSgpKTtcbiAgICB9XG5cbiAgICBASW5wdXQoKSBzZWxlY3RlZDogYW55W10gPSBbXTtcbiAgICBAT3V0cHV0KCkgc2VsZWN0ZWRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGFueVtdPigpO1xuXG4gICAgQENvbnRlbnRDaGlsZHJlbihTZWxlY3RMaXN0SXRlbUNvbXBvbmVudCkgaXRlbXM6IFF1ZXJ5TGlzdDxTZWxlY3RMaXN0SXRlbUNvbXBvbmVudD47XG5cbiAgICBwcml2YXRlIF9zdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX3NlbGVjdGlvbjogU2VsZWN0aW9uU2VydmljZSkge1xuICAgICAgICAvLyBzZXQgdGhlIHNlbGVjdGlvbiBzdHJhdGVneSB0byBzaW5nbGUgYnkgZGVmYXVsdFxuICAgICAgICB0aGlzLl9zZWxlY3Rpb24uc2V0U3RyYXRlZ3kobmV3IFNpbmdsZVNlbGVjdExpc3RTdHJhdGVneSgpKTtcblxuICAgICAgICAvLyBlbWl0IHRoZSBzZWxlY3Rpb24gY2hhbmdlcyB3aGVuIHRoZXkgb2NjdXJcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gdGhpcy5fc2VsZWN0aW9uLnNlbGVjdGlvbiQuc3Vic2NyaWJlKHNlbGVjdGlvbiA9PiB0aGlzLnNlbGVjdGVkQ2hhbmdlLmVtaXQoc2VsZWN0aW9uKSk7XG4gICAgfVxuXG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCk6IHZvaWQge1xuXG4gICAgICAgIC8vIHN1cHBseSB0aGUgaW5pdGlhbCBpdGVtIHNldFxuICAgICAgICB0aGlzLl9zZWxlY3Rpb24uZGF0YXNldCA9IHRoaXMuaXRlbXMubWFwKGl0ZW0gPT4gaXRlbS5kYXRhKTtcblxuICAgICAgICAvLyBpZiB0aGUgaXRlbSBzZXQgY2hhbmdlcyB1cGRhdGUgdGhlIGxpc3RcbiAgICAgICAgdGhpcy5pdGVtcy5jaGFuZ2VzLnN1YnNjcmliZSgoKSA9PiB0aGlzLl9zZWxlY3Rpb24uZGF0YXNldCA9IHRoaXMuaXRlbXMubWFwKGl0ZW0gPT4gaXRlbS5kYXRhKSk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU2VsZWN0TGlzdEl0ZW1Db21wb25lbnQgfSBmcm9tICcuL3NlbGVjdC1saXN0LWl0ZW0vc2VsZWN0LWxpc3QtaXRlbS5jb21wb25lbnQnO1xuaW1wb3J0IHsgU2VsZWN0TGlzdENvbXBvbmVudCB9IGZyb20gJy4vc2VsZWN0LWxpc3QuY29tcG9uZW50JztcblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgU2VsZWN0TGlzdENvbXBvbmVudCxcbiAgICAgICAgU2VsZWN0TGlzdEl0ZW1Db21wb25lbnRcbiAgICBdLFxuICAgIGV4cG9ydHM6IFtcbiAgICAgICAgU2VsZWN0TGlzdENvbXBvbmVudCxcbiAgICAgICAgU2VsZWN0TGlzdEl0ZW1Db21wb25lbnRcbiAgICBdLFxufSlcbmV4cG9ydCBjbGFzcyBTZWxlY3RMaXN0TW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBIb3N0TGlzdGVuZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFNpZGVQYW5lbFNlcnZpY2UgfSBmcm9tICcuL3NpZGUtcGFuZWwuc2VydmljZSc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3V4U2lkZVBhbmVsQ2xvc2VdJ1xufSlcbmV4cG9ydCBjbGFzcyBTaWRlUGFuZWxDbG9zZURpcmVjdGl2ZSB7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9zZXJ2aWNlOiBTaWRlUGFuZWxTZXJ2aWNlKSB7IH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ2NsaWNrJylcbiAgICBjbGlja0hhbmRsZXIoKSB7XG4gICAgICAgIHRoaXMuX3NlcnZpY2UuY2xvc2UoKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgQTExeU1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9hMTF5JztcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRm9jdXNJZk1vZHVsZSB9IGZyb20gJy4uLy4uL2RpcmVjdGl2ZXMvZm9jdXMtaWYvZm9jdXMtaWYubW9kdWxlJztcbmltcG9ydCB7IFNpZGVQYW5lbENsb3NlRGlyZWN0aXZlIH0gZnJvbSAnLi9zaWRlLXBhbmVsLWNsb3NlLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBTaWRlUGFuZWxDb21wb25lbnQgfSBmcm9tICcuL3NpZGUtcGFuZWwuY29tcG9uZW50JztcblxuY29uc3QgRVhQT1JUUyA9IFtcbiAgICBTaWRlUGFuZWxDb21wb25lbnQsXG4gICAgU2lkZVBhbmVsQ2xvc2VEaXJlY3RpdmVcbl07XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIEExMXlNb2R1bGUsXG4gICAgICAgIEZvY3VzSWZNb2R1bGVcbiAgICBdLFxuICAgIGV4cG9ydHM6IEVYUE9SVFMsXG4gICAgZGVjbGFyYXRpb25zOiBFWFBPUlRTXG59KVxuZXhwb3J0IGNsYXNzIFNpZGVQYW5lbE1vZHVsZSB7IH0iLCJpbXBvcnQgeyBDb21wb25lbnQsIElucHV0LCBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29sb3JTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvY29sb3IvaW5kZXgnO1xuaW1wb3J0IHsgQ29sb3JJZGVudGlmaWVyIH0gZnJvbSAnLi4vLi4vaW5kZXgnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LXNwYXJrJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vc3BhcmsuY29tcG9uZW50Lmh0bWwnLFxuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG59KVxuZXhwb3J0IGNsYXNzIFNwYXJrQ29tcG9uZW50IHtcblxuICAgIHZhbHVlczogbnVtYmVyW10gPSBbXTtcblxuICAgIEBJbnB1dCgpIGJhckhlaWdodDogbnVtYmVyID0gMTA7XG4gICAgQElucHV0KCkgaW5saW5lTGFiZWw6IHN0cmluZztcbiAgICBASW5wdXQoKSB0b3BMZWZ0TGFiZWw6IHN0cmluZztcbiAgICBASW5wdXQoKSB0b3BSaWdodExhYmVsOiBzdHJpbmc7XG4gICAgQElucHV0KCkgYm90dG9tTGVmdExhYmVsOiBzdHJpbmc7XG4gICAgQElucHV0KCkgYm90dG9tUmlnaHRMYWJlbDogc3RyaW5nO1xuICAgIEBJbnB1dCgpIHRvb2x0aXA6IHN0cmluZztcblxuICAgIHByaXZhdGUgX3RyYWNrQ29sb3I6IHN0cmluZztcbiAgICBwcml2YXRlIF90aGVtZTogQ29sb3JJZGVudGlmaWVyID0gJ3ByaW1hcnknOyAgICBcbiAgICBwcml2YXRlIF9iYXJDb2xvcjogc3RyaW5nIHwgc3RyaW5nW10gPSBbXTtcbiAgICBcbiAgICBASW5wdXQoKSBcbiAgICBzZXQgdGhlbWUodmFsdWU6IHN0cmluZykge1xuICAgICAgICB0aGlzLl90aGVtZSA9IHRoaXMuX2NvbG9yU2VydmljZS5yZXNvbHZlQ29sb3JOYW1lKHZhbHVlKTtcbiAgICB9XG5cbiAgICBnZXQgdGhlbWUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RoZW1lO1xuICAgIH1cblxuICAgIEBJbnB1dCgpIFxuICAgIHNldCB0cmFja0NvbG9yKHZhbHVlOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5fdHJhY2tDb2xvciA9IHRoaXMuX2NvbG9yU2VydmljZS5yZXNvbHZlKHZhbHVlKTtcbiAgICB9XG5cbiAgICBnZXQgdHJhY2tDb2xvcigpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJhY2tDb2xvcjtcbiAgICB9XG5cbiAgICBASW5wdXQoKSBcbiAgICBzZXQgYmFyQ29sb3IodmFsdWU6IHN0cmluZyB8IHN0cmluZ1tdKSB7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLl9iYXJDb2xvciA9IHZhbHVlLm1hcChjb2xvciA9PiB0aGlzLl9jb2xvclNlcnZpY2UucmVzb2x2ZShjb2xvcikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fYmFyQ29sb3IgPSBbdGhpcy5fY29sb3JTZXJ2aWNlLnJlc29sdmUodmFsdWUpXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBiYXJDb2xvcigpOiBzdHJpbmcgfCBzdHJpbmdbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9iYXJDb2xvcjtcbiAgICB9XG5cbiAgICBASW5wdXQoKVxuICAgIHNldCB2YWx1ZSh2YWx1ZTogbnVtYmVyIHwgbnVtYmVyW10pIHtcblxuICAgICAgICAvLyBlbnN1cmUgJ3ZhbHVlJyBpcyBhbiBhcnJheSBhdCB0aGlzIHBvaW50XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdO1xuXG4gICAgICAgIC8vIGdldCB0aGUgdG90YWwgdmFsdWUgb2YgYWxsIGxpbmVzXG4gICAgICAgIGNvbnN0IHRvdGFsID0gTWF0aC5tYXgodmFsdWVzLnJlZHVjZSgocHJldmlvdXMsIGN1cnJlbnQpID0+IHByZXZpb3VzICsgY3VycmVudCwgMCksIDEwMCk7XG5cbiAgICAgICAgLy8gZmlndXJlIG91dCB0aGUgcGVyY2VudGFnZXMgZm9yIGVhY2ggc3BhcmsgbGluZVxuICAgICAgICB0aGlzLnZhbHVlcyA9IHZhbHVlcy5tYXAodmFsID0+ICh2YWwgLyB0b3RhbCkgKiAxMDApO1xuICAgIH1cblxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVzO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX2NvbG9yU2VydmljZTogQ29sb3JTZXJ2aWNlKSB7IH1cbn0iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcblxuaW1wb3J0IHsgU3BhcmtDb21wb25lbnQgfSBmcm9tICcuL3NwYXJrLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBDb2xvclNlcnZpY2VNb2R1bGUgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9jb2xvci9pbmRleCc7XG5pbXBvcnQgeyBUb29sdGlwTW9kdWxlIH0gZnJvbSAnLi4vdG9vbHRpcC9pbmRleCc7XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW1xuICAgICAgICBDb21tb25Nb2R1bGUsXG4gICAgICAgIENvbG9yU2VydmljZU1vZHVsZSxcbiAgICAgICAgVG9vbHRpcE1vZHVsZVxuICAgIF0sXG4gICAgZXhwb3J0czogW1NwYXJrQ29tcG9uZW50XSxcbiAgICBkZWNsYXJhdGlvbnM6IFtTcGFya0NvbXBvbmVudF1cbn0pXG5leHBvcnQgY2xhc3MgU3BhcmtNb2R1bGUgeyB9XG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBPbkRlc3Ryb3ksIFF1ZXJ5TGlzdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgUmVwbGF5U3ViamVjdCB9IGZyb20gJ3J4anMvUmVwbGF5U3ViamVjdCc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcbmltcG9ydCB7IFJlc2l6YWJsZVRhYmxlQ29sdW1uQ29tcG9uZW50IH0gZnJvbSAnLi9yZXNpemFibGUtdGFibGUtY29sdW1uLmNvbXBvbmVudCc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBSZXNpemFibGVUYWJsZVNlcnZpY2UgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuXG4gIC8qKiBkZXRlcm1pbmUgd2hldGhlciBvciBub3Qgd2UgYXJlIGN1cnJlbnRseSBzaXppbmcgKi9cbiAgcmVzaXppbmc6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAvKiogc3RvcmUgdGhlIHBlcmNlbnRhZ2Ugd2lkdGhzIG9mIGFsbCB0aGUgY29sdW1ucyAqL1xuICBzaXplcyA9IG5ldyBSZXBsYXlTdWJqZWN0PE1hcDxSZXNpemFibGVUYWJsZUNvbHVtbkNvbXBvbmVudCwgbnVtYmVyPj4oKTtcblxuICAvKiogc3RvcmUgdGhlIHRhYmxlIGVsZW1lbnRzIGZvciB1c2Ugd2hlbiBjYWxjdWxhdGluZyB3aWR0aHMgKi9cbiAgcHJpdmF0ZSBfdGFibGU6IEhUTUxUYWJsZUVsZW1lbnQ7XG5cbiAgLyoqIHN0b3JlIHRoZSBjb2x1bW4gY2xhc3NlcyAqL1xuICBwcml2YXRlIF9jb2x1bW5zOiBRdWVyeUxpc3Q8UmVzaXphYmxlVGFibGVDb2x1bW5Db21wb25lbnQ+O1xuXG4gIC8qKiBzdG9yZSB0aGUgY29sdW1uIHNpemVzIGFzIGFuIGFjY2Vzc2libGUgb2JqZWN0ICovXG4gIHByaXZhdGUgX3NpemVzID0gbmV3IE1hcDxSZXNpemFibGVUYWJsZUNvbHVtbkNvbXBvbmVudCwgbnVtYmVyPigpO1xuXG4gIC8qKiBBbiBvYnNlcnZhYmxlIHRvIHVuc3Vic2NyaWJlIG90aGVycyBhdXRvbWF0aWNhbGx5ICovXG4gIHByaXZhdGUgX29uRGVzdHJveSA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5fb25EZXN0cm95Lm5leHQoKTtcbiAgICB0aGlzLl9vbkRlc3Ryb3kuY29tcGxldGUoKTtcbiAgfVxuXG4gIC8qKiBhIHNldHRlciB0byBkZWZpbmUgdGhlIHRhYmxlIGVsZW1lbnQgKi9cbiAgc2V0VGFibGUodGFibGU6IEhUTUxUYWJsZUVsZW1lbnQpOiB2b2lkIHtcbiAgICB0aGlzLl90YWJsZSA9IHRhYmxlO1xuICB9XG5cbiAgLyoqIGEgc2V0dGVyIHRvIGRlZmluZSB0aGUgcXVlcnkgbGlzdCBvZiBjb2x1bW5zICovXG4gIHNldENvbHVtbnMoY29sdW1uczogUXVlcnlMaXN0PFJlc2l6YWJsZVRhYmxlQ29sdW1uQ29tcG9uZW50Pik6IHZvaWQge1xuICAgIC8vIHN0b3JlIGEgcmVmZXJlbmNlIHRvIHRoZSBjb2x1bW5zXG4gICAgdGhpcy5fY29sdW1ucyA9IGNvbHVtbnM7XG5cbiAgICAvLyBzZXQgdXAgdGhlIGluaXRpYWwgY29sdW1zIHNpemVzXG4gICAgdGhpcy5zZXRJbml0aWFsV2lkdGhzKCk7XG5cbiAgICAvLyBzdWJzY3JpYmUgdG8gZnV0dXJlIGNvbHVtbiBjaGFuZ2VzXG4gICAgdGhpcy5fY29sdW1ucy5jaGFuZ2VzLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZSgoKSA9PiB0aGlzLnNldEluaXRpYWxXaWR0aHMoKSk7XG4gIH1cblxuICAvKiogV2Ugd2FudCB0byBjb252ZXJ0IGFsbCB1bml0cyBzaXplcyB0byBwaXhlbHMgdG8gcHJldmVudCBicm93c2VyIGppdHRlciAqL1xuICBzdGFydFJlc2l6aW5nKCk6IHZvaWQge1xuICAgIHRoaXMucmVzaXppbmcgPSB0cnVlO1xuXG4gICAgLy8gY29udmVydCBhbGwgY3VycmVudCBwZXJjZW50YWdlcyBpbnRvIHBpeGVsIHZhbHVlc1xuICAgIHRoaXMuX3NpemVzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHRoaXMuX3NpemVzLnNldChrZXksICh0aGlzLl90YWJsZS5vZmZzZXRXaWR0aCAvIDEwMCkgKiB2YWx1ZSkpO1xuXG4gICAgLy8gZW1pdCB0aGUgbGF0ZXN0IHZhbHVlc1xuICAgIHRoaXMuc2l6ZXMubmV4dCh0aGlzLl9zaXplcyk7XG4gIH1cblxuICAvKiogUmVzdG9yZSB2YWx1ZXMgYmFjayB0byBwZXJjZW50YWdlIHZhbHVlcyAqL1xuICBlbmRSZXNpemluZygpOiB2b2lkIHtcbiAgICB0aGlzLnJlc2l6aW5nID0gZmFsc2U7XG5cbiAgICAvLyBjb252ZXJ0IGFsbCB2YWx1ZXMgYmFjayB0byBwZXJjZW50YWdlc1xuICAgIHRoaXMuX3NpemVzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHRoaXMuX3NpemVzLnNldChrZXksICh2YWx1ZSAvIHRoaXMuX3RhYmxlLm9mZnNldFdpZHRoKSAqIDEwMCkpO1xuXG4gICAgLy8gZW1pdCB0aGUgbGF0ZXN0IHZhbHVlc1xuICAgIHRoaXMuc2l6ZXMubmV4dCh0aGlzLl9zaXplcyk7XG4gIH1cblxuICAvKiogYXBwbHkgYSByZXNpemUgZXZlbnQgdG8gYSBjb2x1bW4gKi9cbiAgcmVzaXplQ29sdW1uKGNvbHVtbjogUmVzaXphYmxlVGFibGVDb2x1bW5Db21wb25lbnQsIHZhbHVlOiBudW1iZXIpOiB2b2lkIHtcblxuICAgIC8vIGdldCB0aGUgc2libGluZyBjb2x1bW4gdGhhdCB3aWxsIGFsc28gYmUgcmVzaXplZFxuICAgIGNvbnN0IHNpYmxpbmcgPSB0aGlzLmdldFNpYmxpbmdDb2x1bW4oY29sdW1uKTtcblxuICAgIC8vIGlmIHRoZXJlIGlzIG5vIHNpYmxpbmcgdGhhdCBjYW4gYmUgcmVzaXplZCB0aGVuIHN0b3AgaGVyZVxuICAgIGlmICghc2libGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGNyZWF0ZSBhIG5ldyBvYmplY3QgZm9yIHRoZSBzaXplc1xuICAgIGNvbnN0IHNpemVzID0gbmV3IE1hcCh0aGlzLl9zaXplcyk7XG5cbiAgICAvLyByZXNpemUgdGhlIGNvbHVtbiB0byB0aGUgZGVzaXJlZCBzaXplXG4gICAgdGhpcy5zZXRDb2x1bW5XaWR0aChjb2x1bW4sIHRoaXMuZ2V0Q29sdW1uV2lkdGgoY29sdW1uKSArIE1hdGgucm91bmQodmFsdWUpLCBzaXplcyk7XG4gICAgdGhpcy5zZXRDb2x1bW5XaWR0aChzaWJsaW5nLCB0aGlzLmdldENvbHVtbldpZHRoKHNpYmxpbmcpIC0gTWF0aC5yb3VuZCh2YWx1ZSksIHNpemVzKTtcblxuICAgIC8vIGlmIHRoZSBtb3ZlIGlzIG5vdCBwb3NzaWJsZSB0aGVuIHN0b3AgaGVyZVxuICAgIGlmICghdGhpcy5pc1dpZHRoVmFsaWQoY29sdW1uLCB0aGlzLmdldENvbHVtbldpZHRoKGNvbHVtbiwgc2l6ZXMpKSB8fCAhdGhpcy5pc1dpZHRoVmFsaWQoc2libGluZywgdGhpcy5nZXRDb2x1bW5XaWR0aChzaWJsaW5nLCBzaXplcykpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gZW5zdXJlIHRoYXQgdGhlIGNvbHVtbiB3aWR0aHMgdG90YWwgZXhhY3RseSAxMDAlXG4gICAgdGhpcy52ZXJpZnlDb2x1bW5XaWR0aHMoc2libGluZywgc2l6ZXMpO1xuXG4gICAgLy8gc3RvcmUgdGhlIG5ldyBzaXplc1xuICAgIHRoaXMuX3NpemVzID0gc2l6ZXM7XG5cbiAgICAvLyBlbWl0IHRoZSBsYXRlc3Qgc2l6ZSB2YWx1ZXNcbiAgICB0aGlzLnNpemVzLm5leHQodGhpcy5fc2l6ZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByaXZhdGUgTWV0aG9kc1xuICAgKi9cblxuICAvKiogaW5pdGlhbGx5IGNvbnZlcnQgdGhlIGRlZmF1bHQgcGl4ZWwgd2lkdGhzIG9mIGVhY2ggY29sdW1uIHRvIHBlcmNlbnRhZ2VzICovXG4gIHByaXZhdGUgc2V0SW5pdGlhbFdpZHRocygpOiB2b2lkIHtcbiAgICAvLyBnZXQgdGhlIHRhYmxlIHdpZHRoIHNvIHdlIGRvbid0IGhhdmUgdG8ga2VlcCBhY2Nlc3NpbmcgdGhlIGRvbVxuICAgIGNvbnN0IHdpZHRoID0gdGhpcy5fdGFibGUub2Zmc2V0V2lkdGg7XG5cbiAgICAvLyBjcmVhdGUgYSBuZXcgb2JqZWN0IGNvbnRhaW5pbmcgYWxsIGNvbHVtbiB3aWR0aHNcbiAgICB0aGlzLl9zaXplcyA9IG5ldyBNYXAoKTtcblxuICAgIC8vIGNhbGN1bGF0ZSB0aGUgcGVyY2VudGFnZSBzaXplIG9mIGVhY2ggY29sdW1uXG4gICAgdGhpcy5fY29sdW1ucy5mb3JFYWNoKGNvbHVtbiA9PlxuICAgICAgdGhpcy5zZXRDb2x1bW5XaWR0aChjb2x1bW4sICgoY29sdW1uLmdldENvbHVtbldpZHRoKCkgLyB3aWR0aCkgKiAxMDApKVxuICAgICk7XG5cbiAgICAvLyBlbWl0IHRoZSBsYXRlc3QgY29sdW1uIHNpemVzXG4gICAgdGhpcy5zaXplcy5uZXh0KHRoaXMuX3NpemVzKTtcbiAgfVxuXG4gIC8qKiBHZXQgdGhlIHBlcmNlbnRhZ2Ugd2lkdGggb2YgYSBzcGVjaWZpYyBjb2x1bW4gKi9cbiAgcHJpdmF0ZSBnZXRDb2x1bW5XaWR0aChjb2x1bW46IFJlc2l6YWJsZVRhYmxlQ29sdW1uQ29tcG9uZW50LCBzaXplczogTWFwPFJlc2l6YWJsZVRhYmxlQ29sdW1uQ29tcG9uZW50LCBudW1iZXI+ID0gdGhpcy5fc2l6ZXMpOiBudW1iZXIge1xuICAgIHJldHVybiBzaXplcy5nZXQoY29sdW1uKTtcbiAgfVxuXG4gIC8qKiBTZXQgdGhlIHBlcmNlbnRhZ2Ugd2lkdGggZm9yIGEgc3BlY2lmaWMgY29sdW1uICovXG4gIHByaXZhdGUgc2V0Q29sdW1uV2lkdGgoY29sdW1uOiBSZXNpemFibGVUYWJsZUNvbHVtbkNvbXBvbmVudCwgd2lkdGg6IG51bWJlciwgc2l6ZXM6IE1hcDxSZXNpemFibGVUYWJsZUNvbHVtbkNvbXBvbmVudCwgbnVtYmVyPiA9IHRoaXMuX3NpemVzKTogdm9pZCB7XG4gICAgc2l6ZXMuc2V0KGNvbHVtbiwgd2lkdGgpO1xuICB9XG5cbiAgLyoqIERldGVybWluZSB3aGV0aGVyIGEgY29sdW1uIGlzIGFib3ZlIG9yIGJlbG93IGl0cyBtaW5pbXVtIHdpZHRoICovXG4gIHByaXZhdGUgaXNXaWR0aFZhbGlkKGNvbHVtbjogUmVzaXphYmxlVGFibGVDb2x1bW5Db21wb25lbnQsIHdpZHRoOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICByZXR1cm4gd2lkdGggPj0gY29sdW1uLm1pbldpZHRoO1xuICB9XG5cbiAgLyoqIEVuc3VyZSB0aGF0IHRoZSB0b3RhbCBjb2x1bW4gd2lkdGhzIGlzIGV4YWN0bHkgMTAwJSAqL1xuICBwcml2YXRlIHZlcmlmeUNvbHVtbldpZHRocyhhZGp1c3RhYmxlQ29sdW1uOiBSZXNpemFibGVUYWJsZUNvbHVtbkNvbXBvbmVudCwgc2l6ZXM6IE1hcDxSZXNpemFibGVUYWJsZUNvbHVtbkNvbXBvbmVudCwgbnVtYmVyPiA9IHRoaXMuX3NpemVzKTogdm9pZCB7XG5cbiAgICAvLyBnZXQgdGhlIHRvdGFsIHdpZHRocyBvZiBhbGwgY29sdW1ucyBjb21iaW5lZFxuICAgIGNvbnN0IHdpZHRoID0gQXJyYXkuZnJvbShzaXplcy52YWx1ZXMoKSkucmVkdWNlKCh0b3RhbCwgY29sdW1uKSA9PiBjb2x1bW4gKyB0b3RhbCwgMCk7XG5cbiAgICAvLyBpZiB0aGUgd2lkdGggZG9lcyBub3QgdG90YWwgMTAwJSBleGFjdGx5IHRoZW4gYWRqdXN0IHRoZSBjb2x1bW4gd2lkdGhcbiAgICBpZiAod2lkdGggIT09IHRoaXMuX3RhYmxlLm9mZnNldFdpZHRoKSB7XG4gICAgICB0aGlzLnNldENvbHVtbldpZHRoKGFkanVzdGFibGVDb2x1bW4sIHRoaXMuZ2V0Q29sdW1uV2lkdGgoYWRqdXN0YWJsZUNvbHVtbiwgc2l6ZXMpICsgKHRoaXMuX3RhYmxlLm9mZnNldFdpZHRoIC0gd2lkdGgpLCBzaXplcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEdldCBhIGNvbHVtbiBhdCBhIGdpdmVuIGluZGV4ICovXG4gIHByaXZhdGUgZ2V0Q29sdW1uQXRJbmRleChpbmRleDogbnVtYmVyKTogUmVzaXphYmxlVGFibGVDb2x1bW5Db21wb25lbnQgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLl9jb2x1bW5zLnRvQXJyYXkoKVtpbmRleF07XG4gIH1cblxuICAvKiogR2V0IHRoZSBuZXh0IGNvbHVtbiBpbiB0aGUgc2VxdWVuY2Ugb2YgY29sdW1ucyAqL1xuICBwcml2YXRlIGdldFNpYmxpbmdDb2x1bW4oY29sdW1uOiBSZXNpemFibGVUYWJsZUNvbHVtbkNvbXBvbmVudCk6IFJlc2l6YWJsZVRhYmxlQ29sdW1uQ29tcG9uZW50IHwgbnVsbCB7XG4gICAgLy8gZ2V0IHRoZSBpbmRleCBvZiB0aGlzIGNvbHVtblxuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fY29sdW1ucy50b0FycmF5KCkuaW5kZXhPZihjb2x1bW4pO1xuXG4gICAgLy8gZmluZCB0aGUgZmlyc3Qgc2libGluZyB0aGF0IGlzIG5vdCBkaXNhYmxlZFxuICAgIGZvciAobGV0IGlkeCA9IGluZGV4ICsgMTsgaWR4IDwgdGhpcy5fY29sdW1ucy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICBjb25zdCBzaWJsaW5nID0gdGhpcy5nZXRDb2x1bW5BdEluZGV4KGlkeCk7XG5cbiAgICAgIGlmICghc2libGluZy5kaXNhYmxlZCkge1xuICAgICAgICByZXR1cm4gc2libGluZztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufSIsImltcG9ydCB7IENvbXBvbmVudCwgRWxlbWVudFJlZiwgSG9zdEJpbmRpbmcsIElucHV0LCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGRpc3RpbmN0VW50aWxDaGFuZ2VkLCBtYXAsIHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzL1N1YmplY3QnO1xuaW1wb3J0IHsgdGljayB9IGZyb20gJy4uLy4uLy4uL2NvbW1vbi9pbmRleCc7XG5pbXBvcnQgeyBSZXNpemFibGVUYWJsZVNlcnZpY2UgfSBmcm9tICcuL3Jlc2l6YWJsZS10YWJsZS5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnW3V4UmVzaXphYmxlVGFibGVDb2x1bW5dJyxcbiAgdGVtcGxhdGVVcmw6ICcuL3Jlc2l6YWJsZS10YWJsZS1jb2x1bW4uY29tcG9uZW50Lmh0bWwnLFxuICBob3N0OiB7XG4gICAgY2xhc3M6ICd1eC1yZXNpemFibGUtdGFibGUtY29sdW1uJ1xuICB9XG59KVxuZXhwb3J0IGNsYXNzIFJlc2l6YWJsZVRhYmxlQ29sdW1uQ29tcG9uZW50IGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICBASW5wdXQoKSBkaXNhYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIC8qKiBUaGUgcGVyY2VudGFnZSB3aWR0aCBvZiB0aGUgY29sdW1uICovXG4gIEBIb3N0QmluZGluZygnc3R5bGUud2lkdGgnKSBnZXQgd2lkdGgoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy50YWJsZS5yZXNpemluZyA/IGAke3RoaXMuX3dpZHRofXB4YCA6IGAke3RoaXMuX3dpZHRofSVgO1xuICB9XG5cbiAgZ2V0IG1pbldpZHRoKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIHRoaXMuZGlzYWJsZWQgPyB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGggOiBwYXJzZUZsb2F0KGdldENvbXB1dGVkU3R5bGUodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50KS5taW5XaWR0aCk7XG4gIH1cblxuICBwcml2YXRlIF93aWR0aDogbnVtYmVyO1xuXG4gIC8qKiBFbnN1cmUgb2JzZXJ2YWJsZXMgZ2V0IGRlc3Ryb3llZCBjb3JyZWN0bHkgKi9cbiAgcHJpdmF0ZSBfb25EZXN0cm95ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgdGFibGU6IFJlc2l6YWJsZVRhYmxlU2VydmljZSwgcHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZikgeyB9XG5cbiAgZ2V0Q29sdW1uV2lkdGgoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoO1xuICB9XG5cbiAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgdGhpcy50YWJsZS5zaXplcy5waXBlKFxuICAgICAgbWFwKHNpemVzID0+IHNpemVzLmdldCh0aGlzKSksXG4gICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpLFxuICAgICAgdGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSksXG4gICAgICB0aWNrKCkgLy8gcHJldmVudHMgZXhwcmVzc2lvbiBoYXMgY2hhbmdlZCBlcnJvclxuICAgICkuc3Vic2NyaWJlKCh3aWR0aDogbnVtYmVyKSA9PiB0aGlzLl93aWR0aCA9IHdpZHRoKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMuX29uRGVzdHJveS5uZXh0KCk7XG4gICAgdGhpcy5fb25EZXN0cm95LmNvbXBsZXRlKCk7XG4gIH1cblxuICBkcmFnc3RhcnQoKTogdm9pZCB7XG4gICAgdGhpcy50YWJsZS5zdGFydFJlc2l6aW5nKCk7XG4gIH1cblxuICBkcmFnKGV2ZW50OiBNb3VzZUV2ZW50LCBoYW5kbGU6IEhUTUxEaXZFbGVtZW50KTogdm9pZCB7XG5cbiAgICAvLyBnZXQgdGhlIGN1cnJlbnQgbW91c2UgcG9zaXRpb25cbiAgICBjb25zdCBtb3VzZVggPSBldmVudC5wYWdlWCAtIHBhZ2VYT2Zmc2V0O1xuXG4gICAgLy8gcG9zaXRpb24gb2YgdGhlIGRyYWcgaGFuZGxlXG4gICAgY29uc3QgeyBsZWZ0LCB3aWR0aCB9ID0gaGFuZGxlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgLy8gZGV0ZXJtaW5lIGhvdyBtdWNoIHRoZSBtb3VzZSBoYXMgbW92ZWQgc2luY2UgdGhlIGxhc3QgdXBkYXRlXG4gICAgY29uc3QgbW92ZW1lbnQgPSBtb3VzZVggLSAobGVmdCArICh3aWR0aCAvIDIpKTtcblxuICAgIC8vIHBlcmZvcm0gcmVzaXppbmdcbiAgICB0aGlzLnRhYmxlLnJlc2l6ZUNvbHVtbih0aGlzLCBtb3ZlbWVudCk7XG4gIH1cblxuICBkcmFnZW5kKCk6IHZvaWQge1xuICAgIHRoaXMudGFibGUuZW5kUmVzaXppbmcoKTtcbiAgfVxuXG59IiwiaW1wb3J0IHsgQWZ0ZXJWaWV3SW5pdCwgQ29udGVudENoaWxkcmVuLCBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIFF1ZXJ5TGlzdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUmVzaXphYmxlVGFibGVDb2x1bW5Db21wb25lbnQgfSBmcm9tICcuL3Jlc2l6YWJsZS10YWJsZS1jb2x1bW4uY29tcG9uZW50JztcbmltcG9ydCB7IFJlc2l6YWJsZVRhYmxlU2VydmljZSB9IGZyb20gJy4vcmVzaXphYmxlLXRhYmxlLnNlcnZpY2UnO1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbdXhSZXNpemFibGVUYWJsZV0nLFxuICBwcm92aWRlcnM6IFtSZXNpemFibGVUYWJsZVNlcnZpY2VdLFxuICBob3N0OiB7XG4gICAgY2xhc3M6ICd1eC1yZXNpemFibGUtdGFibGUnXG4gIH1cbn0pXG5leHBvcnQgY2xhc3MgUmVzaXphYmxlVGFibGVEaXJlY3RpdmUgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0IHtcblxuICBAQ29udGVudENoaWxkcmVuKFJlc2l6YWJsZVRhYmxlQ29sdW1uQ29tcG9uZW50KSBjb2x1bW5zOiBRdWVyeUxpc3Q8UmVzaXphYmxlVGFibGVDb2x1bW5Db21wb25lbnQ+O1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIHByaXZhdGUgX3RhYmxlOiBSZXNpemFibGVUYWJsZVNlcnZpY2UpIHsgfVxuXG4gIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkIHtcbiAgICB0aGlzLl90YWJsZS5zZXRUYWJsZSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpO1xuICAgIHRoaXMuX3RhYmxlLnNldENvbHVtbnModGhpcy5jb2x1bW5zKTtcbiAgfVxufSIsImltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRHJhZ01vZHVsZSB9IGZyb20gJy4uLy4uL2RpcmVjdGl2ZXMvZHJhZy9pbmRleCc7XG5pbXBvcnQgeyBSZXNpemFibGVUYWJsZUNvbHVtbkNvbXBvbmVudCB9IGZyb20gJy4vdGFibGUtY29sdW1uLXJlc2l6ZS9yZXNpemFibGUtdGFibGUtY29sdW1uLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBSZXNpemFibGVUYWJsZURpcmVjdGl2ZSB9IGZyb20gJy4vdGFibGUtY29sdW1uLXJlc2l6ZS9yZXNpemFibGUtdGFibGUuZGlyZWN0aXZlJztcblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZSxcbiAgICAgICAgRHJhZ01vZHVsZVxuICAgIF0sXG4gICAgZGVjbGFyYXRpb25zOiBbXG4gICAgICAgIFJlc2l6YWJsZVRhYmxlRGlyZWN0aXZlLFxuICAgICAgICBSZXNpemFibGVUYWJsZUNvbHVtbkNvbXBvbmVudFxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBSZXNpemFibGVUYWJsZURpcmVjdGl2ZSxcbiAgICAgICAgUmVzaXphYmxlVGFibGVDb2x1bW5Db21wb25lbnRcbiAgICBdXG59KVxuZXhwb3J0IGNsYXNzIFRhYmxlTW9kdWxlIHt9IiwiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcy9CZWhhdmlvclN1YmplY3QnO1xuaW1wb3J0IHsgVGFiQ29tcG9uZW50IH0gZnJvbSAnLi90YWIvdGFiLmNvbXBvbmVudCc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBUYWJzZXRTZXJ2aWNlIHtcblxuICAgIHRhYnMkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxUYWJDb21wb25lbnRbXT4oW10pO1xuICAgIGFjdGl2ZSQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PFRhYkNvbXBvbmVudD4obnVsbCk7XG4gICAgZm9jdXNlZCQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+KGZhbHNlKTtcbiAgICBoaWdobGlnaHRlZCQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PFRhYkNvbXBvbmVudD4obnVsbCk7XG5cbiAgICBhZGQodGFiOiBUYWJDb21wb25lbnQpOiB2b2lkIHtcbiAgICAgICAgdGhpcy50YWJzJC5uZXh0KFsuLi50aGlzLnRhYnMkLnZhbHVlLCB0YWJdKTtcblxuICAgICAgICAvLyBjaGVjayBpZiB0aGlzIGlzIHRoZSBvbmx5IHRhYi4gSWYgc28gc2VsZWN0IHRoaXMgYnkgZGVmYXVsdFxuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlJC52YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3QodGFiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbW92ZSh0YWI6IFRhYkNvbXBvbmVudCk6IHZvaWQge1xuXG4gICAgICAgIC8vIHJlbW92ZSB0aGUgdGFiXG4gICAgICAgIHRoaXMudGFicyQubmV4dCh0aGlzLnRhYnMkLnZhbHVlLmZpbHRlcihfdGFiID0+IF90YWIgIT09IHRhYikpO1xuICAgIH1cblxuICAgIHNlbGVjdCh0YWI6IFRhYkNvbXBvbmVudCk6IHZvaWQge1xuICAgICAgICBpZiAoIXRhYi5kaXNhYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmUkLm5leHQodGFiKTtcbiAgICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWQkLm5leHQodGFiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNlbGVjdEF0SW5kZXgoaW5kZXg6IG51bWJlcik6IHZvaWQge1xuXG4gICAgICAgIC8vIGlmIHRoZXJlIGFyZSBubyB0YWJzIHRoZW4gZG8gbm90aGluZ1xuICAgICAgICBpZiAodGhpcy50YWJzJC52YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZSBpbmRleCBpcyB3aXRoaW4gdGhlIGJvdW5kc1xuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RBdEluZGV4KHRoaXMudGFicyQudmFsdWUubGVuZ3RoIC0gMSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPj0gdGhpcy50YWJzJC52YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbGVjdEF0SW5kZXgoMCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLnRhYnMkLnZhbHVlW2luZGV4XTtcblxuICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdCh0YXJnZXQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2VsZWN0TmV4dFRhYigpOiB2b2lkIHtcbiAgICAgICAgLy8gZmluZCB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGluZGV4XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy50YWJzJC52YWx1ZS5pbmRleE9mKHRoaXMuYWN0aXZlJC52YWx1ZSk7XG5cbiAgICAgICAgLy8gY2hlY2sgdGhlIHRhYnMgYWZ0ZXIgdGhlIGFjdGl2ZSBvbmUgdG8gc2VlIGlmIHRoZXJlIGFyZSBhbnkgc2VsZWN0YWJsZSB0YWJzXG4gICAgICAgIGNvbnN0IHRhYnMgPSB0aGlzLnRhYnMkLnZhbHVlLnNsaWNlKGluZGV4ICsgMSk7XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgYW55IG9mIHRoZSB0YWJzIGFyZSBub3QgZGlzYWJsZWRcbiAgICAgICAgZm9yIChsZXQgdGFiIG9mIHRhYnMpIHtcbiAgICAgICAgICAgIGlmICghdGFiLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0KHRhYik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB3ZSByZWFjaCBoZXJlIHRoZW4gbm8gdGFiIGNvdWxkIGJlIHNlbGVjdGVkIC0gc2VsZWN0IHRoZSBmaXJzdCB0YWJcbiAgICAgICAgdGhpcy5zZWxlY3RGaXJzdFRhYigpO1xuICAgIH1cblxuICAgIHNlbGVjdFByZXZpb3VzVGFiKCk6IHZvaWQge1xuICAgICAgICAvLyBmaW5kIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgaW5kZXhcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLnRhYnMkLnZhbHVlLmluZGV4T2YodGhpcy5hY3RpdmUkLnZhbHVlKTtcblxuICAgICAgICAvLyBjaGVjayB0aGUgdGFicyBiZWZvcmUgdGhlIGFjdGl2ZSBvbmUgdG8gc2VlIGlmIHRoZXJlIGFyZSBhbnkgc2VsZWN0YWJsZSB0YWJzXG4gICAgICAgIGNvbnN0IHRhYnMgPSB0aGlzLnRhYnMkLnZhbHVlLnNsaWNlKDAsIGluZGV4KTtcblxuICAgICAgICAvLyBjaGVjayBpZiBhbnkgb2YgdGhlIHRhYnMgYXJlIG5vdCBkaXNhYmxlZFxuICAgICAgICBmb3IgKGxldCB0YWIgb2YgdGFicy5yZXZlcnNlKCkpIHtcbiAgICAgICAgICAgIGlmICghdGFiLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0KHRhYik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB3ZSByZWFjaCBoZXJlIHRoZW4gbm8gcHJldmlvdXMgdGFiIGNvdWxkIGJlIHNlbGVjdGVkIC0gc2VsZWN0IHRoZSBsYXN0IHRhYlxuICAgICAgICB0aGlzLnNlbGVjdExhc3RUYWIoKTtcbiAgICB9XG5cbiAgICBzZWxlY3RGaXJzdFRhYigpOiB2b2lkIHtcbiAgICAgICAgLy8gZmluZCB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IG5vbi1kaXNhYmxlZCB0YWJcbiAgICAgICAgY29uc3QgdGFiSW5kZXggPSB0aGlzLnRhYnMkLnZhbHVlLmZpbmRJbmRleCh0YWIgPT4gIXRhYi5kaXNhYmxlZCk7XG5cbiAgICAgICAgaWYgKHRhYkluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RBdEluZGV4KHRhYkluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNlbGVjdExhc3RUYWIoKTogdm9pZCB7XG4gICAgICAgIC8vIGZpbmQgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBub24tZGlzYWJsZWQgdGFiXG4gICAgICAgIGNvbnN0IHRhYkluZGV4ID0gdGhpcy50YWJzJC52YWx1ZS5zbGljZSgpLnJldmVyc2UoKS5maW5kSW5kZXgodGFiID0+ICF0YWIuZGlzYWJsZWQpO1xuXG4gICAgICAgIGlmICh0YWJJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0QXRJbmRleCgodGhpcy50YWJzJC52YWx1ZS5sZW5ndGggLSAxKSAtIHRhYkluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbn0gIiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbnB1dCwgT25EZXN0cm95LCBPbkluaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IGZpbHRlciB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFRhYnNldFNlcnZpY2UgfSBmcm9tICcuLi90YWJzZXQuc2VydmljZSc7XG5pbXBvcnQgeyBUYWJDb21wb25lbnQgfSBmcm9tICcuL3RhYi5jb21wb25lbnQnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1t1eFRhYkZvY3VzXSdcbn0pXG5leHBvcnQgY2xhc3MgVGFiRm9jdXNEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG5cbiAgICBASW5wdXQoKSB1eFRhYkZvY3VzOiBUYWJDb21wb25lbnQ7XG5cbiAgICBwcml2YXRlIF9zdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX3RhYnNldDogVGFic2V0U2VydmljZSwgcHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZikgeyB9XG5cbiAgICBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gdGhpcy5fdGFic2V0LmhpZ2hsaWdodGVkJC5waXBlKFxuICAgICAgICAgICAgZmlsdGVyKCgpID0+IHRoaXMuX3RhYnNldC5mb2N1c2VkJC52YWx1ZSA9PT0gdHJ1ZSksXG4gICAgICAgICAgICBmaWx0ZXIoKCkgPT4gdGhpcy5fdGFic2V0LmhpZ2hsaWdodGVkJC52YWx1ZSA9PT0gdGhpcy51eFRhYkZvY3VzKSxcbiAgICAgICAgKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmZvY3VzKCkpO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT25EZXN0cm95LCBPdXRwdXQsIFRlbXBsYXRlUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcy9PYnNlcnZhYmxlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcbmltcG9ydCB7IG1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFRhYnNldFNlcnZpY2UgfSBmcm9tICcuLi90YWJzZXQuc2VydmljZSc7XG5cbmxldCB1bmlxdWVUYWJJZCA9IDA7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtdGFiJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vdGFiLmNvbXBvbmVudC5odG1sJyxcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxufSlcbmV4cG9ydCBjbGFzcyBUYWJDb21wb25lbnQgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuXG4gICAgQElucHV0KCkgaWQ6IHN0cmluZyA9IGB1eC10YWItJHsrK3VuaXF1ZVRhYklkfWA7XG4gICAgQElucHV0KCkgZGlzYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBASW5wdXQoKSBoZWFkaW5nOiBzdHJpbmc7XG4gICAgQElucHV0KCkgY3VzdG9tQ2xhc3M6IHN0cmluZztcblxuICAgIEBPdXRwdXQoKSBzZWxlY3QgPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG4gICAgQE91dHB1dCgpIGRlc2VsZWN0ID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuXG4gICAgQElucHV0KCkgc2V0IGFjdGl2ZSh2YWx1ZTogYm9vbGVhbikge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3RhYnNldC5zZWxlY3QodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBoZWFkaW5nUmVmOiBUZW1wbGF0ZVJlZjxhbnk+O1xuICAgIGFjdGl2ZSQ6IE9ic2VydmFibGU8Ym9vbGVhbj4gPSB0aGlzLl90YWJzZXQuYWN0aXZlJC5waXBlKG1hcChhY3RpdmUgPT4gYWN0aXZlID09PSB0aGlzKSk7XG5cbiAgICBwcml2YXRlIF9zdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX3RhYnNldDogVGFic2V0U2VydmljZSkge1xuICAgICAgICBfdGFic2V0LmFkZCh0aGlzKTtcblxuICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24gPSB0aGlzLmFjdGl2ZSQuc3Vic2NyaWJlKGFjdGl2ZSA9PiBhY3RpdmUgPyB0aGlzLnNlbGVjdC5lbWl0KCkgOiB0aGlzLmRlc2VsZWN0LmVtaXQoKSk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3RhYnNldC5yZW1vdmUodGhpcyk7XG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cblxufSIsImltcG9ydCB7IERpcmVjdGl2ZSwgVGVtcGxhdGVSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFRhYkNvbXBvbmVudCB9IGZyb20gJy4vdGFiLmNvbXBvbmVudCc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3V4VGFiSGVhZGluZ10nXG59KVxuZXhwb3J0IGNsYXNzIFRhYkhlYWRpbmdEaXJlY3RpdmUge1xuXG4gICAgY29uc3RydWN0b3IodGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPGFueT4sIHRhYjogVGFiQ29tcG9uZW50KSB7XG4gICAgICAgIHRhYi5oZWFkaW5nUmVmID0gdGVtcGxhdGVSZWY7XG4gICAgfVxuXG59IiwiaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENvbXBvbmVudCwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFRhYkNvbXBvbmVudCB9IGZyb20gJy4vdGFiL3RhYi5jb21wb25lbnQnO1xuaW1wb3J0IHsgVGFic2V0U2VydmljZSB9IGZyb20gJy4vdGFic2V0LnNlcnZpY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3V4LXRhYnNldCcsXG4gICAgdGVtcGxhdGVVcmw6ICcuL3RhYnNldC5jb21wb25lbnQuaHRtbCcsXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgcHJvdmlkZXJzOiBbVGFic2V0U2VydmljZV0sXG4gICAgaG9zdDoge1xuICAgICAgICAnW2NsYXNzLnRhYnMtbGVmdF0nOiAnc3RhY2tlZCA9PT0gXCJsZWZ0XCInLFxuICAgICAgICAnW2NsYXNzLnRhYnMtcmlnaHRdJzogJ3N0YWNrZWQgPT09IFwicmlnaHRcIicsXG4gICAgfVxufSlcbmV4cG9ydCBjbGFzcyBUYWJzZXRDb21wb25lbnQge1xuXG4gICAgQElucHV0KCkgbWluaW1hbDogYm9vbGVhbiA9IHRydWU7XG4gICAgQElucHV0KCkgc3RhY2tlZDogJ2xlZnQnIHwgJ3JpZ2h0JyB8ICdub25lJyA9ICdub25lJztcbiAgICBASW5wdXQoJ2FyaWEtbGFiZWwnKSBhcmlhTGFiZWw6IHN0cmluZztcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyB0YWJzZXQ6IFRhYnNldFNlcnZpY2UpIHsgfVxuXG4gICAgLyoqXG4gICAgICogQWxsb3cgbWFudWFsIHRhYiBzZWxlY3RlZFxuICAgICAqL1xuICAgIHNlbGVjdCh0YWI6IFRhYkNvbXBvbmVudCk6IHZvaWQge1xuICAgICAgICB0aGlzLnRhYnNldC5zZWxlY3QodGFiKTtcbiAgICB9XG5cbiAgICBzZWxlY3RQcmV2aW91c1RhYihldmVudDogS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGRldGVybWluZSB3aGljaCBhcnJvdyBrZXkgaXMgcHJlc3NlZFxuICAgICAgICBjb25zdCBhcnJvd0xlZnQgPSBldmVudC5rZXkgPT09ICdBcnJvd0xlZnQnIHx8IGV2ZW50LmtleUNvZGUgPT09IDM3O1xuICAgICAgICBjb25zdCBhcnJvd1VwID0gZXZlbnQua2V5ID09PSAnQXJyb3dVcCcgfHwgZXZlbnQua2V5Q29kZSA9PT0gMzg7XG5cbiAgICAgICAgLy8gb25seSBwZXJmb3JtIGFjdGlvbiBpZiB0aGUgYXJyb3cga2V5IG1hdGNoZXMgdGhlIG9yaWVudGF0aW9uXG4gICAgICAgIGlmIChhcnJvd0xlZnQgJiYgdGhpcy5zdGFja2VkICE9PSAnbm9uZScgfHwgYXJyb3dVcCAmJiB0aGlzLnN0YWNrZWQgPT09ICdub25lJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcGVyZm9ybSBzZWxlY3Rpb25cbiAgICAgICAgdGhpcy50YWJzZXQuc2VsZWN0UHJldmlvdXNUYWIoKTtcblxuICAgICAgICAvLyBwcmV2ZW50IHRoZSBicm93c2VyIGZyb20gc2Nyb2xsaW5nIHdoZW4gYXJyb3cga2V5cyBhcmUgcHJlc3NlZFxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cblxuICAgIHNlbGVjdE5leHRUYWIoZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcblxuICAgICAgICAvLyBkZXRlcm1pbmUgd2hpY2ggYXJyb3cga2V5IGlzIHByZXNzZWRcbiAgICAgICAgY29uc3QgYXJyb3dSaWdodCA9IGV2ZW50LmtleSA9PT0gJ0Fycm93UmlnaHQnIHx8IGV2ZW50LmtleUNvZGUgPT09IDM5O1xuICAgICAgICBjb25zdCBhcnJvd0Rvd24gPSBldmVudC5rZXkgPT09ICdBcnJvd0Rvd24nIHx8IGV2ZW50LmtleUNvZGUgPT09IDQwO1xuXG4gICAgICAgIC8vIG9ubHkgcGVyZm9ybSBhY3Rpb24gaWYgdGhlIGFycm93IGtleSBtYXRjaGVzIHRoZSBvcmllbnRhdGlvblxuICAgICAgICBpZiAoYXJyb3dSaWdodCAmJiB0aGlzLnN0YWNrZWQgIT09ICdub25lJyB8fCBhcnJvd0Rvd24gJiYgdGhpcy5zdGFja2VkID09PSAnbm9uZScpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHBlcmZvcm0gc2VsZWN0aW9uXG4gICAgICAgIHRoaXMudGFic2V0LnNlbGVjdE5leHRUYWIoKTtcblxuICAgICAgICAvLyBwcmV2ZW50IHRoZSBicm93c2VyIGZyb20gc2Nyb2xsaW5nIHdoZW4gYXJyb3cga2V5cyBhcmUgcHJlc3NlZFxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFRhYkZvY3VzRGlyZWN0aXZlIH0gZnJvbSAnLi90YWIvdGFiLWZvY3VzLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBUYWJIZWFkaW5nRGlyZWN0aXZlIH0gZnJvbSAnLi90YWIvdGFiLWhlYWRpbmcuZGlyZWN0aXZlJztcbmltcG9ydCB7IFRhYkNvbXBvbmVudCB9IGZyb20gJy4vdGFiL3RhYi5jb21wb25lbnQnO1xuaW1wb3J0IHsgVGFic2V0Q29tcG9uZW50IH0gZnJvbSAnLi90YWJzZXQuY29tcG9uZW50JztcblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIENvbW1vbk1vZHVsZVxuICAgIF0sXG4gICAgZXhwb3J0czogW1RhYnNldENvbXBvbmVudCwgVGFiQ29tcG9uZW50LCBUYWJIZWFkaW5nRGlyZWN0aXZlXSxcbiAgICBkZWNsYXJhdGlvbnM6IFtUYWJzZXRDb21wb25lbnQsIFRhYkNvbXBvbmVudCwgVGFiSGVhZGluZ0RpcmVjdGl2ZSwgVGFiRm9jdXNEaXJlY3RpdmVdLFxufSlcbmV4cG9ydCBjbGFzcyBUYWJzZXRNb2R1bGUgeyB9IiwiaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICAgIHNlbGVjdG9yOiAndXgtdGltZWxpbmUnLFxyXG4gICAgdGVtcGxhdGVVcmw6ICcuL3RpbWVsaW5lLmNvbXBvbmVudC5odG1sJ1xyXG59KVxyXG5leHBvcnQgY2xhc3MgVGltZWxpbmVDb21wb25lbnQge1xyXG59IiwiaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxubGV0IHVuaXF1ZUlkOiBudW1iZXIgPSAwO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgICBzZWxlY3RvcjogJ3V4LXRpbWVsaW5lLWV2ZW50JyxcclxuICAgIHRlbXBsYXRlVXJsOiAnLi90aW1lbGluZS1ldmVudC5jb21wb25lbnQuaHRtbCdcclxufSlcclxuZXhwb3J0IGNsYXNzIFRpbWVsaW5lRXZlbnRDb21wb25lbnQge1xyXG5cclxuICAgIEBJbnB1dCgpIGlkOiBzdHJpbmcgPSBgdXgtdGltZWxpbmUtZXZlbnQtJHt1bmlxdWVJZCsrfWA7XHJcbiAgICBASW5wdXQoKSBiYWRnZUNvbG9yOiBzdHJpbmc7XHJcbiAgICBASW5wdXQoKSBiYWRnZVRpdGxlOiBzdHJpbmc7XHJcbn0iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xyXG5pbXBvcnQgeyBUaW1lbGluZUNvbXBvbmVudCB9IGZyb20gJy4vdGltZWxpbmUuY29tcG9uZW50JztcclxuaW1wb3J0IHsgVGltZWxpbmVFdmVudENvbXBvbmVudCB9IGZyb20gJy4vdGltZWxpbmUtZXZlbnQvdGltZWxpbmUtZXZlbnQuY29tcG9uZW50JztcclxuXHJcbkBOZ01vZHVsZSh7XHJcbiAgICBpbXBvcnRzOiBbXHJcbiAgICAgICAgQ29tbW9uTW9kdWxlXHJcbiAgICBdLFxyXG4gICAgZXhwb3J0czogW1xyXG4gICAgICAgIFRpbWVsaW5lQ29tcG9uZW50LFxyXG4gICAgICAgIFRpbWVsaW5lRXZlbnRDb21wb25lbnRcclxuICAgIF0sXHJcbiAgICBkZWNsYXJhdGlvbnM6IFtcclxuICAgICAgICBUaW1lbGluZUNvbXBvbmVudCxcclxuICAgICAgICBUaW1lbGluZUV2ZW50Q29tcG9uZW50XHJcbiAgICBdXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBUaW1lbGluZU1vZHVsZSB7IH1cclxuIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIGZvcndhcmRSZWYsIElucHV0LCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBOR19WQUxVRV9BQ0NFU1NPUiB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuY29uc3QgVE9HR0xFU1dJVENIX1ZBTFVFX0FDQ0VTU09SID0ge1xuICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFRvZ2dsZVN3aXRjaENvbXBvbmVudCksXG4gICAgbXVsdGk6IHRydWVcbn07XG5cbmxldCB1bmlxdWVUb2dnbGVTd2l0Y2hJZCA9IDA7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtdG9nZ2xlc3dpdGNoJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vdG9nZ2xlc3dpdGNoLmNvbXBvbmVudC5odG1sJyxcbiAgICBwcm92aWRlcnM6IFtUT0dHTEVTV0lUQ0hfVkFMVUVfQUNDRVNTT1JdXG59KVxuZXhwb3J0IGNsYXNzIFRvZ2dsZVN3aXRjaENvbXBvbmVudCBpbXBsZW1lbnRzIENvbnRyb2xWYWx1ZUFjY2Vzc29yIHtcblxuICAgIHByaXZhdGUgX3RvZ2dsZVN3aXRjaElkOiBzdHJpbmcgPSBgdXgtdG9nZ2xlc3dpdGNoLSR7Kyt1bmlxdWVUb2dnbGVTd2l0Y2hJZH1gO1xuXG4gICAgQElucHV0KCkgaWQ6IHN0cmluZyA9IHRoaXMuX3RvZ2dsZVN3aXRjaElkO1xuICAgIEBJbnB1dCgpIG5hbWU6IHN0cmluZyB8IG51bGw7XG4gICAgQElucHV0KCkgdGFiaW5kZXg6IG51bWJlciA9IDA7XG4gICAgQElucHV0KCkgY2xpY2thYmxlOiBib29sZWFuID0gdHJ1ZTtcbiAgICBASW5wdXQoKSBkaXNhYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIEBJbnB1dCgnYXJpYS1sYWJlbCcpIGFyaWFMYWJlbDogc3RyaW5nID0gJyc7XG4gICAgQElucHV0KCdhcmlhLWxhYmVsbGVkYnknKSBhcmlhTGFiZWxsZWRieTogc3RyaW5nID0gbnVsbDtcblxuICAgIEBPdXRwdXQoKSB2YWx1ZUNoYW5nZTogRXZlbnRFbWl0dGVyPGJvb2xlYW4+ID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG4gICAgQElucHV0KClcbiAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICB9XG5cbiAgICBzZXQgdmFsdWUodmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcblxuICAgICAgICAvLyBVcGRhdGUgdmFsdWUgb3V0cHV0XG4gICAgICAgIHRoaXMudmFsdWVDaGFuZ2UuZW1pdCh2YWx1ZSk7XG5cbiAgICAgICAgLy8gTm90aWZ5IG5nTW9kZWxcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKHZhbHVlKTtcbiAgICAgICAgdGhpcy5vblRvdWNoZWRDYWxsYmFjaygpO1xuICAgIH1cblxuICAgIGdldCBpbnB1dElkKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmlkIHx8IHRoaXMuX3RvZ2dsZVN3aXRjaElkfS1pbnB1dGA7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfdmFsdWU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIGZvY3VzZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBvblRvdWNoZWRDYWxsYmFjazogKCkgPT4gdm9pZCA9ICgpID0+IHsgfTtcbiAgICBvbkNoYW5nZUNhbGxiYWNrOiAoXzogYW55KSA9PiB2b2lkID0gKCkgPT4geyB9O1xuXG4gICAgdG9nZ2xlKCk6IHZvaWQge1xuICAgICAgICBpZiAoIXRoaXMuZGlzYWJsZWQgJiYgdGhpcy5jbGlja2FibGUpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSAhdGhpcy52YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHdyaXRlVmFsdWUodmFsdWU6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9ICEhdmFsdWU7XG4gICAgfVxuXG4gICAgcmVnaXN0ZXJPbkNoYW5nZShmbjogYW55KTogdm9pZCB7XG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjayA9IGZuO1xuICAgIH1cblxuICAgIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5vblRvdWNoZWRDYWxsYmFjayA9IGZuO1xuICAgIH1cblxuICAgIHNldERpc2FibGVkU3RhdGUoaXNEaXNhYmxlZDogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICB0aGlzLmRpc2FibGVkID0gaXNEaXNhYmxlZDtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRm9ybXNNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmltcG9ydCB7IFRvZ2dsZVN3aXRjaENvbXBvbmVudCB9IGZyb20gJy4vdG9nZ2xlc3dpdGNoLmNvbXBvbmVudCc7XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogWyBGb3Jtc01vZHVsZSBdLFxuICAgIGV4cG9ydHM6IFsgVG9nZ2xlU3dpdGNoQ29tcG9uZW50IF0sXG4gICAgZGVjbGFyYXRpb25zOiBbIFRvZ2dsZVN3aXRjaENvbXBvbmVudCBdXG59KVxuZXhwb3J0IGNsYXNzIFRvZ2dsZVN3aXRjaE1vZHVsZSB7IH1cbiIsImltcG9ydCB7IERpcmVjdGl2ZSwgSG9zdExpc3RlbmVyLCBPdXRwdXQsIEV2ZW50RW1pdHRlciwgRWxlbWVudFJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1t1eFRvb2xiYXJTZWFyY2hCdXR0b25dJ1xufSlcbmV4cG9ydCBjbGFzcyBUb29sYmFyU2VhcmNoQnV0dG9uRGlyZWN0aXZlIHtcblxuICAgIEBPdXRwdXQoKVxuICAgIGNsaWNrZWQgPSBuZXcgRXZlbnRFbWl0dGVyPHZvaWQ+KCk7XG5cbiAgICBnZXQgd2lkdGgoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmKSB7IH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ2NsaWNrJylcbiAgICBjbGlja0hhbmRsZXIoKSB7XG4gICAgICAgIHRoaXMuY2xpY2tlZC5lbWl0KCk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIEhvc3RMaXN0ZW5lciwgT3B0aW9uYWwsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTmdNb2RlbCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuY29uc3QgS0VZUyA9IHtcbiAgICBFTlRFUjogMTMsXG4gICAgRVNDQVBFOiAyN1xufTtcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbdXhUb29sYmFyU2VhcmNoRmllbGRdJ1xufSlcbmV4cG9ydCBjbGFzcyBUb29sYmFyU2VhcmNoRmllbGREaXJlY3RpdmUge1xuXG4gICAgQE91dHB1dCgpXG4gICAgY2FuY2VsID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuXG4gICAgQE91dHB1dCgpXG4gICAgc3VibWl0ID0gbmV3IEV2ZW50RW1pdHRlcjxzdHJpbmc+KCk7XG5cbiAgICBnZXQgdGV4dCgpOiBzdHJpbmcge1xuICAgICAgICAvLyBVc2UgbmdNb2RlbCBpZiBzcGVjaWZpZWQgb24gdGhlIGhvc3Q7IG90aGVyd2lzZSByZWFkIHRoZSBET01cbiAgICAgICAgaWYgKHRoaXMuX25nTW9kZWwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uZ01vZGVsLnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC52YWx1ZTtcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZixcbiAgICAgICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBfbmdNb2RlbDogTmdNb2RlbCkgeyB9XG5cbiAgICBmb2N1cygpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYmx1cigpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuYmx1cigpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjbGVhcigpIHtcbiAgICAgICAgLy8gVXNlIG5nTW9kZWwgaWYgc3BlY2lmaWVkIG9uIHRoZSBob3N0OyBvdGhlcndpc2UgdXNlIHRoZSBET01cbiAgICAgICAgaWYgKHRoaXMuX25nTW9kZWwpIHtcbiAgICAgICAgICAgIHRoaXMuX25nTW9kZWwucmVzZXQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC52YWx1ZSA9ICcnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcigna2V5ZG93bicsIFsnJGV2ZW50J10pXG4gICAga2V5ZG93bkhhbmRsZXIoZXZlbnQ6IEtleWJvYXJkRXZlbnQpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQua2V5Q29kZSA9PT0gS0VZUy5FTlRFUikge1xuICAgICAgICAgICAgICAgIHRoaXMuc3VibWl0LmVtaXQodGhpcy50ZXh0KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PT0gS0VZUy5FU0NBUEUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuYmx1cigpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsLmVtaXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgYW5pbWF0ZSwgQW5pbWF0aW9uRXZlbnQsIHN0YXRlLCBzdHlsZSwgdHJhbnNpdGlvbiwgdHJpZ2dlciB9IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xuaW1wb3J0IHsgRE9DVU1FTlQgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgQWZ0ZXJDb250ZW50SW5pdCwgQ29tcG9uZW50LCBDb250ZW50Q2hpbGQsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSG9zdEJpbmRpbmcsIEhvc3RMaXN0ZW5lciwgSW5qZWN0LCBJbnB1dCwgT3V0cHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb2xvclNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9jb2xvci9jb2xvci5zZXJ2aWNlJztcbmltcG9ydCB7IFRvb2xiYXJTZWFyY2hCdXR0b25EaXJlY3RpdmUgfSBmcm9tICcuL3Rvb2xiYXItc2VhcmNoLWJ1dHRvbi5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgVG9vbGJhclNlYXJjaEZpZWxkRGlyZWN0aXZlIH0gZnJvbSAnLi90b29sYmFyLXNlYXJjaC1maWVsZC5kaXJlY3RpdmUnO1xuXG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAndXgtdG9vbGJhci1zZWFyY2gnLFxuICAgIHRlbXBsYXRlOiBgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PmAsXG4gICAgYW5pbWF0aW9uczogW1xuICAgICAgICB0cmlnZ2VyKCdleHBhbmRlZCcsIFtcbiAgICAgICAgICAgIHN0YXRlKFxuICAgICAgICAgICAgICAgICdjb2xsYXBzZWQnLFxuICAgICAgICAgICAgICAgIHN0eWxlKHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6ICd7e2luaXRpYWxXaWR0aH19J1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiB7IGluaXRpYWxXaWR0aDogJzMwcHgnIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgc3RhdGUoXG4gICAgICAgICAgICAgICAgJ2V4cGFuZGVkJyxcbiAgICAgICAgICAgICAgICBzdHlsZSh7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiAnMTAwJSdcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHRyYW5zaXRpb24oJ2NvbGxhcHNlZCA8PT4gZXhwYW5kZWQnLCBbYW5pbWF0ZSgnMC4zcyBlYXNlLW91dCcpXSlcbiAgICAgICAgXSlcbiAgICBdXG59KVxuZXhwb3J0IGNsYXNzIFRvb2xiYXJTZWFyY2hDb21wb25lbnQgaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0IHtcblxuICAgIEBIb3N0QmluZGluZygnY2xhc3MuZXhwYW5kZWQnKVxuICAgIEBJbnB1dCgpXG4gICAgZ2V0IGV4cGFuZGVkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXhwYW5kZWQ7XG4gICAgfVxuXG4gICAgc2V0IGV4cGFuZGVkKHZhbHVlOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuX2V4cGFuZGVkID0gdmFsdWU7XG5cbiAgICAgICAgdGhpcy5leHBhbmRlZENoYW5nZS5lbWl0KHZhbHVlKTtcblxuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIC8vIFNldCBmb2N1cyBvbiB0aGUgaW5wdXQgd2hlbiBleHBhbmRlZFxuICAgICAgICAgICAgdGhpcy5maWVsZC5mb2N1cygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQ2xlYXIgdGV4dCB3aGVuIGNvbnRyYWN0ZWRcbiAgICAgICAgICAgIHRoaXMuZmllbGQuY2xlYXIoKTtcblxuICAgICAgICAgICAgLy8gUmVtb3ZlIGZvY3VzICh3b3JrcyBhcm91bmQgYW4gSUUgaXNzdWUgd2hlcmUgdGhlIGNhcmV0IHJlbWFpbnMgdmlzaWJsZSlcbiAgICAgICAgICAgIHRoaXMuZmllbGQuYmx1cigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgQElucHV0KClcbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzJylcbiAgICBkaXJlY3Rpb246ICdsZWZ0JyB8ICdyaWdodCcgPSAncmlnaHQnO1xuXG4gICAgQElucHV0KClcbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmludmVyc2UnKVxuICAgIGludmVyc2UgPSBmYWxzZTtcblxuICAgIEBJbnB1dCgpXG4gICAgc2V0IGJhY2tncm91bmQodmFsdWU6IHN0cmluZykge1xuICAgICAgICB0aGlzLmJhY2tncm91bmRDb2xvciA9IHRoaXMuX2NvbG9yU2VydmljZS5yZXNvbHZlKHZhbHVlKSB8fCAndHJhbnNwYXJlbnQnO1xuICAgIH1cblxuICAgIEBPdXRwdXQoKVxuICAgIGV4cGFuZGVkQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG4gICAgQE91dHB1dCgpXG4gICAgc2VhcmNoID0gbmV3IEV2ZW50RW1pdHRlcjxzdHJpbmc+KCk7XG5cbiAgICBwcml2YXRlIF9leHBhbmRlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgQEhvc3RCaW5kaW5nKCdAZXhwYW5kZWQnKVxuICAgIGdldCBleHBhbmRlZEFuaW1hdGlvbigpOiBhbnkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHRoaXMuZXhwYW5kZWQgPyAnZXhwYW5kZWQnIDogJ2NvbGxhcHNlZCcsXG4gICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICBpbml0aWFsV2lkdGg6IHRoaXMuYnV0dG9uLndpZHRoICsgJ3B4J1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIEBIb3N0QmluZGluZygnc3R5bGUucG9zaXRpb24nKSBwb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS5iYWNrZ3JvdW5kLWNvbG9yJykgYmFja2dyb3VuZENvbG9yID0gJ3RyYW5zcGFyZW50JztcbiAgICBAQ29udGVudENoaWxkKFRvb2xiYXJTZWFyY2hGaWVsZERpcmVjdGl2ZSkgZmllbGQ6IFRvb2xiYXJTZWFyY2hGaWVsZERpcmVjdGl2ZTtcbiAgICBAQ29udGVudENoaWxkKFRvb2xiYXJTZWFyY2hCdXR0b25EaXJlY3RpdmUpIGJ1dHRvbjogVG9vbGJhclNlYXJjaEJ1dHRvbkRpcmVjdGl2ZTtcblxuICAgIHByaXZhdGUgX3BsYWNlaG9sZGVyOiBIVE1MRWxlbWVudDtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgICAgICBwcml2YXRlIF9jb2xvclNlcnZpY2U6IENvbG9yU2VydmljZSxcbiAgICAgICAgQEluamVjdChET0NVTUVOVCkgcHJpdmF0ZSBfZG9jdW1lbnQ6IGFueSkge1xuICAgIH1cblxuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICAgICAgLy8gU3Vic2NyaWJlIHRvIHRoZSBzdWJtaXQgZXZlbnQgb24gdGhlIGlucHV0IGZpZWxkLCB0cmlnZ2VyaW5nIHRoZSBzZWFyY2ggZXZlbnRcbiAgICAgICAgdGhpcy5maWVsZC5zdWJtaXQuc3Vic2NyaWJlKCh0ZXh0OiBzdHJpbmcpID0+IHRoaXMuc2VhcmNoLmVtaXQodGV4dCkpO1xuXG4gICAgICAgIC8vIFN1YnNjcmliZSB0byBjYW5jZWwgZXZlbnRzIGNvbWluZyBmcm9tIHRoZSBpbnB1dCBmaWVsZFxuICAgICAgICB0aGlzLmZpZWxkLmNhbmNlbC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5leHBhbmRlZCA9IGZhbHNlKTtcblxuICAgICAgICAvLyBTdWJzY3JpYmUgdG8gdGhlIGJ1dHRvbiBjbGljayBldmVudFxuICAgICAgICB0aGlzLmJ1dHRvbi5jbGlja2VkLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5leHBhbmRlZCAmJiB0aGlzLmZpZWxkLnRleHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaC5lbWl0KHRoaXMuZmllbGQudGV4dCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZXhwYW5kZWQgPSAhdGhpcy5leHBhbmRlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIHBsYWNlaG9sZGVyIGVsZW1lbnQgdG8gYXZvaWQgY2hhbmdpbmcgbGF5b3V0IHdoZW4gc3dpdGNoaW5nIHRvIHBvc2l0aW9uOiBhYnNvbHV0ZVxuICAgICAgICB0aGlzLmNyZWF0ZVBsYWNlaG9sZGVyKCk7XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcignQGV4cGFuZGVkLnN0YXJ0JywgWyckZXZlbnQnXSlcbiAgICBhbmltYXRpb25TdGFydChldmVudDogQW5pbWF0aW9uRXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LnRvU3RhdGUgPT09ICdleHBhbmRlZCcpIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICAgICAgdGhpcy5lbmFibGVQbGFjZWhvbGRlcih0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ0BleHBhbmRlZC5kb25lJywgWyckZXZlbnQnXSlcbiAgICBhbmltYXRpb25Eb25lKGV2ZW50OiBBbmltYXRpb25FdmVudCkge1xuICAgICAgICBpZiAoZXZlbnQudG9TdGF0ZSA9PT0gJ2NvbGxhcHNlZCcpIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgICAgICAgdGhpcy5lbmFibGVQbGFjZWhvbGRlcihmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGNyZWF0ZVBsYWNlaG9sZGVyKCkge1xuICAgICAgICAvLyBHZXQgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgY29tcG9uZW50XG4gICAgICAgIGNvbnN0IHN0eWxlcyA9IGdldENvbXB1dGVkU3R5bGUodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50KTtcblxuICAgICAgICAvLyBDcmVhdGUgaW52aXNpYmxlIGRpdiB3aXRoIHRoZSBzYW1lIGRpbWVuc2lvbnNcbiAgICAgICAgdGhpcy5fcGxhY2Vob2xkZXIgPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5fcGxhY2Vob2xkZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgdGhpcy5fcGxhY2Vob2xkZXIuc3R5bGUud2lkdGggPSB0aGlzLmJ1dHRvbi53aWR0aCArICdweCc7XG4gICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyLnN0eWxlLmhlaWdodCA9IHN0eWxlcy5oZWlnaHQ7XG4gICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcblxuICAgICAgICAvLyBBZGQgYXMgYSBzaWJsaW5nXG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLl9wbGFjZWhvbGRlciwgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGVuYWJsZVBsYWNlaG9sZGVyKGVuYWJsZWQ6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5fcGxhY2Vob2xkZXIuc3R5bGUuZGlzcGxheSA9IChlbmFibGVkID8gJ2lubGluZS1ibG9jaycgOiAnbm9uZScpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XHJcblxyXG5pbXBvcnQgeyBUb29sYmFyU2VhcmNoQ29tcG9uZW50IH0gZnJvbSAnLi90b29sYmFyLXNlYXJjaC5jb21wb25lbnQnO1xyXG5pbXBvcnQgeyBUb29sYmFyU2VhcmNoRmllbGREaXJlY3RpdmUgfSBmcm9tICcuL3Rvb2xiYXItc2VhcmNoLWZpZWxkLmRpcmVjdGl2ZSc7XHJcbmltcG9ydCB7IFRvb2xiYXJTZWFyY2hCdXR0b25EaXJlY3RpdmUgfSBmcm9tICcuL3Rvb2xiYXItc2VhcmNoLWJ1dHRvbi5kaXJlY3RpdmUnO1xyXG5cclxuY29uc3QgREVDTEFSQVRJT05TID0gW1xyXG4gICAgVG9vbGJhclNlYXJjaENvbXBvbmVudCxcclxuICAgIFRvb2xiYXJTZWFyY2hGaWVsZERpcmVjdGl2ZSxcclxuICAgIFRvb2xiYXJTZWFyY2hCdXR0b25EaXJlY3RpdmVcclxuXTtcclxuXHJcbkBOZ01vZHVsZSh7XHJcbiAgICBpbXBvcnRzOiBbXHJcbiAgICAgICAgQ29tbW9uTW9kdWxlXHJcbiAgICBdLFxyXG4gICAgZXhwb3J0czogREVDTEFSQVRJT05TLFxyXG4gICAgZGVjbGFyYXRpb25zOiBERUNMQVJBVElPTlMsXHJcbiAgICBwcm92aWRlcnM6IFtdLFxyXG59KVxyXG5leHBvcnQgY2xhc3MgVG9vbGJhclNlYXJjaE1vZHVsZSB7IH1cclxuIiwiaW1wb3J0IHsgRGlyZWN0aXZlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBEaXJlY3RpdmUoeyBcbiAgICBzZWxlY3RvcjogJ1t1eFZpcnR1YWxTY3JvbGxMb2FkaW5nXScgXG59KVxuZXhwb3J0IGNsYXNzIFZpcnR1YWxTY3JvbGxMb2FkaW5nRGlyZWN0aXZlIHsgfSIsImltcG9ydCB7IERpcmVjdGl2ZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1t1eFZpcnR1YWxTY3JvbGxMb2FkQnV0dG9uXScgXG59KVxuZXhwb3J0IGNsYXNzIFZpcnR1YWxTY3JvbGxMb2FkQnV0dG9uRGlyZWN0aXZlIHsgfSIsImltcG9ydCB7IERpcmVjdGl2ZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ARGlyZWN0aXZlKHsgXG4gICAgc2VsZWN0b3I6ICdbdXhWaXJ0dWFsU2Nyb2xsQ2VsbF0nIFxufSlcbmV4cG9ydCBjbGFzcyBWaXJ0dWFsU2Nyb2xsQ2VsbERpcmVjdGl2ZSB7XG5cbn0iLCJpbXBvcnQgeyBDb21wb25lbnQsIE9uSW5pdCwgRXZlbnRFbWl0dGVyLCBPdXRwdXQsIElucHV0LCBIb3N0TGlzdGVuZXIsIEVsZW1lbnRSZWYsIEFmdGVyQ29udGVudEluaXQsIENvbnRlbnRDaGlsZCwgVGVtcGxhdGVSZWYsIE9uRGVzdHJveSwgU2ltcGxlQ2hhbmdlcyB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUmVzaXplU2VydmljZSB9IGZyb20gJy4uLy4uL2RpcmVjdGl2ZXMvcmVzaXplL2luZGV4JztcbmltcG9ydCB7IFZpcnR1YWxTY3JvbGxMb2FkaW5nRGlyZWN0aXZlIH0gZnJvbSAnLi9kaXJlY3RpdmVzL3ZpcnR1YWwtc2Nyb2xsLWxvYWRpbmcuZGlyZWN0aXZlJztcbmltcG9ydCB7IFZpcnR1YWxTY3JvbGxMb2FkQnV0dG9uRGlyZWN0aXZlIH0gZnJvbSAnLi9kaXJlY3RpdmVzL3ZpcnR1YWwtc2Nyb2xsLWxvYWQtYnV0dG9uLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBWaXJ0dWFsU2Nyb2xsQ2VsbERpcmVjdGl2ZSB9IGZyb20gJy4vZGlyZWN0aXZlcy92aXJ0dWFsLXNjcm9sbC1jZWxsLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBCZWhhdmlvclN1YmplY3QgfSBmcm9tICdyeGpzL0JlaGF2aW9yU3ViamVjdCc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcy9PYnNlcnZhYmxlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd1eC12aXJ0dWFsLXNjcm9sbCcsXG4gICAgdGVtcGxhdGVVcmw6ICcuL3ZpcnR1YWwtc2Nyb2xsLmNvbXBvbmVudC5odG1sJ1xufSlcbmV4cG9ydCBjbGFzcyBWaXJ0dWFsU2Nyb2xsQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBBZnRlckNvbnRlbnRJbml0LCBPbkRlc3Ryb3kge1xuXG4gICAgQElucHV0KCkgY29sbGVjdGlvbjogT2JzZXJ2YWJsZTxhbnlbXT4gPSBPYnNlcnZhYmxlLmNyZWF0ZSgpO1xuICAgIEBJbnB1dCgpIGNlbGxIZWlnaHQ6IG51bWJlcjtcbiAgICBASW5wdXQoKSBsb2FkT25TY3JvbGw6IGJvb2xlYW4gPSB0cnVlO1xuXG4gICAgQE91dHB1dCgpIGxvYWRpbmc6IEV2ZW50RW1pdHRlcjxudW1iZXI+ID0gbmV3IEV2ZW50RW1pdHRlcjxudW1iZXI+KCk7XG5cbiAgICBAQ29udGVudENoaWxkKFZpcnR1YWxTY3JvbGxDZWxsRGlyZWN0aXZlLCB7IHJlYWQ6IFRlbXBsYXRlUmVmIH0pIGNlbGxUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcbiAgICBAQ29udGVudENoaWxkKFZpcnR1YWxTY3JvbGxMb2FkaW5nRGlyZWN0aXZlLCB7IHJlYWQ6IFRlbXBsYXRlUmVmIH0pIGxvYWRpbmdJbmRpY2F0b3JUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcbiAgICBAQ29udGVudENoaWxkKFZpcnR1YWxTY3JvbGxMb2FkQnV0dG9uRGlyZWN0aXZlLCB7IHJlYWQ6IFRlbXBsYXRlUmVmIH0pIGxvYWRCdXR0b25UZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcblxuICAgIGNlbGxzOiBCZWhhdmlvclN1YmplY3Q8YW55W10+ID0gbmV3IEJlaGF2aW9yU3ViamVjdChbXSk7XG4gICAgc2Nyb2xsVG9wOiBudW1iZXIgPSAwO1xuICAgIGlzTG9hZGluZzogYm9vbGVhbiA9IGZhbHNlO1xuICAgIHBhZ2VOdW1iZXI6IG51bWJlciA9IDA7XG4gICAgZGF0YTogYW55W10gPSBbXTtcbiAgICBsb2FkaW5nQ29tcGxldGU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIHByaXZhdGUgX3N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuICAgIHByaXZhdGUgX2hlaWdodDogbnVtYmVyO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZiwgcmVzaXplU2VydmljZTogUmVzaXplU2VydmljZSkge1xuXG4gICAgICAgIC8vIHdhdGNoIGZvciBhbnkgZnV0dXJlIGNoYW5nZXMgdG8gc2l6ZVxuICAgICAgICByZXNpemVTZXJ2aWNlLmFkZFJlc2l6ZUxpc3RlbmVyKF9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpLnN1YnNjcmliZShldmVudCA9PiB0aGlzLl9oZWlnaHQgPSBldmVudC5oZWlnaHQpO1xuICAgIH1cblxuICAgIG5nT25Jbml0KCkge1xuXG4gICAgICAgIGlmICghdGhpcy5jZWxsSGVpZ2h0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZpcnR1YWwgU2Nyb2xsIENvbXBvbmVudCByZXF1aXJlcyBcImNlbGxIZWlnaHRcIiBwcm9wZXJ0eSB0byBiZSBkZWZpbmVkLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc3Vic2NyaWJlIHRvIHRoZSBjb2xsZWN0aW9uXG4gICAgICAgIHRoaXMuc2V0dXBPYnNlcnZhYmxlKCk7XG5cbiAgICAgICAgLy8gbG9hZCB0aGUgZmlyc3QgcGFnZSBvZiBkYXRhXG4gICAgICAgIHRoaXMubG9hZE5leHRQYWdlKCk7XG4gICAgfVxuXG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCk6IHZvaWQge1xuICAgICAgICAvLyByZS1yZW5kZXIgY2VsbHMgbm93IHRoYXQgd2UgY2FuIGRpc3BsYXkgYW55IGxvYWRpbmcgaW5kaWNhdG9yIG9yIGxvYWRpbmcgYnV0dG9uXG4gICAgICAgIHRoaXMucmVuZGVyQ2VsbHMoKTtcbiAgICB9XG5cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG4gICAgICAgIGlmIChjaGFuZ2VzLmNvbGxlY3Rpb24gJiYgY2hhbmdlcy5jb2xsZWN0aW9uLmN1cnJlbnRWYWx1ZSAhPT0gY2hhbmdlcy5jb2xsZWN0aW9uLnByZXZpb3VzVmFsdWUgJiYgIWNoYW5nZXMuY29sbGVjdGlvbi5pc0ZpcnN0Q2hhbmdlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0dXBPYnNlcnZhYmxlKCk7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuXG4gICAgc2V0dXBPYnNlcnZhYmxlKCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIGEgY3VycmVudCBzdWJzY3JpcHRpb24sIHVuc3Vic2NyaWJlXG4gICAgICAgIGlmICh0aGlzLl9zdWJzY3JpcHRpb24gJiYgdGhpcy5fc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKSB7XG4gICAgICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbiA9IHRoaXMuY29sbGVjdGlvbi5zdWJzY3JpYmUoY29sbGVjdGlvbiA9PiB7XG4gICAgICAgICAgICB0aGlzLmRhdGEucHVzaCguLi5jb2xsZWN0aW9uKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyQ2VsbHMoKTtcbiAgICAgICAgICAgIHRoaXMuaXNMb2FkaW5nID0gZmFsc2U7XG4gICAgICAgIH0sIG51bGwsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubG9hZGluZ0NvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcignc2Nyb2xsJykgcmVuZGVyQ2VsbHMoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuY2VsbHMubmV4dCh0aGlzLmdldFZpc2libGVDZWxscygpKTtcblxuICAgICAgICBpZiAodGhpcy5sb2FkT25TY3JvbGwgJiYgIXRoaXMuaXNMb2FkaW5nICYmICF0aGlzLmxvYWRpbmdDb21wbGV0ZSkge1xuICAgICAgICAgICAgY29uc3QgcmVtYWluaW5nU2Nyb2xsID0gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnNjcm9sbEhlaWdodCAtICh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuc2Nyb2xsVG9wICsgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmNsaWVudEhlaWdodCk7XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZSBjdXJyZW50IGNlbGxzIHRha2UgdXAgbGVzcyB0aGFuIHRoZSBoZWlnaHQgb2YgdGhlIGNvbXBvbmVudCB0aGVuIGxvYWQgdGhlIG5leHQgcGFnZVxuICAgICAgICAgICAgaWYgKHJlbWFpbmluZ1Njcm9sbCA8PSB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuY2xpZW50SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkTmV4dFBhZ2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldFZpc2libGVDZWxscygpOiBhbnlbXSB7XG5cbiAgICAgICAgLy8gc3RvcmUgdGhlIGluaXRpYWwgZWxlbWVudCBoZWlnaHRcbiAgICAgICAgaWYgKCF0aGlzLl9oZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuX2hlaWdodCA9IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwZXJmb3JtIHNvbWUgY2FsY3VsYXRpb25zXG4gICAgICAgIGNvbnN0IHNjcm9sbFRvcCA9IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5zY3JvbGxUb3A7XG4gICAgICAgIGNvbnN0IHN0YXJ0Q2VsbCA9IE1hdGguZmxvb3Ioc2Nyb2xsVG9wIC8gdGhpcy5jZWxsSGVpZ2h0KTtcbiAgICAgICAgY29uc3QgZW5kQ2VsbCA9IE1hdGguY2VpbCh0aGlzLl9oZWlnaHQgLyB0aGlzLmNlbGxIZWlnaHQpICsgMTtcblxuICAgICAgICAvLyB1cGRhdGUgdGhlIHNjcm9sbCBwb3NpdGlvblxuICAgICAgICB0aGlzLnNjcm9sbFRvcCA9IHNjcm9sbFRvcCAtIChzY3JvbGxUb3AgJSB0aGlzLmNlbGxIZWlnaHQpO1xuXG4gICAgICAgIC8vIHJldHVybiBhIHN1Ymxpc3Qgb2YgaXRlbXMgdmlzaWJsZSBvbiB0aGUgc2NyZWVuXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEuc2xpY2Uoc3RhcnRDZWxsLCBzdGFydENlbGwgKyBlbmRDZWxsKTtcbiAgICB9XG5cbiAgICBnZXRUb3RhbEhlaWdodCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5jZWxsSGVpZ2h0ICogdGhpcy5kYXRhLmxlbmd0aDtcbiAgICB9XG5cbiAgICBsb2FkTmV4dFBhZ2UoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuaXNMb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5sb2FkaW5nLm5leHQodGhpcy5wYWdlTnVtYmVyKTtcbiAgICAgICAgdGhpcy5wYWdlTnVtYmVyKys7XG4gICAgfVxuXG4gICAgcmVzZXQoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gcmVzZXQgYWxsIHZhbHVlc1xuICAgICAgICB0aGlzLnNjcm9sbFRvcCA9IDA7XG4gICAgICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucGFnZU51bWJlciA9IDA7XG4gICAgICAgIHRoaXMubG9hZGluZ0NvbXBsZXRlID0gZmFsc2U7XG5cbiAgICAgICAgLy8gc2V0IHNjcm9sbCBwb3NpdGlvblxuICAgICAgICB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuc2Nyb2xsVG9wID0gMDtcblxuICAgICAgICAvLyBjbGVhciB0aGUgY3VycmVudCBjZWxsc1xuICAgICAgICB0aGlzLnJlbmRlckNlbGxzKCk7XG5cbiAgICAgICAgLy8gcmVsb2FkIGZpcnN0IHBhZ2VcbiAgICAgICAgdGhpcy5sb2FkTmV4dFBhZ2UoKTtcbiAgICB9XG5cbn0iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcblxuaW1wb3J0IHsgVmlydHVhbFNjcm9sbENvbXBvbmVudCB9IGZyb20gJy4vdmlydHVhbC1zY3JvbGwuY29tcG9uZW50JztcbmltcG9ydCB7IFJlc2l6ZU1vZHVsZSB9IGZyb20gJy4uLy4uL2RpcmVjdGl2ZXMvcmVzaXplL2luZGV4JztcbmltcG9ydCB7IFZpcnR1YWxTY3JvbGxMb2FkaW5nRGlyZWN0aXZlIH0gZnJvbSAnLi9kaXJlY3RpdmVzL3ZpcnR1YWwtc2Nyb2xsLWxvYWRpbmcuZGlyZWN0aXZlJztcbmltcG9ydCB7IFZpcnR1YWxTY3JvbGxMb2FkQnV0dG9uRGlyZWN0aXZlIH0gZnJvbSAnLi9kaXJlY3RpdmVzL3ZpcnR1YWwtc2Nyb2xsLWxvYWQtYnV0dG9uLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBWaXJ0dWFsU2Nyb2xsQ2VsbERpcmVjdGl2ZSB9IGZyb20gJy4vZGlyZWN0aXZlcy92aXJ0dWFsLXNjcm9sbC1jZWxsLmRpcmVjdGl2ZSc7XG5cbmNvbnN0IERFQ0xBUkFUSU9OUyA9IFtcbiAgICBWaXJ0dWFsU2Nyb2xsQ29tcG9uZW50LFxuICAgIFZpcnR1YWxTY3JvbGxMb2FkaW5nRGlyZWN0aXZlLFxuICAgIFZpcnR1YWxTY3JvbGxMb2FkQnV0dG9uRGlyZWN0aXZlLFxuICAgIFZpcnR1YWxTY3JvbGxDZWxsRGlyZWN0aXZlXG5dO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtcbiAgICAgICAgQ29tbW9uTW9kdWxlLFxuICAgICAgICBSZXNpemVNb2R1bGVcbiAgICBdLFxuICAgIGV4cG9ydHM6IERFQ0xBUkFUSU9OUyxcbiAgICBkZWNsYXJhdGlvbnM6IERFQ0xBUkFUSU9OU1xufSlcbmV4cG9ydCBjbGFzcyBWaXJ0dWFsU2Nyb2xsTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgQWZ0ZXJWaWV3SW5pdCwgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBIb3N0TGlzdGVuZXIsIFJlbmRlcmVyMiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbdXhBdXRvR3Jvd10nXG59KVxuZXhwb3J0IGNsYXNzIEF1dG9Hcm93RGlyZWN0aXZlIGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCB7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZiwgcHJpdmF0ZSBfcmVuZGVyZXI6IFJlbmRlcmVyMikge1xuICAgIC8vIGVuc3VyZSB0aGlzIGlzIGEgdGV4dGFyZWEgb3IgZWxzZSB0aHJvdyBlcnJvclxuICAgIGlmIChfZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSAhPT0gJ3RleHRhcmVhJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd1eEF1dG9Hcm93IGRpcmVjdGl2ZSBjYW4gb25seSBiZSB1c2VkIG9uIDx0ZXh0YXJlYT4gZWxlbWVudHMuJyk7XG4gICAgfVxuICB9XG5cbiAgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH1cblxuICBASG9zdExpc3RlbmVyKCdpbnB1dCcpXG4gIHVwZGF0ZSgpOiB2b2lkIHtcblxuICAgIC8vIHBlcmZvcm0gc2l6aW5nXG4gICAgdGhpcy5fcmVuZGVyZXIuc2V0U3R5bGUodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnb3ZlcmZsb3dZJywgJ2hpZGRlbicpO1xuICAgIHRoaXMuX3JlbmRlcmVyLnNldFN0eWxlKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2hlaWdodCcsICdhdXRvJyk7XG5cbiAgICAvLyBnZXQgdGhlIG5ldyB0b3RhbCBoZWlnaHQgYW5kIGVsZW1lbnQgaGVpZ2h0XG4gICAgY29uc3QgeyBzY3JvbGxIZWlnaHQgfSA9IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgICBjb25zdCB7IG1heEhlaWdodCB9ID0gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpO1xuXG4gICAgLy8gZGV0ZXJtaW5lIHdoYXQgdGhlIG1heGltdW0gYWxsb3dlZCBoZWlnaHQgaXNcbiAgICBjb25zdCBtYXhpbXVtID0gIWlzTmFOKHBhcnNlRmxvYXQobWF4SGVpZ2h0KSkgPyBwYXJzZUZsb2F0KG1heEhlaWdodCkgOiBJbmZpbml0eTtcblxuICAgIC8vIGlmIHRoZXJlIGlzIGEgbWF4IGhlaWdodCBzcGVjaWZlZCB3ZSB3YW50IHRvIHNob3cgdGhlIHNjcm9sbGJhcnNcbiAgICBpZiAobWF4aW11bSA8IHNjcm9sbEhlaWdodCkge1xuICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0U3R5bGUodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnb3ZlcmZsb3dZJywgJ2F1dG8nKTtcbiAgICAgIHRoaXMuX3JlbmRlcmVyLnNldFN0eWxlKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2hlaWdodCcsIG1heGltdW0gKyAncHgnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0U3R5bGUodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnaGVpZ2h0Jywgc2Nyb2xsSGVpZ2h0ICsgJ3B4Jyk7XG4gICAgfVxuICB9XG5cbn0iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuaW1wb3J0IHsgQXV0b0dyb3dEaXJlY3RpdmUgfSBmcm9tICcuL2F1dG8tZ3Jvdy5kaXJlY3RpdmUnO1xyXG5cclxuQE5nTW9kdWxlKHtcclxuICAgIGV4cG9ydHM6IFtBdXRvR3Jvd0RpcmVjdGl2ZV0sXHJcbiAgICBkZWNsYXJhdGlvbnM6IFtBdXRvR3Jvd0RpcmVjdGl2ZV1cclxufSlcclxuZXhwb3J0IGNsYXNzIEF1dG9Hcm93TW9kdWxlIHsgfVxyXG4iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSW5wdXQsIE9uSW5pdCwgT3V0cHV0LCBSZW5kZXJlcjIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW3V4Rml4ZWRIZWFkZXJUYWJsZV0nXG59KVxuZXhwb3J0IGNsYXNzIEZpeGVkSGVhZGVyVGFibGVEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQge1xuXG4gIEBJbnB1dCgpIHRhYmxlSGVpZ2h0OiBudW1iZXIgfCBzdHJpbmc7XG4gIEBPdXRwdXQoKSB0YWJsZVBhZ2luZzogRXZlbnRFbWl0dGVyPG51bWJlcj4gPSBuZXcgRXZlbnRFbWl0dGVyPG51bWJlcj4oKTtcblxuICBwcml2YXRlIF90YWJsZUhlYWQ6IEhUTUxFbGVtZW50O1xuICBwcml2YXRlIF90YWJsZUJvZHk6IEhUTUxFbGVtZW50O1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIHByaXZhdGUgX3JlbmRlcmVyOiBSZW5kZXJlcjIpIHsgfVxuXG4gIG5nT25Jbml0KCk6IHZvaWQge1xuXG4gICAgLy8gYWRkIGNsYXNzIHRvIHRoZSB0YWJsZVxuICAgIHRoaXMuX3JlbmRlcmVyLmFkZENsYXNzKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ3V4LWZpeGVkLWhlYWRlci10YWJsZScpO1xuXG4gICAgLy8gbG9jYXRlIHRoZSBpbXBvcnRhbnQgZWxlbWVudHNcbiAgICB0aGlzLl90YWJsZUhlYWQgPSB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcigndGhlYWQnKTtcbiAgICB0aGlzLl90YWJsZUJvZHkgPSB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQucXVlcnlTZWxlY3RvcigndGJvZHknKTtcblxuICAgIC8vIGJpbmQgdG8gc2Nyb2xsIGV2ZW50cyBvbiB0aGUgdGFibGUgYm9keVxuICAgIHRoaXMuX3JlbmRlcmVyLmxpc3Rlbih0aGlzLl90YWJsZUJvZHksICdzY3JvbGwnLCB0aGlzLm9uU2Nyb2xsLmJpbmQodGhpcykpO1xuXG4gICAgLy8gcmVzaXplIHRoZSB0YWJsZSBoZWFkZXIgdG8gYWNjb3VudCBmb3Igc2Nyb2xsYmFyXG4gICAgdGhpcy5zZXRMYXlvdXQoKTtcblxuICAgIC8vIHRyaWdnZXIgdGhlIGxvYWRpbmcgb2YgdGhlIGZpcnN0IHBhZ2VcbiAgICB0aGlzLnRhYmxlUGFnaW5nLmVtaXQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHRhYmxlIGVsZW1lbnRcbiAgICogUHJpbWFyaWx5IHVzZWQgYnkgY29sdW1uIHdpZHRoIGRpcmVjdGl2ZVxuICAgKi9cbiAgZ2V0VGFibGUoKTogSFRNTFRhYmxlRWxlbWVudCB7XG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgc2Nyb2xsIGV2ZW50c1xuICAgKi9cbiAgcHJpdmF0ZSBvblNjcm9sbCgpOiB2b2lkIHtcblxuICAgIC8vIGRldGVybWluZSBpZiB3ZSBhcmUgc2Nyb2xsZWQgdG8gdGhlIGJvdHRvbSBhbmQgaWYgc28gbG9hZCB0aGUgbmV4dCBwYWdlXG4gICAgaWYgKHRoaXMuX3RhYmxlQm9keS5zY3JvbGxUb3AgPT09ICh0aGlzLl90YWJsZUJvZHkuc2Nyb2xsSGVpZ2h0IC0gdGhpcy5fdGFibGVCb2R5Lm9mZnNldEhlaWdodCkpIHtcbiAgICAgIHRoaXMudGFibGVQYWdpbmcuZW1pdCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIHNpemUgb2YgdGhlIHRhYmxlIGhlYWRlciB0byBhY2NvdW50IGZvciB0aGUgc2Nyb2xsYmFyLlxuICAgKiBUaGlzIGlzIGltcG9ydGFudCB0byBrZWVwIHRoZSBjb2x1bW5zIGFsaWduZWRcbiAgICovXG4gIHByaXZhdGUgc2V0TGF5b3V0KCk6IHZvaWQge1xuXG4gICAgLy8gY2FsY3VsYXRlIHRoZSBzaXplIG9mIHRoZSBzY3JvbGxiYXJcbiAgICBjb25zdCBzY3JvbGxiYXIgPSB0aGlzLl90YWJsZUJvZHkub2Zmc2V0V2lkdGggLSB0aGlzLl90YWJsZUJvZHkuY2xpZW50V2lkdGg7XG5cbiAgICAvLyBhZGQgcGFkZGluZyB0byB0aGUgaGVhZGVyIHRvIGFjY291bnQgZm9yIHRoaXNcbiAgICB0aGlzLl9yZW5kZXJlci5zZXRTdHlsZSh0aGlzLl90YWJsZUhlYWQsICdwYWRkaW5nLXJpZ2h0Jywgc2Nyb2xsYmFyICsgJ3B4Jyk7XG5cbiAgICAvLyBzZXQgdGhlIGRlc2lyZWQgaGVpZ2h0IG9mIHRoZSB0YWJsZSBib2R5XG4gICAgdGhpcy5fcmVuZGVyZXIuc2V0U3R5bGUodGhpcy5fdGFibGVCb2R5LCAnaGVpZ2h0JywgdHlwZW9mIHRoaXMudGFibGVIZWlnaHQgPT09ICdudW1iZXInID8gYCR7dGhpcy50YWJsZUhlaWdodH1weGAgOiB0aGlzLnRhYmxlSGVpZ2h0KTtcbiAgfVxuXG59XG4iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBGaXhlZEhlYWRlclRhYmxlRGlyZWN0aXZlIH0gZnJvbSAnLi9maXhlZC1oZWFkZXItdGFibGUuZGlyZWN0aXZlJztcblxuQE5nTW9kdWxlKHtcbiAgICBleHBvcnRzOiBbRml4ZWRIZWFkZXJUYWJsZURpcmVjdGl2ZV0sXG4gICAgZGVjbGFyYXRpb25zOiBbRml4ZWRIZWFkZXJUYWJsZURpcmVjdGl2ZV1cbn0pXG5leHBvcnQgY2xhc3MgRml4ZWRIZWFkZXJUYWJsZU1vZHVsZSB7IH1cbiIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSG9zdEJpbmRpbmcsIElucHV0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSwgT25Jbml0LCBSZW5kZXJlcjIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbdXhGbG9hdExhYmVsXScsXG4gICAgaG9zdDoge1xuICAgICAgICAnY2xhc3MnOiAndXgtZmxvYXQtbGFiZWwnXG4gICAgfVxufSlcbmV4cG9ydCBjbGFzcyBGbG9hdExhYmVsRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSB7XG5cbiAgICBASW5wdXQoJ3V4RmxvYXRMYWJlbCcpXG4gICAgaW5wdXQ6IEhUTUxJbnB1dEVsZW1lbnQ7XG5cbiAgICBASW5wdXQoKVxuICAgIHZhbHVlOiBhbnk7XG5cbiAgICBASW5wdXQoKVxuICAgIG1vZGU6ICdmb2N1cycgfCAnaW5wdXQnID0gJ2ZvY3VzJztcblxuICAgIEBIb3N0QmluZGluZygnY2xhc3MudXgtZmxvYXQtbGFiZWwtcmFpc2VkJylcbiAgICByYWlzZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuXG4gICAgcHJpdmF0ZSBfZm9jdXNlZCA9IGZhbHNlO1xuICAgIHByaXZhdGUgX2V2ZW50SGFuZGxlczogYW55W10gPSBbXTtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIHByaXZhdGUgX3JlbmRlcmVyOiBSZW5kZXJlcjIpIHsgfVxuXG4gICAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2V2ZW50SGFuZGxlcy5wdXNoKFxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIubGlzdGVuKHRoaXMuaW5wdXQsICdmb2N1cycsIHRoaXMuaW5wdXRGb2N1cy5iaW5kKHRoaXMpKSxcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmxpc3Rlbih0aGlzLmlucHV0LCAnYmx1cicsIHRoaXMuaW5wdXRCbHVyLmJpbmQodGhpcykpLFxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIubGlzdGVuKHRoaXMuaW5wdXQsICdpbnB1dCcsIHRoaXMuaW5wdXRDaGFuZ2UuYmluZCh0aGlzKSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBDaGVjayBpbml0aWFsIGlucHV0IHZhbHVlXG4gICAgICAgIHRoaXMucmFpc2VkID0gdGhpcy5oYXNUZXh0KCk7XG5cbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIGBmb3JgIGF0dHJpYnV0ZSBpcyBzZXRcbiAgICAgICAgaWYgKCF0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuZ2V0QXR0cmlidXRlKCdmb3InKSAmJiB0aGlzLmlucHV0LmdldEF0dHJpYnV0ZSgnaWQnKSkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0QXR0cmlidXRlKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2ZvcicsIHRoaXMuaW5wdXQuZ2V0QXR0cmlidXRlKCdpZCcpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5nT25DaGFuZ2VzKCk6IHZvaWQge1xuICAgICAgICBpZiAoISh0aGlzLm1vZGUgPT09ICdmb2N1cycgJiYgdGhpcy5fZm9jdXNlZCkpIHtcbiAgICAgICAgICAgIHRoaXMucmFpc2VkID0gdGhpcy5oYXNUZXh0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgLy8gVW5zdWJzY3JpYmUgZXZlbnQgaGFuZGxlc1xuICAgICAgICB0aGlzLl9ldmVudEhhbmRsZXMuZm9yRWFjaCgoZXZlbnRIYW5kbGUpID0+IGV2ZW50SGFuZGxlKCkpO1xuICAgIH1cblxuICAgIHByaXZhdGUgaGFzVGV4dCgpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuICEhdGhpcy5pbnB1dC52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gISF0aGlzLnZhbHVlO1xuICAgIH1cblxuICAgIHByaXZhdGUgaW5wdXRGb2N1cygpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gJ2ZvY3VzJykge1xuICAgICAgICAgICAgdGhpcy5fZm9jdXNlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnJhaXNlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGlucHV0Qmx1cigpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gJ2ZvY3VzJykge1xuICAgICAgICAgICAgdGhpcy5fZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5yYWlzZWQgPSB0aGlzLmhhc1RleHQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgaW5wdXRDaGFuZ2UoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLm1vZGUgPT09ICdpbnB1dCcpIHtcbiAgICAgICAgICAgIHRoaXMucmFpc2VkID0gdGhpcy5oYXNUZXh0KCk7XG4gICAgICAgIH1cbiAgICB9XG59IiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgRmxvYXRMYWJlbERpcmVjdGl2ZSB9IGZyb20gJy4vZmxvYXQtbGFiZWwuZGlyZWN0aXZlJztcblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbXSxcbiAgICBleHBvcnRzOiBbRmxvYXRMYWJlbERpcmVjdGl2ZV0sXG4gICAgZGVjbGFyYXRpb25zOiBbRmxvYXRMYWJlbERpcmVjdGl2ZV0sXG4gICAgcHJvdmlkZXJzOiBbXSxcbn0pXG5leHBvcnQgY2xhc3MgRmxvYXRMYWJlbE1vZHVsZSB7IH1cbiIsImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIEhlbHBDZW50ZXJTZXJ2aWNlIHtcblxuICAgIGl0ZW1zOiBCZWhhdmlvclN1YmplY3Q8SGVscENlbnRlckl0ZW1bXT4gPSBuZXcgQmVoYXZpb3JTdWJqZWN0PEhlbHBDZW50ZXJJdGVtW10+KFtdKTtcblxuICAgIHJlZ2lzdGVySXRlbShpdGVtOiBIZWxwQ2VudGVySXRlbSk6IHZvaWQge1xuXG4gICAgICAgIC8vIGdldCB0aGUgY3VycmVudCBpdGVtc1xuICAgICAgICBsZXQgaXRlbXMgPSB0aGlzLml0ZW1zLmdldFZhbHVlKCk7XG5cbiAgICAgICAgLy8gYWRkIHRoZSBuZXcgaXRlbSB0byB0aGUgbGlzdFxuICAgICAgICBpdGVtcy5wdXNoKGl0ZW0pO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgb2JzZXJ2YWJsZVxuICAgICAgICB0aGlzLml0ZW1zLm5leHQoaXRlbXMpO1xuICAgIH1cblxuICAgIHVucmVnaXN0ZXJJdGVtKGl0ZW06IEhlbHBDZW50ZXJJdGVtKTogdm9pZCB7XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBjdXJyZW50IGl0ZW1zXG4gICAgICAgIGxldCBpdGVtcyA9IHRoaXMuaXRlbXMuZ2V0VmFsdWUoKTtcblxuICAgICAgICAvLyByZW1vdmUgdGhlIGl0ZW0gYmVpbmcgdW5yZWdpc3RlcmVkXG4gICAgICAgIGl0ZW1zID0gaXRlbXMuZmlsdGVyKGl0bSA9PiBpdG0gIT09IGl0ZW0pO1xuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgb2JzZXJ2YWJsZVxuICAgICAgICB0aGlzLml0ZW1zLm5leHQoaXRlbXMpO1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBIZWxwQ2VudGVySXRlbSB7XG4gICAgaWNvbj86IHN0cmluZztcbiAgICB0aXRsZTogc3RyaW5nO1xuICAgIHNlbGVjdD86ICgpID0+IHZvaWQ7XG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBJbnB1dCwgT25Jbml0LCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEhlbHBDZW50ZXJTZXJ2aWNlLCBIZWxwQ2VudGVySXRlbSB9IGZyb20gJy4vaGVscC1jZW50ZXIuc2VydmljZSc7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1t1eEhlbHBDZW50ZXJJdGVtXScgfSlcbmV4cG9ydCBjbGFzcyBIZWxwQ2VudGVySXRlbURpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcblxuICAgIEBJbnB1dCgpIHV4SGVscENlbnRlckl0ZW06IEhlbHBDZW50ZXJJdGVtO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfaGVscENlbnRlclNlcnZpY2U6IEhlbHBDZW50ZXJTZXJ2aWNlKSB7IH1cblxuICAgIG5nT25Jbml0KCk6IHZvaWQge1xuXG4gICAgICAgIC8vIHJlZ2lzdGVyIHRoZSBpdGVtIGluIHRoZSBzZXJ2aWNlXG4gICAgICAgIHRoaXMuX2hlbHBDZW50ZXJTZXJ2aWNlLnJlZ2lzdGVySXRlbSh0aGlzLnV4SGVscENlbnRlckl0ZW0pO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICAvLyByZW1vdmUgdGhpcyBpdGVtIHdoZW4gaXQgaXMgZGVzdHJveWVkXG4gICAgICAgIHRoaXMuX2hlbHBDZW50ZXJTZXJ2aWNlLnVucmVnaXN0ZXJJdGVtKHRoaXMudXhIZWxwQ2VudGVySXRlbSk7XG4gICAgfVxufSIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBIZWxwQ2VudGVySXRlbURpcmVjdGl2ZSB9IGZyb20gJy4vaGVscC1jZW50ZXItaXRlbS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgSGVscENlbnRlclNlcnZpY2UgfSBmcm9tICcuL2hlbHAtY2VudGVyLnNlcnZpY2UnO1xuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtdLFxuICAgIGV4cG9ydHM6IFtIZWxwQ2VudGVySXRlbURpcmVjdGl2ZV0sXG4gICAgZGVjbGFyYXRpb25zOiBbSGVscENlbnRlckl0ZW1EaXJlY3RpdmVdLFxuICAgIHByb3ZpZGVyczogW0hlbHBDZW50ZXJTZXJ2aWNlXSxcbn0pXG5leHBvcnQgY2xhc3MgSGVscENlbnRlck1vZHVsZSB7IH1cbiIsImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcbmltcG9ydCB7IEhvdmVyQWN0aW9uQ29udGFpbmVyRGlyZWN0aXZlIH0gZnJvbSAnLi9ob3Zlci1hY3Rpb24tY29udGFpbmVyLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBIb3ZlckFjdGlvbkRpcmVjdGl2ZSB9IGZyb20gJy4vaG92ZXItYWN0aW9uLmRpcmVjdGl2ZSc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBIb3ZlckFjdGlvblNlcnZpY2Uge1xuXG4gICAgYWN0aXZlOiBCZWhhdmlvclN1YmplY3Q8Ym9vbGVhbj4gPSBuZXcgQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+KGZhbHNlKTtcblxuICAgIHByaXZhdGUgX2NvbnRhaW5lcjogSG92ZXJBY3Rpb25Db250YWluZXJEaXJlY3RpdmU7XG4gICAgcHJpdmF0ZSBfZm9jdXNlZDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIHByaXZhdGUgX2hvdmVyZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBwcml2YXRlIF9hY3Rpb25zOiBIb3ZlckFjdGlvbkRpcmVjdGl2ZVtdID0gW107XG5cbiAgICByZWdpc3RlcihhY3Rpb246IEhvdmVyQWN0aW9uRGlyZWN0aXZlKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2FjdGlvbnMucHVzaChhY3Rpb24pO1xuICAgIH1cblxuICAgIHVucmVnaXN0ZXIoYWN0aW9uOiBIb3ZlckFjdGlvbkRpcmVjdGl2ZSk6IHZvaWQge1xuICAgICAgICB0aGlzLl9hY3Rpb25zID0gdGhpcy5fYWN0aW9ucy5maWx0ZXIoYWN0biA9PiBhY3RuICE9PSBhY3Rpb24pO1xuICAgIH1cblxuICAgIHNldENvbnRhaW5lcihjb250YWluZXI6IEhvdmVyQWN0aW9uQ29udGFpbmVyRGlyZWN0aXZlKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB9XG5cbiAgICBzZXRGb2N1c1N0YXRlKGZvY3VzOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2ZvY3VzZWQgPSBmb2N1cztcbiAgICAgICAgdGhpcy51cGRhdGVWaXNpYmlsaXR5KCk7XG4gICAgfVxuXG4gICAgc2V0SG92ZXJTdGF0ZShob3ZlcjogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICB0aGlzLl9ob3ZlcmVkID0gaG92ZXI7XG4gICAgICAgIHRoaXMudXBkYXRlVmlzaWJpbGl0eSgpO1xuICAgIH1cblxuICAgIG5leHQoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gaWYgY29udGFpbmVyIGhhcyBmb2N1cyB0aGVuIGZvY3VzIHRoZSBmaXJzdCBob3ZlciBhY3Rpb25cbiAgICAgICAgaWYgKHRoaXMuY29udGFpbmVySGFzRm9jdXMoKSkge1xuICAgICAgICAgICAgdGhpcy5mb2N1c0FjdGlvbkF0SW5kZXgoMCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVWaXNpYmlsaXR5KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBhIGhvdmVyIGFjdGlvbiBoYXMgZm9jdXMgdGhlbiBmb2N1cyB0aGUgbmV4dCBhY3Rpb25cbiAgICAgICAgaWYgKHRoaXMuYWN0aW9uSGFzRm9jdXMoKSkge1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5nZXRGb2N1c2VkQWN0aW9uSW5kZXgoKSArIDE7XG4gICAgICAgICAgICB0aGlzLmZvY3VzQWN0aW9uQXRJbmRleChpbmRleCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZpc2liaWxpdHkoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByZXZpb3VzKCk6IHZvaWQge1xuICAgICAgICAvLyBpZiBhIGhvdmVyIGFjdGlvbiBoYXMgZm9jdXMgdGhlbiBmb2N1cyB0aGUgcHJldmlvdXMgYWN0aW9uXG4gICAgICAgIGlmICh0aGlzLmFjdGlvbkhhc0ZvY3VzKCkpIHtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IHRoaXMuZ2V0Rm9jdXNlZEFjdGlvbkluZGV4KCkgLSAxO1xuXG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZm9jdXNBY3Rpb25BdEluZGV4KGluZGV4KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGFpbmVyLmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwZGF0ZVZpc2liaWxpdHkoKTtcbiAgICB9XG5cbiAgICB1cGRhdGVWaXNpYmlsaXR5KCk6IHZvaWQge1xuICAgICAgICB0aGlzLmFjdGl2ZS5uZXh0KHRoaXMuX2ZvY3VzZWQgfHwgdGhpcy5faG92ZXJlZCB8fCB0aGlzLmFjdGlvbkhhc0ZvY3VzKCkpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZm9jdXNBY3Rpb25BdEluZGV4KGluZGV4OiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLl9hY3Rpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5fYWN0aW9uc1tpbmRleF0uZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0Rm9jdXNlZEFjdGlvbkluZGV4KCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hY3Rpb25zLmZpbmRJbmRleChhY3Rpb24gPT4gYWN0aW9uID09PSB0aGlzLmdldEZvY3VzZWRBY3Rpb24oKSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjb250YWluZXJIYXNGb2N1cygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZvY3VzZWQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhY3Rpb25IYXNGb2N1cygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5nZXRGb2N1c2VkQWN0aW9uKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRGb2N1c2VkQWN0aW9uKCk6IEhvdmVyQWN0aW9uRGlyZWN0aXZlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGlvbnMuZmluZChhY3Rpb24gPT4gYWN0aW9uLmZvY3VzZWQpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEhvc3RMaXN0ZW5lciwgSW5wdXQsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcy9TdWJzY3JpcHRpb24nO1xuaW1wb3J0IHsgSG92ZXJBY3Rpb25TZXJ2aWNlIH0gZnJvbSAnLi9ob3Zlci1hY3Rpb24uc2VydmljZSc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3V4SG92ZXJBY3Rpb25Db250YWluZXJdJyxcbiAgICBwcm92aWRlcnM6IFtIb3ZlckFjdGlvblNlcnZpY2VdLFxuICAgIGhvc3Q6IHtcbiAgICAgICAgJ1tjbGFzcy5ob3Zlci1hY3Rpb24tY29udGFpbmVyLWFjdGl2ZV0nOiAnYWN0aXZlJyxcbiAgICAgICAgJ1t0YWJpbmRleF0nOiAndGFiaW5kZXgnXG4gICAgfVxufSlcbmV4cG9ydCBjbGFzcyBIb3ZlckFjdGlvbkNvbnRhaW5lckRpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG5cbiAgICBASW5wdXQoKSB0YWJpbmRleDogbnVtYmVyID0gMDtcbiAgICBhY3RpdmU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIHByaXZhdGUgYWN0aXZlJDogU3Vic2NyaXB0aW9uO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZiwgcHJpdmF0ZSBfaG92ZXJBY3Rpb25TZXJ2aWNlOiBIb3ZlckFjdGlvblNlcnZpY2UpIHtcbiAgICAgICAgLy8gcmVnaXN0ZXIgdGhlIGNvbnRhaW5lciBlbGVtZW50IHdpdGggdGhlIHNlcnZpY2VcbiAgICAgICAgdGhpcy5faG92ZXJBY3Rpb25TZXJ2aWNlLnNldENvbnRhaW5lcih0aGlzKTtcblxuICAgICAgICAvLyBhcHBseSBhIGNsYXNzIGJhc2VkIG9uIHRoZSBhY3RpdmUgc3RhdGUgb2YgdGhlIGNvbnRhaW5lciBhbmQgaXQncyBhY3Rpb25zXG4gICAgICAgIHRoaXMuYWN0aXZlJCA9IHRoaXMuX2hvdmVyQWN0aW9uU2VydmljZS5hY3RpdmUuc3Vic2NyaWJlKGFjdGl2ZSA9PiB0aGlzLmFjdGl2ZSA9IGFjdGl2ZSk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuYWN0aXZlJC51bnN1YnNjcmliZSgpO1xuICAgIH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ2NsaWNrJykgZm9jdXMoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgIH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ2ZvY3VzJykgb25Gb2N1cygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5faG92ZXJBY3Rpb25TZXJ2aWNlLnNldEZvY3VzU3RhdGUodHJ1ZSk7XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcignYmx1cicpIG9uQmx1cigpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5faG92ZXJBY3Rpb25TZXJ2aWNlLnNldEZvY3VzU3RhdGUoZmFsc2UpO1xuICAgIH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ21vdXNlZW50ZXInKSBvbkhvdmVyKCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9ob3ZlckFjdGlvblNlcnZpY2Uuc2V0SG92ZXJTdGF0ZSh0cnVlKTtcbiAgICB9XG5cbiAgICBASG9zdExpc3RlbmVyKCdtb3VzZWxlYXZlJykgb25MZWF2ZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5faG92ZXJBY3Rpb25TZXJ2aWNlLnNldEhvdmVyU3RhdGUoZmFsc2UpO1xuICAgIH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ2tleWRvd24uYXJyb3dyaWdodCcpIG5leHQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2hvdmVyQWN0aW9uU2VydmljZS5uZXh0KCk7XG4gICAgfVxufSIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSG9zdExpc3RlbmVyLCBPbkRlc3Ryb3ksIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBIb3ZlckFjdGlvblNlcnZpY2UgfSBmcm9tICcuL2hvdmVyLWFjdGlvbi5zZXJ2aWNlJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMvU3Vic2NyaXB0aW9uJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbdXhIb3ZlckFjdGlvbl0nLFxuICAgIGhvc3Q6IHtcbiAgICAgICAgJ1tjbGFzcy5ob3Zlci1hY3Rpb24tYWN0aXZlXSc6ICdhY3RpdmUnLFxuICAgICAgICAnW2NsYXNzLmhvdmVyLWFjdGlvbi1mb2N1c2VkXSc6ICdmb2N1c2VkJyxcbiAgICAgICAgJ1t0YWJpbmRleF0nOiAndGFiaW5kZXgnXG4gICAgfVxufSlcbmV4cG9ydCBjbGFzcyBIb3ZlckFjdGlvbkRpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG5cbiAgICBASW5wdXQoKSB0YWJpbmRleDogbnVtYmVyID0gMTtcbiAgICBhY3RpdmU6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBmb2N1c2VkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBwcml2YXRlIGFjdGl2ZSQ6IFN1YnNjcmlwdGlvbjtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIHByaXZhdGUgX2hvdmVyQWN0aW9uU2VydmljZTogSG92ZXJBY3Rpb25TZXJ2aWNlKSB7XG5cbiAgICAgICAgLy8gcmVnaXN0ZXIgdGhlIGFjdGlvblxuICAgICAgICB0aGlzLl9ob3ZlckFjdGlvblNlcnZpY2UucmVnaXN0ZXIodGhpcyk7XG5cbiAgICAgICAgLy8gd2F0Y2ggZm9yIGNoYW5nZXMgdG8gdGhlIGFjdGl2ZW5lc3Mgb2YgdGhlIGNvbnRhaW5lclxuICAgICAgICB0aGlzLmFjdGl2ZSQgPSB0aGlzLl9ob3ZlckFjdGlvblNlcnZpY2UuYWN0aXZlLnN1YnNjcmliZShhY3RpdmUgPT4gdGhpcy5hY3RpdmUgPSBhY3RpdmUpO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9ob3ZlckFjdGlvblNlcnZpY2UudW5yZWdpc3Rlcih0aGlzKTtcbiAgICAgICAgdGhpcy5hY3RpdmUkLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuXG4gICAgZm9jdXMoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgIH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ2ZvY3VzJykgb25Gb2N1cygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5mb2N1c2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5faG92ZXJBY3Rpb25TZXJ2aWNlLnVwZGF0ZVZpc2liaWxpdHkoKTtcbiAgICB9XG5cbiAgICBASG9zdExpc3RlbmVyKCdibHVyJykgb25CbHVyKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faG92ZXJBY3Rpb25TZXJ2aWNlLnVwZGF0ZVZpc2liaWxpdHkoKTtcbiAgICB9XG5cbiAgICBASG9zdExpc3RlbmVyKCdrZXlkb3duLmFycm93bGVmdCcsIFsnJGV2ZW50J10pIHByZXZpb3VzKGV2ZW50OiBNb3VzZUV2ZW50KTogdm9pZCB7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpOyAgICAgICAgXG4gICAgICAgIHRoaXMuX2hvdmVyQWN0aW9uU2VydmljZS5wcmV2aW91cygpO1xuICAgIH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ2tleWRvd24uYXJyb3dyaWdodCcsIFsnJGV2ZW50J10pIG5leHQoZXZlbnQ6IE1vdXNlRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHRoaXMuX2hvdmVyQWN0aW9uU2VydmljZS5uZXh0KCk7XG4gICAgfVxufSIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBIb3ZlckFjdGlvbkNvbnRhaW5lckRpcmVjdGl2ZSB9IGZyb20gJy4vaG92ZXItYWN0aW9uLWNvbnRhaW5lci5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgSG92ZXJBY3Rpb25EaXJlY3RpdmUgfSBmcm9tICcuL2hvdmVyLWFjdGlvbi5kaXJlY3RpdmUnO1xuXG5jb25zdCBERUNMQVJBVElPTlMgPSBbXG4gICAgSG92ZXJBY3Rpb25EaXJlY3RpdmUsXG4gICAgSG92ZXJBY3Rpb25Db250YWluZXJEaXJlY3RpdmVcbl07XG5cbkBOZ01vZHVsZSh7XG4gICAgZXhwb3J0czogREVDTEFSQVRJT05TLFxuICAgIGRlY2xhcmF0aW9uczogREVDTEFSQVRJT05TXG59KVxuZXhwb3J0IGNsYXNzIEhvdmVyQWN0aW9uTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbWJlZGRlZFZpZXdSZWYsIElucHV0LCBUZW1wbGF0ZVJlZiwgVmlld0NvbnRhaW5lclJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1t1eExheW91dFN3aXRjaGVySXRlbV0nXG59KVxuZXhwb3J0IGNsYXNzIExheW91dFN3aXRjaGVySXRlbURpcmVjdGl2ZSB7XG5cbiAgICBASW5wdXQoJ3V4TGF5b3V0U3dpdGNoZXJJdGVtJykgcHJpdmF0ZSBfY29uZmlnOiBMYXlvdXRTd2l0Y2hlckl0ZW07XG5cbiAgICBwcml2YXRlIF9lbWJlZGRlZFZpZXc6IEVtYmVkZGVkVmlld1JlZjxhbnk+O1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfdGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPGFueT4sIHByaXZhdGUgX3ZpZXdDb250YWluZXJSZWY6IFZpZXdDb250YWluZXJSZWYpIHsgfVxuXG4gICAgZ2V0TGF5b3V0KCk6IFRlbXBsYXRlUmVmPGFueT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGVtcGxhdGVSZWY7XG4gICAgfVxuXG4gICAgZ2V0Q29uZmlnKCk6IExheW91dFN3aXRjaGVySXRlbSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25maWc7XG4gICAgfVxuXG4gICAgYWN0aXZhdGUoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2VtYmVkZGVkVmlldyA9IHRoaXMuX3ZpZXdDb250YWluZXJSZWYuY3JlYXRlRW1iZWRkZWRWaWV3KHRoaXMuX3RlbXBsYXRlUmVmKTtcbiAgICB9XG5cbiAgICBkZWFjdGl2YXRlKCk6IHZvaWQge1xuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLl92aWV3Q29udGFpbmVyUmVmLmluZGV4T2YodGhpcy5fZW1iZWRkZWRWaWV3KTtcbiAgICAgICAgdGhpcy5fdmlld0NvbnRhaW5lclJlZi5yZW1vdmUoaW5kZXgpO1xuICAgICAgICB0aGlzLl9lbWJlZGRlZFZpZXcgPSBudWxsO1xuICAgIH1cblxufVxuXG5leHBvcnQgaW50ZXJmYWNlIExheW91dFN3aXRjaGVySXRlbSB7XG4gICAgZ3JvdXA/OiBzdHJpbmc7XG4gICAgbWluV2lkdGg/OiBudW1iZXI7XG4gICAgbWF4V2lkdGg/OiBudW1iZXI7XG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBRdWVyeUxpc3QsIENvbnRlbnRDaGlsZHJlbiwgSW5wdXQsIEFmdGVyQ29udGVudEluaXQsIFZpZXdDb250YWluZXJSZWYsIE9uQ2hhbmdlcywgU2ltcGxlQ2hhbmdlcyB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUmVzaXplU2VydmljZSB9IGZyb20gJy4uL3Jlc2l6ZS9pbmRleCc7XG5pbXBvcnQgeyBMYXlvdXRTd2l0Y2hlckl0ZW1EaXJlY3RpdmUgfSBmcm9tICcuL2xheW91dC1zd2l0Y2hlci1pdGVtLmRpcmVjdGl2ZSc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3V4TGF5b3V0U3dpdGNoZXJdJ1xufSlcbmV4cG9ydCBjbGFzcyBMYXlvdXRTd2l0Y2hlckRpcmVjdGl2ZSBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQsIE9uQ2hhbmdlcyB7XG5cbiAgICBASW5wdXQoKSBncm91cDogc3RyaW5nO1xuICAgIEBDb250ZW50Q2hpbGRyZW4oTGF5b3V0U3dpdGNoZXJJdGVtRGlyZWN0aXZlKSBwcml2YXRlIF9sYXlvdXRzOiBRdWVyeUxpc3Q8TGF5b3V0U3dpdGNoZXJJdGVtRGlyZWN0aXZlPjtcbiAgICBcbiAgICBwcml2YXRlIF93aWR0aDogbnVtYmVyO1xuICAgIHByaXZhdGUgX2FjdGl2ZUxheW91dDogTGF5b3V0U3dpdGNoZXJJdGVtRGlyZWN0aXZlO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZiwgcmVzaXplU2VydmljZTogUmVzaXplU2VydmljZSxcbiAgICAgICAgcHJpdmF0ZSBfdmlld0NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZikge1xuXG4gICAgICAgIC8vIHdhdGNoIGZvciBjaGFuZ2VzIHRvIHRoZSBjb250YWluZXIgc2l6ZVxuICAgICAgICByZXNpemVTZXJ2aWNlLmFkZFJlc2l6ZUxpc3RlbmVyKF9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpLnN1YnNjcmliZShldmVudCA9PiB7XG4gICAgICAgICAgICB0aGlzLl93aWR0aCA9IGV2ZW50LndpZHRoO1xuXG4gICAgICAgICAgICAvLyByZW5kZXIgdGhlIGFwcHJvcHJpYXRlIGxheW91dFxuICAgICAgICAgICAgdGhpcy51cGRhdGVBY3RpdmVMYXlvdXQoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xuXG4gICAgICAgIC8vIGlmIHRoZSBhY3RpdmUgZ3JvdXAgaGFzIGNoYW5nZWQgdGhlbiByZW5kZXIgdGhlIGFwcHJvcHJpYXRlIGxheW91dFxuICAgICAgICBpZiAoY2hhbmdlcy5ncm91cC5jdXJyZW50VmFsdWUgIT09IGNoYW5nZXMuZ3JvdXAucHJldmlvdXNWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVBY3RpdmVMYXlvdXQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldEFjdGl2ZUxheW91dCgpOiBMYXlvdXRTd2l0Y2hlckl0ZW1EaXJlY3RpdmUgfCBudWxsIHtcblxuICAgICAgICAvLyBpZiB0aGVyZSBhcmUgY3VycmVudGx5IG5vIGxheW91dHMgdGhlbiBkbyBub3RoaW5nXG4gICAgICAgIGlmICghdGhpcy5fbGF5b3V0cykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvdGhlcndpc2UgZmluZCBsYXlvdXRzIHRoYXQgbWF0Y2ggdGhlIGFjdGl2ZSBncm91cCBhbmQgdGhhdCBtZWV0IHRoZSBjb25zdHJhaW50c1xuICAgICAgICByZXR1cm4gdGhpcy5fbGF5b3V0cy5maWx0ZXIobGF5b3V0ID0+IHRoaXMuZ3JvdXAgPT09IGxheW91dC5nZXRDb25maWcoKS5ncm91cCkuZmluZChsYXlvdXQgPT4ge1xuXG4gICAgICAgICAgICBsZXQgbWluV2lkdGggPSBsYXlvdXQuZ2V0Q29uZmlnKCkubWluV2lkdGggfHwgMDtcbiAgICAgICAgICAgIGxldCBtYXhXaWR0aCA9IGxheW91dC5nZXRDb25maWcoKS5tYXhXaWR0aCB8fCBJbmZpbml0eTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dpZHRoID49IG1pbldpZHRoICYmIHRoaXMuX3dpZHRoIDwgbWF4V2lkdGg7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHVwZGF0ZUFjdGl2ZUxheW91dCgpOiB2b2lkIHtcblxuICAgICAgICAvLyBnZXQgdGhlIGxheW91dCB0aGF0IHNob3VsZCBiZSBzaG93blxuICAgICAgICBsZXQgbGF5b3V0ID0gdGhpcy5nZXRBY3RpdmVMYXlvdXQoKTtcblxuICAgICAgICAvLyBjaGVjayBpZiB3ZSBhcmUgY3VycmVudGx5IHNob3dpbmcgdGhlIGxheW91dFxuICAgICAgICBpZiAodGhpcy5fYWN0aXZlTGF5b3V0ID09PSBsYXlvdXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbW92ZSB0aGUgY3VycmVudCBsYXlvdXRcbiAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZUxheW91dCkge1xuICAgICAgICAgICAgdGhpcy5fYWN0aXZlTGF5b3V0LmRlYWN0aXZhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHN0b3JlIHRoZSBuZXcgYWN0aXZlIGxheW91dFxuICAgICAgICB0aGlzLl9hY3RpdmVMYXlvdXQgPSBsYXlvdXQ7XG5cbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgYW4gYWN0aXZlIGxheW91dCB0aGVuIGFjdGl2YXRlXG4gICAgICAgIGlmICh0aGlzLl9hY3RpdmVMYXlvdXQpIHtcbiAgICAgICAgICAgIHRoaXMuX2FjdGl2ZUxheW91dC5hY3RpdmF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCk6IHZvaWQge1xuXG4gICAgICAgIC8vIHN0b3JlIHRoZSBpbml0aWFsIGN1cnJlbnQgZWxlbWVudCB3aWR0aFxuICAgICAgICB0aGlzLl93aWR0aCA9IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aDtcblxuICAgICAgICAvLyByZW5kZXIgdGhlIGFwcHJvcHJpYXRlIGxheW91dCAtIG5lZWQgYSBkZWxheSBhcyBBbmd1bGFyIGRvZXNuJ3QgbGlrZSBjaGFuZ2VzIGxpa2UgdGhpcyBpbiB0aGVzZSBsaWZlY3ljbGUgaG9va3NcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMudXBkYXRlQWN0aXZlTGF5b3V0LmJpbmQodGhpcykpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTGF5b3V0U3dpdGNoZXJEaXJlY3RpdmUgfSBmcm9tICcuL2xheW91dC1zd2l0Y2hlci5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgTGF5b3V0U3dpdGNoZXJJdGVtRGlyZWN0aXZlIH0gZnJvbSAnLi9sYXlvdXQtc3dpdGNoZXItaXRlbS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgUmVzaXplTW9kdWxlIH0gZnJvbSAnLi4vcmVzaXplL2luZGV4JztcblxuY29uc3QgREVDTEFSQVRJT05TID0gW1xuICAgIExheW91dFN3aXRjaGVyRGlyZWN0aXZlLFxuICAgIExheW91dFN3aXRjaGVySXRlbURpcmVjdGl2ZVxuXTtcblxuQE5nTW9kdWxlKHtcbiAgICBpbXBvcnRzOiBbXG4gICAgICAgIFJlc2l6ZU1vZHVsZVxuICAgIF0sXG4gICAgZXhwb3J0czogREVDTEFSQVRJT05TLFxuICAgIGRlY2xhcmF0aW9uczogREVDTEFSQVRJT05TLFxuICAgIHByb3ZpZGVyczogW10sXG59KVxuZXhwb3J0IGNsYXNzIExheW91dFN3aXRjaGVyTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgQWZ0ZXJWaWV3SW5pdCwgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIElucHV0LCBPbkRlc3Ryb3ksIE9uSW5pdCwgT3V0cHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcy9PYnNlcnZhYmxlJztcbmltcG9ydCB7IHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzL1N1YmplY3QnO1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbdXhPdmVyZmxvd09ic2VydmVyXSwgW3V4T3ZlcmZsb3dIb3Jpem9udGFsT2JzZXJ2ZXJdLCBbdXhPdmVyZmxvd1ZlcnRpY2FsT2JzZXJ2ZXJdJyxcbiAgZXhwb3J0QXM6ICd1eC1vdmVyZmxvdy1vYnNlcnZlcidcbn0pXG5leHBvcnQgY2xhc3MgT3ZlcmZsb3dEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIEFmdGVyVmlld0luaXQsIE9uRGVzdHJveSB7XG5cbiAgLyoqIEFsbG93IGEgb2JzZXJ2YWJsZSB0byBiZSB1c2VkIHRvIGNoZWNrIGZvciBvdmVyZmxvdyAqL1xuICBASW5wdXQoKSB0cmlnZ2VyOiBPYnNlcnZhYmxlPHZvaWQ+O1xuXG4gIC8qKiBBbGxvdyBvdmVyZmxvdyB0byBiZSB3aXRoaW4gYSByYW5nZSBiZWZvcmUgZW1pdHRpbmcgKi9cbiAgQElucHV0KCkgdG9sZXJhbmNlOiBudW1iZXIgPSAwO1xuXG4gIC8qKiBFbWl0IHdoZW4gdGhlcmUgaXMgYSBjaGFuZ2UgdG8gdGhlIG92ZXJmbG93IHN0YXRlIC0gaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCAqL1xuICBAT3V0cHV0KCkgdXhPdmVyZmxvd09ic2VydmVyID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG4gIC8qKiBFbWl0IHdoZW4gdGhlcmUgaXMgYSBjaGFuZ2UgdG8gb3ZlcmZsb3cgb24gdGhlIGhvcml6b250YWwgYXhpcyAqL1xuICBAT3V0cHV0KCkgdXhPdmVyZmxvd0hvcml6b250YWxPYnNlcnZlciA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oKTtcblxuICAvKiogRW1pdCB3aGVuIHRoZXJlIGlzIGEgY2hhbmdlIHRvIG92ZXJmbG93IG9uIHRoZSB2ZXJ0aWNhbCBheGlzICovXG4gIEBPdXRwdXQoKSB1eE92ZXJmbG93VmVydGljYWxPYnNlcnZlciA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oKTtcblxuICAvKiogU3RvcmUgdGhlIG92ZXJmbG93IHN0YXRlIG9uIGJvdGggYXhpcyAqL1xuICBwcml2YXRlIF9zdGF0ZSA9IHsgaG9yaXpvbnRhbE92ZXJmbG93OiBmYWxzZSwgdmVydGljYWxPdmVyZmxvdzogZmFsc2UgfTtcblxuICAvKiogVW5zdWJzY3JpYmUgZnJvbSBhbGwgdGhlIG9ic2VydmFibGVzICovXG4gIHByaXZhdGUgX29uRGVzdHJveSA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZikgeyB9XG5cbiAgLyoqIFNldCB1cCB0aGUgdHJpZ2dlciBpZiBzcGVjaWZpZWQgKi9cbiAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMudHJpZ2dlcikge1xuICAgICAgdGhpcy50cmlnZ2VyLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZSgoKSA9PiB0aGlzLmNoZWNrRm9yT3ZlcmZsb3coKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqIFBlcmZvcm0gYW4gaW50aWFsIGNoZWNrIGZvciBvdmVyZmxvdyAqL1xuICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMuY2hlY2tGb3JPdmVyZmxvdygpKTtcbiAgfVxuXG4gIC8qKiBVbnN1YnNjcmliZSBmcm9tIHRoZSB0cmlnZ2VyICovXG4gIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMuX29uRGVzdHJveS5uZXh0KCk7XG4gICAgdGhpcy5fb25EZXN0cm95LmNvbXBsZXRlKCk7XG4gIH1cblxuICAvKiogUHJvZ3JhbW1hdGljYWxseSB0cmlnZ2VyIGNoZWNrIGZvciBvdmVyZmxvdyAqL1xuICBjaGVja0Zvck92ZXJmbG93KCk6IHZvaWQge1xuXG4gICAgY29uc3QgeyBvZmZzZXRXaWR0aCwgb2Zmc2V0SGVpZ2h0LCBzY3JvbGxXaWR0aCwgc2Nyb2xsSGVpZ2h0IH0gPSB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgY29uc3QgaG9yaXpvbnRhbE92ZXJmbG93ID0gKHNjcm9sbFdpZHRoIC0gb2Zmc2V0V2lkdGgpID4gdGhpcy50b2xlcmFuY2U7XG4gICAgY29uc3QgdmVydGljYWxPdmVyZmxvdyA9IChzY3JvbGxIZWlnaHQgLSBvZmZzZXRIZWlnaHQpID4gdGhpcy50b2xlcmFuY2U7XG5cbiAgICBpZiAoaG9yaXpvbnRhbE92ZXJmbG93ICE9PSB0aGlzLl9zdGF0ZS5ob3Jpem9udGFsT3ZlcmZsb3cpIHtcbiAgICAgIHRoaXMudXhPdmVyZmxvd0hvcml6b250YWxPYnNlcnZlci5lbWl0KGhvcml6b250YWxPdmVyZmxvdyk7XG4gICAgfVxuXG4gICAgaWYgKHZlcnRpY2FsT3ZlcmZsb3cgIT09IHRoaXMuX3N0YXRlLnZlcnRpY2FsT3ZlcmZsb3cpIHtcbiAgICAgIHRoaXMudXhPdmVyZmxvd1ZlcnRpY2FsT2JzZXJ2ZXIuZW1pdCh2ZXJ0aWNhbE92ZXJmbG93KTtcbiAgICB9XG5cbiAgICBpZiAoaG9yaXpvbnRhbE92ZXJmbG93ICE9PSB0aGlzLl9zdGF0ZS5ob3Jpem9udGFsT3ZlcmZsb3cgfHwgdmVydGljYWxPdmVyZmxvdyAhPT0gdGhpcy5fc3RhdGUudmVydGljYWxPdmVyZmxvdykge1xuICAgICAgdGhpcy51eE92ZXJmbG93T2JzZXJ2ZXIuZW1pdCgoaG9yaXpvbnRhbE92ZXJmbG93IHx8IHZlcnRpY2FsT3ZlcmZsb3cpKTtcbiAgICB9XG5cbiAgICAvLyBzdG9yZSB0aGUgc3RhdGVcbiAgICB0aGlzLl9zdGF0ZSA9IHsgaG9yaXpvbnRhbE92ZXJmbG93LCB2ZXJ0aWNhbE92ZXJmbG93IH07XG4gIH1cbn1cbiIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPdmVyZmxvd0RpcmVjdGl2ZSB9IGZyb20gJy4vb3ZlcmZsb3cvb3ZlcmZsb3ctb2JzZXJ2ZXIuZGlyZWN0aXZlJztcblxuQE5nTW9kdWxlKHtcbiAgZXhwb3J0czogW092ZXJmbG93RGlyZWN0aXZlXSxcbiAgZGVjbGFyYXRpb25zOiBbT3ZlcmZsb3dEaXJlY3RpdmVdXG59KVxuZXhwb3J0IGNsYXNzIE9ic2VydmVyc01vZHVsZSB7IH1cbiIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBIb3N0QmluZGluZywgSG9zdExpc3RlbmVyLCBJbnB1dCwgT25EZXN0cm95LCBPbkluaXQsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBtYXAsIHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XHJcbmltcG9ydCB7IFNlbGVjdGlvblNlcnZpY2UgfSBmcm9tICcuL3NlbGVjdGlvbi5zZXJ2aWNlJztcclxuXHJcbkBEaXJlY3RpdmUoe1xyXG4gICAgc2VsZWN0b3I6ICdbdXhTZWxlY3Rpb25JdGVtXScsXHJcbiAgICBleHBvcnRBczogJ3V4LXNlbGVjdGlvbi1pdGVtJ1xyXG59KVxyXG5leHBvcnQgY2xhc3MgU2VsZWN0aW9uSXRlbURpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcclxuXHJcbiAgICBASW5wdXQoKSB1eFNlbGVjdGlvbkl0ZW06IGFueTtcclxuXHJcbiAgICBASW5wdXQoKSBASG9zdEJpbmRpbmcoJ2NsYXNzLnV4LXNlbGVjdGlvbi1zZWxlY3RlZCcpXHJcbiAgICBzZXQgc2VsZWN0ZWQoc2VsZWN0ZWQ6IGJvb2xlYW4pIHtcclxuICAgICAgICBzZWxlY3RlZCA/IHRoaXMuc2VsZWN0KCkgOiB0aGlzLmRlc2VsZWN0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IHNlbGVjdGVkKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zZWxlY3RlZDtcclxuICAgIH1cclxuXHJcbiAgICBASW5wdXQoKSB0YWJpbmRleDogbnVtYmVyID0gbnVsbDtcclxuXHJcbiAgICBAT3V0cHV0KCkgc2VsZWN0ZWRDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XHJcblxyXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy51eC1zZWxlY3Rpb24tZm9jdXNlZCcpIGFjdGl2ZTogYm9vbGVhbiA9IGZhbHNlO1xyXG5cclxuICAgIEBIb3N0QmluZGluZygnYXR0ci50YWJpbmRleCcpXHJcbiAgICBnZXQgYXR0clRhYkluZGV4KCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnRhYmluZGV4ICE9PSBudWxsKSA/IHRoaXMudGFiaW5kZXggOiB0aGlzLl9tYW5hZ2VkVGFiSW5kZXg7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfc2VsZWN0ZWQ6IGJvb2xlYW4gPSBmYWxzZTtcclxuICAgIHByaXZhdGUgX21hbmFnZWRUYWJJbmRleDogbnVtYmVyID0gLTE7XHJcbiAgICBwcml2YXRlIF9vbkRlc3Ryb3kgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX3NlbGVjdGlvblNlcnZpY2U6IFNlbGVjdGlvblNlcnZpY2UsIHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYpIHsgfVxyXG5cclxuICAgIG5nT25Jbml0KCk6IHZvaWQge1xyXG5cclxuICAgICAgICAvLyBpZiB0aGVyZSBpcyBubyBhc3NvY2lhdGVkIGRhdGEgdGhlbiB0aHJvdyBhbiBlcnJvclxyXG4gICAgICAgIGlmICghdGhpcy51eFNlbGVjdGlvbkl0ZW0pIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgdXhTZWxlY3Rpb25JdGVtIGRpcmVjdGl2ZSBtdXN0IGhhdmUgZGF0YSBhc3NvY2lhdGVkIHdpdGggaXQuJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBzdWJzY3JpYmUgdG8gc2VsZWN0aW9uIGNoYW5nZXMgb24gdGhpcyBpdGVtXHJcbiAgICAgICAgdGhpcy5fc2VsZWN0aW9uU2VydmljZS5nZXRTZWxlY3Rpb25TdGF0ZSh0aGlzLnV4U2VsZWN0aW9uSXRlbSkucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSkuc3Vic2NyaWJlKHNlbGVjdGVkID0+IHtcclxuXHJcbiAgICAgICAgICAgIC8vIHN0b3JlIHRoZSBzZWxlY3RlZCBzdGF0ZVxyXG4gICAgICAgICAgICB0aGlzLl9zZWxlY3RlZCA9IHNlbGVjdGVkO1xyXG5cclxuICAgICAgICAgICAgLy8gZW1pdCB0aGUgc2VsZWN0ZWQgc3RhdGVcclxuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZENoYW5nZS5lbWl0KHNlbGVjdGVkKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdGhpcy5fc2VsZWN0ZWQgPSB0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlLmlzU2VsZWN0ZWQodGhpcy51eFNlbGVjdGlvbkl0ZW0pO1xyXG5cclxuICAgICAgICB0aGlzLnNlbGVjdGVkQ2hhbmdlLmVtaXQodGhpcy5fc2VsZWN0ZWQpO1xyXG5cclxuICAgICAgICAvLyBzdWJzY3JpYmUgdG8gY2hhbmdlcyB0byB0aGUgYWN0aXZlIHN0YXRlXHJcbiAgICAgICAgdGhpcy5fc2VsZWN0aW9uU2VydmljZS5hY3RpdmUkLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSksIG1hcChhY3RpdmUgPT4gYWN0aXZlID09PSB0aGlzLnV4U2VsZWN0aW9uSXRlbSkpLnN1YnNjcmliZShhY3RpdmUgPT4ge1xyXG5cclxuICAgICAgICAgICAgLy8gc3RvcmUgdGhlIGZvY3VzIHN0YXRlXHJcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gYWN0aXZlO1xyXG5cclxuICAgICAgICAgICAgLy8gaWYgaXQgaXMgYWN0aXZlIHRoZW4gZm9jdXMgdGhlIGVsZW1lbnRcclxuICAgICAgICAgICAgaWYgKGFjdGl2ZSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0aW9uU2VydmljZS5mb2N1cyQubmV4dCh0aGlzLnV4U2VsZWN0aW9uSXRlbSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBTdWJzY3JpYmUgdG8gY2hhbmdlcyB0byB0aGUgZm9jdXMgdGFyZ2V0XHJcbiAgICAgICAgLy8gVGhpcyBpcyBtb3N0bHkgdGhlIHNhbWUgYXMgYWN0aXZlJCwgZXhjZXB0IHRoYXQgaXQgaGFzIGFuIGluaXRpYWwgdmFsdWUgb2YgdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGNvbGxlY3Rpb24uXHJcbiAgICAgICAgdGhpcy5fc2VsZWN0aW9uU2VydmljZS5mb2N1cyQucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSkuc3Vic2NyaWJlKGZvY3VzVGFyZ2V0ID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fbWFuYWdlZFRhYkluZGV4ID0gKGZvY3VzVGFyZ2V0ID09PSB0aGlzLnV4U2VsZWN0aW9uSXRlbSkgPyAwIDogLTE7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fb25EZXN0cm95Lm5leHQoKTtcclxuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kuY29tcGxldGUoKTtcclxuICAgIH1cclxuXHJcbiAgICBASG9zdExpc3RlbmVyKCdjbGljaycsIFsnJGV2ZW50J10pXHJcbiAgICBjbGljayhldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlLmlzRW5hYmxlZCAmJiB0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlLmlzQ2xpY2tFbmFibGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGlvblNlcnZpY2Uuc3RyYXRlZ3kuY2xpY2soZXZlbnQsIHRoaXMudXhTZWxlY3Rpb25JdGVtKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgQEhvc3RMaXN0ZW5lcignbW91c2Vkb3duJywgWyckZXZlbnQnXSlcclxuICAgIG1vdXNlZG93bihldmVudDogTW91c2VFdmVudCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlLmlzRW5hYmxlZCAmJiB0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlLmlzQ2xpY2tFbmFibGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGlvblNlcnZpY2Uuc3RyYXRlZ3kubW91c2Vkb3duKGV2ZW50LCB0aGlzLnV4U2VsZWN0aW9uSXRlbSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIEBIb3N0TGlzdGVuZXIoJ2tleWRvd24nLCBbJyRldmVudCddKVxyXG4gICAga2V5ZG93bihldmVudDogS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlLmlzRW5hYmxlZCAmJiB0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlLmlzS2V5Ym9hcmRFbmFibGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGlvblNlcnZpY2Uuc3RyYXRlZ3kua2V5ZG93bihldmVudCwgdGhpcy51eFNlbGVjdGlvbkl0ZW0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBASG9zdExpc3RlbmVyKCdmb2N1cycpXHJcbiAgICBmb2N1cygpOiB2b2lkIHtcclxuICAgICAgICAvLyBJZiB0YWJiZWQgdG8gZnJvbSBvdXRzaWRlIHRoZSBjb21wb25lbnQsIGFjdGl2YXRlLlxyXG4gICAgICAgIGlmICh0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlLmFjdGl2ZSQuZ2V0VmFsdWUoKSAhPT0gdGhpcy51eFNlbGVjdGlvbkl0ZW0pIHtcclxuICAgICAgICAgICAgdGhpcy5fc2VsZWN0aW9uU2VydmljZS5hY3RpdmF0ZSh0aGlzLnV4U2VsZWN0aW9uSXRlbSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2VsZWN0IHRoaXMgaXRlbSB1c2luZyB0aGUgY3VycmVudCBzdHJhdGVneVxyXG4gICAgICovXHJcbiAgICBzZWxlY3QoKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3NlbGVjdGlvblNlcnZpY2UuaXNFbmFibGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGlvblNlcnZpY2Uuc3RyYXRlZ3kuc2VsZWN0KHRoaXMudXhTZWxlY3Rpb25JdGVtKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXNlbGVjdCB0aGlzIGl0ZW0gdXNpbmcgdGhlIGN1cnJlbnQgc3RyYXRlZ3lcclxuICAgICAqL1xyXG4gICAgZGVzZWxlY3QoKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3NlbGVjdGlvblNlcnZpY2UuaXNFbmFibGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGlvblNlcnZpY2Uuc3RyYXRlZ3kuZGVzZWxlY3QodGhpcy51eFNlbGVjdGlvbkl0ZW0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBBZnRlckNvbnRlbnRJbml0LCBDaGFuZ2VEZXRlY3RvclJlZiwgQ29udGVudENoaWxkcmVuLCBEaXJlY3RpdmUsIEV2ZW50RW1pdHRlciwgSG9zdEJpbmRpbmcsIElucHV0LCBPbkRlc3Ryb3ksIE91dHB1dCwgUXVlcnlMaXN0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcy9TdWJqZWN0JztcbmltcG9ydCB7IFNlbGVjdGlvbkl0ZW1EaXJlY3RpdmUgfSBmcm9tICcuL3NlbGVjdGlvbi1pdGVtLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBTZWxlY3Rpb25Nb2RlLCBTZWxlY3Rpb25TZXJ2aWNlIH0gZnJvbSAnLi9zZWxlY3Rpb24uc2VydmljZSc7XG5pbXBvcnQgeyBTZWxlY3Rpb25TdHJhdGVneSB9IGZyb20gJy4vc3RyYXRlZ2llcy9zZWxlY3Rpb24uc3RyYXRlZ3knO1xuXG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1t1eFNlbGVjdGlvbl0nLFxuICBleHBvcnRBczogJ3V4LXNlbGVjdGlvbicsXG4gIHByb3ZpZGVyczogWyBTZWxlY3Rpb25TZXJ2aWNlIF1cbn0pXG5leHBvcnQgY2xhc3MgU2VsZWN0aW9uRGlyZWN0aXZlIGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdCwgT25EZXN0cm95IHtcblxuICBASW5wdXQoKSBzZXQgdXhTZWxlY3Rpb24oaXRlbXM6IGFueVtdKSB7XG4gICAgdGhpcy5fc2VsZWN0aW9uU2VydmljZS5zZWxlY3QoLi4uaXRlbXMpO1xuICB9XG5cbiAgQElucHV0KCkgc2V0IGRpc2FibGVkKGRpc2FibGVkOiBib29sZWFuKSB7XG4gICAgdGhpcy5fc2VsZWN0aW9uU2VydmljZS5zZXREaXNhYmxlZChkaXNhYmxlZCk7XG4gIH1cblxuICBASW5wdXQoKSBzZXQgbW9kZShtb2RlOiBTZWxlY3Rpb25Nb2RlIHwgU2VsZWN0aW9uU3RyYXRlZ3kpIHtcbiAgICB0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlLnNldFN0cmF0ZWd5KG1vZGUpO1xuICB9XG5cbiAgQElucHV0KCkgc2V0IGNsaWNrU2VsZWN0aW9uKGlzQ2xpY2tFbmFibGVkOiBib29sZWFuKSB7XG4gICAgdGhpcy5fc2VsZWN0aW9uU2VydmljZS5pc0NsaWNrRW5hYmxlZCA9IGlzQ2xpY2tFbmFibGVkO1xuICB9XG5cbiAgQElucHV0KCkgc2V0IGtleWJvYXJkU2VsZWN0aW9uKGlzS2V5Ym9hcmRFbmFibGVkOiBib29sZWFuKSB7XG4gICAgdGhpcy5fc2VsZWN0aW9uU2VydmljZS5pc0tleWJvYXJkRW5hYmxlZCA9IGlzS2V5Ym9hcmRFbmFibGVkO1xuICB9XG5cbiAgQElucHV0KCkgQEhvc3RCaW5kaW5nKCdhdHRyLnRhYmluZGV4JykgdGFiaW5kZXg6IG51bWJlciA9IG51bGw7XG5cbiAgQE91dHB1dCgpIHV4U2VsZWN0aW9uQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxhbnlbXT4oKTtcblxuICBAQ29udGVudENoaWxkcmVuKFNlbGVjdGlvbkl0ZW1EaXJlY3RpdmUpIGl0ZW1zOiBRdWVyeUxpc3Q8U2VsZWN0aW9uSXRlbURpcmVjdGl2ZT47XG5cbiAgcHJpdmF0ZSBfb25EZXN0cm95ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9zZWxlY3Rpb25TZXJ2aWNlOiBTZWxlY3Rpb25TZXJ2aWNlLCBwcml2YXRlIF9jZFJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYpIHtcbiAgICBfc2VsZWN0aW9uU2VydmljZS5zZWxlY3Rpb24kLnBpcGUodGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZShpdGVtcyA9PiB0aGlzLnV4U2VsZWN0aW9uQ2hhbmdlLmVtaXQoaXRlbXMpKTtcbiAgfVxuXG4gIG5nQWZ0ZXJDb250ZW50SW5pdCgpOiB2b2lkIHtcbiAgICAvLyBwcm92aWRlIHRoZSBpbml0aWFsIGxpc3Qgb2Ygc2VsZWN0aW9uIGl0ZW1zXG4gICAgdGhpcy51cGRhdGUoKTtcblxuICAgIC8vIGlmIHRoZSBsaXN0IGNoYW5nZXMgdGhlbiBpbmZvcm0gdGhlIHNlcnZpY2VcbiAgICB0aGlzLml0ZW1zLmNoYW5nZXMucGlwZSh0YWtlVW50aWwodGhpcy5fb25EZXN0cm95KSkuc3Vic2NyaWJlKCgpID0+IHRoaXMudXBkYXRlKCkpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5fb25EZXN0cm95Lm5leHQoKTtcbiAgICB0aGlzLl9vbkRlc3Ryb3kuY29tcGxldGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGRhdGFzZXQgdG8gcmVmbGVjdCB0aGUgbGF0ZXN0IHNlbGVjdGlvbiBpdGVtc1xuICAgKi9cbiAgdXBkYXRlKCk6IHZvaWQge1xuXG4gICAgdGhpcy5fc2VsZWN0aW9uU2VydmljZS5kYXRhc2V0ID0gdGhpcy5pdGVtcy5tYXAoaXRlbSA9PiBpdGVtLnV4U2VsZWN0aW9uSXRlbSk7XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhhdCBhIHRhYiB0YXJnZXQgaGFzIGJlZW4gZGVmaW5lZCBzbyB0aGF0IHRoZSBjb21wb25lbnQgY2FuIGJlIHRhYmJlZCB0by5cbiAgICBpZiAodGhpcy5fc2VsZWN0aW9uU2VydmljZS5mb2N1cyQuZ2V0VmFsdWUoKSA9PT0gbnVsbCAmJiB0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlLmRhdGFzZXQubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5fc2VsZWN0aW9uU2VydmljZS5mb2N1cyQubmV4dCh0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlLmRhdGFzZXRbMF0pO1xuICAgIH1cblxuICAgIC8vIFRoZSBhYm92ZSBjb3VsZCB0cmlnZ2VyIGEgY2hhbmdlIGluIHRoZSBjb21wdXRlZCB0YWJpbmRleCBmb3Igc2VsZWN0aW9uIGl0ZW1zXG4gICAgdGhpcy5fY2RSZWYuZGV0ZWN0Q2hhbmdlcygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbGVjdCBhbGwgdGhlIGl0ZW1zIGluIHRoZSBsaXN0XG4gICAqL1xuICBzZWxlY3RBbGwoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuX3NlbGVjdGlvblNlcnZpY2UuaXNFbmFibGVkKSB7XG4gICAgICB0aGlzLl9zZWxlY3Rpb25TZXJ2aWNlLnN0cmF0ZWd5LnNlbGVjdEFsbCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZXNlbGVjdCBhbGwgY3VycmVudGx5IHNlbGVjdGVkIGl0ZW1zXG4gICAqL1xuICBkZXNlbGVjdEFsbCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fc2VsZWN0aW9uU2VydmljZS5pc0VuYWJsZWQpIHtcbiAgICAgIHRoaXMuX3NlbGVjdGlvblNlcnZpY2Uuc3RyYXRlZ3kuZGVzZWxlY3RBbGwoKTtcbiAgICB9XG4gIH1cbn1cbiIsImltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU2VsZWN0aW9uSXRlbURpcmVjdGl2ZSB9IGZyb20gJy4vc2VsZWN0aW9uLWl0ZW0uZGlyZWN0aXZlJztcbmltcG9ydCB7IFNlbGVjdGlvbkRpcmVjdGl2ZSB9IGZyb20gJy4vc2VsZWN0aW9uLmRpcmVjdGl2ZSc7XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtcbiAgICBDb21tb25Nb2R1bGVcbiAgXSxcbiAgZGVjbGFyYXRpb25zOiBbU2VsZWN0aW9uRGlyZWN0aXZlLCBTZWxlY3Rpb25JdGVtRGlyZWN0aXZlXSxcbiAgZXhwb3J0czogW1NlbGVjdGlvbkRpcmVjdGl2ZSwgU2VsZWN0aW9uSXRlbURpcmVjdGl2ZV1cbn0pXG5leHBvcnQgY2xhc3MgU2VsZWN0aW9uTW9kdWxlIHsgfVxuIiwiaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcy9CZWhhdmlvclN1YmplY3QnO1xuXG5leHBvcnQgY2xhc3MgVHJlZUdyaWRTdGF0ZSB7XG4gICAgcmVhZG9ubHkgbG9hZGluZyQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PGJvb2xlYW4+KGZhbHNlKTtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwdWJsaWMgcmVhZG9ubHkgbGV2ZWw6IG51bWJlcixcbiAgICAgICAgcHVibGljIHJlYWRvbmx5IHNldFNpemU6IG51bWJlcixcbiAgICAgICAgcHVibGljIHJlYWRvbmx5IHBvc2l0aW9uSW5TZXQ6IG51bWJlcikge31cbn1cbiIsImltcG9ydCB7IENoYW5nZURldGVjdG9yUmVmLCBJbmplY3RhYmxlLCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMvQmVoYXZpb3JTdWJqZWN0JztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzL09ic2VydmFibGUnO1xuaW1wb3J0IHsgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XG5pbXBvcnQgeyBUcmVlR3JpZEl0ZW0gfSBmcm9tICcuL3RyZWUtZ3JpZC1pdGVtLmludGVyZmFjZSc7XG5pbXBvcnQgeyBUcmVlR3JpZExvYWRGdW5jdGlvbiB9IGZyb20gJy4vdHJlZS1ncmlkLWxvYWQtZnVuY3Rpb24udHlwZSc7XG5pbXBvcnQgeyBUcmVlR3JpZFN0YXRlIH0gZnJvbSAnLi90cmVlLWdyaWQtc3RhdGUuY2xhc3MnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgVHJlZUdyaWRTZXJ2aWNlIGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICAgIC8qKiBUaGUgcmF3IHRhYmxlIGRhdGEgKi9cbiAgICBkYXRhJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8VHJlZUdyaWRJdGVtW10+KFtdKTtcblxuICAgIC8qKiBUaGUgZmxhdHRlbmVkIHRhYmxlIGRhdGEgKi9cbiAgICByb3dzJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8VHJlZUdyaWRJdGVtW10+KFtdKTtcblxuICAgIC8qKiBUaGUgZnVuY3Rpb24gdG8gbG9hZCBjaGlsZCBpdGVtcyAqL1xuICAgIGxvYWRDaGlsZHJlbjogVHJlZUdyaWRMb2FkRnVuY3Rpb247XG5cbiAgICAvKiogRW5zdXJlIHdlIGRlc3Ryb3kgYWxsIG9ic2VydmFibGVzIGNvcnJlY3RseSAqL1xuICAgIHByaXZhdGUgX29uRGVzdHJveSA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9jaGFuZ2VEZXRlY3RvcjogQ2hhbmdlRGV0ZWN0b3JSZWYpIHtcbiAgICAgICAgdGhpcy5kYXRhJC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUoZGF0YSA9PiB0aGlzLnJvd3MkLm5leHQodGhpcy5nZXRGbGF0dGVuZWRUcmVlKGRhdGEpKSk7XG4gICAgfVxuXG4gICAgLyoqIFVuc3Vic2NyaWJlIGZyb20gYWxsIG9ic2VydmFibGVzICovXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX29uRGVzdHJveS5uZXh0KCk7XG4gICAgICAgIHRoaXMuX29uRGVzdHJveS5jb21wbGV0ZSgpO1xuICAgIH1cblxuICAgIC8qKiBTZXQgdGhlIGV4cGFuZGVkIHN0YXRlIG9mIGEgcm93ICovXG4gICAgYXN5bmMgc2V0RXhwYW5kZWQoaXRlbTogVHJlZUdyaWRJdGVtLCBleHBhbmRlZDogYm9vbGVhbikge1xuICAgICAgICBpZiAoZXhwYW5kZWQpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuZ2V0Q2hpbGRyZW4oaXRlbSk7XG4gICAgICAgICAgICB0aGlzLmluc2VydENoaWxkcmVuKGl0ZW0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVDaGlsZHJlbihpdGVtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NoYW5nZURldGVjdG9yLmRldGVjdENoYW5nZXMoKTtcbiAgICB9XG5cbiAgICAvKiogQSBmdW5jdGlvbiB0byBmbGF0dGVuIHRyZWUgZGF0YSAqL1xuICAgIHByaXZhdGUgZ2V0RmxhdHRlbmVkVHJlZShkYXRhOiBUcmVlR3JpZEl0ZW1bXSwgcGFyZW50PzogVHJlZUdyaWRJdGVtKTogVHJlZUdyaWRJdGVtW10ge1xuICAgICAgICAvLyBmbGF0dGVuIHRoZSBub2RlcyBhdCB0aGlzIGxldmVsXG4gICAgICAgIHJldHVybiBkYXRhLnJlZHVjZSgocHJldmlvdXMsIGl0ZW0sIGluZGV4KSA9PiB7XG5cbiAgICAgICAgICAgIGl0ZW0uc3RhdGUgPSBuZXcgVHJlZUdyaWRTdGF0ZShwYXJlbnQgPyBwYXJlbnQuc3RhdGUubGV2ZWwgKyAxIDogMCwgZGF0YS5sZW5ndGgsIGluZGV4ICsgMSk7XG5cbiAgICAgICAgICAgIC8vIENvbnZlcnQgYW55IGNoaWxkIG5vZGVzXG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IChpdGVtLmNoaWxkcmVuICYmIGl0ZW0uZXhwYW5kZWQpID8gdGhpcy5nZXRGbGF0dGVuZWRUcmVlKGl0ZW0uY2hpbGRyZW4sIGl0ZW0pIDogW107XG5cbiAgICAgICAgICAgIC8vIHJldHVybiB0aGUgbm9kZXMgaW4gYSBmbGF0dGVuZWQgYXJyYXlcbiAgICAgICAgICAgIHJldHVybiBbLi4ucHJldmlvdXMsIGl0ZW0sIC4uLmNoaWxkcmVuXTtcbiAgICAgICAgfSwgW10pO1xuICAgIH1cblxuICAgIC8qKiBMb2FkIGFueSBjaGlsZHJlbiBkeW5hbWljYWxseSAqL1xuICAgIHByaXZhdGUgYXN5bmMgZ2V0Q2hpbGRyZW4oaXRlbTogVHJlZUdyaWRJdGVtKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAgIGlmICghaXRlbS5jaGlsZHJlbiAmJiB0aGlzLmxvYWRDaGlsZHJlbikge1xuICAgICAgICAgICAgaXRlbS5zdGF0ZS5sb2FkaW5nJC5uZXh0KHRydWUpO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGl0ZW0uY2hpbGRyZW4gPSBhd2FpdCB0aGlzLmdldE5vcm1hbGl6ZWRDaGlsZHJlbih0aGlzLmxvYWRDaGlsZHJlbihpdGVtKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBpdGVtLnN0YXRlLmxvYWRpbmckLm5leHQoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIFdlIHdhbnQgdG8gc3VwcG9ydCBhbiBhcnJheSwgYSBwcm9taXNlIGFuZCBhbiBvYnNlcnZhYmxlLiBUaGlzIHdpbGwgcmV0dXJuIGFsbCB0eXBlcyBhcyBhIHByb21pc2UgKi9cbiAgICBwcml2YXRlIGFzeW5jIGdldE5vcm1hbGl6ZWRDaGlsZHJlbihyZXNwb25zZTogVHJlZUdyaWRJdGVtW10gfCBQcm9taXNlPFRyZWVHcmlkSXRlbVtdPiB8IE9ic2VydmFibGU8VHJlZUdyaWRJdGVtW10+KTogUHJvbWlzZTxUcmVlR3JpZEl0ZW1bXT4ge1xuXG4gICAgICAgIC8vIGlmIGl0IGlzIGFscmVhZHkgYW4gb2JzZXJ2YWJsZSBkbyBub3RoaW5nXG4gICAgICAgIGlmIChyZXNwb25zZSBpbnN0YW5jZW9mIE9ic2VydmFibGUpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCByZXNwb25zZS50b1Byb21pc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIGl0IGlzIGEgcHJvbWlzZSB3cmFwIGl0IGFzIGFuIG9ic2VydmFibGVcbiAgICAgICAgaWYgKHJlc3BvbnNlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgaXQgaXMgYW4gYXJyYXkgdGhlbiBtYWtlIGl0IGFuIG9ic2VydmFibGVcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH1cblxuICAgIC8qKiBJbnNlcnQgdGhlIGNoaWxkcmVuIGludG8gdGhlIGZsYXR0ZW5lZCB0cmVlIGF0IHRoZSBjb3JyZWN0IGxvY2F0aW9uICovXG4gICAgcHJpdmF0ZSBpbnNlcnRDaGlsZHJlbihwYXJlbnQ6IFRyZWVHcmlkSXRlbSk6IHZvaWQge1xuICAgICAgICBpZiAoIXBhcmVudC5jaGlsZHJlbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgcm93ID0gdGhpcy5yb3dzJC5nZXRWYWx1ZSgpO1xuXG4gICAgICAgIGNvbnN0IGluZGV4ID0gcm93LmluZGV4T2YocGFyZW50KTtcblxuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTa2lwIGR1cGxpY2F0ZXMgLSB0aGlzIGNvdWxkIGhhcHBlbiBpZiBhbiBhbHJlYWR5IGV4cGFuZGVkIGNoaWxkIGhhcyBiZWVuIGluc2VydGVkXG4gICAgICAgIGNvbnN0IHVuaXF1ZUNoaWxkcmVuID0gcGFyZW50LmNoaWxkcmVuLmZpbHRlcihjaGlsZCA9PiByb3cuaW5kZXhPZihjaGlsZCkgPT09IC0xKTtcblxuICAgICAgICBjb25zdCBjaGlsZFJvd3MgPSB0aGlzLmdldEZsYXR0ZW5lZFRyZWUodW5pcXVlQ2hpbGRyZW4sIHBhcmVudCk7XG5cbiAgICAgICAgcm93LnNwbGljZShpbmRleCArIDEsIDAsIC4uLmNoaWxkUm93cyk7XG4gICAgfVxuXG4gICAgLyoqIFJlbW92ZSBhbGwgcm93cyBmcm9tIHRoZSBmbGF0dGVuZWQgdHJlZSAqL1xuICAgIHByaXZhdGUgcmVtb3ZlQ2hpbGRyZW4ocGFyZW50OiBUcmVlR3JpZEl0ZW0pOiB2b2lkIHtcblxuICAgICAgICBjb25zdCByb3dzID0gdGhpcy5yb3dzJC5nZXRWYWx1ZSgpO1xuICAgICAgICBjb25zdCBpbmRleCA9IHJvd3MuaW5kZXhPZihwYXJlbnQpO1xuXG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChpbmRleCArIDEgPCByb3dzLmxlbmd0aCAmJiByb3dzW2luZGV4ICsgMV0uc3RhdGUubGV2ZWwgPiBwYXJlbnQuc3RhdGUubGV2ZWwpIHtcbiAgICAgICAgICAgIHJvd3Muc3BsaWNlKGluZGV4ICsgMSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEV2ZW50RW1pdHRlciwgSG9zdEJpbmRpbmcsIEhvc3RMaXN0ZW5lciwgSW5wdXQsIE9uRGVzdHJveSwgT25Jbml0LCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCB9IGZyb20gJ3J4anMtY29tcGF0L0JlaGF2aW9yU3ViamVjdCc7XG5pbXBvcnQgeyBkaXN0aW5jdFVudGlsQ2hhbmdlZCwgc2tpcCwgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XG5pbXBvcnQgeyB0aWNrIH0gZnJvbSAnLi4vLi4vY29tbW9uL29wZXJhdG9ycy90aWNrLm9wZXJhdG9yJztcbmltcG9ydCB7IFRyZWVHcmlkSXRlbSB9IGZyb20gJy4vdHJlZS1ncmlkLWl0ZW0uaW50ZXJmYWNlJztcbmltcG9ydCB7IFRyZWVHcmlkU2VydmljZSB9IGZyb20gJy4vdHJlZS1ncmlkLnNlcnZpY2UnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1t1eFRyZWVHcmlkUm93XScsXG4gICAgZXhwb3J0QXM6ICd1eFRyZWVHcmlkUm93JyxcbiAgICBob3N0OiB7XG4gICAgICAgICdbY2xhc3MudHJlZWdyaWQtcm93XSc6ICd0cnVlJ1xuICAgIH1cbn0pXG5leHBvcnQgY2xhc3MgVHJlZUdyaWRSb3dEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG5cbiAgICBASW5wdXQoJ3V4VHJlZUdyaWRSb3cnKVxuICAgIGl0ZW06IFRyZWVHcmlkSXRlbTtcblxuICAgIEBJbnB1dCgpXG4gICAgY2FuRXhwYW5kOiBib29sZWFuO1xuXG4gICAgQElucHV0KClcbiAgICBzZXQgZXhwYW5kZWQoZXhwYW5kZWQ6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5fZXhwYW5kZWQkLm5leHQoISFleHBhbmRlZCk7XG4gICAgfVxuICAgIGdldCBleHBhbmRlZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4cGFuZGVkJC5nZXRWYWx1ZSgpO1xuICAgIH1cblxuICAgIEBPdXRwdXQoKVxuICAgIGV4cGFuZGVkQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy50cmVlZ3JpZC1yb3ctbG9hZGluZycpXG4gICAgbG9hZGluZzogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy50cmVlZ3JpZC1yb3ctZXhwYW5kZWQnKVxuICAgIGlzRXhwYW5kZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIHByaXZhdGUgX2V4cGFuZGVkJCA9IG5ldyBCZWhhdmlvclN1YmplY3QoZmFsc2UpO1xuXG4gICAgcHJpdmF0ZSBfb25EZXN0cm95ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX3RyZWVHcmlkU2VydmljZTogVHJlZUdyaWRTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuX2V4cGFuZGVkJC5waXBlKHNraXAoMSksIHRpY2soKSwgZGlzdGluY3RVbnRpbENoYW5nZWQoKSwgdGFrZVVudGlsKHRoaXMuX29uRGVzdHJveSkpLnN1YnNjcmliZShleHBhbmRlZCA9PiB7XG4gICAgICAgICAgICB0aGlzLmV4cGFuZGVkQ2hhbmdlLmVtaXQoZXhwYW5kZWQpO1xuICAgICAgICAgICAgdGhpcy5fdHJlZUdyaWRTZXJ2aWNlLnNldEV4cGFuZGVkKHRoaXMuaXRlbSwgZXhwYW5kZWQpO1xuICAgICAgICAgICAgdGhpcy5pc0V4cGFuZGVkID0gZXhwYW5kZWQ7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG5nT25Jbml0KCk6IHZvaWQge1xuXG4gICAgICAgIGlmICghdGhpcy5pdGVtIHx8ICF0aGlzLml0ZW0uc3RhdGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndXhUcmVlR3JpZFJvdyBzaG91bGQgYmUgY29uZmlndXJlZCB3aXRoIGFuIG9iamVjdCBlbWl0dGVkIGJ5IHV4VHJlZUdyaWQucm93cy4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaXRlbS5zdGF0ZS5sb2FkaW5nJC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKVxuICAgICAgICAgICAgLnN1YnNjcmliZShsb2FkaW5nID0+IHRoaXMubG9hZGluZyA9IGxvYWRpbmcpO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kubmV4dCgpO1xuICAgICAgICB0aGlzLl9vbkRlc3Ryb3kuY29tcGxldGUoKTtcbiAgICB9XG5cbiAgICBASG9zdExpc3RlbmVyKCdrZXlkb3duLkFycm93TGVmdCcsIFsnJGV2ZW50J10pXG4gICAgY29sbGFwc2UoZXZlbnQ/OiBFdmVudCk6IHZvaWQge1xuXG4gICAgICAgIHRoaXMuZXhwYW5kZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBASG9zdExpc3RlbmVyKCdrZXlkb3duLkFycm93UmlnaHQnLCBbJyRldmVudCddKVxuICAgIGV4cGFuZChldmVudD86IEV2ZW50KTogdm9pZCB7XG5cbiAgICAgICAgLy8gdGFrZSBpbnRvIGFjY291bnQgd2hldGhlciBvciBub3QgdGhlIGl0ZW0gY2FuIGV4cGFuZGVkXG4gICAgICAgIHRoaXMuZXhwYW5kZWQgPSB0aGlzLmNhbkV4cGFuZCAmJiB0cnVlO1xuXG4gICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRvZ2dsZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5leHBhbmRlZCA/IHRoaXMuY29sbGFwc2UoKSA6IHRoaXMuZXhwYW5kKCk7XG4gICAgfVxufSIsImltcG9ydCB7IERpcmVjdGl2ZSwgSG9zdEJpbmRpbmcsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBUcmVlR3JpZFJvd0RpcmVjdGl2ZSB9IGZyb20gJy4vdHJlZS1ncmlkLXJvdy5kaXJlY3RpdmUnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1t1eFRyZWVHcmlkSW5kZW50XScsXG59KVxuZXhwb3J0IGNsYXNzIFRyZWVHcmlkSW5kZW50RGlyZWN0aXZlIHtcblxuICAgIC8qKiBUaGUgYW1vdW50IGVhY2ggbGV2ZWwgc2hvdWxkIGJlIGluZGVudGVkIGJ5ICovXG4gICAgQElucHV0KCkgdXhUcmVlR3JpZEluZGVudDogbnVtYmVyO1xuXG4gICAgLyoqIFRoZSBwYWRkaW5nIHZhbHVlIGFwcGxpZWQgdG8gZWFjaCBsZXZlbCAqL1xuICAgIEBIb3N0QmluZGluZygnc3R5bGUucGFkZGluZy1sZWZ0LnB4JylcbiAgICBnZXQgaW5kZW50YXRpb24oKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JvdyAmJiB0aGlzLl9yb3cuaXRlbSA/IDcgKyAodGhpcy5fcm93Lml0ZW0uc3RhdGUubGV2ZWwgKiAodGhpcy51eFRyZWVHcmlkSW5kZW50IHx8IDI1KSkgOiA3O1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX3JvdzogVHJlZUdyaWRSb3dEaXJlY3RpdmUpIHt9XG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFdmVudEVtaXR0ZXIsIElucHV0LCBPbkRlc3Ryb3ksIE9uSW5pdCwgT3V0cHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBUcmVlR3JpZEl0ZW0gfSBmcm9tICcuL3RyZWUtZ3JpZC1pdGVtLmludGVyZmFjZSc7XG5pbXBvcnQgeyBUcmVlR3JpZExvYWRGdW5jdGlvbiB9IGZyb20gJy4vdHJlZS1ncmlkLWxvYWQtZnVuY3Rpb24udHlwZSc7XG5pbXBvcnQgeyBUcmVlR3JpZFNlcnZpY2UgfSBmcm9tICcuL3RyZWUtZ3JpZC5zZXJ2aWNlJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzL1N1YmplY3QnO1xuaW1wb3J0IHsgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1t1eFRyZWVHcmlkXScsXG4gICAgcHJvdmlkZXJzOiBbVHJlZUdyaWRTZXJ2aWNlXSxcbiAgICBob3N0OiB7XG4gICAgICAgIGNsYXNzOiAndHJlZWdyaWQnXG4gICAgfVxufSlcbmV4cG9ydCBjbGFzcyBUcmVlR3JpZERpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcbiAgICBASW5wdXQoJ3V4VHJlZUdyaWQnKVxuICAgIHNldCBkYXRhKGRhdGE6IFRyZWVHcmlkSXRlbVtdKSB7XG4gICAgICAgIHRoaXMuX3RyZWVHcmlkU2VydmljZS5kYXRhJC5uZXh0KGRhdGEpO1xuICAgIH1cblxuICAgIEBJbnB1dCgpXG4gICAgc2V0IGxvYWRDaGlsZHJlbihsb2FkQ2hpbGRyZW46IFRyZWVHcmlkTG9hZEZ1bmN0aW9uKSB7XG4gICAgICAgIHRoaXMuX3RyZWVHcmlkU2VydmljZS5sb2FkQ2hpbGRyZW4gPSBsb2FkQ2hpbGRyZW47XG4gICAgfVxuXG4gICAgQElucHV0KClcbiAgICByb3dzOiBUcmVlR3JpZEl0ZW1bXTtcblxuICAgIEBPdXRwdXQoKVxuICAgIHJvd3NDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPFRyZWVHcmlkSXRlbVtdPigpO1xuXG4gICAgcHJpdmF0ZSBfb25EZXN0cm95ID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX3RyZWVHcmlkU2VydmljZTogVHJlZUdyaWRTZXJ2aWNlKSB7fVxuXG4gICAgbmdPbkluaXQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3RyZWVHcmlkU2VydmljZS5yb3dzJC5waXBlKHRha2VVbnRpbCh0aGlzLl9vbkRlc3Ryb3kpKS5zdWJzY3JpYmUocm93cyA9PiB0aGlzLnJvd3NDaGFuZ2UuZW1pdChyb3dzKSk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX29uRGVzdHJveS5uZXh0KCk7XG4gICAgICAgIHRoaXMuX29uRGVzdHJveS5jb21wbGV0ZSgpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBUcmVlR3JpZEluZGVudERpcmVjdGl2ZSB9IGZyb20gJy4vdHJlZS1ncmlkLWluZGVudC5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgVHJlZUdyaWRSb3dEaXJlY3RpdmUgfSBmcm9tICcuL3RyZWUtZ3JpZC1yb3cuZGlyZWN0aXZlJztcbmltcG9ydCB7IFRyZWVHcmlkRGlyZWN0aXZlIH0gZnJvbSAnLi90cmVlLWdyaWQuZGlyZWN0aXZlJztcblxuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgVHJlZUdyaWREaXJlY3RpdmUsXG4gICAgICAgIFRyZWVHcmlkUm93RGlyZWN0aXZlLFxuICAgICAgICBUcmVlR3JpZEluZGVudERpcmVjdGl2ZVxuICAgIF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBUcmVlR3JpZERpcmVjdGl2ZSxcbiAgICAgICAgVHJlZUdyaWRSb3dEaXJlY3RpdmUsXG4gICAgICAgIFRyZWVHcmlkSW5kZW50RGlyZWN0aXZlXG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBUcmVlR3JpZE1vZHVsZSB7fVxuIiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbmplY3RvciwgSW5wdXQsIE91dHB1dCwgRXZlbnRFbWl0dGVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBVcGdyYWRlQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvdXBncmFkZS9zdGF0aWMnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ2NvbnRhY3QtZ3JvdXAnXG59KVxuZXhwb3J0IGNsYXNzIENvbnRhY3RzTmcxQ29tcG9uZW50IGV4dGVuZHMgVXBncmFkZUNvbXBvbmVudCB7XG5cbiAgICBASW5wdXQoKSBjb250YWN0czogQ29udGFjdFtdO1xuICAgIEBJbnB1dCgpIG9yZ2FuaXphdGlvbjogc3RyaW5nO1xuICAgIEBJbnB1dCgpIHNpemU6ICdtZWRpdW0nIHwgJ3NtYWxsJztcbiAgICBASW5wdXQoKSBjb2xvcnM6IGFueTtcbiAgICBASW5wdXQoKSBtYXhDb250YWN0czogbnVtYmVyO1xuXG4gICAgQE91dHB1dCgpIG92ZXJmbG93Q2xpY2s6IEV2ZW50RW1pdHRlcjx2b2lkPiA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcblxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIGluamVjdG9yOiBJbmplY3Rvcikge1xuICAgICAgICBzdXBlcignY29udGFjdEdyb3VwJywgZWxlbWVudFJlZiwgaW5qZWN0b3IpO1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb250YWN0IHtcbiAgICB0ZXN0OiBzdHJpbmc7XG4gICAgc3RhdHVzOiAnYWN0aXZlJyB8ICdwYXNzaXZlJztcbiAgICBjdXN0b21Ub29sdGlwPzoge1xuICAgICAgICB0ZW1wbGF0ZTogc3RyaW5nLFxuICAgICAgICB0b29sdGlwUG9zaXRpb246IHN0cmluZztcbiAgICAgICAgZGF0YT86IGFueTtcbiAgICB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE9yZ2FuaXphdGlvbiB7XG4gICAgdGV4dDogc3RyaW5nO1xuICAgIGxhYmVsOiAnZXh0ZXJuYWwnIHwgJ3Jpc2snO1xuICAgIHRvb2x0aXA/OiBzdHJpbmc7XG4gICAgY3VzdG9tVG9vbHRpcD86IHtcbiAgICAgICAgdGVtcGxhdGU6IHN0cmluZyxcbiAgICAgICAgdG9vbHRpcFBvc2l0aW9uOiBzdHJpbmc7XG4gICAgICAgIGRhdGE/OiBhbnk7XG4gICAgfTtcbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEluamVjdG9yLCBJbnB1dCwgT3V0cHV0LCBFdmVudEVtaXR0ZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFVwZ3JhZGVDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci91cGdyYWRlL3N0YXRpYyc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnZXhwYW5kLWlucHV0J1xufSlcbmV4cG9ydCBjbGFzcyBFeHBhbmRJbnB1dE5nMUNvbXBvbmVudCBleHRlbmRzIFVwZ3JhZGVDb21wb25lbnQge1xuXG4gICAgQElucHV0KCkgZWxuYW1lOiBzdHJpbmc7XG4gICAgQElucHV0KCkgcGxhY2VIb2xkZXI6IHN0cmluZztcbiAgICBASW5wdXQoKSBjbGFzc05hbWU6IHN0cmluZztcbiAgICBASW5wdXQoKSBjbGVhclRleHRJY29uOiBzdHJpbmc7XG4gICAgQElucHV0KCkgY2xvc2VTZWFyY2g6IHN0cmluZztcbiAgICBASW5wdXQoKSBleHBhbmRBbHdheXM6IGJvb2xlYW47XG4gICAgQElucHV0KCkgb25FbnRlcjogRnVuY3Rpb247XG5cbiAgICBAT3V0cHV0KCkgZm9jdXM6IEV2ZW50RW1pdHRlcjxzdHJpbmc+ID0gbmV3IEV2ZW50RW1pdHRlcjxzdHJpbmc+KCk7XG5cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50UmVmOiBFbGVtZW50UmVmLCBpbmplY3RvcjogSW5qZWN0b3IpIHtcbiAgICAgICAgc3VwZXIoJ2V4cGFuZElucHV0JywgZWxlbWVudFJlZiwgaW5qZWN0b3IpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEluamVjdG9yLCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVXBncmFkZUNvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL3VwZ3JhZGUvc3RhdGljJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdmbG9hdGluZy1hY3Rpb24tYnV0dG9uJ1xufSlcbmV4cG9ydCBjbGFzcyBGbG9hdGluZ0FjdGlvbkJ1dHRvbk5nMUNvbXBvbmVudCBleHRlbmRzIFVwZ3JhZGVDb21wb25lbnQge1xuXG4gICAgQElucHV0KCkgaXRlbXM6IEZsb2F0aW5nQWN0aW9uQnV0dG9uSXRlbVtdID0gW107XG4gICAgQElucHV0KCkgcHJpbWFyeTogc3RyaW5nO1xuICAgIEBJbnB1dCgpIGRpcmVjdGlvbjogJ3RvcCcgfCAncmlnaHQnIHwgJ2JvdHRvbScgfCAnbGVmdCc7XG4gICAgQElucHV0KCkgZmFiVG9vbHRpcDogc3RyaW5nO1xuICAgIEBJbnB1dCgpIGZhYlRvb2x0aXBQbGFjZW1lbnQ6ICd0b3AnIHwgJ3JpZ2h0JyB8ICdib3R0b20nIHwgJ2xlZnQnO1xuXG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZjogRWxlbWVudFJlZiwgaW5qZWN0b3I6IEluamVjdG9yKSB7XG4gICAgICAgIHN1cGVyKCdmbG9hdGluZ0FjdGlvbkJ1dHRvbicsIGVsZW1lbnRSZWYsIGluamVjdG9yKTtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmxvYXRpbmdBY3Rpb25CdXR0b25JdGVtIHtcbiAgICBpY29uOiBzdHJpbmc7XG4gICAgZXZlbnQ6IEZ1bmN0aW9uO1xuICAgIHRvb2x0aXA/OiBzdHJpbmc7XG4gICAgdG9vbHRpcFBsYWNlbWVudD86IHN0cmluZztcbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEluamVjdG9yLCBJbnB1dCwgT3V0cHV0LCBFdmVudEVtaXR0ZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFVwZ3JhZGVDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci91cGdyYWRlL3N0YXRpYyc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnZmxvdCdcbn0pXG5leHBvcnQgY2xhc3MgRmxvdE5nMUNvbXBvbmVudCBleHRlbmRzIFVwZ3JhZGVDb21wb25lbnQge1xuXG4gICAgQElucHV0KCkgZGF0YXNldDogYW55O1xuICAgIEBJbnB1dCgpIG9wdGlvbnM6IGFueTtcbiAgICBASW5wdXQoKSBjYWxsYmFjazogYW55O1xuICAgIEBJbnB1dCgpIGRvbnV0TGFiZWxzOiBhbnk7XG4gICAgQE91dHB1dCgpIG9uUGxvdENsaWNrID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG4gICAgQE91dHB1dCgpIG9uUGxvdEhvdmVyID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50UmVmOiBFbGVtZW50UmVmLCBpbmplY3RvcjogSW5qZWN0b3IpIHtcbiAgICAgICAgc3VwZXIoJ3V4RmxvdE5nMScsIGVsZW1lbnRSZWYsIGluamVjdG9yKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbmplY3RvciwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFVwZ3JhZGVDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci91cGdyYWRlL3N0YXRpYyc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnZ3JpZCdcbn0pXG5leHBvcnQgY2xhc3MgR3JpZE5nMUNvbXBvbmVudCBleHRlbmRzIFVwZ3JhZGVDb21wb25lbnQge1xuXG4gICAgQElucHV0KCkgc291cmNlOiBhbnlbXSA9IFtdO1xuICAgIEBJbnB1dCgpIGNvbHVtbnM6IEdyaWRDb2x1bW5bXSA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZvbGxvd2luZyBpbnB1dHMgYXJlIHVuZG9jdW1lbnRlZFxuICAgICAqL1xuICAgIEBJbnB1dCgpIG9wdGlvbnM6IGFueTtcbiAgICBASW5wdXQoKSBldmVudHM6IGFueTtcbiAgICBASW5wdXQoKSBwbHVnaW5zOiBhbnk7XG5cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50UmVmOiBFbGVtZW50UmVmLCBpbmplY3RvcjogSW5qZWN0b3IpIHtcbiAgICAgICAgc3VwZXIoJ2dyaWQnLCBlbGVtZW50UmVmLCBpbmplY3Rvcik7XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdyaWRDb2x1bW4ge1xuICAgIHRpdGxlOiBzdHJpbmc7XG4gICAgdGVtcGxhdGU6IHN0cmluZztcbiAgICB3aWR0aD86IHN0cmluZztcbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEluamVjdG9yLCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVXBncmFkZUNvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL3VwZ3JhZGUvc3RhdGljJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdoaWVyYXJjaHktYmFyJ1xufSlcbmV4cG9ydCBjbGFzcyBIaWVyYXJjaHlCYXJOZzFDb21wb25lbnQgZXh0ZW5kcyBVcGdyYWRlQ29tcG9uZW50IHtcblxuICAgIEBJbnB1dCgpIGRhdGE6IGFueVtdO1xuICAgIEBJbnB1dCgpIG9wdGlvbnM6IEhpZXJhcmNoeUJhck9wdGlvbnM7XG4gICAgQElucHV0KCkgc2VsZWN0Tm9kZTogYW55O1xuICAgIEBJbnB1dCgpIGNvbnRhaW5lckNsYXNzOiBhbnk7XG5cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50UmVmOiBFbGVtZW50UmVmLCBpbmplY3RvcjogSW5qZWN0b3IpIHtcbiAgICAgICAgc3VwZXIoJ2hpZXJhcmNoeUJhcicsIGVsZW1lbnRSZWYsIGluamVjdG9yKTtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSGllcmFyY2h5QmFyT3B0aW9ucyB7XG4gICAgZW5hYmxlZDogYm9vbGVhbjtcbiAgICBvdmVydmlldz86IEZ1bmN0aW9uO1xuICAgIGltYWdlOiBGdW5jdGlvbjtcbiAgICB2YWx1ZUZvcm1hdHRlcjogRnVuY3Rpb247XG4gICAgYWN0aW9uPzoge1xuICAgICAgICB0aXRsZTogc3RyaW5nO1xuICAgICAgICBldmVudDogRnVuY3Rpb247XG4gICAgfTtcbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEluamVjdG9yLCBJbnB1dCwgT3V0cHV0LCBFdmVudEVtaXR0ZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFVwZ3JhZGVDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci91cGdyYWRlL3N0YXRpYyc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnbWFycXVlZS13aXphcmQnXG59KVxuZXhwb3J0IGNsYXNzIE1hcnF1ZWVXaXphcmROZzFDb21wb25lbnQgZXh0ZW5kcyBVcGdyYWRlQ29tcG9uZW50IHtcblxuICAgIEBJbnB1dCgpIHdpemFyZEljb246IHN0cmluZztcbiAgICBASW5wdXQoKSB3aXphcmRTdGVwczogTWFycXVlZVdpemFyZFN0ZXBbXTtcbiAgICBASW5wdXQoKSBidXR0b25PcHRpb25zOiBNYXJxdWVlV2l6YXJkT3B0aW9ucztcbiAgICBASW5wdXQoKSBvbkNoYW5naW5nOiBGdW5jdGlvbjtcbiAgICBASW5wdXQoKSBvbkZpbmlzaGVkOiBGdW5jdGlvbjtcbiAgICBASW5wdXQoKSBvbkZpbmlzaGluZzogRnVuY3Rpb247XG4gICAgQElucHV0KCkgb25DYW5jZWxlZDogRnVuY3Rpb247XG4gICAgQElucHV0KCkgaXNWaXNpdGVkOiBib29sZWFuO1xuICAgIEBJbnB1dCgpIHNpZGVJbmZvOiBNYXJxdWVlV2l6YXJkU2lkZUluZm87XG5cbiAgICBAT3V0cHV0KCkgd2l6YXJkU3RlcHNDaGFuZ2U6IEV2ZW50RW1pdHRlcjxNYXJxdWVlV2l6YXJkU3RlcFtdPiA9IG5ldyBFdmVudEVtaXR0ZXI8TWFycXVlZVdpemFyZFN0ZXBbXT4oKTtcblxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIGluamVjdG9yOiBJbmplY3Rvcikge1xuICAgICAgICBzdXBlcignbWFycXVlZVdpemFyZCcsIGVsZW1lbnRSZWYsIGluamVjdG9yKTtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWFycXVlZVdpemFyZFN0ZXAge1xuICAgIHRpdGxlOiBzdHJpbmc7XG4gICAgaHRtbD86IHN0cmluZztcbiAgICBoZWFkZXI/OiBzdHJpbmc7XG4gICAgdGVtcGxhdGVVcmw/OiBzdHJpbmc7XG4gICAgaGlkZGVuPzogYm9vbGVhbjtcbiAgICBlcnJvcj86IGJvb2xlYW47XG4gICAgY29tcGxldGVkPzogYm9vbGVhbjtcbiAgICB2aXNpdGVkPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNYXJxdWVlV2l6YXJkT3B0aW9ucyB7XG4gICAgbmV4dFRleHQ/OiBzdHJpbmc7XG4gICAgcHJldmlvdXNUZXh0Pzogc3RyaW5nO1xuICAgIGZpbmlzaFRleHQ/OiBzdHJpbmc7XG4gICAgc2hvd05leHQ/OiBib29sZWFuO1xuICAgIHNob3dQcmV2aW91cz86IGJvb2xlYW47XG4gICAgc2hvd0ZpbmlzaD86IGJvb2xlYW47XG4gICAgbmV4dFRvb2x0aXA/OiBzdHJpbmc7XG4gICAgcHJldmlvdXNUb29sdGlwPzogc3RyaW5nO1xuICAgIGZpbmlzaFRvb2x0aXA/OiBzdHJpbmc7XG4gICAgcHJldmlvdXNFbmFibGVkPzogYm9vbGVhbjtcbiAgICBuZXh0RW5hYmxlZD86IGJvb2xlYW47XG4gICAgZmluaXNoRW5hYmxlZD86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWFycXVlZVdpemFyZFNpZGVJbmZvIHtcbiAgICB0aXRsZTogc3RyaW5nO1xuICAgIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbmplY3RvciwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFVwZ3JhZGVDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci91cGdyYWRlL3N0YXRpYyc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnbmVzdGVkLWRvbnV0J1xufSlcbmV4cG9ydCBjbGFzcyBOZXN0ZWREb251dE5nMUNvbXBvbmVudCBleHRlbmRzIFVwZ3JhZGVDb21wb25lbnQge1xuXG4gICAgQElucHV0KCkgZGF0YXNldDogYW55O1xuICAgIEBJbnB1dCgpIG9wdGlvbnM6IGFueTtcblxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIGluamVjdG9yOiBJbmplY3Rvcikge1xuICAgICAgICBzdXBlcigndXhOZXN0ZWREb251dE5nMScsIGVsZW1lbnRSZWYsIGluamVjdG9yKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbmplY3RvciwgSW5wdXQsIE91dHB1dCwgRXZlbnRFbWl0dGVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBVcGdyYWRlQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvdXBncmFkZS9zdGF0aWMnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ29yZ2FuaXphdGlvbi1jaGFydCdcbn0pXG5leHBvcnQgY2xhc3MgT3JnYW5pemF0aW9uQ2hhcnROZzFDb21wb25lbnQgZXh0ZW5kcyBVcGdyYWRlQ29tcG9uZW50IHtcblxuICAgIEBJbnB1dCgpIGRhdGE6IGFueTtcbiAgICBASW5wdXQoKSBvcHRpb25zOiBhbnk7XG4gICAgQE91dHB1dCgpIGRhdGFDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcbiAgICBAT3V0cHV0KCkgb3B0aW9uc0NoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZjogRWxlbWVudFJlZiwgaW5qZWN0b3I6IEluamVjdG9yKSB7XG4gICAgICAgIHN1cGVyKCd1eE9yZ2FuaXphdGlvbkNoYXJ0TmcxJywgZWxlbWVudFJlZiwgaW5qZWN0b3IpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEluamVjdG9yLCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVXBncmFkZUNvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL3VwZ3JhZGUvc3RhdGljJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdwYXJ0aXRpb24tbWFwJ1xufSlcbmV4cG9ydCBjbGFzcyBQYXJ0aXRpb25NYXBOZzFDb21wb25lbnQgZXh0ZW5kcyBVcGdyYWRlQ29tcG9uZW50IHtcblxuICAgIEBJbnB1dCgpIGNoYXJ0RGF0YTogYW55O1xuICAgIEBJbnB1dCgpIGNoYXJ0T3B0aW9uczogYW55O1xuICAgIEBJbnB1dCgpIGNoYXJ0TG9hZGluZzogYW55O1xuXG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZjogRWxlbWVudFJlZiwgaW5qZWN0b3I6IEluamVjdG9yKSB7XG4gICAgICAgIHN1cGVyKCd1eFBhcnRpdGlvbk1hcE5nMScsIGVsZW1lbnRSZWYsIGluamVjdG9yKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbmplY3RvciwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFVwZ3JhZGVDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci91cGdyYWRlL3N0YXRpYyc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnYmFyLWNoYXJ0J1xufSlcbmV4cG9ydCBjbGFzcyBQZWl0eUJhckNoYXJ0TmcxQ29tcG9uZW50IGV4dGVuZHMgVXBncmFkZUNvbXBvbmVudCB7XG5cbiAgICBASW5wdXQoKSBkYXRhOiBhbnk7XG4gICAgQElucHV0KCkgb3B0aW9uczogYW55O1xuXG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZjogRWxlbWVudFJlZiwgaW5qZWN0b3I6IEluamVjdG9yKSB7XG4gICAgICAgIHN1cGVyKCd1eFBlaXR5QmFyQ2hhcnROZzEnLCBlbGVtZW50UmVmLCBpbmplY3Rvcik7XG4gICAgfVxufSIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSW5qZWN0b3IsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBVcGdyYWRlQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvdXBncmFkZS9zdGF0aWMnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ2xpbmUtY2hhcnQnXG59KVxuZXhwb3J0IGNsYXNzIFBlaXR5TGluZUNoYXJ0TmcxQ29tcG9uZW50IGV4dGVuZHMgVXBncmFkZUNvbXBvbmVudCB7XG5cbiAgICBASW5wdXQoKSBkYXRhOiBhbnk7XG4gICAgQElucHV0KCkgb3B0aW9uczogYW55O1xuXG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZjogRWxlbWVudFJlZiwgaW5qZWN0b3I6IEluamVjdG9yKSB7XG4gICAgICAgIHN1cGVyKCd1eFBlaXR5TGluZUNoYXJ0TmcxJywgZWxlbWVudFJlZiwgaW5qZWN0b3IpO1xuICAgIH1cbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEluamVjdG9yLCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVXBncmFkZUNvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL3VwZ3JhZGUvc3RhdGljJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdwaWUtY2hhcnQnXG59KVxuZXhwb3J0IGNsYXNzIFBlaXR5UGllQ2hhcnROZzFDb21wb25lbnQgZXh0ZW5kcyBVcGdyYWRlQ29tcG9uZW50IHtcblxuICAgIEBJbnB1dCgpIGRhdGE6IGFueTtcbiAgICBASW5wdXQoKSBvcHRpb25zOiBhbnk7XG5cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50UmVmOiBFbGVtZW50UmVmLCBpbmplY3RvcjogSW5qZWN0b3IpIHtcbiAgICAgICAgc3VwZXIoJ3V4UGVpdHlQaWVDaGFydE5nMScsIGVsZW1lbnRSZWYsIGluamVjdG9yKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbmplY3RvciwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFVwZ3JhZGVDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci91cGdyYWRlL3N0YXRpYyc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAndXBkYXRpbmctbGluZS1jaGFydCdcbn0pXG5leHBvcnQgY2xhc3MgUGVpdHlVcGRhdGluZ0xpbmVDaGFydE5nMUNvbXBvbmVudCBleHRlbmRzIFVwZ3JhZGVDb21wb25lbnQge1xuXG4gICAgQElucHV0KCkgZGF0YTogYW55O1xuICAgIEBJbnB1dCgpIG9wdGlvbnM6IGFueTtcbiAgICBASW5wdXQoKSBtZXRob2Q6IGFueTtcbiAgICBASW5wdXQoKSB1cGRhdGVpbnRlcnZhbDogYW55O1xuXG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZjogRWxlbWVudFJlZiwgaW5qZWN0b3I6IEluamVjdG9yKSB7XG4gICAgICAgIHN1cGVyKCd1eFBlaXR5VXBkYXRpbmdMaW5lQ2hhcnROZzEnLCBlbGVtZW50UmVmLCBpbmplY3Rvcik7XG4gICAgfVxufSIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSW5qZWN0b3IsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBVcGdyYWRlQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvdXBncmFkZS9zdGF0aWMnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ3NhbmtleSdcbn0pXG5leHBvcnQgY2xhc3MgU2Fua2V5TmcxQ29tcG9uZW50IGV4dGVuZHMgVXBncmFkZUNvbXBvbmVudCB7XG5cbiAgICBASW5wdXQoKSBjaGFydFNpemU6IGFueTtcbiAgICBASW5wdXQoKSBjaGFydERhdGE6IGFueTtcbiAgICBASW5wdXQoKSBvcHRpb25zOiBhbnk7XG4gICAgQElucHV0KCkgY2xpY2s6IGFueTtcblxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIGluamVjdG9yOiBJbmplY3Rvcikge1xuICAgICAgICBzdXBlcigndXhTYW5rZXlOZzEnLCBlbGVtZW50UmVmLCBpbmplY3Rvcik7XG4gICAgfVxufSIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSW5qZWN0b3IsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBVcGdyYWRlQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvdXBncmFkZS9zdGF0aWMnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ3NlYXJjaC10b29sYmFyJ1xufSlcbmV4cG9ydCBjbGFzcyBTZWFyY2hUb29sYmFyTmcxQ29tcG9uZW50IGV4dGVuZHMgVXBncmFkZUNvbXBvbmVudCB7XG5cbiAgICBASW5wdXQoKSBzZWFyY2hUeXBlYWhlYWQ6IGFueVtdO1xuICAgIEBJbnB1dCgpIHBsYWNlSG9sZGVyOiBzdHJpbmc7XG4gICAgQElucHV0KCkgY2xvc2VTZWFyY2g6IHN0cmluZztcbiAgICBASW5wdXQoKSBvblNlYXJjaDogRnVuY3Rpb247XG4gICAgQElucHV0KCkgb25Gb2N1czogRnVuY3Rpb247XG5cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50UmVmOiBFbGVtZW50UmVmLCBpbmplY3RvcjogSW5qZWN0b3IpIHtcbiAgICAgICAgc3VwZXIoJ3NlYXJjaFRvb2xiYXInLCBlbGVtZW50UmVmLCBpbmplY3Rvcik7XG4gICAgfVxufSIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBJbmplY3RvciwgSW5wdXQsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVXBncmFkZUNvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL3VwZ3JhZGUvc3RhdGljJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdzZWxlY3QtdGFibGUnXG59KVxuZXhwb3J0IGNsYXNzIFNlbGVjdFRhYmxlTmcxQ29tcG9uZW50IGV4dGVuZHMgVXBncmFkZUNvbXBvbmVudCB7XG5cbiAgICBASW5wdXQoKSB2YWx1ZXM6IGFueVtdO1xuICAgIEBJbnB1dCgpIG11bHRpcGxlU2VsZWN0OiBib29sZWFuO1xuICAgIEBJbnB1dCgpIHNlbGVjdEtleTogc3RyaW5nO1xuICAgIEBJbnB1dCgpIHNlbGVjdGVkOiBzdHJpbmc7XG4gICAgQElucHV0KCkgc2VhcmNoVGV4dDogc3RyaW5nO1xuICAgIEBJbnB1dCgpIHRhYmxlSGVpZ2h0OiBzdHJpbmc7XG4gICAgQElucHV0KCkgdGVtcGxhdGU6IHN0cmluZztcbiAgICBASW5wdXQoKSB0ZW1wbGF0ZVVybDogc3RyaW5nO1xuICAgIEBJbnB1dCgpIHNlbGVjdEhpZGRlbkl0ZW1zOiAnY2xlYXInIHwgJ3Jlc2VsZWN0JztcblxuICAgIEBPdXRwdXQoKSBzZWxlY3RlZENoYW5nZTogRXZlbnRFbWl0dGVyPHN0cmluZz4gPSBuZXcgRXZlbnRFbWl0dGVyPHN0cmluZz4oKTtcblxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIGluamVjdG9yOiBJbmplY3Rvcikge1xuICAgICAgICBzdXBlcignc2VsZWN0VGFibGUnLCBlbGVtZW50UmVmLCBpbmplY3Rvcik7XG4gICAgfVxufSIsImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSW5qZWN0b3IsIElucHV0LCBPdXRwdXQsIEV2ZW50RW1pdHRlciwgZm9yd2FyZFJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVXBncmFkZUNvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL3VwZ3JhZGUvc3RhdGljJztcbmltcG9ydCB7IENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBOR19WQUxVRV9BQ0NFU1NPUiB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuZXhwb3J0IGNvbnN0IFNMSURFUl9DSEFSVF9WQUxVRV9BQ0NFU1NPUjogYW55ID0ge1xuICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IFNsaWRlckNoYXJ0TmcxQ29tcG9uZW50KSxcbiAgICBtdWx0aTogdHJ1ZVxufTtcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdzbGlkZXItY2hhcnQnLFxuICAgIHByb3ZpZGVyczogW1NMSURFUl9DSEFSVF9WQUxVRV9BQ0NFU1NPUl1cbn0pXG5leHBvcnQgY2xhc3MgU2xpZGVyQ2hhcnROZzFDb21wb25lbnQgZXh0ZW5kcyBVcGdyYWRlQ29tcG9uZW50IGltcGxlbWVudHMgQ29udHJvbFZhbHVlQWNjZXNzb3Ige1xuXG4gICAgQElucHV0KCkgc2xpZGVyT3B0aW9uczogYW55O1xuICAgIEBJbnB1dCgpIG5nTW9kZWw6IGFueTtcbiAgICBASW5wdXQoKSBjaGFydE9wdGlvbnM6IGFueTtcbiAgICBASW5wdXQoKSBjaGFydERhdGE6IGFueTtcblxuICAgIEBPdXRwdXQoKSBuZ01vZGVsQ2hhbmdlOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZjogRWxlbWVudFJlZiwgaW5qZWN0b3I6IEluamVjdG9yKSB7XG4gICAgICAgIHN1cGVyKCdzbGlkZXJDaGFydCcsIGVsZW1lbnRSZWYsIGluamVjdG9yKTtcbiAgICB9XG5cbiAgICB3cml0ZVZhbHVlKG9iajogYW55KTogdm9pZCB7IH1cblxuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm46IGFueSk6IHZvaWQgeyB9XG5cbiAgICByZWdpc3Rlck9uVG91Y2hlZChmbjogYW55KTogdm9pZCB7IH1cbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEluamVjdG9yLCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVXBncmFkZUNvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL3VwZ3JhZGUvc3RhdGljJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdzb2NpYWwtY2hhcnQnXG59KVxuZXhwb3J0IGNsYXNzIFNvY2lhbENoYXJ0TmcxQ29tcG9uZW50IGV4dGVuZHMgVXBncmFkZUNvbXBvbmVudCB7XG5cbiAgICBASW5wdXQoKSBkYXRhOiBhbnk7XG4gICAgQElucHV0KCkgb3B0aW9uczogYW55O1xuICAgIEBJbnB1dCgpIHdpZHRoOiBhbnk7XG4gICAgQElucHV0KCkgaGVpZ2h0OiBhbnk7XG4gICAgQElucHV0KCkgYXBpOiBhbnk7XG4gICAgQElucHV0KCkgY29tbXVuaXRpZXM6IGFueTtcbiAgICBASW5wdXQoKSBkZXRhaWxTdHlsZTogYW55O1xuICAgIEBJbnB1dCgpIHBvcG92ZXJTdHlsZTogYW55O1xuICAgIEBJbnB1dCgpIG5vZGVEZXRhaWw6IGFueTtcbiAgICBASW5wdXQoKSBlZGdlRGV0YWlsOiBhbnk7XG4gICAgQElucHV0KCkgbm9kZVBvcG92ZXI6IGFueTtcbiAgICBASW5wdXQoKSBlZGdlUG9wb3ZlcjogYW55O1xuICAgIEBJbnB1dCgpIGZvcmNlQXRsYXNEdXJhdGlvbjogYW55O1xuICAgIEBJbnB1dCgpIG5vZGVTaXplQXR0cmlidXRlOiBhbnk7XG4gICAgQElucHV0KCkgc3RhcnRNYXhpbWl6ZWQ6IGFueTtcbiAgICBASW5wdXQoKSBzdGFydE1heGltaXNlZDogYW55O1xuICAgIEBJbnB1dCgpIHNob3dNYXhpbWl6ZUNvbnRyb2w6IGFueTtcbiAgICBASW5wdXQoKSBzaG93TWF4aW1pc2VDb250cm9sOiBhbnk7XG4gICAgQElucHV0KCkgc29jaWFsQ2hhcnRDb250YWluZXI6IGFueTtcbiAgICBASW5wdXQoKSBmdWxsc2NyZWVuQnV0dG9uUG9zaXRpb246IGFueTtcbiAgICBASW5wdXQoKSBsb2NhbFN0cmluZ3M6IGFueTtcbiAgICBASW5wdXQoKSBjaGFydFRpdGxlOiBhbnk7XG4gICAgQElucHV0KCkgdGl0bGVEaXNwbGF5VGltZTogYW55O1xuICAgIEBJbnB1dCgpIGVkZ2VXZWlnaHRJbmZsdWVuY2U6IGFueTtcbiAgICBASW5wdXQoKSBtaW5MYWJlbHM6IGFueTtcbiAgICBcblxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIGluamVjdG9yOiBJbmplY3Rvcikge1xuICAgICAgICBzdXBlcigndXhTb2NpYWxDaGFydE5nMScsIGVsZW1lbnRSZWYsIGluamVjdG9yKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbmplY3RvciwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFVwZ3JhZGVDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci91cGdyYWRlL3N0YXRpYyc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnc29ydC1kaXJlY3Rpb24tdG9nZ2xlJ1xufSlcbmV4cG9ydCBjbGFzcyBTb3J0RGlyZWN0aW9uVG9nZ2xlTmcxQ29tcG9uZW50IGV4dGVuZHMgVXBncmFkZUNvbXBvbmVudCB7XG5cbiAgICBASW5wdXQoKSBsYWJlbDogc3RyaW5nO1xuICAgIEBJbnB1dCgpIHNvcnRlcnM6IFNvcnREaXJlY3Rpb25Ub2dnbGVTb3J0ZXJbXTtcbiAgICBASW5wdXQoKSBkZXNjZW5kOiBib29sZWFuO1xuXG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZjogRWxlbWVudFJlZiwgaW5qZWN0b3I6IEluamVjdG9yKSB7XG4gICAgICAgIHN1cGVyKCdzb3J0RGlyZWN0aW9uVG9nZ2xlJywgZWxlbWVudFJlZiwgaW5qZWN0b3IpO1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBTb3J0RGlyZWN0aW9uVG9nZ2xlU29ydGVyIHtcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgc29ydDogc3RyaW5nO1xuICAgIGRlZmF1bHRTb3J0ZXI6IGJvb2xlYW47XG4gICAgc2VsZWN0OiBGdW5jdGlvbjtcbn0iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSW5qZWN0b3IsIElucHV0LCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFVwZ3JhZGVDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci91cGdyYWRlL3N0YXRpYyc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAndHJlZWdyaWQnXG59KVxuZXhwb3J0IGNsYXNzIFRyZWVHcmlkTmcxQ29tcG9uZW50IGV4dGVuZHMgVXBncmFkZUNvbXBvbmVudCB7XG5cbiAgICBASW5wdXQoKSBkYXRhOiBhbnlbXSB8IEZ1bmN0aW9uO1xuICAgIEBJbnB1dCgpIGNvbHVtbnM6IFRyZWVHcmlkQ29sdW1uW107XG4gICAgQElucHV0KCkgdHJlZURhdGE6IFRyZWVHcmlkRGF0YVtdO1xuICAgIEBJbnB1dCgpIHNlbGVjdGVkOiBhbnlbXTtcbiAgICBASW5wdXQoKSBjdXJyZW50Um93OiBhbnk7XG4gICAgQElucHV0KCkgb3B0aW9uczogVHJlZUdyaWRPcHRpb25zO1xuXG4gICAgQE91dHB1dCgpIG9wdGlvbnNDaGFuZ2U6IEV2ZW50RW1pdHRlcjxUcmVlR3JpZE9wdGlvbnM+ID0gbmV3IEV2ZW50RW1pdHRlcjxUcmVlR3JpZE9wdGlvbnM+KCk7XG4gICAgQE91dHB1dCgpIHNlbGVjdGVkQ2hhbmdlOiBFdmVudEVtaXR0ZXI8YW55W10+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnlbXT4oKTtcbiAgICBAT3V0cHV0KCkgY3VycmVudFJvd0NoYW5nZTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcbiAgICBAT3V0cHV0KCkgdHJlZURhdGFDaGFuZ2U6IEV2ZW50RW1pdHRlcjxUcmVlR3JpZERhdGFbXT4gPSBuZXcgRXZlbnRFbWl0dGVyPFRyZWVHcmlkRGF0YVtdPigpO1xuXG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZjogRWxlbWVudFJlZiwgaW5qZWN0b3I6IEluamVjdG9yKSB7XG4gICAgICAgIHN1cGVyKCd0cmVlZ3JpZCcsIGVsZW1lbnRSZWYsIGluamVjdG9yKTtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJlZUdyaWRDb2x1bW4ge1xuICAgIG5hbWU6IHN0cmluZztcbiAgICB2YWx1ZT86IHN0cmluZyB8IEZ1bmN0aW9uO1xuICAgIHRlbXBsYXRlPzogc3RyaW5nO1xuICAgIGhlYWRlckNsYXNzPzogc3RyaW5nO1xuICAgIGNlbGxDbGFzcz86IHN0cmluZztcbiAgICB3aWR0aD86IHN0cmluZztcbiAgICB0b29sdGlwPzogc3RyaW5nO1xuICAgIHRvb2x0aXBQbGFjZW1lbnQ/OiAndG9wJyB8ICdib3R0b20nIHwgJ2xlZnQnIHwgJ3JpZ2h0Jztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUcmVlR3JpZERhdGEge1xuICAgIGRhdGFJdGVtOiBhbnk7XG4gICAgY2hpbGRyZW46IGFueVtdO1xuICAgIGV4cGFuZGVkOiBib29sZWFuO1xuICAgIGV4cGFuZGluZzogYm9vbGVhbjtcbiAgICBsZXZlbDogbnVtYmVyO1xuICAgIGFwaTogYW55O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRyZWVHcmlkT3B0aW9ucyB7XG4gICAgY2hpbGRyZW5Qcm9wZXJ0eT86IHN0cmluZztcbiAgICBoYXNDaGlsZHJlbj86IEZ1bmN0aW9uO1xuICAgIG1heERlcHRoPzogbnVtYmVyO1xuICAgIGV4cGFuZFRvcExldmVsPzogYm9vbGVhbjtcbiAgICBzZWxlY3Q/OiBhbnk7XG4gICAgZXhwYW5kZXI/OiBhbnk7XG4gICAgaWNvbnM/OiBhbnk7XG4gICAgcm93Q2xhc3M/OiBzdHJpbmcgfCBGdW5jdGlvbjtcbiAgICBzb3J0PzogRnVuY3Rpb247XG59XG4iLCJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEluamVjdG9yLCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVXBncmFkZUNvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL3VwZ3JhZGUvc3RhdGljJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICd0aHVtYm5haWwnXG59KVxuZXhwb3J0IGNsYXNzIFRodW1ibmFpbE5nMUNvbXBvbmVudCBleHRlbmRzIFVwZ3JhZGVDb21wb25lbnQge1xuXG4gICAgQElucHV0KCkgdXJsOiBzdHJpbmc7XG4gICAgQElucHV0KCkgc2hvdzogYm9vbGVhbjtcbiAgICBASW5wdXQoKSB3aWR0aDogc3RyaW5nO1xuICAgIEBJbnB1dCgpIGhlaWdodDogc3RyaW5nO1xuXG4gICAgY29uc3RydWN0b3IoZWxlbWVudFJlZjogRWxlbWVudFJlZiwgaW5qZWN0b3I6IEluamVjdG9yKSB7XG4gICAgICAgIHN1cGVyKCd0aHVtYm5haWwnLCBlbGVtZW50UmVmLCBpbmplY3Rvcik7XG4gICAgfVxufSIsImltcG9ydCB7IEluamVjdGFibGUsIEluamVjdCwgSW5qZWN0b3IgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IElOYXZpZ2F0aW9uTWVudVNlcnZpY2UgfSBmcm9tICcuL25hdmlnYXRpb24tbWVudS5pbnRlcmZhY2UnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgTmF2aWdhdGlvbk1lbnVTZXJ2aWNlIGltcGxlbWVudHMgSU5hdmlnYXRpb25NZW51U2VydmljZSB7XG5cbiAgICBjb25zdHJ1Y3RvciggQEluamVjdCgnJG5hdmlnYXRpb25NZW51JykgcHJpdmF0ZSBfbmF2aWdhdGlvbk1lbnVTZXJ2aWNlOiBJTmF2aWdhdGlvbk1lbnVTZXJ2aWNlKSB7IH1cblxuICAgIHNob3coKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX25hdmlnYXRpb25NZW51U2VydmljZS5zaG93KCk7XG4gICAgfVxuXG4gICAgaGlkZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fbmF2aWdhdGlvbk1lbnVTZXJ2aWNlLmhpZGUoKTtcbiAgICB9XG5cbiAgICB2aXNpYmxlKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmF2aWdhdGlvbk1lbnVTZXJ2aWNlLnZpc2libGUoKTtcbiAgICB9XG5cbiAgICBjb2xsYXBzZUF0V2lkdGgoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hdmlnYXRpb25NZW51U2VydmljZS5jb2xsYXBzZUF0V2lkdGgoKTtcbiAgICB9XG5cbiAgICBzZXRDb2xsYXBzZUF0V2lkdGgod2lkdGg6IG51bWJlcik6IHZvaWQge1xuICAgICAgICB0aGlzLl9uYXZpZ2F0aW9uTWVudVNlcnZpY2Uuc2V0Q29sbGFwc2VBdFdpZHRoKHdpZHRoKTtcbiAgICB9XG5cbiAgICBzZXREZWZhdWx0Q29sbGFwc2VBdFdpZHRoKCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9uYXZpZ2F0aW9uTWVudVNlcnZpY2Uuc2V0RGVmYXVsdENvbGxhcHNlQXRXaWR0aCgpO1xuICAgIH1cblxufVxuXG5leHBvcnQgZnVuY3Rpb24gbmF2aWdhdGlvbk1lbnVTZXJ2aWNlRmFjdG9yeShpbmplY3RvcjogSW5qZWN0b3IpIHtcbiAgICByZXR1cm4gaW5qZWN0b3IuZ2V0KCckbmF2aWdhdGlvbk1lbnUnKTtcbn1cblxuZXhwb3J0IGNvbnN0IG5hdmlnYXRpb25NZW51U2VydmljZVByb3ZpZGVyID0ge1xuICAgIHByb3ZpZGU6ICckbmF2aWdhdGlvbk1lbnUnLFxuICAgIHVzZUZhY3Rvcnk6IG5hdmlnYXRpb25NZW51U2VydmljZUZhY3RvcnksXG4gICAgZGVwczogWyckaW5qZWN0b3InXVxufTsiLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBJbmplY3QsIEluamVjdG9yIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBJUGRmU2VydmljZSwgUGRmQ29sdW1ucywgUGRmT3B0aW9ucywgUGRmRG9jdW1lbnQgfSBmcm9tICcuL3BkZi5pbnRlcmZhY2UnO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgUGRmU2VydmljZSBpbXBsZW1lbnRzIElQZGZTZXJ2aWNlIHtcbiAgICBcbiAgICBjb25zdHJ1Y3RvcihASW5qZWN0KCckcGRmJykgcHJpdmF0ZSBfcGRmU2VydmljZTogSVBkZlNlcnZpY2UpIHsgfVxuICAgIFxuICAgIGNyZWF0ZVRhYmxlKGNvbHVtbnM6IFBkZkNvbHVtbnMsIHJvd3M6IGFueVtdLCBvcHRpb25zOiBQZGZPcHRpb25zID0ge30pOiBQZGZEb2N1bWVudCB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wZGZTZXJ2aWNlLmNyZWF0ZVRhYmxlKGNvbHVtbnMsIHJvd3MsIG9wdGlvbnMpO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBkZlNlcnZpY2VGYWN0b3J5KGluamVjdG9yOiBJbmplY3Rvcikge1xuICAgIHJldHVybiBpbmplY3Rvci5nZXQoJyRwZGYnKTtcbn1cblxuZXhwb3J0IGNvbnN0IHBkZlNlcnZpY2VQcm92aWRlciA9IHtcbiAgICBwcm92aWRlOiAnJHBkZicsXG4gICAgdXNlRmFjdG9yeTogcGRmU2VydmljZUZhY3RvcnksXG4gICAgZGVwczogWyckaW5qZWN0b3InXVxufTsiLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBJbmplY3QsIEluamVjdG9yIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBJVGltZUFnb1NlcnZpY2UsIFRpbWVBZ29Mb2NhbGl6ZWRUaW1lcyB9IGZyb20gJy4vdGltZS1hZ28uaW50ZXJmYWNlJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFRpbWVBZ29TZXJ2aWNlIGltcGxlbWVudHMgSVRpbWVBZ29TZXJ2aWNlIHtcblxuICAgIGNvbnN0cnVjdG9yKEBJbmplY3QoJ3RpbWVBZ29TZXJ2aWNlJykgcHJpdmF0ZSBfdGltZUFnb1NlcnZpY2U6IElUaW1lQWdvU2VydmljZSkgeyB9XG5cbiAgICBzZXRTdHJpbmdzKHN0cmluZ3M6IFRpbWVBZ29Mb2NhbGl6ZWRUaW1lcyk6IHZvaWQge1xuICAgICAgICB0aGlzLl90aW1lQWdvU2VydmljZS5zZXRTdHJpbmdzKHN0cmluZ3MpO1xuICAgIH1cblxuICAgIHRpbWVTaW5jZShwYXN0OiBEYXRlLCBwcmVzZW50OiBEYXRlKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RpbWVBZ29TZXJ2aWNlLnRpbWVTaW5jZShwYXN0LCBwcmVzZW50KTtcbiAgICB9XG5cbiAgICB0aW1lU2luY2VOb3cobW9tZW50OiBEYXRlKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RpbWVBZ29TZXJ2aWNlLnRpbWVTaW5jZU5vdyhtb21lbnQpO1xuICAgIH1cblxufVxuXG5leHBvcnQgZnVuY3Rpb24gdGltZUFnb1NlcnZpY2VGYWN0b3J5KGluamVjdG9yOiBJbmplY3Rvcikge1xuICAgIHJldHVybiBpbmplY3Rvci5nZXQoJ3RpbWVBZ29TZXJ2aWNlJyk7XG59XG5cbmV4cG9ydCBjb25zdCB0aW1lQWdvU2VydmljZVByb3ZpZGVyID0ge1xuICAgIHByb3ZpZGU6ICd0aW1lQWdvU2VydmljZScsXG4gICAgdXNlRmFjdG9yeTogdGltZUFnb1NlcnZpY2VGYWN0b3J5LFxuICAgIGRlcHM6IFsnJGluamVjdG9yJ11cbn07IiwiaW1wb3J0IHsgTmdNb2R1bGUsIEluamVjdG9yIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IEZsb2F0aW5nQWN0aW9uQnV0dG9uTmcxQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL2Zsb2F0aW5nLWFjdGlvbi1idXR0b24vZmxvYXRpbmctYWN0aW9uLWJ1dHRvbi5jb21wb25lbnQnO1xuaW1wb3J0IHsgRmxvdE5nMUNvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50cy9mbG90L2Zsb3QuY29tcG9uZW50JztcbmltcG9ydCB7IE5lc3RlZERvbnV0TmcxQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL25lc3RlZC1kb251dC9uZXN0ZWQtZG9udXQuY29tcG9uZW50JztcbmltcG9ydCB7IE9yZ2FuaXphdGlvbkNoYXJ0TmcxQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL29yZ2FuaXphdGlvbi1jaGFydC9vcmdhbml6YXRpb24tY2hhcnQuY29tcG9uZW50JztcbmltcG9ydCB7IFBhcnRpdGlvbk1hcE5nMUNvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50cy9wYXJ0aXRpb24tbWFwL3BhcnRpdGlvbi1tYXAuY29tcG9uZW50JztcbmltcG9ydCB7IFBlaXR5QmFyQ2hhcnROZzFDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvcGVpdHktY2hhcnQvcGVpdHktYmFyLWNoYXJ0LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBQZWl0eUxpbmVDaGFydE5nMUNvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50cy9wZWl0eS1jaGFydC9wZWl0eS1saW5lLWNoYXJ0LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBQZWl0eVBpZUNoYXJ0TmcxQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL3BlaXR5LWNoYXJ0L3BlaXR5LXBpZS1jaGFydC5jb21wb25lbnQnO1xuaW1wb3J0IHsgUGVpdHlVcGRhdGluZ0xpbmVDaGFydE5nMUNvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50cy9wZWl0eS1jaGFydC9wZWl0eS11cGRhdGluZy1saW5lLWNoYXJ0LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBTYW5rZXlOZzFDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvc2Fua2V5LWNoYXJ0L3NhbmtleS5jb21wb25lbnQnO1xuaW1wb3J0IHsgU29jaWFsQ2hhcnROZzFDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvc29jaWFsLWNoYXJ0L3NvY2lhbC1jaGFydC5jb21wb25lbnQnO1xuaW1wb3J0IHsgVGltZUFnb1NlcnZpY2UsIHRpbWVBZ29TZXJ2aWNlUHJvdmlkZXIgfSBmcm9tICcuL3NlcnZpY2VzL3RpbWUtYWdvL3RpbWUtYWdvLnNlcnZpY2UnO1xuaW1wb3J0IHsgUGRmU2VydmljZSwgcGRmU2VydmljZVByb3ZpZGVyIH0gZnJvbSAnLi9zZXJ2aWNlcy9wZGYvcGRmLnNlcnZpY2UnO1xuaW1wb3J0IHsgTmF2aWdhdGlvbk1lbnVTZXJ2aWNlLCBuYXZpZ2F0aW9uTWVudVNlcnZpY2VQcm92aWRlciB9IGZyb20gJy4vc2VydmljZXMvbmF2aWdhdGlvbi1tZW51L25hdmlnYXRpb24tbWVudS5zZXJ2aWNlJztcbmltcG9ydCB7IEdyaWROZzFDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvZ3JpZC9ncmlkLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBUaHVtYm5haWxOZzFDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvdGh1bWJuYWlsL3RodW1ibmFpbC5jb21wb25lbnQnO1xuaW1wb3J0IHsgSGllcmFyY2h5QmFyTmcxQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL2hpZXJhcmNoeS1iYXIvaGllcmFyY2h5LWJhci5jb21wb25lbnQnO1xuaW1wb3J0IHsgQ29udGFjdHNOZzFDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvY29udGFjdHMvY29udGFjdHMuY29tcG9uZW50JztcbmltcG9ydCB7IEV4cGFuZElucHV0TmcxQ29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzL2V4cGFuZC1pbnB1dC9leHBhbmQtaW5wdXQuY29tcG9uZW50JztcbmltcG9ydCB7IFNvcnREaXJlY3Rpb25Ub2dnbGVOZzFDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvc29ydC1kaXJlY3Rpb24tdG9nZ2xlL3NvcnQtZGlyZWN0aW9uLXRvZ2dsZS5jb21wb25lbnQnO1xuaW1wb3J0IHsgU2VhcmNoVG9vbGJhck5nMUNvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50cy9zZWFyY2gtdG9vbGJhci9zZWFyY2gtdG9vbGJhci5jb21wb25lbnQnO1xuaW1wb3J0IHsgVHJlZUdyaWROZzFDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvdHJlZS1ncmlkL3RyZWUtZ3JpZC5jb21wb25lbnQnO1xuaW1wb3J0IHsgU2VsZWN0VGFibGVOZzFDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvc2VsZWN0LXRhYmxlL3NlbGVjdC10YWJsZS5jb21wb25lbnQnO1xuaW1wb3J0IHsgTWFycXVlZVdpemFyZE5nMUNvbXBvbmVudCB9IGZyb20gJy4vY29tcG9uZW50cy9tYXJxdWVlLXdpemFyZC9tYXJxdWVlLXdpemFyZC5jb21wb25lbnQnO1xuaW1wb3J0IHsgU2xpZGVyQ2hhcnROZzFDb21wb25lbnQgfSBmcm9tICcuL2NvbXBvbmVudHMvc2xpZGVyLWNoYXJ0L3NsaWRlci1jaGFydC5kaXJlY3RpdmUnO1xuXG5jb25zdCBkZWNsYXJhdGlvbnMgPSBbXG4gICAgQ29udGFjdHNOZzFDb21wb25lbnQsXG4gICAgRXhwYW5kSW5wdXROZzFDb21wb25lbnQsXG4gICAgRmxvYXRpbmdBY3Rpb25CdXR0b25OZzFDb21wb25lbnQsXG4gICAgRmxvdE5nMUNvbXBvbmVudCxcbiAgICBHcmlkTmcxQ29tcG9uZW50LFxuICAgIEhpZXJhcmNoeUJhck5nMUNvbXBvbmVudCxcbiAgICBNYXJxdWVlV2l6YXJkTmcxQ29tcG9uZW50LFxuICAgIE5lc3RlZERvbnV0TmcxQ29tcG9uZW50LFxuICAgIE9yZ2FuaXphdGlvbkNoYXJ0TmcxQ29tcG9uZW50LFxuICAgIFBhcnRpdGlvbk1hcE5nMUNvbXBvbmVudCxcbiAgICBQZWl0eUJhckNoYXJ0TmcxQ29tcG9uZW50LFxuICAgIFBlaXR5TGluZUNoYXJ0TmcxQ29tcG9uZW50LFxuICAgIFBlaXR5UGllQ2hhcnROZzFDb21wb25lbnQsXG4gICAgUGVpdHlVcGRhdGluZ0xpbmVDaGFydE5nMUNvbXBvbmVudCxcbiAgICBTYW5rZXlOZzFDb21wb25lbnQsXG4gICAgU2VhcmNoVG9vbGJhck5nMUNvbXBvbmVudCxcbiAgICBTZWxlY3RUYWJsZU5nMUNvbXBvbmVudCxcbiAgICBTbGlkZXJDaGFydE5nMUNvbXBvbmVudCxcbiAgICBTb2NpYWxDaGFydE5nMUNvbXBvbmVudCxcbiAgICBTb3J0RGlyZWN0aW9uVG9nZ2xlTmcxQ29tcG9uZW50LFxuICAgIFRyZWVHcmlkTmcxQ29tcG9uZW50LFxuICAgIFRodW1ibmFpbE5nMUNvbXBvbmVudCxcbl07XG5cbkBOZ01vZHVsZSh7XG4gICAgaW1wb3J0czogW10sXG4gICAgZXhwb3J0czogZGVjbGFyYXRpb25zLFxuICAgIGRlY2xhcmF0aW9uczogZGVjbGFyYXRpb25zLFxuICAgIHByb3ZpZGVyczogW1xuICAgICAgICBuYXZpZ2F0aW9uTWVudVNlcnZpY2VQcm92aWRlcixcbiAgICAgICAgcGRmU2VydmljZVByb3ZpZGVyLFxuICAgICAgICB0aW1lQWdvU2VydmljZVByb3ZpZGVyLFxuICAgICAgICBUaW1lQWdvU2VydmljZSxcbiAgICAgICAgUGRmU2VydmljZSxcbiAgICAgICAgTmF2aWdhdGlvbk1lbnVTZXJ2aWNlLFxuICAgIF0sXG59KVxuZXhwb3J0IGNsYXNzIEh5YnJpZE1vZHVsZSB7IH1cbiIsImltcG9ydCB7IFBpcGUsIEluamVjdGFibGUsIFBpcGVUcmFuc2Zvcm0gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQFBpcGUoe1xuICAgIG5hbWU6ICdzdHJpbmdGaWx0ZXInXG59KVxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFN0cmluZ0ZpbHRlclBpcGUgaW1wbGVtZW50cyBQaXBlVHJhbnNmb3JtIHtcbiAgICB0cmFuc2Zvcm0oaXRlbXM6IGFueVtdLCB2YWx1ZTogc3RyaW5nKTogYW55W10geyAgXG4gICAgICAgIGlmICghaXRlbXMpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbXMuZmlsdGVyKGl0ID0+IGl0LnRvTG93ZXJDYXNlKCkuaW5kZXhPZih2YWx1ZS50b0xvd2VyQ2FzZSgpKSA+PSAwKTtcbiAgICB9XG59IiwiaW1wb3J0IHsgU3RyaW5nRmlsdGVyUGlwZSB9IGZyb20gJy4vc3RyaW5nLWZpbHRlci5waXBlJztcbmltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBOZ01vZHVsZSh7XG4gICAgZXhwb3J0czogW1N0cmluZ0ZpbHRlclBpcGVdLFxuICAgIGRlY2xhcmF0aW9uczogW1N0cmluZ0ZpbHRlclBpcGVdXG59KVxuZXhwb3J0IGNsYXNzIFN0cmluZ0ZpbHRlck1vZHVsZSB7IH1cbiIsImltcG9ydCB7IFN0b3JhZ2VBZGFwdGVyIH0gZnJvbSAnLi9zdG9yYWdlLWFkYXB0ZXInO1xuXG5leHBvcnQgY2xhc3MgQ29va2llQWRhcHRlciBpbXBsZW1lbnRzIFN0b3JhZ2VBZGFwdGVyIHtcblxuICAgIGdldEl0ZW0oa2V5OiBzdHJpbmcpOiBzdHJpbmcge1xuXG4gICAgICAgIGlmIChkb2N1bWVudC5jb29raWUpIHtcblxuICAgICAgICAgICAgLy8gZ2V0IGFsbCB0aGUgY29va2llcyBmb3IgdGhpcyBzaXRlXG4gICAgICAgICAgICBjb25zdCBjb29raWVzID0gZG9jdW1lbnQuY29va2llLnNwbGl0KCc7Jyk7XG5cbiAgICAgICAgICAgIC8vIHByb2Nlc3MgdGhlIGNvb2tpZXMgaW50byBhIGZyb20gd2UgY2FuIGVhc2lseSBtYW5hZ2VcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gY29va2llc1xuICAgICAgICAgICAgICAgIC5tYXAoY29va2llID0+ICh7IGtleTogY29va2llLnNwbGl0KCc9JylbMF0udHJpbSgpLCB2YWx1ZTogY29va2llLnNwbGl0KCc9JylbMV0udHJpbSgpIH0pKVxuICAgICAgICAgICAgICAgIC5maW5kKGNvb2tpZSA9PiBjb29raWUua2V5ID09PSBrZXkpO1xuXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaC52YWx1ZSA6IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBzZXRJdGVtKGtleTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IGAke2tleX09JHt2YWx1ZX07IHBhdGg9L2A7XG4gICAgfVxuXG4gICAgcmVtb3ZlSXRlbShrZXk6IHN0cmluZyk6IHZvaWQge1xuXG4gICAgICAgIGRvY3VtZW50LmNvb2tpZS5zcGxpdCgnOycpLmZvckVhY2goY29va2llID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVxUG9zID0gY29va2llLmluZGV4T2YoJz0nKTtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBlcVBvcyA+IC0xID8gY29va2llLnN1YnN0cigwLCBlcVBvcykudHJpbSgpIDogY29va2llO1xuXG4gICAgICAgICAgICBpZiAobmFtZSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuY29va2llID0gY29va2llLnRyaW0oKS5yZXBsYWNlKC89LiovLCBgPTtleHBpcmVzPSR7bmV3IERhdGUoKS50b1VUQ1N0cmluZygpfTtwYXRoPS9gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgY2xlYXIoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gY2FsbCByZW1vdmUgaXRlbSBvbiBlYWNoIGNvb2tpZVxuICAgICAgICBkb2N1bWVudC5jb29raWUuc3BsaXQoJzsnKS5tYXAoY29va2llID0+IGNvb2tpZS5zcGxpdCgnPScpWzBdLnRyaW0oKSlcbiAgICAgICAgICAgIC5mb3JFYWNoKGNvb2tpZSA9PiB0aGlzLnJlbW92ZUl0ZW0oY29va2llKSk7XG4gICAgfVxuXG4gICAgZ2V0U3VwcG9ydGVkKCk6IFN0b3JhZ2VBZGFwdGVyIHtcbiAgICAgICAgLy8gY29va2llcyBhcmUgc3VwcG9ydGVkIGluIGFsbCBicm93c2Vyc1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbn0iLCJpbXBvcnQgeyBTdG9yYWdlQWRhcHRlciB9IGZyb20gJy4vc3RvcmFnZS1hZGFwdGVyJztcbmltcG9ydCB7IENvb2tpZUFkYXB0ZXIgfSBmcm9tICcuL2Nvb2tpZS1hZGFwdGVyJztcblxuZXhwb3J0IGNsYXNzIExvY2FsU3RvcmFnZUFkYXB0ZXIgaW1wbGVtZW50cyBTdG9yYWdlQWRhcHRlciB7XG5cbiAgICBnZXRJdGVtKGtleTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgfVxuXG4gICAgc2V0SXRlbShrZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIHZhbHVlKTtcbiAgICB9XG5cbiAgICByZW1vdmVJdGVtKGtleTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG4gICAgfVxuXG4gICAgY2xlYXIoKTogdm9pZCB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5jbGVhcigpO1xuICAgIH1cblxuICAgIGdldFN1cHBvcnRlZCgpOiBTdG9yYWdlQWRhcHRlciB7XG5cbiAgICAgICAgLy8gaWYgbG9jYWwgc3RvcmFnZSB2YXJpYWJsZSBkb2VzIG5vdCBleGlzdCBmYWxsIGJhY2sgdG8gY29va2llc1xuICAgICAgICBpZiAoIWxvY2FsU3RvcmFnZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb29raWVBZGFwdGVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0cnkgdG8gbWFrZSBhIHRlc3Qgc2F2ZSB0byBsb2NhbCBzdG9yYWdlIHRvIHNlZSBpZiB0aGVyZSBhcmUgYW55IGV4Y2VwdGlvbnNcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCd1eC1wZXJzaXN0ZW50LWRhdGEtc2VydmljZScsICd1eC1wZXJzaXN0ZW50LWRhdGEtc2VydmljZScpO1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3V4LXBlcnNpc3RlbnQtZGF0YS1zZXJ2aWNlJyk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29va2llQWRhcHRlcigpO1xuICAgICAgICB9XG4gICAgfVxuXG59IiwiaW1wb3J0IHsgU3RvcmFnZUFkYXB0ZXIgfSBmcm9tICcuL3N0b3JhZ2UtYWRhcHRlcic7XG5pbXBvcnQgeyBDb29raWVBZGFwdGVyIH0gZnJvbSAnLi9jb29raWUtYWRhcHRlcic7XG5cbmV4cG9ydCBjbGFzcyBTZXNzaW9uU3RvcmFnZUFkYXB0ZXIgaW1wbGVtZW50cyBTdG9yYWdlQWRhcHRlciB7XG5cbiAgICBnZXRJdGVtKGtleTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgICB9XG5cbiAgICBzZXRJdGVtKGtleTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oa2V5LCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmVtb3ZlSXRlbShrZXk6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICBzZXNzaW9uU3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG4gICAgfVxuXG4gICAgY2xlYXIoKTogdm9pZCB7XG4gICAgICAgIHNlc3Npb25TdG9yYWdlLmNsZWFyKCk7XG4gICAgfVxuXG4gICAgZ2V0U3VwcG9ydGVkKCk6IFN0b3JhZ2VBZGFwdGVyIHtcblxuICAgICAgICAvLyBpZiBsb2NhbCBzdG9yYWdlIHZhcmlhYmxlIGRvZXMgbm90IGV4aXN0IGZhbGwgYmFjayB0byBjb29raWVzXG4gICAgICAgIGlmICghc2Vzc2lvblN0b3JhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ29va2llQWRhcHRlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdHJ5IHRvIG1ha2UgYSB0ZXN0IHNhdmUgdG8gbG9jYWwgc3RvcmFnZSB0byBzZWUgaWYgdGhlcmUgYXJlIGFueSBleGNlcHRpb25zXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKCd1eC1wZXJzaXN0ZW50LWRhdGEtc2VydmljZScsICd1eC1wZXJzaXN0ZW50LWRhdGEtc2VydmljZScpO1xuICAgICAgICAgICAgc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbSgndXgtcGVyc2lzdGVudC1kYXRhLXNlcnZpY2UnKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb29raWVBZGFwdGVyKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbn0iLCJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdG9yYWdlQWRhcHRlciB9IGZyb20gJy4vYWRhcHRlcnMvc3RvcmFnZS1hZGFwdGVyJztcbmltcG9ydCB7IENvb2tpZUFkYXB0ZXIgfSBmcm9tICcuL2FkYXB0ZXJzL2Nvb2tpZS1hZGFwdGVyJztcbmltcG9ydCB7IExvY2FsU3RvcmFnZUFkYXB0ZXIgfSBmcm9tICcuL2FkYXB0ZXJzL2xvY2FsLXN0b3JhZ2UtYWRhcHRlcic7XG5pbXBvcnQgeyBTZXNzaW9uU3RvcmFnZUFkYXB0ZXIgfSBmcm9tICcuL2FkYXB0ZXJzL3Nlc3Npb24tc3RvcmFnZS1hZGFwdGVyJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIFBlcnNpc3RlbnREYXRhU2VydmljZSB7XG5cbiAgICAvKipcbiAgICAgKiBTYXZlIHRoZSBpdGVtIGluIHNvbWUgZm9ybSBvZiBwZXJzaXN0ZW50IHN0b3JhZ2VcbiAgICAgKi9cbiAgICBzZXRJdGVtKGtleTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nLCB0eXBlOiBQZXJzaXN0ZW50RGF0YVN0b3JhZ2VUeXBlID0gUGVyc2lzdGVudERhdGFTdG9yYWdlVHlwZS5Mb2NhbFN0b3JhZ2UpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5nZXRBZGFwdGVyKHR5cGUpLnNldEl0ZW0oa2V5LCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGEgc3RvcmVkIHZhbHVlIGZyb20gcGVyc2lzdGVudCBzdG9yYWdlXG4gICAgICovXG4gICAgZ2V0SXRlbShrZXk6IHN0cmluZywgdHlwZTogUGVyc2lzdGVudERhdGFTdG9yYWdlVHlwZSA9IFBlcnNpc3RlbnREYXRhU3RvcmFnZVR5cGUuTG9jYWxTdG9yYWdlKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWRhcHRlcih0eXBlKS5nZXRJdGVtKGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgc3RvcmVkIHZhbHVlIGZyb20gcGVyc2lzdGVudCBzdG9yYWdlXG4gICAgICovXG4gICAgcmVtb3ZlSXRlbShrZXk6IHN0cmluZywgdHlwZTogUGVyc2lzdGVudERhdGFTdG9yYWdlVHlwZSA9IFBlcnNpc3RlbnREYXRhU3RvcmFnZVR5cGUuTG9jYWxTdG9yYWdlKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZ2V0QWRhcHRlcih0eXBlKS5yZW1vdmVJdGVtKGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgc3RvcmVkIHZhbHVlIGZyb20gcGVyc2lzdGVudCBzdG9yYWdlXG4gICAgICovXG4gICAgY2xlYXIodHlwZTogUGVyc2lzdGVudERhdGFTdG9yYWdlVHlwZSA9IFBlcnNpc3RlbnREYXRhU3RvcmFnZVR5cGUuTG9jYWxTdG9yYWdlKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZ2V0QWRhcHRlcih0eXBlKS5jbGVhcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgYXBwcm9wcmlhdGUgYWRhcHRlciBiYXNlZCBvbiB0aGUgdHlwZSByZXF1ZXN0ZWRcbiAgICAgKi9cbiAgICBwcml2YXRlIGdldEFkYXB0ZXIodHlwZTogUGVyc2lzdGVudERhdGFTdG9yYWdlVHlwZSk6IFN0b3JhZ2VBZGFwdGVyIHtcblxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcblxuICAgICAgICAgICAgY2FzZSBQZXJzaXN0ZW50RGF0YVN0b3JhZ2VUeXBlLkNvb2tpZTpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvb2tpZUFkYXB0ZXIoKTtcblxuICAgICAgICAgICAgY2FzZSBQZXJzaXN0ZW50RGF0YVN0b3JhZ2VUeXBlLkxvY2FsU3RvcmFnZTpcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFN0b3JhZ2VBZGFwdGVyID0gbmV3IExvY2FsU3RvcmFnZUFkYXB0ZXIoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxTdG9yYWdlQWRhcHRlci5nZXRTdXBwb3J0ZWQoKTtcblxuICAgICAgICAgICAgY2FzZSBQZXJzaXN0ZW50RGF0YVN0b3JhZ2VUeXBlLlNlc3Npb25TdG9yYWdlOlxuICAgICAgICAgICAgICAgIGNvbnN0IHNlc3Npb25TdG9yYWdlQWRhcHRlciA9IG5ldyBTZXNzaW9uU3RvcmFnZUFkYXB0ZXIoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2Vzc2lvblN0b3JhZ2VBZGFwdGVyLmdldFN1cHBvcnRlZCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZW51bSBQZXJzaXN0ZW50RGF0YVN0b3JhZ2VUeXBlIHtcbiAgICBMb2NhbFN0b3JhZ2UsXG4gICAgQ29va2llLFxuICAgIFNlc3Npb25TdG9yYWdlXG59IiwiaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgUGVyc2lzdGVudERhdGFTZXJ2aWNlIH0gZnJvbSAnLi9wZXJzaXN0ZW50LWRhdGEuc2VydmljZSc7XG5cbkBOZ01vZHVsZSh7XG4gICAgcHJvdmlkZXJzOiBbUGVyc2lzdGVudERhdGFTZXJ2aWNlXSxcbn0pXG5leHBvcnQgY2xhc3MgUGVyc2lzdGVudERhdGFNb2R1bGUgeyB9XG4iLCJleHBvcnQgYWJzdHJhY3QgY2xhc3MgU3RvcmFnZUFkYXB0ZXIge1xuICAgIGFic3RyYWN0IGdldEl0ZW0oa2V5OiBzdHJpbmcpOiBzdHJpbmc7XG4gICAgYWJzdHJhY3Qgc2V0SXRlbShrZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZyk6IHZvaWQ7XG4gICAgYWJzdHJhY3QgcmVtb3ZlSXRlbShrZXk6IHN0cmluZyk6IHZvaWQ7XG4gICAgYWJzdHJhY3QgY2xlYXIoKTogdm9pZDtcbiAgICBhYnN0cmFjdCBnZXRTdXBwb3J0ZWQoKTogU3RvcmFnZUFkYXB0ZXI7XG59Il0sIm5hbWVzIjpbIkRpcmVjdGl2ZSIsIlN1YmplY3QiLCJJbmplY3RhYmxlIiwiRXZlbnRFbWl0dGVyIiwiQ29tcG9uZW50IiwiSW5wdXQiLCJIb3N0QmluZGluZyIsIk91dHB1dCIsIk5nTW9kdWxlIiwiQ29tbW9uTW9kdWxlIiwiUm91dGVyTW9kdWxlIiwiUmVwbGF5U3ViamVjdCIsInRzbGliXzEuX192YWx1ZXMiLCJOZ1pvbmUiLCJkZWJvdW5jZVRpbWUiLCJFbGVtZW50UmVmIiwiQmVoYXZpb3JTdWJqZWN0IiwiZmlsdGVyIiwibWFwIiwiQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kiLCJDb250ZW50Q2hpbGQiLCJUZW1wbGF0ZVJlZiIsIlZpZXdDaGlsZCIsIk5HX1ZBTFVFX0FDQ0VTU09SIiwiZm9yd2FyZFJlZiIsIkZvcm1zTW9kdWxlIiwidW5pcXVlSWQiLCJwYWlyd2lzZSIsInRha2VVbnRpbCIsImNvbWJpbmVMYXRlc3QiLCJGb2N1c01vbml0b3IiLCJpc1BsYXRmb3JtQnJvd3NlciIsIlJlbmRlcmVyMiIsIkluamVjdCIsIlBMQVRGT1JNX0lEIiwiU3BsaXRDb21wb25lbnQiLCJDb250ZW50Q2hpbGRyZW4iLCJTcGxpdEFyZWFEaXJlY3RpdmUiLCJIb3N0TGlzdGVuZXIiLCJPYnNlcnZhYmxlIiwiRm9jdXNLZXlNYW5hZ2VyIiwiRE9XTl9BUlJPVyIsIlJJR0hUX0FSUk9XIiwiVVBfQVJST1ciLCJMRUZUX0FSUk9XIiwiUXVlcnlMaXN0IiwiQTExeU1vZHVsZSIsIkNoYW5nZURldGVjdG9yUmVmIiwiZnJvbUV2ZW50IiwidG9vbHRpcCIsIkNvbXBvbmVudFBvcnRhbCIsIlZpZXdDb250YWluZXJSZWYiLCJPdmVybGF5IiwiU2Nyb2xsRGlzcGF0Y2hlciIsIk92ZXJsYXlNb2R1bGUiLCJPYnNlcnZlcnNNb2R1bGUiLCJkaXN0aW5jdFVudGlsQ2hhbmdlZCIsIk9wdGlvbmFsIiwidHNsaWJfMS5fX2V4dGVuZHMiLCJ0c2xpYl8xLl9fYXNzaWduIiwiZGVsYXkiLCJWaWV3RW5jYXBzdWxhdGlvbiIsIlBpcGUiLCJTdWJzY3JpcHRpb24iLCJtb250aHMiLCJmaWx0ZXJPcGVyYXRvciIsImF1ZGl0VGltZSIsIm9mIiwiZnJvbSIsImZpcnN0IiwiKChkcmFndWxhTmFtZXNwYWNlKSkuZGVmYXVsdCIsIkxpdmVBbm5vdW5jZXIiLCJIb3N0IiwiVmlld0NoaWxkcmVuIiwidGFwIiwibWVyZ2VNYXAiLCJERUNMQVJBVElPTlMiLCJET0NVTUVOVCIsIkJzRHJvcGRvd25EaXJlY3RpdmUiLCJCc0Ryb3Bkb3duTW9kdWxlIiwidHJpZ2dlciIsInRyYW5zaXRpb24iLCJxdWVyeSIsInN0eWxlIiwic3RhZ2dlciIsImFuaW1hdGUiLCJUb29sdGlwRGlyZWN0aXZlIiwiQXR0cmlidXRlIiwiRVNDQVBFIiwiY29uY2F0Iiwic3dpdGNoTWFwIiwidGltZXIiLCJIdHRwQ2xpZW50IiwiSHR0cENsaWVudE1vZHVsZSIsIk5hdmlnYXRpb25FbmQiLCJTa2lwU2VsZiIsIlJvdXRlciIsIkxvY2F0aW9uU3RyYXRlZ3kiLCJzdGF0ZSIsImRyb3Bkb3duIiwiQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyIiwiTkdfVkFMSURBVE9SUyIsIkVOVEVSIiwiQkFDS1NQQUNFIiwiREVMRVRFIiwiU1BBQ0UiLCJFWFBPUlRTIiwiTmdNb2RlbCIsInNraXAiLCJJbmplY3RvciIsIlVwZ3JhZGVDb21wb25lbnQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTs7OztvQkFFQ0EsY0FBUyxTQUFDO3dCQUNULFFBQVEsRUFBRSwyQkFBMkI7cUJBQ3RDOzs2Q0FKRDs7Ozs7OztBQ0FBOztrQ0FNOEIsS0FBSzs0QkFDcEIsSUFBSUMsZUFBTyxFQUFROzs7OztRQUU5QixzQ0FBVzs7O1lBQVg7Z0JBQ0ksSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsQ0FBQzthQUN4Qjs7b0JBUkpDLGVBQVU7OytCQUhYOzs7Ozs7O0FDQUEsSUFHQSxxQkFBSSxRQUFRLEdBQVcsQ0FBQyxDQUFDOztRQXFCckIsaUNBQW1CLFNBQTJCO1lBQTlDLGlCQUVDO1lBRmtCLGNBQVMsR0FBVCxTQUFTLENBQWtCOzJCQVRuQix3QkFBc0IsUUFBUSxFQUFJOzZCQUM3QixJQUFJLENBQUMsT0FBTyxhQUFVOzRCQUV6QixLQUFLOzRCQUU0QixLQUFLO2tDQUV4QyxJQUFJQyxpQkFBWSxFQUFXO1lBR2xELFNBQVMsQ0FBQyxRQUFRLENBQUMsU0FBUyxD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Q0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRTtnQ0FBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDO2dDQUFDLFNBQVM7NkJBQUU7NEJBQzVHLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFO2dDQUFFLENBQUMsQ0FBQyxLQUFLLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO2dDQUFDLE1BQU07NkJBQUU7NEJBQ3RGLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRTtnQ0FBRSxDQUFDLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO2dDQUFDLE1BQU07NkJBQUU7NEJBQ3JFLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFO2dDQUFFLENBQUMsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO2dDQUFDLE1BQU07NkJBQUU7NEJBQ25FLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztnQ0FBRSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDOzRCQUN0QixDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDOzRCQUFDLFNBQVM7cUJBQzlCO29C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QUcsRUFBRTtnQkFDOUIsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUU7Z0JBQzlCLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFO2dCQUM5QixFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRTtnQkFDOUIsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUU7Z0JBQzlCLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFO2dCQUM5QixFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRTtnQkFDOUIsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQUU7Z0JBQzlCLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsRUFBRSxFQUFFO2dCQUM3QixFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLENBQUMsRUFBRTtnQkFDMUIsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtnQkFDOUIsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxDQUFDLEdBQUcsRUFBRTtnQkFDL0IsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxDQUFDLEdBQUcsRUFBRTtnQkFDL0IsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxDQUFDLEdBQUcsRUFBRTtnQkFDL0IsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxDQUFDLEdBQUcsRUFBRTtnQkFDL0IsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxDQUFDLEdBQUcsRUFBRTtnQkFDL0IsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxDQUFDLEdBQUcsRUFBRTtnQkFDL0IsRUFBRSxJQUFJLEVBQUUsT0FB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